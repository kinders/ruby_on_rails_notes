set vim: filetype=markdown 
# 赞誉、扉页、目录、致谢和介绍
## Early praise for Agile Web Development with Rails 4  上版赞誉

Agile Web Development with Rails is the Rails way to build real-world web apps—it’s definitive.
Rails itself relies on this book as a test suite.
Rails moves fast and AWDwR is always there, a backstage pass to the very latest.
➤ Jeremy Kemper
Member of the Rails core team

This is an excellent way to quickly get up and running with Ruby and Rails.
The book is so good that Sam Ruby should change his name to Sam Rails.
➤ Aaron Patterson
Member of the Ruby and Rails core teams

Like many, I started out with Ruby by reading an earlier version of Agile Web Development with Rails.
 Many years (and a few updates) later, it’s still as good a resource for learning Rails as it has ever been, and this edition brings it right up to date with Rails 4.
➤ Stephen Orr
Lead developer, Made Media

## Agile Web Development with Rails 4  扉页

Sam Ruby
Dave Thomas
David Heinemeier Hansson

The Pragmatic Bookshelf
Dallas, Texas • Raleigh, North Carolina

Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and The Pragmatic Programmers, LLC was aware of a trademark claim, the designations have been printed in initial capital letters or in all capitals.
The Pragmatic Starter Kit, The Pragmatic Programmer, Pragmatic Programming, Pragmatic Bookshelf, PragProg and the linking g device are trademarks of The Pragmatic Programmers, LLC.

Every precaution was taken in the preparation of this book.
However, the publisher assumes no responsibility for errors or omissions, or for damages that may result from the use of information (including program listings) contained herein.

Our Pragmatic courses, workshops, and other products can help you and your team create better software and have more fun.
For more information, as well as the latest Pragmatic titles, please visit us at http://pragprog.com.

The team that produced this book includes:
Susannah Pfalzer (editor)
Kim Wimpsett (copyeditor)
David J Kelly (typesetter)
Janet Furlow (producer)
Juliet Benda (rights)
Ellie Callahan (support)

Copyright © 2013 Pragmatic Programmers, LLC.
All rights reserved.

No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or otherwise, without the prior consent of the publisher.
Printed in the United States of America.
ISBN-13: 978-1-937785-56-7
Printed on acid-free paper.
Book version: P1.0—September 2013

## Contents  目录
Acknowledgments .  .  .  .  .  .  .  .  .  .  .  ix 
Introduction .  .  .  .  .  .  .  .  .  .  .  .  xi 

Part I — Getting Started
1.  Installing Rails .  .  .  .  .  .  .  .  .  .  .  3
1.1 Installing on Windows                             4
1.2 Installing on Mac OS X                            4
1.3 Installing on Linux                               6
1.4 Choosing a Rails Version                          8
1.5 Setting Up Your Development Environment           9
1.6 Rails and Databases                               12
                                               
2.  Instant Gratification .  .  .  .  .  .  . .  .    15
2.1 Creating a New Application                        15
2.2 Hello, Rails!                                     17
2.3 Linking Pages Together                            24

3.  The Architecture of Rails Applications .  . .  .  29
    3.1 Models, Views, and Controllers                29
    3.2 Rails Model Support                           32
    3.3 Action Pack: The View and Controller          34

4.  Introduction to Ruby .  .  .  .  .  .  .  .  .  .  37
4.1 Ruby Is an Object-Oriented Language                37
4.2 Data Types                                         39
4.3 Logic                                              43
4.4 Organizing Structures                              45
4.5 Marshaling Objects                                 48
4.6 Pulling It All Together                            49
4.7 Ruby Idioms                                        50

Contents • vi

Part II — Building an Application
5.  The Depot Application .  .  .  .  .  .  .  55
5.1 Incremental Development                    55
5.2 What Depot Does                            56
5.3 Let’s Code                                 60

6.  Task A: Creating the Application .  .  .  .                  61 
6.1 Iteration A1: Creating the Products Maintenance Application  61
6.2 Iteration A2: Making Prettier Listings                       68

7.  Task B: Validation and Unit Testing .  .  .  .  .  .  .  .  77
7.1 Iteration B1: Validating!                                   77
7.2 Iteration B2: Unit Testing of Models                        82

8.  Task C: Catalog Display .  .  .  .  .  .  .  .  .  .  .  . 91
8.1 Iteration C1: Creating the Catalog Listing                 91
8.2 Iteration C2: Adding a Page Layout                         96
8.3 Iteration C3: Using a Helper to Format the Price           100
8.4 Iteration C4: Functional Testing of Controllers            101
8.5 Iteration C5: Caching of Partial Results                   104

9  Task  D: Cart Creation .  .  .  .  .  .  .  .  .          107
9.1   Iteration D1: Finding a Cart                           107
9.2   Iteration D2: Connecting Products to Carts             108
9.3   Iteration D3: Adding a Button                          110

10.  Task E: A Smarter Cart .  .  .  .  .  .  .  .  .  119
10.1 Iteration E1: Creating a Smarter Cart             119
10.2 Iteration E2: Handling Errors                     124
10.3 Iteration E3: Finishing the Cart                  128

11.  Task F: Add a Dash of Ajax .  .  .  .  .  .  .  . 135 
11.1  Iteration F1: Moving the Cart                    136
11.2  Iteration F2: Creating an Ajax-Based Cart        142
11.3  Iteration F3: Highlighting Changes               146
11.4  Iteration F4: Hiding an Empty Cart               149
11.5  Iteration F5: Making Images Clickable            152
11.6  Testing Ajax Changes                             154

12.  Task G: Check Out! .  .  .  .  .   159
12.1 Iteration G1: Capturing an Order   159
12.2 Iteration G2: Atom Feeds           172

13.  Task H: Sending Mail .  .  .  .  .  .  .  .         177
13.1 Iteration H1: Sending Confirmation Emails           177
13.2 Iteration H2: Integration Testing of Applications   184

14.  Task I: Logging In .  .  .  .  .  .  .  .  .  .       191
14.1 Iteration I1: Adding Users                            191
14.2 Iteration I2: Authenticating Users                    197
14.3 Iteration I3: Limiting Access                         202
14.4 Iteration I4: Adding a Sidebar, More Administration   204

15.  Task J: Internationalization .  .  .  .             211
15.1  Iteration J1: Selecting the Locale                 211
15.2  Iteration J2: Translating the Storefront           215
15.3  Iteration J3: Translating Checkout                 222
15.4  Iteration J4: Add a Locale Switcher                229
                                                         
16.  Task K: Deployment and Production .  .  .  .  .  .       233
16.1 Iteration K1: Deploying with Phusion Passenger and MySQL 234 
16.2 Iteration K2: Deploying Remotely with Capistrano         242
16.3 Iteration K3: Checking Up on a Deployed Application      248

17.  Depot Retrospective .  .  .  .  .  .  .  .  .   253
17.1 Rails Concepts                                  253
17.2 Documenting What We Have Done                   256

18.  Finding Your Way Around Rails .  .  .  .  .  261
18.1 Where Things Go                              261
18.2 Naming Conventions                           270

19.  Active Record .  .  .  .  .  .  .  .  .  .  .     275
19.1 Defining Your Data                                275
19.2 Locating and Traversing Records                   280
19.3 Creating, Reading, Updating, and Deleting (CRUD)  284
19.4 Participating in the Monitoring Process           298
19.5 Transactions                                      304

20.  Action Dispatch and Action Controller .  .  .  .  .   309
20.1 Dispatching Requests to Controllers                   309
20.2 Processing of Requests                                319
20.3 Objects and Operations That Span Requests             330

21.  Action View .  .  .  .  .  .  .  .  .  .  .  .      341
21.1 Using Templates                                     341
21.2 Generating Forms                                    343
21.3 Processing Forms                                    346
21.4 Uploading Files to Rails Applications               348
21.5 Using Helpers                                       351
21.6 Reducing Maintenance with Layouts and Partials      358

22.  Migrations .  .  .  .  .  .  .  .  .  .             367
22.1 Creating and Running Migrations                     367
22.2 Anatomy of a Migration                              370
22.3 Managing Tables                                     375
22.4 Advanced Migrations                                 379
22.5 When Migrations Go Bad                              382
22.6 Schema Manipulation Outside Migrations              383

23.  Nonbrowser Applications .  .  .  .  .  .  .  .  .   385
23.1 A Stand-Alone Application Using Active Record       385
23.2 A Library Function Using Active Support             386

24.  Rails’ Dependencies .  .  .  .  .  .  .  .  .  .    393
24.1 Generating XML with Builder                         393
24.2 Generating HTML with ERB                            395
24.3 Managing Dependencies with Bundler                  397
24.4 Interfacing with the Web Server with Rack           400
24.5 Automating Tasks with Rake                          404
24.6 Survey of Rails’ Dependencies                       405

25.  Rails Plugins .  .  .  .  .  .  .  .  .  .  .  .    411
25.1 Credit Card Processing with Active Merchant         411
25.2 Beautifying Our Markup with Haml                    413
25.3 Pagination                                          416
25.4 Finding More at RailsPlugins.org                    418

26.  Where to Go from Here  .  .  .  .    .  .  .  .  .  421

A1. Bibliography .  .  .  .  .  .  .  .  .  .  .  .  .  423
    Index .  .  .  .  .  .  .  .  .  .  .  .  .  . 425

## Acknowledgments 致谢
Rails is constantly evolving and, as it does, so has this book.
Parts of the Depot application were rewritten several times, and all of the narrative was updated.
The avoidance of features as they become deprecated have repeatedly changed the structure of the book as what was once hot became just lukewarm.

So, this book would not exist without a massive amount of help from the Ruby and Rails communities.
To start with, we had a number of incredibly helpful formal reviewers of drafts of this book.

Jeremy Anderson

Andrea Barisone

Ken Coar

Jeff Cohen

Joel Clermont

Geoff Drake

Jeremy Frens

Pavan Gorakavi

Michael Jurewitz

Mikel Lindsaar

Nigel Lowry

Stephen Orr

Aaron Patterson

Paul Rayner

Martijn Reuvers

Doug Rhoten

Gary Sherman

Tibor Simic

Gianluigi Spagnuolo

Davanum Srinivas

Charley Stran

Federico Tomassetti

Stefan Turalski

José Valim

Additionally, each edition of this book has been released as a beta book: early versions were posted as PDFs, and people made comments online.
And comment they did; over time more than 1,000 suggestions and bug reports were posted.
The vast majority ended up being incorporated, making this book immeasurably more useful than it would have been.
While thanks go out to all for supporting the beta book program and for contributing so much valuable feedback, a number of contributors went well beyond the call of duty.

Manuel E. Vidaurre Arenas

Seth Arnold

Will Bowlin

Andy Brice

Jason Catena

Victor Marius Costan

David Hadley

Jason Holloway

David Kapp

Trung LE

Kristian Riiber Mandrup

mltsy

Steve Nicholson

Jim Puls

Johnathan Ritzi

Leonel S

Kim Shrier

Don Smith

Joe Straitiff

Martin Zoller

Finally, the Rails core team has been incredibly helpful, answering questions, checking out code fragments, and fixing bugs—even to the point where part of the release process includes verifying that new releases of Rails don’t break the examples provided in this book.1 A big “thank you” to the following:

Rafael França (rafaelfranca)

Guillermo Iguaran (guilleiguaran)

Jeremy Kemper (bitsweat)

Yehuda Katz (wycats)

Michael Koziarski (nzkoz)

Santiago Pastorino (spastorino)

Aaron Patterson

José Valim (josevalim)

Sam Ruby
rubys@intertwingly.net

August 2013

1.  https://github.com/rails/rails/blob/master/RELEASING_RAILS.rdoc#is-sam-rubyhappy--if-not-make-him-happy

## Introduction 介绍
Ruby on Rails is a framework that makes it easier to develop, deploy, and maintain web applications.
During the months that followed its initial release, Rails went from being an unknown toy to being a worldwide phenomenon; more important, it has become the framework of choice for the implementation of a wide range of so-called Web 2.0 applications.

Why is that?

Rails Simply Feels Right
A large number of developers were frustrated with the technologies they were using to create web applications.
It didn’t seem to matter whether they used Java, PHP, or .NET—there was a growing sense that their jobs were just too damn hard.
And then, suddenly, along came Rails, and Rails was easier.

But easy on its own doesn’t cut it.
We’re talking about professional developers writing real-world websites.
They wanted to feel that the applications they were developing would stand the test of time—that they were designed and implemented using modern, professional techniques.
So, these developers dug into Rails and discovered it wasn’t just a tool for hacking out sites.

For example, all Rails applications are implemented using the Model-ViewController (MVC) architecture.
Java developers are used to frameworks such as Tapestry and Struts, which are based on MVC.
But Rails takes MVC further: when you develop in Rails, you start with a working application, there’s a place for each piece of code, and all the pieces of your application interact in a standard way.

Professional programmers write tests.
And again, Rails delivers.
All Rails applications have testing support baked right in.
As you add functionality to the code, Rails automatically creates test stubs for that functionality.
The framework makes it easy to test applications, and as a result, Rails applications tend to get tested.

Rails applications are written in Ruby, a modern, object-oriented scripting language.
Ruby is concise without being unintelligibly terse—you can express ideas naturally and cleanly in Ruby code.
This leads to programs that are easy to write and (just as important) are easy to read months later.

Rails takes Ruby to the limit, extending it in novel ways that make a programmer’s life easier.
This makes our programs shorter and more readable.
It also allows us to perform tasks that would normally be done in external configuration files inside the codebase instead.
This makes it far easier to see what’s happening.
The following code defines the model class for a project.
Don’t worry about the details for now.
Instead, just think about how much information is being expressed in a few lines of code.

     class Project < ActiveRecord::Base
       belongs_to :portfolio
       has_one :project_manager
       has_many :milestones
       has_many :deliverables, through: milestones
       validates :name, :description, presence: true
       validates :non_disclosure_agreement, acceptance: true
       validates :short_name, uniqueness: true
     end

Two other philosophical underpinnings keep Rails code short and readable:
DRY and convention over configuration.
DRY stands for don’t repeat yourself.

Every piece of knowledge in a system should be expressed in just one place.
Rails uses the power of Ruby to bring that to life.
You’ll find very little duplication in a Rails application; you say what you need to say in one place—a place often suggested by the conventions of the MVC architecture—and then move on.
For programmers used to other web frameworks, where a simple change to the schema could involve a dozen or more code changes, this was a revelation.

Convention over configuration is crucial, too.
It means that Rails has sensible defaults for just about every aspect of knitting together your application.
 Follow the conventions, and you can write a Rails application using less code than a typical Java web application uses in XML configuration.
If you need to override the conventions, Rails makes that easy, too.

Developers coming to Rails found something else, too. Rails doesn’t merely play catch-up with the de facto web standards; it helps define them. And Rails makes it easy for developers to integrate features such as Ajax and RESTful interfaces into their code because support is built in. (And if you’re not familiar with Ajax and REST interfaces, never fear—we’ll explain them later in the book.)

Developers are worried about deployment too.
They found that with Rails you can deploy successive releases of your application to any number of servers with a single command (and roll them back equally easily should the release prove to be somewhat less than perfect).

Rails was extracted from a real-world, commercial application.
It turns out that the best way to create a framework is to find the central themes in a specific application and then bottle them up in a generic foundation of code.

When you’re developing your Rails application, you’re starting with half of a really good application already in place.
But there’s something else to Rails—something that’s hard to describe.

Somehow, it just feels right.
Of course, you’ll have to take our word for that until you write some Rails applications for yourself (which should be in the next forty-five minutes or so…).
That’s what this book is all about.

Rails Is Agile
The title of this book is Agile Web Development with Rails 4.
You may be surprised to discover that we don’t have explicit sections on applying agile practices X, Y, and Z to Rails coding.

The reason is both simple and subtle. Agility is part of the fabric of Rails.
Let’s look at the values expressed in the Agile Manifesto as a set of four preferences.1
1.  http://agilemanifesto.org/. Dave Thomas was one of the seventeen authors of this document.

• Individuals and interactions over processes and tools
• Working software over comprehensive documentation
• Customer collaboration over contract negotiation
• Responding to change over following a plan

Rails is all about individuals and interactions.
There are no heavy toolsets, no complex configurations, and no elaborate processes.
There are just small groups of developers, their favorite editors, and chunks of Ruby code.
This leads to transparency; what the developers do is reflected immediately in what the customer sees.
It’s an intrinsically interactive process.

Rails doesn’t denounce documentation.
Rails makes it trivially easy to create HTML documentation for your entire codebase.
But the Rails development process isn’t driven by documents.
You won’t find 500-page specifications at the heart of a Rails project.
Instead, you’ll find a group of users and developers jointly exploring their need and the possible ways of answering that need.
You’ll find solutions that change as both the developers and the users become more experienced with the problems they’re trying to solve.
You’ll find a framework that delivers working software early in the development cycle.
This software may be rough around the edges, but it lets the users start to get a glimpse of what you’ll be delivering.

In this way, Rails encourages customer collaboration.
When customers see just how quickly a Rails project can respond to change, they start to trust that the team can deliver what’s required, not just what has been requested.

Confrontations are replaced by “What if?” sessions.
That’s all tied to the idea of being able to respond to change.
The strong, almost obsessive, way that Rails honors the DRY principle means that changes to Rails applications impact a lot less code than the same changes would in other frameworks.
And since Rails applications are written in Ruby, where concepts can be expressed accurately and concisely, changes tend to be localized and easy to write.
The deep emphasis on both unit and functional testing, along with support for test fixtures and stubs during testing, gives developers the safety net they need when making those changes.
With a good set of tests in place, changes are less nerve-racking.

Rather than constantly trying to tie Rails processes to the agile principles, we’ve decided to let the framework speak for itself.
As you read through the tutorial chapters, try to imagine yourself developing web applications this way, working alongside your customers and jointly determining priorities and solutions to problems.
Then, as you read the more advanced concepts that follow in Part III, see how the underlying structure of Rails can enable you to meet your customers’ needs faster and with less ceremony.

One last point about agility and Rails is that although it’s probably unprofessional to mention this, think how much fun the coding will be!

Who This Book Is For
This book is for programmers looking to build and deploy web-based applications.
This includes application programmers who are new to Rails (and perhaps even new to Ruby) and ones who are familiar with the basics but want a more in-depth understanding of Rails.

We presume some familiarity with HTML, Cascading Style Sheets (CSS), and JavaScript, in other words, the ability to view source on web pages.
You need not be an expert on these subjects; the most you will be expected to do is to copy and paste material from the book, all of which can be downloaded.

How to Read This Book
The first part of this book makes sure you are ready.
By the time you are done with it, you will have been introduced to Ruby (the language), you will have been exposed to an overview of Rails, you will have Ruby and Rails installed, and you will have verified the installation with a simple example.

The next part takes you through the concepts behind Rails via an extended example; we build a simple online store.
It doesn’t take you one by one through each component of Rails (“here is a chapter on models, here is a chapter on views,” and so forth).
These components are designed to work together, and each chapter in this section tackles a specific set of related tasks that involve a number of these components working together.

Most folks seem to enjoy building the application along with the book.
If you don’t want to do all that typing, you can cheat and download the source code (a compressed tar archive or a zip file).2 
2.  http://pragprog.com/titles/rails4/source_code has the links for the downloads.
This download contains separate sets of source code for Rails 3.0, Rails 3.1, Rails 3.2, and Rails 4.0.

As you will be using Rails 4.0, the files you want are in the rails40 directory.
See the READMEFIRST file for more details.

Be careful if you ever choose to copy files directly from the download into your application, as the server won’t know that it needs to pick up these changes if the timestamps on the file are old.
You can update the timestamps using the touch command on either Mac OS X or Linux, or you can edit the file and save it.
Alternately, you can restart your Rails server.

Part III, Rails in Depth, on page 259 surveys the entire Rails ecosystem.
This starts with the functions and facilities of Rails that you will now be familiar with.
It then covers a number of key dependencies that the Rails framework makes use of that contribute directly to the overall functionality that the Rails framework delivers.
Finally, there is a survey of a number of popular plugins that augment the Rails framework and make Rails an open ecosystem rather than merely a framework.

Along the way, you’ll see various conventions we’ve adopted.

Ruby Tips
Although you need to know Ruby to write Rails applications, we realize that many folks reading this book will be learning both Ruby and Rails at the same time. You will find a (very) brief introduction to the Ruby language in Chapter 4, Introduction to Ruby, on page 37. When we use a Ruby-specific construct for the first time, we’ll cross-reference it to that chapter.

For example, this paragraph contains a gratuitous use of :name, a Ruby
symbol. In formats that support margins, you’ll see a reference to where
symbols are explained.
:name ↪ on page 38

Live Code
Most of the code snippets we show come from full-length, running examples that you can download.
To help you find your way, if a code listing can be found in the download,
there’ll be a bar before the snippet (just like the one here).

     Download rails40/demo1/app/controllers/say_controller.rb
     class SayController < ApplicationController
     ➤ def hello
     ➤ end
       def goodbye
       end
     end

This contains the path to the code within the download.
If you’re reading the ebook version of this book and your ebook viewer supports hyperlinks, you can click the bar, and the code should appear in a browser window.

Some browsers may mistakenly try to interpret some of the HTML templates as HTML.
If this happens, view the source of the page to see the real source code.

And in some cases involving the modification of an existing file where the lines to be changed may not be immediately obvious, you will also see some helpful little triangles on the left of the lines that you will need to change.
Two such lines are indicated in the previous code.

David Says…
Every now and then you’ll come across a “David Says…” sidebar.
Here’s where David Heinemeier Hansson gives you the real scoop on some particular aspect of Rails—rationales, tricks, recommendations, and more.
Because he’s the fellow who invented Rails, these are the sections to read
if you want to become a Rails pro.

Joe Asks…
Joe, the mythical developer, sometimes pops up to ask questions about stuff we talk about in the text.
We answer these questions as we go along.

This book isn’t meant to be a reference manual for Rails.
Our experience is that reference manuals are not the way most people learn.
Instead, we show most of the modules and many of their methods, either by example or narratively in the text, in the context of how these components are used and how they fit together.

Nor do we have hundreds of pages of API listings.
There’s a good reason for this—you get that documentation whenever you install Rails, and it’s guaranteed to be more up-to-date than the material in this book.
If you install Rails using RubyGems (which we recommend), simply start the gem documentation server (using the command gem server), and you can access all the Rails APIs by pointing your browser at http://localhost:8808.
You will find out in A Place for Documentation, on page 265 how to build even more documentation and guides.

In addition, you will see that Rails helps you by producing responses that clearly identify any error found, as well as traces that tell you not only the point at which the error was found but also how you got there.
You can see an example in Figure 25, Our application spills its guts., on page 124.
If you need additional information, peek ahead to Section 10.2, Iteration E2: Handling Errors, on page 124 to see how to insert logging statements.

Should you get really stuck, there are plenty of online resources to help.
In addition to the code listings mentioned, there is a forum,3 where you can ask questions and share experiences; an errata page,4 where you can report bugs; and a wiki,5 where you can discuss the exercises found throughout the book.

These resources are shared resources.
Feel free to post not only questions and problems to the forum and wiki but also any suggestions and answers you may have to questions that others may have posted.

Let’s get started! The first steps are to install Ruby and Rails and to verify
the installation with a simple demonstration.

3. http://forums.pragprog.com/forums/148
4. http://www.pragprog.com/titles/rails4/errata
5. http://www.pragprog.com/wikis/wiki/RailsPlayTime


# Part I Getting Started  起步
# CHAPTER 1  Installing Rails

In this chapter, we’ll see
• installing Ruby, RubyGems, SQLite3, and Rails; and
• development environments and tools.

In Part I of this book, we’ll introduce you to both the Ruby language and the Rails framework.
But we can’t get anywhere until you’ve installed both and verified that they are operating correctly.

To get Rails running on your system, you’ll need the following:

• A Ruby interpreter.
Rails is written in Ruby, and you’ll be writing your applications in Ruby too.
Rails 4.0 recommends Ruby version 2.0.0 but will run on 1.9.3.
It will not work on Ruby versions 1.8.7 or Ruby 1.9.2.

• Ruby on Rails. This book was written using Rails version 4.0 (specifically Rails 4.0.0).

• A JavaScript interpreter.
Both Microsoft Windows and Mac OS X have JavaScript interpreters built in, and Rails will use the version already on your system.
On other operating systems, you may need to install a JavaScript interpreter separately.

• Some libraries, depending on the operating system.

• A database.
We’re using both SQLite 3 and MySQL 5.5 in this book.
 For a development machine, that’s about all you’ll need (apart from an editor, and we’ll talk about editors separately).
However, if you are going to deploy your application, you will also need to install a production web server (as a minimum) along with some support code to let Rails run efficiently.
We have a whole chapter devoted to this, starting in Chapter 16, Task K: Deployment and Production, on page 233, so we won’t talk about it more here.

So, how do you get all this installed? It depends on your operating system....

• 4

## 1.1 Installing on Windows
The easiest way to install Rails on Windows is by using the RailsInstaller1 package.
At the time of this writing, the latest version of RailsInstaller is version 2.2.1, which includes Ruby 1.9.3 and Rails 3.2.
Until a new version is released that supports Rails 4.0.0 or Ruby 2.0, feel free to use version 2.1 of RailsInstaller to get you started.

Base installation is a snap.
After you download, click Run and then click Next.
Select “I accept all of the Licenses” (after reading them carefully of course) and then click Next, Install, and Finish.

This opens a command window and prompts you for your name and email.
This is only to set up the git version control system.
For the purposes of the exercises in this book, you won’t need to worry about the ssh key that is generated.

Close this window and open a new command prompt.
On Windows 8, type cmd on the tile-based Start screen and press Enter.
On versions of Windows prior to Windows 8, select Windows Start, select Run..., enter cmd, and click OK.

Windows 8 users need to perform the additional step of installing node.js.2 Once this is complete, close the command window and open a new one for the changes to %PATH% to take effect.
Verify that the installation is correct by entering the command node -v.

If you have trouble, try looking for suggestions on the Troubleshooting page on the RubyInstaller site.3
As long as the version of RailsInstaller you used installed a version of Ruby that is 1.9.3 or greater, there is no need to upgrade to a newer version of Ruby.
Please skip to Section 1.4, Choosing a Rails Version, on page 8 to ensure that the version of Rails you have installed matches the version described in this edition.
See you there.

1.http://railsinstaller.org/                                     
2.http://nodejs.org/download/
3.https://github.com/oneclick/rubyinstaller/wiki/Troubleshooting

• 5
## 1.2 Installing on Mac OS X
Since Mac OS X ships with Ruby 1.8.7, you’ll need to download a newer version of Ruby that works with Rails 4.0.
The easiest way to do this is to use RailsInstaller, which at the time of this writing installs Ruby 1.9.3.
A second way to do this is to use the newest development version of RVM, which you can use to install Ruby 2.0.0.
Ruby 2.0 is what the Rails core team recommends and is noticeably faster than Ruby 1.9.3, but either can be used with this book.
Both approaches are described here.
The choice is up to you.

Before you start, go to your Utilities folder and drag the Terminal application onto your dock.
You’ll be using this during the installation and then frequently as a Rails developer.

Installing via RailsInstaller
Start by going to the RailsInstaller4 and clicking the big green Download the
Kit button.
Once the download is complete, double-click the file to uncompress it.
Before clicking the app file that is produced, hold down the Control key.
Select the “open” option.
Opening the app in this way gives you the option to install a program from a developer who isn’t known to the app store.
From here there are a few questions (such as your name, which will be used to configure git), and installation will proceed.

Now open the Terminal application, and at the prompt enter the following command:
$ ruby -v

You should see the following result:
ruby 1.9.3p392 (2013-02-22 revision 39386) [x86_64-darwin11.4.0]

Next, update Rails to the version used by this book with the following command:
$ gem install rails --version 4.0.0 --no-ri --no-rdoc

You’re ready to go! Skip forward to join the Windows users in Section 1.4, Choosing a Rails Version, on page 8.

Installing Using RVM
First, download and install the latest (January 2013) Command Line Tools for Xcode for your operating system (OS X Lion or OS X Mountain Lion) using the "Downloads" preference pane within XCode.

Now open the Terminal application, and at the prompt enter the following command to install the development version of RVM:

4.  http://railsinstaller.org/

• 6

$ curl -L https://get.rvm.io | bash -s stable

Check for, and follow, any upgrade notes in the output from that command.
Once you complete those instructions, you can proceed to install the Ruby interpreter.
$ rvm install 2.0.0 --autolibs=enable

The preceding step will take a while as it downloads, configures, and compiles the necessary executables.
Once it completes, use that environment, and install rails.

$ rvm use 2.0.0
$ gem install rails --version 4.0.0 --no-ri --no-rdoc

With the exception of the rvm use statement, each of the previous instructions needs to be done only once.
The rvm use statement needs to be repeated each time you open a shell window.
The use keyword is optional, so you can abbreviate this to rvm 2.0.0.
You can also choose to make it the default Ruby interpreter for new terminal sessions with the following command: 
$ rvm --default 2.0.0 

You can verify successful installation using the following command: 
$ rails -v 

If you have trouble, try the suggestions listed under the “Troubleshooting Your Install” heading on the rvm site.5 OK, you OS X users are done.
You can skip forward to join the Windows users in Section 1.4, Choosing a Rails Version, on page 8.
See you there.

## 1.3 Installing on Linux
Start with your platform’s native package management system, be it apt-get, dpkg, portage, rpm, rug, synaptic, up2date, or yum.

The first step is to install the necessary dependencies.
The following instructions are for Ubuntu 13.04 (Raring Ringtail); if you’re on a different operating system, you may need to adjust both the command and the package names.

$ sudo apt-get install apache2 curl git libmysqlclient-dev mysql-server nodejs

You’ll be prompted for a root password for your mysql server.
If you leave it blank, you’ll be prompted multiple times.
If you specify a password, you’ll need to use that password when you create a database in Iteration K1 on page 239.

5.  https://rvm.io/rvm/install

• 7

While the Rails core team recommends Ruby 2.0 for use with Rails 4.0, if you want to use a system-installed version of Ruby, you can use Ruby 1.9.3.
This will get you up and running quickly.

Starting with Ubuntu 12.04, you can install Ruby 1.9.3 and Rails 4.0 with
the following commands:
$ sudo apt-get install ruby1.9.3
$ sudo gem install rails --version 4.0.0 --no-ri --no-rdoc

If this works for you, you are done with the necessary installation steps and can proceed to Section 1.4, Choosing a Rails Version, on page 8.

Many people prefer instead to have a separate installation of Ruby on their machine dedicated to support their application, and therefore they choose to download and build Ruby.
The easiest way we’ve found to do this is to use RVM.
Installing RVM is described on the RVM site.6 
6. https://rvm.io/rvm/install
An overview of the steps is included here.

First, install RVM.
$ curl -L https://get.rvm.io | bash -s stable

Next, select the “Run command as login shell” checkbox in the Gnome Terminal Profile Preference.
Refer to the Integrating RVM with gnome-terminal page for instructions.7
7. https://rvm.io/integration/gnome-terminal/ 
Exit your command window or Terminal application and open a new one.
This causes your .bash_login to be reloaded.
Execute the following command, which installs the necessary prerequisites needed for your specific operating system:
$ rvm requirements --autolibs=enable

Once this is complete, you can proceed to install the Ruby interpreter.
$ rvm install 2.0.0

This step will take a while as it downloads, configures, and compiles the necessary executables.
Once it completes, use that environment, and install rails.

$ rvm use 2.0.0
$ gem install rails --version 4.0.0 --no-ri --no-rdoc

With the exception of the rvm use statement, each of the previous instructions needs to be done only once.
• 8
The rvm use statement needs to be repeated each time you open a shell window.
The use keyword is optional, so you can abbreviate this to rvm 2.0.0.
You can also choose to make it the default Ruby interpreter for new Terminal sessions with the following command: 
$ rvm --default 2.0.0 
You can verify successful installation using the following command: 
$ rails -v 
If you have trouble, try the suggestions listed under the “Troubleshooting Your Install” heading on the RVM site.8 
8.  https://rvm.io/rvm/install

At this point, we’ve covered Windows, Mac OS X, and Linux.
Instructions after this point are common to all three operating systems.


## 1.4 Choosing a Rails Version 选择一个Rails发行版
The previous instructions helped you install the version of Rails used in the examples by this book.
前面的指令介绍了如何安装最新版本的Rails。
But occasionally you might not want to run that version.
但有时，你可能并不想使用最新版本。
For example, there may be a newer version with some fixes or new features.
比如，可能在本书出版的时候已经有了新版本的Rails。
而你想确信书中的例子和你的运行结果完全吻合；
Or perhaps you are developing on one machine but intending to deploy on another machine that contains a version of Rails that you don’t have any control over.
还可能你在一台机器上进行开发，但要把应用程序部署到另一台已经有Rails的机器上，而你没有权限去更改它的版本。

If either of these situations applies to you, you need to be aware of a few things.
如果你正好处于这两种情况之一，那么首先需要了解几件事情。
For starters, you can find out all the versions of Rails you have installed using the gem command.
第一，可以使用gem命令查看所有已经安装的Rails版本。

     $ gem list --local rails

You can also verify what version of Rails you are running as the default by using the rails --version command.
也可以使用`rails --version`命令来查看哪一个版本的Rails是默认运行。
It should return 4.0.0.
它应该返回4.0.0。

<kinder:note> 下面这一段是4版内容，这一版被删除。补录在此，以供参考。
也可以使用gem命令来安装不同版本的Rails。根据操作系统的不同，可能需要在gem命令前面加上sudo。

    $ gem install rails --version 3.0.5

If it does not, insert the version of Rails surrounded by underscores before the first parameter of any rails command. 
如果不是，可以在rails命令和第一个参数之间，通过添加一个用下划线包围着的完整的版本号来选择需要运行的Rails版本。
Here’s an example:
比如：

     $ rails _4.0.0_ --version

This is particularly handy when you create a new application, because once you create an application with a specific version of Rails, it will continue to use that version of Rails—even if newer versions are installed on the system—until you decide it is time to upgrade.
这种方法在创建新的Rails程序时特别方便，因为一旦用一个特定Rails版本创建应用程序后，它就会一直使用该版本的Rails--即使系统里又安装了更新版本的Rails--直到你决定升级。

To upgrade, simply update the version number in the Gemfile that is in the root directory of your application and run bundle install.
升级时，只需要修改在应用程序的根目录里Gemfile的版本号，在运行bundle
install即可。
We will cover this command in greater depth in Section 24.3, Managing Dependencies with Bundler, on page 397.
24.3节将会介绍这条命令。

• 9

## 1.5 Setting Up Your Development Environment

The day-to-day business of writing Rails programs is pretty straightforward.
Everyone works differently; here’s how we work.

The Command Line
We do a lot of work at the command line.
Although there are an increasing number of GUI tools that help generate and manage a Rails application, we find the command line is still the most powerful place to be.
It’s worth spending a little while getting familiar with the command line on your operating system.
Find out how to use it to edit commands that you’re typing, how to search for and edit previous commands, and how to complete the names of files and commands as you type.

So-called tab completion is standard on Unix shells such as Bash and zsh.
It allows you to type the first few characters of a filename, hit Tab , and have the shell look for and complete the name based on matching files.

Version Control
We keep all our work in a version control system (currently Git).
We make a point of checking a new Rails project into Git when we create it and committing changes once we have passed the tests.
We normally commit to the repository many times an hour.

If you’re working on a Rails project with other people, consider setting up a continuous integration (CI) system.
When anyone checks in changes, the CI system will check out a fresh copy of the application and run all the tests.

It’s a simple way to ensure that accidental breakages get immediate attention.

You can also set up your CI system so that your customers can use it to play with the bleeding-edge version of your application.
This kind of transparency is a great way of ensuring that your project isn’t going off the tracks.

Editors
We write our Rails programs using a programmer’s editor.
We’ve found over the years that different editors work best with different languages and environments.
For example, Dave originally wrote this chapter using Emacs because he thinks that its Filladapt mode is unsurpassed when it comes to neatly formatting XML as he types.
Sam updated the chapter using Vim.
But many think that neither Emacs nor Vim is ideal for Rails development.

Although the choice of editor is a personal one, here are some suggestions of features to look for in a Rails editor:


• 10

• Support for syntax highlighting of Ruby and HTML. Ideally support for .erb files (a Rails file format that embeds Ruby snippets within HTML).
• Support of automatic indentation and reindentation of Ruby source.
This is more than an aesthetic feature: having an editor indent your program as you type is the best way of spotting bad nesting in your code.
Being able to reindent is important when you refactor your code and move stuff.
(TextMate’s ability to reindent when it pastes code from the clipboard is very convenient.)

• Support for insertion of common Ruby and Rails constructs.
You’ll be writing lots of short methods, and if the IDE creates method skeletons with a keystroke or two, you can concentrate on the interesting stuff inside.

• Good file navigation.
As you’ll see, Rails applications are spread across many files; for example, a newly created Rails application enters the world containing forty-six files spread across thirty-four directories.
That’s before you’ve written a thing.

You need an environment that helps you navigate quickly between these.
You’ll add a line to a controller to load a value, switch to the view to add
a line to display it, and then switch to the test to verify you did it all right.
Something like Notepad, where you traverse a File Open dialog box to select each file to edit, just won’t cut it.
We prefer a combination of a tree view of files in a sidebar, a small set of keystrokes that help us find a file (or files) in a directory tree by name, and some built-in smarts that know how to navigate (say) between a controller action and the corresponding view.

• Name completion.
Names in Rails tend to be long.
A nice editor will let you type the first few characters and then suggest possible completions to you at the touch of a key.

We hesitate to recommend specific editors because we’ve used only a few in earnest and we’ll undoubtedly leave someone’s favorite editor off the list.

Nevertheless, to help you get started with something other than Notepad, here are some suggestions:

• TextMate was once the Mac OS X de facto standard text editor for Ruby on Rails.9

9.  http://macromates.com/

• 11

• Sublime Text10 is a cross-platform alternative that some see as the de facto successor for TextMate.
• Aptana Studio 311 is an integrated Rails development environment that runs in Eclipse.
It runs on Windows, Mac OS X, and Linux.
Originally known as RadRails, it won an award for being the best open source developer tool based on Eclipse in 2006, and Aptana became the home for the project in 2007.

• jEdit12 is a fully featured editor with support for Ruby.
It has extensive plugin support.

• Komodo13 is ActiveState’s IDE for dynamic languages, including Ruby.

• RubyMine14 is a commercial IDE for Ruby and is available for free to qualified educational and open source projects.
It runs on Windows, Mac OS X, and Linux.

• NetBeans Ruby and Rails plugin 15 is an open source plugin for the popular NetBeans IDE.

Ask experienced developers who use your kind of operating system which editor they use.
Spend a week or so trying alternatives before settling in.


The Desktop
We’re not going to tell you how to organize your desktop while working with Rails, but we will describe what we do.
Most of the time, we’re writing code, running tests, and poking at an application in a browser.
So, our main development desktop has an editor window and a browser window permanently open.
We also want to keep an eye on the logging that’s generated by the application, so we keep a terminal window open.
In it, we use tail -f to scroll the contents of the log file as it’s updated.

We normally run this window with a very small font so it takes up less space—if we see something interesting flash by, we zoom it up to investigate.

We also need access to the Rails API documentation, which we view in a browser.
In the introduction, we talked about using the gem server command to run a local web server containing the Rails documentation.
This is convenient, but it unfortunately splits the Rails documentation across a number of separate documentation trees.
If you’re online, you can use http://api.rubyonrails.org/ to see a consolidated view of all the Rails documentation in one place.

10. http://www.sublimetext.com/
11. http://www.aptana.com/products/studio3
12. http://www.jedit.org/
13. http://www.activestate.com/komodo-ide
14. http://www.jetbrains.com/ruby/features/index.html
15. http://plugins.netbeans.org/plugin/38549

• 12

Where’s My IDE?
If you’re coming to Ruby and Rails from languages such as C# and Java, you may be wondering about IDEs.
After all, we all know that it’s impossible to code modern applications without at least 100MB of IDE supporting our every keystroke.
For you enlightened ones, here’s the point in the book where we recommend you sit down—ideally propped up on each side by a pile of framework references and 1,000page Made Easy books.

It may surprise you to know that most Rails developers don’t use fully fledged IDEs for Ruby or Rails (although some of the environments come close).
Indeed, many Rails developers use plain old editors.
And it turns out that this isn’t as much of a problem as you might think.
With other, less expressive languages, programmers rely on IDEs to do much of the grunt work for them, because IDEs do code generation, assist with navigation, and compile incrementally to give early warning of errors.

With Ruby, however, much of this support just isn’t necessary.
Editors such as TextMate and BBEdit give you 90 percent of what you’d get from an IDE but are far lighter weight.
Just about the only useful IDE facility that’s missing is refactoring support.

## 1.6 Rails and Databases
The examples in this book were written using SQLite 3 (version 3.7.4 or thereabouts).
If you want to follow along with our code, it’s probably simplest if you use SQLite 3 too.
If you decide to use something else, it won’t be a major problem.

You may have to make minor adjustments to any explicit SQL in our code, but
Rails pretty much eliminates database-specific SQL from applications.

If you want to connect to a database other than SQLite 3, Rails also works with DB2, MySQL, Oracle, Postgres, Firebird, and SQL Server.
For all but SQLite 3, you’ll need to install a database driver, a library that Rails can use to connect to and use your database engine.
This section contains links to instructions to get that done.

The database drivers are all written in C and are primarily distributed in source form.
If you don’t want to bother building a driver from source, take a careful look at the driver’s website.
Many times you’ll find that the author also distributes binary versions.

• 13

Creating Your Own Rails API Documentation
You can create your own local version of the consolidated Rails API documentation.
Just type the following commands at a command prompt:

     rails_apps> rails new dummy_app
     rails_apps> cd dummy_app
     dummy_app> rake doc:rails

The last step takes a while.
When it finishes, you’ll have the Rails API documentation in a directory tree starting at doc/api.
We suggest moving this folder to your desktop and then deleting the dummy_app tree.

To view the Rails API documentation, open the location doc/api/index.html with your browser.

If you can’t find a binary version or if you’d rather build from source anyway, you’ll need a development environment on your machine to build the library.

Under Windows, this means having a copy of Visual C++.

Under Linux, you’ll need gcc and friends (but these will likely already be installed).

Under OS X, you’ll need to install the developer tools (they come with the operating system but aren’t installed by default).
You’ll also need to install your database driver into the correct version of Ruby.
If you installed your own copy of Ruby, bypassing the built-in one, it is important to remember to have this version of Ruby first in your path when building and installing the database driver.
You can use the command which ruby to make sure you’re not running Ruby from /usr/bin.

The following are the available database adapters and the links to their respective home pages:

DB2

http://raa.ruby-lang.org/project/ruby-db2
or http://rubyforge.org/projects/rubyibm

Firebird

http://rubyforge.org/projects/fireruby/

MySQL

http://www.tmtm.org/en/mysql/ruby/

Oracle

http://rubyforge.org/projects/ruby-oci8

Postgres

https://bitbucket.org/ged/ruby-pg/wiki/Home

SQL Server

https://github.com/rails-sqlserver

SQLite

https://github.com/luislavena/sqlite3-ruby

MySQL and SQLite adapters are also available for download as RubyGems
(mysql2 and sqlite3, respectively).


• 14

What We Just Did
• We installed (or upgraded) the Ruby language.
• We installed (or upgraded) the Rails framework.
• We installed (or upgraded) the SQLite3 and MySQL databases.
• We selected an editor.

Now that we have Rails installed, let’s use it.
It’s time to move on to the next chapter where we create our first application.

# CHAPTER 2 Instant Gratification  即时满足

In this chapter, we’ll see
在本章中，我们将学习
• creating a new application,
创建一个新的应用程序
• starting the server,
启动服务器
• accessing the server from a browser,
通过浏览器来访问服务器
• producing dynamic content,
创建动态的网页内容
• adding hypertext links, and
添加超链接
• passing data from the controller to the view.
把数据从控制器传送到视图。

Let’s write a simple application to verify we have Rails snugly installed on our machines.
Along the way, we’ll get a peek at the way Rails applications work.

## 2.1 Creating a New Application 新建一个应用程序
When you install the Rails framework, you also get a new command-line tool, rails, that is used to construct each new Rails application you write.
安装了Rails框架之后，你同时也得到了一个新的命令行工具：Rails，这个工具可以用于创建你编写的每个新Rails应用程序。
Why do we need a tool to do this? Why can’t we just hack away in our favorite editor and create the source for our application from scratch? 
为什么我们需要这个工具，而不直接使用编辑器从头开始编写应用程序呢？
Well, we could just hack.
我们当然可以这样做。
After all, a Rails application is just Ruby source code.
不管怎么说，Rails程序只是由Ruby源代码组成的。
But Rails also does a lot of magic behind the curtain to get our applications to work with a minimum of explicit configuration.
然而通过一个Rails命令行，Rials可以在幕后做许多事情，让我们只需要做最少量的配置即可运行一个应用程序。
To get this magic to work, Rails needs to find all the various components of your application.
为了让这些幕后工作生效，Rails必须能够找到应用程序中所需的各种组件。
As we’ll see later (in Section 18.1, Where Things Go, on page 261), this means we need to create a specific directory structure, slotting the code we write into the appropriate places.
正如我们稍后将会看到的，为了实现这个功能，在创建Rails应用程序时，还需要创建某种固定的目录结构，以此将代码放在合适的目录下。
The rails command simply creates this directory structure for us and populates it with some standard Rails code.
Rails命令可以帮助我们创建这一目录结构，并且生成一些标准的Rails代码。

To create your first Rails application, pop open a shell window, and navigate to a place in your filesystem where you want to create your application’s directory structure.
In our example, we’ll be creating our projects in a directory called work.
In that directory, use the rails command to create an application called demo.
Be slightly careful here—if you have an existing directory called demo, you will be asked whether you want to overwrite any existing files.
(Note: if you want to specify which Rails version to use, as described in Section 1.4, Choosing a Rails Version, on page 8, now would be the time to do so.)

• 16

     rubys> cd work
     work> rails new demo
     create
     create README.rdoc
     create Rakefile
     create config.ru
     : : :
     create vendor/assets/stylesheets
     create vendor/assets/stylesheets/.keep
     run bundle install
     Fetching gem metadata from https://rubygems.org/...........
     : : :
     Your bundle is complete!
     Use `bundle show [gemname]` to see where a bundled gem is installed.
     work>

The command has created a directory named demo.
Pop down into that directory, and list its contents (using ls on a Unix box or using dir under Windows).
You should see a bunch of files and subdirectories.

     work> cd demo
     demo> ls -p
     app/  config/   db/     Gemfile.lock  log/    Rakefile    test/ vendor/ 
     bin/  config.ru Gemfile lib/          public/ README.rdoc tmp/

All these directories (and the files they contain) can be intimidating to start with, but we can ignore most of them for now.
In this chapter, we’ll use only one of them directly: the app directory, where we’ll write our application.
<kinder:note> 在这一章，我们只直接使用其中一个： app目录，我们把程序写在那里。

Examine your installation using the following command:
<kinder:note> 使用下面的命令来检测你的安装：

     demo> rake about

If you get a Rails version other than 4.0.0, please reread Section 1.4, Choosing a Rails Version, on page 8.
<kinder:note> 如果你得到的版本号不是4.0.0，请重读前面第8页1.4节《选择一个Rails版本》。
This command will also detect common installation errors. 
<kinder:note> 这个命令也会检测常见的安装错误。
For example, if it can’t find a JavaScript runtime, it will provide you with a link to available runtimes.
<kinder:note> 比如，如果你不能找到一个JavaScript运行时，它会给你提供一个可用运行时的链接。
If you see a bunch of messages concerning already initialized constants or a possible conflict with an extension, consider deleting the demo directory, creating a separate RVM gemset,1 and starting over.
1. https://rvm.io/gemsets/basics/
<kinder:note> 如果你一堆关于已经初始化常数或可能和扩展冲突的信息，可以考虑删除demo文件夹，新建一个独立的RVM gemset, 然后重新开始。
If that doesn’t work, use bundle exec to run rake commands.  2
<kinder:note> 如果这样还不能运行，使用bundle exec来运行rake命令。
2. http://gembundler.com/v1.3/bundle_exec.html

Once you get rake about working, you have everything you need to start a standalone web server that can run our newly created Rails application.
So, without further ado, let’s start our demo application.


• 17

     demo> rails server
     => Booting WEBrick
     => Rails 4.0.0 application starting in development on http://0.0.0.0:3000
     => Run `rails server -h` for more startup options
     => Ctrl-C to shutdown server
     [2013-04-18 20:22:16] INFO WEBrick 1.3.1
     [2013-04-18 20:22:16] INFO ruby 2.0.0 (2013-02-24) [x86_64-linux]
     [2013-04-18 20:22:16] INFO WEBrick::HTTPServer#start: pid=25170 port=3000

Which web server is run depends on what servers you have installed.
WEBrick is a pure-Ruby web server that is distributed with Ruby itself and therefore is guaranteed to be available.
However, if another web server is installed on your system (and Rails can find it), the rails server command may use it in preference to WEBrick.
You can force Rails to use WEBrick by providing an option to the rails command.

     demo> rails server webrick

As the last line of the startup tracing indicates, we just started a web server on port 3000.
The 0.0.0.0 part of the address means that WEBrick will accept connections on all interfaces.
On Dave’s OS X system, that means both local interfaces (127.0.0.1 and ::1) and his LAN connection.
We can access the application by pointing a browser at the URL http://localhost:3000.
The result is shown in Figure 1, Newly created Rails application, on page 18.

If you look at the window where you started the server, you’ll see tracing showing you started the application.
We’re going to leave the server running in this console window.
Later, as we write application code and run it via our browser, we’ll be able to use this console window to trace the incoming requests.
When the time comes to shut down your application, you can press Ctrl-C in this window to stop WEBrick.
(Don’t do that yet—we’ll be using this particular application in a minute.) At this point, we have a new application running, but it has none of our code in it.
Let’s rectify this situation.


## 2.2 Hello, Rails!  Rails，你好！
We can’t help it—we just have to write a “Hello, World!” program to try a new system.
Let’s start by creating a simple application that sends our cheery greeting to a browser.
After we get that working, we will embellish it with the current time and links.

As we’ll explore further in Chapter 3, The Architecture of Rails Applications, on page 29, Rails is a Model-View-Controller framework.
Rails accepts incoming requests from a browser, decodes the request to find a controller, and calls an action method in that controller.

• 18 Figure 1—Newly created Rails application 

The controller then invokes a particular view to display the results to the user.
The good news is that Rails takes care of most of the internal plumbing that links all these actions.
To write our simple “Hello, World!” application, we need code for a controller and a view, and we need a route to connect the two.
We don’t need code for a model, because we’re not dealing with any data.
Let’s start with the controller.

In the same way that we used the rails command to create a new Rails application, we can also use a generator script to create a new controller for our project.
This command is called rails generate.
So, to create a controller called say, we make sure we’re in the demo directory and run the command, passing in the name of the controller we want to create and the names of the actions we intend for this controller to support.

• 19

     demo> rails generate controller Say hello goodbye
     create app/controllers/say_controller.rb
     route get "say/goodbye"
     route get "say/hello"
     invoke erb
     create
     app/views/say
     create
     app/views/say/hello.html.erb
     create
     app/views/say/goodbye.html.erb
     invoke test_unit
     create
     test/controllers/say_controller_test.rb
     invoke helper
     create
     app/helpers/say_helper.rb
     invoke
     test_unit
     create
     test/helpers/say_helper_test.rb
     invoke assets
     coffee
     invoke
     create
     app/assets/javascripts/say.js.coffee
     invoke
     scss
     create
     app/assets/stylesheets/say.css.scss


The rails generate command logs the files and directories it examines, noting when it adds new Ruby scripts or directories to your application.
For now, we’re interested in one of these scripts and (in a minute) the .html.erb files.

The first source file we’ll be looking at is the controller.
You’ll find it in the file app/controllers/say_controller.rb.
Let’s take a look at it:

     Download rails40/demo1/app/controllers/say_controller.rb
     class SayController < ApplicationController
       def hello
       end
       def goodbye
       end
     end

     defining classes ↪ on page 45
     
Pretty minimal, eh? 
SayController is a class that inherits from ApplicationController, so it automatically gets all the default controller behavior.
What does this code have to do? 
For now, it does nothing—we simply have empty action methods named hello() and goodbye().
To understand why these methods are named this way, we need to look at the way Rails handles requests.

### 2.2.1 Rails and Request URLs     Rails和URL请求
Like any other web application, a Rails application appears to its users to be associated with a URL.
When you point your browser at that URL, you are talking to the application code, which generates a response to you.

• 20

Let’s try it now.
Navigate to the URL `http://localhost:3000/say/hello` in a browser.
You’ll see something that looks like this:

### 2.2.2 Our First Action   第一个动作
At this point, we can see not only that we have connected the URL to our controller but also that Rails is pointing the way to our next step, namely, to tell Rails what to display.
That’s where views come in.
Remember when we ran the script to create the new controller? That command added several files and a new directory to our application.
That directory contains the template files for the controller’s views.
In our case, we created a controller named say, so the views will be in the directory app/views/say.

By default, Rails looks for templates in a file with the same name as the action it’s handling.
In our case, that means we need to replace a file called hello.html.erb in the directory app/views/say.
(Why .html.erb? We’ll explain in a minute.) 
For now, let’s just put some basic HTML in there.

     Download rails40/demo1/app/views/say/hello.html.erb
     <h1>Hello from Rails!</h1>

Save the file hello.html.erb, and refresh your browser window.
You should see it display our friendly greeting.

In total, we’ve looked at two files in our Rails application tree.
We looked at the controller, and we modified a template to display a page in the browser.

• 21

These files live in standard locations in the Rails hierarchy: controllers go into app/controllers, and views go into subdirectories of app/views.
See the following figure:

Figure 2—Standard locations for controllers and views

### 2.2.3 Making It Dynamic 创建动态网页
So far, our Rails application is pretty boring—it just displays a static page.
To make it more dynamic, let’s have it show the current time each time it displays the page.
To do this, we need to change the template file in the view—it now needs to include the time as a string.
That raises two questions.
First, how do we add dynamic content to a template?
Second, where do we get the time from?

### 2.2.4 Dynamic Content 动态内容
There are many ways of creating dynamic templates in Rails.
The most common way, which we’ll use here, is to embed Ruby code in the template.
That’s why we named our template file hello.html.erb; the .html.erb suffix tells Rails to expand the content in the file using a system called ERB.

ERB is a filter that is installed as part of the Rails installation that takes an .erb file and outputs a transformed version.
The output file is often HTML in Rails, but it can be anything.
Normal content is passed through without being changed.
However, content between <%= and %> is interpreted as Ruby code and executed.
The result of that execution is converted into a string, and that • 22 value is substituted in the file in place of the <%=…%> sequence.
For example, change hello.html.erb to display the current time.

     Download rails40/demo2/app/views/say/hello.html.erb
     <h1>Hello from Rails!</h1>
     ➤ <p>
     ➤   It is now <%= Time.now %>
     ➤ </p>

When we refresh our browser window, we see the time displayed using Ruby’s
standard format.

Notice that if you hit Refresh in your browser, the time updates each time
the page is displayed. It looks as if we’re really generating dynamic content.

### 2.2.5 Adding the Time 把时间加上
Our original problem was to display the time to users of our application.
We now know how to make our application display dynamic data.
The second issue we have to address is working out where to get the time from.

We’ve shown that the approach of embedding a call to Ruby’s Time.now() method in our hello.html.erb template works.
Each time we access this page, the user will see the current time substituted into the body of the response.
And for our trivial application, that might be good enough.
In general, though, we probably want to do something slightly different.
We’ll move the determination of the time to be displayed into the controller and leave the view with the simple job of displaying it.
We’ll change our action method in the controller to set the time value into an instance variable called @time.

instance variable ↪ on page 46

     Download rails40/demo3/app/controllers/say_controller.rb
     class SayController < ApplicationController
       def hello
     ➤   @time = Time.now
       end
       def goodbye
       end
     end

• 23
In the .html.erb template, we’ll use this instance variable to substitute the time into the output.

     Download rails40/demo3/app/views/say/hello.html.erb
     <h1>Hello from Rails!</h1>
     <p>
     ➤ It is now <%= @time %>
     </p>

When we refresh our browser window, we will again see the current time, showing that the communication between the controller and the view was successful.

Why did we go to the extra trouble of setting the time to be displayed in the controller and then using it in the view?
Good question.
In this application, it doesn’t make much difference, but by putting the logic in the controller instead, we buy ourselves some benefits.
For example, we may want to extend our application in the future to support users in many countries.
In that case, we’d want to localize the display of the time, choosing a time appropriate to their time zone.
That would be a fair amount of application-level code, and it would probably not be appropriate to embed it at the view level.
By setting the time to display in the controller, we make our application more flexible—we can change the time zone in the controller without having to update any view that uses that time object.
The time is data, and it should be supplied to the view by the controller.
We’ll see a lot more of this when we introduce models into the equation.


------------------------------

Making Development Easier
You might have noticed something about the development we’ve been doing so far.
As we’ve been adding code to our application, we haven’t had to restart the running application.
It has been happily chugging away in the background.
And yet each change we make is available whenever we access the application through a browser.

What gives?
It turns out that the Rails dispatcher is pretty clever.
In development mode (as opposed to testing or production), it automatically reloads application source files when a new request comes along.
That way, when we edit our application, the dispatcher makes sure it’s running the most recent changes.
This is great for development.

However, this flexibility comes at a cost—it causes a short pause after you enter a URL before the application responds.
That’s caused by the dispatcher reloading stuff.
For development it’s a price worth paying, but in production it would be unacceptable.
Because of this, this feature is disabled for production deployment (see Chapter 16, Task K: Deployment and Production, on page 233).

------------------------------

• 24

### 2.2.6 The Story So Far  故事讲到现在
Let’s briefly review how our current application works.
1.  The user navigates to our application.
In our case, we do that using a local URL such as http://localhost:3000/say/hello.

2. Rails then matches the route pattern, which it previously split into two
parts and analyzed.
The say part is taken to be the name of a controller, so Rails creates a new instance of the Ruby class SayController (which it finds in app/controllers/ say_controller.rb).

3.  The next part of the pattern, hello, identifies an action.
Rails invokes a method of that name in the controller.
This action method creates a new Time object holding the current time and tucks it away in the @time instance variable.

4.  Rails looks for a template to display the result.
It searches the directory app/views for a subdirectory with the same name as the controller (say) and in that subdirectory for a file named after the action (hello.html.erb).

5.  Rails processes this file through the ERB templating system, executing any embedded Ruby and substituting in values set up by the controller.

6.  The result is returned to the browser, and Rails finishes processing this request.

This isn’t the whole story—Rails gives you lots of opportunities to override this basic workflow (and we’ll be taking advantage of them shortly).
As it stands, our story illustrates convention over configuration, one of the fundamental parts of the philosophy of Rails.
By providing convenient defaults and by applying certain conventions on how a URL is constructed or in what file a controller definition is placed and what class name and method names are used, Rails applications are typically written using little or no external configuration—things just knit themselves together in a natural way.


## 2.3 Linking Pages Together  把页面连接起来
It’s a rare web application that has just one page.
Let’s see how we can add another stunning example of web design to our “Hello, World!” application.

Normally, each page in your application will correspond to a separate view.
In our case, we’ll also use a new action method to handle the page (although that isn’t always the case, as we’ll see later in the book).
We’ll use the same controller for both actions.
Again, this needn’t be the case, but we have no compelling reason to use a new controller right now.

• 25

We already defined a goodbye action for this controller, so all that remains is to create a new template in the directory app/views/say.
This time it’s called goodbye.html.erb because by default templates are named after their associated actions.

     Download rails40/demo4/app/views/say/goodbye.html.erb
     <h1>Goodbye!</h1>
     <p>
       It was nice having you here.
     </p>

Fire up our trusty browser again, but this time point to our new view using the URL http://localhost:3000/say/goodbye.
You should see something like this:

Figure 3—Our second action

Now we need to link the two screens.
We’ll put a link on the hello screen that takes us to the goodbye screen, and vice versa.
In a real application, we might want to make these proper buttons, but for now we’ll just use hyperlinks.

We already know that Rails uses a convention to parse the URL into a target controller and an action within that controller.
So, a simple approach would be to adopt this URL convention for our links.

The file hello.html.erb would contain the following:

     ...
     <p>
       Say <a href="/say/goodbye">Goodbye</a>!
     </p>
     ...

• 26

And the file goodbye.html.erb would point the other way.

     ...
     <p>
       Say <a href="/say/hello">Hello</a>!
     </p>
     ...

This approach would certainly work, but it’s a bit fragile.
If we were to move our application to a different place on the web server, the URLs would no longer be valid.
It also encodes assumptions about the Rails URL format into our code; it’s possible a future version of Rails might change this.

Fortunately, these aren’t risks we have to take.
Rails comes with a bunch of helper methods that can be used in view templates.
Here, we’ll use the helper method link_to(), which creates a hyperlink to an action.
(The link_to() method can do a lot more than this, but let’s take it gently for now.) Using link_to(), hello.html.erb becomes the following:

       Download rails40/demo5/app/views/say/hello.html.erb
       <h1>Hello from Rails!</h1>
       <p>
         It is now <%= @time %>
       </p>
     ➤ <p>
     ➤   Time to say
     ➤   <%= link_to "Goodbye", say_goodbye_path %>!
     ➤ </p>

There’s a link_to() call within an ERB <%=…%> sequence.
This creates a link to a URL that will invoke the goodbye() action.
The first parameter in the call to link_to() is the text to be displayed in the hyperlink, and the next parameter tells Rails to generate the link to the goodbye() action.

Let’s stop for a minute to consider how we generated the link. We wrote this:

     link_to "Goodbye", say_goodbye_path


First, link_to() is a method call.
(In Rails, we call methods that make it easier to write templates helpers.) If you come from a language such as Java, you might be surprised that Ruby doesn’t insist on parentheses around method parameters.
You can always add them if you like.

say_goodbye_path is a precomputed value that Rails makes available to application views.
It evaluates to the /say/goodbye path.
Over time you will see that Rails provides the ability to name all the routes that you will be using in your application.

• 27

OK, let’s get back to the application.
If we point our browser at our hello page, it will now contain the link to the goodbye page, as shown in the following figure:

Figure 4—The Hello page with a link to the goodbye page

We can make the corresponding change in goodbye.html.erb, linking it back to the initial hello page.

     Download rails40/demo5/app/views/say/goodbye.html.erb
       <h1>Goodbye!</h1>
       <p>
         It was nice having you here.
       </p>
     ➤ <p>
     ➤   Say <%= link_to "Hello", say_hello_path %> again.
     ➤ </p>

At this point, we’ve completed our toy application and in the process verified that our installation of Rails is functioning properly.
After a brief recap, it is now time to move on to building a real application.

## 2.4 What We Just Did 小结
We constructed a toy application that showed us the following:
• How to create a new Rails application and how to create a new controller in that application
• How to create dynamic content in the controller and display it via the view template
• How to link pages together

• 28

This is a great foundation, and it didn’t really take much time or effort.
This experience will continue as we move on to the next chapter and build a much bigger application.

### 2.4.1 Playtime 练习
Here’s some stuff to try on your own:
• Experiment with the following expressions:
• Addition: <%= 1+2 %>
• Concatenation: <%= "cow" + "boy" %>
• Time in one hour: <%= 1.hour.from_now.localtime %>
• A call to the following Ruby method returns a list of all the files in the
current directory:

     @files = Dir.glob('*')

Use it to set an instance variable in a controller action, and then write the corresponding template that displays the filenames in a list on the browser.

Hint: you can iterate over a collection using something like this:

     <% for file in @files %>
       file name is: <%= file %>
     <% end %>

You might want to use a <ul> for the list.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

### 2.4.2 Cleaning Up 清理现场
Maybe you’ve been following along and writing the code in this chapter. If so,
chances are that the application is still running on your computer. When we
start coding our next application in Chapter 6, Task A: Creating the Application,
on page 61, we’ll get a conflict the first time we run it because it will also try
to use the computer’s port 3000 to talk with the browser. Now would be a
good time to stop the current application by pressing Ctrl-C in the window
you used to start it. Microsoft Windows users may need to press Ctrl-Pause/
Break instead.
Now let’s move on to an overview of Rails.

# CHAPTER 3 The Architecture of Rails Applications 应用程序框架
## 概述

In this chapter, we’ll see
在这一章，我们将学习：
• models,
  模型
• views, and
  视图
• controllers.
  控制器

One of the interesting features of Rails is that it imposes some fairly serious constraints on how you structure your web applications.
Rails有趣的特点之一是对“如何组织Web应用的结构”有着相当严格的约束。
Surprisingly, these constraints make it easier to create applications—a lot easier.
令人惊讶的是，这些约束反倒使创建应用程序变得更加简单--甚至简单得多。
Let’s see why.
现在，就让我们来看看这是为什么。

## 3.1 Models, Views, and Controllers  模型、视图以及控制器
Back in 1979, Trygve Reenskaug came up with a new architecture for developing interactive applications.
1979年，Trygve Reenskaug
提出一种开发交互式应用的全新架构。
In his design, applications were broken into three types of components: models, views, and controllers.
在这个设计方案中，把应用程序分为三类组件：模型、视图以及控制器。

The model is responsible for maintaining the state of the application.
模型负责维持应用程序的状态。
Sometimes this state is transient, lasting for just a couple of interactions with the user.
有时这种状态是短暂的，只对于和用户的几次交互有效。
Sometimes the state is permanent and will be stored outside the application, often in a database.
有时候这种状态则是持久的，需要将其保存在应用程序之外，通常保存在数据库中。

A model is more than just data; it enforces all the business rules that apply to that data.
模型是数据，但又不只是数据，它还负责把业务规则附加在这些数据之上。
For example, if a discount shouldn’t be applied to orders of less than $20, the model will enforce the constraint.
比如，“对于20美元以下的订单不予打折”，这一约束就要由模型来执行。
This makes sense; by putting the implementation of these business rules in the model, we make sure that nothing else in the application can make our data invalid.
这种做法是很有意义的；通过将业务规则的实现放在模型中，就可以确保应用程序的其他部分不会使数据无效。
The model acts as both a gatekeeper and a data store.
这样模型不仅仅是数据的容器，还是数据的监护者。

The view is responsible for generating a user interface, normally based on data in the model.
视图负责生成用户界面--通常会根据模型中的数据来生成。
For example, an online store will have a list of products to be displayed on a catalog screen.
譬如，在线商店可能需要将一系列商品显示在屏幕上，。
This list will be accessible via the model, but it will be a view that formats the list for the end user.
通过模型可以访问这个商品列表，但还需要一个视图，将其格式化为最终用户能够理解的形式。
Although the view may present the user with various ways of inputting data, the view itself never handles incoming data.
虽然视图可能允许用户以多种方式输入数据，但输入的数据不一定由视图本身来处理。
The view’s work is done once the data is displayed.
视图的唯一工作就是显示数据。
There may well be many views that access the same model data, often for different purposes.
但由于目的不同，可能会有多个视图访问同一个模型数据。

 • 30 

In the online store, there’ll be a view that displaysproduct information on a catalog page and another set of views used by administrators to add and edit products.
在在线商店的例子中，就有一个视图显示分类页面上的商品信息，还有管理员使用的视图集用于专门添加和编辑商品信息。

Controllers orchestrate the application.
控制器负责协调整个应用程序的运转。
Controllers receive events from the outside world (normally user input), interact with the model, and display an appropriate view to the user.
控制器接受来自外界的事件（通常是用户输入），与模型进行交互，并将合适的视图展示给用户。

This triumvirate—the model, view, and controller—together form an architecture known as MVC.
这个三位一体的组合--模型、视图和控制器--构成了一种架构，那就是著名的MVC。
To learn how the three concepts fit together, see the following figure:


     Controller
     
     View
     
     Model
     
     Database
     
     1.  Browser sends request
         浏览器发出请求
     2.  Controller interacts with model
         控制器与模型交互
     3.  Controller invokes view
         控制器调用视图
     4.  View renders next browser screen
         视图生成浏览器的显示
     
     Figure 5—The Model-View-Controller architecture

The MVC architecture was originally intended for conventional GUI applications, where developers found the separation of concerns led to far less coupling, which in turn made the code easier to write and maintain.
MVC架构的设计初衷是用于传统的GUI应用程序；开发者发现：通过把程序进行这种概念上的分离，可以大大降低系统的耦合度，使代码易于编写、易于维护。
Each concept or action was expressed in just one well-known place.
每个概念、每个动作都只在一个规定的地方进行描述。
Using MVC was like constructing a skyscraper with the girders already in place—it was a lot easier to hang the rest of the pieces with a structure already there.
使用MVC开发应用程序，就好像在搭好的桁架上盖大楼一样--只要结构已经到位，搭建其他部分就容易多了。
During the development of our application, we will be making heavy use of Rails’ ability to generate scaffolding for our application.
<kinder:note> 在程序开发期间，我们将充分利用Rails来产生应用程序的支架。

Ruby on Rails is an MVC framework, too.
Ruby on Rails也是一个MVC框架。
Rails enforces a structure for your application—you develop models, views, and controllers as separate chunks of functionality, and it knits them together as your program executes.
Rails
强迫你将应用程序按照模型、视图和控制器进行划分，并遵循这一结构分别开发各个部分的功能。
One of the joys of Rails is that this knitting process is based on the use of intelligent defaults so that you typically don’t need to write any external configuration metadata to make it all work.
Rails的有趣之处在于：通过使用智能化的默认设置把程序组合连接在一起，因此，一般情况下不需要编写任何外部元数据的配置信息。
This is an example of the Rails philosophy of favoring convention over configuration.
这正是Rails提倡的“约定重于配置”观念的体现。

• 31

In a Rails application, an incoming request is first sent to a router, which works out where in the application the request should be sent and how the request itself should be parsed.
在一个Rails应用中，进入的请求首先会发送给一个路由器，该路由器判断应该将请求发送到应用程序的什么部分，以及如何解析这一请求。
Ultimately, this phase identifies a particular method (called an action in Rails parlance) somewhere in the controller code.
最终，这一阶段将找出控制器代码中的某个特殊方法（Rails中称为行为）。
The action might look at data in the request, it might interact with the model, and it might cause other actions to be invoked.
行为可以查阅请求中携带的数据，可以与模型交互，也可以调用别的行为。
Eventually the action prepares information for the view, which renders something to the user.
最后，行为会为视图准备充分的信息，而视图则将所需的信息展示给用户。

Rails handles an incoming request as shown in the following figure.
下面的图表展示了Rails处理一个请求的全过程。
In this example, the application has previously displayed a product catalog page, and the user has just clicked the Add to Cart button next to one of the products.
在这个例子中，假设应用程序已经向用户展现了一个“产品分类列表”页面，用户则单击了某个产品旁边的“放进购物车”按钮。
This button posts to `http://localhost:3000/line_items?product_id=2`, where line_items is a resource in our application and 2 is our internal ID for the selected product.
这个按钮提交到`http://localhost:3000/line_items?product_id=2`，`line_items`是应用的资源，“2”是所选商品在系统内的id号。

     http://my.url/line_items?product_id=2
     Routing finds LineItems controller
     Controller interacts with model
     Controller invokes view
     View renders next browser screen
     
     Routing
     
     Line Items
     Controller
     
     Line Items
     View
     
     Active
     Record
     Model
     
     Database
     
     Figure 6—Rails and MVC

The routing component receives the incoming request and immediately picks it apart.
路由组件收到来自外部的请求之后，立即将其拆成小块。
The request contains a path (/line_items?product_id=2) and a method (this button does a POST operation; other common methods are GET, PUT, PATCH, and DELETE).
这个请求包含一条路径（/line_items?product_id=2）和一个方法（这里是POST操作，其他方法是GET、PUT和DELETE）。
In this simple case, Rails takes the first part of the path, line_items, as the name of the controller and the product_id as the ID of a product.
在这个例子中，Rails把路径的第一部分（line_items）看作控制器的名称，第二部分（product_id）看作行为的名称。
By convention, POST methods are associated with create() actions.
<kinder:note> 按照约定，POST方法与create()行为相关联。
As a result of all this analysis, the router knows it has to invoke the create() method in the controller class LineItemsController (we’ll talk about naming conventions in Section 18.2, Naming Conventions, on page 270).
这样路由组件就知道，应该调用LineItemsController这个控制器中的create()方法（后面270页，18.2节命名约定会详细讨论）。

The create() method handles user requests.
create()方法会处理用户的请求。
In this case, it finds the current user’s shopping cart (which is an object managed by the model).
找到当前用户的购物车（这也是由模型管理的一个对象）。
It also asks the model to find the information for product 2.
请求模型找出编号为2的商品信息。
It then tells the shopping cart to add that product to itself.
然后告诉购物车将商品加入其中。
(See how the model is being used to keep track of all the business data? The controller tells it what to do, and the model knows how to do it.)
（请留意模型是如何跟踪所有业务数据的：控制器只是告诉它做什么，而模型自己知道该怎么做。）

 • 32 

Now that the cart includes the new product, we can show it to the user.
既然购物车中已经放进了用户选择的商品，我们就需要将这一事实展现给用户。
The controller invokes the view code, but before it does, it arranges things so that the view has access to the cart object from the model.
控制器会安排视图访问模型中的购物车对象，并调用视图代码使其呈现在用户眼前。
In Rails, this invocation is often implicit; again, conventions help link a particular view with a given action.
在Rails中，这一调用是隐式的；对于特定的行为，Rails将根据命名约定自动为其查找一个特定的视图。

That’s all there is to an MVC web application.
这就是关于一个MVC Web应用的全部内容了。
By following a set of conventions and partitioning your functionality appropriately, you’ll discover that your code becomes easier to work with and your application becomes easier to extend and maintain.
只要遵循一定的命名约定，并且合理划分功能，你会发现编写代码变得轻松愉快，应用程序会更具可扩展性、可维护性。
That seems like a good trade.
看起来确实挺划算的。

If MVC is simply a question of partitioning your code a particular way, you might be wondering why you need a framework such as Ruby on Rails.
如果MVC仅仅是“以某种方式划分代码”的话，你可能会想，那还要Ruby On Rails这样的框架干什么？
The answer is straightforward: Rails handles all of the low-level housekeeping for you—all those messy details that take so long to handle by yourself—and lets you concentrate on your application’s core functionality.
答案很简单：Rails帮助你处理了所有底层的基础代码--所有那些需要耗费大把时间去处理的繁琐细节，从而让程序员只需要专注于应用程序的核心功能。
Let’s see how.
现在让我们看看它是如何做到这一点的。

## 3.2 Rails Model Support  模型支持
In general, we’ll want our web applications to keep their information in a relational database.
Order-entry systems will store orders, line items, and customer details in database tables.
Even applications that normally use unstructured text, such as weblogs and news sites, often use databases as their back-end data store.

Although it might not be immediately apparent from the SQL1 you use to access them, relational databases are actually designed around mathematical set theory.
Although this is good from a conceptual point of view, it makes it difficult to combine relational databases with object-oriented (OO) programming languages.
Objects are all about data and operations, and databases are all about sets of values.
Operations that are easy to express in relational terms are sometimes difficult to code in an OO system.
The reverse is also true.
1.SQL, referred to by some as Structured Query Language, is the language used to query and update relational databases.

Over time, folks have worked out ways of reconciling the relational and OO views of their corporate data.
Let’s look at the way that Rails chooses to map relational data onto objects.

• 33

### 3.2.1 Object-Relational Mapping 对象-关系映射
ORM libraries map database tables to classes.
If a database has a table called orders, our program will have a class named Order.
Rows in this table correspond to objects of the class—a particular order is represented as an object of class Order .
Within that object, attributes are used to get and set the individual columns.
Our Order object has methods to get and set the amount, the sales tax, and so on.

In addition, the Rails classes that wrap our database tables provide a set of class-level methods that perform table-level operations.
For example, we might need to find the order with a particular ID.
This is implemented as a class method that returns the corresponding Order object.
In Ruby code, this might look like this:

     order = Order.find(1)
     puts "Customer #{order.customer_id}, amount=$#{order.amount}"

class method ↪ on page 45
puts ↪ on page 39

Sometimes these class-level methods return collections of objects.

     Order.where(name: 'dave').each do |order|
       puts order.amount
     end

iterating ↪ on page 44

Finally, the objects corresponding to individual rows in a table have methods that operate on that row.
Probably the most widely used is save(), the operation that saves the row to the database.

     Order.where(name: 'dave').each do |order|
       order.pay_type = "Purchase order"
       order.save
     end

So, an ORM layer maps tables to classes, rows to objects, and columns to attributes of those objects.
Class methods are used to perform table-level operations, and instance methods perform operations on the individual rows.

In a typical ORM library, you supply configuration data to specify the mappings between entities in the database and entities in the program.
Programmers using these ORM tools often find themselves creating and maintaining a boatload of XML configuration files.

### 3.2.2 Active Record
Active Record is the ORM layer supplied with Rails. It closely follows the
standard ORM model: tables map to classes, rows to objects, and columns
to object attributes. It differs from most other ORM libraries in the way it is
configured. By relying on convention and starting with sensible defaults,
Active Record minimizes the amount of configuration that developers perform.
To illustrate this, here’s a program that uses Active Record to wrap our orders
table:

• 34

     require 'active_record'
     
     class Order < ActiveRecord::Base
     end
     
     order = Order.find(1)
     order.pay_type = "Purchase order"
     order.save

This code uses the new Order class to fetch the order with an id of 1 and modify the pay_type.
(We’ve omitted the code that creates a database connection for now.) Active Record relieves us of the hassles of dealing with the underlying database, leaving us free to work on business logic.

But Active Record does more than that.
As you’ll see when we develop our shopping cart application, starting in Chapter 5, The Depot Application, on page 55, Active Record integrates seamlessly with the rest of the Rails framework.
If a web form sends the application data related to a business object, Active Record can extract it into our model.
Active Record supports sophisticated validation of model data, and if the form data fails validations, the Rails views can extract and format errors.

Active Record is the solid model foundation of the Rails MVC architecture.

## 3.3 Action Pack: The View and Controller 视图控制器
When you think about it, the view and controller parts of MVC are pretty intimate.
The controller supplies data to the view, and the controller receives events from the pages generated by the views.
Because of these interactions, support for views and controllers in Rails is bundled into a single component, Action Pack.

Don’t be fooled into thinking that your application’s view code and controller code will be jumbled up just because Action Pack is a single component.
Quite the contrary; Rails gives you the separation you need to write web applications with clearly demarcated code for control and presentation logic.

### 3.3.1 View Support  视图支持
In Rails, the view is responsible for creating all or part of a response to be displayed in a browser, to be processed by an application, or to be sent as an email.
At its simplest, a view is a chunk of HTML code that displays some fixed text.
More typically you’ll want to include dynamic content created by the action method in the controller.

• 35

In Rails, dynamic content is generated by templates, which come in three flavors.
The most common templating scheme, called Embedded Ruby (ERB), embeds snippets of Ruby code within a view document, in many ways similar to the way it is done in other web frameworks, such as PHP or JSP.
Although this approach is very flexible, some are concerned that it violates the spirit of MVC.
By embedding code in the view, we risk adding logic that should be in the model or the controller.
As with everything, while judicious use in moderation is healthy, overuse can become a problem.
Maintaining a clean separation of concerns is part of the job of the developer.
(We look at HTML templates in Section 24.2, Generating HTML with ERB, on page 395.) You can also use ERB to construct JavaScript fragments on the server that are then executed on the browser.
This is great for creating dynamic Ajax interfaces.
We talk about these starting in Section 11.2, Iteration F2:
Creating an Ajax-Based Cart, on page 142.

Rails also provides XML Builder to construct XML documents using Ruby code—the structure of the generated XML will automatically follow the structure of the code.
We discuss xml.builder templates starting in Section 24.1, Generating XML with Builder, on page 393.

### 3.3.2 And the Controller!  还有控制器
The Rails controller is the logical center of your application.
It coordinates the interaction between the user, the views, and the model.
However, Rails handles most of this interaction behind the scenes; the code you write concentrates on application-level functionality.
This makes Rails controller code remarkably easy to develop and maintain.

The controller is also home to a number of important ancillary services.
• It is responsible for routing external requests to internal actions. It handles people-friendly URLs extremely well.
• It manages caching, which can give applications orders-of-magnitude performance boosts.
• It manages helper modules, which extend the capabilities of the view templates without bulking up their code.
• It manages sessions, giving users the impression of ongoing interaction with our applications.
We’ve already seen and modified a controller in Section 2.2, Hello, Rails!, on page 17 and will be seeing and modifying a number of controllers in the development of a sample application, starting with the products controller in Section 8.1, Iteration C1:
Creating the Catalog Listing, on page 91.

There’s a lot to Rails. But before going any further, let’s have a brief refresher —and for some of you, a brief introduction—to the Ruby language.


# CHAPTER 4 Introduction to Ruby   简介Ruby

In this chapter, we’ll see
• objects: names and methods;
• data: strings, arrays, hashes, and regular expressions;
• control: if, while, blocks, iterators, and exceptions;
• building blocks: classes and modules;
• YAML and marshaling; and
• common idioms that you will see used in this book.

Many people who are new to Rails are also new to Ruby.
If you are familiar with a language such as Java, JavaScript, PHP, Perl, or Python, you will find Ruby pretty easy to pick up.

This chapter is not a complete introduction to Ruby.
It will not cover topics such as precedence rules (like most other programming languages, `1+2*3==7` in Ruby).
It is only meant to explain enough Ruby that the examples in the book make sense.

This chapter draws heavily from material in Programming Ruby [TFH13].
If you think you need more background on the Ruby language (and at the risk of being grossly self-serving), we’d like to suggest that the best way to learn Ruby and the best reference for Ruby’s classes, modules, and libraries is Programming Ruby [TFH13] (also known as the PickAxe book).
Welcome to the Ruby community!

## 4.1 Ruby Is an Object-Oriented Language  面向对象的语言
Everything you manipulate in Ruby is an object, and the results of those manipulations are themselves objects.

When you write object-oriented code, you’re normally looking to model concepts from the real world.
Typically during this modeling process you’ll discover categories of things that need to be represented.
In an online store, the concept of a line item could be such a category.
In Ruby, you’d define a class to represent each of these categories.
You then use this class as a kind of factory that generates objects—instances of that class.
An object is a combination of state (for example, the quantity and the product ID) and methods that use that state (perhaps a method to calculate the line item’s total cost).
We’ll show how to create classes in Classes, on page 45.

• 38

Objects are created by calling a constructor, a special method associated with a class.
The standard constructor is called new().
Given a class called LineItem, you could create line item objects as follows:

     line_item_one = LineItem.new
     line_item_one.quantity = 1
     line_item_one.sku = "AUTO_B_00"

Methods are invoked by sending a message to an object.
The message contains the method’s name, along with any parameters the method may need.
When an object receives a message, it looks into its own class for a corresponding method.
Let’s look at some method calls:

     "dave".length
     line_item_one.quantity()
     cart.add_line_item(next_purchase)
     submit_tag "Add to Cart"

Parentheses are generally optional in method calls.
In Rails applications, you’ll find that most method calls involved in larger expressions will have parentheses, while those that look more like commands or declarations tend not to have them.

Methods have names, as do many other constructs in Ruby.
Names in Ruby have special rules, rules that you may not have seen if you come to Ruby from another language.

### 4.1.1 Ruby Names 命名规则


Local variables, method parameters, and method names should all start with a lowercase letter or with an underscore: order, line_item, and xr2000 are all valid.
Instance variables begin with an “at” (@) sign, such as @quantity and @product_id.
The Ruby convention is to use underscores to separate words in a multiword method or variable name (so line_item is preferable to lineItem).
@name ↪ on page 46

Class names, module names, and constants must start with an uppercase letter.
By convention they use capitalization, rather than underscores, to distinguish the start of words within the name.
Class names look like Object, PurchaseOrder, and LineItem.

Rails uses symbols to identify things.
In particular, it uses them as keys when naming method parameters and looking things up in hashes.
Here’s an example:

     redirect_to :action => "edit", :id => params[:id]

• 39

As you can see, a symbol looks like a variable name, but it’s prefixed with a colon.
Examples of symbols include :action, :line_items, and :id.
You can think of symbols as string literals magically made into constants.
Alternatively, you can consider the colon to mean “thing named,” so :id is “the thing named id.” Now that we have used a few methods, let’s move on to how they are defined.

### 4.1.2 Methods 方法
Let’s write a method that returns a cheery, personalized greeting. We’ll invoke
that method a couple of times.

     def say_goodnight(name)
       result = 'Good night, ' + name
       return result
     end
     # Time for bed...
     puts say_goodnight('Mary-Ellen') # => 'Goodnight, Mary-Ellen'
     puts say_goodnight('John-Boy') # => 'Goodnight, John-Boy'

Having defined the method, we call it twice.
In both cases, we pass the result to the method puts(), which outputs to the console its argument followed by a newline (moving on to the next line of output).

You don’t need a semicolon at the end of a statement as long as you put each statement on a separate line.
Ruby comments start with a # character and run to the end of the line.
Indentation is not significant (but two-character indentation is the de facto Ruby standard).

Ruby doesn’t use braces to delimit the bodies of compound statements and definitions (such as methods and classes).
Instead, you simply finish the body with the keyword end.
The keyword return is optional, and if not present, the results of the last expression evaluated will be returned.

## 4.2 Data Types  数据类型
While everything in Ruby is an object, some of the data types in Ruby have special syntax support, in particular for defining literal values.
In these examples, we’ve used some simple strings and even string concatenation.

### 4.2.1 Strings 字符串
The previous example also showed some Ruby string objects.
One way to create a string object is to use string literals, which are sequences of characters between single or double quotation marks.
The difference between the two forms is the amount of processing Ruby does on the string while constructing the literal.
In the single-quoted case, Ruby does very little.
With only a few exceptions, what you type into the single-quoted string literal becomes the string’s value.

• 40

In the double-quoted case, Ruby does more work.
First, it looks for substitutions—sequences that start with a backslash character—and replaces them with some binary value.
The most common of these is \n, which is replaced with a newline character.
When you write a string containing a newline to the console, the \n forces a line break.

Second, Ruby performs expression interpolation in double-quoted strings.
In the string, the sequence #{expression} is replaced by the value of expression.

We could use this to rewrite our previous method:

     def say_goodnight(name)
       "Good night, #{name.capitalize}"
     end
     puts say_goodnight('pa')

When Ruby constructs this string object, it looks at the current value of name and substitutes it into the string.
Arbitrarily complex expressions are allowed in the #{…} construct.
Here we invoked the capitalize() method, defined for all strings, to output our parameter with a leading uppercase letter.

Strings are a fairly primitive data type that contain an ordered collection of bytes or characters.
Ruby also provides means for defining collections of arbitrary objects via arrays and hashes.


### 4.2.2 Arrays and Hashes 数组和散列
Ruby’s arrays and hashes are indexed collections.
Both store collections of objects, accessible using a key.
With arrays, the key is an integer, whereas hashes support any object as a key.
Both arrays and hashes grow as needed to hold new elements.
It’s more efficient to access array elements, but hashes provide more flexibility.
Any particular array or hash can hold objects of differing types; you can have an array containing an integer, a string, and a floating-point number, for example.

You can create and initialize a new array object using an array literal—a set of elements between square brackets.
Given an array object, you can access individual elements by supplying an index between square brackets, as the next example shows.
Ruby array indices start at zero.

     a = [ 1, 'cat', 3.14 ] # array with three elements
     a[0]                   # access the first element (1)
     a[2] = nil             # set the third element
                            # array now [ 1, 'cat', nil ]

You may have noticed that we used the special value nil in this example.
In many languages, the concept of nil (or null) means “no object.” In Ruby, that’s not the case; nil is an object, just like any other, that happens to represent nothing.

• 41

The method <<() is commonly used with arrays. It appends a value to its receiver.

     ages = []
     for person in @people
       ages << person.age
     end

Ruby has a shortcut for creating an array of words.

     a = [ 'ant', 'bee', 'cat', 'dog', 'elk' ]
     # this is the same:
     a = %w{ ant bee cat dog elk }

Ruby hashes are similar to arrays.
A hash literal uses braces rather than square brackets.
The literal must supply two objects for every entry: one for the key, the other for the value.
For example, you may want to map musical instruments to their orchestral sections.

     inst_section = {
       :cello     => 'string',
       :clarinet  => 'woodwind',
       :drum      => 'percussion',
       :oboe      => 'woodwind',
       :trumpet   => 'brass',
       :violin    => 'string'
     }

The thing to the left of the => is the key, and that on the right is the corresponding value.
Keys in a particular hash must be unique—you can’t have two entries for :drum.
The keys and values in a hash can be arbitrary objects —you can have hashes where the values are arrays, other hashes, and so on.

In Rails, hashes typically use symbols as keys.
Many Rails hashes have been subtly modified so that you can use either a string or a symbol interchangeably as a key when inserting and looking up values.

The use of symbols as hash keys is so commonplace that starting with Ruby 1.9 there is a special syntax for it, saving both keystrokes and eyestrain.

     inst_section = {
       cello: 'string',
       clarinet: 'woodwind',
       drum: 'percussion',
       oboe: 'woodwind',
       trumpet: 'brass',
       violin: 'string'
     }

Doesn’t that look much better?

• 42

Feel free to use whichever syntax you like.
You can even intermix usages in a single expression.
Obviously you’ll need to use the arrow syntax whenever the key is not a symbol.

Hashes are indexed using the same square bracket notation as arrays.

     inst_section[:oboe]      #=> 'woodwind'
     inst_section[:cello]     #=> 'string'
     inst_section[:bassoon]   #=> nil

As the previous example shows, a hash returns nil when indexed by a key it doesn’t contain.
Normally this is convenient, because nil means false when used in conditional expressions.

You can pass hashes as parameters on method calls.
Ruby allows you to omit the braces, but only if the hash is the last parameter of the call.
Rails makes extensive use of this feature.
The following code fragment shows a two-element hash being passed to the redirect_to() method.
In effect, though, you can ignore that it’s a hash and pretend that Ruby has keyword arguments.

     redirect_to action: 'show', id: product.id

There is one more data type worth mentioning—the regular expression.

### 4.2.3 Regular Expressions 正则表达式
A regular expression lets you specify a pattern of characters to be matched in a string.
In Ruby, you typically create a regular expression by writing /pattern/ or %r{pattern}.

For example, you could write a pattern that matches a string containing the text Perl or the text Python using the regular expression /Perl|Python/.

The forward slashes delimit the pattern, which consists of the two things we’re matching, separated by a vertical bar (|).
This bar character means “either the thing on the left or the thing on the right,” in this case either Perl or Python.
You can use parentheses within patterns, just as you can in arithmetic expressions, so you could also write this pattern as /P(erl|ython)/.
Programs typically test strings against regular expressions using the =~ match operator.

     if line =~ /P(erl|ython)/
       puts "There seems to be another scripting language here"
     end

You can specify repetition within patterns.
/ab+c/ matches a string containing an a followed by one or more b’s, followed by a c.
Change the plus to an asterisk, and `/ab*c/` creates a regular expression that matches one a, zero or more b’s, and one c.

• 43

Backward slashes start special sequences; most notably, \d matches any digit, \s matches any whitespace character, and \w matches any alphanumeric (word) character.

Ruby’s regular expressions are a deep and complex subject; this section barely skims the surface.
See the PickAxe book for a full discussion.

This book will make only light use of regular expressions.
With that brief introduction to data, let’s move on to logic.

## 4.3 Logic  逻辑方法
Method calls are statements.
Ruby also provides a number of ways to make decisions that affect the repetition and order in which methods are invoked.

### 4.3.1 Control Structures  控制结构
Ruby has all the usual control structures, such as if statements and while loops.
Java, C, and Perl programmers may well get caught by the lack of braces around the bodies of these statements.
Instead, Ruby uses the keyword end to signify the end of a body.

     if count > 10
       puts "Try again"
     elsif tries == 3
       puts "You lose"
     else
       puts "Enter a number"
     end

Similarly, while statements are terminated with end.

     while weight < 100 and num_pallets <= 30
       pallet = next_pallet()
       weight += pallet.weight
       num_pallets += 1
     end

Ruby also contains variants of these statements.
unless is like if except that it checks for the condition to not be true.
Similarly, until is like while except that the loop continues until the condition evaluates to be true.

Ruby statement modifiers are a useful shortcut if the body of an if, unless, while, or until statement is just a single expression.
Simply write the expression, followed by the modifier keyword and the condition.

     puts "Danger, Will Robinson" if radiation > 3000
     distance = distance * 1.2 while distance < 100

• 44

Although if statements are fairly common in Ruby applications, newcomers to the Ruby language are often surprised to find that looping constructs are rarely used.
Blocks and iterators often take their place.

### 4.3.2 Blocks and Iterators 代码块和迭代器

Code blocks are just chunks of code between braces or between do…end.
A common convention is that people use braces for single-line blocks and do/ end for multiline blocks.

     { puts "Hello" }       # this is a block
     
     do                     ###
       club.enroll(person)    # and so is this
       person.socialize       #
     end                    ###

To pass a block to a method, place the block after the parameters (if any) to the method.
In other words, put the start of the block at the end of the source line containing the method call.
For example, in the following code, the block containing puts "Hi" is associated with the call to the method greet().

     greet { puts "Hi" }

If a method call has parameters, they appear before the block.

     verbose_greet("Dave", "loyal customer") { puts "Hi" }

A method can invoke an associated block one or more times using the Ruby yield statement.
You can think of yield as being something like a method call that calls out to the block associated with the method containing the yield.

You can pass values to the block by giving parameters to yield.
Within the block, you list the names of the arguments to receive these parameters between vertical bars (|).

Code blocks appear throughout Ruby applications.
Often they are used in conjunction with iterators: methods that return successive elements from some kind of collection, such as an array.

     animals = %w( ant bee cat dog elk )    # create an array
     animals.each {|animal| puts animal }   # iterate over the contents

Each integer N implements a times() method, which invokes an associated block N times.

     3.times { print "Ho! " } #=> Ho! Ho! Ho!

The & prefix operator will allow a method to capture a passed block as a named
parameter.

• 45

     def wrap &b
       print "Santa says: "
       3.times(&b)
       print "\n"
     end
     wrap { print "Ho! " }

Within a block, or a method, control is sequential except when there is an exception.

### 4.3.3 Exceptions 异常
Exceptions are objects of class Exception or its subclasses.
The raise method causes an exception to be raised.
This interrupts the normal flow through the code.
Instead, Ruby searches back through the call stack for code that says it can handle this exception.

Both methods and blocks of code wrapped between begin and end keywords intercept certain classes of exceptions using rescue clauses.

     begin
       content = load_blog_data(file_name)
     rescue BlogDataNotFound
       STDERR.puts "File #{file_name} not found"
     rescue BlogDataFormatError
       STDERR.puts "Invalid blog data in #{file_name}"
     rescue Exception => exc
       STDERR.puts "General error loading #{file_name}: #{exc.message}"
     end

rescue clauses can be directly placed on the outermost level of a method defi- nition without needing to enclose the contents in a begin/end block.

That concludes our brief introduction to control flow, and at this point we have our basic building blocks upon which we can build larger structures.

## 4.4 Organizing Structures  组织结构
There are two basic concepts in Ruby for organizing methods, namely, classes and modules. We cover each in turn.

### 4.4.1 Classes 类
Here’s a Ruby class definition:

• 46

     class Order < ActiveRecord::Base
       has_many :line_items
       def self.find_all_unpaid
         self.where('paid = 0')
       end
       def total
         sum = 0
         line_items.each {|li| sum += li.total}
         sum
       end
     end


Class definitions start with the keyword class followed by the class name (which must start with an uppercase letter).
This Order class is defined to be a subclass of the class Base within the ActiveRecord module.

Rails makes heavy use of class-level declarations.
Here has_many is a method that’s defined by Active Record.
It’s called as the Order class is being defined.
Normally these kinds of methods make assertions about the class, so in this book we call them declarations.

Within a class body you can define class methods and instance methods.
Prefixing a method name with self.
(as we do on line 3) makes it a class method; it can be called on the class generally.
In this case, we can make the following call anywhere in our application:

     to_collect = Order.find_all_unpaid

Objects of a class hold their state in instance variables.
These variables, whose names all start with @, are available to all the instance methods of a class.

Each object gets its own set of instance variables.
Instance variables are not directly accessible outside the class.
To make them available, write methods that return their values.

     class Greeter
       def initialize(name)
         @name = name
       end
       def name
         @name
       end
       def name=(new_name)
         @name = new_name
       end
     end
     g = Greeter.new("Barney")
     g.name # => Barney
     g.name = "Betty"
     g.name # => Betty

Ruby provides convenience methods that write these accessor methods for you (which is great news for folks tired of writing all those getters and setters).

• 47

     class Greeter
       attr_accessor :name     # create reader and writer methods 
       attr_reader   :greeting # create reader only
       attr_writer   :age      # create writer only
     end

A class’s instance methods are public by default; anyone can call them.
You’ll probably want to override this for methods that are intended to be used only by other instance methods.

     class MyClass
       def m1 # this method is public
       end
       protected
       def m2 # this method is protected
       end
       private
       def m3 # this method is private
       end
     end

The private directive is the strictest; private methods can be called only from within the same instance.
Protected methods can be called both in the same instance and by other instances of the same class and its subclasses.

Classes are not the only organizing structure in Ruby.
The other organizing structure is a module.

### 4.4.2 Modules 模块
Modules are similar to classes in that they hold a collection of methods, constants, and other module and class definitions.
Unlike classes, you cannot create objects based on modules.

Modules serve two purposes.
First, they act as a namespace, letting you define methods whose names will not clash with those defined elsewhere.
Second, they allow you to share functionality between classes—if a class mixes in a module, that module’s instance methods become available as if they had been defined in the class.
Multiple classes can mix in the same module, sharing the module’s functionality without using inheritance.
You can also mix multiple modules into a single class.

Helper methods are an example of where Rails uses modules.
Rails automatically mixes these helper modules into the appropriate view templates.
For example, if you wanted to write a helper method that would be callable from views invoked by the store controller, you could define the following module in the file store_helper.rb in the app/helpers directory:

• 48

     module StoreHelper
       def capitalize_words(string)
         string.split(' ').map {|word| word.capitalize}.join(' ')
       end
     end

There is one module that is part of the standard library of Ruby that deserves special mention given its usage in Rails, namely, YAML.

### 4.4.3 YAML
YAML1 is a recursive acronym that stands for YAML Ain’t Markup Language.
1.  http://www.yaml.org/
In the context of Rails, YAML is used as a convenient way to define the configuration of things such as databases, test data, and translations.
Here is an example:

     development:
       adapter: sqlite3
       database: db/development.sqlite3
       pool: 5
       timeout: 5000

In YAML, indentation is important, so this defines development as having a set of four key-value pairs, separated by colons.

While YAML is one way to represent data, particularly when interacting with humans, Ruby provides a more general way for representing data for use by applications.

## 4.5 Marshaling Objects  封送（序列化）对象
Ruby can take an object and convert it into a stream of bytes that can be stored outside the application.
This process is called marshaling.
This saved object can later be read by another instance of the application (or by a totally separate application), and a copy of the originally saved object can be reconstituted.

There are two potential issues when you use marshaling.
First, some objects cannot be dumped.
If the objects to be dumped include bindings, procedure or method objects, instances of class IO, or singleton objects, or if you try to dump anonymous classes or modules, a TypeError will be raised.

Second, when you load a marshaled object, Ruby needs to know the definition of the class of that object (and of all the objects it contains).

• 49

Rails uses marshaling to store session data.
If you rely on Rails to dynamically load classes, it is possible that a particular class may not have been defined at the point it reconstitutes session data.
For that reason, you’ll use the model declaration in your controller to list all models that are marshaled.
This preemptively loads the necessary classes to make marshaling work.

Now that you have the Ruby basics down, let’s give what we learned a whirl with a slightly larger, annotated example that pulls together a number of concepts.
We’ll follow that with a walk-through of special features that will help you with your Rails coding.

## 4.6 Pulling It All Together  综合分析
Let’s look at an example of how Rails applies a number of Ruby features together to make the code you need to maintain more declarative.
You will see this example again in Generating the Scaffold, on page 62.
For now, we will focus on the Ruby-language aspects of the example.

     class CreateProducts < ActiveRecord::Migration
       def change
         create_table :products do |t|
           t.string :title
           t.text :description
           t.string :image_url
           t.decimal :price, precision: 8, scale: 2
           t.timestamps
         end
       end
     end

Even if you didn’t know any Ruby, you would probably be able to decipher that this code creates a table named products.
The fields defined when creating this table include title, description, image_url, and price as well as a few timestamps (we’ll describe these in Chapter 22, Migrations, on page 367).

Now let’s look at the same example from a Ruby perspective.
A class named CreateProducts is defined, which inherits from the Migration class from the ActiveRecord module.
One method is defined named change().
This method calls the create_table() method (defined in ActiveRecord::Migration), passing it the name of the table in the form of a symbol.

The call to create_table() also passes a block that is to be evaluated before the table is created.
This block, when called, is passed an object named t, which is used to accumulate a list of fields.
Rails defines a number of methods on this object—methods with names that are named after common data types.

• 50

These methods, when called, simply add a field definition to the ever-accumulating set of names.

The definition of decimal also accepts a number of optional parameters, expressed as a hash.

To someone new to Ruby, this is a lot of heavy machinery thrown at solving such a simple problem.
To someone familiar with Ruby, none of this machinery is particularly heavy.
In any case, Rails makes extensive use of the facilities provided by Ruby to make defining operations (for example, migration tasks) as simple and as declarative as possible.
Even small features of the language, such as optional parentheses and braces, contribute to the overall readability and ease of authoring.

Finally, there are a number of small features, or rather idiomatic combinations of features, that are often not immediately obvious to people new to the Ruby language.
We close this chapter with them.

## 4.7 Ruby Idioms  习惯用语
A number of individual Ruby features can be combined in interesting ways, and the meaning of such idiomatic usage is often not immediately obvious to people new to the language.
We use these common Ruby idioms in this book:

### 4.7.1 Methods such as empty! and empty?
Ruby method names can end with an exclamation mark (a bang method) or a question mark (a predicate method).
Bang methods normally do something destructive to the receiver.
Predicate methods return true or false depending on some condition.

### 4.7.2 a || b
The expression a || b evaluates a.
If it isn’t false or nil, then evaluation stops, and the expression returns a.
Otherwise, the statement returns b.
This is a common way of returning a default value if the first value hasn’t been set.

### 4.7.3 a ||= b
The assignment statement supports a set of shortcuts: a op= b is the same as a = a op b.
This works for most operators.

     count += 1           # same as count = count + 1
     price *= discount    # price = price * discount
     count ||= 0          # count = count || 0

So, count ||= 0 gives count the value 0 if count doesn’t already have a value.

### 4.7.4 obj = self.new
Sometimes a class method needs to create an instance of that class.

• 51

     class Person < ActiveRecord::Base
       def self.for_dave
         Person.new(name: 'Dave')
       end
     end

This works fine, returning a new Person object.
But later, someone might subclass our class.

     class Employee < Person
       # ..
     end
     dave = Employee.for_dave # returns a Person

The for_dave() method was hardwired to return a Person object, so that’s what is returned by Employee.for_dave.
Using self.new instead returns a new object of the receiver’s class, Employee.

### 4.7.5 lambda

The lambda operator converts a block into an object of type Proc.
An alternate syntax, introduced in Ruby 1.9, is ->.
We will see both syntaxes used in Scopes, on page 292.

### 4.7.6 require File.expand_path('../../config/environment', __FILE__)

Ruby’s require method loads an external source file into our application.
This is used to include library code and classes that our application relies on.
In normal use, Ruby finds these files by searching in a list of directories, the LOAD_PATH.

Sometimes we need to be specific about what file to include.
We can do that by giving require a full filesystem path.
The problem is, we don’t know what that path will be—our users could install our code anywhere.

Wherever our application ends up getting installed, the relative path between the file doing the requiring and the target file will be the same.
Knowing this, we can construct the absolute path to the target by using the File.expand_path() method, passing in the relative path to the target file, as well as the absolute path to the file doing the requiring (available in the special variable __FILE__).

In addition, there are many good resources on the Web showing Ruby idioms
and Ruby gotchas. Here are just a few:
• http://www.ruby-lang.org/en/documentation/ruby-from-other-languages/
• http://en.wikipedia.org/wiki/Ruby_programming_language
• http://www.zenspider.com/Languages/Ruby/QuickRef.html

• 52 

By this point, we have a firm foundation upon which to build.
We’ve installed Rails, verified that we have things working with a simple application, covered a brief description of what Rails is, and reviewed (or for some of you, learned for the first time) the basics of the Ruby language.
Now it is time to put this knowledge in place to build a larger application.



# Part II Building an Application  构建应用程序
# CHAPTER 5 The Depot Application  程序Depot

## In this chapter, we’ll see
• incremental development;
• use cases, page flow, data; and
• priorities.

We could mess around all day hacking together simple test applications, but that won’t help us pay the bills.
So, let’s get our teeth into something meatier.
Let’s create a web-based shopping cart application called Depot.

Does the world need another shopping cart application? Nope, but that hasn’t stopped hundreds of developers from writing one.
Why should we be different?

More seriously, it turns out that our shopping cart will illustrate many of the features of Rails development.
We’ll see how to create simple maintenance pages, link database tables, handle sessions, and create forms.
Over the next twelve chapters, we’ll also touch on peripheral topics such as unit testing, security, and page layout.

## 5.1 Incremental Development  增量开发

We’ll be developing this application incrementally.
We won’t attempt to specify everything before we start coding.
Instead, we’ll work out enough of a specification to let us start and then immediately create some functionality.
We’ll try ideas, gather feedback, and continue with another cycle of minidesign and development.

This style of coding isn’t always applicable.
It requires close cooperation with the application’s users because we want to gather feedback as we go along.

We might make mistakes, or the client might discover they asked for one thing but really wanted something different.
It doesn’t matter what the reason—the earlier we discover we’ve made a mistake, the less expensive it will be to fix that mistake.
All in all, with this style of development, there’s a lot of change as we go along.

• 56

Because of this, we need to use a toolset that doesn’t penalize us for changing our minds.
If we decide we need to add a new column to a database table or change the navigation between pages, we need to be able to get in there and do it without a bunch of coding or configuration hassle.
As you’ll see, Ruby on Rails shines when it comes to dealing with change—it’s an ideal agile programming environment.

Along the way, we will be building and maintaining a corpus of tests.
These tests will ensure that the application is always doing what we intend to do.

Not only does Rails enable the creation of such tests, but it actually provides you with an initial set of tests each time you define a new controller.

On with the application.

## 5.2 What Depot Does

Let’s start by jotting down an outline specification for the Depot application.
We’ll look at the high-level use cases and sketch out the flow through the web
pages. We’ll also try working out what data the application needs (acknowledging that our initial guesses will likely be wrong).

Use Cases
A use case is simply a statement about how some entity uses a system.
Consultants invent these kinds of phrases to label things we’ve known all
along—it’s a perversion of business life that fancy words always cost more
than plain ones, even though the plain ones are more valuable.
Depot’s use cases are simple (some would say tragically so). We start off by
identifying two different roles or actors: the buyer and the seller.
The buyer uses Depot to browse the products we have to sell, select some to
purchase, and supply the information needed to create an order.
The seller uses Depot to maintain a list of products to sell, to determine the
orders that are awaiting shipping, and to mark orders as shipped. (The seller
also uses Depot to make scads of money and retire to a tropical island, but
that’s the subject of another book.)
For now, that’s all the detail we need. We could go into excruciating detail
about what it means to maintain products and what constitutes an order
ready to ship, but why bother? If there are details that aren’t obvious, we’ll
discover them soon enough as we reveal successive iterations of our work to
the customer.
Talking of getting feedback, let’s get some right now—let’s make sure our
initial (admittedly sketchy) use cases are on the mark by asking our user.

What Depot Does

• 57

Assuming the use cases pass muster, let’s work out how the application will
work from the perspectives of its various users.

Page Flow
We always like to have an idea of the main pages in our applications and to
understand roughly how users navigate between them. This early in the
development, these page flows are likely to be incomplete, but they still help
us focus on what needs doing and know how actions are sequenced.
Some folks like to mock up web application page flows using Photoshop,
Word, or (shudder) HTML. We like using a pencil and paper. It’s quicker, and
the customer gets to play too, grabbing the pencil and scribbling alterations
right on the paper.
The first sketch of the buyer flow is shown in the following figure.

Figure 7—Flow of buyer pages
It’s pretty traditional. The buyer sees a catalog page, from which he selects
one product at a time. Each product selected gets added to the cart, and the
cart is displayed after each selection. The buyer can continue shopping using


• 58

the catalog pages or check out and buy the contents of the cart. During
checkout, we capture contact and payment details and then display a receipt
page. We don’t yet know how we’re going to handle payment, so those details
are fairly vague in the flow.
The seller flow, shown in the next figure, is also fairly simple. After logging
in, the seller sees a menu letting her create or view a product or ship existing
orders. Once viewing a product, the seller may optionally edit the product
information or delete the product entirely.

Figure 8—Flow of seller pages
The shipping option is very simplistic. It displays each order that has not yet
been shipped, one order per page. The seller may choose to skip to the next
or may ship the order, using the information from the page as appropriate.
The shipping function is clearly not going to survive long in the real world,
but shipping is also one of those areas where reality is often stranger than
you might think. Overspecify it up front, and we’re likely to get it wrong. For
now let’s leave it as it is, confident that we can change it as the user gains
experience using our application.

Data
Finally, we need to think about the data we’re going to be working with.

What Depot Does

• 59

Notice that we’re not using words such as schema or classes here. We’re also
not talking about databases, tables, keys, and the like. We’re simply talking
about data. At this stage in the development, we don’t know whether we’ll
even be using a database.
Based on the use cases and the flows, it seems likely that we’ll be working
with the data shown in the following figure. Again, using pencil and paper
seems a whole lot easier than some fancy tool, but use whatever works for
you.

Figure 9—Initial guess at application data
Working on the data diagram raised a couple of questions.
As the user buys items, we’ll need somewhere to keep the list of products they bought, so we added a cart.
But apart from its use as a transient place to keep this product list, the cart seems to be something of a ghost—we couldn’t find anything meaningful to store in it.
To reflect this uncertainty, we put a question mark inside the cart’s box in the diagram.
We’re assuming this uncertainty will get resolved as we implement Depot.

Coming up with the high-level data also raised the question of what information should go into an order.
Again, we chose to leave this fairly open for now—we will refine this further as we start showing our early iterations to the customer.

Finally, you might have noticed that we’ve duplicated the product’s price in the line item data.
Here we’re breaking the “initially, keep it simple” rule slightly, but it’s a transgression based on experience.
If the price of a product changes, that price change should not be reflected in the line item price of • 60 General Recovery Advice Everything in this book has been tested.
If you follow along with this scenario precisely, using the recommended version of Rails and SQLite3 on Linux, Mac OS X, or Windows, then everything should work as described.
However, deviations from this path may occur.
Typos happen to the best of us, and not only are side explorations possible, but they are positively encouraged.
Be aware that this might lead you to strange places.
Don’t be afraid: specific recovery actions for common problems appear in the specific sections where such problems often occur.
A few additional general suggestions are included here.

You should only ever need to restart the server in the few places where doing so is noted in the book.
But if you ever get truly stumped, restarting the server might be worth trying.

A “magic” command worth knowing, explained in detail in Part III, is rake db:migrate:redo.
It will undo and reapply the last migration.
If your server won’t accept some input on a form, refresh the form on your browser and resubmit it.


currently open orders, so each line item needs to reflect the price of the product at the time the order was made.

Again, at this point we’ll double-check with the customer that we’re still on
the right track. (The customer was most likely sitting in the room with us
while we drew these three diagrams.)

## 5.3 Let’s Code
So, after sitting down with the customer and doing some preliminary analysis, we’re ready to start using a computer for development! We’ll be working from our original three diagrams, but the chances are pretty good that we’ll be throwing them away fairly quickly—they’ll become outdated as we gather feedback.
Interestingly, that’s why we didn’t spend too long on them; it’s easier to throw something away if you didn’t spend a long time creating it.

In the chapters that follow, we’ll start developing the application based on our current understanding.
However, before we turn that page, we have to answer just one more question:
what should we do first?

We like to work with the customer so we can jointly agree on priorities.
In this case, we’d point out to her that it’s hard to develop anything else until we have some basic products defined in the system, so we suggest spending a couple of hours getting the initial version of the product maintenance functionality up and running.
And, of course, the client would agree.


# CHAPTER 6 Task A: Creating the Application 创建应用程序
## In this chapter, we’ll see
• creating a new application,
• configuring the database,
• creating models and controllers,
• adding a stylesheet, and
• updating a layout and a view.

Our first development task is to create the web interface that lets us maintain our product information—create new products, edit existing products, delete unwanted ones, and so on.
We’ll develop this application in small iterations, where small means “measured in minutes.” Typically, our iterations involve multiple steps, as in iteration C, which has steps C1, C2, C3, and so on.
In this case, the iteration has two steps.
Let’s get started.


## 6.1 Iteration A1: Creating the Products Maintenance Application 创建商品维护的应用程序
### 数据库
At the heart of the Depot application is a database.
应用程序的核心是数据库。
Getting this installed and configured and tested before proceeding further will prevent a lot of headaches.
等到数据库安装、配置并测试完毕，再继续开发其他组件，这样可以许多烦恼。
If you aren’t sure what you want, take the defaults, and it will go easy.
在安装、配置数据库时，如果不能确定想要什么，那么就选择默认值，这样会容易许多。
If you know what you want, Rails makes it easy for you to describe your configuration.
如果已经知道想要什么，在Rails中可以很简单地描述配置内容。

### 6.1.1 Creating a Rails Application
In Section 2.1, Creating a New Application, on page 15, we saw how to create a new Rails application.
We’ll do the same thing here.
Go to a command prompt, and type rails new followed by the name of our project.
In this case, our project is called depot, so make sure you are not inside an existing application directory and type this:

    work> rails new depot

<kinder:note> 在防火长城这下，这个命令需要分几步完成：

    $ rails new depot --skip-bundle
    $ cd depot
    $ vi Gemfile   # 第一行改为http://ruby.taobao.org
    $ bundle install

We see a bunch of output scroll by.
When it has finished, we find that a new directory, depot, has been created.
That’s where we’ll be doing our work.

     work> cd depot
     depot> ls -p
     app/ config/    db/      Gemfile.lock  log/     Rakefile     test/ vendor/
     bin/ config.ru  Gemfile  lib/          public/  README.rdoc  tmp/

Windows users will need to use dir /w instead of ls -p.

• 62

### 6.1.2 Creating the Database  创建数据库
For this application, we’ll use the open source SQLite database (which you’ll need if you’re following along with the code).
We’re using SQLite version 3 here.

SQLite 3 is the default database for Rails development and was installed along with Rails in Chapter 1, Installing Rails, on page 3.
With SQLite 3 there are no steps required to create a database, and there are no special user accounts or passwords to deal with.
So, now you get to experience one of the benefits of going with the flow (or, convention over configuration, as Rails folks say...ad nauseam).

If it’s important to you to use a database server other than SQLite 3, the commands you’ll need to create the database and grant permissions will be different.
You will find some helpful hints in the Getting Started Rails Guide.1 
1.  http://guides.rubyonrails.org/getting_started.html#configuring-a-database

### 6.1.3 Generating the Scaffold  生成脚手架
In Figure 9, Initial guess at application data, on page 59, we sketched out the basic content of the products table.
Now let’s turn that into reality.

We need to create a database table and a Rails model that lets our application use that table, a number of views to make up the user interface, and a controller to orchestrate the application.

name mapping ↪ on page 270

So, let’s create the model, views, controller, and migration for our products table.
With Rails, you can do all that with one command by asking Rails to generate what is known as a scaffold for a given model.
Note that on the command line that follows, we use the singular form, Product.
In Rails, a model is automatically mapped to a database table whose name is the plural form of the model’s class.
In our case, we asked for a model called Product, so Rails associated it with the table called products.
(And how will it find that table?
The development entry in config/database.yml tells Rails where to look for it.
For SQLite 3 users, this will be a file in the db directory.) 
Note that command is too wide to fit comfortably on the page.
To enter a command on multiple lines, simply put a backslash as the last character on all but the last line, and you’ll be prompted for more input.
Windows users will need to substitute a caret (^) for the backslash.

     depot> rails generate scaffold Product \
     title:string description:text image_url:string price:decimal
     invoke active_record
     create db/migrate/20121130000001_create_products.rb
     create  app/models/product.rb
     invoke  test_unit
     create  test/models/product_test.rb
     create  test/fixtures/products.yml
     invoke  resource_route
     route   resources :products
     invoke  jbuilder_scaffold_controller
     create  app/controllers/products_controller.rb
     invoke  erb
     create  app/views/products
     create  app/views/products/index.html.erb
     create  app/views/products/edit.html.erb
     create  app/views/products/show.html.erb
     create  app/views/products/new.html.erb
     create  app/views/products/_form.html.erb
     invoke  test_unit
     create  test/controllers/products_controller_test.rb
     invoke  helper
     create  app/helpers/products_helper.rb
     invoke  test_unit
     create  test/helpers/products_helper_test.rb
     invoke  jbuilder
     exist   app/views/products
     create  app/views/products/index.json.jbuilder
     create  app/views/products/show.json.jbuilder
     invoke  assets
     invoke  coffee
     create  app/assets/javascripts/products.js.coffee
     invoke  scss
     create  app/assets/stylesheets/products.css.scss
     invoke  scss
     create  app/assets/stylesheets/scaffolds.css.scss

• 63

The generator creates a bunch of files.
The one we’re interested in first is the migration one, namely, 20121130000001_create_products.rb.

A migration represents a change we want to make to the data, expressed in a source file in database-independent terms.
These changes can update both the database schema and the data in the database tables.
We apply these migrations to update our database, and we can unapply them to roll our database back.
We have a whole section on migrations starting in Chapter 22, Migrations, on page 367.
For now, we’ll just use them without too much more comment.

The migration has a UTC-based timestamp prefix (20121130000001), a name (create_products), and a file extension (.rb, because it’s Ruby code).

The timestamp prefix you will see will be different.
In fact, the timestamps used in this book are clearly fictitious.
Typically your timestamps will not be consecutive; instead, they will reflect the time the migration was created.

• 64

### 6.1.4 Applying the Migration  实施迁移
Although we have already told Rails about the basic data types of each
property, let’s refine the definition of the price to have eight digits of significance and two digits after the decimal point.

     Download rails40/depot_a/db/migrate/20121130000001_create_products.rb
     class CreateProducts < ActiveRecord::Migration
       def change
         create_table :products do |t|
           t.string :title
           t.text :description
           t.string :image_url
       ➤   t.decimal :price, precision: 8, scale: 2
           t.timestamps
         end
       end
     end

Now that we are done with our changes, we need to get Rails to apply this migration to our development database.
We do this using the rake command.

Rake is like having a reliable assistant on hand all the time: you tell it to do some task, and that task gets done.
In this case, we’ll tell Rake to apply any unapplied migrations to our database.

     depot> rake db:migrate
     == CreateProducts: migrating =================================================
     -- create_table(:products)
     -> 0.0027s
     == CreateProducts: migrated (0.0023s) ========================================

And that’s it.
Rake looks for all the migrations not yet applied to the database and applies them.
In our case, the products table is added to the database defined by the development section of the database.yml file.

OK, all the groundwork has been done.
We set up our Depot application as a Rails project.
We created the development database and configured our application to be able to connect to it.
We created a products controller and a Product model and used a migration to create the corresponding products table.

And a number of views have been created for us.
It’s time to see all this in action.

### 6.1.5 Seeing the List of Products 查看商品清单

With three commands we have created an application and a database (or a table inside an existing database, if you chose something besides SQLite 3).

• 65

Before we worry too much about just what happened behind the scenes here, let’s try our shiny new application.

First, we’ll start a local server, supplied with Rails.

     depot> rails server
     => Booting WEBrick
     => Rails 4.0.0 application starting in development on http://0.0.0.0:3000
     => Run `rails server -h` for more startup options
     => Ctrl-C to shutdown server
     [2013-04-18 17:45:38] INFO WEBrick 1.3.1
     [2013-04-18 17:45:38] INFO ruby 2.0.0 (2013-02-24) [x86_64-linux]
     [2013-04-18 17:45:43] INFO WEBrick::HTTPServer#start: pid=24649 port=3000


Just as it did with our demo application on page 15, this command starts a web server on our local host, port 3000.
If you get an error saying Address already in use when you try to run the server, that simply means you already have a Rails server running on your machine.
If you’ve been following along with the examples in the book, that might well be the “Hello, World!” application from CHAPTER 4.
Find its console, and kill the server using Ctrl-C.
If you are running on Windows, you may see the prompt Terminate batch job (Y/N)?.
If so, respond with y.

Let’s connect to our application.
Remember, the URL we give to our browser contains both the port number (3000) and the name of the controller in lowercase (products).

That’s pretty boring. It’s showing us an empty list of products. Let’s add some.
Click the New Product link, and a form should appear as shown in Figure 10, Form for adding new products, on page 66.

These forms are simply HTML templates, just like the ones you created in Section 2.2, Hello, Rails!, on page 17.
In fact, we can modify them.
Let’s change the number of lines in the description field.

• 66

Figure 10—Form for adding new products


     Download rails40/depot_a/app/views/products/_form.html.erb
     <%= form_for(@product) do |f| %>
     <% if @product.errors.any? %>
       <div id="error_explanation">
         <h2><%= pluralize(@product.errors.count, "error") %>
         prohibited this product from being saved:</h2>
         <ul>
         <% @product.errors.full_messages.each do |msg| %>
           <li><%= msg %></li>
         <% end %>
         </ul>
       </div>
     <% end %>
     
       <div class="field">
         <%= f.label :title %><br>
         <%= f.text_field :title %>
       </div>
       <div class="field">
         <%= f.label :description %><br>
     ➤   <%= f.text_area :description, rows: 6 %>
       </div>
       <div class="field">
         <%= f.label :image_url %><br>
         <%= f.text_field :image_url %>
       </div>

• 67

       <div class="field">
         <%= f.label :price %><br>
         <%= f.text_field :price %>
       </div>
       <div class="actions">
         <%= f.submit %>
       </div>
       <% end %>

We will explore this more in Chapter 8, Task C:
Catalog Display, on page 91.

But for now, we’ve adjusted one field to taste, so let’s fill it in.

Figure 11—Creating our first product

Click the Create button, and you should see the new product was successfully created.
If you now click the Back link, you should see the new product in the list, as shown in Figure 12, See the product as it appears in the database., on page 68.

Perhaps it isn’t the prettiest interface, but it works, and we can show it to our client for approval.
She can play with the other links (showing details, editing existing products, and so on).
We explain to her that this is only a first step—we know it’s rough, but we wanted to get her feedback early.
(And four commands probably count as early in anyone’s book.) • 68 Figure 12—See the product as it appears in the database.

At this point, you’ve accomplished a lot with only four commands.
Before we move on, let’s try one more command.

    rake test

Included in the output should be two lines that each say 0 failures, 0 errors.
This is for the model and controller tests that Rails generates along with the scaffolding.
They are minimal at this point, but simply knowing that they are there and that they pass should give you confidence.
As you proceed through these chapters in Part II, you are encouraged to run this command frequently because it will help you spot and track down errors.
We will cover this more in Section 7.2, Iteration B2:
Unit Testing of Models, on page 82.

Note that if you’ve used a database other than SQLite3, this step may have failed.
Check your database.yml file, and see the notes in Section 23.1, A StandAlone Application Using Active Record, on page 385.


## 6.2 Iteration A2: Making Prettier Listings  美化商品清单
### 6.2.1 导入种子数据
Our customer has one more request (customers always seem to have one more request, don’t they?).
The listing of all the products is ugly.
Can we “pretty it up” a bit?
And, while we’re in there, can we also display the product image along with the image URL?

We’re faced with a dilemma here.
As developers, we’re trained to respond to these kinds of requests with a sharp intake of breath, a knowing shake of the head, and a murmured “You want what?” At the same time, we also like to show off a bit.
In the end, the fact that it’s fun to make these kinds of changes using Rails wins out, and we fire up our trusty editor.

• 69

Before we get too far, though, it would be nice if we had a consistent set of test data to work with.
We could use our scaffold-generated interface and type data in from the browser.
However, if we did this, future developers working on our codebase would have to do the same.
And, if we were working as part of a team on this project, each member of the team would have to enter their own data.
It would be nice if we could load the data into our table in a more controlled way.
It turns out that we can.
Rails has the ability to import seed data.

To start, we simply modify the file in the db directory named seeds.rb.
We then add the code to populate the products table.
This uses the create!() method of the Product model.
The following is an extract from that file.
Rather than type the file by hand, you might want to download the file from the sample code available online.2 download ↪ on page xvi While you’re there, copy the images3 into the app/assets/images directory in your application.
Be warned: this seeds.rb script removes existing data from the products table before loading the new data.
You might not want to run it if you’ve just spent several hours typing your own data into your application!

     Download rails40/depot_a/db/seeds.rb
     Product.delete_all
     # . . .
     Product.create!(title: 'Programming Ruby 1.9 & 2.0',
     description:
     %{<p>
     Ruby is the fastest growing and most exciting dynamic language
     out there. If you need to get working programs delivered fast,
     you should add Ruby to your toolbox.
     </p>},
     image_url: 'ruby.jpg',
     price: 49.95)
     # . . .

(Note that this code uses %{…}.
This is an alternative syntax for doublequoted string literals, convenient for use with long strings.
Note also that because it uses Rails’ create!() method, it will raise an exception if records cannot be inserted because of validation errors.) 
To populate your products table with test data, run the following command:

    depot> rake db:seed

2.  http://media.pragprog.com/titles/rails4/code/rails40/depot_a/db/seeds.rb
3.  http://media.pragprog.com/titles/rails4/code/rails40/depot_a/app/assets/images/

• 70

### 6.2.2 整理商品清单
Now let’s get the product listing tidied up.
There are two pieces to this: defining a set of style rules and connecting these rules to the page by defining an HTML class attribute on the page.

We need somewhere to put our style definitions.
As you will continue to find with Rails, there is a convention for this, and the generate scaffold command that you previously issued has already laid all of the necessary groundwork.

As such, we can proceed to fill in the currently empty stylesheet products.css.scss in the directory app/assets/stylesheets.

     Download rails40/depot_a/app/assets/stylesheets/products.css.scss
     // Place all the styles related to the Products controller here.
     // They will automatically be included in application.css.
     // You can use Sass (SCSS) here: http://sass-lang.com/
     ➤  .products {
     ➤    table {
     ➤      border-collapse: collapse;
     ➤    }
     ➤
     ➤    table tr td {
     ➤      padding: 5px;
     ➤      vertical-align: top;
     ➤    }
     ➤
     ➤    .list_image {
     ➤      width: 60px;
     ➤      height: 70px;
     ➤    }
     ➤
     ➤    .list_description {
     ➤      width: 60%;
     ➤
     ➤     dl {
     ➤       margin: 0;
     ➤     }
     ➤
     ➤    dt {
     ➤      color: #244;
     ➤      font-weight: bold;
     ➤      font-size: larger;
     ➤    }
     ➤
     ➤    dd {
     ➤      margin: 0;
     ➤    }
     ➤  }
     ➤
     ➤  .list_actions {
     ➤      font-size: x-small;
     ➤      text-align: right;
     ➤      padding-left: 1em;
     ➤    }
     ➤
     ➤    .list_line_even {
     ➤      background: #e0f8f8;
     ➤    }
     ➤
     ➤    .list_line_odd {
     ➤      background: #f8b0f8;
     ➤    }
     ➤  }

• 71

If you choose to download this file, make sure that the timestamp on the file is updated.
如果你选择下载这个文件，要确保更新文件的时间戳。
If the timestamp is not updated, Rails won’t pick up the changes until the server is restarted.
如果时间戳没有被更新，Rails将不会处理其中的变更，除非服务器被重启。
You can update the timestamp by going into your favorite editor and saving it.
你可以通过在编辑器上打开并保存来更新时间戳。
On Mac OS X and Linux, you can use the touch command.

Look closely at this stylesheet and you will see that CSS rules are nested, in that the rule for dl is defined inside the rule for .list_description, which itself is defined inside the rule for products.
仔细看看样式表，你将看到CSS规则被嵌套了，按照那个规则，dl被定义在`.list_描述`里面，而`.list_描述`则被定义在product里面。
This tends to make rules less repetitive and therefore easier to read, write, understand, and maintain.
这样使得规则减少了重复，因此变得易读、易写、易懂、易于维护。


At this point you are familiar with files ending with erb being preprocessed for embedded Ruby expressions and statements.

If you note that this file ends with scss, you might guess that this means that the file is preprocessed as Sassy CSS 4 before being served as css.
And you would be right!
4.  http://sass-lang.com/

Again, just like ERB, SCSS does not interfere with writing correct CSS.
What SCSS does is provide additional syntax that makes your stylesheets easier to author and easier to maintain.
All of this is converted for you by SCSS to standard CSS that your browser understands.
You can find out more about SCSS in Pragmatic Guide to Sass [CC11].

Finally, we will need to define the products class used by this stylesheet.
If you look at the .html.erb files we’ve created so far, you won’t find any reference to stylesheets.
You won’t even find the HTML `<head>` section where such references would normally live.
Instead, Rails keeps a separate file that is used to create a standard page environment for the entire application.
This file, called application.html.erb, is a Rails layout and lives in the layouts directory.

• 72

     Download rails40/depot_a/app/views/layouts/application.html.erb
     <!DOCTYPE html>
     <html>
       <head>
         <title>Depot</title>
         <%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true %>
         <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
         <%= csrf_meta_tags %>
       </head>
     ➤ <body class='<%= controller.controller_name %>'>  
         <%= yield %>
       </body>
     </html>

<kinder:note> 这一行的用意是让程序全局布局的body根据控制器而变化。
<kinder:note> 注意修改的这一行，<%...%>被单引号括了起来，因为单引号在html里面不是什么特殊符号。
Because Rails loads all of the stylesheets all at once, we need a convention to limit controller-specific rules to pages associated with that controller.
<kinder:note> 因为Rails一次性导入所有的样式表，我们需要一个约定来为页面限制特定控制器的规则。
Using the controller_name as a class name is an easy way to accomplish that and is what we have done here.
<kinder:note> 用一个控制器名称作为类名，是一个简易的实现方式，这也是我们刚才所做的事情。

Now that we have the stylesheets all in place, we will use a simple table-based template, editing the file index.html.erb in app/views/products and replacing the scaffold-generated view.
<kinder:note> 现在既然我们有了样式表，我们将使用一个简单的基于表格的模板，编辑在app/views/products里的index.html.erb。
<kinder:note> 这一句中译本已有。

     Download rails40/depot_a/app/views/products/index.html.erb
     <h1>Listing products</h1>
     <table>
     <% @products.each do |product| %>
       <tr class="<%= cycle('list_line_odd', 'list_line_even') %>">
         <td>
         <%= image_tag(product.image_url, class: 'list_image') %>
         </td>
         <td class="list_description">
           <dl>
             <dt><%= product.title %></dt>
             <dd><%= truncate(strip_tags(product.description), length: 80) %></dd>
           </dl>
         </td>
         <td class="list_actions">
           <%= link_to 'Show', product %><br/>
           <%= link_to 'Edit', edit_product_path(product) %><br/>
           <%= link_to 'Destroy', product, method: :delete, data: { confirm: 'Are you sure?' } %>
         </td>
       </tr>
     <% end %>
     </table>
     <br />
     <%= link_to 'New product', new_product_path %>

• 73

<kinder:note> 下面是haml版本：
<kinder:note> 不得不感叹它缩进严密。

    %h1 Listing products
    %table
      -@products.each do |product|
        %tr{calss: cycle('list_line_odd', 'list_line_even')}
          %td=image_tag(product.image_url, class: 'list_image')
          %td.list_description
            %dl
              %dt=product.title
              %dd=truncate(strip_tags(product.description), length: 80)
          %td.list_actions 
            = link_to 'Show', product
            %br 
            = link_to 'Edit', edit_product_path(product) 
            %br 
            = link_to 'Destroy', product, method: :delete, data: { confirm: 'Are you sure?' }
    %br
    = link_to 'New product', new_product_path

Even this simple template uses a number of built-in Rails features.
即使这只是一个简单的模板，也用到了不少Rails内置的特性：

• The rows in the listing have alternating background colors.
  清单的行背景颜色是交替变化。
The Rails helper method called cycle() does this by setting the CSS class of each row to either list_line_even or list_line_odd, automatically toggling between the two style names on successive lines.
为了完成这件事，Rails的帮助函数cycle通过将每行的CSS类设置为`list_line_even`或`list_line_odd`，并在两个连续行之间自动切换样式名称。

• The truncate() helper is used to display just the first eighty characters of the description.
truncate这个帮助函数用来显示描述字段的前80个字符。
But before we call truncate(), we called strip_tags() in order to remove the HTML tags from the description.
但在调用truncate()之前，需要调用函数strip_tags()去除描述字段中的HTML标签。

• Look at the link_to 'Destroy' line.
注意link_to 'Destroy'这一行。
See how it has the parameter data: { confirm: 'Are you sure?' }. 
看看它如何使用参数data: { confirm: 'Are you sure?' }。
If you click this link, Rails arranges for your browser to pop up a dialog box asking for confirmation before following the link and deleting the product.
如果单击这个链接，Rails会让浏览器弹出一个对话框，要求确认删除该商品。
(Also, see the sidebar on page 75 for some inside scoop on this action.) 
（另外，可以在当前页侧边栏里面看到这个行为的一些内幕消息。）

We loaded some test data into the database, we rewrote the index.html.erb file that displays the listing of products, we filled in the products.css.scss stylesheet, and that stylesheet was loaded into our page by the layout file application.html.erb.
我们将测试数据加载到数据库中，改写了显示商品清单的文件index.html.erb，填充了product.css.scss样式表，该样式被被布局文件application.html.erb导入我们的页面中。

Now, let’s bring up a browser and point to http://localhost:3000/products; the resulting product listing might look something like Figure 13, A slightly prettier view, on page 74.
现在，打开浏览器输入网址http://localhost:3000/products；最终的商品清单页面可能看起来就像下面这样。

So, we proudly show our customer her new product listing, and she’s pleased.
我们自豪地给客户展示了新的商品清单网页，客户还是很满意的。
Now it is time to create the storefront.
现在是时候创建店面了。


## What We Just Did
In this chapter, we laid the groundwork for our store application.
• We created a development database.
• We used a migration to create and modify the schema in our development
database.
• We created the products table and used the scaffold generator to write an application to maintain it.
• We updated an application-wide layout as well as a controller-specific
view in order to show a list of products.
What we’ve done did not require much effort, and it got us up and running quickly.
Databases are vital to this application but need not be scary—in fact, • 74 Figure 13—A slightly prettier view in many cases we can defer the selection of the database to later and simply get started using the default that Rails provides.

Getting the model right is more important at this stage.
As we will soon see, simple selection of data types doesn’t always fully capture the essence of all the properties of the model, even in this small application, so that’s what we will tackle next.

==============================
What’s with method: :delete?

You may have noticed that the scaffold-generated Destroy link includes the parameter method: :delete.
This determines which method is called in the ProductsController class and also affects which HTTP method is used.

Browsers use HTTP to talk with servers.
HTTP defines a set of verbs that browsers can employ and defines when each can be used.
A regular hyperlink, for example, uses an HTTP GET request.
A GET request is defined by HTTP to be used to retrieve data; it isn’t supposed to have any side effects.
Using this parameter in this way indicates that an HTTP DELETE method should be used for this hyperlink.
Rails uses this information to determine which action in the controller to route this request to.

Note that when used within a browser, Rails will substitute the POST HTTP method for PUT, PATCH, and DELETE methods and in the process tack on an additional parameter so that the router can determine the original intent.
Either way, the request will not be cached or triggered by web crawlers.

==============================

## Playtime
Here’s some stuff to try on your own:
• If you’re feeling frisky, you can experiment with rolling back the migration.
Just type the following:

    depot> rake db:rollback

Your schema will be transported back in time, and the products table will be gone.
Calling rake db:migrate again will re-create it.
You will also want to reload the seed data.
More information can be found in Chapter 22, Migrations, on page 367.

• We mentioned version control in Version Control, on page 9, and now would be a great point at which to save your work.
Should you happen to choose Git (highly recommended, by the way), there is a tiny bit of Iteration A2:
 • 75 
Making Prettier Listings configuration you need to do first; basically, all you need to do is provide your name and email address.

    depot> git config --global --add user.name "Sam Ruby"
    depot> git config --global --add user.email rubys@intertwingly.net

You can verify the configuration with the following command:

    depot> git config --global --list

Rails also provides a file named .gitignore, which tells Git which files are
not to be version controlled.

     Download rails40/depot_a/.gitignore
     # See http://help.github.com/ignore-files/ for more about ignoring files.
     #
     # If you find yourself ignoring temporary files generated by your text editor
     # or operating system, you probably want to add a global ignore instead:
     # git config --global core.excludesfile '~/.gitignore_global'
     # Ignore bundler config.
     /.bundle
     # Ignore the default SQLite database.
     /db/*.sqlite3
     /db/*.sqlite3-journal
     # Ignore all logfiles and tempfiles.
     /log/*.log
     /tmp

• 76

Note that because this filename begins with a dot, Unix-based operating systems won’t show it by default in directory listings.
Use ls -a to see it.

At this point, you are fully configured.
The only tasks that remain are to initialize a repository, add all the files, and commit them with a commit message.

    depot> git init
    depot> git add .
    depot> git commit -m "Depot Scaffold"

This may not seem very exciting at this point, but it does mean you are more free to experiment.
Should you overwrite or delete a file that you didn’t mean to, you can always get back to this point by issuing a single command.

depot> git checkout .


# CHAPTER 7 Task B: Validation and Unit Testing 验证和单元测试
## In this chapter, we’ll see
• performing validation and error reporting and
• unit testing.

At this point, we have an initial model for a product, as well as a complete
maintenance application for this data provided for us by Rails scaffolding. In
this chapter, we are going to focus on making the model more bulletproof—as
in, making sure that errors in the data provided never get committed to the
database—before we proceed to other aspects of the Depot application in
subsequent chapters.

## 7.1 Iteration B1: Validating! 验证
While playing with the results of iteration A1, our client noticed something.
If she entered an invalid price or forgot to set up a product description, the application happily accepted the form and added a line to the database.

Although a missing description is embarrassing, a price of $0.00 actually costs her money, so she asked that we add validation to the application.
No product should be allowed in the database if it has an empty title or description field, an invalid URL for the image, or an invalid price.

So, where do we put the validation? 
The model layer is the gatekeeper between the world of code and the database.
Nothing to do with our application comes out of the database or gets stored into the database that doesn’t first go through the model.
This makes models an ideal place to put validations; it doesn’t matter whether the data comes from a form or from some programmatic manipulation in our application.
If a model checks it before writing to the database, then the database will be protected from bad data.

Let’s look at the source code of the model class (in app/models/product.rb):

     class Product < ActiveRecord::Base
     end

• 78

Adding our validation should be fairly clean.
Let’s start by validating that the text fields all contain something before a row is written to the database.
We do this by adding some code to the existing model.

    validates :title, :description, :image_url, presence: true

The validates() method is the standard Rails validator.
It will check one or more model fields against one or more conditions.

presence: true tells the validator to check that each of the named fields is present and its contents are not empty.
In the following figure we can see what happens if we try to submit a new product with none of the fields filled in.
It’s pretty impressive: the fields with errors are highlighted, and the errors are summarized in a nice list at the top of the form.
That’s not bad for one line of code.
You might also have noticed that after editing and saving the product.rb file you didn’t have to restart the application to test your changes—the same reloading that caused Rails to notice the earlier change to our schema also means it will always use the latest version of our code.

Figure 14—Validating that fields are present

• 79

We’d also like to validate that the price is a valid, positive number.
We’ll use the delightfully named numericality() option to verify that the price is a valid number.
We also pass the rather verbosely named :greater_than_or_equal_to option a value of 0.01.

    validates :price, numericality: {greater_than_or_equal_to: 0.01}

Now, if we add a product with an invalid price, the appropriate message will appear, as shown in the following figure:

Figure 15—The price fails validation.
Why test against 1 cent, rather than zero? Well, it’s possible to enter a number such as 0.001 into this field.
Because the database stores just two digits after the decimal point, this would end up being zero in the database, even though it would pass the validation if we compared against zero.
Checking that the number is at least 1 cent ensures only correct values end up being stored.

• 80

We have two more items to validate.
First, we want to make sure each product has a unique title.
One more line in the Product model will do this.
The uniqueness validation will perform a simple check to ensure that no other row in the products table has the same title as the row we’re about to save.

    validates :title, uniqueness: true

Lastly, we need to validate that the URL entered for the image is valid.
We’ll do this using the format option, which matches a field against a regular expression.
For now we’ll just check that the URL ends with one of .gif, .jpg, or .png.
regular expression ↪ on page 42

    validates :image_url, allow_blank: true, format: { with: %r{\.(gif|jpg|png)\Z}i, message: 'must be a URL for GIF, JPG or PNG image.' }

Note that we used the allow_blank option to avoid getting multiple error messages when the field is blank.

Later, we’d probably want to change this form to let the user select from a list of available images, but we’d still want to keep the validation to prevent malicious folks from submitting bad data directly.

So, in a couple of minutes we’ve added validations that check the following:

• The field’s title, description, and image URL are not empty.
• The price is a valid number not less than $0.01.
• The title is unique among all products.
• The image URL looks reasonable.

Your updated Product model should look like this:

    Download rails40/depot_b/app/models/product.rb
    class Product < ActiveRecord::Base
      validates :title, :description, :image_url, presence: true
      validates :price, numericality: {greater_than_or_equal_to: 0.01}
      validates :title, uniqueness: true
      validates :image_url, allow_blank: true, format: {
        with: %r{\.(gif|jpg|png)\Z}i,
        message: 'must be a URL for GIF, JPG or PNG image.'
      }
    end

Nearing the end of this cycle, we ask our customer to play with the application, and she’s a lot happier.
It took only a few minutes, but the simple act of adding validation has made the product maintenance pages seem a lot more solid.

• 81

Before we move on, we once again try our tests.

    rake test
    <kinder:note> 下面详情：
    Run options: --seed 62558
    
    # Running:
    
    F.....F
    
    Finished in 0.876478s, 7.9865 runs/s, 11.4093 assertions/s.
    
      1) Failure:
    ProductsControllerTest#test_should_create_product [/home/liqixun/docs/liqixun/desktop/ror_project/depot/test/controllers/products_controller_test.rb:20]:
    "Product.count" didn't change by 1.
    Expected: 3
      Actual: 2
    
    
      2) Failure:
    ProductsControllerTest#test_should_update_product [/home/liqixun/docs/liqixun/desktop/ror_project/depot/test/controllers/products_controller_test.rb:39]:
    Expected response to be a <redirect>, but was <200>
    
    7 runs, 10 assertions, 2 failures, 0 errors, 0 skips

Uh-oh.
This time we see failures.
<kinder:note> 这回我们看到失败了。
Two, actually—one in should create product and one in should update product.
<kinder:note> 两个失败，一个在创建产品时，一个在更新商品时。
Clearly something we did caused something to do with the creation and updating of products to fail.
<kinder:note> 很明显，我们的修改导致这两个失败。
This isn’t all that surprising.
这并不令人惊奇。
After all, when you think about it, isn’t that the whole point of validation?
你想想看，这不就是验证的目的吗？
The solution is to give valid test data in test/controllers/products_controller_test.rb.
解决方法是，在test/controllers/products_controller_test.rb文件中给出有效的测试数据。

     Download rails40/depot_b/test/controllers/products_controller_test.rb
     require 'test_helper'
     class ProductsControllerTest < ActionController::TestCase
       setup do
         @product = products(:one)
    ➤    @update = { 
    ➤      title: 'Lorem Ipsum',
    ➤      description: 'Wibbles are fun!',
    ➤      image_url: 'lorem.jpg',
    ➤      price: 19.95
    ➤    }
       end
       test "should get index" do
         get :index
         assert_response :success
         assert_not_nil assigns(:products)
       end
       test "should get new" do
         get :new
         assert_response :success
       end
     
       test "should create product" do
         assert_difference('Product.count') do
     ➤     post :create, product: @update
           # <kinder:note> 原本是：
           # post :create, product: { description: @product.description, image_url: @product.image_url, price: @product.price, title: @product.title }
         end
         assert_redirected_to product_path(assigns(:product))
       end
     
       # ...
     
       test "should update product" do
     ➤   patch :update, id: @product, product: @update
           # <kinder:note> 原本是：
           # patch :update, id: @product, @product: { description: @product.description, image_url: @product.image_url, price: @product.price, title: @product.title }
         assert_redirected_to product_path(assigns(:product))
       end
       # ...
     end

• 82

After making this change, we rerun the tests, and they report that all is well.
做出这些修改之后，重新运行测试，结果一切征程。
But all that means is that we didn’t break anything.
但这只是说明我们并没有破坏什么。
We need to do more than that.
我们要多做一些。
We need to make sure the validation code that we just added not only works now but will continue to work as we make further changes.
需要确保的是，刚刚添加的验证代码不仅仅现在能工作，而且在进一步修改后也能正常运行。
We’ll cover controller tests in more detail in Section 8.4, Iteration C4: Functional Testing of Controllers, on page 101.
8.4节会更详细地介绍功能测试。
As for now, it is time for us to write some unit tests.
至于现在，是时候来写一些单元测试了。

## 7.2 Iteration B2: Unit Testing of Models 模型的单元测试
One of the real joys of the Rails framework is that it has support for testing baked right in from the start of every project.
Rails框架的真正乐趣之一是，从每个项目开始时Rails就支持生成相应的测试。
As we have seen, from the moment you create a new application using the rails command, Rails starts generating a test infrastructure for you.
正如所见，从使用rails命令创建一个新的应用程序那一刻起，Rails就开始生成一个基本的测试环境。

Let’s take a peek inside the models subdirectory to see what’s already there:
下面看看unit的子目录中已经有了什么东西：

     depot> ls test/models
     product_test.rb

product_test.rb is the file that Rails created to hold the unit tests for the model we created earlier with the generate script.
Rials创建product_test.rb这个文件用来保存之前用脚本generate生成的模型单元测试。
This is a good start, but Rails can help us only so much.
这是个好开头，但Rials只能帮助哦我们这么多了。

Let’s see what kind of test goodies Rails generated inside test/models/product_test.rb
when we generated that model:

     Download rails40/depot_a/test/models/product_test.rb
     require 'test_helper'
     class ProductTest < ActiveSupport::TestCase
     # test "the truth" do
     #   assert true
     # end
     end

The generated ProductTest is a subclass of ActiveSupport::TestCase.
这个生成的ProductTest是ActiveSupport::TestCase的子类。
The fact that ActiveSupport::TestCase is a subclass of the MiniTest::Unit::TestCase class tells us that Rails generates tests based on the MiniTest 1 framework that comes preinstalled with Ruby.
而ActiveSupport::TestCase又是MiniTest::Unit::TestCase的子类，这说明Rails生成的测试是基于MiniTest框架的，这个框架是ruby预制的。
This is good news because it means if we’ve already been testing our Ruby programs with MiniTest tests (and why wouldn’t we be?), then we can build on that knowledge to test Rails applications.
这是个好消息，因为这意味着如果已经开始使用MiniTest测试来测试我们的ruby程序（为什么不呢？），我们可以在这个基础上来测试Rails应用程序。
If you’re new to MiniTest, don’t worry.
如果你不了解MiniTest，别担心。
We’ll take it slow.
我们会慢慢来的。
1. http://www.ruby-doc.org/stdlib-2.0/libdoc/minitest/unit/rdoc/MiniTest.html

• 83

Inside this test case, Rails generated a single commented-out test called "the truth".
The test...do syntax may seem surprising at first, but here Active Support is combining a class method, optional parentheses, and a block to make defining a test method just the tiniest bit simpler for you.
Sometimes it is the little things that make all the difference.

The assert line in this method is an actual test.
It isn’t much of one, though—all it does is test that true is true.
Clearly, this is a placeholder, one that is intended to be replaced by your actual tests.

### A Real Unit Test  真正的单元测试
Let’s get onto the business of testing validation.
First, if we create a product with no attributes set, we’ll expect it to be invalid and for there to be an error associated with each field.
We can use the model’s errors() and invalid?() methods to see whether it validates, and we can use the any?() method of the error list to see whether there is an error associated with a particular attribute.

Now that we know what to test, we need to know how to tell the test framework whether our code passes or fails.
We do that using assertions.
An assertion is simply a method call that tells the framework what we expect to be true.

The simplest assertion is the method assert(), which expects its argument to be true.
If it is, nothing special happens.
However, if the argument to assert() is false, the assertion fails.
The framework will output a message and will stop executing the test method containing the failure.
In our case, we expect that an empty Product model will not pass validation, so we can express that expectation by asserting that it isn’t valid.

    assert product.invalid?

Replace the test the truth with the following code:

     Download rails40/depot_b/test/models/product_test.rb
     test "product attributes must not be empty" do
       product = Product.new
       assert product.invalid?
       assert product.errors[:title].any?
       assert product.errors[:description].any?
       assert product.errors[:price].any?
       assert product.errors[:image_url].any?
     end

We can rerun just the unit tests by issuing the command rake test:models.
When we do so, we now see the test executed successfully.

    depot> rake test:models
    .
    Finished tests in 0.257961s, 3.8766 tests/s, 19.3828 assertions/s.
    1 tests, 5 assertions, 0 failures, 0 errors, 0 skips

• 84

Sure enough, the validation kicked in, and all our assertions passed.
Clearly at this point we can dig deeper and exercise individual validations.
Let’s look at just three of the many possible tests.
First, we’ll check that the validation of the price works the way we expect.

     Download rails40/depot_c/test/models/product_test.rb
     test "product price must be positive" do
       product = Product.new(title:
         "My Book Title",
         description: "yyy",
         image_url:
         "zzz.jpg")
       product.price = -1
       assert product.invalid?
       assert_equal ["must be greater than or equal to 0.01"], product.errors[:price]
       product.price = 0
       assert product.invalid?
       assert_equal ["must be greater than or equal to 0.01"], product.errors[:price]
       product.price = 1 assert product.valid?
     end

In this code we create a new product and then try setting its price to -1, 0, and +1, validating the product each time.
If our model is working, the first two should be invalid, and we verify the error message associated with the price attribute is what we expect.

The last price is acceptable, so we assert that the model is now valid.
(Some folks would put these three tests into three separate test methods—that’s perfectly reasonable.) Next, we’ll test that we’re validating that the image URL ends with one of .gif, .jpg, or .png.

     Download rails40/depot_c/test/models/product_test.rb
     def new_product(image_url)
       Product.new(title: "My Book Title",
                   description: "yyy",
                   price: 1,
                   image_url: image_url)
     end
     test "image url" do
       ok = %w{ fred.gif fred.jpg fred.png FRED.JPG FRED.Jpg http://a.b.c/x/y/z/fred.gif }
       bad = %w{ fred.doc fred.gif/more fred.gif.more }
       ok.each do |name|
         assert new_product(name).valid?, "#{name} should be valid"
       end
       bad.each do |name|
         assert new_product(name).invalid?, "#{name} shouldn't be valid"
       end
     end

• 85

Here we’ve mixed things up a bit.
Rather than write the nine separate tests, we’ve used a couple of loops—one to check the cases we expect to pass validation and the second to try cases we expect to fail.
At the same time, we factored out the common code between the two loops.

You’ll notice that we’ve also added an extra parameter to our assert method calls.
All of the testing assertions accept an optional trailing parameter containing a string.
This will be written along with the error message if the assertion fails and can be useful for diagnosing what went wrong.

Finally, our model contains a validation that checks that all the product titles in the database are unique.
To test this one, we’re going to need to store product data in the database.

One way to do this would be to have a test create a product, save it, then create another product with the same title, and try to save it too.
这样做的方式，是创造一个商品，然后保存它，然后再创造另一个商品，让它和那个已经生成的商品有相同的标题，也保存到数据库中。
This would clearly work.
这显然是可行的。
But there’s a much simpler way—we can use Rails fixtures.
但还有一个更简单的方法--使用Rails的夹具。

### Test Fixtures  静态测试（夹具）
In the world of testing, a fixture is an environment in which you can run a test.
在测试领域中，夹具（静态测试）是一个可以在其中运行测试的环境。
If you’re testing a circuit board, for example, you might mount it in a test fixture that provides it with the power and inputs needed to drive the function to be tested.
比如，如果正在测试一个电路板，可以将它装载在一个夹具（静态测试）中，这个夹具提供测试功能所需要的电源和驱动功能测试所需要的输入。

In the world of Rails, a test fixture is simply a specification of the initial contents of a model (or models) under test.
在Rails的世界里，静态测试只是为了待测试的一个或多个模型而准备的初始内容的规范。
If, for example, we want to ensure that our products table starts off with known data at the start of every unit test, we can specify those contents in a fixture, and Rails will take care of the rest.
举例来说，如果要确保products表在每一个单元测试都从已知的数据开始，可以在一次夹具中指定下面这些内容，Rails会处理剩下的事情。

You specify fixture data in files in the test/fixtures directory.
可以在test/fixtures目录内的文件中详细说明静态数据。
These files contain test data in YAML format.
这些文件包含YAML格式的测试数据。
Each fixture file contains the data for a single model.
每个夹具文件包含单个模型的数据。
The name of the fixture file is significant; the base name of the file must match the name of a database table.
夹具文件的名称是很重要的：文件的基本名称必须与数据库表的名称匹配。
Because we need some data for a Product model, which is stored in the products table, we’ll add it to the file called products.yml.
因为需要给Product模型一些数据，而这些数据存在products表中，因此要把它们添加到名为products.yml的文件中。
YAML ↪ on page 48

Rails already created this fixture file when we first created the model.

• 86

     Download rails40/depot_b/test/fixtures/products.yml
     # Read about fixtures at
     # http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
     one:
       title: MyString
       description: MyText
       image_url: MyString
       price: 9.99
     two:
       title: MyString
       description: MyText
       image_url: MyString
       price: 9.99

The fixture file contains an entry for each row that we want to insert into the database.
这个夹具文件每行都包含了一个要插入数据库的条目。
Each row is given a name.
每行都给出了字段名。
In the case of the Rails-generated fixture, the rows are named one and two.
Rails生成的夹具中，那些行被命名为one和two。
This name has no significance as far as the database is concerned—it is not inserted into the row data.
这些名称对数据是没有意义的--这些行不会插入该行的数据。
Instead, as we’ll see shortly, the name gives us a convenient way to reference test data inside our test code.
但我们很快会看到，这些名称提供了一个便捷的在测试代码中引用测试数据的途径。
They also are the names used in the generated integration tests, so for now, we’ll leave them alone.
它们也是那些在生成的集成测试中所用的名称，不过现在，我们把这些放在一旁。

Inside each entry you’ll see an indented list of name-value pairs.
Just like in your config/database.yml, you must use spaces, not tabs, at the start of each of the data lines, and all the lines for a row must have the same indentation.
Be careful as you make changes because you will need to make sure the names of the columns are correct in each entry; a mismatch with the database column names may cause a hard-to-track-down exception.

Let’s add some more data to the fixture file with something we can use to test our Product model.

     Download rails40/depot_c/test/fixtures/products.yml
     ruby:
       title: Programming Ruby 1.9
       description: Ruby is the fastest growing and most exciting dynamic
         language out there. If you need to get working programs
         delivered fast, you should add Ruby to your toolbox.
       price: 49.50
       image_url: ruby.png

Now that we have a fixture file, we want Rails to load the test data into the products table when we run the unit test.
现在已经有了夹具文件，在运行单元测试时，我们想让Rails把这些测试数据加载到products表中。
And, in fact, Rails is already doing this (convention over configuration for the win!), but you can control which fixtures to load by specifying the following line in test/models/product_test.rb:
实际上Rails已经在做这个了（这正是约定胜于配置原则的好处），但也可以通过在文件test/models/product_test.rb中指定下面这行来控制加载哪些静态测试。

     class ProductTest < ActiveSupport::TestCase
     ➤ fixtures :products
         #...
       end

• 87

------------------------------
------------------------------
David says: Picking Good Fixture Names
挑选好的静态测试名称
Just like the names of variables in general, you want to keep the names of fixtures as self-explanatory as possible.
就像通常的变量名称一样，静态测试名称也尽可能不言自明，通过名称就可以大致了解静态测试的用途。
This increases the readability of the tests when you’re asserting that product(:valid_order_for_fred) is indeed Fred’s valid order.
当用断言product(:valid_order_for_fred)来确认Fred的有效订单时，静态测试的名称就增加了测试的可读性。
It also makes it a lot easier to remember which fixture you’re supposed to test against without having to look up p1 or order4.
这也让大家更容易地记住哪个是应该进行测试的静态测试，而无需查找p1或者order4.
The more fixtures you get, the more important it is to pick good fixture names.
静态测试越多，那么好的静态测试名称就越重要。
So, starting early keeps you happy later.
因此，越早开始这么做，就会使以后的工作越方便。

But what do we do with fixtures that can’t easily get a self-explanatory name like valid_order_for_fred? 
如果不能轻易地得到像valid_order_for_fred这样不解自明的静态测试名称，怎么办呢？
Pick natural names that you have an easier time associating to a role.
使用一个可以容易联想到角色的自然名称。
For example, instead of using order1, use christmas_order.
比如，使用christmas_order，而不是order1。
Instead of customer1, use fred.
使用fred，而不是customer1。
Once you get into the habit of natural names, you’ll soon be weaving a nice little story about how fred is paying for his christmas_order with his invalid_credit_card first, then paying with his valid_credit_card, and finally choosing to ship it all off to aunt_mary.
一旦养成了使用自然名称的习惯，那就能很快编排出一个漂亮的故事：fred如何先用他的无效信用卡来支付圣诞订单，然后再用有效信用卡来支付，最后选择发货到玛丽阿姨那里去。

Association-based stories are key to remembering large worlds of fixtures with ease.
基于故事联想的方法，是帮助记忆这个庞大静态测试世界的关键。

------------------------------
------------------------------

The fixtures() directive loads the fixture data corresponding to the given model name into the corresponding database table before each test method in the test case is run.
在测试案例中的每个测试方法运行前，fixtures()将给定模型名称的对应的夹具数据加载到对应数据表中，
The name of the fixture file determines the table that is loaded, so using :products will cause the products.yml fixture file to be used.
夹具文件名决定要加载的表，因此用:products就意味着会使用products.yml夹具文件。

Let’s say that again another way.
换种方法来说。
In the case of our ProductTest class, adding the fixtures directive means that the products table will be emptied out and then populated with the three rows defined in the fixture before each test method is run.
在ProductTest类中输入fixtures指令意味着：在运行每个测试方法前，products表将清空，然后用静态测试中定义的那3行来填充表。
<kinder:note> 不是3行，应该是one，two，ruby三个数据。

Note that most of the scaffolding that Rails generates doesn’t contain calls to the fixtures method.
请注意，大部分Rails生成的脚手架并不包含调用fixtures方法。
That’s because the default for tests is to load all fixtures before running the test.
这是因为在运行测试之前会默认加载所有夹具。
Because that default is generally the one you want, there usually isn’t any need to change it.
因为默认一般都是你想要的，通常不需要去改变它。
Once again, conventions are used to eliminate the need for unnecessary configuration.
再说一次，约定就是用来消除不必要的配置需要的。

So far, we’ve been doing all our work in the development database.
目前为止，一直是在开发数据库中工作。
Now that we’re running tests, though, Rails needs to use a test database.
现在我们是在进行测试，Rails需要使用一个测试数据库。
If you look in the database.yml file in the config directory, you’ll notice Rails actually created a configuration for three separate databases.
如果看看config目录中的databases.yml，会发现实际上Rails为3个独立的数据库创建了配置。
• db/development.sqlite3 will be our development database. All of our programming work will be done here.
• db/test.sqlite3 is a test database.
• db/production.sqlite3 is the production database.
Our application will use this when we put it online.

Each test method gets a freshly initialized table in the test database, loaded from the fixtures we provide.
在测试数据库中，每个测试方法都有一张刚刚初始化的表，加载了所提供的静态测试数据。
This is automatically done by the rake test command but can be done separately by running rake db:test:prepare.
这是由`rake test`命令自动完成的，但也可单独运行`rake db:test:prepare`来初始化数据库表。

• 88

### Using Fixture Data 使用静态数据
Now that we know how to get fixture data into the database, we need to find ways of using it in our tests.

Clearly, one way would be to use the finder methods in the model to read the data.
However, Rails makes it easier than that.
For each fixture it loads into a test, Rails defines a method with the same name as the fixture.
You can use this method to access preloaded model objects containing the fixture data:
simply pass it the name of the row as defined in the YAML fixture file, and it’ll return a model object containing that row’s data.

In the case of our product data, calling products(:ruby) returns a Product model containing the data we defined in the fixture.
Let’s use that to test the validation of unique product titles.

     Download rails40/depot_c/test/models/product_test.rb
     test "product is not valid without a unique title" do
       product = Product.new(title: products(:ruby).title,
         description: "yyy",
         price: 1,
         image_url: "fred.gif")
       assert product.invalid?
       assert_equal ["has already been taken"], product.errors[:title]
     end

The test assumes that the database already includes a row for the Ruby book.
It gets the title of that existing row using this:

     products(:ruby).title

It then creates a new Product model, setting its title to that existing title.
It asserts that attempting to save this model fails and that the title attribute has the correct error associated with it.

• 89

If you want to avoid using a hard-coded string for the Active Record error, you can compare the response against its built-in error message table.

     Download rails40/depot_c/test/models/product_test.rb
     test "product is not valid without a unique title - i18n" do
       product = Product.new(title: products(:ruby).title,
         description: "yyy",
         price: 1,
         image_url: "fred.gif")
       assert product.invalid?
       assert_equal [I18n.translate('errors.messages.taken')],
         product.errors[:title]
       # 错误消息是：["has already been taken"]
     end

We will cover the I18n functions in Chapter 15, Task J:
Internationalization, on page 211.

Now we can feel confident that our validation code not only works but will continue to work.
Our product now has a model, a set of views, a controller, and a set of unit tests.
It will serve as a good foundation upon which to build the rest of the application.

## What We Just Did
In just about a dozen lines of code, we augmented that generated code with
validation.
• We ensured that required fields were present.
• We ensured that price fields were numeric and at least one cent.
• We ensured that titles were unique.
• We ensured that images matched a given format.
• We updated the unit tests that Rails provided, both to conform to the constraints we have imposed on the model and to verify the new code we added.

We show this to our customer, and although she agrees that this is something an administrator could use, she says that it certainly isn’t anything that she would feel comfortable turning loose on her customers.
Clearly, in the next iteration we are going to have to focus a bit on the user interface.

• 90

## Playtime
Here’s some stuff to try on your own:

• If you are using Git, now might be a good time to commit our work.
You can first see what files we changed by using the git status command.

     depot> git status
     # On branch master
     # Changes not staged for commit:
     # (use "git add <file>..." to update what will be committed)
     # (use "git checkout -- <file>..." to discard changes in working directory)
     # app/models/product.rb
     # modified:
     # modified:
     test/fixtures/products.yml
     # modified:
     test/controllers/products_controller_test.rb
     # modified:
     test/models/product_test.rb
     # no changes added to commit (use "git add" and/or "git commit -a")


Since we modified only some existing files and didn’t add any new ones, we can combine the git add and git commit commands and simply issue a single git commit command with the -a option.

    depot> git commit -a -m 'Validation!'

With this done, we can play with abandon, secure in the knowledge that we can return to this state at any time using a single git checkout .
command.

• The validation option :length checks the length of a model attribute.
Add validation to the Product model to check that the title is at least ten characters long.

• Change the error message associated with one of your validations.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)


# CHAPTER 8 Task C: Catalog Display 商品目录显示
## In this chapter, we’ll see

• writing our own views,
• using layouts to decorate pages,
• integrating CSS,
• using helpers, and
• writing functional tests.

All in all, it’s been a successful set of iterations.
We gathered the initial requirements from our customer, documented a basic flow, worked out a first pass at the data we’ll need, and put together the maintenance page for the Depot application’s products.
It hasn’t even taken many lines of code.
We even have a small but growing test suite.

Thus emboldened, it’s on to our next task.
We chatted about priorities with our customer, and she said she’d like to start seeing what the application looks like from the buyer’s point of view.
Our next task is to create a simple catalog display.

This also makes a lot of sense from our point of view.
Once we have the products safely tucked into the database, it should be fairly simple to display them.
It also gives us a basis from which to develop the shopping cart portion of the code later.

We should also be able to draw on the work we just did in the product maintenance task—the catalog display is really just a glorified product listing.

Finally, we will also need to complement our unit tests for the model with some functional tests for the controller.

## 8.1 Iteration C1: Creating the Catalog Listing  创建商品目录清单
We’ve already created the products controller, used by the seller to administer the Depot application.
Now it’s time to create a second controller, one that interacts with the paying customers.
Let’s call it Store.

     depot> rails generate controller Store index
     create app/controllers/store_controller.rb
     route get "store/index"
     invoke erb
     create app/views/store
     create  app/views/store/index.html.erb
     invoke  test_unit
     create  test/controllers/store_controller_test.rb
     invoke  helper
     create  app/helpers/store_helper.rb
     invoke  test_unit
     create  test/helpers/store_helper_test.rb
     invoke  assets
     invoke  coffee
     create  app/assets/javascripts/store.js.coffee
     invoke  scss
     create  app/assets/stylesheets/store.css.scss

• 92

Just as in the previous chapter, where we used the generate utility to create a controller and associated scaffolding to administer the products, here we’ve asked it to create a controller (class StoreController in the file store_controller.rb) containing a single action method, index().

While everything is already set up for this action to be accessed via http:// localhost:3000/store/index (feel free to try it!), we can do better.
Let’s simplify things for the user and make this the root URL for the website.
We do this by editing config/routes.rb.

     Download rails40/depot_d/config/routes.rb
     Depot::Application.routes.draw do
     get "store/index"
     resources :products
     # The priority is based upon order of creation:
     # first created -> highest priority.
     # See how all your routes lay out with "rake routes".
     
     # You can have the root of your site routed with "root"
     ➤ root 'store#index', as: 'store'
     # ...
     end

At the top of the file, you can see the lines added to support the store and products controllers.
We’ll leave those lines alone.
Further along in the file you will see a commented-out line that defines a root for the website.
Either uncomment out that line or add a new line immediately after that one.
All we are changing on that line is the name of the controller (from welcome to store) and adding as: 'store'.
The latter tells Rails to create a store_path accessor method.

We saw this before with say_goodbye_path on page 26.
Let’s try it.
Point a browser at http://localhost:3000/, and up pops our web page (Figure 16, Template not found, on page 93).

• 93

Figure 16—Template not found

It might not make us rich, but at least we know everything is wired together correctly.
尽管页面看起来不是很充实，但是至少直到了，所有事情都正确地连接在一起了。
The page even tells us where to find the template file that draws this page.
这个页面甚至还说明了，在哪里可以找到形成这个页面的模板文件。

Let’s start by displaying a simple list of all the products in our database.
让我们从显示简单清单开始。该清单包含数据库中的所有商品。
We know that eventually we’ll have to be more sophisticated, breaking them into categories, but this will get us going.
最终的结果肯定会更复杂，要把它们分门别类地排列。但目前这个清单足以让工作继续进行。

We need to get the list of products out of the database and make it available to the code in the view that will display the table.
需要得到商品清单而非源自数据库，且把它提供给显示清单的视图代码。
This means we have to change the index() method in store_controller.rb.
这意味着我们必须改变store_controller的index()方法。
We want to program at a decent level of abstraction, so let’s just assume we can ask the model for a list of the products we can sell.
在合适的抽象层面上进行编程，这样可先假定可以从模型中得到可销售的商品清单：

     Download rails40/depot_d/app/controllers/store_controller.rb
     class StoreController < ApplicationController
       def index
     ➤   @products = Product.order(:title)
         # 原本无此代码
       end
     end

We ask our customer whether she had a preference regarding the order things should be listed in, and we jointly decided to see what happened if we displayed the products in alphabetical order.
先征询客户对商品的显示顺序是否有偏好，然后共同确定了以字母顺序来显示商品清单。
We do this by adding an order(:title) call to the Product model.
<kinder:note> 通过增加一个order(:title)调用Product模型来实现。

Now we need to write our view template. 
现在需要编写视图模板。
To do this, edit the file index.html.erb in app/views/store. 
(Remember that the path name to the view is built from the name of the controller [store] and the name of the action [index]. 
The .html.erb part signifies an ERB template that produces an HTML result.)

• 94

     Download rails40/depot_d/app/views/store/index.html.erb
     <% if notice %>
       <p id="notice"><%= notice %></p>
     <% end %>
     <h1>Your Pragmatic Catalog</h1>
     <% @products.each do |product| %>
     <div class="entry">
       <%= image_tag(product.image_url) %>
       <h3><%= product.title %></h3>
       <%= sanitize(product.description) %>
       <div class="price_line">
         <span class="price"><%= product.price %></span>
       </div>
     </div>
     <% end %>

Note the use of the sanitize() method for the description.
要注意关于商品属性描述所使用的sanitize()方法。
This allows us to safely add HTML stylings to make the descriptions more interesting for our customers.
它允许安全地添加HTML风格代码，使客户对这一商品属性描述内容更感兴趣。
Note that this decision opens a potential security hole,1 but because product descriptions are created by people who work for our company, we think that the risk is minimal.
注意，这个决定存在潜在的安全漏洞，但是因为商品描述都是由公司员工所创建的，所以这里可以认为该风险很小。

      1.  http://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29

We’ve also used the image_tag() helper method.
This generates an HTML <img> tag using its argument as the image source.

Next we add a stylesheet, making use of the fact that in Iteration A2 on page 72 we set things up so that pages created by the StoreController will define an HTML class by the name of store.

     Download rails40/depot_d/app/assets/stylesheets/store.css.scss
     // Place all the styles related to the Store controller here.
     // They will automatically be included in application.css.
     // You can use Sass (SCSS) here: http://sass-lang.com/
     ➤ .store {
     ➤
     ➤   h1 {
     ➤     margin: 0;
     ➤     padding-bottom: 0.5em;
     ➤     font: 150% sans-serif;
     ➤     color: #226;
     ➤     border-bottom: 3px dotted #77d;
     ➤   }
     ➤
       /* An entry in the store catalog */
     ➤   .entry {
     ➤     overflow: auto;
     ➤     margin-top: 1em;
     ➤     border-bottom: 1px dotted #77d;
     ➤     min-height: 100px;
     ➤     img {
     ➤       width: 80px;
     ➤       margin-right: 5px;
     ➤       margin-bottom: 5px;
     ➤       position: absolute;
     ➤     }
     ➤     h3 {
     ➤       font-size: 120%;
     ➤       font-family: sans-serif;
     ➤       margin-left: 100px;
     ➤       margin-top: 0;
     ➤       margin-bottom: 2px;
     ➤       color: #227;
     ➤     }
     ➤     p, div.price_line {
     ➤       margin-left: 100px;
     ➤       margin-top: 0.5em;
     ➤       margin-bottom: 0.8em;
     ➤     }
     ➤     .price {
     ➤       color: #44a;
     ➤       font-weight: bold;
     ➤       margin-right: 3em;
     ➤     }
     ➤   }
     ➤ }

• 95

Hitting Refresh brings up the display shown in Figure 17, Our first (ugly) catalog page, on page 96.
It is still pretty basic, and it seems to be missing something.
The customer happens to be walking by as we ponder this, and she points out that she’d also like to see a decent-looking banner and sidebar on public-facing pages.

At this point in the real world, we’d probably want to call in the design folks—we’ve all seen too many programmer-designed websites to feel comfortable inflicting another on the world.
But Pragmatic Web Designer is off getting inspiration on a beach somewhere and won’t be back until later in the year, so let’s put a placeholder in for now.
It’s time for another iteration.

• 96

Figure 17—Our first (ugly) catalog page

## 8.2 Iteration C2: Adding a Page Layout 增加页面布局
The pages in a typical website often share a similar layout—the designer will have created a standard template that is used when placing content.
Our job is to modify this page to add decoration to each of the store pages.

So far, we’ve made only minimal changes to application.html.erb, namely, to add a class attribute in Iteration A2 on page 71.
As this file is the layout used for all views for all controllers that don’t otherwise provide a layout, we can change the look and feel of the entire site by editing just one file.
This makes us feel better about putting a placeholder page layout in for now; we can update it when the designer eventually returns from the islands.

Let’s update this file to define a banner and a sidebar.

• 97

     Download rails40/depot_e/app/views/layouts/application.html.erb
     <!DOCTYPE html>
     <html>
     <head>
       <title>Pragprog Books Online Store</title>
       <%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true %>
       <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
       <%= csrf_meta_tags %>
     </head>
     <body class="<%= controller.controller_name %>">
       <div id="banner">
         <%= image_tag("logo.png") %>
         <%= @page_title || "Pragmatic Bookshelf" %>
       </div>
       <div id="columns">
         <div id="side">
           <ul>
             <li><a href="http://www....">Home</a></li>
             <li><a href="http://www..../faq">Questions</a></li>
             <li><a href="http://www..../news">News</a></li>
             <li><a href="http://www..../contact">Contact</a></li>
           </ul>
         </div>
         <div id="main">
           <%= yield %>
         </div>
       </div>
     </body>
     </html>

    <kinder:note> 下面是haml版本，但不知为何，application.css.scss竟然没有应用到这个模板中，而上面erb版本则没有这个问题。
    <kinder:note> 值得注意的是，这个haml版本和上面erb版本生成的html代码是一样的。
    !!!
    %html
      %head
        %title Pragrog Books Online Store
        = stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true
        = javascript_include_tag "application", "data-turbolinks-track" => true
        = csrf_meta_tags
      %body{:class => controller.controller_name}
        .banner
          = image_tag("logo.jpg")
          = @page_title || "Pragmatic Bookshelf"
        .columns
          .side
            %ul
              %li
                %a{ :href => "http://www...." }
                  Home
              %li
                %a{ href: "http://www..../faq"}
                  Questions
              %li
                %a{ href: "http://www..../news"}
                  News
              %li
                %a{ href: "http://www..../contact"}
                  Contact
          .main= yield

Apart from the usual HTML gubbins, this layout has three Rails-specific items.
Line 5 uses a Rails stylesheet_link_tag() helper method to generate a <link> tag to our application’s stylesheet and specifies an option to enable turbolinks,2 which transparently works behind the scenes to speed up page changes within your application.
Similarly, line 7 generates a <link> to our application’s scripts.
2.  https://github.com/rails/turbolinks

Finally, line 8 sets up all the behind-the-scenes data needed to prevent crosssite request forgery attacks, which will be important once we add forms in CHAPTER 12, Task G: Check Out!, on page 159.

On line 13, we set the page heading to the value in the instance variable @page_title.
The real magic, however, takes place on line 25.
When we invoke yield, Rails automatically substitutes in the page-specific content—the stuff generated by the view invoked by this request.
Here, this will be the catalog page generated by index.html.erb.
yield ↪ on page 44

To make this all work, first rename the file application.css to application.css.scss.
If you didn’t opt to try Git as was suggested in Playtime, on page 74, now might be a good time to do so.
The command to rename a file using Git is git mv.

Once you have renamed this file, either through Git or using the underlying operating system commands to do so, add the following lines:

• 98

     Download rails40/depot_e/app/assets/stylesheets/application.css.scss
     <kinder:note> 注意原本是application.css，需要自己更改文件名
     /*
      * This is a manifest file that'll be compiled into application.css, which will
      * include all the files listed below.
      *
      * Any CSS and SCSS file within this directory, lib/assets/stylesheets,
      * vendor/assets/stylesheets, or vendor/assets/stylesheets of plugins, if any,
      * can be referenced here using a relative path.
      *
      * You're free to add application-wide styles to this file and they'll appear
      * at the top of the compiled file, but it's generally better to create a new
      * file per style scope.
      *
      *= require_self
      *= require_tree .
      */
     ➤#banner {
     ➤    background: #9c9;
     ➤    padding: 10px;
     ➤    border-bottom: 2px solid;
     ➤    font: small-caps 40px/40px "Times New Roman", serif;
     ➤    color: #282;
     ➤    text-align: center;
     ➤    img {
     ➤      float: left;
     ➤    }
     ➤  }
     ➤  #notice {
     ➤    color: #000 !important;
     ➤    border: 2px solid red;
     ➤    padding: 1em;
     ➤    margin-bottom: 2em;
     ➤    background-color: #f0f0f0;
     ➤    font: bold smaller sans-serif;
     ➤  }
     ➤  #columns {
     ➤    background: #141;
     ➤    #main {
     ➤      margin-left: 17em;
     ➤      padding: 1em;
     ➤      background: white;
     ➤    }
     ➤    #side {
     ➤      float: left;
     ➤      padding: 1em 2em;
     ➤      width: 13em;
     ➤      background: #141;
     ➤      ul {
     ➤        padding: 0;
     ➤        li {
     ➤          list-style: none;
     ➤          a {
     ➤            color: #bfb;
     ➤            font-size: small;
     ➤          }
     ➤        }
     ➤      }
     ➤   }
     ➤}


• 99

As explained in the comments, this manifest file will automatically include all stylesheets available in this directory and in any subdirectory.
This is accomplished via the require_tree directive.

We could instead list the names of individual stylesheets we want to be linked in the stylesheet_link_tag(), but because we are in the layout for the entire application and because this layout is already set up to load all stylesheets, we’ll leave it alone for now.

This page design consists of three primary areas on the screen:
a banner across the top, a main area on the bottom right, and a side area on the left.

Additionally, there is some provision for a notice should it appear.
Each of these has margins, padding, fonts, and colors—typical things you see in CSS.

The banner is also centered and specifies that the image is to be placed on the left.
Inside the side area, there is special styling for the list, namely, to turn off padding and bullets and to specify a different font and color.

Again, we make heavy use of Sass, which is exactly what the file rename enabled us to do.
For example, there is an img selector nested inside the #banner selector.
There also is an a selector inside of the #side selector.

Hit Refresh, and the browser window looks something like Figure 18, Catalog with layout added, on page 100.
It won’t win any design awards, but it’ll show our customer roughly what the final page will look like.

Looking at this page, we spot a minor problem with how prices are displayed.
The database stores the price as a number, but we’d like to show it as dollars and cents.
A price of 12.34 should be shown as $12.34, and 13 should display as $13.00.
We’ll tackle that next.

• 100

Figure 18—Catalog with layout added

## 8.3  Iteration C3: Using a Helper to Format the Price 用帮助函数来调整价格格式
Ruby provides a sprintf() function that can be used to format prices.
We could place logic that makes use of this function directly in the view.
For example, we could say this:

    <span class="price"><%= sprintf("$%0.02f", product.price) %></span>

This would work, but it embeds knowledge of currency formatting into the view.
Should we display prices of products in several places and want to internationalize the application later, this would be a maintenance problem.

Instead, let’s use a helper method to format the price as a currency.
Rails has an appropriate one built in—it’s called number_to_currency().

Using our helper in the view is simple; in the index template, we change this:

    <span class="price"><%= product.price %></span>

to the following:

     Download rails40/depot_e/app/views/store/index.html.erb
     <span class="price"><%= number_to_currency(product.price) %></span>

Sure enough, when we hit Refresh, we see a nicely formatted price, as in Figure 19, Catalog with price formatted, on page 101.

<kinder:note> 关于帮助函数，参见http://api.rubyonrails.org的介绍。相关函数还有： number_to_human, number_to_human_size, number_to_percentage, number_to_phone, number_with_delimiter, number_with_precision 等。

• 101

Figure 19—Catalog with price formatted

Although it looks nice enough, we are starting to get a nagging feeling that we really should be running and writing tests for all this new functionality, particularly after our experience of adding logic to our model.

## 8.4 Iteration C4: Functional Testing of Controllers  控制器功能测试
Now for the moment of truth.
现在该说真话了。
Before we focus on writing new tests, we need to determine whether we have actually broken anything.
在专注于编写新的测试之前，需要确定，是否已经破坏了什么。
Remembering our experience after we added validation logic to our model, with some trepidation we run our tests again.
还记得在模型中添加验证逻辑的经历吧，现在以一种紧张心情再次运行测试。

     depot> rake test

This time, all is well.
这次，一切都好。
We added a lot, but we didn’t break anything.
尽管增加了很多，但没有破坏任何东西。
That’s a relief, but our work is not yet done; we still need tests for what we just added.
这让我松了口气，当工作还没完成，仍需测试刚刚加入的功能。

The unit testing of models that we did previously seemed straightforward enough.
之前所做的模型单元测试看上去是相当清楚的。
We called a method and compared what it returned against what we expected it to return.
调用方法，且比较其返回值和期待值。
But now we are dealing with a server that processes requests and a user viewing responses in a browser.
但当前在浏览器中所涉及的不仅是服务器处理请求，而且用户也在注视着响应。
What we will need is functional tests that verify that the model, view, and controller work well together.
我们需要的是功能测试，它能验证模型、视图、控制器是否在一起工作正常。
Never fear, Rails makes this easy too.
别害怕，Rails 可以很容易实现这一点。

First, let’s take a look at what Rails generated for us.
首先，看看Rails生成了什么。

• 102

     Download rails40/depot_d/test/controllers/store_controller_test.rb
     require 'test_helper'
     class StoreControllerTest < ActionController::TestCase
       test "should get index" do
         get :index
         assert_response :success
       end
     end

The should get index test gets the index and asserts that a successful response is expected.
这个should get index测试得到了索引并断言期待成功响应。
That certainly seems straightforward enough.
这个看上去是够直接了当的。
That’s a reasonable beginning, but we also want to verify that the response contains our layout, our product information, and our number formatting.
这个开始挺合理，但我们还想验证响应是否还包含了布局、商品信息和数字格式。
Let’s see what that looks like in code.
看一看下面的代码：

     Download rails40/depot_e/test/controllers/store_controller_test.rb
       require 'test_helper'
       class StoreControllerTest < ActionController::TestCase
         test "should get index" do
           get :index
           assert_response :success
      ➤    assert_select '#columns #side a', minimum: 4
      ➤    assert_select '#main .entry', 3
      ➤    assert_select 'h3', 'Programming Ruby 1.9'
      ➤    assert_select '.price', /\$[,\d]+\.\d\d/
         end
       end

The four lines we added take a look into the HTML that is returned, using CSS selector notation.
As a refresher, selectors that start with a number sign (#) match on id attributes, selectors that start with a dot (.) match on class attributes, and selectors that contain no prefix at all match on element names.

So, the first select test looks for an element named a that is contained in an element with an id with a value of side, which is contained within an element with an id with a value of columns.
This test verifies that there are a minimum of four such elements.
Pretty powerful stuff, assert_select(), eh?
这个方法是个相当厉害的家伙，对吧？

The next three lines verify that all of our products are displayed.
The first verifies that there are three elements with a class name of entry inside the main portion of the page.
The next line verifies that there is an h3 element with the title of the Ruby book that we had entered previously.
The third line verifies that the price is formatted correctly.
These assertions are based on the test data that we had put inside our fixtures.
这些断言都是基于夹具（静态测试）中的测试数据：

• 103

     Download rails40/depot_e/test/fixtures/products.yml
     # Read about fixtures at
     # http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
     one:
       title: MyString
       description: MyText
       image_url: MyString
       price: 9.99
     two:
       title: MyString
       description: MyText
       image_url: MyString
       price: 9.99
     ruby:
       title: Programming Ruby 1.9
       description: Ruby is the fastest growing and most exciting dynamic
         language out there. If you need to get working programs
         delivered fast, you should add Ruby to your toolbox.
       price: 49.50
       image_url: ruby.png

If you noticed, the type of test that assert_select() performs varies based on the type of the second parameter.
你会注意到，方法执行的测试类型随着第二个参数类型而发生变化。
If it is a number, it will be treated as a quantity.
If it is a string, it will be treated as an expected result.
Another useful type of test is a regular expression, which is what we use in our final assertion.

We verify that there is a price that has a value that contains a dollar sign followed by any number (but at least one), commas, or digits; followed by a decimal point; followed by two digits.

regular expression ↪ on page 42

One final point before we move on: both validation and functional tests will test the behavior of controllers only; they will not retroactively affect any objects that already exist in the database or in fixtures.
In the previous example, two products contain the same title.
Such data will cause no problems and will go undetected up to the point where such records are modified and saved.

We’ve touched on only a few things that assert_select() can do.
More information can be found in the online documentation.3 
3.  http://api.rubyonrails.org/classes/ActionDispatch/Assertions/SelectorAssertions.html

• 104

That’s a lot of verification in just a few lines of code.
We can see that it works by rerunning just the functional tests (after all, that’s all we changed).

depot> rake test:controllers

Now not only do we have something recognizable as a storefront, we have tests that ensure that all of the pieces—the model, view, and controller—are all working together to produce the desired result.
Although this sounds like a lot, with Rails it was easy.
In fact, it was mostly HTML and CSS and not much in the way of code or tests.
Before moving on, let’s make sure that it will stand up to the onslaught of customers we’re expecting.

## 8.5 Iteration C5: Caching of Partial Results  缓存部分结果
<kinder:note> 这一节是本版新增的，因此这一节我自己翻译。
If everything goes as planned, this page will definitely be a high-traffic area for the site.
如果事情都很如意，那么这个页面将会是本站访问最频繁的页面了。
To respond to requests for this page, we would need to fetch every product from the database and render each one.
要响应对这个页面的请求，我们需要逐个从数据库中取出商品，然后进行渲染。
We can do better than that.
我们可以做得更好一些。

After all, the catalog doesn’t really change that often, so there is no need to start from scratch on each request.
毕竟，商品目录不总是经常发生变化，所以没有必要为每个请求抓取数据。
Just so we can see what we’re doing, the first thing we’re going to do is to modify the configuration for the development environment to turn on caching.
这样我们就知道要做的东西了。我们要做的第一件事是修改开发环境的配置来开启缓存。

     Download rails40/depot_e/config/environments/development.rb
     config.action_controller.perform_caching = true

<kinder:note> 注意生产环境中缓存是默认开启的，参见同目录下production.rb
As with all configuration changes, you need to restart your server.
当配置改变时，需要重启服务器。

Next we need to plan our attack.
接下来，需要计划我们的流量。
Thinking about it, we only need to re-render things if a product changed, and even then we need to render only the products that actually changed.
考虑到我们只需要在商品改变时才重新渲染，我们可以在商品真正被更改时方需要渲染。
Focusing on the first part of the problem, we need to add code that returns the most recently updated product.
对于问题的第一个部分，我们需要增加代码，返回最常更新的商品。

     Download rails40/depot_e/app/models/product.rb
     def self.latest
       Product.order(:updated_at).last
       # <kinder:note> 这是一个类方法，首先将Product类根据更新时间进行排序，在取出最后一个--即是最新的一个
     end

Next we mark the sections of our template that we need to update if any product changes, and inside that section we mark the subsection that we need in order to update any specific product that changed.
接着我们标记我们的模板章节，如果商品改变，则该模板需要更新；在章节里面，标记出子章节，需要按顺序更新特定更改的商品。

• 105

       Download rails40/depot_e/app/views/store/index.html.erb
       <% if notice %>
         <p id="notice"><%= notice %></p>
       <% end %>
       <h1>Your Pragmatic Catalog</h1>
     ➤ <% cache ['store', Product.latest] do %>
       <!-- 将下面片段缓存起来 -->
         <% @products.each do |product| %>
     ➤     <% cache ['entry', product] do %>
           <!-- 将下面片段缓存起来 -->
             <div class="entry">
               <%= image_tag(product.image_url) %>
               <h3><%= product.title %></h3>
               <%= sanitize(product.description) %>
               <div class="price_line">
                 <span class="price"><%= number_to_currency(product.price) %></span>
               </div>
             </div>
     ➤     <% end %>
         <% end %>
     ➤ <% end %>

In addition to bracketing the sections, we identify the components of the name for each cache entry.
除了方括号的片段，我们为每个缓存条目标识处名称的组件。
We make the choice to call the overall cache entry store and the individual cache entries entry.
我们选择调用全面缓存项目store、部分缓存项目entry。
We also associate a product with each, namely, the latest with the overall store and the individual product we are rendering with the entry.
我们也将一个商品和每个最新版本联系在一起，以及我们要渲染的项目和整个商店、特定商品。
Bracketed sections can be nested to arbitrary depth, which is why those in the Rails community have come to refer to this as Russian doll caching.4
方括号部分可以被嵌套任意深度，这就是为什么那些Rails社区的人称它为俄罗斯套筒娃娃缓存了。
4. http://37signals.com/svn/posts/3113-how-key-based-cache-expiration-works

With this, we’re done! 
到了这里，我们完成了。
Rails takes care of all of the rest, including managing the storage and deciding when to invalidate old entries.
Rails会处理剩下的一切，包括管理内存、决定何时让旧的项目失效。
If you’re really interested, there are all sorts of knobs you can turn and choices as to what backing store to use for the cache.
对于缓存使用什么后备存储器，如果你真的感兴趣，还有许多门道可以更改，和选择。
It’s nothing you need to worry about now, but it might be worth bookmarking the overview page of Caching with Rails in the RailsGuides.5 
没有什么需要你担心的，但将RailsGuides的Caching with Rails页面保存为书签真是非常值得！
As far as verifying that this works, unfortunately there isn’t much to see.
至于验证这个工作，不幸的是没有什么好看的。
<kinder:note> 不过我觉得还是应该看看的。
<kinder:note> 这是第一次生成页面的后台记录

    Started GET "/" for 127.0.0.1 at 2014-08-14 14:22:46 +0800
    Processing by StoreController#index as HTML
      Product Load (0.7ms)  SELECT  "products".* FROM "products"   ORDER BY "products"."updated_at" DESC LIMIT 1
      Cache digest for app/views/store/index.html.haml: 527a837257bc51623fbebd7cc039dfb6
    Read fragment views/store/products/1-20140809133156907882000/527a837257bc51623fbebd7cc039dfb6 (0.2ms)
      Product Load (0.3ms)  SELECT "products".* FROM "products"   ORDER BY "products"."title" ASC
      Cache digest for app/views/store/index.html.haml: 527a837257bc51623fbebd7cc039dfb6
    Read fragment views/entry/products/1-20140809133156907882000/527a837257bc51623fbebd7cc039dfb6 (0.2ms)
    Write fragment views/entry/products/1-20140809133156907882000/527a837257bc51623fbebd7cc039dfb6 (15.2ms)
    Write fragment views/store/products/1-20140809133156907882000/527a837257bc51623fbebd7cc039dfb6 (1.6ms)
      Rendered store/index.html.haml within layouts/application (228.2ms)
    Completed 200 OK in 482ms (Views: 475.8ms | ActiveRecord: 2.1ms)

<kinder:note> 这是第二次访问时的后台记录

    Started GET "/" for 127.0.0.1 at 2014-08-14 14:23:08 +0800
    Processing by StoreController#index as HTML
      Product Load (0.4ms)  SELECT  "products".* FROM "products"   ORDER BY "products"."updated_at" DESC LIMIT 1
      Cache digest for app/views/store/index.html.haml: 527a837257bc51623fbebd7cc039dfb6
    Read fragment views/store/products/1-20140809133156907882000/527a837257bc51623fbebd7cc039dfb6 (0.3ms)
      Rendered store/index.html.haml within layouts/application (9.9ms)
    Completed 200 OK in 44ms (Views: 40.8ms | ActiveRecord: 0.4ms)

If you go to that page, you should see nothing change, which in fact is the point!
如果你到了那个页面，你可以看到没有变化，那就对了。
The best you can do is to make a change to the template anywhere inside the cache block without updating any product and verifying that you do not see that update because the cached version of the page has not been updated.
你能做的最好的是改变模板，任何缓存块内的，但没有更新任何产品并且没有验证你没有看到更新的地方,因为页面的缓存版本没有更新。

Once you’re satisfied that caching is working, turn caching off in development so that further changes to the template will always be visible immediately.
一旦你对缓存的运作感到满意，在开发模式下关闭缓存以便即时看到对模板进行的更多改变。

5. http://guides.rubyonrails.org/caching_with_rails.html

• 106

     Download rails40/depot_f/config/environments/development.rb
     config.action_controller.perform_caching = false

Once again, restart the server, and verify that changes to the template once again show up as quickly as you save them.
再次，一旦你保存了更改后的模板，马上重启服务器显示它，就验证模板的改变了。
<kinder:note> 下面是关闭缓存之后的后台记录

    Started GET "/" for 127.0.0.1 at 2014-08-14 14:53:08 +0800
      ActiveRecord::SchemaMigration Load (0.3ms)  SELECT "schema_migrations".* FROM "schema_migrations"
    Processing by StoreController#index as HTML
      Product Load (0.4ms)  SELECT  "products".* FROM "products"   ORDER BY "products"."updated_at" DESC LIMIT 1
      Product Load (0.3ms)  SELECT "products".* FROM "products"   ORDER BY "products"."title" ASC
      Rendered store/index.html.haml within layouts/application (81.9ms)
    Completed 200 OK in 269ms (Views: 211.6ms | ActiveRecord: 1.3ms)


## 8.6 What We Just Did 本章小结
We’ve put together the basis of the store’s catalog display.
下面我们将商品显示目录的那些基本部件组装在了一起。
The steps were as follows:
具体步骤如下：

1. Create a new controller to handle customer-centric interactions.
   创建了新的控制器来处理用户为中心的交互。
2. Implement the default index() action.
   实现了默认行为index。
3.  Add a call to the order() method within the Store controller to control the order in which the items on the website are listed.
   在Store控制器中添加了order()方法的调用，来控制网站所列项目的顺序。
4. Implement a view (an .html.erb file) and a layout to contain it (another .html.erb file).
   实现了视图及其页面布局。
5. Use a helper to format prices the way we want.
   用帮助函数将价格转换为我们想要的方式。
6. Make use of a CSS stylesheet.
   使用CSS样式表。
7. Write functional tests for our controller.
   写了控制器的功能测试。
8. Implement fragment caching for portions of the page.
   实现页面部分的片段缓存。
It’s time to check it all in and move on to the next task, namely, making a shopping cart!
现在是上传这些代码的时候，然后开始下一个任务，即创建购物车。

## Playtime
Here’s some stuff to try on your own:
可以自己尝试以下任务：
• Add a date and time to the sidebar.
  在网页侧边栏添加时间和日期。
It doesn’t have to update; just show the value at the time the page was displayed.
这是不需要自动更新的；只要打开网页时，显示它们就可以了。

• Experiment with setting various number_to_currency helper method options, and see the effect on your catalog listing.
尝试为number_to_currency帮助函数设置不同参数，并且看一下商品目录清单的不同效果。

• Write some functional tests for the product maintenance application using assert_select.
使用assert_select函数编写商品维护应用程序的功能测试。
The tests will need to be placed into the test/controllers/products_controller_test.rb file.
这些测试需要放在test/functional/products_controller_test.rb文件中。

• Just a reminder—the end of an iteration is a good time to save your work using Git.
提醒一下--在迭代结束的时候用Git保存工作。
If you have been following along, you have the basics you need at this point.
如果一直跟随本书一起工作，那么此时需要做个版本号。
We will pick things back up, in terms of exploring more Git functionality, in Prepping Your Deployment Server, on page 242.
后面我们将复习这些内容，并探索更多的Git功能。

(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)


# CHAPTER 9 Task D: Cart Creation 创建购物车
## In this chapter, we’ll see
• sessions and session management,
• adding relationships between models, and
• adding a button to add a product to a cart.

Now that we have the ability to display a catalog containing all our wonderful products, it would be nice to be able to sell them.
Our customer agrees, so we’ve jointly decided to implement the shopping cart functionality next.
This is going to involve a number of new concepts, including sessions, relationships between models, and adding a button to the view, so let’s get started.

### 9.1 Iteration D1: Finding a Cart  寻找购物车
As users browse our online catalog, they will (we hope) select products to buy.
当用户浏览在线目录时，他们将（当然也是我们的希望）选择要购买的产品。
The convention is that each item selected will be added to a virtual shopping cart, held in our store.
通常习惯是每个所选的产品会添加到在线商店的虚拟购物车中。
At some point, our buyers will have everything they need and will proceed to our site’s checkout, where they’ll pay for the stuff in their cart.
买家选完商品后，就会去在线商店的收银台给购物车中的东西付款。

This means that our application will need to keep track of all the items added to the cart by the buyer.
这意味着，应用程序需要跟踪所有由买家添加到购物车中的商品。
To do that, we’ll keep a cart in the database and store its unique identifier, cart.id, in the session.
要做到这一点，需要把购物车放进数据库中，并在会话中存储购物车的唯一标识符。
Every time a request comes in, we can recover the identity from the session and use it to find the cart in the database.
每当请求出现时，可以从会话中找到该购物车的标识，并用该标识在数据库中查找购物车。

Let’s go ahead and create a cart.

     depot> rails generate scaffold Cart
     ...
     depot> rake db:migrate
     == CreateCarts: migrating ====================================================
     -- create_table(:carts)
     -> 0.0012s
     == CreateCarts: migrated (0.0014s) ===========================================

Rails makes the current session look like a hash to the controller, so we’ll store the ID of the cart in the session by indexing it with the symbol :cart_id.
Rails将当前的会话看上去像是控制器的一个散列，所以将这个购物车id放在会话中，其可以使用符号:cart_id建立索引。

• 108 

     Download rails40/depot_f/app/controllers/concerns/current_cart.rb
     module CurrentCart
       extend ActiveSupport::Concern
       private
       def set_cart
         @cart = Cart.find(session[:cart_id])
         rescue ActiveRecord::RecordNotFound
           @cart = Cart.create
           session[:cart_id] = @cart.id
       end
     end

rescue ↪ on page 45
private ↪ on page 47 

## 9.2 Iteration D2: Connecting Products to Carts 将产品放到购物车中

The set_cart() method starts by getting the :cart_id from the session object and then attempts to find a cart corresponding to this ID.
<kinder:note> set_cart方法通过从session（会话）对象中取得:cart_id，然后寻找对应这个ID的购物车。
If such a cart record is not found (which will happen if the ID is nil or invalid for any reason), then this method will proceed to create a new Cart, store the ID of the created cart into the session, and then return the new cart.
如果没找到（如果id是nil或由于某个原因而无效时，就会找不到），该方法会创建一个新的购物车，这个购物车的id会保存在会话中，然后该方法返回新创键的购物车。

Note that we place the set_cart() method in a CurrentCart module and mark it as private.
<kinder:note> 注意我们把方法`set_cart()`放在CurrentCart模块中，并定义该方法为私有。
This treatment allows us to share common code (even as little as a single method!) between controllers and furthermore prevents Rails from ever making it available as an action on the controller.
<kinder:note> 这种处理让我们在控制器之间共享代码，同时也避免Rails让该方法像控制器中的行为那样被调用（即使仅是一个单例方法）。

We’re looking at sessions because we need somewhere to keep our shopping cart.
我们现在正盯着会话看，因为我们需要有个地方来存放购物车。
We’ll cover sessions in more depth in Rails Sessions, on page 331, but for now let’s move on to implement the cart.
后面331页的会话一节会更深入研究这个会话。现在让我们先来实现购物车功能。

Let’s keep things simple.
让事情变得简单点。
A cart contains a set of products.
购物车包含了一些选购的货品。
Based on the Initial guess at application data diagram on page 59, combined with a brief chat with our customer, we can now generate the Rails models and populate the migrations to create the corresponding tables.
基于前面59页应用程序图解的初始猜想，加上和客户简短的沟通，现在可以创建Rails模型并应用迁移来创建相应的数据库表。

     depot> rails generate scaffold LineItem product:references cart:belongs_to
     ...
     depot> rake db:migrate
     == CreateLineItems: migrating ================================================
     -- create_table(:line_items)
     -> 0.0013s
     == CreateLineItems: migrated (0.0014s) =======================================

<kinder:note> 为什么一个是reference一个是belongs_to？下面的解释认为它们是一致的，只是书面不同而已。
The database now has a place to store the references between line items, carts, and products.
现在数据库中有了地方来存储在线商品、购物车和产品之间的关系了。
If you look at the generated definition of the LineItem class, you can see the definitions of these relationships.
<kinder:note> 如果你看看生成的LineItem类的定义，就会发现这些关系的定义。

• 109

     Download rails40/depot_f/app/models/line_item.rb
     class LineItem < ActiveRecord::Base
       belongs_to :product
       belongs_to :cart
     end

At the model level, there is no difference between a simple reference and a “belongs to” relationship.
<kinder:note> 在模型级别，一个简单的引用和一个”属于“关系是没有区别的。
Both are implemented using the belongs_to() method.
<kinder:note> 两者都是使用belongs_to()方法实现的。

In the LineItem model, the two belongs_to() calls tell Rails that rows in the line_items table are children of rows in the carts and products tables.
在LineItem模型里面，两个belongs_to()调用告诉Rails，数据库line_items表的行carts表和products表的子行。
No line item can exist unless the corresponding cart and product rows exist.
除非存在对应的购物车和产品，否则在线商品是不存在的。
There’s an easy way to remember where to put belongs_to declarations:
有一个简易的方法来记住哪里放置belongs_to的声明：
if a table has foreign keys, the corresponding model should have a belongs_to for each.
如果一个数据表有一个或多个外主键，每个对应的模型就应该有一个belongs_to。

Just what do these various declarations do? 
只是这些声明是干嘛的？
Basically, they add navigation capabilities to the model objects.
基本上，它们给模型对象增加了导航能力。
Because Rails added the belongs_to declaration to LineItem, we can now retrieve its Product and display the book’s title.
因为Rails增加了belongs_to声明给LineItem，我们现在能够找到它的产品，并显示书籍的标题。

     li = LineItem.find(...)
     puts "This line item is for #{li.product.title}"

To be able to traverse these relationships in both directions, we need to add some declarations to our model files that specify their inverse relations.
<kinder:note> 为了在两个方面横贯（验证）这些关系，我们需要增加一些声明到模型文件中，指定它们相反的关系。
Open the cart.rb file in app/models, and add a call to has_many().
<kinder:note> 在app/models打开cart.rb，并增加一个has_many()的调用。

     Download rails40/depot_f/app/models/cart.rb
     class Cart < ActiveRecord::Base
     ➤ has_many :line_items, dependent: :destroy
     end

That has_many :line_items part of the directive is fairly self-explanatory: a cart (potentially) has many associated line items.
<kinder:note> 指令的那个`has_many :line_items`部分是相当富有自我解释性的： 一个购物车（潜在的）有许多相关的在线商品。
These are linked to the cart because each line item contains a reference to its cart’s ID.
<kinder:note> 它们链接到购物车，因为每个在线商品包含了一个指向购物车ID的引用。
The dependent: :destroy part indicates that the existence of line items is dependent on the existence of the cart.
<kinder:note> `dependent: :destroy`部分指出：在线商品的存在依赖于购物车的存在。
If we destroy a cart, deleting it from the database, we’ll want Rails also to destroy any line items that are associated with that cart.
<kinder:note> 如果我们删除了一个购物车，从数据库中删除了它，我们需要Rails页删除和购物车相关的在线商品。

Now that the Cart is declared to have many line items, we can reference them (as a collection) from a cart object.
现在Cart被声明为拥有很多在线商品，我们可以从一个cart对象引用它们（作为一个收集集合）。

     cart = Cart.find(...)
     puts "This cart has #{cart.line_items.count} line items"

Now, for completeness, we should add a has_many directive to our Product model.
现在，出于完整性，应该在模型Product中页添加一个has_many指令。
After all, if we have lots of carts, each product might have many line items referencing it.
毕竟，如果我们有许多个购物车，每个产品页可以有多个在线商品引用它。
This time, we will make use of validation code to prevent the removal of products that are referenced by line items.
这次，我们用验证代码来避免删除那些正在被在线商品引用的产品。

• 110

      Download rails40/depot_f/app/models/product.rb
      class Product < ActiveRecord::Base
     ➤  has_many :line_items
     ➤  before_destroy :ensure_not_referenced_by_any_line_item
       #...
     ➤ private
     
     ➤   # ensure that there are no line items referencing this product
     ➤   def ensure_not_referenced_by_any_line_item
     ➤     if line_items.empty?
     ➤       return true
     ➤     else
     ➤       errors.add(:base, 'Line Items present')
     ➤       return false
     ➤     end
     ➤   end
       end

Here we declare that a product has many line items and define a hook method named `ensure_not_referenced_by_any_line_item()`.
这里我们声明了一个产品有多个在线商品，并定义了一个叫`ensure_not_referenced_by_any_line_item()`的钩子方法。
A hook method is a method that Rails calls automatically at a given point in an object’s life.
钩子方法就是在对象的生命周期中某个给定的地方，Rails会自动调用的方法。
In this case, the method will be called before Rails attempts to destroy a row in the database.
在这个例子中，Rails在尝试删除数据库中的一个数据行之前，会先调用该方法。
If the hook method returns false, the row will not be destroyed.
如果钩子方法返回false，就不会删除改行。

Note that we have direct access to the errors object.
注意，在这里我们直接访问了errors对象。
This is the same place that the validates() stores error messages.
validates()也会把错误信息放在这个对象里。
Errors can be associated with individual attributes, but in this case we associate the error with the base object.
<kinder:note> 错误信息可以关联到单个属性上，但在本例中将错误信息直接与base对象相关联。

We’ll have more to say about intermodel relationships starting in Specifying Relationships in Models, on page 282.
我们会在后面进一步讨论内部模型之间的关系。

## 9.3 Iteration D3: Adding a Button  增加一个按钮
Now that that’s done, it is time to add an Add to Cart button for each product.
现在模型间的关系处理完毕，该给每个产品一个Add to Cart按钮了。

There is no need to create a new controller or even a new action.
我们不必创建一个新的控制器，甚至页不必创建一个新的行为。
Taking a look at the actions provided by the scaffold generator, you find index(), show(), new(), edit(), create(), update(), and destroy().
看一下由脚手架生成器提供的那些行为：索引、显示、新建、编辑、创建、更新、销毁。
The one that matches this operation is create().
我们要添加的这个按钮的操作正好可以用行为create。
(new() may sound similar, but its use is to get a form that is used to solicit input for a subsequent create() action.) 
（new可能听上去也差不多，但这个行为通常是要获得一个表单，可在其中输入某些信息，然后由create继续）

Once this decision is made, the rest follows.
一旦作出决定，那就继续做下去。
What are we creating? 
我们正在创建什么呢？
Certainly not a Cart or even a Product.
肯定不是一个Cart、Product。
What we are creating is a LineItem.
我们正在创建的是LineItem。
Looking at the comment associated with the create() method in app/controllers/line_items_controller.rb, you see that this choice also determines the URL to use (/line_items) and the HTTP method (POST).
看看app/controllers/line_items_controller.rb中的关于create方法的注释，可以发现这个选择也决定了URL(/line_items)和HTTP方法(POST)。

• 111

This choice even suggests the proper UI control to use.
这个决定甚至建议了要用的合适的用户界面控制。
When we added links before, we used link_to(), but links default to using HTTP GET.
在添加链接前，我们使用link_to()，但link默认使用HTTP GET。
We want to use POST, so we will add a button this time; this means we will be using the button_to() method.
而我们需要使用POST，所以我们这次增加了一个按钮；这意味着我们将用button_to()方法。
<kinder:note>这个button_to()方法参见ActionView::Helper::UrlHelper。
button_to(name = nil, options = nil, html_options = nil, &block) 

Options

The options hash accepts the same options as url_for.

There are a few special html_options:

    :method - Symbol of HTTP verb. Supported verbs are :post, :get, :delete, :patch, and :put. By default it will be :post.

    :disabled - If set to true, it will generate a disabled button.

    :data - This option can be used to add custom data attributes.

    :remote - If set to true, will allow the Unobtrusive JavaScript drivers to control the submit behavior. By default this behavior is an ajax submit.

    :form - This hash will be form attributes

    :form_class - This controls the class of the form within which the submit button will be placed

    :params - Hash of parameters to be rendered as hidden fields within the form.

Data attributes

    :confirm - This will use the unobtrusive JavaScript driver to prompt with the question specified. If the user accepts, the link is processed normally, otherwise no action is taken.

    :disable_with - Value of this parameter will be used as the value for a disabled version of the submit button when the form is submitted. This feature is provided by the unobtrusive JavaScript driver.

Examples

    <%= button_to "New", action: "new" %>
    # => "<form method="post" action="/controller/new" class="button_to">
    #      <div><input value="New" type="submit" /></div>
    #    </form>"
    
    <%= button_to "New", new_articles_path %>
    # => "<form method="post" action="/articles/new" class="button_to">
    #      <div><input value="New" type="submit" /></div>
    #    </form>"
    
    <%= button_to [:make_happy, @user] do %>
      Make happy <strong><%= @user.name %></strong>
    <% end %>
    # => "<form method="post" action="/users/1/make_happy" class="button_to">
    #      <div>
    #        <button type="submit">
    #          Make happy <strong><%= @user.name %></strong>
    #        </button>
    #      </div>
    #    </form>"
    
    <%= button_to "New", { action: "new" }, form_class: "new-thing" %>
    # => "<form method="post" action="/controller/new" class="new-thing">
    #      <div><input value="New" type="submit" /></div>
    #    </form>"
    
    <%= button_to "Create", { action: "create" }, remote: true, form: { "data-type" => "json" } %>
    # => "<form method="post" action="/images/create" class="button_to" data-remote="true" data-type="json">
    #      <div>
    #        <input value="Create" type="submit" />
    #        <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"/>
    #      </div>
    #    </form>"
    
    <%= button_to "Delete Image", { action: "delete", id: @image.id },
                                    method: :delete, data: { confirm: "Are you sure?" } %>
    # => "<form method="post" action="/images/delete/1" class="button_to">
    #      <div>
    #        <input type="hidden" name="_method" value="delete" />
    #        <input data-confirm='Are you sure?' value="Delete Image" type="submit" />
    #        <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"/>
    #      </div>
    #    </form>"
    
    <%= button_to('Destroy', 'http://www.example.com',
              method: "delete", remote: true, data: { confirm: 'Are you sure?', disable_with: 'loading...' }) %>
    # => "<form class='button_to' method='post' action='http://www.example.com' data-remote='true'>
    #       <div>
    #         <input name='_method' value='delete' type='hidden' />
    #         <input value='Destroy' type='submit' data-disable-with='loading...' data-confirm='Are you sure?' />
    #         <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"/>
    #       </div>
    #     </form>"


We could connect the button to the line item by specifying the URL, but again we can let Rails take care of this for us by simply appending `_path` to the controller’s name.
我们可以通过指定URL将按钮和在线商品联系起来，但还是让Rails来处理，Rails可以简单地将`_path`追加到控制器的名称后面，从而完成这一联系。
In this case, we will use line_items_path.
在本例中，我们将用line_items_path。

However, there’s a problem with this: how will the line_items_path method know which product to add to our cart? We’ll need to pass it the ID of the product corresponding to the button.
然而，这样做会有一个问题：line_items_path方法如何直到酒精那个产品要添加到购物车中呢？
我们要将和这个按钮相对应的产品id也传给这个方法。
That’s easy enough—all we need to do is add the :product_id option to the line_items_path() call.
这很容易实现--所需做的就是调用line_items_path的时候添加一个:product_id参数。
We can even pass in the product instance itself—Rails knows to extract the ID from the record in circumstances such as these.
我们甚至可以在product实例中传递实例本身--在某些情况下Rails直到从记录中提取id，就像这次。
<kinder:note> 这一句话真是玄妙无穷。可惜现在道行不足，没有参透。

In all, the one line that we need to add to our index.html.erb looks like this:
总之，我们需要添加到index.html.erb中的那一行看起来就像：

     Download rails40/depot_f/app/views/store/index.html.erb
     <% if notice %>
       <p id="notice"><%= notice %></p>
     <% end %>
     <h1>Your Pragmatic Catalog</h1>
     <% cache ['store', Product.latest] do %>
       <% @products.each do |product| %>
         <% cache ['entry', product] do %>
     <div class="entry">
           <%= image_tag(product.image_url) %>
       <h3><%= product.title %></h3>
           <%= sanitize(product.description) %>
       <div class="price_line">
           <span class="price"><%= number_to_currency(product.price) %></span>
     ➤     <%= button_to 'Add to Cart', line_items_path(product_id: product) %>
       </div>
     </div>
         <% end %>
       <% end %>
     <% end %>

There’s one more formatting issue.
这里出现了一个格式问题。
button_to creates an HTML <form>, and that form contains an HTML <div>.
Both of these are normlly block elements, which will appear on the next line.
We’d like to place them next to the price, so we need to add a little CSS magic to make them inline.

• 112

     Download rails40/depot_f/app/assets/stylesheets/store.css.scss
       p, div.price_line {
         margin-left: 100px;
         margin-top: 0.5em;
         margin-bottom: 0.8em;
     ➤   form, div {
     ➤     display: inline;
     ➤   }
       }

Now our index page looks like the following figure.
现在我们的索引网页看起正如下图。
But before we push the button, we need to modify the create() method in the line items controller to expect a product ID as a form parameter.
但在单击这个按钮之前，还需要修改在线商品控制器的create方法，从而使产品id作为表单的参数。
Here’s where we start to see how important the id field is in our models.
这里我们开始发现模型中的id字段是多么重要了。
Rails identifies model objects (and the corresponding database rows) by their id fields.
Rails通过字段id来标识模型对象（以及对应的数据库行）。
If we pass an ID to create(), we’re uniquely identifying the product to add.
如果将id传递给create，那么就能唯一地标识要添加的产品了。

Figure 20—Now there’s an Add to Cart button!

<kinder:note> 下面这一段“为什么”在本节的上面已经讲过了。
Why the create() method? 
The default HTTP method for a link is a get, the default HTTP method for a button is a post, and Rails uses these conventions to determine which method to call.
Refer to the comments inside the app/controllers/line_items_controller.rb file to see other conventions.
We’ll be making extensive use of these conventions inside the Depot application.

Now let’s modify the LineItemsController to find the shopping cart for the current session (creating one if there isn’t one there already), add the selected product to that cart, and display the cart contents.
现在来修改LineItemsController来找当前会话中的购物车（如果还没有，就创建一个），添加所选的产品到购物车中，并显示购物车的内容。

• 113

We use the CurrentCart concern we implemented in Iteration D1 on page 108 to find (or create) a cart in the session.
我们使用前面实现的CurrentCart关联来查找会话里的购物车。

     Download rails40/depot_f/app/controllers/line_items_controller.rb
     class LineItemsController < ApplicationController
     ➤ include CurrentCart
     ➤ before_action :set_cart, only: [:create]
       before_action :set_line_item, only: [:show, :edit, :update, :destroy]
       # GET /line_items
       #...
     end

We include the CurrentCart module and declare that the set_cart() method is to be involved before the create() action.
<kinder:note> 我们包含了CurrentCart模块，声明了set_cart方法在create行为之前调用。
We explore action callbacks in depth in Callbacks, on page 337, but for now all we need to know is that Rails provides the ability to wire together methods that are to be called before, after, or even around controller actions.
<kinder:note> 我们会在后面337页深入学习调用行为，但现在我们需要知道Rails提供了一个方法间连线的能力，它们在控制器行为之前之后甚至左右调用。
In fact, as you can see, the generated controller already uses this facility to set the value of the @line_item instance variable before the show(), edit(), update(), or destroy() actions are called.
<kinder:note> 事实上，正如所见，生成的控制器已经使用了这个方便来在调用show、edit、update或destroy行为之前设置了@line_item实例变量的值。
Now that we know that the value of @cart is set to the value of the current cart, all we need to modify is a few lines of code in the create() method in 1 app/controllers/line_items_controller.rb.  to build the line item itself.
<kinder:note> 既然我们知道@cart的值被设置为当前购物车的值，那我们所需要修改的就只是app/controllers/line_items_controller.rb里的create方法的几行，于是就构建了在线商品自身。
1.  Some lines have been wrapped to fit on the page.

     Download rails40/depot_f/app/controllers/line_items_controller.rb
     def create
       # 修改前的原文是：
       # @line_item = LineItem.new(line_item_params)
     ➤ product = Product.find(params[:product_id])   # parmas参数的内容是网页index的请求传过来的。
     ➤ @line_item = @cart.line_items.build(product: product)
       respond_to do |format|
         if @line_item.save
           # 修改前的原文是：
           # format.html { redirect_to @line_item,
           #               notice: 'Line item was successfully created.' }
     ➤     format.html { redirect_to @line_item.cart,
                         notice: 'Line item was successfully created.' }
           format.json { render action: 'show', status: :created, location: @line_item }
         else
           format.html { render action: 'new' }
           format.json { render json: @line_item.errors, status: :unprocessable_entity }
         end
       end
     end

• 114

We use the params object to get the :product_id parameter from the request.
我们使用params对象来从请求取得:product_id参数。
The params object is important inside Rails applications.
params对象是Rails程序的重要概念。
It holds all of the parameters passed in a browser request.
它保存了所有在浏览器请求中传递的参数。
We store the result in a local variable because there is no need to make this available to the view.
因为视图不需要访问这个结果，所以我们将该结果保存在一个本地变量里。
We then pass that product we found into @cart.line_items.build.
然后将找到的产品传递给@cart.line_items.build。
<kinder:note> 为什么不是line_itmes，而是@cart.line_items？
<kinder:note> 除了build方法，这个数据库关联形式还有什么其他方法呢？
This causes a new line item relationship to be built between the @cart object and the product.
这会构造一个新的@cart对象和product之间的在线商品关系。
You can build the relationship from either end, and Rails will take care of establishing the connections on both sides.
你可以从任何一端来构造这个关系，Rails会帮助建立双方的练习。

We save the resulting line item into an instance variable named @line_item.
我们将这个在线商品的结果保存到一个名为@line_item的实例变量中。
The remainder of this method takes care of handling errors, which we will cover in more detail in Section 10.2, Iteration E2: Handling Errors, on page 124, and handling JSON requests.
这种方法的其余部分是用来处理错误和JSON请求的。处理错误部分我们会在后面E2节讨论细节。
But for now, we want to modify only one more thing: once the line item is created, we want to redirect you to the cart instead of back to the line item.
现在，我们只是想再修改一件事情：一旦创建了在线商品，我们希望将用户重定向到购物车，而不是回到在线商品网页。
Since the line item object knows how to find the cart object, all we need to do is add .cart to the method call.
由于在线商品对象直到如何找到购物车对象，所有我们需要做的就是在方法调用中添加.cart。

As we changed the function of our controller, we know that we will need to update the corresponding functional test.
修改控制器功能时，我们知道需要更新相应的功能测试。
We need to pass a product ID on the call to create and change what we expect for the target of the redirect.
在调用create方法时需要传递产品id给该方法，并将重定向的网址修改为我们想要的。
We do this by updating test/controllers/line_items_controller_test.rb.
通过修改test/controllers/line_items_controller_test.rb就可以做到。

     Download rails40/depot_g/test/controllers/line_items_controller_test.rb
     test "should create line_item" do
       assert_difference('LineItem.count') do
     #   原文：
     #   post :create, line_item: { cart_id: @line_item.cart_id, product_id: @line_item.product_id }
     ➤   post :create, product_id: products(:ruby).id

       end
     # 原文：
     # assert_redirected_to line_item_path(assigns(:line_item))
     ➤ assert_redirected_to cart_path(assigns(:line_item).cart)
     end

While we haven’t talked about the assigns method to date, we have already been using it because it is generated automatically by the scaffold command.
<kinder:note> 当目前为止，我们还没谈到assigns方法，但已经用上，因为它已经在生成的脚手架上了。
This method gives us access to the instance variables that have been (or can be) assigned by controller actions for use in views.
<kinder:note> 这个方法让我们可以访问那些已经（或可能）由控制器行为赋值的、在视图使用的变量。
We now rerun this set of tests.
现在我们重新运行这组测试：

     depot> rake test test/controllers/line_items_controller_test.rb

Confident that the code works as intended, we try the Add to Cart buttons in our browser.
相信代码会如期待的那样工作，现在我们尝试单击浏览器中的Add to Cart按钮。

And Figure 21, Confirmation that the request was processed, on page 115 shows what we see.

• 115

Figure 21—Confirmation that the request was processed

This is a bit underwhelming.
页面普通了些。
Although we have scaffolding for the cart, when we created it, we didn’t provide any attributes, so the view doesn’t have anything to show.
For now, let’s write a trivial template (we’ll tart it up in a minute).
虽然购物车准备了脚手架，但当创建购物车时，我们没有提供任何属性，所以这个视图中什么都没有显示。
<kinder:note> 还是不能理解这个assigns。
现在让我们写个简单的模板（一分钟就够了）：

     Download rails40/depot_f/app/views/carts/show.html.erb
     <% if notice %>
       <p id="notice"><%= notice %></p>
     <% end %>
     <h2>Your Pragmatic Cart</h2>
     <ul>
       <% @cart.line_items.each do |item| %>
       <li><%= item.product.title %></li>
       <% end %>
     </ul>

So, with everything plumbed together, let’s go back and click the Add to Cart button again and see our simple view displayed, as in Figure 22, Cart with new item displayed, on page 116.
好的，所有东西都已经结合在了一起。这时可以返回、再次单击Add to Cart按钮，看到我们的视图显示出来：带有在线商品的购物车。

Go back to http://localhost:3000/, the main catalog page, and add a different product to the cart.
返回主目录页，添加不同商品到购物车中。
You’ll see the original two entries plus our new item in your cart.
你会在购物车中看到原来的两个产品以及新选的产品。
It looks like we have sessions working.
看起来会话工作正常。
It’s time to show our customer, so we call her over and proudly display our handsome new cart.
是时候给客户看看我们的成果了。于是请他过来，展示给他看这个漂亮的、新的购物车。
Somewhat to our dismay, she makes that tsk-tsk sound that customers make just before telling you that you clearly don’t get something.
令我们失望的是，她发出了啧啧的声音，然后说你没有拿出她想要的东西来。

• 116

Figure 22—Cart with new item displayed

Real shopping carts, she explains, don’t show separate lines for two of the same product.
她解释说，真正的购物车不会在不同的行列中出现两个同样的产品。
Instead, they show the product line once with a quantity of 2.
相反，该产品应该只显示一次，数量为2。
It looks like we’re lined up for our next iteration.
看起来我们该做下一次迭代了。

## What We Just Did
It has been a busy, productive day so far.
We’ve added a shopping cart to our store, and along the way we’ve dipped our toes into some neat Rails features.

• We created a Cart object in one request and were able to successfully locate the same cart in subsequent requests using a session object.

• We added a private method and placed it in a concern, making it accessible to all of our controllers.

• We created relationships between carts and line items and relationships between line items and products, and we were able to navigate using these relationships.

• We added a button that caused a product to be posted to a cart, causing a new line item to be created.

• 117

## Playtime
Here’s some stuff to try on your own:
可以自己尝试一下任务：
• Add a new variable to the session to record how many times the user has accessed the store controller’s index action.
  增加一个变量到会话中，以便记录用户已经访问了多少次商店的索引页面。
Note that the first time this page is accessed, your count won’t be in the session.
注意第一次访问这个页面时，你的计数器不在会话中。
You can test for this with code like this:
你可以用类似下面的代码测试一下：

     if session[:counter].nil?
     ...

If the session variable isn’t there, you’ll need to initialize it.
如果会话变量不存在，你需要初始化它。
Then you’ll be able to increment it.
这样你就可以增加它了。

<kinder:note>答案：
1. 修改Store控制器的index方法：

        @count = session[:counter]
        if @count
          @count = @count + 1
        else
          @count = 1
        end
        session[:counter] = @count

2. 修改对应的index.html.haml：

    -if @count > 1
      %p
        == 您已经对本网页访问 #{@count} 次。 

• Pass this counter to your template, and display it at the top of the catalog page.
将这个计数器传给你的模板，并在目录页面的顶部显示该计数器。
Hint: the pluralize helper (definition on page 354) might be useful when forming the message you display.
提示：在构造你要显示的消息时，帮助函数pluralize（后面354页）可能有用。

<kinder:note> 答案：修改布局模板application.html.erb即可

        <% if @count && @count > 1 %>
	  <p>您已经对本页进行<%= @count %> 次访问！</p>
	<% end %>

<kinder:note> 关于pluralize方法的参考：

     pluralize(count, singular, plural = nil) Link

Attempts to pluralize the singular word unless count is 1. If plural is supplied, it will use that when count is > 1, otherwise it will use the Inflector to determine the plural form.

    pluralize(1, 'person')
    # => 1 person
    pluralize(2, 'person')
    # => 2 people
    pluralize(3, 'person', 'users')
    # => 3 users
    pluralize(0, 'person')
    # => 0 people

• Reset the counter to zero whenever the user adds something to the cart.
  每当用户添加东西到购物车时，将计数器重置为0。
<kinder:note> 答案：
在line_items_controller.rb上的create方法增加如下代码：

    session[:counter] = nil

• Change the template to display the counter only if it is greater than five.
  更改模板，只有计数大于5时，才显示该计数器。
(You’ll find hints at http://pragprog.com/wikis/wiki/RailsPlayTime.)
<kinder:note> 答案：
在模板layout/application.html.erb上修改：

        <% if @count && @count > 4 %>
	  <p>您已经对本页进行<%= @count %> 次访问！</p>
	<% end %>



# CHAPTER 10 Task E: A Smarter Cart  更智能的购物车
## In this chapter, we’ll see
• modifying the schema and existing data,
  修改数据库模式与现有数据
• error diagnosis and handling,
  诊断和处理错误
• the flash, and
  闪存
• logging.
  日志

Although we have rudimentary cart functionality implemented, we have much to do.
虽然已经实现了购物车的基本功能，但还是有很多事情要做。
To start with, we will need to recognize when customers add multiples of the same item to the cart.
首先，要识别何时用户将同一商品项目多次添加到购物车中。
Once that’s done, we will also have to make sure that the cart can handle error cases and communicate problems encountered along the way to the customer or system administrator, as appropriate.
一旦完成，还必须确保购物车本身能够处理错误事件，并在问题发生时以一种合适的方式与消费车或系统管理员沟通。

## 10.1 Iteration E1: Creating a Smarter Cart 创建更智能的购物车
Associating a count with each product in our cart is going to require us to modify the line_items table.
由于购物车中的每个产品都要有一个关联的计数器，这就要求修改line_items表。
We’ve used migrations before; for example, we used a migration in Applying the Migration, on page 64, to update the schema of the database.
之前如64页使用过迁移来修改数据库的模式。
While that was as part of creating the initial scaffolding for a model, the basic approach is the same.
虽然这只是建立模型的初始脚手架的一部分，但基本过车是一样的。

    depot> rails generate migration add_quantity_to_line_items quantity:integer

Rails can tell from the name of the migration that you are adding one or more columns to the line_items table and can pick up the names and data types for each column from the last argument.
Rails可以从迁移名称中判断出正在加一个或多个数据字段到line_items表中，还能从最后一个参数中获取每个字段名称和类型。
The two patterns that Rails matches on are add_XXX_to_TABLE and remove_XXX_from_TABLE, where the value of XXX is ignored; what matters is the list of column names and types that appear after the migration name.
Rails有两种匹配模式，即add_xxx_to_TABLE和remove_xxx_from_TABLE，xxx的值被忽略；重要的是出现在迁移之后的字段名及其类型的情况。

The only thing Rails can’t tell is what a reasonable default is for this column.
唯一Rails无法判断的事情是，什么是该字段的合理默认值。
In many cases, a null value would do, but let’s make it the value 1 for existing carts by modifying the migration before we apply it.
在许多情况下，默认值为null，但在应用迁移之前，应该把已有购物车的默认值设置为1。
<kinder:note> 购物车内的物品数量不能小于1,否则就不会出现在购物车内。

     Download rails40/depot_g/db/migrate/20121130000004_add_quantity_to_line_items.rb
     class AddQuantityToLineItems < ActiveRecord::Migration
       def change
     ➤   add_column :line_items, :quantity, :integer, default: 1
       end
     end

• 120

Once complete, we run the migration.
一旦完成修改，我们运行迁移。

     depot> rake db:migrate

Now we need a smart add_product() method in our Cart, one that checks whether our list of items already includes the product we’re adding; if it does, it bumps the quantity, and if it doesn’t, it builds a new LineItem.
现在Cart中需要一个聪明的add_product()方法，该方法用来判断商品清单中是否已经包含了想要添加的产品；如果是，就增加数量；否则就生成新的LineItem：
<kinder:note> 这个方法能否放在控制器呢？不能，因为它涉及写入操作数据库的数据。
<kinder:note> 可是为什么它不是在lineitem上？而是在cart上呢？仅仅因为这个操作的情景在cart上吗？

     Download rails40/depot_g/app/models/cart.rb
       def add_product(product_id)
         current_item = line_items.find_by(product_id: product_id)
         if current_item
           current_item.quantity += 1
         else
           current_item = line_items.build(product_id: product_id)
           # 这一行同上一章line_items_controller.rb的create方法上的一行。
         end
         current_item
       end

The find_by() method is a streamlined version of the where() method.
<kinder:note> find_by()方法是where()方法的改进版。
Instead of returning an array of results, it returns either an existing LineItem or nil.
和where方法返回一个数组不同，find_by方法返回一个已有的LineItem，或者nil。
We also need to modify the line item controller to use this method.
我们也需要修改在线商品控制器，以使用这个方法。

     Download rails40/depot_g/app/controllers/line_items_controller.rb
       def create
         product = Product.find(params[:product_id])
     ➤   @line_item = @cart.add_product(product.id)
         # 这一行的原文是：
       # @line_item = @cart.line_items.build(product: product)

         respond_to do |format|
           if @line_item.save
             format.html { redirect_to @line_item.cart,
                           notice: 'Line item was successfully created.' }
             format.json { render action: 'show',
                           status: :created, location: @line_item }
           else
             format.html { render action: 'new' }
             format.json { render json: @line_item.errors,
                           status: :unprocessable_entity }
           end
         end
       end

There’s one last quick change to the show view to use this new information.
要使用这个新信息，还需要快速修改show视图：

     Download rails40/depot_g/app/views/carts/show.html.erb
       <% if notice %>
         <p id="notice"><%= notice %></p>
       <% end %>
       <h2>Your Pragmatic Cart</h2>
       <ul>
       <% @cart.line_items.each do |item| %>
     ➤   <li><%= item.quantity %> &times; <%= item.product.title %></li>
       <% end %>
       </ul>

• 121

Now that all the pieces are in place, we can go back to the store page and hit the Add to Cart button for a product that is already in the cart.
现在所有东西都已到位，可以回到商店页面，单击Add to Cart按钮查看已在购物车里的在线商品。
What we are likely to see is a mixture of individual products listed separately and a single product listed with a quantity of two.
可能会看到的是：数量1和数量为2的产品分开列出。
This is because we added a quantity of one to existing columns instead of collapsing multiple rows when possible.
这是因为我们增加了数量1到现有字段，来取代有可能铺开多行的显示方式。

What we need to do next is migrate the data.
下一步要做的是数据迁移。
<kinder:note> 为什么需要迁移，因为上面的内容只是针对以后的操作。 而之前，已经有了一批分行的数据。 这就需要把这些分行的数据进行合并。

We start by creating a migration.
先创建一个迁移。

     depot> rails generate migration combine_items_in_cart

This time, Rails can’t infer what we are trying to do, so we can’t rely on the generated change() method.
<kinder:note> 这次，Rails可推断不出想做什么了，我们不能依赖生成的change()方法。

What we need to do instead is to replace this method with separate up() and down() methods.
<kinder:note> 我们需要用独立的up()和down()方法来替代change()方法。
First here’s the up() method:
<kinder:note> 首先是up()方法：

     Download rails40/depot_g/db/migrate/20121130000005_combine_items_in_cart.rb
     def up
       # replace multiple items for a single product in a cart with a single item
       Cart.all.each do |cart|
         # count the number of each product in the cart
         sums = cart.line_items.group(:product_id).sum(:quantity)
         sums.each do |product_id, quantity|
           if quantity > 1
             # remove individual items
             cart.line_items.where(product_id: product_id).delete_all
             # replace with a single item
             item = cart.line_items.build(product_id: product_id)
             item.quantity = quantity
             item.save!
           end
         end
       end
     end

This is easily the most extensive code we’ve seen so far.
这显然是目前为止代码扩充得最多的地方。
Let’s look at it in small pieces:
接下来仔细分析：

• We start by iterating over each cart.
  从迭代每个购物车开始。
• For each cart, we get a sum of the quantity fields for each of the line items associated with this cart, grouped by product_id.
  对于每个购物车及其每个相关联的商品项目，按照字段product_id进行分组，得出各个字段数量之和。
The resulting sums will be a list of ordered pairs of product_ids and quantity.
计算结果将是字段product_id和数量对的有序列表。

iterating ↪ on page 44

• We iterate over these sums, extracting the product_id and quantity from each.
然后迭代每一组的和，从每一组中提取product和quantity。
• In cases where the quantity is greater than one, we will delete all of the individual line items associated with this cart and this product and replace them with a single line item with the correct quantity.
对于数量大于1的组，将删除与该购物车和该产品相关联的所有单个商品项目，然后用正确数量的单行商品项目来代替它们。

• 122

Note how easily and elegantly Rails enables you to express this algorithm.
注意，Rails可以如此简单和优雅地来表示这个算法。
With this code in place, we apply this migration just like any other migration.
代码到位后，就像应用别的迁移一样来处理这个迁移：

     depot> rake db:migrate

We can immediately see the results by looking at the cart.
马上就可以通过查看购物车得到结果了。

Figure 23—Three LineItems combined into one

Although we have reason to be pleased with ourselves, we are not done yet.
虽然我们有理由高兴，但事情还没做完。
An important principle of migrations is that each step needs to be reversible, so we implement a down() too.
迁移的一个重要原则是，每一步都应该是可逆的；所以还要实现一个down方法。
This method finds line items with a quantity of greater than one; adds new line items for this cart and product, each with a quantity of one; and finally deletes the line item.
这个方法查找数量大于1的商品项目，为该购物车和产品添加一个新的商品项目，1个数量增加一行，最后删除该商品项目多余的行。
The following code accomplishes that:
该操作的代码如下：

     Download rails40/depot_g/db/migrate/20121130000005_combine_items_in_cart.rb
       def down
         # split items with quantity>1 into multiple items
         LineItem.where("quantity>1").each do |line_item|
           # add individual items
           line_item.quantity.times do
             LineItem.create cart_id: line_item.cart_id,   
             product_id: line_item.product_id, quantity: 1
             #<kinder:note> 这两句（其实是一句）挺有意思，`cart_id`和`procut_id`、`quantity`都是create的参数。
           end
           # remove original item
           line_item.destroy
         end
       end

• 123

At this point, we can just as easily roll back our migration with a single command.
现在可以很容易地用下面的命令进行回滚迁移了：

    depot> rake db:rollback

Rails provides a handy rake task to allow you to check the status of your migrations.
<kinder:note> Rails提供了一个方便的rake任务，允许检查迁移的状态：

     depot> rake db:migrate:status
     database: /home/rubys/work/depot/db/development.sqlite3
     Status Migration ID Migration Name
     -------------------------------------------------
     up 20130407000001 Create products
     up 20130407000002 Create carts
     up 20130407000003 Create line items
     up 20130407000004 Add quantity to line items
     down 20130407000005 Combine items in cart

At this point you can modify and reapply the migration or even delete it entirely.
<kinder:note> 这样你可以修改，重新应用迁移，或者完全删除它们。
We can inspect the results of the rollback by moving the migration to another directory and looking at the cart.
<kinder:note> 可以通过将一个迁移移动到另一个目录来看看回滚的结果，看看购物车。

Figure 24—LineItems once again split apart

Once we move the migration file back and reapply the migration (with the rake db:migrate command), we have a cart that maintains a count for each of the products it holds, and we have a view that displays that count.
<kinder:note> 一旦我们移回了迁移文件，使用`rake db:migrate`命令重新应用迁移，我们又有了一个包含数量和商品的购物车，和一个显示数量的视图。

Happy that we have something presentable, we call our customer over and show her the result of our morning’s work.
令人高兴的是，有东西可以展示了，我们让客户过来并告诉他今天上午的工作成果。
She’s pleased—she can see the site starting to come together.
她很高兴看到网站开始组合在了一起。
However, she’s also troubled, having just read an article in the trade press on the way ecommerce sites are being attacked and compromised daily.
不过，她还是有些困扰，她刚在贸易报刊的文章中看到：这种电子商务网站每天都被攻击和损害。
She read that one kind of attack involves feeding requests with bad parameters into web applications, hoping to expose bugs and security flaws.
她读到有种攻击是通过传递带错误参数的请求到Web应用程序，希望网站能够暴露出缺陷和安全漏洞。
She noticed that the link to the cart looks like carts/nnn, where nnn is our internal cart ID.
她注意到购物车的链接看起来像是cats/nnn，nnn是内部购物车的id。
Feeling malicious, she manually types this request into a browser, giving it a cart ID of wibble.
正是感觉到不安，她在浏览器上输入了购物车号为ID的请求。
She’s not impressed when our application displays the page in Figure 25, Our application spills its guts., on page 124.
应用程序一下子暴露出了自己的内部信息，她感到很不高兴。

 • 124

Figure 25—Our application spills its guts.

This seems fairly unprofessional.
看上去这很不专业。
So, our next iteration will be spent making the application more resilient.
所以下一个迭代将是使应用程序具有更强的韧性。

## 10.2 Iteration E2: Handling Errors 处理错误
Looking at the page displayed in the previous figure, it’s apparent that our application raised an exception at line 67 of the carts controller.1 
看看上页所示的这个网页，很明显应用程序在购物车控制器的第16行抛出了异常。
That turns out to be this line:
也就是这一行：

    @cart = Cart.find(params[:id])

1.  Your line number might be different. We have some book-related formatting stuff in our source files.

• 125

If the cart cannot be found, Active Record raises a RecordNotFound exception, which we clearly need to handle.
如果无法找到购物车，Active Record会抛出一个RecordNotFound异常，这个异常显然需要处理。
The question arises—how?
问题在于：如何处理它？
<kinder:note> 实际上，用户可能不止输入类似这样的错误，所以找不到的网页应该都通通显示404代码，才更加合理！

We could just silently ignore it.
当然可以忽略它。
From a security standpoint, this is probably the best move, because it gives no information to a potential attacker.
从安全的角度看，这可能是最好的，因为它没有给潜在的攻击者提供所需要的信息。
However, it also means that should we ever have a bug in our code that generates bad cart IDs, our application will appear to the outside world to be unresponsive—no one will know there has been an error.
不过，这也意味着，代码中应该有个漏洞，这个漏洞产生了错误的购物车id，应用程序会出现对外界没有相应的情况--没人直到程序里发生的错误。

Instead, we’ll take two actions when an exception is raised.
另一个方法是，当异常抛出时采取两个行动。
First, we’ll log the fact to an internal log file using Rails’ logger facility.2 
2.  http://guides.rubyonrails.org/debugging_rails_applications.html#the-logger
首先，用Rails的日志功能在内部日志文件中记录发生的事实。
Second, we’ll redisplay the catalog page along with a short message to the user (something along the lines of “Invalid cart”) so they can continue to use our site.
其次，重新显示目录页，并发个短消息给用户（比如“无效购物车”等），使他们可以继续使用网站。

Rails has a convenient way of dealing with errors and error reporting.
Rails提供了方便的处理错误和报告错误的方法。
It defines a structure called a flash.
它定义了称为闪存的结构。
A flash is a bucket (actually closer to a Hash) in which you can store stuff as you process a request.
闪存是一个桶（实际上更接近一个散列），当处理请求时，可以在其中存储东西。
The contents of the flash are available to the next request in this session before being deleted automatically.
对于同一会话的下次请求，在自动删除闪存内容之前，闪存中的内容都是有效的。
Typically the flash is used to collect error messages.
通常情况下闪存是用来收集错误信息的。
For example, when our show() method detects that it was passed an invalid cart ID, it can store that error message in the flash area and redirect to the index() action to redisplay the catalog.
例如，当show方法发现传递给它的参数是个无效的购物车id时，可以将这个错误信息存储在闪存中，并重定向到index行动，以重新显示商品目录。
The view for the index action can extract the error and display it at the top of the catalog page.
index行动的视图可以提示错误，并将其显示在目录页的顶部。
The flash information is accessible within the views by using the flash accessor method.
在视图中可以用闪存存取方法来访问闪存的消息。

Why couldn’t we just store the error in any old instance variable? 
为什么不能将错误存放在老的实例变量中呢？
Remember that after a redirect is sent by our application to the browser, the browser sends a new request back to our application.
要记得，应用程序发送重定向浏览器后，浏览器返回一个新的请求给应用程序。
By the time we receive that request, our application has moved on—all the instance variables from previous requests are long gone.
在收到请求的这段时间内，应用程序已经继续向前运行了--所有以前请求中的实例变量都已不复存在。
The flash data is stored in the session in order to make it available between requests.
闪存数据存储在会话中，以使其能在请求与请求的中间被访问。

Armed with all this background about flash data, we can now create an invalid_cart() method to report on the problem.
<kinder:note> 有了关于闪存数据的相关背景知识之后，现在可以创建一个invalid_cart()方法来报告这个问题。

       Download rails40/depot_h/app/controllers/carts_controller.rb
       class CartsController < ApplicationController
         before_action :set_cart, only: [:show, :edit, :update, :destroy]
     ➤   rescue_from ActiveRecord::RecordNotFound, with: :invalid_cart
         # GET /carts
         # ...
         private
         # ...
     ➤   def invalid_cart
     ➤     logger.error "Attempt to access invalid cart #{params[:id]}"
     ➤     redirect_to store_url, notice: 'Invalid cart'
     ➤   end
       end

• 126

The rescue_from clause intercepts the exception raised by Cart.find().
<kinder:note> rescue_from语句拦截了Cart.find()抛出的异常。
In the handler, we do the following:
在该句柄中，做到以下几点：

• Use the Rails logger to record the error.
 使用Rails日志器记录错误。
Every controller has a logger attribute.
每个控制器有一个logger属性。
Here we use it to record a message at the error logging level.
这里用它来记录错误日志级别的消息。

• Redirect to the catalog display using the redirect_to() method.
  使用redirect_to()方法重定向到目录页。
The :notice parameter specifies a message to be stored in the flash as a notice.
参数:notice指定存储在闪存中的通知信息。
Why redirect rather than just display the catalog here?
为什么这里要重定向，而不是仅仅显示目录页？
If we redirect, the user’s browser will end up displaying the store URL, rather than http://.../cart/wibble.
如果是重定向，用户的浏览器将终止于显示商店的网址，而不是http://...cart/wibble。
We expose less of the application this way.
这样可以更少地暴露应用程序的信息。
We also prevent the user from retriggering the error by hitting the Reload button.
还可以防止用户通过单击刷新按钮再次引发这个错误。

With this code in place, we can rerun our customer’s problematic query.
有了这个代码，可以重新运行那个引起问题的查询。
This time, when we enter the following URL:
输入下面的网址：

    http://localhost:3000/carts/wibble

we don’t see a bunch of errors in the browser.
浏览器里没看到一堆错误信息了。
Instead, the catalog page is displayed.
看到的是目录页。
If we look at the end of the log file (development.log in the log directory), we’ll see our message.
如果看看日志文件的结尾部分（log/development.log），会看到这样的信息：

       Started GET "/carts/wibble" for 127.0.0.1 at 2013-01-29 09:37:39 -0500
       Processing by CartsController#show as HTML
         Parameters: {"id"=>"wibble"}
         ^[[1m^[[35mCart Load (0.1ms)^[[0m SELECT "carts".* FROM "carts" WHERE
       "carts"."id" = ? LIMIT 1 [["id", "wibble"]]
     ➤ Attempt to access invalid cart wibble
       Redirected to http://localhost:3000/
       Completed 302 Found in 3ms (ActiveRecord: 0.4ms)

Figure 26, Much more user-oriented error message, on page 127 shows a better way.

On Unix machines, we’d probably use a command such as tail or less to view this file.
On Windows, you could use your favorite editor.
It’s often a good idea to keep a window open showing new lines as they are added to this file.
In Unix you’d use tail -f.
You can download a tail command for Windows 3 or get a GUI-based tool.4 
Finally, some OS X users use Console.app to track log files.
Just say open name.log at the command line.

3. http://gnuwin32.sourceforge.net/packages/coreutils.htm
4. http://tailforwin32.sourceforge.net/

• 127

Figure 26—Much more user-oriented error message

This being the Internet, we can’t just worry about our published web forms; we have to worry about every possible interface because malicious crackers can get underneath the HTML we provide and attempt to provide additional parameters.
<kinder:note> 现在是互联网时代，我们不能只是担心我们的公开的web窗体；还要担心任何接口，因为恶意攻击者能够得到我们提供的HTML底层并试图提出额外的参数。
Invalid carts aren’t our biggest problem here; we also want to prevent access to other people’s carts.
<kinder:note> 无效购物车并不是我们最大的问题，我们还要阻止他们访问其他人的购物车。

As always, your controllers are your first line of defense.
<kinder:note> 你的控制器如常是你的第一线屏障。
Let’s go ahead and remove cart_id from the list of parameters that are permitted.
<kinder:note> 我们接下来从允许的参数列表中移除cart_id：

       Download rails40/depot_h/app/controllers/line_items_controller.rb
       # Never trust parameters from the scary internet, only allow the white
       # list through.
         def line_item_params
     ➤     params.require(:line_item).permit(:product_id)
           # 原文是：
           # params.require(:line_item).permit(:product_id, :cart_id)
         end

<kinder:note> 
可是上面的代码仍然不能阻止用户访问他人的购物车。如果在输入http://0.0.0.0:3000/carts/2，就可以访问别人的购物车。
应该在ｓｈｏｗ方法中加入如下代码：

    def show
      if @cart.id != session[:cart_id]
        respond_to do |format|
          format.html { redirect_to store_url, notice: '无效购物车'}
        end
      end
    end

</kinder:note> 

We can see this in action by rerunning our controller tests.
<kinder:note> 通过重新运行控制器测试，可以看到这个行动。

     rake test:controllers

While no tests fail, a quick peek into our log/test.log reveals an attempt to breach security that was thwarted.
<kinder:note> 虽然没有测试失败，但看看log/test.log就显示了一个突破安全的尝试被阻止了。
<kinder:note> 那怎样测试没有报错呢？不可能是因为这个测试被中断了，后面的assertJ_redirected_to()没有执行。

• 128

       LineItemsControllerTest: test_should_update_line_item
       ----------------------------------------------------
         ^[[1m^[[36m (0.0ms)^[[0m ^[[1mbegin transaction^[[0m
         ^[[1m^[[35mLineItem Load (0.1ms)^[[0m SELECT "line_items".* FROM
       "line_items" WHERE "line_items"."id" = ? LIMIT 1 [["id", 980190962]]
       Processing by LineItemsController#update as HTML
         Parameters: {"line_item"=>{"product_id"=>nil}, "id"=>"980190962"}
         ^[[1m^[[36mLineItem Load (0.1ms)^[[0m ^[[1mSELECT "line_items".* FROM
       "line_items" WHERE "line_items"."id" = ? LIMIT 1^[[0m [["id", "980190962"]]
     ➤ Unpermitted parameters: cart_id
         ^[[1m^[[35m (0.0ms)^[[0m SAVEPOINT active_record_1
         ^[[1m^[[36m (0.1ms)^[[0m ^[[1mRELEASE SAVEPOINT active_record_1^[[0m
       Redirected to http://test.host/line_items/980190962
       Completed 302 Found in 2ms (ActiveRecord: 0.2ms)
         ^[[1m^[[35m (0.0ms)^[[0m rollback transaction

Cleaning up that test case will make the problem go away.
<kinder:note> 清除那个测试例子将会导致一个问题消失。

       Download rails40/depot_h/test/controllers/line_items_controller_test.rb
       test "should update line_item" do
     ➤   patch :update, id: @line_item, line_item: { product_id: @line_item.product_id }
         # 原文是：
         # patch :update, id: @line_item, line_item: { cart_id: @line_item.cart_id, product_id: @line_item.product_id }

         assert_redirected_to line_item_path(assigns(:line_item))
       end

At this point, we clear the test logs and rerun the tests.
<kinder:note> 现在，我们清除测试日志，重新运行测试。

     rake log:clear LOGS=test
     rake test:controllers

<kinder:note> log/test.log相关对应片段如下：

    LineItemsControllerTest: test_should_update_line_item
    -----------------------------------------------------
      [1m[36mLineItem Load (0.2ms)[0m  [1mSELECT  "line_items".* FROM "line_items"  WHERE "line_items"."id" = ? LIMIT 1[0m  [["id", 980190962]]
    Processing by LineItemsController#update as HTML
      Parameters: {"line_item"=>{"product_id"=>nil}, "id"=>"980190962"}
      [1m[35mLineItem Load (0.2ms)[0m  SELECT  "line_items".* FROM "line_items"  WHERE "line_items"."id" = ? LIMIT 1  [["id", 980190962]]
      [1m[36m (0.1ms)[0m  [1mSAVEPOINT active_record_1[0m
      [1m[35m (0.1ms)[0m  RELEASE SAVEPOINT active_record_1
    Redirected to http://test.host/line_items/980190962
    Completed 302 Found in 4ms (ActiveRecord: 0.4ms)
      [1m[36m (0.2ms)[0m  [1mrollback transaction[0m

A final scan of the logs identifies no further problems.
浏览了log最后确定没有其他问题。
<kinder:note> 在gvim上浏览一遍log文件：密密麻麻都是字，怎么确认问题啊！
It makes good sense to review log files periodically—they have a lot of useful information.
经常查看log文件是个好习惯，那里的有用信息太多了。

Sensing the end of an iteration, we call our customer over and show her that the error is now properly handled.
She’s delighted and continues to play with the application.
She notices a minor problem on our new cart display—there’s no way to empty items out of a cart.
她发现新购物车显示页面有个小问题--没有办法清空购物车。
This minor change will be our next iteration.
We should make it before heading home.

## 10.3 Iteration E3: Finishing the Cart  对购物车进行最后加工
We know by now that in order to implement the “empty cart” function, we have to add a link to the cart and modify the destroy() method in the carts controller to clean up the session.
现在我们知道，为了实现“清空购物车”功能，必须在购物车中添加链接，并修改购物车控制器中的destroy方法来清理会话。

Let’s start with the template and again use the button_to() method to put a button on the page.
先从模板开始，并再次用button_to()方法给页面添加按钮。

• 129

------------------------------
David says: Battle of the Routes: product_path vs. product_url
戴维说：路由的争斗：product_path和product_url
It can seem hard in the beginning to know when to use product_path and when to use product_url when you want to link or redirect to a given route.
当链接或重定向到一个给定的路由时，在一开始似乎很难知道何时用product_path，何时用product_url。
In reality, it’s really quite simple.
实际上，它真的很简单。

When you use product_url, you’ll get the full enchilada with protocol and domain name, like http://example.com/products/1.
当用product_url时，会得到包括协议和域名的完整信息，如http://example.com/products/1。
That’s the thing to use when you’re doing redirect_to because the HTTP spec requires a fully qualified URL when doing 302 Redirect and friends.
这就是在用redirect_to时所要的，因为在做302重定向时，HTTP规范要求完全合格的URL。
You also need the full URL if you’re redirecting from one domain to another, like 
如果从一个域到另一个域的重定向，那么也需要完整的URL，就像这样的格式：

    product_url(domain: "example2.com", product: product).

The rest of the time, you can happily use product_path.
在其他的情况下，使用prodcut_path也无妨。
This will generate only the /products/1 part, and that’s all you need when doing links or pointing forms, like 
它仅生成/product/1部分，当想要链接到或转向表单时，这一部分就足够了。

    link_to "My lovely product", product_path(product).

The confusing part is that oftentimes the two are interchangeable because of lenient browsers.
令人困惑的地方是，一些要求不严谨的浏览器常常互换这两个。
You can do a redirect_to with a product_path and it’ll probably work, but it won’t be valid according to spec.
你可以构造一个使用product_path的redirect_to，它也能工作，但按照规范它是无效的。
And you can link_to a product_url, but then you’re littering up your HTML with needless characters, which is a bad idea too.
你可以link_to一个product_url，但HTML就会充斥着不必要的字符，这可是个坏注意。

------------------------------

     Download rails40/depot_h/app/views/carts/show.html.erb
     <% if notice %>
       <p id="notice"><%= notice %></p>
     <% end %>
     <h2>Your Pragmatic Cart</h2>
     <ul>
     <% @cart.line_items.each do |item| %>
       <li><%= item.quantity %> &times; <%= item.product.title %></li>
     <% end %>
     </ul>
     ➤ <%= button_to 'Empty cart', @cart, method: :delete,
     ➤     data: { confirm: 'Are you sure?' } %>

In the controller, we’ll modify the destroy() method to ensure that the user is deleting their own cart (think about it!) and to remove the cart from the session before redirecting to the index page with a notification message.
在控制器中修改destroy()方法，以确保用户只是删除他自己的的购物车（想想吧），并在重定向到索引页面之前（带有通知消息），从会话中删除该购物车。
<kinder:note> 因为/carts页面是公开的。

       Download rails40/depot_h/app/controllers/carts_controller.rb
       def destroy
         # 原文：
         # @cart.destroy
     ➤   @cart.destroy if @cart.id == session[:cart_id]
     ➤   session[:cart_id] = nil
         respond_to do |format|
     ➤     format.html { redirect_to store_url,
     ➤                   notice: 'Your cart is currently empty' }
           # 原文是：
           # format.html { redirect_to carts_url, notice: 'Cart was successfully destroyed.'}
           format.json { head :no_content }
         end
       end

• 130

And we update the corresponding test in test/controllers/carts_controller_test.rb.
然后更新对应的测试：

       Download rails40/depot_i/test/controllers/carts_controller_test.rb
       test "should destroy cart" do
         assert_difference('Cart.count', -1) do
     ➤     session[:cart_id] = @cart.id
           # 这一句原代码没有。
           delete :destroy, id: @cart
         end
     ➤   assert_redirected_to store_path
         # 原代码：
         # assert_redirected_to store_path
       end

       # <kinder:note> 上面改了show方法，这里当然要改了。
       test "should show cart" do
         get :show, id: @cart
         assert_redirected_to store_path
       end


Now when we view our cart and click the Empty cart button, we get taken back to the catalog page, and a nice little message says this:
现在看看购物车并单击“清空购物车”按钮，网页自动回到了目录页面，同时还有个漂亮的消息如下：

Figure 27—Flash alert: cart in need of products

We can also remove the flash message that is automatically generated when a line item is added.
添加在线商品时，也可以删除那个自动生成的闪存。

       Download rails40/depot_i/app/controllers/line_items_controller.rb
       def create
         product = Product.find(params[:product_id])
         @line_item = @cart.add_product(product.id)
         respond_to do |format|
           if @line_item.save
     ➤       format.html { redirect_to @line_item.cart }
             # <kinder:note> 那个闪存应该更加详细一些，而不是一删了之。下面是我的修改：
             # format.html { redirect_to @line_item.cart, notice: "#{@line_item.product.title} 已经放入购物车！" }
             format.json { render action: 'show',
                           status: :created, location: @line_item }
           else
             format.html { render action: 'new' }
             format.json { render json: @line_item.errors,
                           status: :unprocessable_entity }
           end
         end
       end

And, finally, we’ll get around to tidying up the cart display.
最后，整理一下购物车的显示页面。
Rather than use <li> elements for each item, let’s use a table.
用表格来整理该页面，而不是给每个商品加上<li>元素。
Again, we’ll rely on CSS to do the styling.
同样，用CSS制作样式。

• 131

       Download rails40/depot_i/app/views/carts/show.html.erb
       <% if notice %>
         <p id="notice"><%= notice %></p>
       <% end %>
     ➤ <h2>Your Cart</h2>
     ➤ <table>
         <% @cart.line_items.each do |item| %>
     ➤   <tr>
     ➤     <td><%= item.quantity %>&times;</td>
     ➤     <td><%= item.product.title %></td>
     ➤     <td class="item_price"><%= number_to_currency(item.total_price) %></td>
     ➤   </tr>
       <% end %>
     ➤   <tr class="total_line">
     ➤     <td colspan="2">Total</td>
     ➤     <td class="total_cell"><%= number_to_currency(@cart.total_price) %></td>
     ➤   </tr>
     ➤ </table>
       <%= button_to 'Empty cart', @cart, method: :delete,
           data: { confirm: 'Are you sure?' } %>

To make this work, we need to add a method to both the LineItem and Cart models that returns the total price for the individual line item and entire cart, respectively.
要让这个代码运行，需要为LineItem和Cart模型增加一个方法，分别返回每种商品的总价、所有商品的总价。
Here’s the line item, which involves only simple multiplication:
这是在线商品，只是调用乘法：

     Download rails40/depot_i/app/models/line_item.rb
     def total_price
       product.price * quantity
     end

We implement the Cart method using Rails’ nifty Array::sum() method to sum the prices of each item in the collection.
Cart模型中则使用Rails漂亮的Array::sum()方法来总计集合中各个元素的价格总和：

     Download rails40/depot_i/app/models/cart.rb
     def total_price
       line_items.to_a.sum { |item| item.total_price }
     end

Then we need to add a small bit to our carts.css.scss stylesheet.

     Download rails40/depot_i/app/assets/stylesheets/carts.css.scss
     // Place all the styles related to the Carts controller here.
     // They will automatically be included in application.css.
     // You can use Sass (SCSS) here: http://sass-lang.com/
     ➤ .carts {
     ➤   .item_price, .total_line {
     ➤     text-align: right;
     ➤   }
     ➤   .total_line .total_cell {
     ➤     font-weight: bold;
     ➤     border-top: 1px solid #595;
     ➤   }
     ➤ }

• 132

Figure 28, Cart display with a total, on page 132 shows a nicer-looking cart:

Figure 28—Cart display with a total

## What We Just Did
Our shopping cart is now something the client is happy with.
Along the way, we covered the following:

• Adding a column to an existing table, with a default value
• Migrating existing data into the new table format
• Providing a flash notice of an error that was detected
• Using the logger to log events
• Removing a parameter from the permitted list
• Deleting a record
• Adjusting the way a table is rendered, using CSS

But, just as we think we’ve wrapped up this functionality, our customer wanders over with a copy of Information Technology and Golf Weekly.
Apparently, there’s an article about the “Ajax” style of browser interface, where stuff gets updated on the fly.
Hmmm…let’s look at that tomorrow.

• 133

## Playtime 练习时间
Here’s some stuff to try on your own:
可以自己尝试一下任务：

• Create a migration that copies the product price into the line item, and change the add_product() method in the Cart model to capture the price whenever a new line item is created.
  创建一个迁移，该迁移将产品的价格复制给在线商品，并修改Cart模型中的add_product()方法，每当创建一个新的在线商品时，该方法都可获得价格。
<kinder:note> 价格信息本无需如此，但复制好信息可以提防后来更改商品信息。
产生迁移：
rails g migration add_price_to_line_items price: :decimal

修改迁移文件：
    add_column :line_items, :price, :decimal, precision: 8, scale: 2

应用迁移：
rake db:migrate

修改app/models/cart.rb，获得价格
add_product方法else从句增加
current_item.price = current_item.product.price

app/views/carts/show.rb，增加一行价格，如：

    %table
      %tr
        %td 商品名称
        %td 单价
        %td &times;
        %td 数量
        %td 合计
      -@cart.line_items.each do |item|
        %tr
          %td= item.product.title
          %td= item.price
          %td &times;
          %td= item.quantity
          %td.item_price= number_to_currency(item.total_price)
      %tr.total_line
        %td 总计
        %td.total_cell= number_to_currency(@cart.total_price)

还有css文件：

    .carts {
      table,td{
        border-bottom: 1px solid green;
        border-collapse: collapse;
        padding: 10px;
      }
      ...
    }

复制已有值的价格（慎重！因为中途迁移会导致数据失真！）
$ rails g migration replenish_price_in_cart
编辑db/migration/20140820000001_replenish_price_in_cart.rb

      def up
        Cart.all.each do |cart|
          cart.line_items.each do |item|
            unless item.price
               # item.price = item.product.price 这一句我写的，没有作用，下面一句是答案
              item.update_attributes :price => item.product.price  
            end
          end
        end
      end
      def down
        Cart.all.each do |cart|
          cart.line_items.each do |item|
            if item.price
              # item.price = nil   这一句我写的，没有作用，下面一句是答案
              item.update_attributes :price => nil  
            end
          end
        end
      end

<kinder:note> 下面是论坛上贴出的答案，答题者是 Marius，不过我没有运行他的答案。

    The migration first: rails generate migration add_product_price_to_line_item price:decimal

    class AddProductPriceToLineItem < ActiveRecord::Migration
      def self.up
        add_column :line_items, :price, :decimal, :precision => 8, :scale => 2
    
        say_with_time "Updating prices..." do
          LineItem.find(:all).each do |lineitem|
            lineitem.update_attribute :price, lineitem.product.price
          end
        end
      end
    
      def self.down
        remove_column :line_items, :price
      end
    end
    
    In app/models/cart.rb
    
    
    def add_product(product_id, product_price)
      current_item = line_items.where(:product_id => product_id).first
      if current_item
        current_item.quantity += 1
      else
        current_item = LineItem.new(:product_id => product_id, :price => product_price)
        line_items << current_item
      end
      current_item
    end
    
    In app/controllers/line_items_controller.rb pass product.price as an argument in the Create action:
    
    
    def create
      @cart = current_cart
      product = Product.find(params[:product_id])
      @line_item = @cart.add_product(product.id, product.price)
      session[:counter] = 0
      respond_to do |format|
        if @line_item.save
          format.html { redirect_to(@line_item.cart) }
          format.xml  { render :xml => @line_item, :status => :created, :location => @line_item }
        else
          format.html { render :action => "new" }
          format.xml  { render :xml => @line_item.errors, :status => :unprocessable_entity }
        end
      end
    end


• Add unit tests that add unique products and duplicate products.
当添加唯一产品和重复产品时，添加单元测试。
Note that you will need to modify the fixture to refer to products and carts by name, for example product: ruby.
注意你将需要修改静态测试以达到通过名称来引用产品和购物车，例如product: ruby。
<kinder:note> 本身这个题意就有些难了。什么叫做“添加唯一产品”？什么叫做“添加重复产品”？

Hint: 
答案提示：
add two tests to test/models/cart_test.rb; 
在test/models/cart_test.rb里增加两个测试。
in one test create a cart, add two different books to the cart, and then make assertions as to what the cart.line_items.size and cart.total_price should be. 
在一个测试里创造一个购物车，新增两个不同的书籍到购物车里，断言cart.line_items.size和cart.total_price的结果。
Make sure to save the LineItems that you create before making these assertions.

Readers’ Solutions
读者的方案：
Long says

My attempt:
In test/unit/cart_test.rb:


  def new_cart_with_one_product(product_name)
    cart = Cart.create
    cart.add_product(products(product_name).id)
    cart
  end

  test 'cart should create a new line item when adding a new product' do
    cart = new_cart_with_one_product(:one)
    assert_equal 1, cart.line_items.count
    # Add a new product
    cart.add_product(products(:ruby).id)
    assert_equal 2, cart.line_items.count
  end

  test 'cart should update an existing line item when adding an existing product' do
    cart = new_cart_with_one_product(:one)
    # Re-add the same product
    cart.add_product(products(:one).id)
    assert_equal 1, cart.line_items.count
  end


• Check products and line items for other places where a user-friendly error message would be in order.
检查其他地方的商品和在线商品项目，在这些地方，用户友好的错误消息是按顺序的。
<kinder:note> 也是不好理解。原来验证的时候，这些信息本身就是按表达的顺序的。
Hint: 
答案提示：
what about a price too high or a image_url that is not unique? 
比如价格太高，或图片地址不是唯一的。
You also aren’t limited to the validates method as Rails also has a validate method that can enforce any restriction that you can express via code.
也不必限于验证方法，Rails也有一个通过代码表达的验证方法可强制进行任何约束。
<kinder:note> 在线读者的答案似乎在说，可以通过logger.error的方法记录错误，然后redirect到原有页面。
birnenjoe says:

    I set the image_url of products to be unique:
    
    validates :image_url, uniqueness: true
    
    and wrote tests to verify that behaviour (similar to unique title tests)
    
    ...in depot/test/unit/product_test.rb
    
    def new_product_with_url(image_url)
      Product.new(
        title: "My Book Title",
        description: "yyy",
        price: 1,
        image_url: image_url
      )
    end
    
    test "product is not valid without a unique image_url" do
      product = new_product_with_url(products(:ruby).image_url)
      assert !product.save
      assert_equal "has already been taken", product.errors[:image_url].join('; ')
    end


• Add the ability to delete individual line items from the cart.
  添加从购物车中删除单个商品项目的功能。
This will require buttons on each line, and such buttons will need to be linked to the destroy() action in the LineItemsController.
这就要求每一行上都要添加一个按钮，这些按钮将需要链接到LineItemsController的destroy行为。

Hint: 
答案提示：
the destroy action currently redirects to the line_items_url upon completion.
destroy行动一般重定向到line_items_url来完成。
Is this where you want it to go? 
这就是你要它去的地方吗？
If you change this, be sure to update your unit test. 
如果你改变了这个，确保更新你的单元测试。
Also consider adding a :notice. 
也要考虑增加一个提示。
If you do so, make sure that the target view displays this notice.
如果你这样做，确保目标视图会显示这个提示。

<kinder:note> 论坛读者的答案：
Sergey Says

line_items_controller.rb
  def destroy
    @line_item = LineItem.find(params[:id])
    @cart_id = @line_item.cart_id  # <kinder:note> 这一句是我增加的以便返回购物车。
    @line_item.destroy
    respond_to do |format|
      format.html { redirect_to "/carts/#{@cart_id}", notice: "商品#{@line_item.product.title}已被成功删除." }    # <kinder:note> 这一句是我增加的以便返回购物车。
      format.html { redirect_to current_cart }
      format.json { head :no_content }
    end
  end

Functional Test for Removing Line Item
  test "should destroy line_item" do
    assert_difference('LineItem.count', -1) do
      delete :destroy, id: @line_item
    end
    assert_redirected_to Cart.find(session[:cart_id])
  end

h3. Here is my solution I was kinda hoping to get it to redirect to the cart but I didn’t get it working as I wanted and ended up redirecting back to the catalog and leaving a notice
<kinder:note> 上面这段代码果然出错。
Error:
LineItemsControllerTest#test_should_destroy_line_item:
ActiveRecord::RecordNotFound: Couldn't find Cart without an ID
    test/controllers/line_items_controller_test.rb:52:in `block in <class:LineItemsControllerTest>'

Show.html.erb

    <div class="cart_title">Your Cart</div>
    <table>
      <% for item in @cart.line_items %>
        <tr>
          <td><%= item.quantity %>&times;</td>
          <td><%= item.product.title %></td>
          <td class="item_price"><%= number_to_currency(item.total_price) %></td>
          <td><%= button_to 'Delete Line Item', item, :method => :delete, :confirm => 'Are You Sure' %></td>
          <!-- <kinder:note> 这个item我万万没有想到。我写了@cart, @line_item,甚至写了一个delete_one_kind方法，无奈路由没有通过。 -->
        </tr>
      <% end %>
      <tr class="total_line">
        <td colspan="2">Total</td>
        <td class="total_cell"><%= number_to_currency(@cart.total_price) %></td>
      </tr>
    </table>
    <%= button_to 'Empty cart', @cart, :method => :delete, :confirm => 'Are you sure?' %>


line_items_controller.rb


  def destroy
    @line_item = LineItem.find(params[:id])
    @line_item.destroy

    respond_to do |format|
      format.html { redirect_to(store_url, :notice => 'Line Item Removed' )}
      format.xml  { head :ok }
    end
  end

<kinder:note> 我的诸多尝试，可还是不够完美，比较接近的一个是：
line_item的destroy方法的redirect_to指向增加一个`/cart/#{session[:cart_id]}`
Failure:
LineItemsControllerTest#test_should_destroy_line_item [/home/liqixun/docs/liqixun/desktop/ror_project/depot/test/controllers/line_items_controller_test.rb:52]:
Expected response to be a redirect to <http://test.hostcarts/> but was a redirect to <http://test.host/carts/>.
Expected "http://test.hostcarts/" to be === "http://test.host/carts/".

<kinder:note> 最后还是觉得测试真是该死，比如我增加了闪存信息的内容：

    notice: "商品“#{@line_item.product.title}”已被成功删除."

可是测试就是通不过：
LineItemsControllerTest#test_should_destroy_line_item:
NoMethodError: undefined method `title' for nil:NilClass
    app/controllers/line_items_controller.rb:66:in `block (2 levels) in destroy'
即使在测试文件上增加下面两句也是不行：

    @line_item.product = products(:one)
    @line_item.product.title = products(:one).title

可是我又舍不得扔掉那一句提醒。只好养着这么一个错误吗？
唉，一晚折腾，换来一声长叹！
<kinder:note> 另一个方案，在论坛有个读者增加了一个表单来更改数量。我还增加了一个“增加一个”和“减少一个”的按键。
app/views/carts/show.html.haml:

    -if notice
      %p#notice= notice
    %h2 我的购物车
    %table
      %tr
        %td 商品名称
        %td 单价
        %td &times;
        %td 数量
        %td 合计
        %td{colspan: 3, style: 'border-style: none;'} 更改数量
      -@cart.line_items.each do |item|
        %tr
          %td= item.product.title
          %td= item.product.price
          %td &times;
          %td= item.quantity
          %td.item_price= number_to_currency(item.total_price)
          %td{style: 'border-style: none;'}= button_to( '+',  line_items_path(product_id: item.product))
          %td{style: 'border-style: none;'}
            =form_for item do |f|
              = f.text_field :quantity, size: 1
              = f.submit '✓'
          %td{style: 'border-style: none;'}= button_to '-', item
          %td{style: 'border-style: none;'}= button_to '删除', item, method: :delete, data: { confirm: '您确定要删除该商品吗？'}
      %tr.total_line
        %td{colspan: 4} 总计
        %td= number_to_currency(@cart.total_price)
      %tr
        %td= button_to '清空购物车', @cart, method: :delete, data: { confirm: '您确定要删除吗？'}, form_class: 'qingkonggouwuche'
        %td{colspan: 3}= link_to '继续选购', store_url, id: 'jixuxuangou'
        %td= button_to '现在付款', @cart, method: :delete, data: { confirm: '您确定要删除吗？'}, form_class: 'qingkonggouwuche'

app/controllers/line_items_controller.rb

      def update
        respond_to do |format|
          if @line_item.update(line_item_params)
            if @line_item.quantity == 0
	      @line_item.destroy
            end
            format.html { redirect_to @line_item.cart, notice: "购物车中#{@line_item.product.title}的数量已经更新" }            format.json { render :show, status: :ok, location: @line_item }
            end
          else
            respond_to do |format|
            format.html { render :edit }
            format.json { render json: @line_item.errors, status: :unprocessable_entity }
          end
        end
      end

        # 下面是最后部分，private级别
        def line_item_params
          params.require(:line_item).permit(:product_id, :quantity)
        end

<kinder:note> 下面是我用javascript实现“减少或增加一个或多个”的部分：
用js来实现增加一个或减少一个，修改app/assets/javascripts/carts.js.coffee
$(document).on "ready", ->
  $('.add_one').click ->
    x = parseInt($(this).parent().parent().find('#line_item_quantity').val())
    x += 1
    $(this).parent().parent().find('#line_item_quantity').val(x)
    $(this).parent().parent().find(':submit').click()
  $('.subtract_one').click ->
    x = parseInt($(this).parent().parent().find('#line_item_quantity').val())
    x -= 1
    $(this).parent().parent().find('#line_item_quantity').val(x)
    $(this).parent().parent().find(':submit').click()

修改test/controllers/line_item_controller_test.rb
update和destroy
    @line_item = line_items(:two)
    ...
    assert_redirected_to cart_path(assigns(:line_item).cart)

修改夹具:test/fixtures/line_items.yml
two:
  product: ruby
  cart: one


(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)


# CHAPTER 11 Task F: Add a Dash of Ajax Ajax初体验
## In this chapter, we’ll see
• using partial templates,
  使用局部模板
• rendering into the page layout,
  呈现页面布局
• updating pages dynamically with Ajax and JavaScript,
  利用Ajax和Javascript动态更新页面
• highlighting changes with jQuery UI,
  用jQuery界面高亮变化
• hiding and revealing DOM elements, and
  隐藏和显示DOM元素
• testing the Ajax updates.
  测试Ajax更新

Our customer wants us to add Ajax support to the store.
客户想要我们为商店添加Ajax支持
But just what is Ajax?
但什么是Ajax呢？

In the old days (up until 2005 or so), browsers were treated as really dumb devices.
以前（2005年以前），浏览器被视为很笨拙的设备。
When you wrote a browser-based application, you’d send stuff to the browser and then forget about that session.
当你在写一个基于浏览器的应用程序时，你可能会被东西发给浏览器，然后不再使用那个会话。
At some point, the user would fill in some form fields or click a hyperlink, and your application would get woken up by an incoming request.
某些时刻，当用户填写完某些表格项，或是单击了一个超链接时，应用程序会被收到的请求唤醒。
It would render a complete page back to the user, and the whole tedious process would start afresh.
浏览器会呈现整个页面给用户，然后这整个过程又重新开始。
That’s exactly how our Depot application behaves so far.
这恰是我们的Depot程序目前为止所做的。

But it turns out that browsers aren’t really that dumb (who knew?).
但结果是浏览器还没有那么蠢（谁知道呢？）
They can run code.
它还可以运行代码。
Almost all browsers can run JavaScript.
几乎所有的浏览器都可以运行JavaScript。
And it turns out that the JavaScript in the browser can interact behind the scenes with the application on the server, updating the stuff the user sees as a result.
结果是，浏览器中的Javascript能在幕后与服务器上的应用程序交互，更新用户的所见。
Jesse James Garrett named this style of interaction Ajax (which once stood for Asynchronous JavaScript and XML but now just means “making browsers suck less”).
Jesse James Garrett把这种交互方式称为Ajax（即异步javascript和xml，或直白地就是“让浏览器没那么蠢”）。

So, let’s Ajaxify our shopping cart.
那么，就为购物车添加Ajax吧。
Rather than having a separate shopping cart page, let’s put the current cart display into the catalog’s sidebar.
让我们把当前整个购物车的显示放到商品目录的侧边栏中，而不是一个独立的页面。
Then, we’ll add the Ajax magic that updates the cart in the sidebar without redisplaying the whole page.
然后，我们利用Ajax来更新这个侧边栏，而不用重新显示整个页面。

Whenever you work with Ajax, it’s good to start with the non-Ajax version of the application and then gradually introduce Ajax features.
无论你何时使用Ajax，以下做法都是值得提倡的，即从一个非Ajax的应用程序版本开始，循序渐进地添加Ajax特性。
That’s what we’ll do here.
这正是我们打算做的。
For starters, let’s move the cart from its own page and put it in the sidebar.
第一步，让我们把购物车从独立的页面移到侧边栏中。

• 136

## 11.1 Iteration F1: Moving the Cart 转移购物车
Currently, our cart is rendered by the show action in the CartController and the corresponding .html.erb template.
当前，我们通过CartController中的show动作和相应的.html.erb模板来呈现购物车。
What we’d like to do is to move that rendering into the sidebar.
我们想要做的是把这个呈现移动到侧边栏中去。
This means it will no longer be in its own page.
这意味着不是在一个独立的页面里，
Instead, we’ll render it in the layout that displays the overall catalog.
而要把购物车呈现在一个显示所有商品目录的布局中。
And that’s easy using partial templates.
利用局部模板，这很容易。

### 11.1.1 Partial Templates 局部模板
Programming languages let you define methods.
程序语言让你可以定义方法的。
A method is a chunk of code with a name: invoke the method by the name, and the corresponding chunk of code gets run.
方法是一段命名的代码：用该名字调用这个方法会让这段代码得以运行。
And, of course, you can pass parameters to a method, which lets you write one piece of code that can be used in many different circumstances.
当然，你可以给方法传递参数，让方法在不同场合使用。

You can think of Rails partial templates (partials for short) as a kind of method for views.
可以把Rails的局部模板当作一种视图的方法。
A partial is simply a chunk of a view in its own separate file.
简单来说，局部模板就是一个在单独文件中的视图。
You can invoke (render) a partial from another template or from a controller, and the partial will render itself and return the results of that rendering.
你可以利用模板或控制器来调用（或呈现）局部模板，它会显示自己并返回显示的结果。
And, just as with methods, you can pass parameters to a partial, so the same partial can render different results.
正如方法一样，可以传递参数给模板，这样使用相同的局部模板可以呈现出不同的结果。

We’ll use partials twice in this iteration.
这个迭代我们会两次用到局部模板。
First, let’s look at the cart display:
首先，让我们看看购物车的显示：

     Download rails40/depot_i/app/views/carts/show.html.erb
     <% if notice %>
       <p id="notice"><%= notice %></p>
     <% end %>
     <h2>Your Cart</h2>
     <table>
     <% @cart.line_items.each do |item| %>
       <tr>
         <td><%= item.quantity %>&times;</td>
         <td><%= item.product.title %></td>
         <td class="item_price"><%= number_to_currency(item.total_price) %></td>
       </tr>
     <% end %>
       <tr class="total_line">
         <td colspan="2">Total</td>
         <td class="total_cell"><%= number_to_currency(@cart.total_price) %></td>
       </tr>
     </table>
     <%= button_to 'Empty cart', @cart, method: :delete,
         data: { confirm: 'Are you sure?' } %>

• 137

It creates a list of table rows, one for each item in the cart.
这段代码生成了一列表格行，每行对应着购物车的一个项目。
Whenever you find yourself iterating like this, you might want to stop and ask yourself, is this too much logic in a template? 
每当你看到像这样的循环时，都应该停下来问自己，在模板中这样做是否太逻辑化了？
It turns out we can abstract away the loop using partials (and, as we’ll see, this also sets the stage for some Ajax magic later).
答案是我们可以使用局部模板来抽象化这些循环（我们也会看到，这样做还为接下来施展Ajax魔法做好了铺垫）。
To do this, we’ll make use of the fact that you can pass a collection to the method that renders partial templates, and that method will automatically invoke the partial once for each item in the collection.
要这样做，我们得利用到一点：**可以向显示局部模板的方法传递一个集合，这个方法会自动为集合中的每一项调用一次局部模板。**
Let’s rewrite our cart view to use this feature.
利用这个特性我们重写购物车的显示：

     Download rails40/depot_j/app/views/carts/show.html.erb
       <% if notice %>
         <p id="notice"><%= notice %></p>
       <% end %>
       <h2>Your Cart</h2>
       <table>
     ➤   <%= render(@cart.line_items) %>
         <tr class="total_line">
           <td colspan="2">Total</td>
           <td class="total_cell"><%= number_to_currency(@cart.total_price) %></td>
         </tr>
       </table>
       <%= button_to 'Empty cart', @cart, method: :delete,
           data: { confirm: 'Are you sure?' } %>

That’s a lot simpler.
这样一来简单多了。
The render() method will iterate over any collection that is passed to it.
render()方法会循环遍历任何一个传递给它的集合。
The partial template itself is simply another template file (by default in the same directory as the object being rendered and with the name of the table as the name).
局部模板本身不过是另一个模板文件（该文件在默认情况下与当前呈现的对象在同一文件夹下，且与表格的名字相同）。
However, to keep the names of partials distinct from regular templates, Rails automatically prepends an underscore to the partial name when looking for the file.
但是，为了与普通的模板区分开来，Rails会自动在局部模板的名字前面加一个下划线。
That means we need to name our partial _line_item.html.erb and place it in the app/views/line_items directory.
就是把模板命名为`_line_item.html.erb`，且放在app/views/line_items文件夹下：

     Download rails40/depot_j/app/views/line_items/_line_item.html.erb
     <tr>
       <td><%= line_item.quantity %>&times;</td>
       <td><%= line_item.product.title %></td>
       <td class="item_price"><%= number_to_currency(line_item.total_price) %></td>
     </tr>

There’s something subtle going on here.
这里需要注意一些地方。
Inside the partial template, we refer to the current object using the variable name that matches the name of the template.
在局部模板中，**当前对象的变量名称需与模板的名称相一致**。
In this case, the partial is named line_item, so inside the partial we expect to have a variable called line_item.
在这里，局部模板的名称是`line_item`，所以在其中也得有个变量称为`line_item`。

• 138

So, now we’ve tidied up the cart display, but that hasn’t moved it into the sidebar.
现在就整理好了购物车的显示，但还没有移动到侧边栏中去。
To do that, let’s revisit our layout.
要做到，我们要重新审视一下布局。
If we had a partial template that could display the cart, we could simply embed a call like this within the sidebar:
如果有一个局部模板能显示购物车，我们可以简单地在侧边栏嵌入如下调用：

    render("cart")

But how would the partial know where to find the cart object? 
**但局部模板怎么知道去哪里找购物车对象呢？**
One way would be for it to make an assumption.
一种方法是做一个假设。
In the layout, we have access to the @cart instance variable that was set by the controller.
在布局中，我们可以访问控制器设置好的@cart实例变量。
It turns out that this is also available inside partials called from the layout.
这样做的结果是，对于被布局调用的局部模板，该实例变量也是可用的。
However, this is a bit like calling a method and passing it some value in a global variable.
但是，这样做相当于调用一个方法炳传给它某个全局变量。
It works, but it’s ugly coding, and it increases coupling (which in turn makes your programs brittle and hard to maintain).
这样做虽然行得通，但却代码丑陋，且增加了耦合（让程序不健壮且难以维护）。

Now that we have a partial for a line item, let’s do the same for the cart.
现在对于一个在线商品有了一个局部模板，让我们对购物车做相同的事情。
First we’ll create the `_cart.html.erb` template.
首先，建立`_cart.html.erb`模板。
This is basically our carts/show.html.erb template but using cart instead of @cart, and without the notice.
这基本上就是carts/show.html.erb模板，只不过使用cart而不是@cart。
(Note that it’s OK for a partial to invoke other partials.).
请注意，一个局部模板可以调用其他的局部模板。

       Download rails40/depot_j/app/views/carts/_cart.html.erb
       <h2>Your Cart</h2>
       <table>
     ➤   <%= render(cart.line_items) %>
         <tr class="total_line">
           <td colspan="2">Total</td>
     ➤     <td class="total_cell"><%= number_to_currency(cart.total_price) %></td>
         </tr>
       </table>
     ➤ <%= button_to 'Empty cart', cart, method: :delete,
           data: { confirm: 'Are you sure?' } %>

As the Rails mantra goes, don’t repeat yourself (DRY).
Rails的宗旨是不要重复你自己。
But we have just done that.
但我们刚刚违反了这一条规则。
At the moment the two files are in sync, so there may not seem to be much of a problem, but having one set of logic for the Ajax calls and another set of logic to handle the case where JavaScript is disabled invites problems.
当前两个文件是同步的，所以不会有什么问题，但同时有一套逻辑控制Ajax调用，和另一套逻辑对付JavaScript被禁用的情况，会引入一些问题。
Let’s avoid all of that and replace the original template with code that causes the partial to be rendered.
为了避免这些问题，可以把原模板替换成如下呈现局部模板的代码。

     Download rails40/depot_k/app/views/carts/show.html.erb
     <% if notice %>
       <p id="notice"><%= notice %></p>
     <% end %>
     ➤ <%= render @cart %>

• 139

Now we will change the application layout to include this new partial in the sidebar.
现在改变一下应用程序的布局，把这个新的局部模板加入侧边栏中。

     Download rails40/depot_k/app/views/layouts/application.html.erb
     <!DOCTYPE html>
     <html>
     <head>
       <title>Pragprog Books Online Store</title>
       <%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true %>
       <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
       <%= csrf_meta_tags %>
     </head>
     <body class="<%= controller.controller_name %>">
       <div id="banner">
         <%= image_tag("logo.png") %>
         <%= @page_title || "Pragmatic Bookshelf" %>
       </div>
       <div id="columns">
         <div id="side">
     ➤     <div id="cart">
     ➤       <%= render @cart %>
     ➤     </div>
     ➤     <ul>
             <li><a href="http://www....">Home</a></li>
             <li><a href="http://www..../faq">Questions</a></li>
             <li><a href="http://www..../news">News</a></li>
             <li><a href="http://www..../contact">Contact</a></li>
           </ul>
         </div>
         <div id="main">
           <%= yield %>
         </div>
       </div>
     </body>
     </html>

Next we have to make a small change to the store controller.
下面我们稍微修改一下商店的控制器。
We’re invoking the layout while looking at the store’s index action, and that action doesn’t currently set @cart.
我们在调用布局的同时，查看商店的index动作，而这个动作并没有设置@cart。
That’s easy enough to remedy.
这点非常容易修改。

       Download rails40/depot_k/app/controllers/store_controller.rb
       class StoreController < ApplicationController
     ➤   include CurrentCart
     ➤   before_action :set_cart
         def index
           @products = Product.order(:title)
         end
       end

• 140

Finally, we modify the style instructions—which currently apply only to the output produced by the CartController—to also apply to the table when it appears in the sidebar.
<kinder:note> 最后，修改样式构造--当前样式只适用于CartController生成的输出--修改为当它出现在侧边栏时应用表格。
Again, SCSS enables us to make this change in one place because it will take care of all of the nested definitions.
<kinder:note> SCSS让我们在一个地方作出修改，因为它将处理好所有嵌入的定义。

       Download rails40/depot_k/app/assets/stylesheets/carts.css.scss
       // Place all the styles related to the Carts controller here.
       // They will automatically be included in application.css.
       // You can use Sass (SCSS) here: http://sass-lang.com/
     ➤ .carts, #side #cart {
         .item_price, .total_line {
           text-align: right;
         }
     
         .total_line .total_cell {
           font-weight: bold;
           border-top: 1px solid #595;
         }
       }

While the data for the cart is common no matter where it is placed in the output, there is no requirement that the presentation needs to be identical independent of where this content is placed.
<kinder:note> 因为购物的数据对被放置于输出中的何处不重要，因此没有要求该表示的内容需要被置于一样独立的（地方）。

In fact, black lettering on a green background is rather hard to read, so let’s provide additional rules for this table when it appears in the sidebar.
事实上，黑色字体配绿色背景相当难读，我们应该为这个表格提供额外的规则，以让它出现在侧边栏中。

     Download rails40/depot_k/app/assets/stylesheets/application.css.scss
       #side {
         float: left;
         padding: 1em 2em;
         width: 13em;
         background: #141;
     ➤   form, div {
     ➤     display: inline;
     ➤   }
     ➤
     ➤   input {
     ➤     font-size: small;
     ➤   }
     ➤
     ➤   #cart {
     ➤     font-size: smaller;
     ➤     color: white;
     ➤     table {
     ➤       border-top:
     ➤       1px dotted #595;
     ➤       border-bottom: 1px dotted #595;
     ➤       margin-bottom: 10px;
     ➤     }
     ➤   }
         ul {
           padding: 0;
           li {
             list-style: none;
             a {
               color: #bfb;
               font-size: small;
             }
           }
         }
       }

• 141

If you display the catalog after adding something to your cart, you should see something like the following figure.
如果你向购物车添加了一些东西后显示目录，应该看到下图所示页面。
Let’s just wait for the Webby Award nomination.
让我们等待威比奖的提名吧。

Figure 29—The cart is in the sidebar.

### 11.1.2 Changing the Flow  改变流程
Now that we’re displaying the cart in the sidebar, we can change the way that the Add to Cart button works.
现在购物车已经显示在侧边栏中了，我们接着改变Add to Cart按键的工作方式。
Rather than displaying a separate cart page, all it has to do is refresh the main index page.
按下该键只需要刷新主索引页面，而不是显示一个单独的购物车页面。

The change is pretty simple.
这个改变很简单。
At the end of the create action, we simply redirect the browser back to the index.
在create动作的最后把浏览器重定向到索引。

• 142

       Download rails40/depot_k/app/controllers/line_items_controller.rb
       def create
         product = Product.find(params[:product_id])
         @line_item = @cart.add_product(product.id)
         respond_to do |format|
           if @line_item.save
     ➤       format.html { redirect_to store_url }
             format.json { render action: 'show',
                           status: :created, location: @line_item }
           else
             format.html { render action: 'new' }
             format.json { render json: @line_item.errors,
                           status: :unprocessable_entity }
           end
         end
       end


So, now we have a store with a cart in the sidebar.
现在我们商店的侧边栏中显示了购物车。
When we click to add an item to the cart, the page is redisplayed with an updated cart.
当我们单击向购物车中增加项目的时候，页面会显示为更新后的购物车。
However, if our catalog is large, that redisplay might take a while.
但是，**如果我们的商品目录很大的话，整个刷新可能要等待一段时间**。
It uses bandwidth, and it uses server resources.
这个过程会消耗带宽和服务器的资源。
Fortunately, we can use Ajax to make this better.
幸运的是，我们可以用Ajax来改进它。

## 11.2 Iteration F2: Creating an Ajax-Based Cart  建立一个基于Ajax的购物车
Ajax lets us write code that runs in the browser that interacts with our serverbased application.
Ajax可以让我们写出运行在浏览器上的代码，并可以与基于服务器的应用程序互动。
In our case, we’d like to make the Add to Cart buttons invoke the server create action on the LineItems controller in the background.
在这里，我们想让“添加到购物车”按键在后台调用服务器端的LineItems控制器的create动作。
The server can then send down just the HTML for the cart, and we can replace the cart in the sidebar with the server’s updates.
服务器只需传输购物车的HTML，我们可以随着服务器的更新，替换侧边栏中的购物车。

Now, normally we’d do this by writing JavaScript that runs in the browser and by writing server-side code that communicated with this JavaScript (possibly using a technology such as JavaScript Object Notation [JSON]).
通常为了实现这个功能，我们可以写一段浏览器中运行的JavaScript代码，并在服务器端写另外一些代码与JavaScript通信（或许使用像JSON那样的技术）。

The good news is that, with Rails, all this is hidden from us.
好消息是，在Rails中，所有的这些都隐藏了。
We can do everything we need to do using Ruby (and with a whole lot of support from some Rails helper methods).
利用Ruby我们可以做想做的任何事情（并且还可以得到许多Rails帮助方法的支持）。

The trick when adding Ajax to an application is to take small steps.
向应用程序中添加Ajax的技巧是**逐步进行**。
So, let’s start with the most basic one.
首先从一些最基础的步骤开始。
Let’s change the catalog page to send an Ajax request to our server application and have the application respond with the HTML fragment containing the updated cart.
让我们更改一下目录的页面，以向服务器的应用程序发出一个Ajax请求，并让程序回复一段更新过的购物车的HTML代码片段。

On the index page, we’re using button_to() to create the link to the create action.
在索引页，我们正使用button_to()来建立create动作的链接。
We want to change this to send an Ajax request instead.
我们想把这个改为发送Ajax请求。
To do this, we simply add a `remote: true` parameter to the call.
这样我们只需为调用增加一个`:remote: true`参数。

• 143

     Download rails40/depot_l/app/views/store/index.html.erb
     <% if notice %>
     <p id="notice"><%= notice %></p>
     <% end %>
     <h1>Your Pragmatic Catalog</h1>
     <% cache ['store', Product.latest] do %>
       <% @products.each do |product| %>
         <% cache ['entry', product] do %>
           <div class="entry">
             <%= image_tag(product.image_url) %>
             <h3><%= product.title %></h3>
             <%= sanitize(product.description) %>
             <div class="price_line">
               <span class="price"><%= number_to_currency(product.price) %></span>
     ➤         <%= button_to 'Add to Cart', line_items_path(product_id: product),
     ➤             remote: true %>
             </div>
           </div>
         <% end %>
       <% end %>
     <% end %>

So far, we’ve arranged for the browser to send an Ajax request to our application.
到目前为止，我们已经让浏览器可以向应用程序发送Ajax请求。
The next step is to have the application return a response.
下一步是让应用程序回复该请求。
The plan is to create the updated HTML fragment that represents the cart and to have the browser stick that HTML into the browser’s internal representation of the structure and content of the document being displayed, namely, the Document Object Model (DOM).
我们的计划是创建一个更新过的HTML片段用以表示购物车，并且让浏览器将HTML插入到其显示文档结构和内容的内部表示中去，即文档对象模型（DOM）。
By manipulating the DOM, we cause the display to change in front of the user’s eyes.0
通过操作DOM，我们可以改变浏览器的显示。

The first change is to stop the create action from redirecting to the index display if the request is for JavaScript.
第一个要更改的是，如果请求的是JavaScript，让create动作不要重定向到索引的显示上。
We do this by adding a call to respond_to() telling it that we want to respond with a format of .js.
这点可以通过一下方式实现：向respond_to增加一个调用，来告诉它我们希望得到一个.js格式的回复。

This syntax may seem surprising at first, but it is simply a method call that is passing an optional block as an argument.
整额语法也许初看之下有点儿让人惊讶，但只不过是一个传递可选块参数的方法调用。
Blocks are described in Blocks and Iterators, on page 44.
块的介绍在前面44页。
We will cover the respond_to() method in greater detail in Selecting a Data Representation, on page 318.
我们还会在后面318页详细介绍respond_to方法。

     Download rails40/depot_l/app/controllers/line_items_controller.rb
     def create
       product = Product.find(params[:product_id])
       @line_item = @cart.add_product(product.id)
       respond_to do |format|
         if @line_item.save
           format.html { redirect_to store_url }
     ➤     format.js
           format.json { render action: 'show',
                         status: :created, location: @line_item }
         else
           format.html { render action: 'new' }
           format.json { render json: @line_item.errors,
                         status: :unprocessable_entity }
         end
       end
     end

• 144

Because of this change, when create finishes handling the Ajax request, Rails will look for a create template to render.
因为这个改变，当create完成了Ajax请求的处理，Rails会寻找一个create模板来显示。
Rails supports templates that generate JavaScript—the JS stands for JavaScript.
Rails支持生成JavaScript的模板--JS代表JavaScript。
A .js.erb template is a way of getting JavaScript on the browser to do what you want, all by writing server-side Ruby code.
一个.js.erb模板是一个方式，让JavaScript在浏览器上做你想要的事，这全部是由服务器端的Ruby代码实现的。
Let’s write our first: create.js.erb.
接下来编写我们的第一个：create.js.erb。
It goes in the app/views/line_items directory, just like any other view for line items.
它放在app/views/line_items文件夹下，就像其他的在线商品的视图一样：

    Download rails40/depot_l/app/views/line_items/create.js.erb
    $('#cart').html("<%= escape_javascript render(@cart) %>");

This simple template tells the browser to replace the content of the element whose id="cart" with that HTML.
<kinder:note> 这个简单的模板告诉浏览器将将id为cart的内容替换为该HTML。

Let’s analyze how it manages to do that.
让我们来分析一下这个模板。
For simplicity and conciseness, the jQuery library is aliased to $, and most usages of jQuery start there.
<kinder:note> 为简洁，jQuery库被别名为$，大部分的jQuery用这个开始。
The first call—$('#cart')—tells jQuery to find the HTML element that has an id of cart.
<kinder:note> 第一个调用--$('cart')--告诉jQuery找到id为cart的HTML元素。
The html() method1 is then called with a first argument of the desired replacement for the contents of this element.
<kinder:note> html()方法被调用，所带第一个参数将体会这个HTML元素的内容。
This content is formed by calling the render() method on the @cart object.
<kinder:note> 这个内容被@cart对象上的render()方法调用所形成。
The output of this method is processed by a escape_javascript() helper method that converts this Ruby string into a format acceptable as input to JavaScript.
<kinder:note> 这个方法的输出被一个辅助方法escape_javascript方法所处理，它将Ruby字符串转换为一种JavaScript的输入所接受的格式。

1.  http://api.jquery.com/html/

Note that this script is executed in the browser.
注意这个脚本是在浏览器里执行的。
The only parts executed on the server are the portions within the <%= and %> delimiters.
唯一在服务器上执行的部分是在<%=和%>分隔符之间的部分。

Does it work? 
这样行得通吗？
Well, it’s hard to show in a book, but it sure does.
虽然很难在书中显示，但答案是行得通。
Make sure you reload the index page to get the remote version of the form and the JavaScript libraries loaded into your browser.
确保你重新加载了索引页面，以便将远程版本的表单和JavaScript库载入浏览器中。
Then, click one of the Add to Cart buttons.
然后，单击“添加到购物车”按钮。
You should see the cart in the sidebar update.
你应该可以在侧边栏中看见更新的购物车。
And you shouldn’t see your browser show any indication of reloading the page.
同时不应该看到浏览器有任何重载页面的征兆。
You’ve just created an Ajax application.
你已经创建了一个Ajax应用程序。

• 145

Troubleshooting
排疑解难
Although Rails makes Ajax incredibly simple, it can’t make it foolproof.
尽管Rails让Ajax变得十分简单，但却无法确保万无一失。
And, because you’re dealing with the loose integration of a number of technologies, it can be hard to work out why your Ajax doesn’t work.
另外，因为在这里你面对的是一些松散整合在一起的技术；若是Ajax不能正确地工作，调试可能会比较困难。
That’s one of the reasons you should always add Ajax functionality one step at a time.
这也是应该总是一步一步来添加Ajax功能的原因之一。

Here are a few hints if your Depot application didn’t show any Ajax magic:
如果Ajax的魔法无法在你的Depot应用程序中起作用，以下是线索：

• Does your browser have any special incantation to force it to reload everything on a page? 
浏览器是否有任何特别的功能强制刷新页面？
Sometimes browsers hold local cached versions of page assets, and this can mess up testing.
有时浏览器会在本地缓存页面，这会把测试弄得混乱。
Now would be a good time to do a full reload.
那样的话就应该全部重载页面了。

• Did you have any errors reported? 
  是否有错误报告？
Look in development.log in the logs directory.
查看一下logs目录下的development.log。
Also look in the Rails server window because some errors are reported there.
也要查看一下Rails服务器的窗口，因为有些错误会显示在那里。

• Still looking at the log file, do you see incoming requests to the action create? 
继续查看日志文件，你能看见进入动作create的请求吗？
If not, it means your browser isn’t making Ajax requests.
如果不能，意味着你的浏览器没有发出Ajax请求。
If the JavaScript libraries have been loaded (using View Source in your browser will show you the HTML), perhaps your browser has JavaScript execution disabled?
如果JavaScript库已经加载了（利用浏览器上的”显示源代码“，可以查看HTML），那么或许就是你的浏览器把执行JavaScript给禁用了。

• Some readers have reported that they had to stop and start their application to get the Ajax-based cart to work.
有些读者报告，他们得关掉并重启应用程序才能让基于Ajax的购物车运行。

• If you’re using Internet Explorer, it might be running in what Microsoft calls quirks mode, which is backward compatible with old Internet Explorer releases but is also broken.
如果你用的是IE浏览器，原因可能是浏览器运行在微软所谓的怪异模式下，也就是为了向后兼容旧的IE版本的坏模式。
Internet Explorer switches into standards mode, which works better with the Ajax stuff, if the first line of the downloaded page is an appropriate DOCTYPE header.
如果下载下来的页面的第一行是一个正确的DOCTYPE头，那么IE就会转到标准模式下，Ajax可以得到更好的支持。
Our layouts use this:
在布局里使用这个：

    <!DOCTYPE html>

 • 146

### 11.2.2 The Customer Is Never Satisfied 客户永远不会满足
We’re feeling pretty pleased with ourselves.
我们对自己感到非常满意。
We changed a handful of lines of code, and our boring old Web 1.0 application now sports Web 2.0 Ajax speed stripes.
我们更改了许多行代码，让原本乏味的Web 1.0应用程序升级到了Web 2.0 Ajax。
We breathlessly call the client over to come look.
我们把客户叫了过来，屏息以待。
Without saying anything, we proudly click Add to Cart and look at her, eager for the praise we know will come.
事先并没有告诉她任何事情，当我们骄傲地按下“添加到购物车”，期待对方褒奖。
Instead, she looks surprised.
她却看起来非常惊讶。
“You called me over to show me a bug?” she asks, “You click that button, and nothing happens.” 
“你叫我过来就是向我展示一个bug？”她问道， “点了那个按钮，却什么也没发生。”
We patiently explain that, in fact, quite a lot happened.
我们不得不耐心解释，其实发生了许多事情。
Just look at the cart in the sidebar.
看看侧边栏吧。
See?
看到了吗？
When we add something, the quantity changes from 4 to 5.
我们加入一件东西的时候，数量从4变成了5。

“Oh,” she says, “I didn’t notice that.” 
“哦”，她说：“我没注意到这一点。”
And, if she didn’t notice the page update, it’s likely our customers won’t either.
如果她没有注意到页面更新，那么很可能我们的顾客也不会注意到。
It’s time for some user-interface hacking.
是时候修改一下用户交互了。

## 11.3 Iteration F3: Highlighting Changes 高亮变化
A number of JavaScript libraries are included with Rails.
Rails中包含了一些JavaScript库。
One of those libraries, jQuery UI,2 lets you decorate your web pages with a number of visually interesting effects.
其中，jQuery UI, 让你可以用一些视觉上有趣的效果来装点页面。
One of these effects is the (now) infamous Yellow Fade Technique.
其中一个就是声名狼藉的黄色褪色技术。
This highlights an element in a browser: by default it flashes the background yellow and then gradually fades it back to white.
该技术可以高亮显示浏览器中的某个元素，默认情况下它让背景变成黄色，然后逐步褪成白色。
We can see the Yellow Fade Technique being applied to our cart in the following figure; the image at the back shows the original cart.
将该计数应用到我们的购物车上，可以看到首页变成下面图片所示的样子，在最后面的图片展示的是原始的购物车。
The user clicks the Add to Cart button, and the count updates to two as the line flares brighter.
用户单击“添加到购物车”按钮，商品数量更新到2，与此同时该行闪烁变亮。
It then fades back to the background color over a short period of time.
然后经过一段时间逐渐褪还成背景颜色。

2.  http://jqueryui.com/

Figure 30—Our cart with the Yellow Fade Technique

• 147

Installing the jQuery UI library is simple enough.
<kinder:note> 安装jQuery UI库是很简单的。
First add one line to your Gemfile.
<kinder:note> 首先增加一行到Gemfile中。

       Download rails40/depot_m/Gemfile
       # Use jquery as the JavaScript library
         gem 'jquery-rails'
     ➤   gem 'jquery-ui-rails'

Install the gem by running the bundle install command.
<kinder:note> 运行`bundle install`命令安装这个gem。

     $ bundle install

After this command completes, restart your server.
<kinder:note> 命令完成之后，重启服务器。

Now that we have the jQuery-UI libraryjQuery-UI library available to our application, we need to pull in the effect that we want to use.
<kinder:note>现在我们的应用程序有了jQuery-UI库可用，我们需要将想要使用的效果推进去。
We do that by adding one line to app/assets/javascripts/application.js.
添加一行到app/assets/javascripts/application.js中：

     Download rails40/depot_m/app/assets/javascripts/application.js
     // This is a manifest file that'll be compiled into application.js, which will
     // include all the files listed below.
     //
     // Any JavaScript/Coffee file within this directory, lib/assets/javascripts,
     // vendor/assets/javascripts, or vendor/assets/javascripts of plugins, if any,
     // can be referenced here using a relative path.
     //
     // It's not advisable to add code directly here, but if you do, it'll appear at
     // the bottom of the compiled file.
     //
     // Read Sprockets README
     // (https://github.com/sstephenson/sprockets#sprockets-directives) for details
     // about supported directives.
     //
     //= require jquery
     ➤ //= require jquery.ui.effect-blind
     //= require jquery_ujs
     //= require turbolinks
     //= require_tree .

We saw assets/stylesheets/application.css in Iteration A2 on page 97.
<kinder:note> 我们在前面97页的迭代A2见过了assets/stylesheets/application.css。
This file behaves similarly but for JavaScripts instead of stylesheets.
<kinder:note> 这个文件的表现有些类似，但是JavaScripts，而不是stylesheets。
Be careful to use a dash instead of an underscore in this line, as clearly not all authors of libraries follow the same naming conventions.
<kinder:note> 小心在这一行中使用的是`-`，不是`_`，很明显，不是所有的库的作者都使用相同的命名习惯。

Let’s use this library to add this kind of highlight to our cart.
让我们使用这个库来增加这种高亮到购物车中吧。
Whenever an item in the cart is updated (either when it is added or when we change the quantity), let’s flash its background.
无论何时购物车中的项目更新了（当项目增加了，或者我们改变了数量），让我们把背景变化一下。
That will make it clearer to our users that something has changed, even though the whole page hasn’t been refreshed.
这个效果可以提醒我们的用户有效东西改变了，尽管整个页面并没有更新。

• 148

The first problem we have is identifying the most recently updated item in the cart.
第一个问题是如何在购物车中找到最近更新的项目。
Right now, each item is simply a <tr> element.
当前，每个项目不过是一个<tr>元素。
We need to find a way to flag the most recently changed one.
我们得找到一种办法来标记最近改变过的项目。
The work starts in the LineItemsController.
我们从LineItemsController开始着手。
Let’s pass the current line item down to the template by assigning it to an instance variable.
将当前的商品项目以赋值给一个实例变量的形式传给模板。

     Download rails40/depot_m/app/controllers/line_items_controller.rb
     def create
       product = Product.find(params[:product_id])
       @line_item = @cart.add_product(product.id)
       respond_to do |format|
         if @line_item.save
           format.html { redirect_to store_url }
     ➤     format.js { @current_item = @line_item }
           format.json { render action: 'show',
                         status: :created, location: @line_item }
         else
           format.html { render action: 'new' }
           format.json { render json: @line_item.errors,
                         status: :unprocessable_entity }
         end
       end
     end

In the `_line_item.html.erb` partial, we then check to see whether the item we’re rendering is the one that just changed.
在`_line_item.html.erb`局部模板里，我们检查当前正在呈现的项目是否刚刚更改过。
If so, we tag it with an ID of current_item.
如果是，用一个current_item的id来标记它。

       Download rails40/depot_m/app/views/line_items/_line_item.html.erb
     ➤  <% if line_item == @current_item %>
     ➤    <tr id="current_item">
     ➤  <% else %>
     ➤    <tr>
     ➤  <% end %>
           <td><%= line_item.quantity %>&times;</td>
           <td><%= line_item.product.title %></td>
           <td class="item_price"><%= number_to_currency(line_item.total_price) %></td>
       </tr>

As a result of these two minor changes, the <tr> element of the most recently changed item in the cart will be tagged with id="current_item".
经过这两个小的更改之后，购物车中最近更改过的项目的<tr>元素会被标记为`id="current_item"`。
Now we just need to tell the JavaScript to change the background color to one that will catch the eye and then to gradually change it back.
现在只需要告诉JavaScript在该项目上调用高亮效果。
We do this in the existing create.js.erb template.
在现有的create.js.erb模板中就可以做到。

     Download rails40/depot_m/app/views/line_items/create.js.erb
     $('#cart').html("<%= escape_javascript render(@cart) %>");
     ➤
     ➤ $('#current_item').css({'background-color':'#88ff88'}).
     ➤  animate({'background-color':'#114411'}, 1000);

• 149

See how we identified the browser element that we wanted to apply the effect to by passing '#current_item' to the $ function?
<kinder:note> 看到了如何找到那个浏览器元素了吗？我们想通过传递`:current_item`给$函数来施加该效果。
We then called css() to set the initial background color and followed up with a call to the animate() method to transition back to the original color used by our layout over a period of 1000 milliseconds, more commonly known as one second.
<kinder:note> 然后调用css()设置初始背景颜色，接着调用animate()方法经过1000毫秒（即1秒）的时间转回布局原来的颜色。

With that change in place, click any Add to Cart button, and you’ll see that the changed item in the cart glows a light green before fading back to merge with the background.
经过这个改变，单击“添加到购物车”按钮，你会看到改变的项目变成了淡绿色，然后渐渐褪为背景色。

## 11.4 Iteration F4: Hiding an Empty Cart 隐藏一个空的购物车
There’s one last request from the customer.
顾客还有最后一个要求。
Right now, even carts with nothing in them are still displayed in the sidebar.
现在，即使成空的购物车仍然会显示在侧边栏中。
Can we arrange for the cart to appear only when it has some content?
是否可以仅当购物车中有内容时序列显示它？
But of course!
当然可以。

In fact, we have a number of options.
事实上，有好几个选择。
The simplest is probably to include the HTML for the cart only if the cart has something in it.
最简单的可能就是仅当购物车中有东西的时候菜包含购物车的HTML。
We could do this totally within the `_cart` partial.
我们完全可以在`_cart`局部模板中实现。

     ➤ <% unless cart.line_items.empty? %>
         <div class="cart_title">Your Cart</div>
       <table>
         <%= render(cart.line_items) %>
         <tr class="total_line">
           <td colspan="2">Total</td>
           <td class="total_cell"><%= number_to_currency(cart.total_price) %></td>
         </tr>
       </table>
       <%= button_to 'Empty cart', cart, method: :delete,
           confirm: 'Are you sure?' %>
     ➤ <% end %>

Although this works, the user interface is somewhat brutal: the whole sidebar redraws on the transition between a cart that’s empty and a cart with something in it.
尽管这样行得通，但对于用户接口来说却有点野蛮：在购物车中商品从无到有的转变过程中，整个侧边栏都会重新显示。
So, let’s not use this code.
因此最好不要使用这个代码。
Instead, let’s smooth it out a little.
让我们来把这个过程过渡一下。
The jQuery UI library also provides transitions that make elements appear.
jQuery UI库也提供了过渡显示元素的效果。
Let’s use the blind option on show(), which will smoothly reveal the cart, sliding the rest of the sidebar down to make room.
我们使用show()的blind选项，可以平滑地显示购物车，将侧边栏的剩余部分往下移动以腾出空间。

Not surprisingly, we’ll again use our existing .js.erb template to call the effect.
毫不奇怪，我们将再次使用已有的.js.erb模板来调用这个效果。
Because the create template is invoked only when we add something to the cart, we know that we have to reveal the cart in the sidebar whenever there is exactly one item in the cart (because that means previously the cart was empty and hence hidden).
因为当且仅当我们向购物车中添加了东西的时候，create模板才会被调用，并且我们知道，无论何时购物车中有且只有一个项目的时候，我们就要在侧边栏中显示这个购物车（因为这意味着之前购物车是空的，因而被隐藏了）。
And, because the cart should be visible before we start the highlight effect, we’ll add the code to reveal the cart before the code that triggers the highlight.
并且，由于购物车必须在我们启动高亮效果之前才是可见的，所以得把显示购物车的代码添加在触发高亮之前。
 • 150
The template now looks like this:
模板现在看起来就是这样：

     Download rails40/depot_n/app/views/line_items/create.js.erb
     ➤ if ($('#cart tr').length == 1) { $('#cart').show('blind', 1000); }
     ➤ 
       $('#cart').html("<%= escape_javascript render(@cart) %>");

       $('#current_item').css({'background-color':'#88ff88'}).
         animate({'background-color':'#114411'}, 1000);

We also have to arrange to hide the cart when it’s empty.
我们也要在购物车清空时隐藏掉它。
There are two basic ways of doing this.
有两种基本的方法可以做到这一点。
One, illustrated by the code at the start of this section, is not to generate any HTML at all.
一种方法已经在本节开始的代码中演示过了，不生成任何HTML代码。
Unfortunately, if we do that, then when we add something to the cart and suddenly create the cart HTML, we see a flicker in the browser as the cart is first displayed and then hidden and slowly revealed by the blind effect.
遗憾的是，如果这样做，当我们向购物车中添加东西并突然创建购物车的HTML代码时，会在浏览器中看到一个闪烁，因为先是显示购物车，然后隐藏并缓慢地通过blind效果显示出来。

A better way to handle the problem is to create the cart HTML but set the CSS style to display: none if the cart is empty.
一个更好的方法是创建购物车的HTML代码，如果购物车为空，则将CSS风格设置为`display: none;`。
To do that, we need to change the application.html.erb layout in app/views/layouts.
为了实现这一点，需要改变application.html.erb布局。
Our first attempt is something like this:
我们的第一次尝试是这样的：

     <div id="cart"
       <% if @cart.line_items.empty? %>
       style="display: none"
       <% end %>
       >
     <%= render(@cart) %>
     </div>

This code adds the CSS style= attribute to the <div> tag, but only if the cart is empty.
仅当购物车为空时，这段代码才将CSS的`style=`属性加入<div>标签中。
It works fine, but it’s really, really ugly.
这样做虽然行得通，却非常丑陋。
That dangling > character looks misplaced (even though it isn’t), and the way logic is interjected into the middle of a tag is the kind of thing that gives templating languages a bad name.
悬空的符号`>`像是被放错了地方（虽然并没有），并且逻辑以这种方式插入到标签中像是给模板语言起了一个糟糕的名字。
Let’s not let that kind of ugliness litter our code.
不要让这种丑陋现象污染我们的代码。
Instead, let’s create an abstraction that hides it—we’ll write a helper method.
应该创建一个抽象层将其隐藏起来--利用帮助方法。

### Helper Methods  帮助方法
Whenever we want to abstract some processing out of a view (any kind of view), we should write a helper method.
**不管我们何时相当某个过程从一个视图中（任何一种视图）抽象出来，都应该写一个帮扶方法。**

If you look in the app directory, you’ll find six subdirectories.
如果你查看app文件夹，会发现有个6子目录。

     depot> ls -p app
     assets/ controllers/ helpers/ mailers/ models/ views/

• 151

Not surprisingly, our helper methods go in the helpers directory.
毫不奇怪，我们的帮助方法应该放在helpers文件夹下。
If you look in that directory, you’ll find it already contains some files.
如果你查看那个文件夹的内容，会发现里面已经有了一些文件：

     depot> ls -p app/helpers
     application_helper.rb line_items_helper.rb store_helper.rb
     carts_helper.rb       products_helper.rb

The Rails generators automatically created a helper file for each of our controllers (products and store).
Rails生成器自动为每个控制器（产品和商店）生成了一个帮助方法的文件。
The Rails command itself (the one that created the application initially) created the file application_helper.rb.
Rails命令本身创建了文件application_helper.rb。
If you like, you can organize your methods into controller-specific helpers, but because this method will be used in the application layout, let’s put it in the application helper.
如果你喜欢，可以将方法组织到控制器特定的帮助方法中；但因为这个方法会在应用程序的布局中用到，所以我们就把它放在应用程序的帮助方法中。

Let’s write a helper method called hidden_div_if().
现在写一个hidden_div_if的帮助方法。
It takes a condition, an optional set of attributes, and a block.
它接受一个条件、一个可选的属性集合和一个块。
It wraps the output generated by the block in a <div> tag, adding the display: none style if the condition is true.
它将块的输出整合在<div>标签中。如果条件为真，就在该标签中增加`display: none;`风格。
Use it in the store layout like this:
在商店布局中这样使用它：

    Download rails40/depot_n/app/views/layouts/application.html.erb
    <%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
      <%= render @cart %>
    <% end %>

We’ll write our helper so that it is visible to the store controller by adding it to application_helper.rb in the app/helpers directory.
<kinder:note> 我们写下了帮助方法，把它放在app/helpers目录下的application_helper.rb，于是store控制器可以使用它了。

     Download rails40/depot_n/app/helpers/application_helper.rb
       module ApplicationHelper
     ➤   def hidden_div_if(condition, attributes = {}, &block)
     ➤     if condition
     ➤       attributes["style"] = "display: none"
     ➤     end
     ➤     content_tag("div", attributes, &block)
     ➤   end
       end

This code uses the Rails standard helper, content_tag(), which can be used to wrap the output created by a block in a tag.
这段代码使用了Rails的标准帮助方法，content_tag()，可以整合标签中块的输出。
By using the &block notation, we get Ruby to pass the block that was given to hidden_div_if() down to content_tag().
通过使用&block标记，我们让Ruby将传递到hidden_div的块进一步传递至content_tag中。

&block notation ↪ on page 44

And, finally, we need to stop setting the message in the flash that we used to display when the user empties a cart.
最后，我们需要停止在闪存中设置消息，这个信息原本是当用户清空购物车时显示的。
It really isn’t needed anymore, because the cart clearly disappears from the sidebar when the catalog index page is redrawn.
它不再需要了，因为当目录索引页重新显示的时候，购物车清楚地从侧边栏中消失了。
But there’s another reason to remove it, too.
并且，这里还有另外一个原因要移除它。
Now that we’re using Ajax to add products to the cart, the main page doesn’t get redrawn between requests as people shop.
现在我们使用Ajax来向购物车中添加商品，人们购物的时候，主页面不会再在请求之间刷新了。
That means we’ll continue to display the flash message saying the cart is empty even as we display a cart in the sidebar.
这意味着，购物车为空的闪存消息会继续显示，即使当我们在侧边栏中显示购物车。

• 152

     Download rails40/depot_n/app/controllers/carts_controller.rb
     def destroy
       @cart.destroy if @cart.id == session[:cart_id]
       session[:cart_id] = nil
       respond_to do |format|
     ➤   format.html { redirect_to store_url }
         format.json { head :no_content }
       end
     end

Now that we have added all this Ajax goodness, go ahead and empty your cart and add an item.
到现在为止，我们已经添加了所有这些Ajax的优良特性，试一试清空你的购物车，再添加一个项目吧。
Although this might seem like a lot of work, there really are only two essential steps to what we did.
虽然这样看起来好像坐了许多工作，实际上只有两个关键步骤。
First, we make the cart hide and reveal itself by making the CSS display style conditional on the number of items in the cart.
第一，让购物车项目中的数目来决定CSS的显示风格，可以让购物车显示或隐藏。
Second, we provided JavaScript instructions to invoke the blind effect when the cart went from being empty to having one item.
第二，当购物车从空的状态变成有了一个项目，我们使用JavaScript构造来调用blind效果。

So far, these changes have been pretty but not functional.
至今，这些改变已经非常漂亮，但还不实用。
Let’s proceed to changing the behavior of the page.
我们继续改变页面的行为吧。
How about we make clicking the image cause an item to be added to the cart?
单击图片来添加到购物车，这个功能怎么样？
It turns out that that’s easy too with JQuery.
用JQuery，那也很简单。

## 11.5 Iteration F5: Making Images Clickable 可点击图片 
<kinder:note> 本版新增，除了最后关于测试的几段，其他都是自己翻译。
So far, we have been doing things only in response to a click and only on things that are defined to be clickable (namely, buttons and links).
到目前，我们已经做的都是响应单击，而且是那些可单击的东西（也就是按钮和链接）。
In this case, what we want to do is to handle the onClick event for the image and have it execute some behavior that we define.
在这个情况下，我们想做的是处理图片的的onClick事件，并让他执行一些我们定义的行为。
In other words, what we want to do is to have a script that executes when the page loads and have it find all the images and associate logic with those images to forward the processing of click events to the Add to Cart button for the same entry.
换句话说，我们要做的是写一个脚本，当页面载入执行、发现所有图片，并与那些图片进行逻辑联系，将click事件联系到“添加到购物车”按钮同样的项目中。

First, we refresh our memory as to how the page in question is organized.
第一步，我们重刷新记忆到问题页面的组织上来。

• 153

     Download rails40/depot_n/app/views/store/index.html.erb
     <% if notice %>
       <p id="notice"><%= notice %></p>
     <% end %>
     <h1>Your Pragmatic Catalog</h1>
     <% cache ['store', Product.latest] do %>
       <% @products.each do |product| %>
       <% cache ['entry', product] do %>
         <div class="entry">
           <%= image_tag(product.image_url) %>
           <h3><%= product.title %></h3>
           <%= sanitize(product.description) %>
           <div class="price_line">
             <span class="price"><%= number_to_currency(product.price) %></span>
             <%= button_to 'Add to Cart', line_items_path(product_id: product),
                 remote: true %>
           </div>
         </div>
         <% end %>
       <% end %>
     <% end %>

Using this information, we proceed by modifying app/assets/javascripts/store.js.coffee.
要使用这个信息，修改app/assets/javascripts/store.js.coffee就可处理。

     Download rails40/depot_n/app/assets/javascripts/store.js.coffee
     # Place all the behaviors and hooks related to the matching controller here.
     # All this logic will automatically be available in application.js.
     # You can use CoffeeScript in this file: http://coffeescript.org/
     ➤ $(document).on "ready page:change", ->
     ➤   $('.store .entry > img').click ->
     ➤     $(this).parent().find(':submit').click()

CoffeeScript3 is another preprocessor that makes writing assets easier.
CoffeeScript是另一种预处理器，它让书写assets变得更简单。
In this case, CoffeeScript helps you express JavaScript in a more concise form.
在本例中，CoffeeScript帮你以一种更简洁的方式表达JavaScript。
Combined with JQuery, you can produce significant effects with very little effort.
加上JQuery，你就可事半功倍了。

In this case, the first thing we want to do is to define a function that executes on page load.
在本例中，我们要做的第一件事是定义一个在页面装载时执行的函数。
That’s what the first line of this script does: it defines a function using the -> operator and passes it to a function named on, which associates the function with two events: ready and page:change.
那就是第一行所做的事情：它使用->操作符定义了一个函数，然后将它传递一个名为on的函数中，on函数连接着两个事件：ready（就绪）和page:change（页面变化）。 
ready is the event that fires if people navigate to your page from outside of your site, and page:change is the event that Turbolinks4 fires if people navigate to your page from within your site.
ready在人们从站外浏览到你的页面时触发的，page:change则是人们在网站内部浏览到该页面时Turbolinks所触发的。
Associating the script to both makes sure you are covered either way.
将两者和脚本联系起来可确保对两种方式都有效。

The second line finds all images that are immediate children of elements that are defined with class="entry", which themselves are descendants of an element with class="store".
第二行会找到所有的图片，它们是class="store"元素的后代元素class="entry"元素的直接子元素。
This last part is important because, just like with stylesheets, Rails will by default combine all JavaScripts into a single resource.
这最后部分很重要，因为正如样式表，Rails将默认将所有的JavaScripts整合到单个资源之中。
For each image found, which could be zero when run against other pages in our application, a function is defined that is associated with the click event for that image.
每找到一个图片（运行应用程序的其他页面则无法找到），就定义一个函数，它将每个图片和click事件联系起来。

3. http://jashkenas.github.com/coffee-script/
4. https://github.com/rails/turbolinks/blob/master/README.md#turbolinks

• 154

The third and final line processes that click event.
第三行也就是最后一行处理单击事件。
It starts with the element on which the event occurred, namely, this.
它用发生事件的元素开始，即this。
It then proceeds to find the parent element, which will be the div that specifies class="entry".
然后接着寻找父元素，该父元素将被指定为<div class="entry">。
Within that element we find the submit button, and we proceed to click it.
在那个元素里面找到submit按钮，单击它。

Proceeding to the browser, the page looks no different from it did in Figure 29, The cart is in the sidebar., on page 141.
回到浏览器，页面看起来和前面141页的图29并没有两样。
But it behaves differently.
不过它的表现可不同了。
Click the images to cause items to be added to the cart.
单击页面将把项目添加到购物车中。
Marvel in the fact that all this was accomplished with a mere three lines of code.
奇迹就发生在这仅有的三行代码中。

Of course, you could have done all of this in JavaScript directly, but that would have required five more sets of parentheses, two sets of braces, and overall about 50 percent more characters.
当然，你可以直接用JavaScript来做，但至少需要5组花括号、2组支架，并多出50%的代码字符。
And this just barely scratches the surface of what CoffeeScript can do.
不过这只是CoffeeScript所能做的皮毛而已。
A good place to find out more on this subject is CoffeeScript:Accelerated JavaScript Development [Bur11].
详情可参《CoffeeScript：快速JavaScript开发》一书。

At this point, it occurs to us that we haven’t really done much with respect to testing, but it doesn’t really feel like we’ve made much in the way of functional changes, so we should be fine.
现在，好像我们并没有进行测试，但由于我们没有在功能上做太多改变，所以应该没有问题。
But just to be sure, we run our tests again.
为保险期间，再次运行测试：

    depot> rake test
    .....E...F.EEEE.........EEEE..

Oh dear. 
哦。
Failures and errors. 
失败和错误。
This is not good. 
这可不好。
Clearly, we need to revisit our approach to testing. 
显然，我们得重新考虑测试的方法了。
In fact, we will do that next.
下一步我们就做了。

## 11.6 Testing Ajax Changes  测试Ajax的变化
We look at the test failures, and we see a number of errors that look like the following:
通过检查这些测试失败，我们看到了一些像下面这样的错误信息：

    ActionView::Template::Error: undefined method `line_items' for nil:NilClass

Since this error represents the majority of the problems reported, let’s address it first so that we can focus on the rest.
因为这个错误代表了报告的大多数问题，所以先来解决它。
According to the test, we will have a problem if we get the product index, and sure enough, when we point our browser to http://localhost:3000/products/, we see the results shown in Figure 31, An error in a layout can affect the entire application., on page 155.
根据测试，如果我们get访问产品目录页，就会有问题。果然我们在浏览器访问http://localhost:3000/products/时，显示的结果正如下页的图表31。

This information is very helpful.
这个信息非常有用。
The message identifies the template file that was being processed at the point where the error occurs (app/views/layouts/application.html.erb), the line number where the error occurred, and an excerpt from the template of lines around the error.
该消息标定了当错误发生时，正在处理的模板文件（app/views/layouts/application.html.erb），错误发生的行数和该错误附近的模板文件的摘录。
From this, we see that the expression being evaluated at the point of error is @cart.line_items, and the message produced is undefined method `line_items' for nil.
通过这些，我们可以知道错误发生的时候正在计算的是表达式@cart.line_items，并且产生的错误是undefined method `line_items' for nil。

• 155

Figure 31—An error in a layout can affect the entire application.

So, @cart is apparently nil when we display an index of our products.
因此，当我们显示商品的索引的时候，@cart显然为nil。
That makes sense, because it is set only in the store controller.
这说得通，因为它是在商店控制器中被设置的。
This is easy enough to fix; all we need to do is avoid displaying the cart at all unless this value is set.
修复这个错误十分简单；只需避免显示购物车，除非这个值被设置了：

     Download rails40/depot_o/app/views/layouts/application.html.erb
     ➤ <% if @cart %>
         <%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
           <%= render @cart %>
         <% end %>
     ➤ <% end %>

After this fix, we rerun the tests and see that we are down to one error.
修复这个问题之后，我们重新运行测试，发现错误减少了一个。
The value of the redirect was not what was expected.
重定向的值不是我们所期望的。
This occurred on creating a line item.
该错误发生在创建一个行项目的时候。
Sure enough, we did change that on Changing the Flow, on page 141.
果然，我们是在前面141页中更改它的。
Unlike the last change, which was entirely accidental, this change was intentional, so we update the corresponding functional test case.
与上个完全无意的修改不同，这个改变是有意的，因此我们来更新相应的功能测试案例。

     Download rails40/depot_o/test/controllers/line_items_controller_test.rb
     test "should create line_item" do
       assert_difference('LineItem.count') do
         post :create, product_id: products(:ruby).id
       end
     ➤ assert_redirected_to store_path
     end

• 156

With this change in place, our tests now once again pass.
这个修改过后，我们的测试再次通过了。
Just imagine what could have happened.
想想会发生什么。
A change in one part of an application in order to support a new requirement breaks a function we previously implemented in another part of the application.
为了支持一个新的需求，我们更改了应用程序的一部分，但整个修改却破坏了我们之前在应用程序另一部分所写的代码。
If you are not careful, this can happen in a small application like Depot.
如果你不小心，就会发生在像Depot一样的小的应用程序中。
Even if you are careful, this will happen in a large application.
即使你小心了，也会在一个大的应用程序中出现。

But we are not done yet.
但还没结束。
We haven’t tested any of our Ajax additions, such as what happens when we click the Add to Cart button.
我们还没有测试所有与Ajax相关的其他东西，比如当我们按下“添加到购物车”按钮的时候会发生什么。
Rails makes that easy too.
使用Rails实现它十分简单。

We already have a test for should create line item, so let’s add another one called should create line item via ajax.
对于，我们已经有了一个should create line item测试，现在再添加另一个称为should create line item via ajax的测试。

     Download rails40/depot_o/test/controllers/line_items_controller_test.rb
     test "should create line_item via ajax" do
       assert_difference('LineItem.count') do
         xhr :post, :create, product_id: products(:ruby).id
       end
       assert_response :success
       assert_select_jquery :html, '#cart' do
         assert_select 'tr#current_item td', /Programming Ruby 1.9/
       end
     end

This test differs in the name of the test, in the manner of invocation from the create line item test (xhr :post vs.  simply post, where xhr stands for the XMLHttpRequest mouthful), and in the expected results.
与其名字不同的是，该测试引用创建在线商品的测试方式（xhr :post和纯粹的post相比，xhr的全称是XMLHttpRequest）和预期的结果。
Instead of a redirect, we expect a successful response containing a call to replace the HTML for the cart, and in that HTML we expect to find a row with an ID of current_item with a value matching Programming Ruby 1.9.
我们预期获得一个成功的回复，而不是重定向；该回复包含了一个调用来代替购物车的HTML，并且在该HTML中，我们应该可以找到一行id为current_item，其值和“Programming Ruby 1.9”一致。
This is achieved by applying the assert_select_jquery() to extract the relevant HTML and then processing that HTML via whatever additional assertions you want to apply.
为了做到这一点，我们可以用assert_select_jquery()来提取相关的HTML，并且用你想要的其他任何断言来处理该HTML。

Finally, there is the CoffeeScript that we introduced.
<kinder:note> 最后要介绍的，是CoffeeScript。
While testing code that actually executes in the browser is outside the scope of this book, we should test that the markup this script depends on is in place.
<kinder:note>
因为有关“测试浏览器中执行的代码”超出了本书的论述范围，我们转而测试这个脚本的标记。
And it is certainly easy enough.
它是如此简单：

     Download rails40/depot_o/test/controllers/store_controller_test.rb
     test "markup needed for store.js.coffee is in place" do
       get :index
       assert_select '.store .entry > img', 3
       assert_select '.entry input[type=submit]', 3
     end

This way, should an exuberant web designer change the markup on the page in a way that affects our logic, we will be alerted to this issue and be able to make a change before the code goes into production.
这样一来，旺盛的网页设计师更改页面上的标记以一种方式影响我们的逻辑，我们要警醒这个问题，并能代码投产之前做出改变。
• 157 

Note that :submit is a jQuery-only extension to CSS; we simply need to spell out input[type=submit] in our test.
<kinder:note> 注意“:submit”是一个CSS只适用于jQuery的扩展；我们只需要在测试中写出input[type=submit]即可。
<kinder:note>怎么理解“a jQuery-only extension to CSS”？

Keeping tests up-to-date is an important part of maintaining your application.
维护应用程序的一个非常重要的部分是令测试集总是最新的。
Rails makes this easy to do.
Rails令这一点变得简单。
Agile programmers make testing an integral part of their development efforts.
测试是敏捷程序员的开发过程中不可或缺的一部分。
Many even go so far as to write their tests first, before the first line of code is written.
许多程序员甚至先于第一行代码之前写下测试集。

## What We Just Did
In this iteration, we added Ajax support to our cart.
• We moved the shopping cart into the sidebar.
We then arranged for the create action to redisplay the catalog page.

• We used remote: true to invoke the LineItemsController.create() action using Ajax.

• We then used an ERB template to create JavaScript that will execute on the client.
This script made use of jQuery in order to update to the page with just the cart’s HTML.

• To help the user see changes to the cart, we added a highlight effect, using the jQuery-UI library.

• We wrote a helper method that hides the cart when it is empty and used jQuery to reveal it when an item is added.

• We wrote a test that verifies not only the creation of a line item but also the content of the response that is returned from such a request.

• We added a bit of CoffeeScript in order to cause items to be added to the cart when an image is clicked.

The key point to take away is the incremental style of Ajax development.
Start with a conventional application and then add Ajax features, one by one.
Ajax can be hard to debug; by adding it slowly to an application, you make it easier to track down what changed if your application stops working.
And, as we saw, starting with a conventional application makes it easier to support both Ajax and non-Ajax behavior in the same codebase.

Finally, we’ll give you a couple of hints.
First, if you plan to do a lot of Ajax development, you’ll probably need to get familiar with your browser’s JavaScript debugging facilities and with its DOM inspectors, such as Firefox’s Firebug, Internet Explorer’s Developer Tools, Google Chrome’s Developer Tools, Safari’s Web Inspector, or Opera’s Dragonfly.
And, second, the NoScript plugin for Firefox makes checking JavaScript/no JavaScript a one-click breeze.

• 158

Others find it useful to run two different browsers when they are developing —with JavaScript enabled in one and disabled in the other.
Then, as new features are added, poking at it with both browsers will make sure your application works regardless of the state of JavaScript.

## Playtime
Here’s some stuff to try on your own:
• The cart is currently hidden when the user empties it by redrawing the entire catalog.
当前， 如果用户重新刷新整个购物目录可以将购物车清空并隐藏。
Can you change the application to use the jQuery UI blind effect instead?
你可以用jQuery UI的blind效果来实现吗？

• Add a button next to each item in the cart.
  在购物车的每个项目上都添加一个按钮。
When clicked, it should invoke an action to decrement the quantity of the item, deleting it from the cart when the quantity reaches zero.
单击该按键时，触发一个动作，使得某个项目的数量减少，并当数量为0时从购物车中将该项目删去。
Get it working without using Ajax first and then add the Ajax goodness.
先不用Ajax实现，然后在添加Ajax特性。

(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)


# CHAPTER 12 Task G: Check Out!  付款
## In this chapter, we’ll see
• linking tables with foreign keys;
• using belongs_to, has_many, and :through;
• creating forms based on models (form_for);
• linking forms, models, and views; and
• generating a feed using atom_helper on model objects.

Let’s take stock.
So far, we’ve put together a basic product administration system, we’ve implemented a catalog, and we have a pretty spiffy-looking shopping cart.
So, now we need to let the buyer actually purchase the contents of that cart.
Let’s implement the checkout function.

We’re not going to go overboard here.
For now, all we’ll do is capture the customer’s contact details and payment option.
Using these, we’ll construct an order in the database.
Along the way, we’ll be looking a bit more at models, validation, and form handling.

#### 12.1 Iteration G1: Capturing an Order  获取订单
An order is a set of line items, along with details of the purchase transaction.
订单是商品项目及其购买交易的细节的集合。
Our cart already contains line_items, so all we need to do is add an order_id column to the line_items table and create an orders table based on the Initial guess at application data diagram on page 59, combined with a brief chat with our customer.
我们的购物车已经包含了`line_items`，那么现在要做的只是在`line_items`表中添加一列`order_id`，并根据前面第9页所示创建一个orders表，该表格整合了与顾客的简短聊天互动。

First we create the order model and update the line_items table.
首先我们创建订单模型并更新`line_items`表：

     depot> rails generate scaffold Order name address:text email pay_type
     depot> rails generate migration add_order_to_line_item order:references

Note that we didn’t specify any data type for three out of the four columns.
<kinder:note> 注意四栏表格中的三栏，我们没有指定数据类型。
This is because the data type defaults to string.
<kinder:note> 这是因为数据类型的默认值就是字符串。
This is yet another small way in which Rails makes things easier for you in the most common case without making things any more cumbersome when you need to specify a data type.
<kinder:note> 这只是Rails针对常用情景进行简化的另一个方法；当你需要指定数据类型时，不会把事情变得复杂。

• 160

Now that we’ve created the migrations, we can apply them.
创建迁移之后，应用它们。

     depot> rake db:migrate
     == CreateOrders: migrating =======================================
     -- create_table(:orders)
         -> 0.0014s
     == CreateOrders: migrated (0.0015s) ==============================
     
     == AddOrderIdToLineItem: migrating ===============================
     -- add_column(:line_items, :order_id, :integer)
         -> 0.0008s
     == AddOrderIdToLineItem: migrated (0.0009s) ======================

Because the database did not have entries for these two new migrations in the schema_migrations table, the db:migrate task applied both migrations to the database.
因为数据库的`schema_migrations`表格中还没有这两个新东西的项目，所以`db:migrate`任务会将它们两个都迁移到数据库中。
We could, of course, have applied them separately by running the migration task after creating the individual migrations.
当然，我们也可以通过在创建一个迁移之后运行迁移任务来单独地迁移它们。

#### Creating the Order Capture Form 创建获取订单的表单
Now that we have our tables and our models as we need them, we can start the checkout process.
现在我们有了所需的表格和模型，可以开始付款的过程了。
First, we need to add a Checkout button to the shopping cart.
首先，在购物车中添加一个“提交订单”的按钮。
Because it will create a new order, we’ll link it back to a new action in our order controller.
因为这样会创建一个新的订单，所以我们要将它连接回订单控制器的new动作。

     Download rails40/depot_o/app/views/carts/_cart.html.erb
     <h2>Your Cart</h2>
     <table>
       <%= render(cart.line_items) %>
       <tr class="total_line">
         <td colspan="2">Total</td>
         <td class="total_cell"><%= number_to_currency(cart.total_price) %></td>
       </tr>
     </table>
     ➤ <%= button_to "Checkout", new_order_path, method: :get %>
       <%= button_to 'Empty cart', cart, method: :delete,
           data: { confirm: 'Are you sure?' } %>

The first thing we want to do is check to make sure that there’s something in the cart.
我们要做的第一件事是检查购物车中是否有东西。
This requires us to have access to the cart.
<kinder:note> 这要求我们可以访问购物车。
Planning ahead, we’ll also need this when we create an order.
<kinder:note> 接着，创建订单时，需要这个。

     Download rails40/depot_o/app/controllers/orders_controller.rb
     class OrdersController < ApplicationController
     ➤ include CurrentCart
     ➤ before_action :set_cart, only: [:new, :create]
       before_action :set_order, only: [:show, :edit, :update, :destroy]
       # GET /orders
       #...
     end

• 161

------------------------------
Joe asks: Where’s the Credit-Card Processing?
Joe问： 信用卡处理在哪里？
In the real world, we’d probably want our application to handle the commercial side of checkout.
在现实世界中，我们或许希望应用程序可以处理商业付款问题
We might even want to integrate credit-card processing.
甚至希望可以整合信用卡的处理。
However, integrating with back-end payment-processing systems requires a fair amount of paperwork and jumping through hoops.
但是，与后台付款处理系统的整合需要许多文件和环节。
And this would distract from looking at Rails, so we’re going to punt on this particular detail for the moment.
这会分散对Rails的注意，所以这里会暂时搁置这个细节。

We will come back to this in Section 25.1, Credit Card Processing with Active Merchant, on page 411, where we will explore a plugin that can help us with this function.
在后面25.1节中，会再提到这一点，届时我们会使用一个插件来完成这个功能。

------------------------------

Next we need to add the code that checks the cart.
下面我们需要添加代码来检查购物车。
If there is nothing in the cart, we redirect the user back to the storefront, provide a notice of what we did, and return immediately.
如果购物车里没有东西，要将用户重定向会商店首页，并提示一个通知，告诉用户我们将他送回。
This prevents people from navigating directly to the checkout option and creating empty orders.
这会阻止用户直接进入结算选项、创建空订单。
The return statement is important here; without it you will get a double render error because your controller will attempt to both redirect and render output.
`return`回语句在这里非常重要；没有它，就会发生`double render error`（双重显示错误），因为控制器会试图同时重定向和显示输出。

       Download rails40/depot_o/app/controllers/orders_controller.rb
       def new
     ➤   if @cart.line_items.empty?
     ➤     redirect_to store_url, notice: "Your cart is empty"
     ➤     return
     ➤   end
     ➤   @order = Order.new
       end

And we add a test for requires item in cart and modify the existing test for should get new to ensure that there is an item in the cart.
然后，为`requires item in cart`增加一个测试，并修改`should get new`的测试来保证购物车中有商品。

     Download rails40/depot_o/test/controllers/orders_controller_test.rb
     ➤ test "requires item in cart" do
     ➤   get :new
     ➤   assert_redirected_to store_path
     ➤   assert_equal flash[:notice], 'Your cart is empty'
     ➤ end
     
       test "should get new" do
     ➤   item = LineItem.new
     ➤   item.build_cart   # 这个build_cart方法还是第一次看到吧？干嘛的？
     ➤   item.product = products(:ruby)
     ➤   item.save!
     ➤   session[:cart_id] = item.cart.id
         get :new
         assert_response :success
       end

• 162

Now we want the new action to present our user with a form, prompting them to enter the information in the orders table: their name, address, email address, and payment type.
现在我们想要让new动作向用户展示一个表单，该表单让它们可以在订单表格中填写相关信息：
名字、地址、电邮地址和付款类型。
This means we will need to display a Rails template containing a form.
这意味着我们需要显示一个包含了表单的Rails模板。
The input fields on this form will have to link to the corresponding attributes in a Rails model object, so we’ll need to create an empty model object in the new action to give these fields something to work with.
该表单的输入项需要连接到一个Rails模型对象的相应属性，因此我们得在new动作中创建一个空的模型对象，以便让这些项目可以在上面工作。

As always with HTML forms, the trick is populating any initial values into the form fields and then extracting those values out into our application when the user hits the submit button.
就像HTML表单一样，这里的技巧是向表单项中填入一些初始值，然后在用户单击提交按钮之后，取出这些值放回到应用程序中。

In the controller, the @order instance variable is set to reference a new Order model object.
在这个控制中，@order实例变量被设置成一个新的Order模型对象的引用。
This is done because the view populates the form from the data in this object.
之所以这么做是因为视图从这个对象的数据中生成了表单。
As it stands, that’s not particularly interesting.
按照实际情况来说，这不是特别有意义。
Because it’s a new model object, all the fields will be empty.
因为它是个新的模型对象，所有项都是空的。
However, consider the general case.
但是，考虑一般情况。
Maybe we want to edit an existing order.
或许我们想要编辑一个已存在的订单。
Or maybe the user has tried to enter an order but their data has failed validation.
或者用户视图输入一个订单，但数据验证却失败了。
In these cases, we want any existing data in the model shown to the user when the form is displayed.
在这些情况下，我们希望显示表单时，任何在模型中存在的数据都会显示该用户。
Passing in the empty model object at this stage makes all these cases consistent—the view can always assume it has a model object available.
在此阶段传递一个空模型对象让所有的这些情况保持了一致--视图可以假定总是有一个模型对象可用。

Then, when the user hits the submit button, we’d like the new data from the form to be extracted into a model object back in the controller.
然后，当用户单击提交按钮，我们要提取表单中的新数据放到控制器的模型对象中。

Fortunately, Rails makes this relatively painless.
幸运的是， Rails让这个过程变得相对简单。
It provides us with a bunch of form helper methods.
它提供了很多form帮助方法。
These helpers interact with the controller and with the models to implement an integrated solution for form handling.
这些帮助方法与控制器和模型交互，以实现对表单处理的集成解决方案。
Before we start on our final form, let’s look at a simple example:
在开始我们最后的表单之前，来看一个简单的例子：

     <%= form_for @order do |f| %>
     <p>
       <%= f.label :name, "Name:" %>
       <%= f.text_field :name, size: 40 %>
     </p>
     <% end %>

There are two interesting things in this code.
这段代码有两个事情有意思：
First, the form_for() helper on line 1 sets up a standard HTML form.
首先，form_for()帮助方法设置了一个标准的HTML表单。
But it does more.
但它还做了更多的事情。
The first parameter, @order, tells the method the instance variable to use when naming fields and when arranging for the field values to be passed back to the controller.
第一个参数@order告诉方法，当命名字段和安排传递回控制器的字段值值时，应该用什么样的实例变量。

You’ll see that form_for sets up a Ruby block environment (this block ends on line 6).
你会看到`form_for`设置了一个ruby代码块环境（该代码位在第六行结束）。
Within this block, you can put normal template stuff (such as the <p> tag).
在这个代码块中，可以用普通的模板（例如<p>标签）。
But you can also use the block’s parameter (f in this case) to reference a form context.
但也可以用这个代码块的参数（在这个例子中是f）去引用一个表单的内容。
We use this context on line 4 to add a text field to the form.
我们在第四行用这个内容给表单增加一个text项。

• 163

Because the text field is constructed in the context of the form_for, it is automatically associated with the data in the @order object.
因为该text项是在form_for的内容中创建的，所以它自动与@order对象中的数据相关联。

All these relationships can be confusing.
所有这些关系有点让人迷惑。
It’s important to remember that Rails needs to know both the names and the values to use for the fields associated with a model.
最重要的是要记住，Rails需要同时知道与模型相关联的命名和值。
The combination of form_for and the various fieldlevel helpers (such as text_field) gives it this information.
form_for和各种字段级辅助方法（例如text_field）的联合给出了这个信息。
We can see this process in the following figure:
下图显示了这个过程。

     controller:                    model object:
     def edit                         @order.name ---> "Dave"
       @order = Order.find(...)          |    /
     end   \  \                          |  /
             \ \                         | |
               \                         | |
     <%= form_for @order do |f| %>       | |
       <p>                               |/
         <%= f.label :name, "Name:" %>   |
         <%= f.text_field :name , size: 40 %>
       </p>
     <% end %>
                             +--------------------+
                             |         +------+   |
                             |   Name: | Dave |   |
                             |         +------+   |
                             +--------------------+

Figure 32—The names in form_for map to objects and attributes.

Now we can update the template for the form that captures a customer’s details for checkout.
现在我们可以为获取顾客付款细节的表单更新模板了。
It’s invoked from the new action in the order controller, so the template is called new.html.erb, found in the directory app/views/orders.
它由订单控制器中的new动作调用，所以这个模板被命名为new.html.erb，你可以在文件app/view/orders中找到它：

     Download rails40/depot_o/app/views/orders/new.html.erb
     <div class="depot_form">
       <fieldset>
         <legend>Please Enter Your Details</legend>
         <%= render 'form' %>
       </fieldset>
     </div>

This template makes use of a partial named `_form`.
这个模板利用了一个名叫`_form`的局部模板：

• 164

     Download rails40/depot_o/app/views/orders/_form.html.erb
     <%= form_for(@order) do |f| %>
       <% if @order.errors.any? %>
         <div id="error_explanation">
           <h2><%= pluralize(@order.errors.count, "error") %>
           prohibited this order from being saved:</h2>
           <ul>
           <% @order.errors.full_messages.each do |msg| %>
             <li><%= msg %></li>
           <% end %>
           </ul>
         </div>
       <% end %>
       <div class="field">
         <%= f.label :name %><br>
     ➤   <%= f.text_field :name, size: 40 %>
       </div>
       <div class="field">
         <%= f.label :address %><br>
     ➤   <%= f.text_area :address, rows: 3, cols: 40 %>
       </div>
       <div class="field">
     ➤   <%= f.label :email %><br>
         <%= f.email_field :email, size: 40 %>
       </div>
       <div class="field">
         <%= f.label :pay_type %><br>
     ➤   <%= f.select :pay_type, Order::PAYMENT_TYPES,
     ➤       prompt: 'Select a payment method' %>
       </div>
       <div class="actions">
     ➤   <%= f.submit 'Place Order' %>
       </div>
     <% end %>

Rails has form helpers for all the different HTML-level form elements.
Rails有许多表单帮助方法，用来为所有不同层次的HTML级表单元素服务。
In the previous code, we use text_field, email_field, and text_area helpers to capture the customer’s name, email, and address.
在之前的代码中，我们使用text_field和text_area帮助方法来获取顾客的姓名、邮箱、地址。
We cover form helpers in more depth in Section 21.2, Generating Forms, on page 343.
在后面343页21.2节会详细介绍表单帮助方法。

The only tricky thing in there is the code associated with the selection list.
这里唯一麻烦的是与选项的相关的代码。
We’ve assumed that the list of available payment options is an attribute of the Order model.
我们已经假定可用的付款方式选项的列表是Order模型的一个属性。
We’d better define the option array in the model order.rb before we forget.
最好在我们忘记之前在模型order.rb中定义选项数组：

     Download rails40/depot_o/app/models/order.rb
     class Order < ActiveRecord::Base
     ➤ PAYMENT_TYPES = [ "Check", "Credit card", "Purchase order" ]
     end

In the template, we pass this array of payment type options to the select helper.
在这个模板中，我们向select帮助方法传递了付款方式选项的数组。
We also pass the :prompt parameter, which adds a dummy selection containing the prompt text.
也传递了:promot参数，添加一个含有提示文字的伪选择。

• 165

Add a little CSS magic:
增加一点CSS魔法：

     Download rails40/depot_o/app/assets/stylesheets/application.css.scss
     .depot_form {
       fieldset {
         background: #efe;
         legend {
           color: #dfd;
           background: #141;
           font-family: sans-serif;
           padding: 0.2em 1em;
         }
       }
       form {
         label {
           width: 5em;
           float: left;
           text-align: right;
           padding-top: 0.2em;
           margin-right: 0.1em;
           display: block;
         }
         select, textarea, input {
           margin-left: 0.5em;
         }
         .submit {
           margin-left: 4em;
         }
         br {
           display: none
         }
       }
     }

We’re ready to play with our form.
可以试试我们的表单了。
Add some stuff to your cart, and then click the Checkout button.
向购物车中添加一点东西，然后单击“提交订单”按钮。
You should see something like Figure 33, Our checkout screen, on page 166.
应该可以看到下页所示的页面了。

Looking good! 
看起来不错。
Before we move on, let’s finish the new action by adding some validation.
在继续之前，让我们通过增加一些验证来完成new动作。
We’ll change the Order model to verify that the customer enters data for all the input fields.
我们要改变Order模型以检验顾客在所有项中输入的数据。

We also validate that the payment type is one of the accepted values.
我们还要验证付款方式是可接受值中的一个。

• 166

Figure 33—Our checkout screen

Some folks might be wondering why we bother to validate the payment type, given that its value comes from a drop-down list that contains only valid values.
有人可能会想，既然付款方式的值是从仅含有效值的下拉菜单中选择的，为什么还要关心验证它？
We do it because an application can’t assume that it’s being fed values from the forms it creates.
这是因为**一个应用程序不能假设它所接收的值是从它所创建的表单得来的**。
Nothing is stopping a malicious user from submitting form data directly to the application, bypassing our form.
什么也无法阻止恶意用户绕过我们的表单，直接向应用程序提交表单数据。
If the user set an unknown payment type, they might conceivably get our products for free.
如果用户设置了一个未知的付款方式，他们或许可以免费得到我们的产品。

     Download rails40/depot_o/app/models/order.rb
     class Order < ActiveRecord::Base
     # ...
     ➤ validates :name, :address, :email, presence: true
     ➤ validates :pay_type, inclusion: PAYMENT_TYPES
     end

Note that we already loop over the @order.errors at the top of the page.
注意我们已经在页面的上方循环遍历了@order.errors。
This will report validation failures.
这会报告验证失败。
Since we modified validation rules, we need to modify our test fixture to match.
既然我们已经修改了验证规则，需要修改静态测试以匹配。
• 167

     Download rails40/depot_o/test/fixtures/orders.yml
     # Read about fixtures at
     # http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
     one:
     ➤ name: Dave Thomas      # 三处修改部分原文全部为MyText
       address: MyText
     ➤ email: dave@example.org
     ➤ pay_type: Check
     two:
       name: MyString
       address: MyText
       email: MyString
       pay_type: MyString

Furthermore, for an order to be created, a line item needs to be in the cart, so we need to modify the line items test fixture too.
并且，为了创建一个订单，购物车中需要有一个商品项目，所以我们也得修改商品项目的静态测试。

     Download rails40/depot_o/test/fixtures/line_items.yml
     # Read about fixtures at
     # http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
     one:
       product: ruby      # 原文： product_id:
     ➤ order: one         # 原文： cart_id:
     two:
       product: ruby
       cart: one

Note that if you didn’t choose to do the optional exercises in Playtime, on page 132, you will need to modify all of the references to products and carts at this time.
<kinder:note> 注意，如果你没有做前面132页的练习，需要修改所有指向产品和购物车的引用。
<kinder:note> 什么意思？怎么修改？改为：`order_id: one`

Feel free to make other changes, but only the first is currently used in the functional tests.
可随意改两个订单，但当前的功能测试只是使用一个。

For these tests to pass, we will need to implement the model.
<kinder:note> 随着测试通过，我们需要实现该模型。

#### Capturing the Order Details  获取订单细节
Let’s implement the create() action in the controller. 
让我们来实现控制器的create()动作。
This method has to do the following:
这个方法要完成以下几件事情：

1. Capture the values from the form to populate a new Order model object.
   获取表单中的值，以生成一个新的Order模型对象。
2. Add the line items from our cart to that order.
   向该订单中添加购物车中的商品项目。
3.  Validate and save the order.
    验证并保存订单。
If this fails, display the appropriate messages, and let the user correct any problems.
如果保存失败，显示合适的消息以让用户纠正问题。
4.  Once the order is successfully saved, delete the cart, redisplay the catalog page, and display a message confirming that the order has been placed.
    一旦订单保存成功，删除购物车，重新显示目录页，并显示一则消息确认已下好订单。

We define the relationships themselves, first from the line item to the order:
定义关系本身，先从在线商品到订单。

     Download rails40/depot_o/app/models/line_item.rb
     class LineItem < ActiveRecord::Base
     ➤ belongs_to :order
       belongs_to :product
       belongs_to :cart
       def total_price
         product.price * quantity
       end
     end

• 168

and then from the order to the line item, once again indicating that all line items that belong to an order are to be destroyed whenever the order is destroyed.
然后，从订单到在线商品，再一次指明无论何时订单被销毁，所有该订单的在线商品都要被销毁。

     Download rails40/depot_o/app/models/order.rb
     class Order < ActiveRecord::Base
     ➤ has_many :line_items, dependent: :destroy
       # ...
     end

The method itself ends up looking something like this:
最后，方法本身如下：

     Download rails40/depot_o/app/controllers/orders_controller.rb
     def create
       @order = Order.new(order_params)
     ➤ @order.add_line_items_from_cart(@cart)
       # 这个@cart参数是怎么传递过来的？应该不是通过浏览器的请求。
       # 是Rails施展了它的魔法吗？呵呵，具体是哪个组件？
       respond_to do |format|
         if @order.save
     ➤     Cart.destroy(session[:cart_id])
     ➤     session[:cart_id] = nil
     ➤     format.html { redirect_to store_url, notice:
     ➤                   'Thank you for your order.' }
     ➤     format.json { render action: 'show', status: :created,
                         location: @order }
         else
           format.html { render action: 'new' }
           format.json { render json: @order.errors,
                         status: :unprocessable_entity }
         end
       end
     end

We start by creating a new Order object and initialize it from the form data.
首先我们创建一个新的Order对象，并且用表单数据初始化它。
The next line adds into this order the items that are already stored in the cart—we’ll write the actual method to do this in a minute.
下一行将购物车中已存储的项目添加到该订单中--我们马上就会实现这个方法。

Next we tell the order object to save itself (and its children, the line items) to the database.
接下来让订单对象保存自身（和它的子项目，在线商品）到数据库中。

Along the way, the order object will perform validation (but we’ll get to that in a minute).
在该过程中，订单对象会执行验证（我们后面再来讨论这一点）。
If the save succeeds, we do two things.
如果保存成功，将会完成两件事情。
First, we ready ourselves for this customer’s next order by deleting the cart from the session.
第一，通过从会话中删除购物车，为顾客的下一个订单做好准备。
Then, we redisplay the catalog using the redirect_to() method to display a cheerful message.
第二，通过使用redirected_to()方法重新显示目录并显示一条祝贺信息。
If, instead, the save fails, we redisplay the checkout form with the current cart.
如果失败，则会重新显示付款表单。

In the create action we assumed that the order object contains the method add_line_items_from_cart(), so let’s implement that method now.
在create动作中，我们假定订单对象包含有`add_line_items_from_cart`方法，现在我们来实现这个方法。

• 169

------------------------------
Joe asks: 
Joe 问：
Aren’t You Creating Duplicate Orders?
你没有创建重复订单吧？
Joe is concerned to see our controller creating Order model objects in two actions: new and create.
Joe很关心地来看我们的控制器，该控制器用两个动作new和create创建了订单模型对象。
He’s wondering why this doesn’t lead to duplicate orders in the database.
他很想直到为什么这样不会导致数据库中的重复订单。

The answer is simple: the new action creates an Order object in memory simply to give the template code something to work with.
答案很简单：new动作在内存中创建了一个Order对象来给模板工作。
Once the response is sent to the browser, that particular object gets abandoned, and it will eventually be reaped by Ruby’s garbage collector.
一旦将响应发给浏览器，就会抛弃那个特定的对象，并最终由ruby的垃圾收集器清理。
It never gets close to the database.
它从来无法接近数据库。

The create action also creates an Order object, populating it from the form fields.
create动作也创建了一个Order对象，它由表单中的项生成。
This object does get saved in the database.
该对象会保存在数据库中。
So, model objects perform two roles:
所以，模型对象有两个作用：
they map data into and out of the database, but they are also just regular objects that hold business data.
它们将数据映射进或映射出数据库，但它们也只是保持商业数据的普通对象。
They affect the database only when you tell them to, typically by calling save().
当且仅当让它们影响数据库的时候它们才会这么做，通常情况下是通过调用save()来实现。

------------------------------

     Download rails40/depot_p/app/models/order.rb
     class Order < ActiveRecord::Base
       # ...
     ➤ def add_line_items_from_cart(cart)
     ➤   cart.line_items.each do |item|
     ➤     item.cart_id = nil
     ➤     line_items << item
           # <kinder:note> 对这句`<<`感到迷惑。
           # 如果不是`cart.line_items`，那这个line_items变量又是干嘛的？
           # 从下面的sqlite3操作可知，这个`<<`似乎和`order_id`字段的赋值有关。不过这一步是在哪里实现的？
           # 这个order的line_items变量是在models定义的，这里是order的作用域，所以无需表明order.line_items。无论是cart.line_items还是order.line_items，本质都是line_item的id。
     ➤   end
     ➤ end
     end


For each item that we transfer from the cart to the order, we need to do two things.
对于每个从购物车转移到订单的项目，需要做两件事：
First we set the cart_id to nil in order to prevent the item from going poof when we destroy the cart.
首先，当销毁购物车的时候，将`cart_id`设置为nil，这样可防止项目消失。
<kinder:note> 如果没有设置为nil，则销毁购物车时，商品项目会丢失？为什么？因为在迭代D声明关系的时候已经规定了这个属性。
Then we add the item itself to the line_items collection for the order.
接下来将项目本身添加到订单的line_items集合中。

Notice that we didn’t have to do anything special with the various foreign key fields, such as setting the order_id column in the line item rows to reference the newly created order row.
注意，我们不需要对各种不同的外键做任何特别的事情，比如在商品项目的行中设置`order_id`列以索引新创建的订单列。
Rails does that knitting for us using the has_many() and belongs_to() declarations we added to the Order and LineItem models.
Rails利用我们在Order和LineItem模型添加的`has_many`和`belongs_to`声明来为我们实现这个功能。
Appending each new line item to the line_items collection hands the responsibility for key management over to Rails.
向`line_items`集合中附加的每个新商品项目都会将键管理这个责任交给Rails。

We will also need to modify the test to reflect the new redirect.
我们还需要修改测试来反映这个新的重定向。

       Download rails40/depot_p/test/controllers/orders_controller_test.rb
       test "should create order" do
         assert_difference('Order.count') do
           post :create, order: { address: @order.address, email: @order.email,
             name: @order.name, pay_type: @order.pay_type }
         end
     ➤   assert_redirected_to store_path
       end

• 170

So, as a first test of all of this, hit the Place Order button on the checkout page without filling in any of the form fields.
因此，作为这所有测试中的第一，按下付款页面上的`Place Order`按钮且不填写任何项目。
You should see the checkout page redisplayed along with error messages complaining about the empty fields, as shown in Figure 34, Full house! Every field fails validation., on page 171.
你应该可以看见付款页面上显示了一些有关未填写项目的错误信息，如下面171页图34所示。

If we fill in some data (as shown at the top of Figure 35, Entering order information produces a “Thanks!”, on page 171) and click Place Order , we should get taken back to the catalog, as shown at the bottom of the figure.
如果我们填写了一些数据（如图35上部，键入订单信息，产生一个“谢谢惠顾”的信息），然后单击“Place Order”按钮，我们应该被带回目录页，如图下部所示。
But did it work?
但究竟成功了吗？
Let’s look in the database.
让我们看一下数据库。

     depot> sqlite3 -line db/development.sqlite3
     SQLite version 3.7.4
     Enter ".help" for instructions

     sqlite> select * from orders;
     id = 1
     name = Dave Thomas
     address = 123 Main St
     email = customer@example.com
     pay_type = Check
     created_at = 2013-01-29 02:31:04.964785
     updated_at = 2013-01-29 02:31:04.964785

     sqlite> select * from line_items;
     id = 10
     product_id = 2
     cart_id =
     created_at = 2013-01-29 02:30:26.188914
     updated_at = 2013-01-29 02:31:04.966057
     quantity = 1
     price = 36
     order_id = 1

     sqlite> .quit

Although what you see will differ on details such as version numbers and dates (and price will be present only if you completed the exercises defined in Playtime, on page 132), you should see a single order and one or more line items that match your selections.
虽然你所看见的会因为一些细节而不同，比如版本号和日期（仅当你完成了10.3节中的练习，价格才会显示），你应该可以看见一条订单和一件或多件你选择的商品项目。

#### One Last Ajax Change 最后一个Ajax更改
After we accept an order, we redirect to the index page, displaying the cheery flash message “Thank you for your order.” 
If the user continues to shop and they have JavaScript enabled in their browser, we’ll fill the cart in their sidebar without redrawing the main page.
接收订单之后，我们被重定向到索引页面，上面显示了“谢谢惠顾”的信息。
如果用户继续购物并且启用浏览器上的JavaScript，购物车会被填充到侧边栏中，但不会刷新主页面。
This means the flash message will continue to be displayed. 
这意味着上面那条消息会继续显示。
We’d rather it went away after we add the first item to the cart (as it does when JavaScript is disabled in the browser).
在向购物车中添加了第一个商品项目之后，我们更愿意让这条信息消失（就像禁用浏览器的JavaScript一样）。
Fortunately, the fix is simple:
幸运的是，这个修改很简单：
we just hide the <div> that contains the flash message when we add something to the cart.
当我们向购物车中添加一些东西的时候，将包含消息的<div>隐藏起来。

• 171

Figure 34—Full house! Every field fails validation.

Figure 35—Entering order information produces a “Thanks!”

• 172

     Download rails40/depot_p/app/views/line_items/create.js.erb
     ➤ $('#notice').hide();
     ➤
     if ($('#cart tr').length == 1) { $('#cart').show('blind', 1000); }
     $('#cart').html("<%= escape_javascript render(@cart) %>");
     $('#current_item').css({'background-color':'#88ff88'}).
     animate({'background-color':'#114411'}, 1000);

Note that when we come to the store for the first time, there’s nothing in the flash, so the paragraph with an ID of notice isn’t displayed.
注意如果我们第一次来商店，闪存中没有任何消息，所以不会显示id为notice的段落。
Therefore, there’s no tag with the ID of notice, and the call to jQuery matches no elements.
因此也没有ID为notice的标签，调用jQuery不能匹配任何元素。
This is not a problem, as the call to hide() is applied to each matching element, so nothing happens.
<kinder:note> 这不是个问题，因为hide()调用被应用到每个匹配的元素中，因此什么都没有发生。
This is exactly what we want to happen, so all is well.
<kinder:note> 这就是我们想要的事情，那这样就行了。

Now that we’ve captured the order, it is time to alert the ordering department.
现在我们就已经可以获得订单，是时候通知接收订单的部门了。
We will do that with feeds, specifically, an Atom-formatted feed of orders.
我们会用推送来实现，具体是订单的Atom格式的推送。

## 12.2 Iteration G2: Atom Feeds  Atom推送
Using a standard feed format, such as Atom, means you can immediately take advantage of a wide variety of preexisting clients.
使用一种标准的推送格式，例如Atom，意味着你可以立即利用许多已经存在的客户端。
Because Rails already knows about IDs, dates, and links, it can free you from having to worry about these pesky details and let you focus on producing a human-readable summary.
因为Rails已经知道了id、日期和链接，它可以让你不用再担心那些烦人的细节，并让你专注于生成可读的汇总信息。
We start by adding a new action to the products controller.
第一步是向产品控制器添加一个新的动作。

    Download rails40/depot_p/app/controllers/products_controller.rb
    def who_bought
      @product = Product.find(params[:id])
      @latest_order = @product.orders.order(:updated_at).last
      if stale?(@latest_order)   
      # stale方法应该是rails自己定义的，标准ruby没有此法。
      # 果然。在actionpack/lib/action_controller/metal/conditional_get.rb
      # 参见rails的api。
        respond_to do |format|
          format.atom
        end
      end
    end

In addition to fetching the product, we check to see whether the request is stale.
<kinder:note> 除了取得商品，我们还可以查看到那些请求是否过期。
Remeber in Section 8.5, Iteration C5: Caching of Partial Results, on page 104 when we cached partial results of responses because the catalog display was expected to be a high-traffic area? 
<kinder:note> 记得前面104页8.5节迭代C5缓存片段结果吗？我们缓存了部分响应的结果，因为目录页是个高流量的区域。
Well, feeds are like that, but with a different usage pattern.
<kinder:note> 推送很像缓存，但用法模式不同。
Instead of a large number of different clients all requesting the same page, we have a small number of clients repeatedly requesting the same page.
<kinder:note> 和多个不同客户端请求一个页面不同，这里只有小部分的客户端重复请求相同页面。
If you’re familiar with the idea of browser caches, then the same thing holds true for feed aggregators.
<kinder:note> 如果你熟悉浏览器缓存的原理，那推送聚集器也是一样的。

• 173

---------------------------------
Joe asks: Why Atom?
Joe问：为什么是Atom？
There are a number of different feed formats, most notably RSS 1.0, RSS 2.0, and Atom, standardized in 2000, 2002, and 2005, respectively.
有很多不同的推送格式，最重要的格式为 RSS 1.0, RSS 2.0和Atom，分别于2000、2002、2005年标准化。
These three are all widely supported.
这三种格式得到了最广泛的支持。
To aid with the transition, a number of sites provide multiple feeds for the same site, but this is no longer necessary, increases user confusion, and generally is not recommended.
为了支持事务，许多站点都为相同的页面提供多种推送，但是这种做法已经不是必需的，这只会增加用户的困惑，成、一般不予推荐。

The Ruby language provides a low-level library, which can produce any of these formats, as well as a number of other less common versions of RSS.
Ruby语言提供了一种底层的库，它可以生成这些格式中的任意一种，也支持其他一些不那么常用的RSS版本。
For best results, stick with one of the three main versions.
为了达到最好的效果，建议还是使用上述三种最主要的版本。

The Rails framework is all about picking reasonable defaults and has chosen Atom as the default for feed formats.
Rails框架中总是使用合理的建议，它选择了Atom作为默认的推送格式。
It is specified as an Internet standards–track protocol for the Internet community by the IETF, and Rails provides a higher-level helper named atom_feed that takes care of a number of details based on knowledge of Rails naming conventions for things like IDs and dates.
这种格式是由IETF指定的一种因特网社区的因特网标准-交流协议，Rails提供了一个名为atom_feed的高层帮助方法，它依据Rails的命名习惯（例如id和日期），来帮你处理许多细节。

---------------------------------

The way this works is that the responses contain a bit of metadata that identifies when the content was last modified and a hashed value called an ETag.
<kinder:note> 它运行的方式是，响应包含一些元信息，可以识别内容最后被修改的时间，还有一个散列值，可调用一个ETag。
If a subsequent request provides this data back, this gives the server the opportunity to respond with an empty response body and an indication that the data has not been modified.
<kinder:note> 如果一个并发的请求提供这个数据回来，这会让服务器有机会用一个空的响应主体和一个数据未被修改的提示来响应。

As is usual with Rails, you don’t need to worry about the mechanics.
和Rails的一般使用一样，你不需要担心这个机制。
You just need to identify the source of the content, and Rails will do the rest.
<kinder:note> 只需要确定内容的源，Rails会把剩余的所有东西做好。
In this case, we use the last order.
<kinder:note> 本例中，我们使用最近的订单。
Inside the if statement, we process the request normally.
<kinder:note> 在if语句里面，我们正常处理请求。

By adding format.atom, we cause Rails to look for a template named who_bought.atom.builder.
通过添加format.atom，我们让Rails寻找一个名为who_bought.atom.builder的模板。
Such a template can use the generic XML functionality that Builder provides as well as using the knowledge of the Atom feed format that the atom_feed helper provides.
该模板可以利用Builder提供的通用XML功能，以及atom_feed帮助方法提供的有关Atom推送格式的信息。


    Download rails40/depot_p/app/views/products/who_bought.atom.builder
    atom_feed do |feed|
      feed.title "Who bought #{@product.title}"     # 标题
      feed.updated @latest_order.try(:updated_at)   # 时间。 这个变量@latest_order哪来的？try(:updated_at)又是怎么回事？
      @product.orders.each do |order|               # 遍历订单。product和order的关系在product的模型中定义。具体见下文。
        feed.entry(order) do |entry|                # 遍历商品项目。feed.entry(order)是把order作为feed.entry方法的参数
          entry.title "Order #{order.id}"             # 标题
          entry.summary type: 'xhtml' do |xhtml|      # 摘要。这句话应该是type: 'xhtml'作为summary的参数。
            xhtml.p "Shipped to #{order.address}"     # 地址

• 174

            xhtml.table do                            # 商品表格
              xhtml.tr do                             # 第一行：标题
                xhtml.th 'Product'                    # 产品名称
                xhtml.th 'Quantity'                   # 数量
                xhtml.th 'Total Price'                # 总价格
              end
              order.line_items.each do |item|         # 第二行开始：数据
                xhtml.tr do
                  xhtml.td item.product.title
                  xhtml.td item.quantity
                  xhtml.td number_to_currency item.total_price
                end
              end
              xhtml.tr do                              # 最后一行：总计
                xhtml.th 'total', colspan: 2
                xhtml.th number_to_currency \
                order.line_items.map(&:total_price).sum  
                # 这个map方法需要复习。
              end
            end
            xhtml.p "Paid by #{order.pay_type}"        # 付款类型
          end
          entry.author do |author|                     # 作者？
            author.name order.name
            author.email order.email
          end
        end
      end
    end

More information on Builder can be found in Section 24.1, Generating XML with Builder, on page 393.
更多关于Builder的信息参见后面393页的24.1节。
At the overall feed level, we need to provide only two pieces of information:
在推送的总体层，我们只需要提供两条信息，
the title and the latest updated date. 
标题和最新更新日期。
If there are no orders, the updated_at value will be null, and Rails will supply the current time instead.
如果没有订单，updated_at的值为空，Rails会为此提供当前的时间。
Then we iterate over each order associated with this product.
然后循环遍历与该产品有关的订单。
Note that there is no direct relationship between these two models.
注意，这两种模型之间没有直接的关系。
In fact, the relationship is indirect.
事实上是间接的。
Products have many line_items, and line_items belongs to an order.
每个商品有很多在线项目，而每个在线项目属于一个订单。

We could iterate and traverse, but by simply declaring that there is a relationship between products and orders through the line_items relationship, we can
simplify our code.
通过简单地声明在线项目相关联的产品与订单的关系，我们得以迭代和遍历，简化的代码如下：

     Download rails40/depot_p/app/models/product.rb
     class Product < ActiveRecord::Base
       has_many :line_items
     ➤ has_many :orders, through: :line_items
     #...
     end

• 175

For each order, we provide a title, a summary, and an author.
对于每一个订单都提供标题、摘要和作者。
The summary can be full XHTML, and we use this to produce a table of product titles, quantity ordered, and total prices.
摘要可以是完整的XHTML，利用它可以生成商品名称，数量和总价的表格。
We follow this table with a paragraph containing the pay_type.
该表之后是一个包含`pay_type`的段落。

To make this work, we need to define a route.
要让整个过程得以工作，我们还要定义一条路径。
This action will respond to HTTP GET requests and will operate on a member of the collection (in other words, on an individual product) as opposed to the entire collection itself (which in this case would mean all products).
该动作会响应HTTP GET请求，并操作于集合的一个成员上（换句话说，在一个单一的产品上），而不是整个集合本身（也就是说全部的产品）。

       Download rails40/depot_p/config/routes.rb
       Depot::Application.routes.draw do
         resources :orders
         resources :line_items
         resources :carts
         get "store/index"
     ➤   resources :products do
     ➤     get :who_bought, on: :member
     ➤   end
       # The priority is based upon order of creation:
       # first created -> highest priority.
       # See how all your routes lay out with "rake routes".
       # You can have the root of your site routed with "root"
         root 'store#index', as: 'store'
       # ...
       end

We can try it for ourselves.
让我们来试一下。

    depot> curl --silent http://localhost:3000/products/3/who_bought.atom
    <?xml version="1.0" encoding="UTF-8"?>
    <feed xml:lang="en-US" xmlns="http://www.w3.org/2005/Atom">
      <id>tag:localhost,2005:/products/3/who_bought</id>
      <link type="text/html" href="http://localhost:3000" rel="alternate"/>
      <link type="application/atom+xml"
        href="http://localhost:3000/info/who_bought/3.atom" rel="self"/>
      <title>Who bought Programming Ruby 1.9</title>
      <updated>2013-01-29T02:31:04Z</updated>
      <entry>
        <id>tag:localhost,2005:Order/1</id>
        <published>2013-01-29T02:31:04Z</published>
        <updated>2013-01-29T02:31:04Z</updated>
        <link rel="alternate" type="text/html" href="http://localhost:3000/orders/1"/>
        <title>Order 1</title>
        <summary type="xhtml">
          <div xmlns="http://www.w3.org/1999/xhtml">
            <p>Shipped to 123 Main St</p>


• 176

            <table>
              ...
            </table>
            <p>Paid by check</p>
          </div>
        </summary>
        <author>
          <name>Dave Thomas</name>
          <email>customer@pragprog.com</email>
        </author>
      </entry>
    </feed>

Looks good.
看起来不错。
Now we can subscribe to this in our favorite feed reader.
现在就可以将它订阅到我们最喜欢的推聚合阅读器上了。

Best of all, the customer likes it.
顾客很满意。
We’ve implemented product maintenance, a basic catalog, and a shopping cart, and now we have a simple ordering system.
我们已经实现了产品的维护、基本的目录和购物车，现在又有了一个简单的订单系统。
Obviously we’ll also have to write some kind of fulfillment application, but that can wait for a new iteration.
显然我们还得写一个类似履行的应用，但这要等到一个新的迭代了。
(And that iteration is one that we’ll skip in this book; it doesn’t have much new to say about Rails.)
（本书忽略了这个迭代，因为其中没有介绍任何新的Rails的知识。）


## 12.3 迭代G3： 分页
<kinder:note> 这个部分在本版已经被移动到下面25.3节。
## What We Just Did 本章小结
In a fairly short amount of time, we did the following:
在一个相对短的时间内，我们完成了一下事项：
• We created a form to capture details for the order and linked it to a new order model.
  创建了一个表单用以捕获订单细节，并将它连接到了一个新的订单模型。
• We added validation and used helper methods to display errors to the user.
  添加了验证并使用了帮助方法来向用户显示错误。
• We provided a feed so that the administrator can monitor orders as they come in.
提供了推送服务以便让管理员监视订单。

## Playtime 练习时间
Here’s some stuff to try on your own:
可以自己尝试一下任务：
• Get HTML-, XML-, and JSON-formatted views working for who_bought requests.
  让HTML-， XML-，和JSON-格式的视图可以为who_bought请求工作。
Experiment with including the order information in the XML view by rendering @product.to_xml(include: :orders).
通过呈现@product.to_xml(include: :orders)，实验一下在XML视图中包含订单信息。
Do the same thing for JSON.
用JSON做同样的事情。

<kinder:note> 
Hint: use builder templates for XML.
提示：使用XML的构建模板。
builder的有关资料见：http://api.rubyonrails.org/classes/ActionView/Base.html。

下面的文字来自：https://pragprog.com/wikis/wiki/Pt-G-1

Render XML

Would be helpful to know more about the XML render syntax. 
In this case,

    format.xml { render :xml => @product.to_xml(:include => :orders) }

Seems to suffice with no template….

Render JSON

    format.json {render :json => @product.to_json(:include => :orders)}

Render HTML

    format.html who_bought.html.erb

    <% @product.orders.each do |order| %>
      <h2>Order <%= order.id %></h2>
      <p>Shipped to <%= order.address %></p>
      <table>
        <tr>
          <th>Product</th>
          <th>Quantity</th>
          <th>Total Price</th>
        </tr>
        <% order.line_items.each do |item| %>
          <tr>
            <td><%= item.product.title %></td>
            <td><%= item.quantity %></td>
            <td><%= number_to_currency item.total_price %></td>
          </tr>
        <% end %>
        <tr>
          <th colspan="2">total</th>
          <th><%= number_to_currency order.line_items.map(&:total_price).sum %></th>
        </tr>
      </table>
      <p>Paid by <%= order.pay_type %>
    <% end %>

Research
研究
The Rails API is your friend! 
Rails API是你的朋友。
to_xml() can be passed options that help you to fine-tune the output. 
to_xml()可被传入选项，帮你调好输出。
format.xml { render :xml => @product.to_xml(:include => :orders) } works but does not get you output similar to the atom feed. 
`format.xml { render :xml => @product.to_xml(:include => :orders)}`可以运行，但你的输出就和atom推送不一样了。
To get XML similar to what was in the example atom feed by just using to_xml():
使用to_xml()可获得类似与atom推送那个例子类似的XML。

        format.xml { render( :xml => @product.to_xml(
           :only => [ :title, :updated_at ],
           :skip_types => true,
           :include => { 
              :orders => {
                 :except => [ :created_at, :updated_at ],
                 :skip_types => true,
                 :include => { 
                    :line_items => {
                       :skip_types => true,
                       :except => [ :created_at, :updated_at, :cart_id, :order_id ]
                    }
                 }
              }
           }
        )) }

There’s a link on that same page to using as_json() to generate similar output, using the same options (except :skip_types).
同一页面上有个链接，使用as_json()来产生类似的输出，选项也一样（除了:skip_types）。

• What happens if you click the Checkout button in the sidebar while the checkout screen is already displayed? 
  当已经显示付款界面时，如果你单击侧边栏中的Checkout按钮会发生什么？
Can you find a way to disable the button in this circumstance?
你能在这种情形下找到一种方法来禁用这个按钮吗？

Hint: variables set in the controller are available in layouts and partials as well as in the directly rendered template.
提示：控制器中的变量集合在布局、局部模板和直接呈现的模板都是可用的。

<kinder:note> 答案千奇百怪。见：https://pragprog.com/wikis/wiki/Pt-G-2。

• The list of possible payment types is currently stored as a constant in the Order class.
当前可能的付款方式的列表是以一个常量的形式存储在order类中的。
Can you move this list into a database table? 
你可以把这个列表移动到一个数据库的表中吗？
Can you still make validation work for the field?
你能验证这项功能吗？

Hint: Replace the pay_type string with a pay_type_id in the Orders model, and use `validates_presence_of` to verify that this field is set.
提示： 在Orders模型中用`pay_type_id`替换`pay_type`， 使用`validates_presence_of`来验证这个字段集合。

<kinder:note> 下面是Cliff在https://pragprog.com/wikis/wiki/Pt-G-3上贴出的答案：

Here’s a stab at it. 
Generate a PaymentType model with a single string field.

    rails generate model payment_type name:string

Add the three payment types in seeds.rb, and run rake db:seed.

    PaymentType.create(:name => "Check")
    PaymentType.create(:name => "Credit card")
    PaymentType.create(:name => "Purchase order")

Add a names class method to the PaymentType model.

    class PaymentType < ActiveRecord::Base
      def self.names
        all.collect { |payment_type| payment_type.name }
      end
    end

Change the validation in the Order model. Initially, one might do this:

    validates :pay_type, :inclusion => PaymentType.names

Now I’m a Rails n00b, but as far as I can tell, doing validation that way would fetch the payment types just once from the DB at the moment when Ruby defines the Order model class.
What if the payment types table in the DB is modified after the Order model class has been defined? 
Hence, I rewrote the validation to query the DB for the payment types every time the validation is called (at least, I think I did):

    validates_each :pay_type do |model, attr, value|
      if !PaymentType.names.include?(value)
        model.errors.add(attr, "Payment type not on the list") 
      end
    end

Then, in views/orders/_form.html.erb, replace

    <%= f.select :pay_type, Order::PAYMENT_TYPES,
                 :prompt => 'Select a payment method' %>

with

    <%= f.select :pay_type, PaymentType.names,
                 :prompt => 'Select a payment method' %>

Wham bam.
Added some unit and functional tests too.
Works fine.
I’m not super satisfied with the messy-looking validates_each block, though.
Anyone with a more elegant validation?
<kinder:note>个人认为这还可改进，应该增加付款列表，把付款方式和订单关联起来。 



(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)


# CHAPTER 13 Task H: Sending Mail  发送电子邮件
## In this chapter, we’ll see
• sending email and
• integration testing.

At this point, we have a website that will respond to requests and will provide feeds that allow sales of individual titles to be checked periodically.
At times it makes sense to have something more than that.
For those times, what we need is the ability to actively target a message to somebody specific when an event occurs.
It could be wanting to notify a system administrator when an exception occurs.
It could be a user feedback form.
In this chapter, we will opt to simply send confirmation emails to people who have placed orders.

Once we complete that, we will create tests not only for the mail support that we just added but for the entire user scenario we have created so far.

## 13.1 Iteration H1: Sending Confirmation Emails  发送确认邮件
There are three basic parts to sending email in Rails: 
在Rails中发送邮件有三个基本的步骤：
configuring how email is to be sent, determining when to send the email, and specifying what you want to say.
配置如何发送邮件，确定何时发送，以及指定要写的内容。
We will cover each of these three in turn.
下面按顺序介绍这三步。

### 13.1.1 Email Configuration  邮件配置
Email configuration is part of a Rails application’s environment and involves a Depot::Application.configure block.
配置邮件是Rails应用程序环境的一部分，它要用到`Depot::Application.configure`代码块。
If you want to use the same configuration for development, testing, and production, add the configuration to environment.rb in the config directory; otherwise, add different configurations to the appropriate files in the config/environments directory.
如果想要在开发、测试和生产中使用相同的配置，可以在config目录下的environment.rb中添加这个配置；否则，在config/environments目录下相应的文件中添加不同的配置。

Inside the block, you will need to have one or more statements.
在代码块内部需要一个或多个语句。
You first have to decide how you want mail delivered.
首先要决定如何递送邮件。

    config.action_mailer.delivery_method = :smtp

Alternatives to :smtp include :sendmail and :test.
替代:smtp的选项包括:sendmail和:test。

• 178 

The :smtp and :sendmail options are used when you want Action Mailer to attempt to deliver email.
当想要用Action Mailer来尝试发送邮件时，使用选项:smtp和:sendmail。
You’ll clearly want to use one of these methods in production.
在产品环境上，你肯定需要用到其中的方法。

The :test setting is great for unit and functional testing, which we will make use of in Testing Email, on page 183.
:test设置对单元和功能测试非常有用，我们会在后面183页介绍。
Email will not be delivered; instead, it will be appended to an array (accessible via the attribute ActionMailer::Base.deliveries).
使用该选项时邮件实际上不会被发送，而是添加到一个数组中（该数组可通过属性ActionMailer:Base.deliveries访问）。
This is the default delivery method in the test environment.
在测试环境中，这是默认的发送函数。
Interestingly, though, the default in development mode is :smtp.
有意思的是，在开发模式下默认的是:smtp。
If you want Rails to deliver email during the development of your application, this is good.
如果想要Rails在应用程序开发过程中发送邮件，这样做非常好。
If you’d rather disable email delivery in development mode, edit the file development.rb in the directory config/environments, and add the following lines:
如果你更愿意在开发模式下禁用邮件发送，编辑config/environments/development.rb文件，添加如下几行：

    Depot::Application.configure do
      config.action_mailer.delivery_method = :test
    end

The :sendmail setting delegates mail delivery to your local system’s sendmail program, which is assumed to be in /usr/sbin.
:sendmail设置将邮件发送委托给本地系统下的sendmail程序，并假定它在目录/usr/sbin中。
This delivery mechanism is not particularly portable, because sendmail is not always installed in this directory on different operating systems.
这种发送机制可移植性差，因为在不同的操作系统下sendmail不总是在该目录下。
It also relies on your local sendmail supporting the -i and -t command options.
另外，它还取决于本地sendmail对命令行选项-i和-t的支持。

You achieve more portability by leaving this option at its default value of :smtp.
通过让该选项保持它默认的:smtp值，可以达到更好的可移植性。
If you do so, you’ll need also to specify some additional configuration to tell Action Mailer where to find an SMTP server to handle your outgoing email.
如果这样做，还需要指定另外一些配置，告诉Action Mailer在哪里可以找到SMTP服务器。
This may be the machine running your web application, or it may be a separate box (perhaps at your ISP if you’re running Rails in a noncorporate environment).
它可以是运行Web应用的机器，也可以是一个单独的机器（如果Rails在托管环境下运行的话，它或许就在互联网服务提供商那儿）。
Your system administrator will be able to give you the settings for these parameters.
系统管理员可以告诉你如何设置这些参数。
You may also be able to determine them from your own mail client’s configuration.
或许也可以通过自己的邮件客户端配置来确定这些参数。

The following are typical settings for Gmail.
下面是Gmail的典型设置。
Adapt them as you need.
请根据需要作出相应的修改。

    Depot::Application.configure do
      config.action_mailer.delivery_method = :smtp
      config.action_mailer.smtp_settings = {
        address: "smtp.gmail.com",           # 'smtp.sina.cn',
        port: 587,                           # 25,
        domain: "domain.of.sender.net",      # 'sina.cn',
        authentication: "plain",             # :login
        user_name: "dave",                   # 
        password: "secret",                  # 
        enable_starttls_auto: true
      }
    end

• 179

As with all configuration changes, you’ll need to restart your application if you make changes to any of the environment files.
当所有配置更改完成之后，如果对环境文件做了修改，需要重启应用程序。

### 13.1.2 Sending Email  发送邮件
Now that we have everything configured, let’s write some code to send emails.
所有配置已经做好，现在来实现发送邮件。
By now you shouldn’t be surprised that Rails has a generator script to create mailers.
到现在为止，你不应该对Rails中生成脚本来创建mailer感到惊讶，应该惊讶在哪里创建它们。
In Rails, a mailer is a class that’s stored in the app/mailers directory.
在Rails中，mailer是存放在目录app/mailers下的一个类。
It contains one or more methods, with each method corresponding to an email template.
它包含一个或多个方法，每个方法对应一个邮件模板。
To create the body of the email, these methods in turn use views (in just the same way that controller actions use views to create HTML and XML).
这些方法依次使用视图来创建邮件主体（与控制器行为使用视图来创建HTML和XML的方式相同）。
So, let’s create a mailer for our store application.
那么，让我们开始为商店应用创建一个mailer。
We’ll use it to send two different types of email: one when an order is placed and a second when the order ships.
它用来发送两种不同的邮件，一种是当订单下达的时候，另一种是当订单发货的时候。
The rails generate mailer command takes the name of the mailer class, along with the names of the email action methods.
`rails generate mailer`命令以mailer类的名字和邮件行为方法的名字作为参数。

    depot> rails generate mailer OrderNotifier received shipped
      create app/mailers/order_notifier.rb
      invoke erb
      create
      app/views/order_notifier
      create
      app/views/order_notifier/received.text.erb
      app/views/order_notifier/shipped.text.erb
      create
      invoke test_unit
      create
      test/mailers/order_notifier_test.rb
  
Notice that we’ve created an OrderNotifier class in app/mailers and two template files, one for each email type, in app/views/order_notifier.
注意，在app/mailers下创建一个OrderNotifier类，在app/views/order_notifier里创建两个模板文件，分别对应两种不同的邮件类型。
(We also created a test file—we’ll look into this in Testing Email, on page 183.)
（我们还创建了一个测试文件--将在本节后面内容中详细介绍）。

Each method in the mailer class is responsible for setting up the environment for sending a particular email.
在mailer类中的每个方法都负责为发送特定邮件设置环境。
Let’s look at an example before going into the details.
在深入介绍细节之前，先来看一个例子。
Here’s the code that was generated for our OrderNotifier class, with one default changed:
下面是一些为OrderNotifier类所生成的代码，更改了一个默认项目。

    Download rails40/depot_q/app/mailers/order_notifier.rb
    class OrderNotifier < ActionMailer::Base
    ➤ default from: 'Sam Ruby <depot@example.com>'
      # Subject can be set in your I18n file at config/locales/en.yml
      # with the following lookup:
      #
      #
      en.order_notifier.received.subject
      #
      def received
        @greeting = "Hi"
        mail to: "to@example.org"
      end

• 180

      # Subject can be set in your I18n file at config/locales/en.yml
      # with the following lookup:
      #
      # en.order_notifier.shipped.subject
      #
      def shipped
        @greeting = "Hi"
        mail to: "to@example.org"
      end
    
    end

If you are thinking to yourself that this looks like a controller, it is because it very much does.
你可能认为这很像一个控制器，其实它就是一个控制器。
There is one method per action.
每个行为都有一个方法。
Instead of a call to render(), there is a call to mail().
但与调用render()不同的是，这里调用的是mail()。
Mail accepts a number of parameters including :to (as shown), :cc, :from, and :subject, each of which does pretty much what you would expect them to do.
mail接受一系列参数，包括:to（如上所示）、:cc、:from和:subject，每个参数的作用都如其字面上的意思。
Values that are common to all mail calls in the mailer can be set as defaults by simply calling default, as is done for :from at the top of this class.
在mailer中所有mail调用的共同的值可以通过调用default来设置，就像此类上的:from所做的那样。
Feel free to tailor this to your needs.
尽管按照需要修改这些设置。

The comments in this class also indicate that subject lines are already enabled for translation, a subject we cover in Chapter 15, Task J: Internationalization, on page 211.
此类中的注释页指明主题行已经启用了翻译，有关该主题会在后面211页的15章讲到。
For now, we will simply use the :subject parameter.
现在，我们简单地使用:subject参数。

As with controllers, templates contain the text to be sent, and controllers and mailers can provide values to be inserted into those templates via instance variables.
就像控制器一行，模板包含了待发送的文本，并且控制器和mailer可以通过实例变量来提供在那些模板中插入的值。

### 13.1.3 Email Templates 邮件模板
The generate script created two email templates in app/views/order_notifier, one for each action in the Notifier class.
生成脚本在app/views/order_notifier中创建了两个邮件模板，每个都对应着Notifier类中的动作。
These are regular .erb files.
它们是普通的.erb文件。
We’ll use them to create plain-text emails (we’ll see later how to create HTML email).
我们将使用它们来创建纯文本格式额邮件（之后会介绍如何创建HTML格式的邮件）。
As with the templates we use to create our application’s web pages, the files contain a combination of static text and dynamic content.
就像那些用来创建应用程序页面的模板一样，这些文件包括了静态文字和动态内容的组合。
We can customize the template in received.text.erb; this is the email that is sent to confirm an order:
在received.text.erb中可以定制该模板，下面是用来确认订单的邮件：

    Download rails40/depot_q/app/views/order_notifier/received.text.erb
    Dear <%= @order.name %>
    Thank you for your recent order from The Pragmatic Store.
    You ordered the following items:
    <%= render @order.line_items =%>    # <kinder:note>将调用下面的局部模板。
    We'll send you a separate e-mail when your order ships.

• 181

The partial template that renders a line item formats a single line with the item quantity and the title.
呈现商品的局部模板用商品的数量和名字格式化了一行。
Because we’re in a template, all the regular helper methods, such as truncate(), are available.
由于处于模板之内，所有的普通帮助方法，如truncate()，都是可用的。

    Download rails40/depot_q/app/views/line_items/_line_item.text.erb
    <%= sprintf("%2d x %s", line_item.quantity, truncate(line_item.product.title, length: 50)) %>

We now have to go back and fill in the received() method in the OrderNotifier class.
现在必须回到OrderNotifier类中填入received()方法所需的数据。

    Download rails40/depot_r/app/mailers/order_notifier.rb
    def received(order)
      @order = order
      mail to: order.email, subject: 'Pragmatic Store Order Confirmation'
    end

What we did here is add order as an argument to the method-received call, add code to copy the parameter passed into an instance variable, and update the call to mail() specifying where to send the email and what subject line to use.
在这里，向received方法的调用添加了order参数，增加了拷贝传给实例变量的参数的代码，并更新mail调用，该调用指定发送邮件的目标和使用的邮件主题。

### 13.1.4 Generating Emails 生成邮件
Now that we have our template set up and our mailer method defined, we can use them in our regular controllers to create and/or send emails.
设置好模板并定义了mailer方法之后，就可以在普通的控制器中使用它们来创建或发送邮件了。

    Download rails40/depot_r/app/controllers/orders_controller.rb
    def create
      @order = Order.new(order_params)
      @order.add_line_items_from_cart(@cart)
      respond_to do |format|
        if @order.save
          Cart.destroy(session[:cart_id])
          session[:cart_id] = nil
        ➤ OrderNotifier.received(@order).deliver   # deliver应该是一个已经定义在rails邮件系统里的一个方法。
          format.html { redirect_to store_url, notice: 'Thank you for your order.' }
          format.json { render action: 'show', status: :created, location: @order }
        else
          format.html { render action: 'new' }
          format.json { render json: @order.errors, status: :unprocessable_entity }
        end
      end
    end


And we need to update shipped() just like we did for received().
我们需要更新shipped()，就像对received()所做的那样：
<kinder:note> 当然这个发货提醒需要放在出货系统中。出货系统在哪里？本书没有介绍，按照本书的思路，自己做一个吧。

• 182

    Download rails40/depot_r/app/mailers/order_notifier.rb
    def shipped(order)
      @order = order
      mail to: order.email, subject: 'Pragmatic Store Order Shipped'
    end

At this point, we have enough of the basics in place that you can place an order and have a plain email sent to yourself, presuming that you didn’t disable the sending of email in development mode.
至此，所有基本的设置已就绪，若没有禁用开发模式下发送邮件的功能，你可以下一个订单，一封简单的邮件就会发送给自己。
Now let’s spice up the email with a bit of formatting.
现在来给邮件添加一些格式。

### 13.1.5 Delivering Multiple Content Types 发送多内容类型
Some people prefer to receive email in plain-text format, while others like the look of an HTML email.
一些人喜欢接收纯文本格式的邮件，而另一些人更偏好看起来像HTML的邮件。
Rails makes it easy to send email messages that contain alternative content formats, allowing the user (or their email client) to decide what they’d prefer to view.
Rails使得发送可选内容格式的邮件变得简单，它让用户（或是它们的邮件客户端）来决定自己喜欢的视图。

In the preceding section, we created a plain-text email.
在本节前面的内容中，我们创建了纯文本格式的邮件。
The view file for our received action was called received.text.erb.
receive动作的视图文件是received.text.erb。
This is the standard Rails naming convention.
这是标准的Rails的命名习惯。
We can also create HTML-formatted emails.
按照同样的方式可以创建HTML格式的邮件。

Let’s try this with the order-shipped notification.
让我们用订单发货提醒来试试。
We don’t need to modify any code; we simply need to create a new template.
不需要修改任何代码，只需简单地创建一个新的模板。

    Download rails40/depot_r/app/views/order_notifier/shipped.html.erb
    <h3>Pragmatic Order Shipped</h3>
    <p>
      This is just to let you know that we've shipped your recent order:
    </p>
    <table>
      <tr><th colspan="2">Qty</th><th>Description</th></tr>
      <%= render @order.line_items %>
    </table>

We don’t even need to modify the partial because the existing one we already have will do just fine.
我们甚至不需要修改局部模板，因为已有的那个就足够了。

    Download rails40/depot_r/app/views/line_items/_line_item.html.erb
    <% if line_item == @current_item %>
      <tr id="current_item">
    <% else %>
      <tr>
    <% end %>
        <td><%= line_item.quantity %>&times;</td>
        <td><%= line_item.product.title %></td>
        <td class="item_price"><%= number_to_currency(line_item.total_price) %></td>
      </tr>

• 183

But, for email templates, there’s a little bit more naming magic.
但是，对于邮件模板，有个小的命名技巧。
If you create multiple templates with the same name but with different content types embedded in their filenames, Rails will send all of them in one email, arranging the content so that the email client will be able to distinguish each.
如果你用相同的名字创建了多个模板，但是在名字中嵌入了不同的内容类型，Rails会在一封邮件中将它们全部发送，在此邮件中内容会以邮件客户端可以将它们分辨的方式来安排。
This means you will want to either update or delete the plain-text template that Rails provided for the shipped notifier.
这意味着，要么更新，要么删除由Rails提供给shipped的用于提醒的纯文本模板。

### 13.1.6 Testing Email 邮件功能测试
When we used the generate script to create our order mailer, it automatically constructed a corresponding order_notifier_test.rb file in the application’s test/mailers directory.
当我们使用生成脚本来创建订单mailer的时候，该脚本自动在应用程序的test/functional文件夹中构建了一个相应的order_notifier_test.rb文件。
It is pretty straightforward; it simply calls each action and verifies selected portions of the email produced.
该文件直截了当，它调用每个动作并验证生成邮件的选定部分。
As we have tailored the email, let’s update the test case to match.
因为已经调整了邮件，为了匹配，让我们更新这个测试用例：

    Download rails40/depot_r/test/mailers/order_notifier_test.rb
    require 'test_helper'
    class OrderNotifierTest < ActionMailer::TestCase
      test "received" do
    ➤   mail = OrderNotifier.received(orders(:one))                        
    ➤   assert_equal "Pragmatic Store Order Confirmation", mail.subject    
    ➤   assert_equal ["dave@example.org"], mail.to                         
    ➤   assert_equal ["depot@example.com"], mail.from                      
    ➤   assert_match /1 x Programming Ruby 1.9/, mail.body.encoded         
      end
      test "shipped" do                                                    
    ➤   mail = OrderNotifier.shipped(orders(:one))                         
    ➤   assert_equal "Pragmatic Store Order Shipped", mail.subject         
    ➤   assert_equal ["dave@example.org"], mail.to                         
    ➤   assert_equal ["depot@example.com"], mail.from                      
    ➤   assert_match /<td>1&times;<\/td>\s*<td>Programming Ruby 1.9<\/td>/,
    ➤     mail.body.encoded
      end                                                                    
    end                                                                      

The test method instructs the mail class to create (but not to send) an email, and we use assertions to verify that the dynamic content is what we expect.
该测试方法直到mail类创建（但不发送）一封邮件，并且使用了断言来验证该动态内容是我们期望的。
 Note the use of assert_match() to validate just part of the body content.
注意使用assert_match()来验证部分邮件正文内容的用户。
Your results may differ depending on how you tailored the default :from line in your Notifier.
实际的结果可能因Notifier中default:from的裁剪方式的不同而不同。

At this point, we have verified that the message we intend to create is formatted correctly, but we haven’t verified that it is sent when the customer completes the ordering process.
至此，已经验证了消息的格式是正确的，但还没有验证当顾客完成了整个订单过程之后，它会被发送。
For that, we employ integration tests.
对此，我们要部署集成测试。

• 184

=============================== ===============================
Joe asks: Can I Also Receive Email?
Joe问：我也可以接收电子邮件吗？
Action Mailer makes it easy to write Rails applications that handle incoming email.
Action Mailer让实现处理接收邮件的Rails程序变得简单。
Unfortunately, you need to find a way to retrieve appropriate emails from your server environment and inject them into the application; this requires a bit more work.
遗憾的是，你需要找到一种方法来从服务器环境中得到相应的邮件，并将它们注入应用程序中;这需要做一点工作。

The easy part is handling an email within your application.
简单的部分是在应用程序内部处理邮件。
In your Action Mailer class, write an instance method called receive() that takes a single parameter.
在Action Mailer类中，实现一个叫做receive的实例方法，让它接受单一参数。
This parameter will be a Mail::Message object corresponding to the incoming email.
该参数是一个对应来见的Mail::Message对象。
You can extract fields, the body text, and/or attachments and use them in your application.
你可以提示出相应的字段，正文和/或福建，在应用程序中使用它们。
 All the normal techniques for intercepting incoming email end up running a command, passing that command the content of the email as standard input.
大凡截取接收邮件的技术都归结为运行一条命令，该命令可以传入邮件的内容作为标准输入。
If we make the Rails runner script the command that’s invoked whenever an email arrives, we can arrange to pass that email into our application’s email-handling code.
如果让Rails的runner脚本作为每次邮件到达后调用的命令，便可将该邮件传入到应用程序的邮件处理代码中。
For example, using procmail-based interception, we could write a rule that looks something like the example that follows.
例如，利用基于procmail的拦截，可以写一条如下所示的规则。
Using the arcane syntax of procmail, this rule copies any incoming email whose subject line contains Bug Report through our runner script:
借助procmail的神秘语法，这条规则拷贝所有主题行包含“Bug Report”的来件到runner脚本：

    RUBY=/opt/local/bin/ruby
    TICKET_APP_DIR=/Users/dave/Work/depot
    HANDLER='IncomingTicketHandler.receive(STDIN.read)'
    :0 c
    * ^Subject:.*Bug Report.*
    | cd $TICKET_APP_DIR && $RUBY bin/rails runner $HANDLER

The receive() class method is available to all Action Mailer classes.
receive()类方法对所有Action Mailer类都是可用的。
It takes the email text, parses it into a Mail object, creates a new instance of the receiver’s class, and passes the Mail object to the receive() instance method in that class.
它接收邮件文本，将它解析为一个Tmail对象，创建一个receiver类的实例，并将Mail对象传入receive类的receive实例方法中。

=============================== ===============================

## 13.2 Iteration H2: Integration Testing of Applications 应用程序的集成测试
Rails organizes tests into model, controller, and integration tests.
Rails将测试分为模型测试、控制器测试和集成测试。
Before explaining integration tests, let’s briefly recap what we have covered so far.
在解释集成测试之前，简单地来回顾一下到目前为止我们所讲的内容。
### 13.2.1 Unit testing of models 模型的单元测试
Model classes contain business logic.
模型类包含了业务逻辑。
For example, when we add a product to a cart, the cart model class checks to see whether that product is already in the cart’s list of items.
例如，当向购物车中添加了一个产品，购物车模型类检查该产品是否已经存在于购物车中。
If so, it increments the quantity of that item; if not, it adds a new item for that product.
如果是，那么就增加该项的数量；否则为该产品新增一项。

### 13.2.2 Functional testing of controllers 控制器的功能测试
Controllers direct the show.
控制器导演整个过程。
They receive incoming web requests (typically user input), interact with models to gather application state, and then respond by causing the appropriate view to display something to the user.
它们接收进入的网络请求（通常是用户输入），与模型交互以获取应用程序状态，并且以向用户显示相应的视图来响应请求。
So when we’re testing controllers, we’re making sure that a given request is answered with an appropriate response.
所以当测试控制器时，必须确保一个给定的请求得到适当响应。
We still need models, but we already have them covered with unit tests.
我们仍然需要模型，但 它们已经有了单元测试。

• 185

The next level of testing is to exercise the flow through our application.
测试的下一个层次是检查应用程序的流程。
In many ways, this is like testing one of the stories that our customer gave us when we first started to code the application.
很多时候，这像是测试刚开始编写应用成时顾客告诉我们的场景一样。
For example, we might have been told the following:
例如，我们被告知了如下情形：
A user goes to the store index page.
用户浏览商店的索引页面。
They select a product, adding it to their cart.
他选择了一个产品，添加到购物车中。
They then check out, filling in their details on the checkout form.
然后付款，在付款表单中填写细节。
When they submit, an order is created in the database containing their information, along with a single line item corresponding to the product they added to their cart.
当他们提交之后，在数据库中就创建了一个订单，其中包含他的信息和购物车中产品的项目。
Once the order has been received, an email is sent confirming their purchase.
一旦订单被接收，发送邮件确认购买。

This is ideal material for an integration test.
这就是一个集成测试的完美材料。
Integration tests simulate a continuous session between one or more virtual users and our application.
集成测试模拟了一个或多个虚拟用户和应用程序之间的连续会话。
You can use them to send in requests, monitor responses, follow redirects, and so on.
你可以使用它们来发送请求、监视响应、跟踪重定向等等。

When you create a model or controller, Rails creates the corresponding unit or functional tests.
当创建了一个模型或控制器时，Rails相应地创建了单元或功能测试。
Integration tests are not automatically created, however, but you can use a generator to create one.
虽然集成测试不会被自动生成，但可以用一个生成器来创建它。

    depot> rails generate integration_test user_stories
    invoke test_unit
    create
    test/integration/user_stories_test.rb

Notice that Rails automatically adds `_test` to the name of the test.
注意，Rails自动添加`_test`到测试名中。
Let’s look at the generated file.
让我们看一下生成的文件。

    require 'test_helper'
    class UserStoriesTest < ActionDispatch::IntegrationTest
      # test "the truth" do
      #   assert true
      # end
    end

Let’s launch straight in and implement the test of our story.
让我们开始实现情景测试。
Because we’ll be testing only the purchase of a product, we’ll need only our products fixture.
因为只需测试购买产品，所以只需产品的静态测试。
So, instead of loading all the fixtures, let’s load only this one:
所以，只需要导入这个夹具，不需要导入所有的静态测试。

    fixtures :products

Now let’s build a test named buying a product.
现在让我们写一个称为buying a product的测试。
By the end of the test, we know we’ll want to have added an order to the orders table and a line item to the line_items table, so let’s empty them out before we start.
在测试的末尾，我们想要在orders表中添加一个订单，并且在`line_items`表中添加一个产品项目，因此在开始之前先清空它们。
And, because we’ll be using the Ruby book fixture data a lot, let’s load it into a local variable.
并且由于要经常使用ruby book静态测试数据，让我们将其载入到一个本地变量中。

• 186

    Download rails40/depot_r/test/integration/user_stories_test.rb
    LineItem.delete_all
    Order.delete_all
    ruby_book = products(:ruby)

Let’s attack the first sentence in the user story: A user goes to the store index page.
首先实现情景中的第一句话，用户浏览商店的索引页面。

    Download rails40/depot_r/test/integration/user_stories_test.rb
    get "/"
    assert_response :success
    assert_template "index"

This almost looks like a functional test.
这看起来非常像一个功能测试。
The main difference is the get method.
最主要的差别是get方法。
In a functional test, we check just one controller, so we specify just an action when calling get().
在功能测试中，我们只检查一个控制器，因此，当调用get的时候只需指定一个动作。
In an integration test, however, we can wander all over the application, so we need to pass in a full (relative) URL for the controller and action to be invoked.
但在集成测试中，我们可以在整个应用程序中活动，所以需要为控制器和被调用的动作传递一个完整（相对）的URL。

The next sentence in the story goes They select a product, adding it to their cart.
情景中的下一句是：他选择了一个产品，添加到购物车中。
We know that our application uses an Ajax request to add things to the cart, so we’ll use the xml_http_request() method to invoke the action.
我们直到应用程序使用一个Ajax请求来将物品添加到购物车中，因此让我们使用xml_http_request方法来调用这个动作。
When it returns, we’ll check that the cart now contains the requested product.
当它返回时，要检查购物车中包含有被请求的产品。

    Download rails40/depot_r/test/integration/user_stories_test.rb
    xml_http_request :post, '/line_items', product_id: ruby_book.id
    
    assert_response :success
    cart = Cart.find(session[:cart_id])
    assert_equal 1, cart.line_items.size
    assert_equal ruby_book, cart.line_items[0].product

In a thrilling plot twist, the user story continues: They then check out….
继续下一个步骤，然后付款……
That’s easy in our test.
在测试中这非常简单。

    Download rails40/depot_r/test/integration/user_stories_test.rb
    get "/orders/new"
    assert_response :success
    assert_template "new"

At this point, the user has to fill in their details on the checkout form.
当前，用户必须在付款表单中填写它们的细节。
Once they do and they post the data, our application creates the order and redirects to the index page.
一旦完成并发送了数据，应用程序便会创建该订单并重定向到索引页面。
Let’s start with the HTTP side of the world by posting the form data to the save_order action and verifying we’ve been redirected to the index.
让我们从HTTP端的发送表单数据到save_order动作和验证被重定向到索引页面开始。
We’ll also check that the cart is now empty.
还需检查购物车是否为空。
The test helper method post_via_redirect() generates the post request and then follows any redirects returned until a nonredirect response is returned.
测试辅助方法post_via_redirect生成post请求，然后跟随所有返回的重定向，直到返回非重定向响应。

• 187

    Download rails40/depot_r/test/integration/user_stories_test.rb
    post_via_redirect "/orders", order: { 
      name: "Dave Thomas",
      address: "123 The Street",
      email: "dave@example.com",
      pay_type: "Check" 
    }
    assert_response :success
    assert_template "index"
    cart = Cart.find(session[:cart_id])
    assert_equal 0, cart.line_items.size

Next, we’ll wander into the database and make sure we’ve created an order and corresponding line item and that the details they contain are correct.
接着，到数据库中，保证订单和相应的商品项目已经创建，并且它们的细节都是正确的。
Because we cleared out the orders table at the start of the test, we’ll simply verify that it now contains just our new order.
因为orders表在测试开始 的时候已经清空，此时只需验证它只包含这个新的订单。

    Download rails40/depot_r/test/integration/user_stories_test.rb
    orders = Order.all
    assert_equal 1, orders.size
    order = orders[0]
    assert_equal  "Dave Thomas",       order.name
    assert_equal  "123 The Street",    order.address
    assert_equal  "dave@example.com",  order.email
    assert_equal  "Check",             order.pay_type
    
    assert_equal 1, order.line_items.size
    line_item = order.line_items[0]
    assert_equal ruby_book, line_item.product

Finally, we’ll verify that the mail itself is correctly addressed and has the expected subject line.
最后，验证邮件本身的地址和主题行是正确的。

    Download rails40/depot_r/test/integration/user_stories_test.rb
    mail = ActionMailer::Base.deliveries.last
    assert_equal ["dave@example.com"], mail.to
    assert_equal 'Sam Ruby <depot@example.com>', mail[:from].value
    assert_equal "Pragmatic Store Order Confirmation", mail.subject

And that’s it.
这就是全部了。
Here’s the full source of the integration test:
以下是集成测试的完整源代码。

    Download rails40/depot_r/test/integration/user_stories_test.rb
    require 'test_helper'
    class UserStoriesTest < ActionDispatch::IntegrationTest
      fixtures :products
      # A user goes to the index page. They select a product, adding it to their
      # cart, and check out, filling in their details on the checkout form. When
      # they submit, an order is created containing their information, along with a
      # single line item corresponding to the product they added to their cart.
    
    • 188
    
      test "buying a product" do
        LineItem.delete_all
        Order.delete_all
        ruby_book = products(:ruby)
    
        get "/"
        assert_response :success
        assert_template "index"
        xml_http_request :post, '/line_items', product_id: ruby_book.id
        assert_response :success
        cart = Cart.find(session[:cart_id])
        assert_equal 1, cart.line_items.size
        assert_equal ruby_book, cart.line_items[0].product
    
        get "/orders/new"
        assert_response :success
        assert_template "new"
        post_via_redirect "/orders", order: { 
          name:       "Dave Thomas",
          address:    "123 The Street",
          email:      "dave@example.com",
          pay_type:   "Check" 
        }
        assert_response :success
        assert_template "index"
        cart = Cart.find(session[:cart_id])
        assert_equal 0, cart.line_items.size
        orders = Order.all
        assert_equal 1, orders.size
        order = orders[0]
        assert_equal "Dave Thomas",       order.name
        assert_equal "123 The Street",    order.address
        assert_equal "dave@example.com",  order.email
        assert_equal "Check",             order.pay_type
        assert_equal 1, order.line_items.size
        line_item = order.line_items[0]
        assert_equal ruby_book, line_item.product
        mail = ActionMailer::Base.deliveries.last
        assert_equal ["dave@example.com"], mail.to
        assert_equal 'Sam Ruby <depot@example.com>', mail[:from].value
        assert_equal "Pragmatic Store Order Confirmation", mail.subject
      end
    end

• 189

Taken together, unit, functional, and integration tests give you the flexibility to test aspects of your application either in isolation or in combination with each other.
综上，单元测试、功能 测试和集成测试在测试应用程序的各个方面显示出了足够的灵活性，可以独立使用，也可以与其他方法结合在一起进行测试。
In Section 25.4, Finding More at RailsPlugins.org, on page 418, we will tell you where you can find add-ons that take this to the next level and allow you to write plain-text descriptions of behaviors that can be read by your customer and be verified automatically.
25.4节会介绍哪里可以找到插件，它们可以让测试工作到达一个新的层次，且允许书写纯文本格式的行为描述， 这既可以让顾客读懂，又可以由系统自动验证。

Speaking of our customer, it is time to wrap up this iteration and see what functionality is next in store for Depot.
说到顾客，是时候对这个迭代进行总结并看看商店中的Depot的新功能。


## What We Just Did 本章小结
Without much code and with just a few templates, we have managed to pull off the following:
通过不多的代码和一些模板，我们做到了以下几点，
• We configured our development, test, and production environments for our Rails application to enable the sending of outbound emails.
为了让Rails应用程序可以向外发送电子邮件，需要配置开发、测试和生产环境。

• We created and tailored a mailer that will send confirmation emails in both plain-text and HTML formats to people who order our products.
创建并修改了一个mailer，可以向预定我们产品的用户发送纯文本格式和HTML格式的确认邮件。

• We created both a functional test for the emails produced and an integration test that covers the entire order scenario.
为生成的电子邮件创建功能测试，并且为整个下订单过程覆盖集成测试。

## Playtime 练习时间
Here’s some stuff to try on your own:
可以自己尝试以下任务：

• Add a ship_date column to the orders table, and send a notification when this value is updated by the OrdersController.
在订单表中添加一个ship_date列，当OrdersController更新该值时，将发送一个提醒
<kinder:note> 下面是论坛的答案：
Mark attempted:

Add ship_date (rails migrate add_ship_date_to_order)

class AddShipDateToOrder < ActiveRecord::Migration
  def self.up
    add_column :orders, :ship_date, :datetime
  end

  def self.down
    remove_column :orders, :ship_date   
  end
end

make it so rake db:migrate
Add Notifier call after updated, if ship_date set

  def update
    @order = Order.find(params[:id])

    respond_to do |format|
      if @order.update_attributes(params[:order])
        Notifier.order_shipped(@order).deliver unless @order.ship_date.nil?
        format.html { redirect_to(@order, :notice => 'Order was successfully updated.') }
        format.xml { head :ok }
      else
        format.html { render :action => "edit" }
        format.xml { render :xml => @order.errors, :status => :unprocessable_entity }
      end
    end
  end

Note: This is a literal interpretation of the requirement. Seems it could be improved by make sure that not only is the ship_date no nil, but changed from before.

ok32 guessed:
I think it can be done this way:


 def update
  @order = Order.find(params[:id])
  @order.attributes = params[:order]

  ship_date_changed = @order.ship_date_changed?

  respond_to do |format|
    if @order.save
      OrderNotifier.shipped(@order).deliver if ship_date_changed

      format.html { redirect_to @order, :notice => 'Order was successfully updated.' }
      format.json { head :ok }
    else
      format.html { render :action => "edit" }
      format.json { render :json => @order.errors, :status => :unprocessable_entity }
    end
  end
end

Tom answered:

I managed to send an email when the shipping value had updated, however I wanted to extend beyond this and send a separate email if the shipping value was changed again.

I decided in the end it was best to perform all the actions within the model
Order.rb:


  after_update :send_new_ship_email, :if => :ship_date_changed? && :no_ship_date
  after_update :send_changed_ship_email, :if => :ship_date_changed? && :ship_date_was

  def no_ship_date
    self.ship_date_was.nil?
  end

  def send_new_ship_email
    Notifier.order_shipped(self).deliver
  end

  def send_changed_ship_email
    Notifier.changed_shipping(self).deliver
  end

</kinder:note> 
<kinder:note> 个人思考
添加发货单
$ rails g scaffold Ship order:references send_date:date sender express_company express_number is_receive:boolean
修改 db/migrate/20150111143605_create_ships.rb
      t.boolean :is_receive, default: :false

$ rake db:migrate
修改app/models/order.rb
has_many :ships, dependent: :destroy

修改app/models/ship.rb
belongs_to :order

修改app/veiws/ships/new.html.erb
<h1>创建发货单</h1>
<strong>请核对如下商品</strong>
<table>
  <thead>
    <tr>
      <td>商品名称</td>
      <td>商品价格</td>
      <td>商品数量</td>
  </thead>
  <tbody>
  <% @want_ship_products.each do |w| %>
    <tr>
      <td><%= w[0] %></td>
      <td><%= w[1] %></td>
      <td><%= w[2] %></td>
    </tr>
  <% end %>
  </tbody>
</table>
<strong>请核对如下货运信息</strong>
<table>
  <thead>
    <tr>
      <td>收件人</td>
      <td>收件地址</td>
  </thead>
  <tbody>
    <td><%= @want_ship_order.name %></td>
    <td><%= @want_ship_order.address %></td>
  </tbody>
</table>
<strong>下面输入发货单信息</strong>
<%= render 'form' %>

<%= link_to '返回中心', ships_path %>

修改app/views/ships/_form.html.erb
<%= form_for(@ship) do |f| %>
  <% if @ship.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(@ship.errors.count, "error") %> prohibited this ship from being saved:</h2>

      <ul>
      <% @ship.errors.full_messages.each do |message| %>
        <li><%= message %></li>
      <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field">
    <%= f.label '订单号码' %><br>
    <%= f.text_field :order_id %>
  </div>
  <div class="field">
    <%= f.label '发货日期' %><br>
    <%= f.date_select :send_date %>
  </div>
  <div class="field">
    <%= f.label '发货人' %><br>
    <%= f.text_field :sender %>
  </div>
  <div class="field">
    <%= f.label '快递公司' %><br>
    <%= f.text_field :express_company %>
  </div>
  <div class="field">
    <%= f.label '快递单号' %><br>
    <%= f.text_field :express_number %>
  </div>                      # <kinder:note> 下面删掉了is_receive
  <div class="actions">
    <%= f.submit '保存快递信息'%>
  </div>
<% end %>


添加“是否发货”字段
$ rails g migration add_is_ship_to_order is_ship:boolean
修改 db/migrate/20150111143605_add_is_ship_to_orde.rb
    add_column :orders, :is_ship, :boolean, default: :false

$ rake db:migrate

添加“是否完成”字段
rails g migration add_is_end_to_order is_end:boolean
修改 db/migrate/20150111143605_add_is_end_to_order.rb
    add_column :orders, :is_end, :boolean, default: :false

$ rake db:migrate

添加新字段的访问，修改app/controllers/order_controller.rb
    def order_params
      params.require(:order).permit(:name, :address, :email, :pay_type, :user_id, :is_ship, :is_end)
    end

添加管理员
$ rails g scaffold Administrator name  # 更好的做法是user:references
$ rake db:migrate

添加管理员权限管理：
修改app/controllers/application_controller.rb
  def authorize_administrator
    user = User.find_by(id: session[:user_id])
    if Administrator.count.zero?
      @first_administrators = Administrator.new(name: User.order(:id).first.name)
      @first_administrators.save!
      redirect_to user, notice: '欢迎回来'
    else
      unless Administrator.find_by(name: user.name)
        redirect_to user, notice: '欢迎回来！'
      end
    end
  end

给其他控制器添加该管理员过滤器
修改app/controlllers/admin_controller.rb
  before_action :authorize_administrator

修改app/controlllers/administrators_controller.rb
  before_action :authorize_administrator

修改app/controlllers/carts_controller.rb
  before_action :authorize_administrator, only: :index

修改app/controlllers/line_items_controller.rb
  before_action :authorize_administrator, only: :index

修改app/controlllers/orders_controller.rb
  before_action :authorize_administrator, only: :index

修改app/controlllers/payment_types_controller.rb
  before_action :authorize_administrator

修改app/controlllers/products_controller.rb
  before_action :authorize_administrator

修改app/controlllers/sessions_controller.rb
  before_action :authorize_administrator, only: :index

修改app/controlllers/ships_controller.rb
  before_action :authorize_administrator, only: :index

修改app/controlllers/users_controller.rb
  before_action :authorize_administrator, only: :index

添加管理员管理面板
修改app/controllers/admin_controller.rb
  def index
    @total_orders = Order.all.count
    @unship_orders = Order.where("is_ship = 'f'").count
    #@not_ship_products = []
    @not_ship_orders = []
    Order.where(is_ship: :f).each do |order|
      @not_ship_orders << [order.id, order.created_at]
    end

修改app/views/admin/index.html.erb
<h1>欢迎</h1>
<p>现在是 <%= Time.now %></p>
<p>现在，系统上已经有了 <%= @total_orders %> 个订单。</p>
<p>其中，还有 <%= @unship_orders %> 个订单仍未发货。</p>
<table>
  <thead>
    <tr>
      <th>订单编号</th>
      <th>订购时间</th>
      <th>发货</th>
    </tr>
  </thead>

  <tbody>
  <% @not_ship_orders.each do |product| %>
      <tr>
	<td><%= product[0] %></td>
	<td><%= product[1] %></td>
        <td><%= link_to '发货', new_ship_path(order_id: product[0]) %>
      </tr>
    <% end %>
  </tbody>
</table>

收货操作
修改app/controllers/ships_controller.rb
  def new
    @ship = Ship.new
    @ship.order_id = params[:order_id]
    @want_ship_order = Order.find_by(id: params[:order_id])
    @want_ship_products = []
    @ship.order.line_items.each do |l|
      @want_ship_products << [l.product.title, l.price, l.quantity]
    end
  end

  def create
    @ship = Ship.new(ship_params)
    @ship.order.update(is_ship: "t")  # <kinder:note> new
    ...

  def confirm_receive         #<kinder:note> 新方法
    @ship = Ship.find(params[:id])
    @ship.update(is_receive: "t")
    @ship.order.update(is_end: "t")
    respond_to do |format|
      format.html { redirect_to @ship.order.user, notice: '恭喜您收到货物！' }
    end
  end

修改config/route.rb，增加路由
  post 'ships/confirm_receive'

修改app/views/ships/show.html.erb
<% if notice %>
  <p id="notice"><%= notice %></p>
<% end %>
<p>
  <strong>订单号：</strong>
  <%= @ship.order_id %>
</p>

<p>
  <strong>发货日期</strong>
  <%= @ship.send_date %>
</p>

<p>
  <strong>发货人</strong>
  <%= @ship.sender %>
</p>

<p>
  <strong>快递公司：</strong>
  <%= @ship.express_company %>
</p>

<p>
  <strong>快递单：</strong>
  <%= @ship.express_number %>
</p>

<p>
  <strong>是否收货：</strong>
  <% if @ship.is_receive == nil %>
    还未收货
  <% else %>
    已经收货
  <% end %>
</p>
<% if @ship.is_receive == nil %>
  <%= button_to '确认收到货物', ships_confirm_receive_path(id: @ship.id) %> 
<% end %>
<%= link_to '回到用户中心', user_path(id: @ship.order.user.id) %>

修改测试
在夹具将用户添加为管理员，修改test/fixtures/administrators.yml
one:
  name: dave

修改夹具line_items.yml
one:
  product: ruby
  order: one
  cart: one   # <kinder:note> new

修改夹具orders.yml
one:
  name: Dave Thomas
  address: MyText
  email: dave@example.org
  pay_type: 支付宝
  user: one   # <kinder:note> new

修改夹具ships.yml
one:
  order: one    # 原文是order_id:

修改功能测试test/controllers/session_controller_test.rb
  test "should get new" do
    session[:user_id] = nil   # <kinder:note> new
    get :new
    assert_response :success
  end

修改功能测试test/controllers/ships_controller_test.rb
  test "should get new" do
    @order_id = line_items(:one).order_id    #<kinder:note> 
    get :new, order_id: @order_id            #<kinder:note> 
    assert_response :success
  end

添加用户管理面板
修改app/controllers/users_controller.rb
  def show
    if @user.id != session[:user_id]
      @real = User.find_by(id: session[:user_id])
      respond_to do |format|
        format.html {redirect_to @real, notice: '无效用户'}
      end
    end
    @total_orders = Order.count
    @my_orders = Order.where("user_id = #{@user.id}")
    @my_total_orders = @my_orders.count
    @my_unend_products = []
    @my_ended_products = []
    @my_orders.each do |order|
      if order.is_end
        order.line_items.each do |line_item|
          @my_ended_products << [order.id, line_item.product.title, line_item.price, line_item.quantity, line_item.created_at.to_s(:db), order.ship.first.id]
        end
      else
        order.line_items.each do |line_item|
          if order.is_ship
            @my_unend_products << [order.id, line_item.product.title, line_item.price, line_item.quantity, line_item.created_at.to_s(:db), order.is_ship, order.ship.first.id]
          else
            @my_unend_products << [order.id, line_item.product.title, line_item.price, line_item.quantity, line_item.created_at.to_s(:db), order.is_ship]
	  end
        end
      end
    end
  end

修改app/views/users/show.html.erb
<% if notice %>
  <p id="notice"><%= notice %></p>
<% end %>
<p>
  <strong>这里是<%= @user.name %>的私人空间！</strong>
</p>
<%= link_to '更新密码', edit_user_path(@user) %>
<p>知道吗？系统上已经有了<%= @total_orders %>个订单！</p>
<p></p>
<% if @my_total_orders %>
<p>我贡献了其中的 <%= @my_total_orders %> 个订单：</p>

<% if @my_unend_products.count > 0 %>
<p>下面是还未完成交易的<%= @my_unend_products.count %>个商品：</p>
<table>
  <thead>
    <tr>
      <th>订单编号</th>
      <th>商品名称</th>
      <th>商品价格</th>
      <th>商品数量</th>
      <th>订购时间</th>
      <th>发货状态</th>
    </tr>
  </thead>
  <tbody>
  <% @my_unend_products.each do |product| %>
      <tr>
	<td><%= product[0] %></td>
	<td><%= product[1] %></td>
	<td style="text-align: right"><%= product[2] %></td>
	<td style="text-align: center"><%= product[3] %></td>
	<td><%= product[4] %></td>
        <% if product[5] %>
	  <td><%= link_to "查看快递信息", controller: "ships", action: 'show', id: product[6] %></td>
        <% else %>
	  <td>未发货</td>
        <% end %>
      </tr>
    <% end %>
  </tbody>
</table>
<% end %>

<% if @my_ended_products.count > 0 %>
<p>下面是已经完成交易的<%= @my_ended_products.count %>个商品：</p>
<table>
  <thead>
    <tr>
      <th>订单编号</th>
      <th>商品名称</th>
      <th>商品价格</th>
      <th>商品数量</th>
      <th>订购时间</th>
      <th>物流状态</th>
    </tr>
  </thead>

  <tbody>
  <% @my_ended_products.each do |product| %>
      <tr>
	<td><%= product[0] %></td>
	<td><%= product[1] %></td>
	<td style="text-align: right"><%= product[2] %></td>
	<td style="text-align: center"><%= product[3] %></td>
	<td><%= product[4] %></td>
	<td><%= link_to "查看快递信息", controller: "ships", action: 'show', id: product[5] %></td>
      </tr>
    <% end %>
  </tbody>
</table>
<% end %>
<% end %>


添加禁止查看他人的资料，包括购物车、在线商品、订单、会话、发货单、用户中心
修改cart#show
  def show
   if @cart.id != session[:cart_id]
     respond_to do |format|
       format.html {redirect_to store_url, notice: '无效购物车'}
     end
   end
  end

修改line_item#show
    if @line_item.cart.id != session[:cart_id]
      redirect_to store_url, notice: '无效项目'

修改order#show
  def show
    if @order.user.id != session[:user_id]
      redirect_to @order.user, notice: '无效订单'
    end
  end

修改ship#show
  def show
    if @ship.order.user.id != session[:user_id]
      redirect_to @ship.order.user, notice: '无效页面'
    end
  end

修改user#show
    if @user.id != session[:user_id]
      @real = User.find_by(id: session[:user_id])
      respond_to do |format|
        format.html {redirect_to @real, notice: '找不到该页面'}
      end
    end


<kinder:note>因为是事后回忆，难免有些细节会出现疏漏。总的来说，通过所有测试这一过程非常有意思。
</kinder:note> 


• Update the application to send an email to the system administrator, namely, yourself, when there is an application failure such as the one we handled in Section 10.2, Iteration E2: Handling Errors, on page 124.
当应用程序出现 如10.2节中的错误时，让应用程序向管理员，也就是你自己，发送一封邮件。

<kinder:note> 
Suresh attempted:
Add method to mailer Notifier:
class Notifier < ActionMailer::Base
# existing lines here...
  def error_occured(error)
    @error = error
    mail :to => "abc@xmail.com", :subject => 'Depot App Error Incident'  ## replace your email id to receive mails
  end
end

Create notifier template (in app/views/notifier) file “error_occured.text.erb”:


Hello Admin,

This is just to inform you that an exception was raised and rescued in the Depot app.

Error details:

<%= @error.message %>

Regards,
Depot App

Modify the carts controller to send the mail out:


  def show
    begin
      @cart = Cart.find(params[:id])
    rescue ActiveRecord::RecordNotFound => e
      logger.error "Attempt to access invalid cart #{params[:id]}" 
      Notifier.error_occured(e).deliver   ##### new line
      redirect_to store_url, :notice => 'Invalid cart'
    else
      respond_to do |format|
        format.html # show.html.erb
        format.xml  { render :xml => @cart }
      end
    end
  end

The above code can be added to any other rescue blocks, but I am leaving it at that, for now.

Now visit http://localhost:3000/carts/wibble and you should receive a mail about the incident.
下面是我根据Suresh的方案改动，因为rails4的代码有点不同：
$ rails g mailer Console_notifier error_occured
修改app/mailers/ConsoleNotifier.rb
class Notifier < ActionMailer::Base
  # existing lines here...
  def error_occured(error)
    @error = error
    mail :to => "abc@xmail.com", 
         :subject => 'Depot App的运行出现错误' 
  end
end

修改app/views/console_notifier/error_occured.text.erb，删除html.erb版本
管理员：
您好！

Depot网站抛出了意外错误。错误细节:

<%= @error %>

Regards,
Depot App

修改app/controllers/cart_controller.rb
    def invalid_cart
      e = "该操作尝试访问 #{params[:id]}"
      logger.error e
      redirect_to store_url, notice: '无效购物车'
      ConsoleNotifier.error_occured(e).deliver
    end
      ...

修改test/mailers/console_notifier.rb
  test "error_occured" do
    e = '这是一个错误'
    mail = ConsoleNotifier.error_occured(e)
    assert_equal "Depot App出现了错误", mail.subject
    assert_equal ["869027168@qq.com"], mail.to
    assert_equal ["from@example.com"], mail.from
    assert_match e, mail.body.encoded
  end


</kinder:note> 

• Add integration tests for both of the previous items.
为前面两项添加集成测试。
<kinder:note> 
Suresh attempted:

Note: I cheat a bit since I update the ship date in the order controller as soon as the order is taken. Let us assume we are selling only ebooks :).
For testing whether the shipment notification mail works properly, modify UserStoriesTest.”buying a product”:

  test "buying a product" do
    # existing code here...
    ship_date_expected = Time.now.to_date    ### new line
    post_via_redirect "/orders", ### existing line
    # existing code here...
    assert_equal "Check", order.pay_type  ### existing line
    assert_equal ship_date_expected, order.ship_date.to_date  ### new line
    # existing code here...
  end

For testing whether error notification mail works properly, add a new test:

  test "should mail the admin when error occurs" do
    get "/carts/wibble" 
    assert_response :redirect  # should redirect to...
    assert_template "/"        # ...store index

    mail = ActionMailer::Base.deliveries.last
    assert_equal ["abc@xmail.com"], mail.to  ## replace mail id
    assert_equal "some one <depot@example.com>", mail[:from].value  ## replace contact name/mail id
    assert_equal "Depot App Error Incident", mail.subject
  end
</kinder:note> 

# CHAPTER 14 Task I: Logging In 登录
## In this chapter, we’ll see
• adding secure passwords to models,
• using more validations,
• adding authentication to a session,
• using rails console,
• using database transactions, and
• writing an Active Record hook.

We have a happy customer—in a very short time we’ve jointly put together a basic shopping cart that she can start showing to her users.
客户很高兴，在非常短的时间内做好了一个基本的购物车，他可以展示给他的用户了。
There’s just one more change that she’d like to see.
但他还想改进一点。
Right now, anyone can access the administrative functions.
当前，所有人都可以访问管理功能。

She’d like us to add a basic user administration system that would force you to log in to get into the administration parts of the site.
他想要增加一个基本的用户管理系统，以使得强制登录才可获得网站的管理员权限。
我们非常乐意这么做，因为它让我们有机会看到虚拟属性以及过滤器，并且可以让整个应用程序变得整洁。
Chatting with our customer, it seems as if we don’t need a particularly sophisticated security system for our application.
在与客户交流之后，应用程序看起来并不需要一个非常复杂的安全系统。
We just need to recognize a number of people based on usernames and passwords.
所要做的只是根据用户名和密码进行识别。
Once recognized, these folks can use all of the administration functions.
一旦识别成功，他就可以使用所有的管理员功能。

## 14.1 Iteration I1: Adding Users 添加用户
### 用户表
Let’s start by creating a model and database table to hold our administrators’ usernames and passwords.
首先创建一个存放管理员的用户名和密码的模型和数据库表。
Rather than store passwords in plain text, we will store a digest hash value of the password.
密码不会以明文的格式存放，而是存放一个密码的256为的SHA2散列值和另外一个在密码学中叫做salt的值。
By doing so we ensure that even if our database is compromised, the hash won’t reveal the original password, so it can’t be used to log in as this user using the forms.
这么做出于以下几点考虑：即使数据库被破解了，从散列值也无法得到原始密码，这样就不能登录成功，也不能在其他地方使用，即使通常情况下用户总是在多个地方使用相同的密码。

    depot> rails generate scaffold User name:string password:digest

We declared the password as a digest type, which is another one of the nice extra touches that Rails provides.
<kinder:note> 我们声明password字段是一个digest摘要类型，这是Rails提供的另一种相当特别的地方。
Now run the migration as usual.
像往常那样运行迁移：

    depot> rake db:migrate

Next we have to flesh out the user model.
接下来充实一下用户模型。

    Download rails40/depot_r/app/models/user.rb
    class User < ActiveRecord::Base
    ➤ validates :name, presence: true, uniqueness: true
      has_secure_password
    end

• 192
这有点复杂，因为从应用程序角度看，该模型要与明文的密码打交道，但同时还要维护数据库中的salt值和散列密码。
让我们分步来看一个这个模型。
首先是验证。
对于一个简单的模型来说，这算是一个比较复杂的验证。

We check that the name is present and unique (that is, no two users can have the same name in the database).
首先检查名字是否存在并且唯一（即在数据库中不能有两个同名的用户）。

Then there’s the mysterious has_secure_password().
然后出现了这个神秘的has_secure_password参数。

You know those forms that prompt you to enter a password and then make you reenter it in a separate field so they can validate that you typed what you thought you typed?
你是否见过这种表单，它可以让你输入一个密码，然后在下面让你再输入一次？
That’s exactly what has_secure_password() does for you: it tells Rails to validate that the two passwords match.
这就是has_secure_password()所做的事情，它告诉Rails验证你两次输入的密码是否匹配。

<kinder:note> 下面是第二版关于密码的探讨。暂时不知该方案是否有效，但该细节显然值得进一步探讨。
Rails可以自动验证两个密码是否一样。
我们在后面介绍这是怎么工作的。
现在只需要知道两个密码项，一个为实际的密码，另一个为了确认。
最后，检查密码设置好了。
但我们并不检查密码属性本身。
为什么？
因为它实际上并不存在——至少在数据库中。
相反，我们检查它的代理存在，即散列密码。
要理解这个原理，需要看看密码存储是怎么处理的。
现在创建一个散列密码，需要分三步。
首先，创建一个独一无二的salt值（稍后我们会谈到salt）。
其次，将此salt值与明文密码相结合以生成一个字符串。
最后，在结果上运行SHA2 digest，这会返回一个40个字符的十六进制数字。
将上述步骤写成一个公共类方法。
（要记住在文件中引用digest/sha2库。在后面内容中介绍此库应该放在哪里）。

    depot_r/app/models/user.rb
    def User.encrypt_password(password, salt)
      Digest::SHA2.hexidigest(password + "wibble" + salt)
    end

在密码学中，salt字符串是随机的，它可以让密码难以破解。
在这里我们通过将一个随机数和用户对象的id连接而得到salt字符串。
事实上salt是什么并不重要，只要它难以预测（例如使用时间作为salt的熵比使用随机字符要低）。
将此salt值存放在模型对象的salt属性中。
因为它应该是私有方法，在源代码中将它放置在private关键字之后。

    depot_r/app/models/user.rb
    def generate_salt
      self.salt = self.object_id.to_s + rand.to_s
    end

在这段代码中有点儿微秒的东西我们从来没有见过。
注意`self.salt = ...`，它强迫赋值使用`salt=`存取器方法——这相当于说“在当前对象中调用salt=”。
如果没有`self.`，Ruby会以为是对本地变量赋值，这样的话代码就没有效果了。
<kinder:note> 没有什么效果？

虽然直接使用实例变量也会得到正确的结果，但这样会将你束缚在一个不总是一致的表示上。
属性`salt/salt=`是“官方”的对底层模型属性的接口，所以最后使用它们而不是实例变量。

从另一个角度来看，是因为这些属性构成了类公共接口的一部分，那么该类就应该自我试用并也使用那些接口。
如果在内部使用@xxx而在外部使用.xxx，那么就会为某些错误匹配大开方便之门。
<kinder:note> 还是搞不懂。

现在开始实现一段代码，无论何时将一个新的纯文本格式的密码存入用户对象，都会自动生成一个散列密码（它会自动保存在数据库中）。
通过将纯文本格式的密码作为模型的一个虚拟属性来实现——它看起来像是应用程序的一个属性，但却不会在数据库中持续存在。

如果不需要创建散列密码，可以简单地通过使用Ruby的attr_accessor声明来来实现这一点：

    attr_accessor :password

attr_accessor在幕后生成两个存取器方法：一个叫做password的读方法和一个叫做password=的写方法。
写方法的名字以等号结尾意味着它可以被赋值。
所有，使用标准的存取器可以简单地实现一些公共方法，并让写方法创建一个新的salt和设置散列密码：

    depot_r/app/models/user.rb
    def password=(password)
      @password = password
      if password.present?
        generate_salt          # 这个方法的代码见上面。
        self.hashed_password = self.class.encrypt_password(password, salt)  # 产生散列值
      end
    end

再次利用self来访问hashed_password，但不使用self来访问password赋值函数，因为这样做只会重复递归调用。

还有最后一个修改。
让我们实现一个公共类方法，如果调用者提供正确的用户名和密码，此方法返回该用户的对象。
因为输入的密码是明文的，必须使用名字作为键值来访问用户记录，然后再次使用该记录的salt值来生成散列密码。
如果散列密码匹配，就返回该用户对象。
使用这种方法就可以验证一个用户了。

    depot_r/app/models/user.rb
    def User.authenticate(name, password)
      if  user = find_by_name(name)
        if user.hashed_password == encrypt_password(password, user.salt)
          user
        end
      end
    end

用户模型包含了许多代码，但它显示了模型如何承载大量的商业逻辑。
在开始处理控制器之前，让我们审视一下整个模型：

    depot_r/app/models/user.rb
    require 'digest/sha2'
    class User < ActiveRecord::Base
      validates :name, :presence => true, :uniqueness => true
      validates :password, :confirmation => true
      attr_accessor :password_confirmation
      attr_reader :password
      validates :password_must_be_present

      def User.authenticate(name, password)
        if  user = find_by_name(name)
          if user.hashed_password == encrypt_password(password, user.salt)
            user
          end
        end
      end

      def User.encrypt_password(password, salt)
        Digest::SHA2.hexidigest(password + "wibble" + salt)
      end

      def password=(password)
        @password = password
        if password.present?
          generate_salt          # 这个方法的代码见上面。
          self.hashed_password = self.class.encrypt_password(password, salt)  # 产生散列值
        end
      end

      private

      def password_must_be_present
        errors.add(:password, "Missing password") unless hashed_password.present?
      end

      def generate_salt
        self.salt = self.object_id.to_s + rand.to_s
      end

    end

<kinder:note> 以上就是2版的内容，已经在4版被删除。


This line was added for you because you specified password:digest when you generated your scaffold.
<kinder:note> 这一行是创建支架时指定password:digest所添加的。

The next step is to uncomment out the bcrypt-ruby gem in your Gemfile.
<kinder:note> 下一步是在Gemfile里面取消bcrypt-ruby gem的注释。

    Download rails40/depot_r/Gemfile
    # Use ActiveModel has_secure_password
    ➤ gem 'bcrypt-ruby', '~> 3.0.0'

Next, you need to install the gem.
<kinder:note> 下一步，需要安装gem。

    depot> bundle install

Finally, you need to restart your server.
<kinder:note> 最后，需要重启服务器。
With this code in place, we have the ability to present both a password and a password confirmation field in a form, as well as the ability to authenticate a user given a name and a password.
当这些代码完成之后，就可以在表单中显示和确认密码了，并给定一个用户名和密码以认证该用户。

### Administering Our Users  管理用户
In addition to the model and table we set up, we already have some scaffolding generated to administer the model.
除了设置好模型和数据表之外，我们也已经生成了一些管理模型的脚手架。
Let’s go through it and make some tweaks as necessary.
让我们配置一些必要的东西。

### 修改控制器
We start with the controller.
首先从控制器开始。
It defines the standard methods: index(), show(), new(), edit(), update(), and delete().
它定义了标准的方法，index()， show()，new()，update()，delete()。
By default, Rails omits the unintelligible password hash from the view.
<kinder:note> 缺省情况下，Rails忽略了视图中莫名其妙的密码散列。
This means that in the case of users, there isn’t really much to show(), except a name.
<kinder:note> 这意味着从用户的角度来讲，除了用户名，并没有什么东西需要显示。
So, let’s avoid the redirect to showing the user after a create operation.
所以在创建操作之后，让我们避免重定向到显示用户。
Instead, let’s redirect to the user’s index and add the username to the flash notice.
重定向到用户索引并在闪存通知中加入用户名。

String interpolation ↪ on page 40

    Download rails40/depot_r/app/controllers/users_controller.rb
    def create
      @user = User.new(user_params)
      respond_to do |format|
      ➤ if @user.save
      ➤   format.html { redirect_to users_url, notice: "User #{@user.name} was successfully created." }
          format.json { render action: 'show', status: :created, location: @user }

• 193

        else
          format.html { render action: 'new' }
          format.json { render json: @user.errors, status: :unprocessable_entity }
        end
      end
    end

Let’s do the same for an update operation.
对update操作做相同的修改。

    def update
      respond_to do |format|
      ➤ if @user.update(user_params)
      ➤   format.html { redirect_to users_url, notice: "User #{@user.name} was successfully updated." }
          format.json { head :no_content }
        else
          format.html { render action: 'edit' }
          format.json { render json: @user.errors, status: :unprocessable_entity }
        end
      end
    end

While we are here, let’s also order the users returned in the index by name.
同时，对索引中返回的用户按name排序。

    def index
    ➤ @users = User.order(:name)
    end

### 修改视图
Now that the controller changes are done, let’s attend to the view.
现在控制器已经改好，继续修改视图。
As it stands now, the index view doesn’t display notice information, so let’s add it.
当前视图并不显示通知信息，我们添加上。

    Download rails40/depot_r/app/views/users/index.html.erb
    <h1>Listing users</h1>
    ➤ <% if notice %>
    ➤   <p id="notice"><%= notice %></p>
    ➤ <% end %>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
      <% @users.each do |user| %>
        <tr>
          <td><%= user.name %></td>                                                            
          <td><%= link_to 'show', user %></td>
          <td><%= link_to 'edit', edit_user_path(user) %></td>
          <td><%= link_to 'destroy', user, method: :delete, data: { confirm: 'are you sure?' } %></td>
        </tr>
      <% end %>
      </tbody>
    </table>
    <br>
    <%= link_to 'New User', new_user_path %>

• 194

Finally, we need to update the form used both to create a new user and to update an existing user.
最后，需要更新表单，用来创建一个新用户、更新一个已有的用户。
Note that this form is already set up to show the password and password confirmation fields.
<kinder:note> 注意这个表格已经设置好显示密码和密码确认字段。
To improve the appearance of the page, we add legend and fieldset tags.
<kinder:note> 我们增加legend和fieldset标签来改进页面的外观。
And finally we wrap the output in a <div> tag with a class that we previously defined in our stylesheet.
最后用之前在样式表中定义的类将输出包裹在<div>标签中。

    Download rails40/depot_r/app/views/users/_form.html.erb
    <div class="depot_form">
      <%= form_for @user do |f| %>
        <% if @user.errors.any? %>
          <div id="error_explanation">
            <h2><%= pluralize(@user.errors.count, "error") %> prohibited this user from being saved:</h2>
            <ul>
            <% @user.errors.full_messages.each do |msg| %>
              <li><%= msg %></li>
            <% end %>
            </ul>
          </div>
        <% end %>
        <fieldset>
        <legend>Enter User Details</legend>
        <div class="field">
          <%= f.label :name, 'Name:' %>
          <%= f.text_field :name, size: 40 %>
        </div>
        <div class="field">
          <%= f.label :password, 'Password:' %>
          <%= f.password_field :password, size: 40 %>
        </div>

• 195

        <div class="field">
          <%= f.label :password_confirmation, 'Confirm:' %>
          <%= f.password_field :password_confirmation, size: 40 %>
        </div>
        <div class="actions">
          <%= f.submit %>
        </div>
      </fieldset>
      <% end %>
    </div>

### 实践检验
Let’s try it.
试一下。
<kinder:note>在尝试之前，请在Gemfile文件中将bcrypt的一行的注释去掉，运行`bundle install`安装该gem，否则报错。

Navigate to http://localhost:3000/users/new.
浏览http://localhost:3000/users/new。
For a stunning example of page design, see the following figure:
效果如下图表：
Figure 36—Entering user details

After clicking Create User , the index is redisplayed with a cheery flash notice.
单击‘创建用户’之后，索引与一个祝贺的闪存通知一起显示。
If we look in our database, you’ll see that we’ve stored the user details.
如果此时查看数据库，会发现已经存储了用户细节。

    depot> sqlite3 -line db/development.sqlite3 "select * from users"
    id = 1
    name = dave
    password_digest = $2a$10$lki6/oAcOW4AWg4A0e0T8uxtri2Zx5g9taBXrd4mDSDVl3rQRWRNi
    created_at = 2013-01-29 14:40:06.230622
    updated_at = 2013-01-29 14:40:06.230622

• 196

### 更新测试
Like we have done before, we need to update our tests to reflect the validation and redirection changes we have made.
就像我们之前做的一样，需要更新测试集来反映对验证和重定向所做的更改。
First we update the test for the create() method.
<kinder:note> 首先更新create()方法的测试。

    Download rails40/depot_r/test/controllers/users_controller_test.rb
    test "should create user" do
      assert_difference('User.count') do
    ➤   post :create, user: { 
          name: 'sam',   #原文 name: @user.name
          password: 'secret', 
          password_confirmation: 'secret' 
        }
      end
    ➤ assert_redirected_to users_path
    # assert_redirected_to user_path(assigns(:user)) 原文
    end

As the redirect on the update() method changed too, the update test also needs to change.
<kinder:note> 因为更新方法的重定向也更改了，更新测试也需要改变。

    test "should update user" do
      patch :update, id: @user, user: { name: @user.name, password: 'secret',
        password_confirmation: 'secret' }
    ➤ assert_redirected_to users_path
    # assert_redirected_to user_path(assigns(:user)) 原文
    end

And we need to update the test fixtures to ensure that there are no duplicate
names.
<kinder:note> 并且需要更新测试夹具来确保没有重复的名字。

    Download rails40/depot_r/test/fixtures/users.yml
    # Read about fixtures at
    # http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
    one:
    ➤ name: dave
      password_digest: <%= BCrypt::Password.create('secret') %>
    two:
    ➤ name: susannah
      password_digest: <%= BCrypt::Password.create('secret') %>

Note the use of dynamically computed values in the fixture, specifically for the value of password_digest.
<kinder:note> 注意夹具中用户的动态计算值，特别是password_digest的值。
This code was also inserted by the scaffolding command and uses the same function that Rails1 uses to compute the password.
<kinder:note> 这个代码也是被脚手架命令插入的，使用和Rails计算密码相同的函数。

At this point, we can administer our users; we need to first authenticate users and then restrict administrative functions so they will be accessible only by administrators.
至此，我们就可以管理用户了；需要先认证用户，然后限制管理功能只能由管理员访问。

1.  https://github.com/rails/rails/blob/3-2-stable/activemodel/lib/active_model/secure_password.rb

• 197

## 14.2 Iteration I2: Authenticating Users 认证用户
What does it mean to add login support for administrators of our store?
为商店管理员添加登录支持意味着什么呢？
• We need to provide a form that allows them to enter their username and password.
  需要提供一个可供它们输入用户名和密码的表单。
• Once they are logged in, we need to record that fact somehow for the rest of their session (or until they log out).
  一旦登录了，需要在剩下的会话中记录下这个事实（直到注销）。
• We need to restrict access to the administrative parts of the application, allowing only people who are logged in to administer the store.
  需要限制对应用用程序的管理部分的访问，仅允许那些成功登录管理商店的人访问。

We could put all of the logic into a single controller, but it makes more sense to split it into two: a session controller to support logging in and out and a controller to welcome administrators.
我们需要一个会话控制器来支持登录和注销，还需要一个控制器来欢迎管理员。

    depot> rails generate controller Sessions new create destroy
    depot> rails generate controller Admin index

The SessionsController#create action will need to record something in session to say that an administrator is logged in.
SessionsController#create动作需要在会话中记录管理员已经登录。
Let’s have it store the ID of their User object using the key :user_id.
让我们用键`:user_id`存储User对象的ID。
The login code looks like this:
登录代码如下：

      Download rails40/depot_r/app/controllers/sessions_controller.rb
      def create
    ➤   user = User.find_by(name: params[:name])   # params参数从浏览器获得
    ➤   if user and user.authenticate(params[:password])  # 参见下面视图
    ➤     session[:user_id] = user.id
    ➤     redirect_to admin_url    
          #<kinder:note> 怎么一下子就成了管理员了？
    ➤   else
    ➤     redirect_to login_url, alert: "Invalid user/password combination"
    ➤   end
      end

We are also doing something new here: using a form that isn’t directly associated with a model object.
还要做一件新的事情：使用一个并不直接与模型对象相关联的表单。
To see how that works, let’s look at the template for the sessions#new action.
要知道怎么做，看一下sessions#new动作的模板。

    Download rails40/depot_r/app/views/sessions/new.html.erb
    <div class="depot_form">
      <% if flash[:alert] %>
        <p id="notice"><%= flash[:alert] %></p>
      <% end %>
      <%= form_tag do %>
        <fieldset>
          <legend>Please Log In</legend>
          <div>
            <%= label_tag :name, 'Name:' %>
            <%= text_field_tag :name, params[:name] %>
          </div>

• 198

          <div>
            <%= label_tag :password, 'Password:' %>
            <%= password_field_tag :password, params[:password] %>
          </div>
          <div>
            <%= submit_tag "Login" %>
          </div>
        </fieldset>
      <% end %>
    </div>


This form is different from ones we saw earlier.
这个表单和我们之前看过的有所不同。
Rather than using form_for, it uses form_tag, which simply builds a regular HTML <form>.
它使用form_tag，而不是form_for，这样做就建立了一个普通的HTML<form>。
Inside that form, it uses text_field_tag and password_field_tag, two helpers that create HTML <input> tags.
在那个表单之中，使用text_field_tag和password_field_tag这两个帮助方法来创建HTML<input>标签。
Each helper takes two parameters.
每个帮助方法接收两个参数。
The first is the name to give to the field, and the second is the value with which to populate the field.
第一个是给此项的名字，第二个是此项的赋值。
This style of form allows us to associate values in the params structure directly with form fields—no model object is required.
这种类型的表单让我们可以将params结构中的值直接与表单项关联起来——不需要对象模型。
In our case, we chose to use the params object directly in the form.
在这里，我们选择直接在表单里使用params对象。
An alternative would be to have the controller set instance variables.
另一种方法是让控制器设置实例变量。

We also make use of the label_tag helpers to create HTML <label> tags.
<kinder:note> 我们页使用label_tag帮助方法来创建HTML<label>标签。
This helper also accepts two parameters.
<kinder:note> 这个帮助方法也接收两个参数。
The first contains the name of the field, and the second contains the label to be displayed.
<kinder:note> 第一个参数包含字段名，第二个包含显示的标签。

See Figure 37, Parameters flow between controllers, templates, and browsers., on page 199.
见下页的图表37。

Note how the value of the form field is communicated between the controller and the view using the params hash: the view gets the value to display in the field from params[:name], and when the user submits the form, the new field value is made available to the controller the same way.
注意表单项中的值是如何利用params散列与控制器和视图通信的：视图从params[:name]中得到显示的值，当用户提交表单，该项新的值以同样的方式对控制器可用。
If the user successfully logs in, we store the ID of the user record in the session data.
如果用户成功登入，在会话数据中存储下用户记录的id。
We’ll use the presence of that value in the session as a flag to indicate that an administrative user is logged in.
在会话期间我们会使用该值来作为管理员用户已经登录的标志。

As you might expect, the controller actions for logging out are considerably simpler.
如你所愿，注销的控制器行为非常简单。

    Download rails40/depot_r/app/controllers/sessions_controller.rb
    def destroy
    ➤ session[:user_id] = nil
    ➤ redirect_to store_url, notice: "Logged out"
    end

Finally, it’s about time to add the index page, the first screen that administrators see when they log in.
最后，是时候添加索引页面了，即管理员登录后的第一个页面。
Let’s make it useful—we’ll have it display the total number of orders in our store.
让我们使用它来显示在线商店中的总的订单数。
Create the template in the file index.html.erb in the directory app/views/admin.
在目录app/views/admin中的index.html.erb文件夹中创建模板。
(This template uses the pluralize() helper, which in this case generates the string order or orders depending on the cardinality of its first parameter.)
（这个模板使用pluralize帮助方法，它可以依据第一个参数的数目来生成order或orders字符串。）

• 199
    
                  Template （模板）
                  <% form_tag do %>
                    Name: <%= text_field_tag :name, params[:name] %>
                    ...                               ^  |
                  <% end %>                           |  |
                                                      |  |
    Controller （控制器）                             |  |
    def login                                         |  |
      name = params[:name]   ----------------->-------+  |
      ...      ^                                         |
    end        |                视图                     |
               |             +-----------+               |
               +-<-  用户名：|           |   <-----------+
                             +-----------+
    Figure 37—Parameters flow between controllers, templates, and browsers.


    Download rails40/depot_r/app/views/admin/index.html.erb
    <h1>Welcome</h1>
    It's <%= Time.now %>
    We have <%= pluralize(@total_orders, "order") %>.

The index() action sets up the count.
index()动作设置了合计。

    Download rails40/depot_r/app/controllers/admin_controller.rb
    class AdminController < ApplicationController
      def index
    ➤   @total_orders = Order.count
      end
    end

• 200

We have one more task to do before we can use this.
在使用它之前还有一件事要做。
Whereas previously we relied on the scaffolding generator to create our model and routes for us, this time we simply generated a controller because there is no database-backed model for this controller.
尽管之前我们依靠脚手架生成器来创建模型和路由，然而这次我们直接生成了一个控制器，因为这个控制器没有后端数据库的模型。
Unfortunately, without the scaffolding conventions to guide it, Rails has no way of knowing which actions are to respond to GET requests, which are to respond to POST requests, and so on, for this controller.
遗憾的是，没有了脚手架的指导，对这个控制器，Rails不知道用什么样的行为来响应GET请求，这个Get请求又是用来响应POST请求的，等等。
We need to provide this information by editing our config/routes.rb file.
我们需要通过编辑config/routes.rb来提供这个信息。

        Download rails40/depot_r/config/routes.rb
        Depot::Application.routes.draw do
     ➤    get 'admin' => 'admin#index'
     ➤    controller :sessions do
          # <kinder:note> 
          # 这一句应该改为：`controller :session do`
          # 否则会报错说没有路由。
          # </kinder:note> 
     ➤      get 'login' => :new
     ➤      post 'login' => :create
     ➤      delete 'logout' => :destroy
     ➤    end
          get "sessions/create"         # <kinder:note> 这一行还要保留吗？
          get "sessions/destroy"         # <kinder:note> 这一行还要保留吗？
          resources :users
          resources :orders
          resources :line_items
          resources :carts
          get "store/index"
          resources :products do
            get :who_bought, on: :member
          end
          # The priority is based upon order of creation:
          # first created -> highest priority.
          # See how all your routes lay out with "rake routes".
          # You can have the root of your site routed with "root"
          root 'store#index', as: 'store'
          # ...
        end

We’ve touched this before, when we added a root statement in Section 8.1, Iteration C1: Creating the Catalog Listing, on page 91.
之前已经涉及了这一点，在前面91页8.1节中我们增加了一条root语句。
What the generate command will add to this file are fairly generic get statements for each of the actions specified.
generate命令向这个文件中添加的只不过是每个指定行为的通用get语句。
You can (and should) delete the routes provided for sessions/ new, sessions/create, and sessions/destroy.
可以（也应该）删除提供给session/new、session/create、和session/destroy的路由。

In the case of admin, we will shorten the URL that the user has to enter (by removing the /index part) and map it to the full action.
对于admin，我们要缩短用户要输入URL（通过移除/index部分）并把它映射到一个完整的行为上。
In the case of session actions, we will completely change the URL (replacing things like session/create with simply login) as well as tailor the HTTP action that we will match.
对于会话行为，要完完全全地改变URL（将session/create替换成login）并且修剪要匹配的HTTP行为。

• 201

Note that login is mapped to both the new and create actions, the difference being whether the request was an HTTP GET or HTTP POST.
注意到login被同时映射到new和create动作上，差别只在请求是HTTP GET还是HTTP POST。

We also make use of a shortcut: wrapping the session route declarations in a block and passing it to a controller() class method.
我们还会利用到一条捷径：将session route声明放在一个块中并传递给controller类方法。
This saves us a bit of typing as well as makes the routes easier to read.
这样做的好处是不用输入那么多代码了，同时路由也变得更加便于阅读。
We will describe all you can do in this file in Section 20.1, Dispatching Requests to Controllers, on page 309.
后面309页20.1节会完整地介绍这个文件的用法。

With these routes in place, we can experience the joy of logging in as an administrator.
这些路由就绪之后，就可以以管理员的身份登录了。
See the following figure:
如下图所示：

Figure 38—Administrative interface

We need to replace the functional tests in the session controller to match what we just implemented.
还需要在会话控制器中对这些刚刚实现的东西进行功能测试。

    Download rails40/depot_r/test/controllers/sessions_controller_test.rb
    require 'test_helper'

    class SessionsControllerTest < ActionController::TestCase
      test "should get new" do
        get :new
        assert_response :success
      end
    
    ➤ test "should login" do
    ➤   dave = users(:one)
    ➤   post :create, name: dave.name, password: 'secret'
    ➤   assert_redirected_to admin_url
    ➤   assert_equal dave.id, session[:user_id]
    ➤ end
    
    ➤ test "should fail login" do
    ➤   dave = users(:one)
    ➤   post :create, name: dave.name, password: 'wrong'
    ➤   assert_redirected_to login_url
    ➤ end

    ➤ test "should logout" do
    ➤   delete :destroy
    ➤   assert_redirected_to store_url
    ➤ end
    end

<kinder:note> 2版还有静态测试的。这一版没有了。
• 202

We show our customer where we are, but she points out that we still haven’t controlled access to the administrative pages (which was, after all, the point of this exercise).
我们将进度给客户看，但他指出还没有控制管理员页面的访问（毕竟，这是这个练习的重点）。

## 14.3 Iteration I3: Limiting Access 限制访问
We want to prevent people without an administrative login from accessing our site’s admin pages.
我们想要防止那些不具备管理员权限的人访问网站的管理员页面。
It turns out that it’s easy to implement using the Rails callback facility.
利用Rails过滤器的帮助，这一点非常容易实现。

Rails callbacks allow you to intercept calls to action methods, adding your own processing before they are invoked, after they return, or both.
Rails过滤器允许你拦截行为方法的调用，在它们被调用和或返回后添加你自己的处理。
In our case, we’ll use a before action callback to intercept all calls to the actions in our admin controller.
在这里，使用before动作回调来拦截对于管理控制器中动作的调用。
The interceptor can check session[:user_id].
拦截者能检查session[:user_id]。
If it’s set and if it corresponds to a user in the database, the application knows an administrator is logged in, and the call can proceed.
如果该项被设置了，并且对应了数据库中的一个用户，应用程序就知道一个管理员登录了，那么调用就会继续。
If it’s not set, the interceptor can issue a redirect, in this case to our login page.
如果没有设置，拦截者可以重定向，在这里可以重定向到登录页面。

Where should we put this method? 
应该将这个方法放在哪里呢？
It could sit directly in the admin controller, but, for reasons that will become apparent shortly, let’s put it instead in ApplicationController, the parent class of all our controllers.
它可以直接放在admin控制器中，但是基于某些马上就会提到的原因，把它放在ApplicationController中，也就是所有控制器的父类。
This is in the file application_controller.rb in the directory app/controllers.
它在app/controllers目录下的application_controller.rb文件中。
Note too that we chose to restrict access to this method.
同时注意，还要限制访问此方法。
This prevents it from ever being exposed to end users as an action.
这可避免它作为一个行为暴露给终端用户。

    Download rails40/depot_r/app/controllers/application_controller.rb
    class ApplicationController < ActionController::Base
    ➤ before_action :authorize
      # ...
    ➤
    ➤ protected
    ➤
    ➤ def authorize
    ➤   unless User.find_by(id: session[:user_id])
    ➤     redirect_to login_url, notice: "Please log in"
    ➤   end
    ➤ end
    end

• 203

The before_action() line causes the authorize() method to be invoked before every action in our application.
before_action()一行导致authorization()方法于应用程序中每个行为之前被调用。

This is going too far.
然而这么做有些过犹不及。
We have just limited access to the store itself to administrators.
我们刚刚将商店的访问只给了管理员。
That’s not good.
这并不好。

We could go back and change things so that we mark only those methods that specifically need authorization.
可以回到之前，仅修改那些特别需要验证的方法。
Such an approach is called blacklisting and is prone to errors of omission.
这种方式叫做黑名单，很容易因为疏忽而出错。
A much better approach is to “whitelist” or list methods or controllers for which authorization is not required.
一个更好的方式是“白名单”，即仅列出那些不需要验证的方法或控制器。
We do this simply by inserting a skip_before_action() call within the StoreController:
通过在StoreController中插入一个skip_before_action()调用，可以做到这一点。

    Download rails40/depot_r/app/controllers/store_controller.rb
    class StoreController < ApplicationController
    ➤ skip_before_action :authorize

and again for the SessionsController class, like so:
同时对SessionsController类：

    Download rails40/depot_r/app/controllers/sessions_controller.rb
    class SessionsController < ApplicationController
    ➤ skip_before_action :authorize

We’re not done yet; now we need to allow people to create, update, and delete carts.
还没完；现在要允许人们创建、更新和删除购物车：

    Download rails40/depot_r/app/controllers/carts_controller.rb
    class CartsController < ApplicationController
    ➤ skip_before_action :authorize, only: [:create, :update, :destroy]
      # ...
      private
      # ...
      def invalid_cart
        logger.error "Attempt to access invalid cart #{params[:id]}"
        redirect_to store_url, notice: 'Invalid cart'
      end
    end

And we allow them to create line items:
允许人们创建商品项目：

    Download rails40/depot_r/app/controllers/line_items_controller.rb
    class LineItemsController < ApplicationController
    ➤ skip_before_action :authorize, only: :create

as well as create orders (which includes access to the new form):
并且创建订单（包括对new表单的访问）：

    Download rails40/depot_r/app/controllers/orders_controller.rb
    class OrdersController < ApplicationController
    ➤ skip_before_action :authorize, only: [:new, :create]

• 204

With the authorization logic in place, we can now navigate to http://localhost:3000/products.
验证逻辑就绪后，就可以访问http://localhost:3000/products了。
The callback method intercepts us on the way to the product listing and shows us the login screen instead.
回调方法阻止我们访问产品列表，且显示登录页面。

Unfortunately, this change pretty much invalidates most of our functional tests because most operations will now redirect to the login screen instead of doing the function desired.
遗憾的是，该更改会让大多数功能测试失效，因为许多操作现在都被重定向到登录页面，而不是完成相应的功能了。
Fortunately, we can address this globally by creating a setup() method in the test_helper.
幸好可以通过在test_helper中创建一个setup()方法来全局性地解决这个问题。
While we are there, we also define some helper methods to login_as() and logout() a user.
我们还会定义一些帮助方法来login_as和login_in一个用户。

    Download rails40/depot_r/test/test_helper.rb
    class ActiveSupport::TestCase
      # ...
      # Add more helper methods to be used by all tests here...
      def login_as(user)
        session[:user_id] = users(user).id
      end
      def logout
        session.delete :user_id
      end
      def setup
        login_as :one if defined? session
      end
    end

Note that the setup() method will call login_as() only if session is defined.
注意，仅当定义了session，setup()方法才会调用login_as。
This prevents the login from being executed in tests that do not involve a controller.
这样做可以阻止在那些不调用控制器的测试中执行login。

We show our customer and are rewarded with a big smile and a request:
我们把这些给客户看，他回报了一个大大的微笑，还有一个请求：
could we add a sidebar and put links to the user and product administration stuff in it? 
可以增加一个侧边栏，并把指向用户和商品管理的链接放在里面吗？
And while we’re there, could we add the ability to list and delete administrative users? 
还有，可以增加列出和删除管理员用户的功能吗？
You betcha!
当然可以！

## 14.4 Iteration I4: Adding a Sidebar, More Administration 增加侧边栏，更多管理
### 增加侧边栏
Let’s start with adding links to various administration functions to the sidebar in the layout and have them show up only if there is :user_id in the session.
首先在侧边栏中增加各式管理功能的链接，并且仅当session中:user_id时才显示它们。

    Download rails40/depot_r/app/views/layouts/application.html.erb
    <!DOCTYPE html>
    <html>
    <head>
      <title>Pragprog Books Online Store</title>
      <%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true %>
      <%= javascript_include_tag "application", "data-turbolinks-track" => true %>

• 205


      <%= csrf_meta_tags %>
    </head>
    <body class="<%= controller.controller_name %>">
    <div id="banner">
      <%= image_tag("logo.png") %>
      <%= @page_title || "Pragmatic Bookshelf" %>
    </div>
    <div id="columns">
      <div id="side">
        <% if @cart %>
          <%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
            <%= render @cart %>
          <% end %>
        <% end %>
        <ul>
          <li><a href="http://www....">Home</a></li>
          <li><a href="http://www..../faq">Questions</a></li>
          <li><a href="http://www..../news">News</a></li>
          <li><a href="http://www..../contact">Contact</a></li>
        </ul>
    ➤
    ➤   <% if session[:user_id] %>
    ➤     <ul>
    ➤       <li><%= link_to 'Orders', orders_path %></li>
    ➤       <li><%= link_to 'Products', products_path %></li>
    ➤       <li><%= link_to 'Users', users_path %></li>
    ➤     </ul>
    ➤     <%= button_to 'Logout', logout_path, method: :delete %> 
    ➤   <% end %>
    ➤
      </div>
      <div id="main">
        <%= yield %>
      </div>
    </div>
    </body>
    </html>


Now it is all starting to come together.
所有的东西都渐渐成型。
We can log in, and by clicking a link on the sidebar, we can see a list of users.
我们可以登录，并且通过单击侧边栏中的链接看见用户列表。
Let’s see whether we can break something.
让我们检查一下还有什么东西需要改进。

### Would the Last Admin to Leave… 如果删除了最后一个管理员
We bring up the user list screen that looks something like Figure 39, Listing our users, on page 206; then we click the Destroy link next to dave to delete that user.
用户列表界面看起来如下页的下图；通过单击dave旁边的“Destroy”链接来删除该用户。
Sure enough, our user is removed.
毫无疑问，用户被移除了。
But to our surprise, we’re then presented with the login screen instead.
但意外的是，登录页面随后显示出来。
We just deleted the only administrative user from the system.
我们刚刚删除了系统中唯一的管理员。
When the next request came in, the authentication failed, so the application refused to let us in.
当收到下一个请求时，验证失败了，应用程序拒绝我们进入。
We have to log in again before using any administrative functions.
必须重新登录才能使用管理功能。

• 206

Figure 39—Listing our users

But now we have an embarrassing problem: there are no administrative users in the database, so we can’t log in.
但现在的问题优点尴尬：因为数据库中没有了任何管理员用户，所以无法登录。

Fortunately, we can quickly add a user to the database from the command line.
幸运的是，可以通过快速地通过命令行向数据库中增加一个用户。
If you invoke the command rails console, Rails invokes Ruby’s irb utility, but it does so in the context of your Rails application.
如果调用命令rails console，Rails会调用Ruby的irb工具，但仅在此Rails应用程序的范围内。
That means you can interact with your application’s code by typing Ruby statements and looking at the values they return.
这意味着可以通过输入Ruby语句来与应用程序代码交互，并以此来查看它返回的值。

We can use this to invoke our user model directly, having it add a user into the database for us.
通过这种方法可以直接调用用户模型，让它向数据库中增加一个用户：

    depot> rails console
    Loading development environment.
    >> User.create(name: 'dave', password: 'secret', password_confirmation: 'secret')
    => #<User:0x2933060 @attributes={...} ... >
    >> User.count
    => 1

• 207

The >> sequences are prompts.
`>>`是提示符。
After the first, we call the User class to create a new user, and after the second, we call it again to show that we do indeed have a single user in our database.
在第一个提示符后，调用user类来创建新用户，第二个提示符后，再次调用user显示数据库中确实存在一个用户。
After each command we enter, rails console displays the value returned by the code (in the first case, it’s the model object, and in the second case, it’s the count).
在每个输入命令之后，`rails console`会显示代码的返回值。（第一个提示符后显示的是模型对象，第二个后面是用户数量。）

Panic over.
恐慌结束了。
We can now log back in to the application.
现在可以重新登录应用程序。
But how can we stop this from happening again? 
但如何才能防止这样的情况再次发生呢？
There are several ways.
有几种方法。
For example, we could write code that prevents you from deleting your own user.
比如，可以实现防止删除自己的用户账户的代码。
That doesn’t quite work—in theory, A could delete B at just the same time that B deletes A.
理论上说这种做法行不通，A用户可以在B用户删除自己的同时删除B用户。
Instead, let’s try a different approach.
试一下另一种方法。
We’ll delete the user inside a database transaction.
在数据库事务内部删除用户。
If there are no users left after we’ve deleted the user, we’ll roll the transaction back, restoring the user we just deleted.
如果在删除用户之后数据库中没有任何用户，就将该事务回滚，回复刚刚删除的用户。

To do this, we’ll use an Active Record hook method.
使用Active Record钩子方法可以做到这一点。
We’ve already seen one of these: the validate hook is called by Active Record to validate an object’s state.
之前已经介绍过其中的一个方法，Active Record调用validates钩子来验证对象的状态。
It turns out that Active Record defines sixteen or so hook methods, each called at a particular point in an object’s life cycle.
事实上Acitive Record定义了十六种钩子方法，每个都在对象声明周期的特定点调用。
We’ll use the after_destroy() hook, which is called after the SQL delete is executed.
这里使用after_destroy()钩子，它在SQL delete执行之后调用。
If a method by this name is publicly visible, it will conveniently be called in the same transaction as the delete, so if it raises an exception, the transaction will be rolled back.
如果方法名是公共可见的，它会很方便地在与delete相同的事务中调用，因此，如果它引起了一个异常，事务就会被回滚。
The hook method looks like this:
钩子方法如下所示：

    Download rails40/depot_s/app/models/user.rb
    after_destroy :ensure_an_admin_remains
    private
    def ensure_an_admin_remains
      if User.count.zero?
        raise "Can't delete last user"
      end
    end

The key concept here is the use of an exception to indicate an error when deleting the user.
这里的重点是使用异常来指明删除用户时的错误。
This exception serves two purposes.
这个异常有两个意图。
First, because it is raised inside a transaction, it causes an automatic rollback.
第一，因为它于事务中抛出，所以会导致一个自动回滚。
By raising the exception if the users table is empty after the deletion, we undo the delete and restore that last user.
如果users表在删除后为空，通过抛出这个异常可以撤销该删除并恢复用户。

Second, the exception signals the error back to the controller, where we use a begin/end block to handle it and report the error to the user in the flash.
第二，异常信号将错误通知控制器，在控制器中可以使用begin/end块来处理它，并将该错误在闪存中报告给用户。
If you want only to abort the transaction but not otherwise signal an exception, raise an ActiveRecord::Rollback exception instead, because this is the only exception that won’t be passed on by ActiveRecord::Base.transaction.
如果只想终止这个事务而不想报告异常，那么就使用ActiveRecord::RollBack异常，因为它是唯一一个不会通过ActiveRecord::Base.transaction的异常。

    Download rails40/depot_s/app/controllers/users_controller.rb
    def destroy
    ➤ begin
    ➤   @user.destroy
    ➤   flash[:notice] = "User #{@user.name} deleted"
    ➤ rescue StandardError => e
    ➤   flash[:notice] = e.message
    ➤ end
      respond_to do |format|
        format.html { redirect_to users_url }
        format.json { head :no_content }
      end

• 208

This code still has a potential timing issue—it is still possible for two administrators each to delete the last two users if their timing is right.
上述代码还有一个潜在的时机问题——如果时机正确，两个管理员将最后的两个用户删除的可能性依然存在。
Fixing this would require more database wizardry than we have space for here.
要消除这个问题需要更高山的数据库技术，它超出了本书讨论的范围。

In fact, the login system described in this chapter is rather rudimentary.
事实上，在本章中介绍的登陆系统还比较基础。
Most applications these days use a plugin to do this.
当今大多数应用程序都使用插件来实现这个功能。
A number of plugins are available that provide ready-made solutions that not only are more comprehensive than the authentication logic shown here but generally require less code and effort on your part to use.
许多插件都提供现成的解决方案，不仅比这里展示的验证逻辑更全面，而且通常使用起来不需要花费很多代码和精力。
See Section 25.4, Finding More at RailsPlugins.org, on page 418 for a couple of examples.
参见后面418页的25.4节。

## What We Just Did 本章小结
By the end of this iteration, we’ve done the following:
在本次迭代工作中，我们完成了一下几点：
• We used has_secure_password to store an encrypted version of the password into the database.
  创建了代表纯文本格式密码的虚拟属性，并且无论明文密码何时更新，都会创建散列密码。
• We controlled access to the administration functions using before action callbacks to invoke an authorize() method.
  通过使用before过滤器调用authorize()方法来控制管理员功能的访问。
• We saw how to use rails console to interact directly with a model (and dig us out of a hole after we deleted the last user).
  学习如何使用Rails console直接与模型相交互（并解决了删除最后一个用户之后的窘境）。
• We saw how a transaction can help prevent deleting the last user.  
  学习了如何使用事务防止删除最后一个用户。

## Playtime 练习时间
Here’s some stuff to try on your own:
可以自由尝试一下任务：
• Modify the user update function to require and validate the current password before allowing a user’s password to be changed.
  <kinder:note> 修改用户更新功能，在允许用户密码更改之前，要求验证当前用户密码。
Hint: you can add markup specific to a particular action in `_form.html.erb` by adding an if check ensuring that params[:action] is the one you want.
<kinder:note> 提示： 你可以增加一个if检查确保你需要的参数[:action]，在`_form.html.erb`，添加特定标志到一个特定行为
Hint: you can simultaneously retrieve and remove the non-database field from the params hash by using the delete method.
<kinder:note> 提示： 你可以通过使用delete方法做到同时从参数哈希表中获取和删除非数据库字段

<kinder:note> 
Daniel says:

I think Malcolm’s implementation should authenticate before updating the user or else it will update the user and then fail because the password changed.

if @user.authenticate(current_password) && @user.update(user_params)

Malcolm says (10 July 2013):

My implementation.
Extra field in `views/users/_form.html.erb`:

  <% if params[:action] == 'edit' || params[:action] == 'update' %> 
  # 'update' needed or field will disappear when there is an error
  <div class="field">
    <%= f.label :current_password, 'Current password:' %>
    <%= f.password_field :current_password, size: 40 %>
  </div>
  <% end %>

In users_controller.rb:

  def update
    current_password = params[:user].delete(:current_password) 
    # Return and simultaneously delete value
    respond_to do |format|
      if @user.update(user_params) && @user.authenticate(current_password)
        format.html { redirect_to users_url, notice: "User #{@user.name} was successfully updated." }
        format.json { head :no_content }
      else
        @user.errors.add(:current_password, "for user is incorrect") unless @user.authenticate(current_password)
        format.html { render action: 'edit' }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

This will give a consistent-looking error for an incorrect current password field, appearing as if it has failed a model validation (which it of course hasn’t because it’s not a model attribute). 
If there are any validation errors from the other fields they will also appear at the same time. 
The below solutions only seem to operate on the currently logged in user, which could either be a good thing or a bad thing, but I feel like my solution is slightly cleaner and what the book (at least the current edition) was asking for.

malevsilich
in `users/_form.html.erb`:

  <fieldset>
    <legend>Enter user details</legend>
    <div>
      <%= f.label :name %><br />
      <%= f.text_field :name, size: 40 %>
    </div>
    <% if params[:action]=="edit" || params[:action]=="update" %>
      <div>
        <%= f.label :current_password, :class => "long_label" %><br />
        <%= f.password_field :current_password, size: 40 %>
      </div>
    <% end %>
    <div>
      <%= f.label :password %><br />
      <%= f.password_field :password, size: 40 %>
    </div>
    <div>
      <%= f.label :password_confirmation, 'Confirm' %>
      <%= f.password_field :password_confirmation, size: 40 %>
    </div>

    <div>
      <%= f.submit %>
    </div>

  </fieldset>

in `users_controller.rb`:

  def update
    @user = User.find(params[:id])
    cp = params[:user].delete('current_password')
    @user.errors.add(:current_password, 'is not correct') unless @user.authenticate(cp)

    respond_to do |format|
      if @user.errors.empty? and @user.update_attributes(params[:user])
        format.html { redirect_to users_url, notice: "User #{@user.name} was successfully updated." }
        format.json { head :no_content }
      else
        format.html { render action: "edit" }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

in user.rb:

    validates :password, presence: true

somebody

I did something different:

In the `users_controllers.rb`

def edit
  @user = User.find(params[:id])
  params[:action] = :edit
end

def update
  @user = User.find(params[:id])    
  if @user.authenticate(params:user)    
    params[:user].delete :current_password      
    respond_to do |format|      
      if @user.update_attributes(params[:user])
        format.html { redirect_to users_url, notice: "User #{@user.name} was successfully updated." }
        format.json { head :ok }
      else
        format.html { render action: "edit" }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end      
  else
    redirect_to edit_user_path(@user), notice: 'Current password is incorrect'
  end      
end

in the `_form.html.erb` (users) I added:

<% if params[:action] == :edit %>
  <%= f.label :current_password, 'Current password' %> <%= f.password_field :current_password, size: 40 %>
<% end %>

in the edit.html.erb (users) I added:

<% if notice %>
  <%= notice %>
<% end %>

Following line doesn’t display correctly in browser:

if @user.authenticate(params:user)

Instead it should looks like this:

if @user.authenticate(params[:user][:current_password])
</kinder:note> 
<kinder:note> Malcolm的答案是正解。下面我添加一个功能测试：
修改test/controllers/users_controller_test.rb
  test "should update user" do
    patch :update, id: @user, user: { name: @user.name, password: 'secret', password_confirmation: 'secret', current_password: 'secret' }
    assert_redirected_to users_path
  end
</kinder:note> 


• When the system is freshly installed on a new machine, there are no administrators defined in the database, and hence no administrator can log on.
  如果系统是在一台新的机器上刚刚安装的，因为数据库中没有任何管理员。所以没有管理员能登录。
But, if no administrator can log on, then no one can create an administrative user.
但如果没有管理员可以登录，就不能创建管理员用户。

• 209

Change the code so that if no administrator is defined in the database, any username works to log on (allowing you to quickly create a real administrator).
请修改代码，当数据库中没有管理员时，任何用户名都可登录（即允许快速创建管理员）。

Hint: User.count.zero? can be used to determine if there are any existing users.
提示：User.count.zero?可用于判断是否存在用户。

<kinder:note> 论坛上的答案
Alkasai says:

Here is how i did it. This is the OLD code in application_controller.rb:

    def  authorize
        unless  User.find_by_id(session[:user_id]) 
            session[:original_uri]  =  request.request_uri
            #flash[:notice]  =  "You're loged in as #{params[:name]}" 
            redirect_to  :controller  =>  'admin' ,  :action  =>  'login'
        end
    end

And this is the NEW code in application_controller.rb:

      def  authorize
        if User.count == 0 
            if request.path_parameters[:controller] == 'users' and request.path_parameters[:action] == 'create'
                #do nothing. let the users controoler verify that everything is correct 
            elsif !(request.path_parameters[:controller] == 'users' and request.path_parameters[:action] == 'new')
                flash[:notice] = "Please create Admin User" 
                redirect_to :controller => 'users' , :action => 'new'                
            end
        elsif  !User.find_by_id(session[:user_id])
            session[:original_uri]  =  request.request_uri
            redirect_to  :controller  =>  'admin' ,  :action  =>  'login'
        end
    end

This should redirect all the pages to ’/users/new’ (except the ’/store’ of cause), when there are no users in DB. 
However, only page that is not redirected for some reason is ’/admin/login’. 
Anybody knows why?

unknown

This is a quick and dirty solution, just creates a user with the given credentials when no user exists in the database. 
In login_controller.rb:

def login
  session[:user_id] = nil

  if request.post?
    if User.count.zero?
      user = User.create(:name => params[:name],
                         :password => params[:password],
                         :password_confirmation => params[:password])
    else
      user = User.authenticate(params[:name], params[:password])
    end

    if user
      session[:user_id] = user.id
      uri = session[:original_uri]
      session[:original_uri] = nil
      redirect_to(uri || { :action => "index" })
    else
      flash[:notice] = "Invalid user/password combination" 
    end
  end
end

Cosmin Lehene:

This will pass over authorize method like a valid login as long as no users are created in the database and will flash a warning notice permanently. After the first user is created it will ask for credentials.
In application.rb change the authorize method:


def authorize
  unless User.find_by_id(session[:user_id]) or User.count == 0
    session[:original_uri] = request.request_uri
    flash[:notice] = "Please login" 
    redirect_to(:controller => "login", :action => "login")
  end

  if User.count == 0 
    flash[:notice] = "Please create the first user account" 
  end
end
end

Of course, in order to get the required behavior, you have to modify the login action in login_controller.rb also:


def login
  session[:user_id] = nil
  if User.count == 0 
    redirect_to(:action => "add_user")
  elsif 
  [...]

k9d says:

I followed Cosmin’s example except I wanted the user to be redirect to the page where they can create the first user account. To achieve this I modified def authorize in application.rb to look more like this

#...
if User.count == 0 
  flash[:notice] = "Please create the first user account" 
  redirect_to(:controller => "login", :action => "add_user")
end
#...

All is well except the before_filter in login_controller.rb doesn’t allow the un-authorized user to see add_user. Is there a way to work around this problem?

Also, a handy mysql command if you need to manually clear out the last user, to Delete a row(s) from a table>

DELETE from [table name] where [field name] = 'whatever';

Matt says:
To allow an unauthorised user to get to the add_user page, check the path_parameters of the request:


def authorize
  unless User.find_by_id(session[:user_id]) or User.count == 0
    session[:original_uri] = request.request_uri
    flash[:notice] = "Please log in." 
    redirect_to(:controller=>"login", :action=>"login")
  end
  if User.count == 0 
    if request.path_parameters[:action]=="add_user" and request.path_parameters[:controller]=="login" 
      #As we are already on our way to the add_user action, do nothing here.
    else
      flash[:notice] = "Please create an account." 
      redirect_to(:controller=>"login", :action=>"add_user")
    end
  end
end

jwat says:

Matt’s code worked for me. However, as good programming practice, it makes more sense to write the logic for zero user counts as so:


      def authorize
        unless User.find_by_id(session[:user_id]) or User.count == 0
            session[:original_uri] = request.request_uri
            flash[:notice] = "Please log in." 
            redirect_to(:controller=>"login", :action=>"login")
        end
        if (User.count == 0 and request.path_parameters['action'] != "add_user")
                flash[:notice] = "Please create an account." 
                redirect_to(:controller=>"login", :action=>"add_user")
        end
      end

I suppose you can check for the controller params as well, but I didn’t bother.
h3. Dimitris says: 
All you need to do is go to application.rb and change the check in the authorize method to:

    unless User.find_by_id(session[:user_id]) || User.count == 0

In this way, authorization is bypassed if there are no users in the DB. As soon as you create a user, you’re asked to login and everything works as before. 

h3. Valerie says: 

Nice solution, Dimitris! I also added a flash notice, as Cosmin mentioned.

  def authorize
    flash[:notice] = "Please create an admin user" if User.count == 0
    unless User.find_by_id(session[:user_id]) || User.count == 0
      session[:original_uri] = request.request_uri
      flash[:notice] = "Please log in" 
      redirect_to :controller => 'admin', :action => 'login'
    end
  end

Grazybom

Here is my simple solution: admin_controller.rb

  def login
    if request.post?
      user = User.authenticate(params[:name], params[:password])
      if user
        session[:user_id] = user.id
        uri = session[:original_uri]
        session[:original_uri] = nil
        redirect_to(uri || { :action => "index" })
      elsif User.count.zero?
        flash[:notice] = "Create your first administrator account. Please, logout after you have created your new account and login with your new credentials." 
        redirect_to(:controller => "users", :action => "new")  
      else
        flash.now[:notice] = "Invalid user/password combination" 
      end
    end
  end

and application.rb

  def authorize
    unless User.find_by_id(session[:user_id]) or User.count.zero?
      session[:original_uri] = request.request_uri
      flash[:notice] = "Please log in" 
      redirect_to :controller => 'admin', :action => 'login'
    end
  end

Even though, each action is available via get request untill the first account is created.

m1kee

I didn’t like how Grazybom’s solution allowed full access to the entire site as long as there wasn’t any user account created.

Here’s my solution:
app/controllers/application.rb

def authorize
  unless User.find_by_id(session[:user_id]) || User.count.zero?
    session[:original_uri] = request.request_uri
    flash[:notice] = "Please log in" 
    redirect_to(:controller => 'admin', :action => 'login')
  end

  if (User.count.zero?)
    if !(request.path_parameters[:controller] == 'users' and request.path_parameters[:action] == 'new')
      if !(request.path_parameters[:controller] == 'users' and request.path_parameters[:action] == 'create')
        redirect_to(:controller => 'admin', :action => 'login')
      end
    end
  end
end
#...

app/controllers/admin_controller.rb
class AdminController < ApplicationController
  def login
    if User.count.zero?
      redirect_to(:controller => 'users', :action => 'new')
    end
#...

As an addition, to ensure user account creation:
app/controllers/store_controller.rb
class StoreController < ApplicationController
  before_filter :find_cart, :except => :empty_cart

  def index
    if (User.count.zero?)
      redirect_to(:controller => 'admin', :action => 'login')
    end
#...

AndriySand
Hi! I resolved this problem this way. Now I work with Rails 1.8.02 First I commented the method after_destroy in order be able to delete last user.


# def after_destroy
   # if User.count.zero?
     # raise "Can't delete last user" 
   # end
 # end      

Then I wrote ‘except ‘ in ‘login_ controller’ this way in order be able to add user to non-administrator person only once.


before_filter :authorize,:except =>  if User.count == 0 
                                        :add_user 
                                      else 
                                        :login
                                       end 

After I added couple strings of code in ‘authorize’ method in application.rb and this method looks like this


private
  def authorize
    if  User.count == 0  
      flash[:notice] = "Please create first admin" 
      redirect_to(:controller => "login", :action => "add_user")
    else
      unless User.find_by_id(session[:user_id])
        flash[:notice] = "Please log in" 
        redirect_to(:controller => "login", :action => "login")    
      end
    end
  end
end

Good luck to every one!
Pablo says

I’ve solved this problem in very few lines

class ApplicationController < ActionController::Base
  layout "store" 
  before_filter :create_first_admin
  before_filter :authorize, :except => :login
...
    protected
    def create_first_admin
        flash[:notice] = %q{There are currently no users in the database.
        Please create one administrator user} if User.count == 0

        ignore1 = (controller_name+action_name != "usersnew")
        ignore2 = !request.post? || controller_name != "users" 

        if User.count == 0 && ignore1 && ignore2
            session[:user_id] = nil;
            redirect_to :controller => :users, :action => :new
        end 
    end
...
end

Only problem is, I didn’t know how to use the :except option in before_filter so that I can also say that the users controller must be ignored and hence I did it on my own in the function (this is the only part I don’t really like).

I decided that not even the store should be available when there are any user in the database. What is the point of browsing products, adding stuff in the cart, check it out when there is no one that will take your order?
illbzo1 says

Reading through a few of the methods shown above, here’s what I came up with.

First, I add a skip_before_filter method to :users_controller. We don’t want to be redirected while accessing the :new method, or while using it to :create a user.


skip_before_filter :authorize, :only => [:new, :create]

Next we update application_controller. Using an unless/or combination, we can check for either a logged in user, or an absence of users, then apply methods depending on that result.


def authorize
  unless User.find_by_id(session[:user_id]) or User.count.zero?
    redirect_to login_url, :notice => "Please log in" 
  end
  if User.count.zero?
    redirect_to new_user_path, :notice => "Please create a user" 
  end
end
end

MarkB says

I solved this similarly to illbzo1 above. I added

skip_before_filter :authorize, :only => [:new, :create]

to the top of users_controller.rb so that I didn’t get a redirect loop and added the below code to the respond_to block of the create method after the save of the record which checks if there is now only one user in the database and if so, sets the session id to to be that user ID so that the authorize filter will allow the redirect.

        if User.count == 1
          session[:user_id] = User.find_by_name(@user.name).id
        end

I then altered the authorize method in application_controller.rb as below to check for an empty User table and redirect if there is.

  def authorize
    if User.count.zero?
      redirect_to new_user_path, notice: "Please create the first user account" 
    else
      unless User.find_by_id(session[:user_id])
        redirect_to login_url, notice: "Please log in" 
      end
    end
  end

John Lane says

I did this by just creating a user if none exists. The user is created with whatever is entered in the login box:

class SessionsController < ApplicationController
  skip_before_filter :authorize
  def new
  end

  def create
    if User.count == 0
      user = User.new(name: params[:name],
                      password_digest: BCrypt::Password.create(params[:password]))

      user.save
    else
      user = User.find_by_name(params[:name])
    end
    if user and user.authenticate(params[:password]) 
      session[:user_id] = user.id
      redirect_to admin_url
    else
      redirect_to login_url, alert: "Invalid user/password combination" 
    end
  end

  def destroy
    session[:user_id] = nil
    redirect_to store_url, notice: "Logged out" 
  end
end

Pierre says

If no admin is in the database a login of anybody will redirect to users/new to create a new user. After the user is created the login page is displayed to login with the new user just created.
In the session controller I have added rows marked with #*

def create
  if User.count.zero? #*
    redirect_to new_user_path #*
  else #*
    user = User.find_by_name(params[:name])
    # ...
  end #*
end

In the application_controller.rb I have added rows marked with #*

def authorize
  return if User.count.zero? #*

  # ...
end
  
</kinder:note> 
<kinder:note> 我采用的是MarkB的做法，允许普通人注册新的用户
但`if User.count == 1`这一块被我省略。为什们需要这个代码？
允许注册新用户。修改app/controllers/users_controller.rb
skip_before_filter :authorize, :only => [:new, :create]

修改app/controllers/application_controller.rb
  def authorize
    if User.count.zero?
      redirect_to new_user_path, notice: "请先注册用户" 
    else
      unless User.find_by_id(session[:user_id])
        redirect_to login_url, notice: "请先登录网站" 
      end
    end
  end

</kinder:note> 

• Experiment with rails console.
  练习使用rails console。
Try creating products, orders, and line items.
试一试创建产品，订单和商品项目。
 Watch for the return value when you save a model object—when validation fails, you’ll see false returned.
当保存模型对象时看看返回的值——当验证失败时会看到返回false。
Find out why by examining the errors.
通过查看以下错误来找到原因。

    >> prd = Product.new
    => #<Product id: nil, title: nil, description: nil, image_url:
    nil, created_at: nil, updated_at: nil, price:
    #<BigDecimal:246aa1c,'0.0',4(8)>>
    >> prd.save
    => false
    >> prd.errors.full_messages
    => ["Image url must be a URL for a GIF, JPG, or PNG image",
        "Image url can't be blank", "Price should be at least 0.01",
        "Title can't be blank", "Description can't be blank"]

<kinder:note> 
Hint: check out the documentation for full_messages
提示： 参考full_message的文档

Returns all the full error messages in an array.

class Person
  validates_presence_of :name, :address, :email
  validates_length_of :name, in: 5..30
end

person = Person.create(address: '123 First St.')
person.errors.full_messages
# => ["Name is too short (minimum is 5 characters)", "Name can't be blank", "Email can't be blank"]

Source: hide | on GitHub

# File activemodel/lib/active_model/errors.rb, line 355
def full_messages
  map { |attribute, message| full_message(attribute, message) }
end

</kinder:note> 
• Look up the authenticate_or_request_with_http_basic() method and utilize it in your :authorize callback if the request.format is not Mime::HTML.
<kinder:note>查找authenticate_or_request_with_http_basic()方法，在你的:authorize调用中使用它，如果request.format不是Mime::HTML。
Test that it works by accessing an Atom feed.
<kinder:note> 通过访问Atom推送测试它是否运行。

    curl --silent --user dave:secret \
    http://localhost:3000/products/2/who_bought.atom

<kinder:note> 
Hint: check out the documentation for authenticate_or_request_with_http_basic
提示：参考authenticate_or_request_with_http_basic<http://guides.rubyonrails.org/action_controller_overview.html#http-basic-authentication>的文档

Cheng Long says:
Simple solution:

   def authorize
      return if User.count.zero?

      if request.format == Mime::HTML
        user = User.find_by(id: session[:user_id])
      else
        user = authenticate_or_request_with_http_basic do |u, p|
          User.find_by_name(u).try(:authenticate, p)
        end
      end

      redirect_to login_url, notice: "Please log in" unless user
    end

Diego says:

I’ve duplicated the code a little, I do think that there is a better way of doing this but my solution was to add some extra logic in the authorize method of the Application Controller.
I now looks like the following


 def authorize
        if User.count.zero?
          redirect_to new_user_path unless session[:new_user]
          return
        end

        unless User.find_by_id(session[:user_id])
          if request.format == Mime::HTML
            redirect_to login_url, notice: "Please log in" 
          elsif
            if user = authenticate_with_http_basic do |u, p|
                  finded_user = User.find_by_name(u)
                  finded_user.authenticate(p) if finded_user
              end
              session[:user_id] = user.id
            elsif
              render :status => 403, :text => "login failed" and return
            end
          end
        end
      end

I really wanted to redirect to SessionController to do the password check but I couldn’t figure it out how to do it.

Anonymous says:

Taken from http://api.rubyonrails.org/classes/ActionController/HttpAuthentication/Basic.html – Simple Digest example
In products_controller.rb:


class ProductsController < ApplicationController
  skip_before_filter :authorize, :only => [:who_bought]
  before_filter :authorize_digest, :only => [:who_bought]
  ...

In application_controller.rb:


require 'digest/md5'
class ApplicationController < ActionController::Base
  REALM = "SuperSecret" 
  USERS = { "test1" => "1234", #plain text password
            "test2" => Digest::MD5.hexdigest(["test2", REALM, "1234"].join(":")) }  #ha1 digest password

...

def authorize_digest
  authenticate_or_request_with_http_digest(REALM) do |username|
    USERS[username]
  end
end  

Then try http://localhost:3000/products/1/who_bought.atom using the credentials test1/1234 or test2/1234.

Pierre says

Alike Diego’s solution.

http://localhost:3000/products/2/who_bought.xml will ask for the http password, other pages redirect to the login page.


def authorize
  unless request.format == Mime::HTML
    authenticate_or_request_with_http_basic do |n, p|
      user = User.find_by_name(n)
      if user and user.authenticate(p)
        session[:user_id] = user.id
      end
    end
  else
    return if User.count.zero?

    unless User.find_by_id(session[:user_id])
      redirect_to login_url, notice: "Please log in" 
    end
  end
end

Matt says:

I kept it pretty simple. authenticate_or_request_with_http_basic seems to handle returning the correct error on failure, plus I found the “format.any” for a catch-all:


    def authorize
      respond_to do |format|
        format.html do
          unless User.count.zero? or User.find_by(id: session[:user_id])
            redirect_to login_url, notice: "Please log in" 
          end
        end
        format.any do
          authenticate_or_request_with_http_basic do |username, password|
            user = User.find_by_name(username)
            user and user.authenticate(password)
          end
        end
      end
    end

</kinder:note> 
• While we have gotten our tests working by performing a login, we haven’t yet written tests that verify that access to sensitive data requires login.
<kinder:note>我们已经忘了通过运行login来测试，还没有写下测试来验证访问那些要求login的的敏感数据。
Write at least one test that verifies this by calling logout() and then attempting to fetch or update some data that requires authentication.
<kinder:note> 至少写一个测试来验证这个，可通过调用logout()，然后获取或更新一些需要认证的资料。

<kinder:note> 
Hint: authentication errors result in redirections to login_path.
提示： 验证错误会重定向到login_path。

论坛答案：
I added a test to the integration tests, not sure if that’s exactly what they were looking for here.

In carts.yml:

one: 
  id: 12345
two: {}
#  column: value

In user_stories_test.rb:

  test "should fail on access of sensitive data" do
    # login user
    user = users(:one)
    get "/login" 
    assert_response :success
    post_via_redirect "/login", name: user.name, password: 'secret'
    assert_response :success
    assert_equal '/admin', path

    # look at a protected resource
    get "/carts/12345" 
    assert_response :success  
    assert_equal '/carts/12345', path

    # logout user
    delete "/logout" 
    assert_response :redirect
    assert_template "/"      

    #try to look at protected resource again, should be redirected to login page
    get "/carts/12345" 
    assert_response :redirect
    follow_redirect!  
    assert_equal '/login', path      
  end

I ended up with a very simple integration test in user_stories_test.rb

   test "should logout and not be allowed back in" do
      delete "/logout" 
      assert_redirected_to store_url

      get "/users" 
      assert_redirected_to login_url
   end

<kinder:note> 亲自尝试了上面的代码，结果令人沮丧：
Error:
SessionControllerTest#test_should_fail_on_access_of_sensitive_data:
ActionController::UrlGenerationError: No route matches {:action=>"/login", :controller=>"session"}
...
都是诸如此类的错误提示。
</kinder:note> 
</kinder:note> 

(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

# CHAPTER 15 Task J: Internationalization 国际化
## In this chapter, we’ll see 在本章中，我们将学习
• localizing templates and
  本地化模板
• database design considerations for I18n.
  关于I18n数据库涉及的考虑

Now we have a basic cart working, and our customer starts to inquire about languages other than English, noting that her company has a big push on for expansion in emerging markets.
现在已经拥有了一个基本运作的购物车，由于客户公司对新兴市场的大举拓展，仅仅有英语语言的网站已经无法满足要求，他们开始询问在网站中使用其他语言的可能性。
Unless we can present something in a language that visitors to our customer’s website will understand, our customer will be leaving money on the table.
除非顾客能用自己熟悉的语言看的懂网站内容，否则他们不会轻易在该网站上购物，这样就会让客户损失利益。
We can’t have that.
不能让这样的事发生。

 The first problem is that none of us is a professional translator.
首要问题是：我们都不是专业的翻译人员。
 The customer reassures us that this is not something we need to concern ourselves with because that part of the effort will be outsourced.
客户一再保证，无需担忧此事，因为这部分工作将外包出去，
All we need to worry about is enabling translation.
而所要关心的只是实现翻译功能。

Furthermore, we don’t have to worry about the administration pages just yet, because all the administrators speak English.
另外，眼下也不用考虑管理页面，因为所有的管理员都说英语。
What we have to focus on is the store.
只要专注于商店就行了。

That’s a relief—but is still a tall order.
负担是减轻了一些——但仍然是一项艰巨的任务。
We are going to need to define a way to enable the user to select a language, we are going to have to provide the translations themselves, and we are going to have to change the views to use these translations.
需要定义一种方式，让用户可以选择语言，还必须提供翻译，并且得基于这些翻译来调整视图。
But we are up to the task, and armed with a bit of memory of high-school Spanish, we set off to work.
尽管这样，我们还是可以胜任这项任务的，带着一点点高中时学到的西班牙语的残留印象，开始工作。

## 15.1 Iteration J1: Selecting the Locale 选择语言环境
We start by creating a new configuration file that encapsulates our knowledge of what locales are available and which one is to be used as the default.
先从创建一个新的配置文件开始，这个文件概括了一下信息：哪些语言环境是可用的，默认的语言环境是什么。

    Download rails40/depot_s/config/initializers/i18n.rb
    #encoding: utf-8
    I18n.default_locale = :en
    LANGUAGES = [ ['English', 'en'],
                  ["Espa&ntilde;ol".html_safe, 'es']
    ]

• 212

============================================================
Joe asks: 
Joe问：
If We Stick to One Language, Do We Need to Read This Chapter?
如果只使用一种语言，还需要阅读这一章吗？
The short answer is no.
简单来讲是不用。
In fact, many Rails applications are for a small or homogeneous group and never need translating.
实际上，许多Rails的应用程序都用于小型或者由相同地域的人组成的团队，根本不需要翻译。
That being said, pretty much everybody who does find that they need translation agrees that it is best if this is done early.
话虽如此，几乎每个确实觉得自己需要翻译功能的人，都会同意翻译最好早点进行。
So, unless you are sure that translation will not ever be needed, it is our recommendation that you at least understand what would be involved so that you can make an informed decision.
因此，除非十分肯定自己永远不会用到翻译，否则我们还是建议，至少懂得哪些是需要的，这样才能做出明智的决定。

============================================================

This code is doing two things.
这段代码做了两件事。
The first thing it does is use the I18n module to set the default locale.
第一件事，用I18n模型设置默认的语言环境。
I18n is a funny name, but it sure beats typing out internationalization all the time.
I18n是个奇怪的名字，但它一定比每次都要打internationalization方便得多。
Internationalization, after all, starts with an i, ends with an n, and has eighteenletters in between.
究其根源，这么命名是因为Internationalization由i开头，以n结尾，中间有18个字母。

Then it defines a list of associations between display names and locale names.
第二，它定义了显示名称和语言环境名称间的关联列表。
 Unfortunately, all we have available at the moment is a U.S. keyboard, and español has a character that can’t be directly entered via our keyboard.
可惜现阶段只有美式键盘可用，而español里有一个字符是不能用这个键盘直接输入的。
Different operating systems have different ways of dealing with this, and often the easiest way is to simply copy and paste the correct text from a website.
对此，不同的操作系统有不同的解决方法，通常最简单的办法是从网页上复制正确的文本，然后粘帖。
If you do this, just make sure your editor is configured for UTF-8.
如果真是这么做的，一定要确保已将编辑器配置为UTF-8。
Meanwhile, we’ve opted to use the HTML equivalent of “n con tilde” character in Spanish.
同时，这里选择使用HTML中与西班牙“带波浪号的n”相对应的字符。
If we didn’t do anything else, the markup itself would be shown.
如果不做其他事情，这个标记会自动显示。
But by calling html_safe, we inform Rails that the string is safe to be interpreted as containing HTML.
但是当调用html_safe的时候，会通知Rails“把这个字符串解释为包含HTML”是安全的。

To get Rails to pick up this configuration change, the server needs to be restarted.
要让这个配置在Rails中生效，需要重启服务器。

Since each page that is translated will have an en and es version (for now, more will be added later), it makes sense to include this in the URL.
由于每个翻译过的页面都将会有一个英语版本（en）和一个西班牙语版本（es）（只现在是这样，以后会加入更多东西），因此把I18n包含到URL里是合理的。
Let’s plan to put the locale up front, make it optional, and have it default to the current locale, which in turn will default to English.
语言环境计划放在最前面，设为可选，并且将默认配置设为当前语言环境，按照次序，它将默认为英语。

To implement this cunning plan, let’s start with modifying config/routes.rb.
要实现这个巧妙的计划，可以从修改config/routes.rb开始。

    Download rails40/depot_s/config/routes.rb
    Depot::Application.routes.draw do
      get 'admin' => 'admin#index'
      controller :sessions do
        get 'login' => :new
        post 'login' => :create
        delete 'logout' => :destroy
      end
      get "sessions/create"
      get "sessions/destroy"
      resources :users
      resources :products do
        get :who_bought, on: :member
      end
    ➤ scope '(:locale)' do
        resources :orders
        resources :line_items
        resources :carts
        root 'store#index', as: 'store', via: :all
    ➤ end
    end

• 213

What we have done is nested our resources and root declarations inside a scope declaration for :locale.
上面这段代码所做的事情是，在对:local的范围声明中嵌套资源和根地址声明。
Furthermore, :locale is in parentheses, which is the way to say that it is optional.
另外，这里:local在括号里，声明它是可选的。
Note that we did not choose to put the administrative and session functions inside this scope, because it is not our intent to translate them at this time.
注意，这里没有选择把管理和会话功能放在这个范围中，因为不打算在这个时候就翻译它们。

What this means is that both http://localhost:3000/ will use the default locale, namely, English, and therefore be routed exactly the same as http:// localhost:3000/en.
这表明，两个http://localhost:3000/都将使用默认的语言环境，也就是英语，因此这两个页面都会被引导到与http://localhost:3000/en完全一样的路径。
http://localhost:3000/es will route to the same controller and action, but we will want this to cause the locale to be set differently.
http://localhost:3000/es将路由到同一个控制器和动作，但它应该产生不同的语言环境设置。

At this point, we’ve made a lot of changes to config.routes, and with the nesting and all the optional parts to the path, the gestalt might be hard to visualize.
<kinder:note> 现在，我们已经对config.routs文件修改了很多，有嵌套，有路径的可选部分，它的形态已经很难一眼看清了。
Never fear: when running a server in development mode, Rails provides a visual aid.
<kinder:note> 不用担心：开发模式下运行服务器，Rails会提供视图的。
All you need to do is navigate to http://localhost:3000/rails/info/routes, and you’ll see a list of all your routes, as shown in Figure 40, A list of all of the active routes, on page 214.
<kinder:note>
需要你做的事情是进入http://localhost:3000/rails/info/routs，你会看到你的路由列表显示出来，就像下页的图表那样。
More information on the fields shown in this table can be found in the description of rake routes on page 312.
<kinder:note> 表格中字段的更多信息可见后面312页的描述。

With the routing in place, we are ready to extract the locale from the parameters and make it available to the application.
路由就位，我们准备从参数中解压locale，以便应用程序使用。
To do this, we need to create a before_action callback and to set the default_url_options.
完成这项工作，需要创建before_action回调，设置default_url_options。
The logical place to do both is in the common base class for all of our controllers, which is ApplicationController.
在所有控制器的公共基类，即ApplicationController内修改是比较合理的。

• 214

Figure 40—A list of all of the active routes

      Download rails40/depot_s/app/controllers/application_controller.rb
      class ApplicationController < ActionController::Base
    ➤   before_action :set_i18n_locale_from_params
        # ...
    ➤   protected
    ➤   def set_i18n_locale_from_params
    ➤     if params[:locale]
    ➤       if I18n.available_locales.map(&:to_s).include?(params[:locale])
    ➤         I18n.locale = params[:locale]
    ➤       else
    ➤         flash.now[:notice] = "#{params[:locale]} translation not available"
    ➤         logger.error flash.now[:notice]
    ➤       end
    ➤     end
    ➤   end
    ➤   def default_url_options
    ➤     { locale: I18n.locale }
    ➤   end
    ➤ end

This set_i18n_locale_from_params does pretty much what it says: it sets the locale from the params, but only if there is a locale in the params; otherwise, it leaves the current locale alone.
set_i18n_locale_from_params做的事情和它名字的描述大概一致——从参数中取值来设置对话框的语言环境——前提是在参数中有语言环境的值；否则，不会去修改它。
Care is taken to provide a message for both the user and the administrator when there is a failure.
在碰到错误时，会同时给用户和管理员提供错误信息。

• 215

And default_url_options also does pretty much what it says, in that it provides a hash of URL options that are to be considered as present whenever they aren’t otherwise provided.
default_url_options的工作也和名字描述相似，在其中它提供了一个URL选项的散列，无论是否设置这些选项，都认为其是存在的。
In this case, we are providing a value for the :locale parameter.
本例给`:locale`参数设定一个值。
This is needed when a view on a page that does not have the locale specified attempts to construct a link to a page that does.
当一个未设定语言环境的页面视图尝试建立一个链接，并指向已设定语言环境的页面时，这是必要的。
We will see that in use soon.
我们将在使用中很快看到这种青岛。

With this in place, we can see the results in the following figure:
做好这些之后，更新后页面可以看到如下图所示的结果：

Figure 41—English version of the front page
图表41-英语版的首页

At this point, the English version of the page is available both at the root of the website and at pages that start with /en.
现在，网站根地址和以/en开头的页面都可以访问版的页面了。
Additionally, a message on the screen says that the translation is not available (as we can see in Figure 42, Translation not available, on page 216), which will also leave a message in the log indicating that the file wasn’t found.
另外，显示屏上有一条消息，说明目前西班牙语的翻译还不可用（见下一页的图示），与此同时，日志中也会留下信息，写明文件未找到。
It might not look like it, but that’s progress.
也许还并不完美，但已经有了进步。

## 15.2 Iteration J2: Translating the Storefront 翻译在线商店页面
Now it is time to begin providing the translated text.
至此，是时候开始提供翻译文本了。
Let’s start with the layout, because it is pretty visible.
现在将从版面设计入手，因为它非常直观。
We replace any text that needs to be translated with calls to I18n.translate.
我们将调用I18n.translate来替代所需翻译的文本。
Not only is this method conveniently aliased as I18n.t, but there also is a helper provided named t.
这个方法不仅有简单的别名I18n.t，而且还有一个称为t的帮助程序。

The parameter to the translate function is a unique dot-qualified name.
翻译函数的参数名称是唯一的，且以点缀方式命名。
We can choose any name we like, but if we use the t helper function provided, names that start with a dot will first be expanded using the name of the template.
可以选择任何喜欢的名字，但如果使用提供的t帮助函数，以点开始的名称会首先按模板名展开。
So, let’s do that.
那么就可以这样来实现。

• 216

Figure 42—Translation not available
图示42--翻译不可用

    Download rails40/depot_s/app/views/layouts/application.html.erb
    <!DOCTYPE html>
    <html>
    <head>
      <title>Pragprog Books Online Store</title>
      <%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true %>
      <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
      <%= csrf_meta_tags %>
    </head>
    <body class="<%= controller.controller_name %>">
      <div id="banner">
        <%= image_tag("logo.png") %>
    ➤   <%= @page_title || t('.title') %>
      </div>
      <div id="columns">
        <div id="side">
          <% if @cart %>
            <%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
              <%= render @cart %>
            <% end %>
          <% end %>
          <ul>
    ➤       <li><a href="http://www...."><%= t('.home') %></a></li>
    ➤       <li><a href="http://www..../faq"><%= t('.questions') %></a></li>
    ➤       <li><a href="http://www..../news"><%= t('.news') %></a></li>
    ➤       <li><a href="http://www..../contact"><%= t('.contact') %></a></li>
          </ul>

• 217

          <% if session[:user_id] %>
            <ul>
              <li><%= link_to 'Orders', orders_path %></li>
              <li><%= link_to 'Products', products_path %></li>
            <li><%= link_to 'Users', users_path %></li>
          </ul>
          <%= button_to 'Logout', logout_path, method: :delete %>
        <% end %>
      </div>
      <div id="main">
        <%= yield %>
      </div>
    </div>
    </body>
    </html>

Since this view is named layouts/application.html.erb, the English mappings will expand to en.layouts.application.
因为这个视图命名为layouts/application.html.erb，其英语映射将被扩展为en.layouts.application。
Here’s the corresponding locale file:
下面是相关的语言环境文件。

    Download rails40/depot_s/config/locales/en.yml
    en:
      layouts:
        application:
          title:      "Pragmatic Bookshelf"
          home:       "Home"
          questions:  "Questions"
          news:       "News"
          contact:    "Contact"

Here it is in Spanish:
然后是西班牙语的：

    Download rails40/depot_s/config/locales/es.yml
    es:
      layouts:
        application:
          title:      "Publicaciones de Pragmatic"
          home:       "Inicio"
          questions:  "Preguntas"
          news:       "Noticias"
          contact:    "Contacto"

The format is YAML, the same as the one used to configure the databases.
格式为YAML，和配置数据库时用的一样。
YAML simply consists of indented names and values, where the indentation in this case matches the structure that we created in our names.
YAML仅仅由缩进式名称和值构成，这里的缩进与命名时创建的结构匹配。

YAML ↪ on page 48

• 218

To get Rails to recognize that there are new YAML files, the server needs to be restarted.
需要重启网络服务器，Rails才能识别出新的YAML文件。
At this point, we can see in the following figure the actual translated text appearing in our browser window:
至此，可以在浏览器中看到实际翻译好的文本了。

Figure 43—Baby steps: translated titles and sidebar
图示43--最初的一步：翻译好的标题和侧边栏

Next to be updated is the main title as well as the Add to Cart button.
下一步需要更新的是主标题和Add to Cart按钮。
Both can be found in the store index template.
在商店的索引模板中可以找到它们。

    Download rails40/depot_s/app/views/store/index.html.erb
      <% if notice %>
        <p id="notice"><%= notice %></p>
      <% end %>
    ➤ <h1><%= t('.title_html') %></h1>
      <% cache ['store', Product.latest] do %>
        <% @products.each do |product| %>
          <% cache ['entry', product] do %>
            <div class="entry">
              <%= image_tag(product.image_url) %>
              <h3><%= product.title %></h3>
              <%= sanitize(product.description) %>
              <div class="price_line">
                <span class="price"><%= number_to_currency(product.price) %></span>
    ➤           <%= button_to t('.add_html'), line_items_path(product_id: product), remote: true %>
              </div>
            </div>
          <% end %>
        <% end %>
      <% end %>

• 219

And here’s the corresponding updates to the locales files, first in English:
下面是语言环境文件相关更新，首先是英语的。

    Download rails40/depot_s/config/locales/en.yml
    en:
      store:
        index:
          title_html: "Your Pragmatic Catalog"
          add_html: "Add to Cart"

and then in Spanish:
然后是西班牙语的：

    Download rails40/depot_s/config/locales/es.yml
    es:
      store:
        index:
          title_html: "Su Cat&aacute;logo de Pragmatic"
          add_html: "A&ntilde;adir al Carrito"

Note that since `title_html` and `add_html` end in the characters `_html`, we are free to use HTML entity names for characters that do not appear on our keyboard.
注意，由于title_html和add_html都以字符`_html`结尾，因此可以自由地把没有出现在键盘上的字符作为HTML的实体名来来对待。
If we did not name the translation key this way, what you would end up seeing on the page is the markup.
如果不这样命名翻译键，最桌在网页上看到的是标记本身。
This is yet another convention that Rails has adopted to make your coding life easier.
这又是Rails的另一个约定，它让变成生活更轻松。
Rails will also treat names that contain html as a component (in other words, the string .html.) as HTML key names.
Rails也可以处理那些包含html的名称（换句话说，含字符`.html`），把它们看作HTML的键名。

By refreshing the page in the browser window, we see the results shown in Figure 44, Translated heading and button, on page 220.
通过刷新浏览器窗口的页面，可以看到结果，如下一页220的图示44所示：
Feeling confident, we move on to the cart partial.
我们信心倍增，接着进入购物车部分。

    Download rails40/depot_s/app/views/carts/_cart.html.erb
    ➤ <h2><%= t('.title') %></h2>
      <table>
        <%= render(cart.line_items) %>
        <tr class="total_line">
          <td colspan="2">Total</td>
          <td class="total_cell"><%= number_to_currency(cart.total_price) %></td>
        </tr>
      </table>
    ➤ <%= button_to t('.checkout'), new_order_path, method: :get %>
    ➤ <%= button_to t('.empty'), cart, method: :delete, data: { confirm: 'Are you sure?' } %>

And again, here are the translations:
和前面一样，语言环境的翻译：

• 220

Figure 44—Translated heading and button

    Download rails40/depot_s/config/locales/en.yml
    en:
      carts:
        cart:
          title:     "Your Cart"
          empty:     "Empty cart"
          checkout:  "Checkout"

    Download rails40/depot_s/config/locales/es.yml
    es:
      carts:
        cart:
          title:     "Carrito de la Compra"
          empty:     "Vaciar Carrito"
          checkout:  "Comprar"

Refreshing the page, we see the cart title and buttons have been translated (Figure 45, Carrito bonita, on page 221).
<kinder:note> 刷新页面，我们看到购物车的标题和按钮已经翻译好了（下页的图示45）。 

We now notice our first problem.
现在注意第一个问题。
Languages are not the only thing that varies from locale to locale; currencies do too.
不单单是语言会因地域而改变，货币也会。
And the customary way that numbers are presented varies too.
并且显示数字的习惯方法也五花八门。

• 221

Figure 45—Carrito bonita
图示45--

So, first we check with our customer, and we verify that we are not worrying about exchange rates at the moment (whew!), because that will be taken care of by the credit card and/or wire companies, but we do need to display the string “USD” or “$US” after the value when we are showing the result in Spanish.
因此，首先跟客户确认，正是我们此刻不必担心汇率（太好了），因为那时信用卡或电汇公司需要关注的，但是在显示西班牙语页面的价格数值时，得在其后标注“USD”或者“$US”字样。

Another variation is the way that numbers themselves are displayed.
另一个变化是显示数字的方式。
Decimal values are delimited by a comma, and separators for the thousands place are indicated by a dot.
小数用逗号分割，千位的分隔符是一个点。

Currency is a lot more complicated than it first appears, and that’s a lot of decisions to be made.
货币的问题比预想的更复杂些，需要做很多决定。
Fortunately, Rails knows to look in your translations file for this information; all we need to do is supply it.
幸运的是，Rails直到要在翻译文件中寻找到这条信息，这里所需要做的仅仅是提供这条信息。
Here it is for en:
首先是英语版：

    Download rails40/depot_s/config/locales/en.yml
    en:
      number:
        currency:
        format:
          unit:       "$"
          precision:  2
          separator:  "."
          delimiter:  ","
          format:     "%u%n"

<kinder:note> %u是单位，%n是数字。如$49.5是%u%n，而49.5$则是%n$u。

• 222

Here it is for es:
接下来是西班牙语版：

    Download rails40/depot_s/config/locales/es.yml
    es:
      number:
        currency:
          format:
            unit:       "$US"        
            precision:  2
            separator:  ","
            delimiter:  "."
            format:     "%n&nbsp;%u"

We’ve specified the unit, precision, separator, and delimiter for number.currency.format. 
这里已经为number.currency.format明确规定了单位、精度、分隔符和小数点。
That much is pretty self-explanatory.
一切不言自明。
The format is a bit more involved:
格式则有些复杂：
%n is a placeholder for the number; &nbsp; is a nonbreaking space character, preventing this value from being split across multiple lines; and %u is a placeholder for the unit (see Figure 46, Mas dinero, por favor., on page 223).
%n是数字的占位符；`%nbsp;`代表一个不间断空格的字符，可防止这个值在多行中分开；%u是单位的占位符（详见下一页223页的图示46）。

## 15.3 Iteration J3: Translating Checkout 翻译结帐页面
Now we feel that we are in the home stretch. The new order page is next.
现在我们感觉已经进入最后阶段了。

    Download rails40/depot_s/app/views/orders/new.html.erb
    <div class="depot_form">
      <fieldset>
    ➤   <legend><%= t('.legend') %></legend>
        <%= render 'form' %>
      </fieldset>
    </div>

Here is the form that is used by this page:
这个页面使用的表单是：

    Download rails40/depot_s/app/views/orders/_form.html.erb
    <%= form_for(@order) do |f| %>
      <% if @order.errors.any? %>
        <div id="error_explanation">
          <h2><%= pluralize(@order.errors.count, "error") %>
          prohibited this order from being saved:</h2>
          <ul>
            <% @order.errors.full_messages.each do |msg| %>
              <li><%= msg %></li>
            <% end %>
          </ul>
        </div>
      <% end %>

• 223

Figure 46—Mas dinero, por favor.

        <div class="field">
    ➤ 
          <%= f.label :name, t('.name') %><br>
          <%= f.text_field :name, size: 40 %>
        </div>
    ➤   <div class="field">
          <%= f.label :address, t('.address_html') %><br>
          <%= f.text_area :address, rows: 3, cols: 40 %>
        </div>
    ➤   <div class="field">
          <%= f.label :email, t('.email') %><br>
          <%= f.email_field :email, size: 40 %>
        </div>
    ➤   <div class="field">
    ➤     <%= f.label :pay_type, t('.pay_type') %><br>
          <%= f.select :pay_type, Order::PAYMENT_TYPES, prompt: t('.pay_prompt_html') %>
        </div>
        <div class="actions">
    ➤     <%= f.submit t('.submit') %>
        </div>
      <% end %>

<kinder:note> 这一句在本版被删去：
请注意，除非想做些特殊的事情，如允许使用HTML实体，通常不会在标签中显性调用I18n函数。
</kinder:note> 
Here are the corresponding locale definitions:
下面是对应的本地化定义：

• 224


    Download rails40/depot_s/config/locales/en.yml
    en:
      orders:
        new:
          legend: "Please Enter Your Details"
          form:
            name: "Name"
            address_html: "Address"
            email: "E-mail"
            pay_type: "Pay with"
            pay_prompt_html: "Select a payment method"
            submit: "Place Order"

    Download rails40/depot_s/config/locales/es.yml
    es:
      orders:
        new:
          legend: "Por favor, introduzca sus datos"
          form:
            name: "Nombre"
            address_html: "Direcci&oacute;n"
            email: "E-mail"
            pay_type: "Forma de pago"
            pay_prompt_html: "Seleccione un m&eacute;todo de pago"
            submit: "Realizar Pedido"


See Figure 47, Ready to take your money—in Spanish, on page 225 for the completed form.
看看下一页225图示47显示的完整表单。

All looks good until we hit the Realizar Pedido button prematurely and see the results shown in Figure 48, Translation missing, on page 225.
一切都看起来很不错，但我们贸然单击Realizar按钮，看到的下页225图示48出现的结果。
The error messages that Active Record produces can also be translated; what we need to do is supply the translations.
Active Record模块产生的这些错误信息也是可以翻译的，所需要的是提供翻译：

    Download rails40/depot_s/config/locales/es.yml
    es:
      activerecord:
        errors:
          messages:
            inclusion: "no est&aacute; incluido en la lista"
            blank:     "no puede quedar en blanco"
        errors:        
          template:    
            body:      "Hay problemas con los siguientes campos:"
            header:    
              one:     "1 error ha impedido que este %{model} se guarde"
              other:   "%{count} errores han impedido que este %{model} se guarde"

• 225

Figure 47—Ready to take your money—in Spanish
图示47--准备付款——西班牙语

Figure 48—Translation missing
图示48—— 找不到翻译

Note that messages with counts typically have two forms: errors.template.header.one is the message that is produced when there is one error, and errors.template.header.other is produced otherwise.
注意，带计数功能的信息通常有两种格式：error.template.header.one是在有一个错误时产生的信息，而在其他情况下则使用error.template.header.other。
This gives the translators the opportunity to provide the correct pluralization of nouns and to match the verbs with the nouns.
这个翻译人员有机会提供正确的复数名字，还能给名词匹配正确的动词。

• 226

Since we once again made use of HTML entities, we will want these error messages to be displayed as is (or in Rails parlance, raw).
由于再次使用HTML实体，我们希望显示的这些错误信息和现在一样（也就是Rails中说的原始值）
We will also need to translate the error messages.
还需要调整错误信息的翻译。
So again, we modify the form.
这样，我们修改表单：

    Download rails40/depot_t/app/views/orders/_form.html.erb
    <%= form_for(@order) do |f| %>
      <% if @order.errors.any? %>
        <div id="error_explanation">
    ➤     <h2><%=raw t('errors.template.header', count: @order.errors.count,
    ➤                  model: t('activerecord.models.order')) %>.</h2>
    ➤     <p><%= t('errors.template.body') %></p>
          <ul>
            <% @order.errors.full_messages.each do |msg| %>
    ➤         <li><%=raw msg %></li>
            <% end %>
          </ul>
        </div>
      <% end %>
      <!-- ... -->

Note that we are passing the count and model name (which is, itself, enabled for translation) on the translate call for the error template header.
注意，为错误信息的模板标头调用翻译函数时，给该调用传递了总数和模型名称（这个模型本身已经实现了翻译。
 With these changes in place, we try again and see improvement in the following figure:
坐了这些改变后，再次尝试可看到下图的改进：

Figure 49—English nouns in Spanish sentences
图示49——西班牙语句中的英语名词

That’s better, but the names of the model and attributes bleed through the interface.
看起来好了一些，但模型名称和属性还暴露在界面上。
This is OK in English, because the names we picked work for English.
这在英语界面中没有问题，因为所选的名字在英语界面中也能用。
We need to provide translations for each.
需要给每个语言版本都提供翻译。

• 227

This, too, goes into the YAML file.
同样，在YAML文件中修改。

    Download rails40/depot_t/config/locales/es.yml
    es:
      activerecord:
        models:
          order:        "pedido"
        attributes:     
          order:        
            address:    "Direcci&oacute;n"
            name:       "Nombre"
            email:      "E-mail"
            pay_type:   "Forma de pago"

Note that there is no need to provide English equivalents for this, because those messages are built in to Rails.
注意给英语界面提供翻译是没有必要的，因为那些信息在Rails中是内置的。
We are pleased to see the model and attribute names translated in the following figure; we fill out the form, we submit the order, and we get a “Thank you for your order” message.
我们很高兴看到模型和属性的名称已经翻译好了（见下图）；填好表单，提交订单，然后收到“Thank you for your order”的信息。

Figure 50—Model names are now translated too.
图示50——模型名称也翻译好了。

We need to update the flash messages.
需要更新闪存信息。

    Download rails40/depot_t/app/controllers/orders_controller.rb
    def create
      @order = Order.new(order_params)
      @order.add_line_items_from_cart(@cart)
      respond_to do |format|
        if @order.save

• 228

              Cart.destroy(session[:cart_id])
              session[:cart_id] = nil
              OrderNotifier.received(@order).deliver
              format.html { redirect_to store_url, notice:
        ➤                   I18n.t('.thanks') }
              format.json { render action: 'show', status: :created,
                            location: @order }
            else
              format.html { render action: 'new' }
              format.json { render json: @order.errors, status: :unprocessable_entity }
            end
          end
        end

Finally, we provide the translations.
最后提供翻译：

    Download rails40/depot_t/config/locales/en.yml
    en:
      thanks: "Thank you for your order"

    Download rails40/depot_t/config/locales/es.yml
    es:
      thanks: "Gracias por su pedido"

See the cheery message in the next figure:
就能看到下图所示的开心的信息了。

Figure 51—Thanking the customer in Spanish
图示51——西班牙语版谢谢惠顾

• 229

## 15.4 Iteration J4: Add a Locale Switcher 添加语言环境的切换器

We’ve completed the task, but we really need to advertise its availability more.
虽然任务已经完成了，但还需要更多地宣传其可用性。
We spy some unused area in the top-right side of the layout, so we add a form immediately before the image_tag.
我们发现在版面的右上角还有一些空白的区域，于是马上在image_tag前添加一个表单：

    Download rails40/depot_t/app/views/layouts/application.html.erb
       <div id="banner">                                       
    ➤    <%= form_tag store_path, class: 'locale' do %>
    ➤      <%= select_tag 'set_locale',
    ➤        options_for_select(LANGUAGES, I18n.locale.to_s),
    ➤        onchange: 'this.form.submit()' %>
    ➤      <%= submit_tag 'submit' %>
    ➤      <%= javascript_tag "$('.locale input').hide()" %>
    ➤    <% end %>
         <%= image_tag("logo.png") %>
         <%= @page_title || t('.title') %>
       </div>

The form_tag specifies the path to the store as the page to be redisplayed when the form is submitted.
提交表单时，form_tag指定商店的路径作为重新显示的页面。
A class attribute lets us associate the form with some CSS.
class属性允许表单和某些CSS练习起来。

The select_tag is used to define the one input field for this form, namely, locale.
select_tag用来为这个表单定义输入栏，即语言环境。
It is an options list based on the LANGUAGES array that we set up in the configuration file, with the default being the current locale (also made available via the I18n module).
他是一个可选列表，可供选择的内容基于配置完美中设置的LANGUAGE数组，默认选项是当前的语言环境（也可以由I18n模型提供）。
<kinder:note> 这个模型位于何处？
We also set up an onchange event handler, which will submit this form whenever the value changes.
还设置了一个onchange事件句柄，用来在值有所改变的时候随时提交这个表单。
This works only if JavaScript is enabled, but it is handy.
虽然只有启用JavaScript时它才运行，但它是有用处的。

Then we add a submit_tag for the cases when JavaScript is not available.
接下来加入submit_tag来应对浏览器没有启用JavaScript的情况。
To handle the case where JavaScript is available and the submit button is unnecessary, we add a tiny bit of JavaScript that will hide each of the input tags in the locale form, even though we know that there is only one.
一旦JavaScript是可用的，提交按钮就多余了；为了处理这个情况，增加了一点JavaScript来隐藏语言环境表单中的每一个输入标签，即使已知只有一个标签。

Next, we modify the store controller to redirect to the store path for a given locale if the :set_locale form is used.
下一步是修改商店控制器，如果使用了:set_locale表单，这个控制器将对给定的语言环境重新定位商店的路径。

      Download rails40/depot_t/app/controllers/store_controller.rb
      def index
    ➤   if params[:set_locale]
    ➤     redirect_to store_url(locale: params[:set_locale])
    ➤   else
          @products = Product.order(:title)
    ➤   end
      end

Finally, we add a bit of CSS.
最后，加一点CSS。

• 230

    Download rails40/depot_t/app/assets/stylesheets/application.css.scss
    .locale {
      float: right;
      margin: -0.25em 0.1em;
    }

For the actual selector, see the following figure.
真实的选择器效果在下面的图示。
We can now switch back and forth between languages with a single mouse click.
现在通过单击鼠标就可以切换语言了。

Figure 52—Locale selector in top right
图示52——右上角的语言选择器

At this point, we can now place orders in two languages, and our thoughts turn to actual deployment.
至此，可以用两种语言下订单了，于是我们决定下一步转向实际部署。
But because it has been a busy day, it is time to put down our tools and relax.
但因为已经忙碌了一整天，是时候放下手头的工作放松放松了。
We will start on deployment in the morning.
明天早上再开始部署。

## What We Just Did 本章小节
By the end of this iteration, we’ve done the following:
在这个迭代里，做了一下事情。
• We set the default locale for our application and provided a means for the user to select an alternate locale.
  为应用程序设置了默认的语言环境，并且为用户提供了一种方式，可以选择适当的语言环境。
• We created translation files for text fields, currency amounts, errors, and model names.
  为文本输入框、货币数量、错误信息和模型名称创建了翻译文件。
• We altered layouts and views to call out to the I18n module by way of the t() helper in order to translate textual portions of the interface.
  为翻译界面的文本部分，修改了版面和视图，让它们可以使用t帮助程序来调用I18n模块。

• 231

## Playtime 练习时间
Here’s some stuff to try on your own:
可以自己尝试一下任务：
• Add a locale column to the products database, and adjust the index view to select only the products that match the locale.
  在产品数据库中增加一个语言环境字段，调整索引视图，让它只选择与语言环境匹配的产品。
Adjust the products view so that you can view, enter, and alter this new column.
改变产品视图，以便可以查看、输入和修改这个新字段。
Enter a few products in each locale, and test the resulting application.
在每个语言环境里输入一些产品，然后测试生成的应用程序。

• Determine the current exchange rate between U.S. dollars and euros, and localize the currency display to display euros when ES_es is selected.
确定当前美元和欧元之间的汇率，将显示本地化，当选中ES_es时，显示欧元及其对应的金额。

• Translate the Order::PAYMENT_TYPES shown in the drop-down.
  翻译下拉框中显示的Order::PAYMENT_TYPES。
You will need to keep the option value (which is sent to the server) the same.
让选择的值保持一致（它将被发送到服务器上）。
Change only what is displayed.
只改变所显示出的类型。

(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

# CHAPTER 16 Task K: Deployment and Production  部署和生产
## In this chapter, we’ll see
在本章中，我们将学习
• running our application in a production web server,
  在生产Web服务器上运行应用程序。
• configuring the database for MySQL,
  为MySQL配置数据库
• using Bundler and Git for version control, and
  用Bundler和Git进行版本管理
• deploying our application using Capistrano.
  用Capistrano部署应用程序

Deployment is supposed to mark a happy point in the lifetime of our application.
部署是应用程序制作周期中令人高兴的标志性时刻。
It’s when we take the code that we’ve so carefully crafted and upload it to a server so that other people can use it.
在这个时刻，我们把精心制作的代码上传到服务器上，供他人使用。
It’s when the beer, champagne, and hors d’oeuvres are supposed to flow.
在这个时刻，大家开始了庆祝。
Shortly thereafter, our application will be written about in Wired magazine, and we’ll be overnight names in the geek community.
此后不久，连线杂志将会报道该应用程序，然后我们在计算机奇才界将一夜成名。

The reality, however, is that it often takes quite a bit of up-front planning in order to pull off a smooth and repeatable deployment of your application.
然而现实并非如此，要完成流畅且可重复的应用程序部署，往往需要相当长时间的前期规划。
By the time we are through with this chapter, our setup will look like the following figure:
在本章结束的时候，设置将如下图所示：

                 +----+                  +------+
        +------->| git|----------------->|  git |
        |        +----+                  +------+
        |           ^                      |  |
        |           |                      |  |
    +------+     +----+                    |  |
    | Gems |     |Code|                    |  |
    +------+     +----+                    |  |
        ||         ||                       \/
        \|         |/                   +---------+
        +-----------+     +------+      | Apache /| 
        |  WEBrick  |---->| User |<-----|Passenger|
        +-----------+     +------+      +---------+
              ^                              ^
              |                              |
        +------------+                  +----------+
        |   SQLite3  |                  |  MySQL   |
        +------------+                  +----------+

Figure 53—Application deployment road map
图示53——应用程序部署的路线

• 234

At the moment, we’ve been doing all of our work on one machine, though user interaction with our web server could be done on a separate machine.
目前，尽管用户和Web服务器间的交互可以在另一台单独的机器上完成，但所有工作仍然一直在同一台机器上进行。
In the figure, the user’s machine is in the center, and the WEBRick web server is on the left.
在上页的图示中，用户的机器位于中心，WEBRrick网络服务器在左边。
This server makes use of SQLite3, various gems you have installed, and your application code.
这台服务器会使用SQLite3、安装各种gem以及应用程序的代码。
Your code may or may not have also been placed in Git by this point; either way, it will be by the end of the chapter, as will be the gems you are using.
这个时候，你的代码可能已经放在了Git中，也可能没有；有两种方式可以把代码放到Git中：一种会在本章的结尾介绍，一种是利用正在使用的gem。

This Git repository will be replicated on the production server, which again could be another machine but need not be.
Git存储库在产品服务器上会被复制，这个产品服务器可以是另一台机器，但这不是必需的。
This server will be running a combination of Apache httpd and Phusion Passenger.
这个服务器将会在装有Apache httpd和Phusion Passenger的机器上运行。
This code will access a MySQL database on what may yet be a fourth machine.
而这部分代码会访问MySQL数据库，该数据库可能在第四台机器上。

Capistrano will be the tool we use to update the deployment server(s) remotely, safely, and repeatably from the comfort of our development machine.
Capistrano是用来更新部署服务器的工具，它可以远程地、安全地、重复地在开发机器的舒适环境中完成更新。

That’s a lot of moving parts!
这涉及到许多可移动部件！
Instead of doing it all at once, we will do it in three iterations. 
我们不打算一步到位，而是把工作分为三个迭代。
Iteration K1 will get the Depot application up and running with Apache, MySQL, and Passenger—a truly production-quality web server environment.
迭代K1让Depot应用程序运行起来，并且和Apache、MySQL以及Passenger一起运行——这是一个真正高质量产品Web服务器环境。
We will leave Git, Bundler, and Capistrano to a second iteration.
Git，Bundler，Capistrano会放在第二个迭代中。
These tools will enable us to separate our development activities from our deployment environment.
这些工具能够把开发活动从部署环境中分离出来。
This means that by the time we are done, we will be deploying twice; but that’s only this first time and only to ensure that each part is working independently.
这意味着在完成时，要部署两次；但这仅仅是在第一次部署时需要做的，其目的只是想确保每个部件都在独立工作。
It also allows us to focus on a smaller set of variables at any one time, which will simplify the process of untangling any problems that we might encounter.
开发活动和部署环境的独立性也允许可以在任何时候把重点放在一个较小的变量集合上，对那些可能会遇到的问题，这将简化解决问题的过程。

In a third iteration, we will cover various administrative and cleanup tasks.
在第三个迭代，将介绍各种管理和清除任务。
Let’s get started!
这就开始吧！

## 16.1 Iteration K1: Deploying with Phusion Passenger and MySQL 部署PM
### 引言
So far, as we’ve been developing a Rails application on our local machine, we’ve probably been using WEBrick when we run our server.
到目前为止，已经在本地机器上开发了一个Rails应用程序，在运行服务器时，也许已经使用了WEBRick或Mongrel。
For the most part, it doesn’t matter.
大多数情况下，这没有问题。
The rails server command will sort out the most appropriate way to get our application running in development mode on port 3000.
`rails server`命令将挑选出最适当的方式来让该应用程序在开发模式上运行，端口为3000.

However, a deployed Rails application works a bit differently.
但是，部署后的Rails应用程序的工作原理有点不同。
We can’t just fire up a single Rails server process and let it do all the work.
不能只开启一个单一的Rails服务器进程来完成所有工作。
Well, we could, but it’s far from ideal.
如果硬要这么做，结果会很不理想。
The reason for this is that Rails is single-threaded.
因为Rails是单线程的。
It can work on only one request at a time.
它一次只能处理一个请求。

• 235

==============================
Joe asks: Can We Deploy to Microsoft Windows?
Joe问：可以部署到Microsoft Windows吗？
Although we can deploy applications to Windows environments, the overwhelming amount of Rails tools and shared knowledge assumes a Unix-based operating system such as Linux or Mac OS X.
虽然可以把应用程序部署到Windows环境中，但是大量的Rails工具和共享知识都假设其使用环境是Unix基操作系统，比如Linux或Mac OS X。
One such tool, Phusion Passenger, is highly recommended by the Ruby on Rails development team and covered in this chapter.
其中诸如Passenger工具就是这样，它得到Ruby on Rails开发团队的强烈推荐，内容会在本章中有所涵盖。

The techniques described in this chapter can be used by those deploying to Linux or Mac OS X.
本章描述的技术可以用于Windows上进行开发，然后在Linux或Mac OS X上部署的应用程序。

==============================

The Web, however, is an extremely concurrent environment.
然而， Web是一个极度并发的环境。
Production web servers, such as Apache, Lighttpd, and Zeus, can work on several requests —even tens or hundreds of requests—at the same time.
生产Web服务器，例如Apache、Lighttpd、Zeus，都可以同时处理多个请求（有时甚至几十或者几百个）。
A single-process, single-threaded Ruby-based web server can’t possibly keep up.
一个基于Ruby的单进程、单线程的Web服务器不可能跟上这个速度。
Luckily, it doesn’t have to keep up.
幸运的是，它不需要和产品网络服务器齐头并进。
Instead, the way we deploy a Rails application into production is to use a front-end server, such as Apache, to handle requests from the client.
相反，把Rails应用程序部署到生产环境中的方式是：使用诸如Apache的前端服务器来处理客户端的请求。
Then, you use the HTTP proxying of Passenger to send requests that should be handled by Rails to one of any number of back-end application processes.
然后，用Passenger的HTTP代理把那些需要Rails处理的请求发送给任意数量的后端应用程序进程。

### 16.1.1 Configuring a Second Machine  配置第二台机器 
<kinder:note> 本章2版没有，全是我自己翻译的。
If you have a second machine you can use, that’s great.
要是你有另一台可用的机器，就太棒了。
If not, you can use a virtual machine.
要是没有，可以使用虚拟机。
There’s plenty of free software you can use for this purpose, such as VirtualBox1 and Ubuntu.2 
有很多自由软件都可达到这个目的，比如VirtualBox和Ubuntu。
If you go with Ubuntu, we recommend 12.04 LTS.
如果你用Ubuntu，我们推荐12.04LTS版。

Configure this machine using the instructions in Chapter 1, Installing Rails, on page 3.
配置机器时，可使用第3页第一章的介绍。
If you like, you can skip the step of installing Rails and instead install Bundler.
如果你喜欢，可以跳过安装Rails这一步，直接安装Bundle。

    $ gem install bundler

Next, copy your entire directory containing the Depot application from your first machine to your second machine.
接下来，将第一台机器里包含Depot应用程序的目录整个地复制到第二台机器中。
On the second machine, change into that directory and use Bundler to install all of your application’s dependencies.
在第二台机器上，转到那个目录，使用Bundler来安装应用程序依赖的组件。

    $ bundle install

Verify that your installation is working using any combination of the following commands:
使用下面的命令组合来验证安装是否成功：

1. https://www.virtualbox.org/
2. http://www.ubuntu.com/download/desktop

• 236

    $ rake about
    $ rake test
    $ rails server

At this point you should be able to launch a browser on either machine and see your application.
这样你就可以打开任意机器的浏览器查看应用程序了。
Once you’re satisfied that your application is running correctly, stop the server.
如果你对程序的正确运行感到满意，停掉服务器。

These steps of copying directories and starting and stopping servers aren’t generally something you want your application developers to be doing, and by the time we’re done with this chapter this will all be automated.
复制目录、启动服务器、停止服务器，这些步骤一般不是应用程序开发者所做的事情，现在我们这一章所做的事全是自动化的。
But for now, knowing what the steps are and that the intermediate results are correct has established the base upon which we can build our deployment.
但现在，知道了每一步的走法以及正确的结果，将为我们构建部署奠定了基础。

### 16.1.2 Installing Passenger 安装Passenger
The next step is to ensure that the Apache web server is installed and running on our second machine.
下一步是确保部署机安装并运行了Apache web服务器。
Linux users should have already installed Apache in Section 1.3, Installing on Linux, on page 6.
<kinder:note> Linux用户应该在前面第6页的1.3节中安装了Apache。
For Mac OS X users, it’s already installed with the operating system, but you’ll need to enable it.
<kinder:note> 对于Mac OS X用户来说，操作系统已经自带了这个软件，只需要你启用它。
For Mac OS X releases prior to 10.8, this can be accomplished by going into System Preferences > Sharing and enabling Web Sharing.
<kinder:note> Mac OS X 10.8之前的版本，可通过"系统首选项>共享"启用Web共享来完成。

Starting with Mac OS X 10.8, this needs to be done via the Terminal application.
<kinder:note> Starting with Mac OS X 10.8及之后的版本，需要通过终端来完成。

    $ sudo apachectl start
    $ sudo launchctl load -w /System/Library/LaunchDaemons/org.apache.httpd.plist

The next step is to install Passenger.
下一步是安装Passenger。

        $ gem install passenger --version 4.0.8
        $ passenger-install-apache2-module

If the necessary dependencies are not met, the latter command will tell you what you need to do.
如果没有满足必要的包依赖关系，第二条命令会说明需要做什么。
For example, on a Ubuntu 13.04 (Raring Ringtail), you will find that you need to install libcurl4-openssl-dev, apache2-prefork-dev, libapr1-dev, and libaprutil1-dev.
比如，在Ubuntu13.04上，需要安装libcurl4-openssl-dev，apche2-prefork-dev，libapr1-dev和libaprutil1-dev。
If this happens, follow the provided instructions, and try the Passenger install command again.
如果发生这种情况，按照提供的说明操作，然后再试一次Passenger的安装命令。

Once the dependencies are satisfied, this command causes a number of sources to be compiled and the configuration files to be updated.
一旦满足了包依赖关系，这条命令会编译许多源代码，并且更新配置文件。
During the process, it will ask us to update our Apache configuration.
过程中，它会让用户更新Apache的配置。
The first will be to enable your freshly built module and will involve adding lines such as the following to our Apache configuration.
第一步是启用新建的模块，然后在Apache的配置中添加新的行，内容如下：
(Note: Passenger will tell you the exact lines to copy and paste into this file, so use those, not these.
（注意，Passenger会给出要复制粘帖到配置中的确切内容，因此请使用Passenger告知的那些，而不是书中的这些。
Also, we’ve had to elide the path specification in the LoadModule line to make it fit the page.
另外，为了符合页面大小，书中将LoadModule一行对折了。
输入时，所有内容都要写成一行。）
Be sure to use the path specification that Passenger provided for you.)
<kinder:note> 确保使用Passenger提供的路径规范。）

• 237

    LoadModule passenger_module /home/rubys/.rvm/.../ext/apache2/mod_passenger.so
    PassengerRoot /home/rubys/.rvm/gems/ruby-2.0.0-p0/gems/passenger-4.0.1
    PassengerDefaultRuby /home/rubys/.rvm/wrappers/ruby-2.0.0-p0/ruby

To find out where your Apache configuration file is, try issuing the following command:
可以通过以下命令来确定Apache的配置文件的位置：

    $ apachectl -V | grep HTTPD_ROOT
    $ apachectl -V | grep SERVER_CONFIG_FILE

On some systems, the command name is apache2ctl; on others, it’s httpd.
在一些系统中，命令的名字是apache2ctl；而有的系统是httpd。
Experiment until you find the correct command.
试一试就能发现正确的命令。

Instead of modifying this file directly, most modern systems have conventions that allow you to maintain your extensions separately.
<kinder:note> 无需直接修改这个文件，现在的大多数系统都有允许你独立维护扩展的管理。
On Mac OS X, for example, you may see the following line at the end of your httpd.conf file:
<kinder:note> 比如在 Mac OS X，你可以看到下面这一行出现在httpd.conf文件的结尾。

    Include /private/etc/apache2/other/*.conf

If you see this line in your httpd.conf, you can put the lines that Passenger provided into a passenger.conf file in that directory.
<kinder:note> 如果你看到，可以将Passenger提供的那些行放在该目录下的passenger.conf文件中。
On Ubuntu you can put these lines into /etc/apache2/conf.d/passenger.
<kinder:note> 在 Ubuntu，你可以放进/etc/apache2/conf.d/passenger。


### 16.1.3 Deploying Our Application Locally  在本地部署应用程序
The next step is to deploy our application.
下一步是部署应用程序。
Whereas the previous step needs to be done only once per server, this step is actually once per application.
前面的步骤每个服务器只需要做一次，而这一步需要每个应用程序都做一次。

Substitute your host’s name and your application’s directory path in the following ServerName line:
用你的主机名称替换下面代码中ServerName后的内容：

    <VirtualHost *:80>
      ServerName depot.yourhost.com
      DocumentRoot /home/rubys/deploy/depot/public/
      <Directory /home/rubys/deploy/depot/public>
        AllowOverride all
        Options -MultiViews
        Order allow,deny
        Allow from all
      </Directory>
    </VirtualHost>

Note that the DocumentRoot is set to our public directory in our Rails application and that we mark the public directory as readable.
注意这儿的DocumentRoot设置为Rails应用程序的public目录。
Again, your Apache installation may have conventions for the best place to put these instructions.
<kinder:note> 再次，将这一块放在你的Apache安装位置中按惯例最适合的地方。
On Mac OS X, check your httpd.conf for the following (possibly commented-out) line:
在 Mac OS X，用下面这行（可能被注释掉了）检查httpd.conf。

    #Include /private/etc/apache2/extra/httpd-vhosts.conf

• 238

If this line is present, consider uncommenting the line and replacing the dummy-host.example.com with your host.
如果该行存在，取消注释，用你的主机替换dummy-host.com。
<kinder:note> 这行没有dummy-host.com啊。已核过原文，确实如此。
On Ubuntu, the convention is to place these lines in a file in the /etc/apache2/sitesavailable directory and then to separately enable the site.
在 Ubuntu，惯例是将这些行放进/etc/apache2/sitesavailable 目录，然后独立地启用站点。
For example, if you named the file depot, then the site can be enabled using the following command:
比如，你将文件命名为depot，该站点可用下面命令启用：

    sudo a2ensite depot

If you have multiple applications, repeat this VirtualHost block once per application, adjusting the ServerName and DocumentRoot in each block.
如果想用相同的apache Web服务器为多个应用程序服务，为每个应用程序重复一遍这个VirtualHost代码块，调整每块的ServerName额DocumentRoot。
You will also need to verify that the following line is present in the configuration files already:
也需要先确认下面这行内容已经在配置文件里。（<kinder:note> ubuntu中该文件是/etc/apache2/sites-available/defaut）

    NameVirtualHost *:80

If this line is not present, add it before a line that contains the text Listen 80.
如果配置文件中没有上述内容，那么在包含Listen 80文本的前一行加上它。

The final step is to restart our Apache web server.
最后一步是重启Apache Web服务器。

    $ sudo apachectl restart

You will now need to configure your client so that it maps the host name you chose to the correct machine.
现在需要配置客户端，以便它能把所有的主机名映射到正确的机器上。
This is done in a file named /etc/hosts.
可以在/etc/hosts文件中做。
On Windows machines, this file can be found in C:\windows\system32\drivers\etc\.
若是视窗系统，可以在C:\windows\system32\driver\etc路径下找到这个文件。
To edit this file, you will need to open the file as an administrator.
以管理员身份打开它，即可编辑该文件。

A typical /etc/hosts line will look like the following:
典型的/etc/hosts行如下：

    127.0.0.1 depot.yourhost.com

That’s it!
这就是所有工作了。
We can now access our application using the host (or virtual host) we specified.
现在可以用指定的主机（或者虚拟主机）访问该应用程序了。
Unless we used a port number other than 80, there is no longer any need for us to specify a port number on our URL.
除非使用了另一个非80端口号，否则不必在URL中指定端口号。

There are a few things to be aware of.
下面是一些注意事项：

• If when restarting your server you see a message that The address or port is invalid, this means the NameVirtualHost line is already present, perhaps in another configuration file in the same directory.
  如果重启服务器时看到“The address or port is invalid（地址或端口无效）”这样的信息，这表明NameVirtualHost行已经存在，也许在相同目录的另一个配置文件中。
If so, remove the line you added because this directive needs to be present only once.
如果这样，删除增加的NameVirtualHost行，因为这条指令只需要出现一次。

• If we want to run in an environment other than production, we can include a RailsEnv directive in each VirtualHost in our Apache configuration.
  如果想在其他环境，而不是在产品环境中运行，可以在Apache配置的每个VirtualHost中包含一条RailsEnv指令：

    RailsEnv development 

• We can restart our application without restarting Apache at any time by updating or creating a file named restart.txt in the tmp of our application.
  通过在应用程序的tmp目录下升级或创建名为restart.txt的文件，可以随时重启应用程序，而不重启Apache：

    $ touch tmp/restart.txt

• 239

• The output of the passenger-install-apache2-module command will tell us where we can find additional documentation.
  passenger-install-apache2-module命令的输出会告知哪里可以找到更多的文档。

### 16.1.4 Using MySQL for the Database 使用MySQL数据库
The SQLite website3 is refreshingly honest when it comes to describing what this database is good at and what it is not good at.
SQLite网站的坦诚着实让人记忆犹新，它说明了这个数据库擅长什么，又不擅长什么。
In particular, SQLite is not recommended for high-volume, high-concurrency websites with large datasets.
尤其在大容量、高并发且需要处理大型数据集合的网站上，不推荐使用SQLite。
And, of course, we want our website to be such a website.
当然，我们想开发的正是这样的网站。

There are plenty of alternatives to SQLite, both free and commercial.
有很多可以替代SQLite的选择，免费的、商业的都有。
We will go with MySQL.
我们选择MySQL。
It is available via your native packaging tool in Linux, and an installer is provided for OS X on the MySQL website.4 
<kinder:note> 通过Linux的原生软件包工具可以获得它，它的网站上也提供了OS X的安装器。

The Mac OS X ver.10.7 (x86, 64-bit), DMG Archive version works fine on 10.8.
<kinder:note> Mac OS X 10.7版（x86,64位），DMG存档版可在10.8上运行。

If you don’t want to sign up, look for the No thanks, just take me to the downloads! link at the bottom of the page.
<kinder:note> 如果你不想登录，可在页面底部查找`No thanks, just take me to the down load!`链接。

In addition to installing the MySQL database, you will also need to add the mysql gem to the Gemfile.
除了安装MySQL数据库，还需要在Gemfile中添加mysql的gem：

    Download rails40/depot_t/Gemfile
    group :production do
      gem 'mysql2'
    end

By putting this gem in group production, it will not be loaded when running in development or test.
把这个gem放到production组中，在开发或测试中运行时，就不会载入它。
If you like, you can put the sqlite3 gem into (separate) development and test groups.
如果喜欢，可以把sqlite3 gem（分别）放入development或test组中。

Install the gem using bundle install.
使用`bundle install`来安装gem。
You may need to locate and install the MySQL database development files for your operating system first.
可能需要为操作系统先定位并安装MySQL数据库开发文件。
On Ubuntu, for example, you will need to install libmysqlclient-dev.
例如在 Ubuntu，必须安装libmysqlclient-dev。

You can use the mysql command-line client to create your database or if you’re more comfortable with tools such as phpmyadmin or CocoaMySQL, go for it.
可以使用mysql命令行客户端来创建数据库，或者倘若对诸如phpmyadmin或CocoaMySQL这样的工具得心应手，尽管拿来使用：

    depot> mysql -u root                                                 # 似乎应该是>mysql -u root -p
    mysql> CREATE DATABASE depot_production DEFAULT CHARACTER SET utf8;  # 这个depot_production的名字可要记住了，下面yaml文件要填入的。
    mysql> GRANT ALL PRIVILEGES ON depot_production.*                    # 这是授权
        ->     TO 'username'@'localhost' IDENTIFIED BY 'password';
    mysql> EXIT;

3.  http://www.sqlite.org/whentouse.html
4.  http://dev.mysql.com/downloads/mysql/

• 240

If you picked a different database name, remember it, because you will need to adjust the configuration file to match the name you picked.
如果选择了不同的数据库名称，那要记住它，因为将需要调整配置文件来匹配所选择的名称。
Let’s look at that configuration file now.
现在看看配置文件。

The config/database.yml file contains information on database connections.
config/database.yml文件包含有关数据库连接的信息。
It contains three sections, one each for the development, test, and production databases.
它包含三个部分，分别对应于开发、测试和产品环境数据库。
The current production section contains the following: 
当前的产品环境部分包括一下内容：

    production: 
      adapter: sqlite3 
      database: db/production.sqlite3 
      pool: 5 
      timeout: 5000 

We replace that section with something like the following:
用和下面相似的内容替换这个部分：

    production:
      adapter: mysql2
      encoding: utf8
      reconnect: false
      database: depot_production
      pool: 5
      username: username
      password: password
      host: localhost

Change the username, password, and database fields as necessary.
必要时改变username（用户名）、password（密码）和数据库字段。

### 16.1.4 Loading the Database 加载数据库
Next, we apply our migrations.
接下来实施迁移。

    depot> rake db:setup RAILS_ENV="production"

One of two things will happen.
有两种情况可能发生。
If all is set up correctly, you will see output like the following:
如果一切都设置正确，会看到如下输出：

    -- create_table("carts", {:force=>true})
    -> 0.1722s
    -- create_table("line_items", {:force=>true})
    -> 0.1255s
    -- create_table("orders", {:force=>true})
    -> 0.1171s
    -- create_table("products", {:force=>true})
    -> 0.1172s
    -- create_table("users", {:force=>true})
    -> 0.1255s
    -- initialize_schema_migrations_table()
    -> 0.0006s
    -- assume_migrated_upto_version(20121130000008, "db/migrate")
    -> 0.0008s

• 241

If instead you see an error of some sort, don’t panic! 
要是看到某种错误，不要惊慌！
It’s probably a simple configuration issue. 
可能是很简单的配置问题。
Here are some things to try:
可以试试下面这些方法：
• Check the name you gave for the database in the production: section of database.yml.
  在database.yml的`production:`部分，核对给数据库定义的名称。
It should be the same as the name of the database you created (using mysqladmin or some other database administration tool).
它应该和所创建的数据库名称一致（使用mysqladmin或其他数据库管理工具）。
• Check that the username and password in database.yml match what you used when you created the database on page 239.
  检查database.yml中的用户名和密码，它们要与前面上一节239页中创建的内容匹配。

• Check that your database server is running.
  检查数据库服务器是否运行。
• Check that you can connect to it from the command line. 
  检查能否用命令行连接数据库服务器。
If using MySQL, run the following command:
如果用MySQL，可以用以下命令来测试：

    depot> mysql depot_production
    mysql>

• If you can connect from the command line, can you create a dummy table?
如果可以从命令行连接，试试能否创建一个虚拟表？
(This tests that the database user has sufficient access rights to the database.)
（这可以测试该数据库用户是否有足够的权限来存取数据库。）

    mysql> create table dummy(i int);
    mysql> drop table dummy;

• If you can create tables from the command line but rake db:migrate fails, double-check the database.yml file.
  如果可以从命令行成功创建数据库表，但是`rake db:migrate`失败，那么再确认一次database.yml文件。
If there are socket: directives in the file, try commenting them out by putting a hash character (#) in front of each.
如果该文件中存在`socket:`指令，试着在每行开头处用#号注释掉。

• If you see an error saying No such file or directory… and the filename in the error is mysql.sock, your Ruby MySQL libraries can’t find your MySQL database.
如果看到“No such file or
directory……”（这没有这样的文件或目录）的错误，并且该错误中的文件名为mysql.sock，那表明Ruby MySQL库找不到MySQL数据库。
This might happen if you installed the libraries before you installed the database or if you installed the libraries using a binary distribution and that distribution made the wrong assumption about the location of the MySQL socket file.
在安装数据库之前安装了Ruby MySQL库，oven安装该库所使用的二进制版本对MySQL套接字文件的位置做出了错误的假设，都有可能引发这个错误。
To fix this, the best idea is to reinstall your Ruby MySQL libraries.
要修改这个错误，最后的办法是重装Ruby MySQL库。
If this isn’t an option, double-check that the socket: line in your database.yml file contains the correct path to the MySQL socket on your system.
如果不想重装，那么再次检查database.yml文件中的`socket:`一行，确保它包含了到系统MySQL套接字的正确路径。

• If you get the error Mysql not loaded, it means you’re running an old version of the Ruby MySQL library.
  如果遇到“Mysql not loaded”（MySQL没有加载）的错误，说明所用的Ruby
MySQL库版本太旧。
Rails needs at least version 2.5.
Rails至少需要2.5版。

• Some readers also report getting the error message Client does not support authentication protocol requested by server; consider upgrading MySQL client.
一些读者也反馈他们碰到了这样的错误信息“Client does not support authentication protocol requested by server; consider upgrading MySQL client.”（客户端不支持服务器请求的认证协议，请升级MySQL客户端。）
To resolve this incompatibility between the installed version of MySQL and the libraries used to access it, follow the instructions at http://dev.mysql.com/doc/mysql/en/old-client.html and issue a MySQL command such as
要解决MySQL安装版本和存取库之间不兼容的问题，请按照这里的说明操作：http://dev.mysql.com/doc/mysql/en/old-client.html，并且发出一条这样的MySQL命令：

    set password for 'some_user'@ 'some_host' = OLD_PASSWORD('newpwd');.

• 242

• If you’re using MySQL under Cygwin on Windows, you may have problems if you specify a host of localhost.
  若是在Windows的Cygwin上使用MySQL，也许会在指定localhost主机时遇到问题。
Try using 127.0.0.1 instead.
这是可以试试127.0.0.1看。

• Finally, you might have problems in the format of the database.yml file.
The YAML library that reads this file is strangely sensitive to tab characters.
最后，有可能碰到database.yml文件格式的问题。
YAML库对Tab键出奇地敏感。
If your file contains tab characters, you’ll have problems.
如果你的文件中包含Tab键，就会有问题。
(And you thought you’d chosen Ruby over Python because you didn’t like Python’s significant whitespace, eh?) 
（这时回想起当初选择ruby而不是python，是因为不喜欢Python别有含义的空格键，对吧？）

Rerun the rake db:setup as many times as you need to in order to correct any configuration issues you may have.
不断运行`rake db:setup`，直到所有的配置都正确为止。

If all this sounds scary, don’t worry.
如果这一切听起来吓人，别担心。
In reality, database connections work like a charm most of the time.
现实中，数据库连接在大多数时候都很有效。
And once you have Rails talking to the database, you don’t have to worry about it again.
一旦Rails可以和数据库沟通，就无需再担心这部分的问题了。

At this point, you are up and running.
现在一切都设置好，并且运行起来了。
Nothing looks any different when you are running as a single user.
和运行单一用户时没有什么不同。
The differences become apparent only when you have a large number of concurrent users or a large database.
只有当大量并发用户或大型数据库时，差异才会变得明显。

The next step is to split our development from our production machine.
下一步是把开发重产品环境机器中分离出来。

## 16.2 Iteration K2: Deploying Remotely with Capistrano 用Capistrano远程部署
### 16.2.0 引言
If you are a large shop, having a pool of dedicated servers that you administer so that you can ensure that they are running the same version of the necessary software is the way to go.
假设有一家大型商店，拥有一群可管理的专用服务器，以便可以确保这些服务器和预想的一样，运行着相同版本的必要软件。
For more modest needs, a shared server will do, but we will have to take additional care to deal with the fact that the versions of software installed may not always match the version that we have installed on our development machine.
对于不太重要的需求，共享服务器就可以做到这一点，但是需要格外留心的是：安装的软件版本可能不会总是和开发机器上安装的版本匹配。

Don’t worry, we’ll talk you through it.
别担心，我们会帮你度过这一关。

### 16.2.1 Prepping Your Deployment Server 准备号部署服务器
Although putting our software under version control is a really, really, really good idea during development, not putting our software under version control when it comes to deployment is downright foolhardy—enough so that the software that we have selected to manage your deployment, namely, Capistrano, all but requires it.
在开发过程中把软件放在版本管理之下真是一个非常棒的主意，而在部署时不这么做则是十足的蛮干——因此，选择用来管理部署的软件，也就是Capistrano要求必须要有版本管理。

Plenty of software configuration management (SCM) systems are available.
有很多软件配置管理系统可供选择。
Subversion, for example, is a particularly good one.
例如Subversion，就是特别好的一个。
But if you haven’t yet chosen one, go with Git, which is easy to set up and doesn’t require a separate server process.
但是如果还没有选择任何一个，可以试试Git，它容易设置，并且不要求单独的服务器进程。
The examples that follow will be based on Git, but if you picked a different SCM system, don’t worry.
下面的例子都是基于Git的，但如果选择了其他的SCM系统，也不用担心。

• 243

Capistrano doesn’t much care which one you pick, just so long as you pick one.
Capistrano不太介意你选了哪个，只要有就好了。

The first step is to create an empty repository on a machine accessible by your deployment servers.
第一步是：在部署服务器可以访问到的机器上创建一个空的储存器。
In fact, if we have only one deployment server, there is no reason that it can’t do double duty as your Git server.
实际上，如果只有一个部署服务器，完全有理由把它同时作为Git服务器和部署服务器。
So, log onto that server, and issue the following commands:
现在，登录到那个服务器，输入下面的命令：

    $ mkdir -p ~/git/depot.git
    $ cd ~/git/depot.git
    $ git --bare init   # 预备仓库

The next thing to be aware of is that even if the SCM server and our web server are the same physical machine, Capistrano will be accessing our SCM software as if it were remote.
要明白的下一件事情是，即使SCM服务器和Web服务器是在同一台机器上，Capistrano也会把SMC软件当作远程的来访问。
We can make this smoother by generating a public key (if you don’t already have one) and then using it to give ourselves permission to access our own server.
可以通过生成公共密钥来让这个过程更顺畅（如果没有密钥），然后当访问自己的服务器时，用它给出权限：

    $ test -e ~/.ssh/id_dsa.pub || ssh-keygen -t dsa  # 这条命令首先检查是否存在密钥，若不存在则创建一个
    $ cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys  # 导入公共密钥

Test this by ssh’ing into your own server.
用ssh连接到自己服务器的方法，可以测试公共密钥是否正常工作。
Among other things, this will ensure that your known_hosts file is updated.
除此之外，这么做还将更新`known_hosts`文件。

While we are here, we have one last thing to attend to.
到这里，应该注意另外两件事情。
Capistrano will insert a directory named current between our application directory name and the Rails subdirectories, including the public subdirectory.
Capistrano将在应用程序目录名和Rails子目录之间插入名为current的目录，其中包括public子目录。
This means you will have to adjust your DocumentRoot and Directory lines in your httpd.conf if you control your own server or in a control panel for your shared host.
这意味着，如果自行管理自己的服务器，那么必须调整在httpd.conf文件中的DocumentRoot的设置，或者在共享主机的控制面板中修改：

    DocumentRoot /home/rubys/deploy/depot/current/public/

    <Directory /home/rubys/deploy/depot/current/public>

Restart your Apache server.
<kinder:note> 重启Apache服务器。
You will see a warning that the depot/current/public directory doesn’t exist.
<kinder:note> 发现警告说depot/current/public目录不存在。
That’s fine, because we will be creating it shortly.
<kinder:note> 这就对了，因为我们很快要创建它。

Finally, ensure that the changes you made to your Gemfile and config/database.yml are copied from the Depot application on your second machine to the Depot application on your first machine.
<kinder:note> 最后，确保把你对Gemfile和config/database.yml的修改，从第二个机器上的Depot应用程序处复制到你第一个机器上的Depot应用程序。

That’s it for the server! 
服务器就是这样了。
From here on out, we will be doing everything from your development machine.
从这里开始，将在开发机器上完成所有工作。

### 16.2.2 Getting an Application Under Control 把应用程序放在版本控制之下
The first thing we are going to do is update our Gemfile to indicate that we are using Capistrano.
第一步是更新Gemfile，以表明正在使用Capistrano。

• 244

      Download rails40/depot_t/Gemfile
      # Use Capistrano for deployment
    ➤ gem 'rvm-capistrano', group: :development

All users will need to uncomment out that one line.
<kinder:note> 所有用户都需要取消该行的注释。
RVM users will need to add the characters rvm- where indicated.
RVM用户需要添加字符rvm-指明。

We can now install Capistrano using bundle install.
现在使用`bundle install`安装Capistrano。
We used this command in Iteration G3 on page 192 to install the bcrypt-ruby gem.
前面192页迭代G3中，曾使用这个指令来安装bcrypt-ruby包。

If you haven’t already put your application under configuration control, do so now.
如果还没有把应用程序放在配置管理之下，现在来做这件事情：

    $ cd your_application_directory
    $ git init
    $ git add .
    $ git commit -m "initial commit"

This next step is optional but might be a good idea if either you don’t have full control of the deployment server or you have many deployment servers to manage.
下一步可选，但倘若没有完全控制部署服务器，或者要管理许多部署服务器，这一步可能会很有帮助。
We are going to use a second feature of Bundler, namely, the package command.
这将使用Bundle的另一个功能，package命令。
What it does is put the version of the software that you are dependent on into the repository.
就是把所有依赖的软件版本放到储存库中。

    $ bundle package
    $ git add Gemfile.lock vendor/cache
    $ git commit -m "bundle gems"

We will explain more of the features of Bundler in Section 24.3, Managing Dependencies with Bundler, on page 397.
后面397页24.3节会详细介绍Bundle的功能。
From here, it is a simple matter to push all your code out to the server.
从这里开始，把所有代码放到服务器上最简单的：

    $ git remote add origin ssh://user@host/~/git/depot.git
    $ git push origin master

Be sure to substitute user and host with the name of your user and host on the remote machine.
<kinder:note> 确保将user和host替换为你远程机器的用户名和主机名。

With these few steps, you have gained control over what is being deployed.
经过这几步，就已经获得了正在部署内容的控制权。
You control what is being committed to your local repository.
你控制着那些提交到本地存储库中的内容。
You control when this is being pushed out to your server.
也控制着什么时候把它们清理出服务器。
Next up, you will control putting this code into production.
下一步，控制把代码放到生产环境中。

### 16.2.3 Deploying the Application Remotely 远程部署应用程序
We previously deployed the application locally on a server.
之前在服务器上本地部署了应用程序。
Now we are going to do a second deployment, this time remotely.
现在要进行另一个部署，这一次将远程操作。

• 245

The prep work is now done.
预备工作已经完成。
Our code is now on the SCM server where it can be accessed by the app server.
现在代码在SCM服务器上， 并且可以用应用服务器访问。
Again, it matters not whether these two servers are the same; what is important here are the roles that are being performed.
和前面一样，这两个服务器是否相同并不重要，重要的是所扮演的角色

To add the necessary files to the project for Capistrano to do its magic, execute the following command:
要让Capistrano发挥神奇功效，需要给这个项目添加一些必要的文件，执行下面的命令：

    $ capify .
    [add] writing './Capfile'
    [add] writing './config/deploy.rb'
    [done] capified!

From the output, we can see that Capistrano set up two files.
从输出可以看出，Capistrano设置了两个文件。
The first, Capfile, is Capistrano’s analog to a Rakefile.
第一个文件名为Capfile，是Capistrano对Rakefile的模拟。
You need to uncomment out one line.
<kinder:note> 你需要将第一行消除注释。
After you do this, you won’t need to touch this file further.
今后就不用接触这个文件了。

      Download rails40/depot_t/Capfile
      load 'deploy'
      # Uncomment if you are using Rails' asset pipeline
    ➤ load 'deploy/assets'
      load 'config/deploy' # remove this line to skip loading any of the default tasks

The second file, namely, config/deploy.rb, contains the recipes needed to deploy our application.
第二个文件，顾名思义，config/deploy.rb，包含部署应用程序所需要的方法。
Capistrano will provide us with a minimal version of this file, but the following is a somewhat more complete version that you can download and use as a starting point.
Capistrano 将会提供该文件的简单版本；下面这个版本有些复杂，可以下载来当作修改的起始点：

      Download rails40/depot_t/config/deploy.rb
      require 'bundler/capistrano'
      # be sure to change these
      set :user, 'rubys'
      set :domain, 'depot.pragprog.com'
      set :application, 'depot'
      # adjust if you are using RVM, remove if you are not
      set :rvm_type, :user
      set :rvm_ruby_string, 'ruby-2.0.0-p247'
      require 'rvm/capistrano'
      # file paths
      set :repository, "#{user}@#{domain}:git/#{application}.git"
      set :deploy_to, "/home/#{user}/deploy/#{application}"
      # distribute your applications across servers (the instructions below put them
      # all on the same server, defined above as 'domain', adjust as necessary)
      role :app, domain
      role :web, domain
      role :db, domain, :primary => true
      
• 246

      # 特殊任务：
      # you might need to set this if you aren't seeing password prompts
      # default_run_options[:pty] = true
    
      # As Capistrano executes in a non-interactive mode and therefore doesn't cause
      # any of your shell profile scripts to be run, the following might be needed
      # if (for example) you have locally installed gems or applications. Note:
      # this needs to contain the full values for the variables set, not simply
      # the deltas.
      # default_environment['PATH']='<your paths>:/usr/local/bin:/usr/bin:/bin'
      # default_environment['GEM_PATH']='<your paths>:/usr/lib/ruby/gems/1.8'

      # miscellaneous options
      set :deploy_via, :remote_cache
      set :scm, 'git'
      set :branch, 'master'
      set :scm_verbose, true
      set :use_sudo, false
      set :normalize_asset_timestamps, false
      set :rails_env, :production
      namespace :deploy do
        desc "cause Passenger to initiate a restart"
        task :restart do
          run "touch #{current_path}/tmp/restart.txt"
        end
        desc "reload the database with seed data"
        task :seed do
          deploy.migrations
          run "cd #{current_path}; rake db:seed RAILS_ENV=#{rails_env}"
        end
      end

We will need to edit several properties to match our application.
需要改变几个属性来匹配应用程序。
We certainly will need to change the :user, :domain, and :application.
肯定需要修改的是：:user，:domain，和:application。
The :repository matches where we put our Git file earlier.
`:repository`要改为先前放置Git文件的地方。
The :deploy_to may need to be tweaked to match where we told Apache it could find the public directory for the application.
`:deploy_to`可能需要转而与这样的路径匹配，在这个路径下，Apache可以找到该应用程序的config/public目录。

We’ve also included a few lines to show how to instruct Capistrano to make use of RVM.5 
<kinder:note> 里面也花了几行介绍在RVM下怎么构建Capistrano。
If RVM was installed as root on your deployment machine, change the set :rvm_type line to specify :system instead of :user.
如果RVM被root安装在开发机上，要将`set :rvm_type`行改为`:system`，而不是`:user`。

Adjust the :rvm_ruby_string to match the version of the Ruby interpreter that you have installed and want to use.
<kinder:note> 将`:rvm_ruby_string`调整为和你安装、准备使用的Ruby编译器的版本匹配。
If you are not using RVM at all, remove these lines.
<kinder:note> 如果没有使用RVM，可以移除这些行。

5.  https://rvm.io/integration/capistrano/

• 247

The default_run_options and default_environment are to be used only if you have specific problems.
`default_run_options`和`default_environment`只有在有特殊问觉察的时候使用。
The “miscellaneous options” provided are based on Git, and they disable some of the asset processing logic that is meant for prior versions of Rails.
所提供的“miscellaneous options”是基于Git的。这些选项关闭了一些Rails之前版本的asset处理逻辑。

Two tasks are defined.
然后定义了两个任务。
One tells Capistrano how to restart Passenger.
一个任务告诉Capistrano如何重启Passenger。
The other reloads that database with seed data.
<kinder:note> 另一个用seed数据重载数据库。
<kinder:note>二版的表述为：
另一个任务利用先前放在Git储存库中，安装gem。
2版的内容不知是否过时。</kinder:note> 
Feel free to adjust these tasks as you see fit.
只要认为合适，可任意调整这些任务。

The first time we deploy our application, we have to perform an additional step to set up the basic directory structure to deploy on the server.
第一次不是应用程序时，还必须执行一个额外的步骤，用来为服务器上的部署设立基本的目录结构。

    $ cap deploy:setup

When we execute this command, Capistrano will prompt us for our server’s password.
执行这条命令时，Capistrano会提示服务器密码。
If it fails to do so and fails to log in, we might need to uncomment out the default_run_options line in our deploy.rb file and try again.
如果提示失败或者登录不成功，也许需要取消deploy.rb文件中的default_run_options的注释，然后再试一次。
Once it can connect successfully, it will make the necessary directories.
一旦连接成功，它会生成必要的目录。
After this command is done, we can check out the configuration for any other problems.
命令执行之后，可以测试配置，看看有没有其他问题。

    $ cap deploy:check

As before, we might need to uncomment out and adjust the default_environment lines in our deploy.rb.
和前面一样，可能需要在deploy.rb中取消`default_environment`的注释，并且修改它。
We can repeat this command until it completes successfully, addressing any issues it may identify.
重复这条命令，直到不再有错误，并且解决所有可能找到的问题。

One last task: we load the “seed” data containing our products.
最后一个任务：导入seed数据，包含我们的产品。

    $ cap deploy:seed

At this point, we should be off to the races.
至此，我们才刚刚开始。

### 16.2.4 Rinse, Wash, Repeat 冲洗、洗净、重复
Once we’ve gotten this far, our server is ready to have new versions of our application deployed to it any time we want.
一旦走到这一步，服务器就随时准备好迎接要部署的应用程序的新版本了。
All we need to do is check our changes into the repository and then redeploy.
所要做的是检查储存库中的变化，然后重新部署。
At this point, we have two Capistrano files that haven’t been checked in.
目前，有两个Capistrano文件尚未添加到版本管理中。
Although they aren’t needed by the app server, we can still use them to test the deployment process.
尽管应用服务器并不需要这两个文件，但还是可以用它们来测试部署过程。

    $ git add .
    $ git commit -m "add cap files"
    $ git push
    $ cap deploy

The first three commands will update the SCM server.
前三条命令将更新SCM服务器。
Once you become more familiar with Git, you may want to have finer control over when and which files are added, you may want to incrementally commit multiple changes before deployment, and so on.
随着对Git的使用越来越熟悉，你可能想要管理得更细致，如什么时候添加了哪些文件，也许想在部署前提交多个改变，也许还有更多。

 • 248

It is only the final command that will update our app, web, and database servers.
只有最后一条命令会更新应用、Web和数据库服务器。

If for some reason we need to step back in time and go back to a previous
version of our application, we can use this:
如果出于某种原因，需要及时回滚到上一个应用程序版本，可以使用：

    $ cap deploy:rollback

We now have a fully deployed application and can deploy as needed to update the code running on the server.
现在有一个完全部署好的应用程序，而且可以根据需要部署，用以更新在服务器上运行的代码。
Each time we deploy our application, a new version of it is checked out onto the server, some symlinks are updated, and the Passenger processes are restarted.
每次部署该应用程序，都会在服务器上生成一个新版本，另外，会更新一些符号链接，并且重启Passenger进程。


## 16.3 Iteration K3: Checking Up on a Deployed Application 检查部署的应用程序
Once we have our application deployed, we’ll no doubt need to check up on how it’s running from time to time.
一旦发布了应用程序，毫无疑问，必须不断地检查该程序是否运行正常。
We can do this in two primary ways.
主要方法有两个。
The first is to monitor the various log files output by both our front-end web server and the Apache server running our application.
第一种方式是监视各种日志文件，这些日志是前端的Web服务器和Apache服务器运行该应用程序的输出文件。
The second is to connect to our application using rails console.
第二种方式是用rails console连接该应用程序。

### 16.3.1 Looking at Log Files 查看日志文件
To get a quick look at what’s happening in our application, we can use the tail command to examine log files as requests are made against our application.
对应用程序发出请求时，要快速查看该应用程序正在发生的事情，可以使用tail命令来检查日志文件。
The most interesting data will usually be in the log files from the application itself.
最令人关注的数据当属这个应用程序自己生成的日志文件。
Even if Apache is running multiple applications, the logged output for each application is placed in the production.log file for that application.
即使Apache正在运行多个应用程序，每个应用程序的日志输出都会放在那个应用程序的production.log文件里。

Assuming that our application is deployed into the location we showed earlier, here’s how we look at our running log file:
假设要把这个应用程序部署到上一节提到的路径下，可以用如下方法查看日志文件：

    # On your server
    $ cd /home/rubys/deploy/depot/current
    $ tail -f log/production.log

Sometimes, we need lower-level information—what’s going on with the data in our application? 
有时需要低一级别的信息，如该应用程序中的数据正发生这什么？
When this is the case, it’s time to break out the most useful live server debugging tool.
在这种情况下，就该打开最有用的实时服务器调试工具。

### 16.3.2 Using Console to Look at a Live Application
We’ve already created a large amount of functionality in our application’s model classes.
至此已经在应用程序的模型类中创建了大量的功能。
Of course, we created these to be used by our application’s controllers.
当然，创建这些功能是为了让该应用程序的控制器使用。
But we can also interact with them directly.
但也可以直接和这些功能进行交互。
The gateway to this world is the rails console script.
通往这个世界的门户是`rails console`脚本。
We can launch it on our server with this:
可以在服务器上运行下列代码：

• 249

    # On your server
    $ cd /home/rubys/deploy/depot/current/
    $ rails console production
    Loading production environment.
    irb(main):001:0> p = Product.find_by(title: "CoffeeScript")
    => #<Product:0x24797b4 @attributes={. . .}
    irb(main):002:0> p.price = 29.00
    => 29.0
    irb(main):003:0> p.save
    => true

Once we have a console session open, we can poke and prod all the various methods on our models.
一旦开启了命令行界面对话，就可以在模型上仔细检查所有种类的方法。
We can create, inspect, and delete records.
可以创建、检视和删除记录。
In a way, it’s like having a root console to your application.
在某种程序上，就像该应用程序有个根命令行界面。

Once you put an application into production, we need to take care of a few chores to keep your application running smoothly.
一旦把应用程序放到生产环境中，需要关心一些琐事来保证这个应用程序平稳地运行。
These chores aren’t automatically taken care of for us, but, luckily, we can automate them.
虽然系统不会自动照看这些所示，但幸运的是，可以让它们自动化。

### 16.3.3 Dealing with Log Files 处理日志文件
As an application runs, it will constantly add data to its log file.
当应用程序运行时，会不断地在自己的日志文件中添加数据。
Eventually, the log files can grow extremely large.
最后，这些日志文件可以变得相当巨大。
To overcome this, most logging solutions can roll over log files to create a progressive set of log files of increasing age.
为了克服这个问题，大部分日志的解决办法是通过创建随时间增长的渐进式日志文件集合，用来滚动增加日志文件。
This will break up our log files into manageable chunks that can be archived or even deleted after a certain amount of time has passed.
这将把日志文件拆分为可管理的组件，可以存档这些组块，甚至可以过一段时间后删除它们 。

The Logger class supports rollover.
Logger类支持滚动增加日志。
We need to specify how many (or how often) log files we want and the size of each, using a line like one of the following in the file config/environments/production.rb:
需要指定想要多少（或过多久得到）日志文件和每个文件的大小，只要在config/environments/production.rb文件中加入如下的一行内容：

    config.logger = Logger.new(config.paths['log'].first, 'daily')

Or perhaps this:
也可能这样：

    require 'active_support/core_ext/numeric/bytes'
    config.logger = Logger.new(config.paths['log'].first, 10, 10.megabytes)

Note that in this case an explicit require of active_support is needed because this statement is processed early in the initialization of your application—before the Active Support libraries have been included.
注意在这个例子中，需要有一个显性的`active_support`需求，因为我们在该应用程序中包含Active Support库之前的的早期初始化过程中使用了这一声明
In fact, one of the configuration options that Rails provides is to not include Active Support libraries at all.
事实上，Rails提供的其中一个配置选项根本不包含Active Support库：

    config.active_support.bare = true

Alternately, we can direct our logs to the system logs for our machine.
除此之外，可以把日志文件指向本机系统的日志文件。

    config.logger = SyslogLogger.new

• 250

Find more options at http://rubyonrails.org/deploy.
在http://rubyonrails.org/deploy上可以找到更多方法。

### 16.3.4 Moving On to Launch and Beyond 开始发行，超越自我
Once we’ve set up our initial deployment, we’re ready to finish the development of our application and launch it into production.
一旦设置完初始的部署，就准备好完成该应用程序的开发，并且把它发行到生产环境中了。
We’ll likely set up additional deployment servers, and the lessons we learn from our first deployment will tell us a lot about how we should structure later deployments.
这里将很有可能要设置额外的部署服务器，在第一次部署中学习到的东西涉及许多信息，这些信息是关于应该如何安排以后的部署的。
For example, we’ll likely find that Rails is one of the slower components of our system—more of the request time will be spent in Rails than in waiting on the database or filesystem.
例如，将有可能会发现Rails是系统中比较慢的配件之一——更多请求时间将花在Rails而不是数据库或文件系统上的等待）。
This indicates that the way to scale up is to add machines to split up the Rails load.
这表明扩大规模的方式是增加机器来分担Rails的负载。

However, we might find that the bulk of the time a request takes is in the database.
但是，也有可能会发现一个请求把大部分时间花在数据库中。
If this is the case, we’ll want to look at how to optimize our database activity.
如果是这种情况，则应该想想如何优化数据库活动。
Maybe we’ll want to change how we access data.
也许可以改变存取数据的方法，
Or maybe we’ll need to custom craft some SQL to replace the default Active Record behaviors.
或者需要自定义地精心制作一些SQL，用以替代默认的Active Record行为。

One thing is for sure: every application will require a different set of tweaks over its lifetime.
有一点是确定的：每个应用程序在它的整个声明周期中将需要一系列不同的微调。
The most important activity to do is to listen to it over time and discover what needs to be done.
最重要的事情是随着时间的推移留心倾听这个应用程序，发现什么是要做的。
Our job isn’t done when we launch our application.
我们的工作在发行这个应用程序发时并没有完成。
It’s actually just starting.
事实上，这只是个开始。

While our job is just starting when we first deploy our application to production, we have completed our tour of the Depot application.
当把该应用程序第一次部署到产品环境中，该就是任务开始之初时，已经完成了Depot应用程序的勘察。
After we recap what we did in this chapter, let’s look back at what we have accomplished in remarkably few lines of code.
在重述本章要点之后，回顾一下在极少的几行代码后完成了什么任务。

## What We Just Did 本章小结
We covered a lot of ground in this chapter.
在本章中涉及了许多领域。
We took our code that ran locally on our development machine for a single user and placed it on a different machine, running a different web server, accessing a different database, and possibly even running a different operating system.
我们把单一用户本地运行的代码，从开发机器放到了另一台机器上，在那儿，代码在一个不同的Web服务器运行，存取不同的数据库，甚至可能运行在不同的操作系统上。

To accomplish this, we used a number of products.
为了完成这个任务，使用了许多的产品环境：
• We installed and configured Phusion Passenger and Apache httpd, a production-quality web server.
  安装并配置了Phusion Passenger和Apache httpd，一个生产级别的Web服务器。
• We installed and configured MySQL, a production-quality database server.
  安装并配置了MySQL，一个产品级别的数据库服务器。
• We got our application’s dependencies under control using Bundler and Git.
  使用Bundler和Git对该应用程序的包依赖关系进行版本管理。
• We installed and configured Capistrano, which enables us to confidently and repeatably deploy our application.
  安装并配置了Capistrano，用以自信地、重复地部署该应用程序。

• 251

## Playtime 练习时间
Here’s some stuff to try on your own:
可以自己尝试以下任务：
• If we have multiple developers collaborating on development, we might feel uncomfortable putting the details of the configuration of our database (potentially including passwords!) into our configuration management system.
如果有多个开发者合作开发，也许把数据库配置的详细信息（可能包含密码）放在配置管理系统中会有些令人有些不安。
To address this, copy the completed database.yml into the shared directory, and write a task instructing Capistrano to copy this file into your current directory each time you deploy.
要解决这个问题，可以复制完整的database.yml文件，把它放到shared目录下，然后写一个任务，指示Capistrano在每次部署时将这个文件复制到current目录下面。

• While this chapter has focused on stable, tried and true, and perhaps somewhat conservative deployment choices, the fact is that there is a lot of innovation going on in this area.
<kinder:note> 这一章的部署侧重稳定、可靠、真实甚至是有些保守，事实上，还有许多创新性的作为。
At the moment, Capistrano and Git appear to be virtually uncontested choices.
<kinder:note> 现在，Capistrano和Git似乎是个不容争辩的选择。
Everything else is up for grabs.
<kinder:note> 而其他的一切仍可替代。

Here are some things to play with:
下面是一些练习：
• Try replacing rvm with rbenv6 and ruby-build.7
  尝试用rbenv6和ruby-build来替代rvm。
• Try replacing mysql with PostgreSQL.8
  尝试用PostgreSQL替代mysql。
• Try replacing both Phusion Passenger and Apache httpd with Unicorn9 and nginx.10
  尝试使用Unicorn和nginx替代Phusion Passenger和Apache httpd。
Being agile means more than making the right choices.
敏捷开发意味着更能作出正确的选择。
It requires both adaptive planning and rapid and flexible response to change.
它既要求适应性广的计划，也要求快速和有弹性的改变。

(You’ll find hints at http://pragprog.com/wikis/wiki/RailsPlayTime.)

6.  https://github.com/sstephenson/rbenv/#readme     
7.  https://github.com/sstephenson/ruby-build#readme
8.  http://www.postgresql.org/
9.  http://unicorn.bogomips.org/
10. http://wiki.nginx.org/Main


# CHAPTER 17 Depot Retrospective  Depot回顾
## In this chapter, we’ll see
本章，我们将学习：
• reviewing Rails concepts: model, view, controller, configuration, testing, and deployment; and
  回顾Rails的概念：模型、视图、控制器、配置、测试以及部署
• documenting what we have done.
  文档化所做过的事情。

Congratulations! By making it this far, you have obtained a solid understanding of the basics of every Rails application.
恭喜你！
进行到这一步，你已经透彻地理解了每个Rails应用程序的基本知识。
There is much more to learn, which we will pick back up again in Part III.
在第三部分将学习更多的知识。
For now, relax, and let’s recap what we’ve seen in Part II.
现在，大家只要放松心情，回顾在第二部分做了什么。

## 17.1 Rails Concepts Rails的概念
In Chapter 3, The Architecture of Rails Applications, on page 29 we introduced models, views, and controllers.
第3章介绍了模型、视图和控制器。
Now let’s see how we applied each of these concepts in the Depot application.
现在来看看如何把这些概念应用到Depot应用程序中。
Then let’s explore how we used configuration, testing, and deployment.
然后探讨如何在配置、测试和部署中使用它们。

### 17.1.1 Model 模型
Models are where all of the persistent data retained by your application is managed.
模型是管理所有持久性数据的地方，这些数据应由应用程序保留。
In developing the Depot application, we created five models: Cart, LineItem, Order, Product, and User.
在Depot应用程序的开发过程中，共创建了5个模型：Cart, LineItem, Order, Product, 和 User。

By default, all models have id, created_at, and updated_at attributes.
默认下，所有的模型都具有`id`, `created_at`和`updated_at`属性。
To our models, we added attributes of type string (examples: title, name), integer (quantity), text (description, address), and decimal (price), as well as foreign keys (product_id, cart_id).
在这些模型中，新添加了其他类型的属性：string(title, name) integer(quantity) text(description, address) decimal(price)以及关系键(`product_id`, `cart_id`)。
We even created a virtual attribute that is never stored in the database, namely, a password.
我们甚至还创建了一个虚拟的属性，password，但它永远不会在数据库中储存。

We created has_many and belongs_to relationships that we can use to navigate between our model objects, such as from Carts to LineItems to Products.
创建的`has_many`和`belongs_to`关系，用于在模型对象之间导航，比如，从Carts到LineItems，再到Product。

We employed migrations to update the databases, not only to introduce new schema information but also to modify existing data.
利用迁移来更新数据库，在迁移过程中不仅介绍了新的架构信息，还修改了已有的数据。
We demonstrated that they can be applied in a fully reversible manner.
并且证明可以用一种完全可逆的方式应用它们。

• 254

The models we created were not merely passive receptacles for our data.
所创建的模型并不单单是数据的被动容器。
For starters, they actively validate the data, preventing errors from propagating.
对启动装置来说，它们积极地对数据进行验证，防止错误传播。
We created validations for presence, inclusion, numericality, range, uniqueness, format, and confirmation (and length too, if you completed the exercises).
我们为存在、包含、数值、范围、单一、格式、确认（如果完成了练习，那么还有很多其他的）创建了验证。
 We created custom validations for ensuring that deleted products are not referenced by any line item.
还创建了自定义校验来确保没有任何商品项目在使用已删除的产品。
We used an Active Record hook to ensure that an administrator always remains and used a transaction to roll back incomplete updates on failure.
同时，用Active
Record钩子来保证管理员总是存在，并且确保一个未完成的回滚事务处理会导致更新失败。

We also created logic to add a product to a cart, add all line items from a cart to an order, encrypt and authenticate a password, and compute various totals.
还创建了行为准则，规定如何在购物车中添加产品，如何把所有的在线商品项目从一个购物车添加到另一个订单中，如何加密和验证密码，以及如何计算各种总数。

Finally, we created a default sort order for products for display purposes.
最后，由于显示需要，创建了一个默认的给产品排序的功能。

### 17.1.2 View 视图
Views control the way our application presents itself to the external world.
视图控制着应用程序向外界展现自我的方式。
 By default, Rails scaffolding provides edit, index, new, and show, as well as a partial named form that is shared between edit and new.
默认情况下，Rails的脚手架提供了编辑、目录、新建和显示，此外还有一个叫form的部分，由新建和编辑共享。
We modified a number of these, as well as created new partials for carts and line items.
我们修改了其中的许多内容，还为购物车和在车商品项目创建了新的部分。

In addition to the model-backed resource views, we created entirely new views for admin, sessions, and the store itself.
除了模型支持的资源视图外，也为admin、sessions和store完整创建了新的视图。
We updated an overall layout to establish a common look and feel for the entire site.
更新总体版面设计，为整个网站建立一个共同的外观和感受。
We linked in a stylesheet.
连接了一个样式表。
We made use of templates to generate JavaScript that takes advantage of Web 2.0 technologies to make our website more interactive.
用了模板来了产生JavaScript，利用Web 2.0技术来让网站变得更容易交互。

We made use of a helper to determine when to hide the cart from the main view.
使用帮助程序来决定什么时候该在主视图中隐藏购物车。
We localized the customer views for display both in English and in Spanish.
本地化顾客的视图，让网页可以同时用英语和西班牙语显示。
While we focused primarily on HTML views, we also created plain-text views and Atom views.
虽然主要注意力集中在Html视图，但还是创建了纯文本视图和Atom视图。
Not all of the views were designed for browsers: we created views for email too, and those views were able to share partials for displaying line items.
不是所有的视图都是为浏览器设计的，与此同时也为电子邮件创建了视图，这些视图可以共享显示商品项目的部分。

### 17.1.3 Controller 控制器
By the time we were done, we created eight controllers: one each for the five models and the three additional ones in order to support the views for admin, sessions, and the store itself.
到现在为止，共创建了8个控制器：每个建立的模型都有一个相应的控制器，剩下的3个控制器用于支持admin、session和store自身的视图。
 These controllers interacted with the models in a number of ways, from finding and fetching data and putting it into instance variables to updating models and saving data entered via forms.
这些控制器采用多种方式与模型进行交互：寻找并获得数据，然后把数据放到实例变量中；或者更新模型，通过表单来保存输入的数据。
When done, we either redirected to another action or rendered a view.
控制器完成一项任务后，我们要么重定向到另一个行为，要么转入一个视图。
We rendered views in HTML, JSON, and Atom.
可以用HTML， JSON，Atom来渲染视图。

• 255

We limited the set of permitted parameters on the line item controller.
<kinder:note> 在在线商品控制器上，限制了一组权限参数。
创建过滤器用于授权请求，
We created callback actions that were run before selected actions to find the cart, set the language, and authorize requests.
<kinder:note> 创建了回调（2版称为过滤器）行动，在所选行为之前运行，以寻找购物车，设置语言，验证请求。
We placed logic common to a number of controllers into a concern, namely, the CurrentCart module.
<kinder:note> 将许多控制器共有的逻辑放在一个concern中，也就是CurrentCart模块。

We managed sessions, keeping track of the logged-in user (for administrators) and carts (for customers).
管理了会话，为管理员、为顾客持续了解登录用户和购物车的动态。
We kept track of the current locale used for internationalization of our output.
<kinder:note> 跟踪了当前语言环境，用于输出国际化。
We captured errors, logged them, and informed the user via notices.
<kinder:note> 捕获了错误，记录它们，并通过提醒告知用户。

We employed fragment caching on the storefront and page-level caching on the Atom feeds.
<kinder:note> 在店面使用片段缓存，在Atom推送使用页面缓存。
We also sent confirmation emails on receipt of an order.
<kinder:note> 收到订单后，还会发送确认邮件。

### 17.1.4 Configuration 配置
While conventions keep to a minimum the amount of configuration required for a Rails application, we did do a bit of customization.
虽然约定为Rails的应用程序保持着最低所需的配置，将还是做了一些自定义。

We modified our database configuration in order to use MySQL in production.
修改了数据库的配置，以便在生产中能使用MySQL。

We defined routes for our resources, our admin and session controllers, and the root of our website, namely, our storefront.
给资源、管理、会话的控制器、网站的根目录（即店面）定义了路由。
We defined a who_bought member of our products resource in order to access Atom feeds that contain this information.
为了访问Atom包含买家信息的订阅页面，定义了一个名为`who_bought`的产品资源成员。

We created an initializer for i18n purposes and updated the locales information for both English (en) and Spanish (es).
为i18n创建了初始化程序，并且给英文版和西班牙语版更新了语言环境信息。

We created seed data for our database.
为数据库创建了订阅页面的数据。

We created a Capistrano script for deployment, including the definition of a few custom tasks.
为部署创建了Capistrano脚本，其中包含一些自定义页面。

### 17.1.5 Testing 测试
We maintained and enhanced tests throughout.
在整个过程中都保持并加强了测试。
We employed unit tests to validation methods.
为检验方法做了单元测试。
 We also tested increasing the quantity on a given line item.
也对一个给定的在线项目进行了数量增加测试。

Rails provided basic tests for all our scaffolded controllers, which we maintained as we made changes. 
Rails为所有脚手架提供了基础测试，当进行改变时，需要维护这些测试。
We added tests along the way for things such as Ajax and ensuring that a cart has items before we create an order.
我们添加了其他测试，例如Ajax，来保证在创建订单前购物车里存在商品。


• 256

We used fixtures to provide test data to fuel our tests.
使用夹具来提供测试数据，增强测试。
Finally, we created an integration test to test an end-to-end scenario involving a user adding a product to a cart, entering an order, and receiving a confirmation email.
最后，创建了一个集成测试来测试一个端对端的情景，该情景包括一个用户添加产品到购物车中，输入订单，以及收到确认邮件。

### 17.1.6 Deployment 部署
We deployed our application to a production-quality web server (Apache httpd) using a production-quality database server (MySQL).
使用生产级数据库，把应用程序部署到生产级Web服务器上。
Along the way, we installed and configured Phusion Passenger to run our application, Bundler to track dependencies, and Git to configuration manage our code.
接着，安装并配置了Phusion Passenger以运行该应用程序；安装并配置了Bundler用于跟踪包依赖关系；安装并配置Git用于配置管理代码。
Capistrano was employed to orchestrate updating the deployed web server in production from our development machine.
Capistrano用来精心安排从开发及器到生产部署Web服务器的更新。

We made use of test and production environments to prevent our experimentation during development from affecting production.
使用测试和生成环境来避免在开发过程中的实验影响到产品。
Our development environment made use of the lightweight SQLite database server and a lightweight web server, most likely WEBrick.
开发环境使用的是轻量的SQLite数据库服务和Web服务器，如最常用的WEBRick。
Our tests were run in a controlled environment with test data provided by fixtures.
而测试则在可控制的环境中运行，该环境的测试数据由夹具测试提供。


## 17.2 Documenting What We Have Done 文档化所做的事情
To complete our retrospective, let’s take a look at the code from two new perspectives.
要完成这次回顾，需要从两个新的角度来看一看代码。

Rails makes it easy to run Ruby’s RDoc1 utility on all the source files in an application to create good-looking programmer documentation.
在应用程序的所有源文件上运行Ruby的RDoc实用程序，可创建一个漂亮的程序员文档，这在Rails中很容易做到。
But before we generate that documentation, we should probably create a nice introductory page so that future generations of developers will know what our application does.
但在生成文档之前，可能需要创建一个很好的介绍页面，以便下一任开发者知道该应用程序是做什么的。

To do this, edit the file README.rdoc, and enter anything you think might be useful.
要完成这项工作，需要编辑README.rdoc文件，输入任何可用的信息。
This file will be processed using RDoc, so you have a fair amount of formatting flexibility.
该文件将用RDoc处理，所以格式具有非常大的灵活性。

You can generate the documentation in HTML format using the rake command.
可以用rake命令生成HTML格式的文档：

    depot> rake doc:app

This generates documentation into the directory doc/app.
这会在doc/app目录下生成文档。
(See Figure 54, Our application's internal documentation, on page 257.) 
（详见下一页的图示54）

1. http://rdoc.sourceforge.net/

• 257

Figure 54—Our application’s internal documentation
图示54——应用程序的内部文档
Finally, we might be interested to see how much code we’ve written.
最后，我们也许会对编写了多少代码感兴趣。
There’s a Rake task for that, too.
也用Rake任务来做：

    depot> rake stats
    +----------------------+-------+-------+---------+---------+-----+-------+
    | Name                 | Lines |  LOC  | Classes | Methods | M/C | LOC/M |
    +----------------------+-------+-------+---------+---------+-----+-------+
    | Controllers          |   622 |   382 |       9 |      56 |   6 |     4 |
    | Helpers              |    26 |    24 |       0 |       1 |   0 |    22 |
    | Models               |   112 |    72 |       5 |       7 |   1 |     8 |
    | Mailers              |    29 |    11 |       1 |       2 |   2 |     3 |
    | Javascripts          |    50 |     5 |       0 |       0 |   0 |     0 |
    | Libraries            |     0 |     0 |       0 |       0 |   0 |     0 |
    | Controller tests     |   404 |   283 |       8 |       0 |   0 |     0 |
    | Helper tests         |    32 |    24 |       8 |       0 |   0 |     0 |
    | Model tests          |   130 |    90 |       5 |       2 |   0 |    43 |
    | Mailer tests         |    25 |    18 |       1 |       0 |   0 |     0 |
    | Integration tests    |   198 |   138 |       2 |       9 |   4 |    13 |
    +----------------------+-------+-------+---------+---------+-----+-------+
    | Total                |  1628 |  1047 |      39 |      77 |   1 |    11 |
    +----------------------+-------+-------+---------+---------+-----+-------+
    Code LOC: 494         Test LOC: 553      Code to Test Ratio: 1:1.1

If you think about it, you have accomplished a lot and with not all that much code.
想想看，你完成了很多工作，但没有编写太多代码。
Furthermore, much of that code was generated for you.
而且，其中许多代码是自动生成的。
This is the magic of Rails.
这就是Rails的神奇魔力。

# Part III Rails in Depth 深入Rails
# CHAPTER 18 Finding Your Way Around Rails  自己去发现Rails（工作）的方法

In this chapter, we’ll see
在本章中，我们将学习
• the directory structure of a Rails application,
  Rails应用程序的目录结构
• naming conventions,
  命名约定
• generating documentation for Rails itself,
  为Rails自身生成文档
• adding Rake tasks, and
  添加Rake任务
• configuration.
  配置

Having survived our Depot project, you are now prepared to dig deeper into Rails.
在经历了整个Depot项目的开发后，你已经具备挖掘更深层Rails的条件。
For the rest of the book, we’ll go through Rails topic by topic (which pretty much means module by module).
本书的剩余部分仅仅讲述每个模块的功能（也就是按照模块进行）。
You have seen most of these modules in action before.
先前已经在行为中出现许多模块了。
We will cover not only what each module does but also how to extend or even replace the module and why you might want to do so.
这里将不仅仅讲述每个模块的功能，而且也会介绍如何扩展甚至替换模块，已经可能要这么做的原因。

The chapters in Part III cover all the major subsystems of Rails: Active Record, Active Resource, Action Pack (including both Action Controller and Action View), and Active Support.
第三部分的章节涵盖了Rails的所有主要子系统：Active Record 模块、 Active Resource模块、Action Pack框架（包括Action Controller模块和Action View模块），以及Active Support模块。
This is followed by an in-depth look at migrations.
在这之后，将了解迁移的详细内容。

Then we are going to delve into the interior of Rails and show how the components are put together, how they start up, and how they can be replaced.
接下来会深入Rails的内部，展示如何把组件放在一起，如何启动组件，以及如何替换组件。
Having shown how the parts of Rails can be put together, we’ll complete this book with a survey of a number of popular replacement parts, many of which can be used outside of Rails.
在介绍组件的组合之后，会以一分调查结束本书，该调查针对大量的流行替换部件展开，其中大部分部件都可以在Rails外使用。

We need to set the scene.
但首先得设置场景。
This chapter covers all the high-level stuff you need to know to understand the rest:
本章涵盖了所有高层次的内容， 必须弄懂这些才能更好地理解其他内容：
directory structures, configuration, and environments.
目录结构、配置和环境

## 18.1 Where Things Go 东西都去哪里了
### 顶级目录
Rails assumes a certain runtime directory layout and provides application and scaffold generators, which will create this layout for you.
Rails会假设某种运行时的目录布局，并且提供应用程序和脚手架生成器，以此来帮助创建这个布局。
For example, if we generate my_app using the command rails new my_app, the top-level directory for our new application appears as shown in Figure 55, All Rails applications have this top-level directory structure., on page 262.
例如，如果使用命令`rails new my_app`来生成新应用程序，新应用程序的最高级别目录如262页图表55所示。
Let’s start with the text files in the top of the application directory.
可以从这应用程序的顶级目录入手：

• 262

Figure 55—All Rails applications have this top-level directory structure.
所有Rails程序都存在这样一个顶级目录的目录结构

• config.ru configures the Rack Webserver Interface, either to create Rails Metal applications or to use Rack Middlewares in your Rails application.
  config.ru会配置Rack Web服务器界面，让它要么创建Rails Metal应用程序，要么使用Rails应用程序中的Rack中间件。
These are discussed further in the Rails Guides.[1]
更详细的讨论请看Rails指南。

[1].  http://guides.rubyonrails.org/rails_on_rack.html

• Gemfile specifies the dependencies of your Rails application.
  Gemfile指定了Rails应用程序的包依赖关系。
You have already seen this in use when the bcrypt-ruby gem was added to the Depot application.
在Depot程序的bcrypt-ruby包中，你已经看到它的使用了。
Application dependencies also include the database, web server, and even scripts used for deployment.
应用程序的包依赖关系也包括数据库、web服务器，甚至用于部署的脚本。

• 263
##############################
Joe asks:  So, Where’s Rails? 那么，Rails在哪里？
One of the interesting aspects of Rails is how componentized it is.
如何组件化是Rails框架的一个有趣的话题。
From a developer’s perspective, you spend all your time dealing with high-level modules such as Active Record and Action View.
从开发者的角度看，你把所有时间都在高级别的模块上，如Active Record模块和Active View模块。
There is a component called Rails, but it sits below the other components, silently orchestrating what they do and making them all work together seamlessly.
但深藏在其他组件之下，有一个称为Rails的组件，它默默地协调着模块间的活动，让它们能亲密无间地共同工作。
Without the Rails component, not much would happen.
没有这个Rails组件，很多工作都不能完成。
But at the same time, only a small part of this underlying infrastructure is relevant to developers in their day-to-day work.
但同时，这个下层的基础设施只有一小部分功能与开发者的日常工作有关。
We’ll cover the parts that are relevant in the rest of this chapter.
相关部分的内容将会在本章的剩余部分讨论。
##############################

Technically, this file is not used by Rails but rather by your application.
从技术上说，使用这个文件的并不是Rails本身，而是该应用程序。
You can find calls to the Bundler [2] in the config/application.rb and config/boot.rb files.
你可以在config/boot.rb文件和config/application.rb文件中找到对Bundler的调用。
[2].  https://github.com/carlhuda/bundler
<kinder:note> 下面是boot.rb文件的内容：

    # Set up gems listed in the Gemfile.
    ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)
    
    require 'bundler/setup' if File.exist?(ENV['BUNDLE_GEMFILE'])

</kinder:note> 
<kinder:note> 下面是application.rb文件的内容：

    require File.expand_path('../boot', __FILE__)
    
    require 'rails/all'
    
    # Require the gems listed in Gemfile, including any gems
    # you've limited to :test, :development, or :production.
    Bundler.require(*Rails.groups)
    
    module Depot
      class Application < Rails::Application
        # Settings in config/environments/* take precedence over those specified here.
        # Application configuration should go into files in config/initializers
        # -- all .rb files in that directory are automatically loaded.
    
        # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
        # Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
        # config.time_zone = 'Central Time (US & Canada)'
    
        # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
        # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
        # config.i18n.default_locale = :de
      end
    end

</kinder:note> 

• Gemfile.lock records the specific versions for each of your Rails application’s dependencies.
  <kinder:note> Gemfile.lock记录了Rails程序的每个依赖的具体版本。
This file is maintained by Bundler and should be checked into your repository.
<kinder:note> 这个文件由Bundler维护，并进入你的组件仓库进行检查。

• Rakefile defines tasks to run tests, create documentation, extract the current structure of your schema, and more.
  Rakefile定义了这样一些任务，运行测试、创建文档、提取这个架构的当前结构，以及其他功能。
Type rake -T at a prompt for the full list.
在命令行输入`rake -T`会输出一个完整列表。
<kinder:note> 下面是完整列表：

rake about                              # List versions of all Rails frameworks and the environment
                                          列出所有Rails框架和环境的版本
<kinder:note> $ rake about
About your application's environment
Ruby version              2.1.2-p95 (i686-linux)
RubyGems version          2.2.2
Rack version              1.5
Rails version             4.1.1
JavaScript Runtime        Node.js (V8)
Active Record version     4.1.1
Action Pack version       4.1.1
Action View version       4.1.1
Action Mailer version     4.1.1
Active Support version    4.1.1
Middleware                Rack::Sendfile, ActionDispatch::Static, Rack::Lock, #<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0xb8952e88>, Rack::Runtime, Rack::MethodOverride, ActionDispatch::RequestId, Rails::Rack::Logger, ActionDispatch::ShowExceptions, ActionDispatch::DebugExceptions, ActionDispatch::RemoteIp, ActionDispatch::Reloader, ActionDispatch::Callbacks, ActiveRecord::Migration::CheckPending, ActiveRecord::ConnectionAdapters::ConnectionManagement, ActiveRecord::QueryCache, ActionDispatch::Cookies, ActionDispatch::Session::CookieStore, ActionDispatch::Flash, ActionDispatch::ParamsParser, Rack::Head, Rack::ConditionalGet, Rack::ETag
Application root          /home/liqixun/docs/liqixun/desktop/ror_project/depot-20150114-complete
Environment               development
Database adapter          sqlite3
Database schema version   20150113053634
</kinder:note> 
rake assets:clean[keep]                 # Remove old compiled assets
                                          移除旧的编译asset
rake assets:clobber                     # Remove compiled assets
                                          移除编译的asset
rake assets:environment                 # Load asset compile environment
                                          导入asset编译环境
rake assets:precompile                  # Compile all the assets named in config.assets.precompile
                                          编译所有在config.assets.precompile中已命名的的asset
rake cache_digests:dependencies         # Lookup first-level dependencies for TEMPLATE (like messages/show or comments/_comment.html)
                                          为TEMPLATE模板（比如messages/show或comments/_comment.html）寻找第一级依赖。
rake cache_digests:nested_dependencies  # Lookup nested dependencies for TEMPLATE (like messages/show or comments/_comment.html)
                                          为TEMPLATE模板（比如messages/show或comments/_comment.html）寻找嵌套依赖。
rake db:create                          # Creates the database from DATABASE_URL or config/database.yml for the current RAILS_ENV (use db:create:all to create all databases in the config)
                                          为当前的RAILS_ENV，从DATABASE_URL或者cofig/databases.yml中创建数据库（使用`db:create:all`创建所有config的数据库）
rake db:drop                            # Drops the database from DATABASE_URL or config/database.yml for the current RAILS_ENV (use db:drop:all to drop all databases in the config)
                                          为当前的RAILS_ENV，从DATABASE_URL或者cofig/databases.yml中删除数据库（使用`db:drop:all`删除所有config的数据库）
rake db:fixtures:load                   # Load fixtures into the current environment's database
                                          将夹具导入到当前环境的数据库中
rake db:migrate                         # Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)
                                          迁移数据库（选项有：VERSION=x, VERBOSE=false, SCOPE=blog）
rake db:migrate:status                  # Display status of migrations
                                          显示迁移状态
rake db:rollback                        # Rolls the schema back to the previous version (specify steps w/ STEP=n)
                                          将schema滚回之前的版本（可指定steps w/ STEP=n）
rake db:schema:cache:clear              # Clear a db/schema_cache.dump file
                                          清除一个db/schema_cache.dump文件
rake db:schema:cache:dump               # Create a db/schema_cache.dump file
                                          创建一个 db/schema_cache.dump文件
rake db:schema:dump                     # Create a db/schema.rb file that is portable against any DB supported by AR
                                          创建一个db/schema.rb文件，可插拔任何AR（是Active Record吧）支持的DB。
rake db:schema:load                     # Load a schema.rb file into the database
                                          将一个schema.rb文件导入数据库中。
rake db:seed                            # Load the seed data from db/seeds.rb
                                          从db/seeds.rb中导入seed数据。
rake db:setup                           # Create the database, load the schema, and initialize with the seed data (use db:reset to also drop the database first)
                                          创建数据库，导入schema，用seed数据初始化（使用`db:reset`则先删除数据库）
rake db:structure:dump                  # Dump the database structure to db/structure.sql
                                          转储数据库结构到db/structure.sql中。
rake db:version                         # Retrieves the current schema version number
                                          找回当前schema的版本号码
rake doc:app                            # Generate docs for the app -- also available doc:rails, doc:guides (options: TEMPLATE=/rdoc-template.rb, TITLE="Custom Title")
                                          为应用程序产生docs文档--用`doc:rails``doc:guids`也可以（选项有：TEMPLATE=/rdoc-template.rb, TITLE="Custom Title"）
rake log:clear                          # Truncates all `*.log` files in log/ to zero bytes (specify which logs with LOGS=test,development)
                                          将log文件夹里所有`.log`文档截断为0（用LOGS=test,development可指定特定log）
rake middleware                         # Prints out your Rack middleware stack
                                          输出你的Rack中间件栈堆
<kinder:note> $ rake middleware
use Rack::Sendfile
use ActionDispatch::Static
use Rack::Lock
use #<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0xbb0f0dc8>
use Rack::Runtime
use Rack::MethodOverride
use ActionDispatch::RequestId
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use ActionDispatch::DebugExceptions
use ActionDispatch::RemoteIp
use ActionDispatch::Reloader
use ActionDispatch::Callbacks
use ActiveRecord::Migration::CheckPending
use ActiveRecord::ConnectionAdapters::ConnectionManagement
use ActiveRecord::QueryCache
use ActionDispatch::Cookies
use ActionDispatch::Session::CookieStore
use ActionDispatch::Flash
use ActionDispatch::ParamsParser
use Rack::Head
use Rack::ConditionalGet
use Rack::ETag
run Depot::Application.routes
</kinder:note>
rake notes                              # Enumerate all annotations (use notes:optimize, :fixme, :todo for focus)
                                          列出所有评注（焦点可用note:optimize, :fixme, :todo）
rake notes:custom                       # Enumerate a custom annotation, specify with ANNOTATION=CUSTOM
                                          列出一个定制的评注，用ANNOTATION=CUSTOM指定。
rake rails:template                     # Applies the template supplied by LOCATION=(/path/to/template) or URL
                                          应用LOCATION=(/path/to/template)或URL提供的模板。
rake rails:update                       # Update configs and some other initially generated files (or use just update:configs or update:bin)
                                          更新升级configs和一些其他初始产生的文件（或使用update:configs 或 update:bin）
rake routes                             # Print out all defined routes in match order, with names
                                          按匹配的顺序，输出所有已定义的路由名称
rake secret                             # Generate a cryptographically secure secret key (this is typically used to generate a secret for cookie sessions)
                                          产生一个加了密的安全密钥（一般用于生成cookie会话的密码）
rake stats                              # Report code statistics (KLOCs, etc) from the application
                                          报告应用程序的代码统计信息（如KLOCs等）
rake test                               # Runs test:units, test:functionals, test:generators, test:integration together
                                          一起运行单元测试，功能测试，生成测试和集成测试
rake test:all                           # Run tests quickly by merging all types and not resetting db
                                          合并所有类型，不重设数据库，快速运行测试。
rake test:all:db                        # Run tests quickly, but also reset db
                                          快速测试，但重设数据库。
rake time:zones:all                     # Displays all time zones, also available: time:zones:us, time:zones:local -- filter with OFFSET parameter, e.g., OFFSET=-6
                                          显示所有时区，--带OFFSET过滤器的参数（如OFFSET=-6）的`time:zones:us`、`time:zones:local`也行
rake tmp:clear                          # Clear session, cache, and socket files from tmp/ (narrow w/ tmp:sessions:clear, tmp:cache:clear, tmp:sockets:clear)
                                          从tmp/清除会话、缓存和套接字文件（narrow w/ tmp:sessions:clear, tmp:cache:clear, tmp:sockets:clear）
rake tmp:create                         # Creates tmp directories for sessions, cache, sockets, and pids
                                          为会话、缓存、套接字和pid创建tmp目录
</kinder:note> 
Type rake -D task to see a more complete description of a specific task.
输入`rake -D task`可以查看特定任务的完整描述。

• README contains general information about the Rails framework.
  README包含有关Rails框架本身的普通信息。
Now let’s look at what goes into each directory (although not necessarily in order).
现在来看一看每个目录都有什么内容（尽管没有必要按顺序来）。

### 18.1.1  A Place for Our Application应用程序的位置
Most of our work takes place in the app directory.
大部分工作都在app目录中进行。
The main code for the application lives below the app directory, as shown in Figure 56, The main code for our application lives in the app directory., on page 264.
应用程序的主要代码在app目录下，如下页图表56所示。
We’ll talk more about the structure of the app directory as we look at the various Rails modules such as Active Record, Action Controller, and Action View in more detail later in the book.
在本书后面的章节中介绍Rails模块（如Active Record模块、Action Controller模块和Action View模块）时，再来讨论更多有关app目录结构的内容。

### 18.1.2 A Place for Our Tests测试的位置
As we have seen in Section 7.2, Iteration B2: Unit Testing of Models, on page 82, Section 8.4, Iteration C4: Functional Testing of Controllers, on page 101, and Section 13.2, Iteration H2: Integration Testing of Applications, on page 184, Rails has ample provisions for testing your application, and the test directory is the home for all testing-related activities, including fixtures that define data used by our tests.
如在7.2节、8.4节、以及13.2节中看到的那样，Rails拥有丰富的措施来测试应用程序，而test目录是所有测试相关活动的大本营。


• 264

Figure 56—The main code for our application lives in the app directory.
          应用程序的主要代码保存在app目录下

• 265

### 18.1.3 A Place for Documentation 文档的位置
While the doc directory is no longer part of the required directories, as we saw in Section 17.2, Documenting What We Have Done, on page 256, Rails provides a doc:app rake task to generate documentation, which it places in the doc/ directory.
就像在17.2节里所做的那样，Rails提供**`doc::app`**rake任务来产生文档，该文档在doc/目录下。
In addition to this command, Rails provides other tasks that generate documentation: doc:rails will provide documentation for the version of Rails you are running, and doc:guides will provide usage guides.
除了这个命令外，Rails也提供其他任务，用于生产文档： **`doc:rails`**会提供正在运行的Rails版本， **`doc:guides`**会提供使用指南。
Before you build the guides, you will need to add the gem redcarpet to your Gemfile and run bundle install.
在建立指南之前，得在Gemfile里添加**redcarpet**包，然后运行`bundle install`。
<kinder:note> 还需要一个`nokogiri`gem。
<kinder:note> $ sudo rake doc:guides
<kinder:note> 生成的是和网络的指南一样的页面。还是用网上中文翻译的好读。
Rails also provides other document-related tasks.
Rails也提供其他与文档相关的任务。
To see them all, enter the command rake -T doc.
输入命令`rake -T doc`可以显示所有任务。
 
### 18.1.4 A Place for Supporting Libraries 支持库的位置
The lib directory holds application code that doesn’t fit neatly into a model, view, or controller.
lib目录存储着不能很好地适应模型、视图或控制器的应用程序代码。
For example, you may have written a library that creates PDF receipts that your store’s customers can download.[3] 
例如，已编写一个库，可以为商店的顾客创建可以下载的pdf版发票。
[3].  ...which we did in the Pragmatic Programmer store.
   就像Pragmatic Programmer商店里做的一样。
These receipts are sent directly from the controller to the browser (using the send_data() method).
这些发票直接从控制器发送到浏览器（使用`send_data()`方法）。
The code that creates these PDF receipts will sit naturally in the lib directory.
顺理成章地，创建这些PDF版发票的代码将放在lib目录下。

The lib directory is also a good place to put code that’s shared among models, views, or controllers.
lib目录也是一个存放代码的好地方，这些代码在模型、视图、控制器之间共享。
Maybe you need a library that validates a credit card number’s checksum, that performs some financial calculation, or that works out the date of Easter.
它可以是一个用来验证信用卡卡号检验位的库，或者是一个执行某些财务核算的库，或者是一个找出复活节日期的库。
Anything that isn’t directly a model, view, or controller should be slotted into lib.
任何不直接定义为模型、视图或控制器的东西都应该放在lib中。

Don’t feel that you have to stick a bunch of files directly into the lib directory.
把诸多文件文件直接放在lib目录下并不是必需的。
Feel free to create subdirectories in which you group related functionality under lib.
可以自由地创建子目录，将lib下的相关功能分组。
For example, on the Pragmatic Programmer site, the code that generates receipts, customs documentation for shipping, and other PDF-formatted documentation is in the directory lib/pdf_stuff.
例如，在Pragmatic
Programmer网站上，用来生成发票、顾客的发货文件，以及其他PDF格式文档的代码都保存在lib/pdf_stuff目录下。

In previous versions of Rails, the files in the lib directory were automatically included in the load path used to resolve require statements.
在先前的Rails版本中，lib目录下的文件会自动包含在搜索里。
require ↪ on page 51
This is now an option that you need to explicitly enable.
现在这个功能是可选的，必须显性开启。
To do so, place the following in config/application.rb:
开启的方式是在config/application.rb中放入：

  config.autoload_paths += %W(#{Rails.root}/lib)

• 266
Once you have files in the lib directory and the lib added to your autoload paths, you can use them in the rest of your application.
一旦把文件放在lib目录中，并且把lib目录添加到自动加载的路径中，就可以在该应用程序的其他部分使用它们了。
If the files contain classes or modules and the files are named using the lowercase form of the class or module name, then Rails will load the file automatically.
如果文件包含类或模块，并且文件以该类或模块的小写字母命名，那么Rails就会自动加载这个文件。
For example, we might have a PDF receipt writer in the file receipt.rb in the directory lib/pdf_stuff.
比如，也许在lib/pdf_stuff目录下的receipt.rb文件中有一个PDF版发票的打印程序。
As long as our class is named PdfStuff::Receipt, Rails will be able to find and load it automatically.
只要这个类以PdfStuff::Receipt命名，Rails就可以找到并自动加载。

require ↪ on page 51
For those times where a library cannot meet these automatic loading conditions, you can use Ruby’s require mechanism.
如果一个库不能满足加载条件，可以使用Ruby的require机制。
If the file is in the lib directory, you can require it directly by name.
如果这个文件在lib目录下，可以直接通过名称获取它。
For example, if our Easter calculation library is in the file lib/easter.rb, we can include it in any model, view, or controller using this:
比如，倘若复活节日期的计算库在lib/ester.rb文件里，可以在任意模型、视图或控制器中包含它，方法如下：

    require "easter"

If the library is in a subdirectory of lib, remember to include that directory’s name in the require statement.
如果该库在lib的子目录下，别忘了require语句中包含那个目录的名称。
For example, to include a shipping calculation for airmail, we might add the following line:
例如，要包含一个航空邮件运输计算器，可以添加下面内容：

    require "shipping/airmail"

### 18.1.5 A Place for Our Rake Tasks Rake任务的位置
You’ll also find an empty tasks directory under lib.
在lib目录下也可以找到一个空的tasks目录。
This is where you can write your own Rake tasks, allowing you to add automation to your project.
在这里可以编写自己的Rake任务，这些任务让该项目自动化。
This isn’t a book about Rake, so we won’t go into it deeply here, but here’s a simple example.
可惜本书不是关于Rake的书，因此在这里不打算深入讨论；但下面有一个简单的例子。

Rails provides a Rake task to tell you the latest migration that has been performed.
Rails提供Rake任务，告诉用户已执行的最新迁移。
But it may be helpful to see a list of all the migrations that have been performed.
但是，能看到所有执行过的迁移也许更有帮助。
We’ll write a Rake task that prints the versions listed in the schema_migration table.
可以编写一个Rake任务，用来输出schema_migration表中列出内容的版本。
These tasks are Ruby code, but they need to be placed into files with the extension .rake.
这些任务都是用Ruby写的，但必须以.rake作为文件名后缀。
We’ll call ours db_schema_migrations.rake.
我们将调用我们的db_schema_migrations.rake文件。

    Download rails40/depot_t/lib/tasks/db_schema_migrations.rake
    namespace :db do
      desc "Prints the migrated versions"
      task :schema_migrations => :environment do
        puts ActiveRecord::Base.connection.select_values(
          'select version from schema_migrations order by version' )
        end
      end

We can run this from the command line just like any other Rake task.
就像任何其他的Rake任务一样，可以从命令行运行它：

    depot> rake db:schema_migrations
    (in /Users/rubys/Work/...)
    20121130000001
    20121130000002
    20121130000003
    20121130000004
    20121130000005
    20121130000006
    20121130000007

• 267

Consult the Rake documentation at http://rubyrake.org/ for more information on writing Rake tasks.
可以在http://rubyrake.org上查阅Rake的文档，获得更多有关编写Rake任务的信息。

### 18.1.6 A Place for Our Logs 日志的位置
As Rails runs, it produces a bunch of useful logging information.
Rails运行是会生成许多有用的日志信息。
This is stored (by default) in the log directory.
这些信息（在默认情况下）会放在log目录下。
Here you’ll find three main log files, called development.log, test.log, and production.log.
在这个目录下可以发现三个主要的日志文件，分别是development.log, test.log和production.log。
The logs contain more than just simple trace lines; they also contain timing statistics, cache information, and expansions of the database statements executed.
这些日志文件不单包含简单的跟踪线，还包含时间统计、缓存信息，以及执行过的数据库语句的扩展。

Which file is used depends on the environment in which your application is running (and we’ll have more to say about environments when we talk about the config directory in A Place for Configuration, on page 268).
使用哪个日志文件取决于该应用程序运行的环境（在后面268页讨论config目录时，将介绍更多有关环境的内容。）

### 18.1.7 A Place for Static Web Pages 静态网页的位置
The public directory is the external face of your application.
public目录是应用程序的外部接口。
The web server takes this directory as the base of the application.
web服务器把这个目录作文应用程序的基础。
In here you place static (in other words, unchanging) files, generally related to the running of the server.
<kinder:note> 在这里放置了静态（换句话说，不变的）文件，一般和服务器的运行有关。

### 18.1.8 A Place for Script Wrappers 脚本的位置
If you find it helpful to write scripts that are launched from the command line and perform various maintenance tasks for your application, the bin directory is the place to put wrappers that call those scripts.
如果认为编写脚本代码很有帮助，可以在scripts目录中存放这些脚本；它们可以在命令行中运行，然后为应用程序执行各种各样的维护任务。
You can use bundle binstubs to populate this directory.
<kinder:note> 你可以使用`bundle binstubs`来移动这个目录。

This directory also holds the Rails script.
这个目录页保存Rails脚本。
This is the script that is run when you run the rails command from the command line.
在命令行运行rails命令时，就会运行这个Rails脚本。
The first argument you pass to that script determines the function Rails will perform.
第一个传入该脚本的参数决定了Rails将执行的函数。

console
Allows you to interact with your Rails application methods.
允许与Rails程序的方法交互。
dbconsole
Allows you to directly interact with your database via the command line.
允许直接通过命令行与数据库交互。
destroy
Removes autogenerated files created by generate.
删除由generate自动生成的文件。

• 268

generate
A code generator.
代码生成器。
Out of the box, it will create controllers, mailers, models, scaffolds, and web services.
在服务器外，它将生成控制器、邮件程序、模型、脚手架以及web服务器。
Run generate with no arguments for usage information on a particular generator; here’s an example:
不带任何参数运行generate可以得到特定生成器的用法信息。比如：

    rails generate migration

new
Generates Rails application code.
生成Rails应用程序代码。

runner
Executes a method in your application outside the context of the Web.
在web环境外的应用程序中执行一种方法。
This is the noninteractive equivalent of rails console.
这是一个rails console的非交互等价物。
You could use this to invoke cache expiry methods from a cron job or handle incoming email.
可以用它来从cron任务中调用缓存届满方法，或者处理收到的邮件。

server
Runs your Rails application in a self-contained web server, using Mongrel (if it is available on your box) or WEBrick.
使用Mongrel（如果它在服务器上可用）或WEBrick，让Rails应用程序在本身包含的Web服务器上运行。
We’ve been using this in our Depot application during development.
在开发Depot应用程序的过程中，已经使用过这个函数。

### 18.1.9 A Place for Temporary Files临时文件的位置
It probably isn’t a surprise that Rails keeps its temporary files tucked in the tmp directory.
Rails把临时文件放在tmp目录下也许并不令人惊讶。
You’ll find subdirectories for cache contents, sessions, and sockets in here.
在这儿可以找到缓存内容、会话和套接字的子目录。
Generally these files are cleaned up automatically by Rails, but occasionally if things go wrong, you might need to look in here and delete old files.
通常Rails会自动清除这些文件，但是如果偶然出错，可能需要到这里看一看，然后删除旧文件。

### 18.1.10 A Place for Third-Party Code 第三方代码的地方
The vendor directory is where third-party code lives.
vendor目录用来存放第三方代码。
You can install Rails and all of its dependencies into the vendor directory, as we saw in Getting an Application Under Control, on page 243.
可以将Rails机器所有的包依赖关系安装到vendor目录下，如前面243页16.2节所描述的那样。

If you want to go back to using the system-wide version of gems, you can delete the vendor/cache directory.
如果你想再次使用系统范围的gem版本，可以删除vendor/cache目录

### 18.1.11 A Place for Configuration 配置的位置
The config directory contains files that configure Rails.
config目录包含了配置Rails的文件。
In the process of developing Depot, we configured a few routes, configured the database, created an initializer, modified some locales, and defined deployment instructions.
在开发Depot的过程中，配置了一些新路由、配置了数据库、创建了初始化程序、修改了一些语言环境并且定义了部署。
The rest of the configuration was done via Rails conventions.
剩下的配置由Rails的约定完成。

Before running your application, Rails loads and executes config/environment.rb and config/application.rb.
在运行应用程序前，Rails加载并执行config/environment.rb文件和config/application.rb文件。
The standard environment set up automatically by these files includes the following directories (relative to your application’s base directory) in your application’s load path:
这些文件设置的标准环境会自动将以下目录包含在该应用程序的加载路径中（与这个应用程序的基础目录有关）：

• 269

• The app/controllers directory and its subdirectories
  app/controllers目录及其子目录。
• The app/models directory       
  app/models目录。       
• The vendor directory and the lib contained in each plugin subdirectory
  vendor目录以及每个plugin子目录下包含的lib目录。
• The directories app, app/helpers, app/mailers, app/services, and lib
  app目录、app/helper目录、app/mailer目录、app/services目录、config目录和lib目录。

Each of these directories is added to the load path only if it exists.
以上的每个目录只有在加载路径存在的情况下才会添加到其中。

In addition, Rails will load a per-environment configuration file.
此外，Rails会加载每个环境的配置文件。
This file lives in the environments directory and is where you place configuration options that vary depending on the environment.
这些文件在environment目录下，并且记录了存放配置选项的地点，这些配置文件花样百出，随环境而定。

This is done because Rails recognizes that your needs, as a developer, are very different when writing code, testing code, and running that code in production.
这么做的原因是Rails懂得，在编写代码、测试代码，以及在产品中运行代码时，开发人员的需求有所不同。
When writing code, you want lots of logging, convenient reloading of changed source files, in-your-face notification of errors, and so on.
在编写代码时，想要许多日志文件，想要方便地重载改变了的源文件，想要直截了当的错误通知等。
In testing, you want a system that exists in isolation so you can have repeatable results.
在测试中，则想要一个单独存在的系统，以便可以重复结果。
In production, your system should be tuned for performance, and users should be kept away from errors.
在生产环境中，系统应该转向提高性能，而用户则应远离错误。

The switch that dictates the runtime environment is external to your application.
对该应用程序来说，决定运行时环境的切换是外部的。
This means that no application code needs to be changed as you move from development through testing to production.
这意味着从开发到测试，再到生产，无需改变该应用程序的代码。
In Chapter 16, Task K: Deployment and Production, on page 233, we specified the environment on the rake command using a RAILS_ENV parameter and to Phusion Passenger using a RailsEnv line in our Apache configuration file.
在16章中，rake命令里使用了RAILS_ENV参数来指定环境，而Phusion Passenger则在Apache的配置文件中使用RailsEnv行。
When starting WEBrick with the rails server command, we use the -e option.
当用`rails server`命令启动WEBrick时，又使用-e选项：

    depot> rails server -e development
    depot> rails server -e test
    depot> rails server -e production

If you have special requirements, such as if you favor having a staging environment, you can create your own environments.
如果有特殊需求，例如，想要一个临时环境，也可以创建自己的环境。
You’ll need to add a new section to the database configuration file and a new file to the config/environments directory.
你需要在数据库的配置文件中添加一个新的部分，并且在config/environments目录下增加一个新文件。

What you put into these configuration files is entirely up to you.
在这些配置里面放什么东西完全取决于个人喜好。
You can find a list of configuration parameters you can set in the Configuring Rails Applications guide you generated with the rake doc:guides command in A Place for Documentation, on page 265.
在先前用`rake
doc:guides`命令生成的《配置Rails应用程序指南》中，能找到可以设置的配置参数列表。
This information is also available online.4 
这些信息在网上也能找到。
[4]. http://guides.rubyonrails.org/configuring.html


• 270

## 18.2 Naming Conventions 命令约定
Newcomers to Rails are sometimes puzzled by the way it automatically handles the naming of things.
刚接触Rails的新手有时会对Rails自动处理命令的方式感到迷惑。
They’re surprised that they call a model class Person and Rails somehow knows to go looking for a database table called people.
大家会惊奇地发现，调用Person模型类时，Rails自然而然得就知道要去寻找名为person的数据库表。
In this section, you’ll learn how this implicit naming works.
在这一节中，将学习这种隐式命名的工作原理。

The rules here are the default conventions used by Rails.
这里提及的规则是Rails使用的默认约定。
You can override all of these conventions using configuration options.
可以使用配置选项来重写所有约定。

### 18.2.1 Mixed Case, Underscores, and Plurals 混合大小写、下划线和复数
We often name variables and classes using short phrases.
通常使用短语来命令变量和类。
In Ruby, the convention is to have variable names where the letters are all lowercase and words are separated by underscores.
在Ruby中，约定**变量**全部小写，词与词之间用下划线分开。
Classes and modules are named differently: there are no underscores, and each word in the phrase (including the first) is capitalized.
**类和模块**的命名则不同：不使用下划线，短语中的每个词（包括第一个词）开头都要大写。
(We’ll call this mixed case, for fairly obvious reasons.) 
（相当明显，这种形式称为混合大小写）
These conventions lead to variable names such as order_status and class names such as LineItem.
这些约定让变量名看起来如order_status，而类名则是LineItem。

Rails takes this convention and extends it in two ways.
Rails继承了这些约定，并且在两个方面进行了扩展。
First, it assumes that database table names, such as variable names, have lowercase letters and underscores between the words.
第一，Rails假设数据库表名像变量名，由小写字母组成，词之间用下划线连接。
Rails also assumes that table names are always plural.
Rails还假设表名总是复数的。
This leads to table names such as orders and third_parties.
于是，表名看起来就像orders和third_parties。

On another axis, Rails assumes that files are named using lowercase with underscores.
第二方面，Rails假设**文件名**由小写字母和下划线组成。
Rails uses this knowledge of naming conventions to convert names automatically.
Rails使用命名约定的知识来自动转换名称。
For example, your application might contain a model class that handles line items.
例如，应用程序可能包含处理商品项目的模型类。
You’d define the class using the Ruby naming convention, calling it LineItem.
可以用Ruby的命名约定来定义类的名称，如LineItem。
From this name, Rails would automatically deduce the following:
从这个名称开始，Rails会自动推导出以下内容：

• That the corresponding database table will be called line_items.
  相关联的数据表名为line_items。
That’s the class name, converted to lowercase, with underscores between the words and pluralized.
这是类名转化为小写，然后在词之间加入下划线，最后在复数化的结果。

• Rails would also know to look for the class definition in a file called line_item.rb (in the app/models directory).
  Rails还知道去line_item.rb文件中（app/models目录下）寻找类的定义。

Rails controllers have additional naming conventions.
Rails控制器也有额外的命名约定。
If our application has a store controller, then the following happens:
倘若应用程序中有商店控制器，那么将发生下面的事情：

• Rails assumes the class is called StoreController and that it’s in a file named store_controller.rb in the app/controllers directory.
  Rails假设类名为StoreController，并且这个类在app/controllers目录下的store_controller.rb中。

• 271

• Rails also looks for a helper module named StoreHelper in the file store_helper.rb located in the app/helpers directory.
  Rails也会假设app/helpers目录下的store_helper.rb文件中有一个StoreHelper的帮助程序模块。

• It will look for view templates for this controller in the app/views/store directory.
  Rails也会在app/views/store目录下为这个控制器寻找视图模板。

• It will by default take the output of these views and wrap them in the layout template contained in the file store.html.erb or store.xml.erb in the directory app/views/layouts.
  默认情况下，Rails将取得所有视图的输出，将它们包装到布局模板中；布局模板在app/views/layouts目录下的store.html.erb或store.xml.erb中。

All these conventions are shown in the following tables.
所有这些约定如下图所示：

    Model Naming 模型命名
    Table line_items
    File app/models/line_item.rb
    Class LineItem
    
    Controller Naming  控制器命名
    URL http://../store/list
    File app/controllers/store_controller.rb
    Class StoreController
    Method list
    Layout app/views/layouts/store.html.erb
    
    View Naming 视图命名
    URL http://../store/list
    File app/views/store/list.html.erb (or .builder)
    Helper module StoreHelper
    File app/helpers/store_helper.rb

There’s one extra twist.
还有另外的一点。
In normal Ruby code you have to use the require keyword to include Ruby source files before you reference the classes and modules in those files.
普通的Ruby代码中，要引用Ruby源文件内定义的那些类和模块之前，必须使用require关键字来包含这些文件。
Because Rails knows the relationship between filenames and class names, require is normally not necessary in a Rails application.
因为Rails直到文件名和类名之间的关系，require在Rails应用程序中通常没有必要。
The first time you reference a class or module that isn’t known, Rails uses the naming conventions to convert the class name to a filename and tries to load that file behind the scenes.
第一次引用未知的类或模块时，Rails使用命名约定来把类名转换为文件名，并且尝试加载文件背后的场景。
The net effect is that you can typically reference (say) the name of a model class, and that model will be automatically loaded into your application.
这样产生的连锁效应是，只要引用模型类的名称，然后这个模型就会自动下载到应用程序中。


### 18.2.2 Grouping Controllers into Modules 把控制器分组到模块中。
So far, all our controllers have lived in the app/controllers directory.
至此，所有的控制器都放置在app/controller目录下。
It is sometimes convenient to add more structure to this arrangement.
有时约定也会添加更多结构到这个目录中。
For example, our store might end up with a number of controllers performing related but disjoint administration functions.
比如，在线商店可能最终有许多控制器，这些控制器配合执行，但管理功能却不相交。

• 272 

Rather than pollute the top-level namespace, we might choose to group them into a single admin namespace.
可以选择将这些控制器分组到一个单独的admin命令空间下，而不是去干扰高级别的命令空间。

Rails does this using a simple naming convention.
Rails用简单的命名约定来完成这件事。
If an incoming request has a controller named (say) admin/book, Rails will look for the controller called book_controller in the directory app/controllers/admin.
如果传入的请求包含名为admin/book的控制器，Rails将在app/controllers/admin目录下寻找名称为book_controller的控制器。
That is, the final part of the controller name will always resolve to a file called name_controller.rb, and any leading path information will be used to navigate through subdirectories, starting in the app/controllers directory.
也就是说，控制器名称的最后部分总是指向name_controller.rb，并且所有指向路径的信息都会用于为子目录定位，而所有的定位都始于app/controllers目录。

Imagine that our program has two such groups of controllers (say, admin/xxx and content/xxx) and that both groups define a book controller.
试想，程序有两个控制器组（比如admin/xxx和content/xxx），并且两个组都各定义了book控制器。
There’d be a file called book_controller.rb in both the admin and content subdirectories of app/controllers.
这样，在app/controllers目录的admin和content子目录下都将会有book_controller.rb文件。
Both of these controller files would define a class named BookController.
这两个控制器文件都可以定义BookController类。
If Rails took no further steps, these two classes would clash.
如果Rails不作任何分析，这两个类就会发生冲突。

To deal with this, Rails assumes that controllers in subdirectories of the directory app/controllers are in Ruby modules named after the subdirectory.
要解决这个问题，Rails假设app/controllers子目录下的控制器都在Ruby模块下，并且以子目录命名。
Thus, the book controller in the admin subdirectory would be declared like this:
这样，在admin子目录里的book控制器将以如下形式声明：

    class Admin::BookController < ActionController::Base
    # ...
    end

The book controller in the content subdirectory would be in the Content module:
而content子目录下的book控制器则在Content模块中。

    class Content::BookController < ActionController::Base
    # ...
    end

The two controllers are therefore kept separate inside your application.
因此，这两个控制器就在该应用程序中分割开了。
The templates for these controllers appear in subdirectories of app/views.
这些控制器的模板在app/views的子目录中。
Thus, the view template corresponding to this request:
所以，视图模板的相关请求：

    http://my.app/admin/book/edit/1234

will be in this file:
将保存在这个目录下：

    app/views/admin/book/edit.html.erb

You’ll be pleased to know that the controller generator understands the concept of controllers in modules and lets you create them with commands such as this:
你将会高兴地2直到，控制器生成器懂得控制器在模块中的概念，可以用如下命令创建它们：

    myapp> rails generate controller Admin::Book action1 action2 ...

• 273

------------------------------
------------------------------
David says: Why Plurals for Tables? 为什么表名要使用复数？
Because it sounds good in conversation.
因为它符合使用日常对话的习惯。
Really.
确实如此。
“Select a Product from products.” 
例如：“Select a Product from products.”
And “Order has_many :line_items.” 
或者：“Order has_many :line_items.” 
The intent is to bridge programming and conversation by creating a domain language that can be shared by both.
这么做的目的是，通过创建一种能在编程和语言之间共享的领域语言，使它们能够沟通。
Having such a language means cutting down on the mental translation that otherwise confuses the discussion of a product description with the client when it’s really implemented as merchandise body.
这样一种语言意味着减少人工翻译，因此也减少了当讨论真正落实为商品主体、与客户讨论产品描述时所产生的歧义。
These communications gaps are bound to lead to errors.
这些沟通的缺陷必会导致错误。

Rails sweetens the deal by giving you most of the configuration for free if you follow the standard conventions.
如果遵循标准约定，Rails将免费提供大部分的配置让用户尝尝甜头。
Developers are thus rewarded for doing the right thing, so it’s less about giving up “your ways” and more about getting productivity for free.
因此，开发者会因为作对事情而得到奖励；Rails不是要你放弃“自己的方式”，而是提倡免费得到生产力。

------------------------------
------------------------------

## What We Just Did 本章小结
Everything in Rails has a place, and we systematically explored each of those nooks and crannies.
Rails中的每样东西都有位置，而我们系统地探讨了那些角落和缝隙。
In each place, files and the data contained in them follow naming conventions, and we covered that too.
在每个地方，Rails包含的文件和数据都遵循命令约定，这些已经讨论过了。
Along the way, we filled in a few missing pieces.
同时，还填补了一些缺失的地方。

• We generated both API and user guide documentation for Rails.
  为Rails本身生成API和用户指南文件。
• We added a Rake task to print the migrated versions.
  添加Rake任务来显示迁移的版本。
• We showed how to configure each of the Rails execution environments.
  展示了如何单独地配置每个Rails执行文件的环境。
Next up are the major subsystems of Rails, starting with the largest, Active Record.
接下来要讨论的是Rails的主要子系统，从最大的Active Record开始。

# CHAPTER 19 Active Record 活性记录
## In this chapter, we’ll see
   在本章中，我们将学习
• the establish_connection method;
  方法establish_connection；
• tables, classes, columns, and attributes;
  表、类、字段和属性；
• IDs and relationships;
  属性ID及其相互关系；
• create, read, update, and delete operations; and
   创建、读取、更新和删除操作；
• callbacks and transactions.
  回调和事务。

Active Record is the object-relational mapping (ORM) layer supplied with Rails.
Rails提供了对象关系映射层的Active Record。
It is the part of Rails that implements your application’s model.
它是Rails中实现应用程序模型的部分。

In this chapter, we’ll build on the mapping data to rows and columns that we did in Depot.
在这一章中，我们将数据映射到表的行和列，正如前面Depot程序所做的那样。
Then we’ll look at using Active Record to manage table relationships and in the process cover create, read, update, and delete operations (commonly referred to in the industry as CRUD methods).
然后，借助ActiveRecord管理表的关联，并处理创建、读取、更新和删除操作（即通常业内所说的CRUD方法）。
Finally, we will dig into the Active Record object life cycle (including callbacks and transactions).
最后，还将进一步探讨ActiveRecord对象的生命周期（包括回调和事务）。

## 19.1 Defining Your Data 定义数据结构
### 前言
In Depot, we defined a number of models, including one for an Order.
在Depot中，定义了一组模型，其中包括Order模型。
This particular model has a number of attributes, such as an email address of type String.
这一特殊模型具有许多属性，比如数据类型是字符串的电子邮箱地址等。
In addition to the attributes that we defined, Rails provided an attribute named id that contains the primary key for the record.
除了定义属性之外，Rails还提供了名为id的属性，用来标识数据库记录的主键。
Rails also provides several additional attributes, including attributes that track when each row was last updated.
Rails还提供了其他几个属性，包括跟踪何时更新过数据库记录。
Finally, Rails supports relationships between models, such as the relationship between orders and line items.
最后，Rails完全支持模型（如Order与LineItem模型）之间的互相关联。

When you think about it, Rails provides a lot of support for models.
就像你想象的那样，Rails对模型提供了大量支持。
Let’s examine each in turn.
就此逐个作如下探讨。

### 19.1.1 Organizing Using Tables and Columns 使用表和字段的规则
Each subclass of ActiveRecord::Base, such as our Order class, wraps a separate database table.
ActiveRecord::Base的每个子类，如类Order，封装了各自的数据库表。
By default, Active Record assumes that the name of the table associated with a given class is the plural form of the name of that class.
默认情况下，Active Record假定，与给定模型关联的**表名是该类名的复数形式**。
If the class name contains multiple capitalized words, the table name is assumed to have underscores between these words.
如果类名包含多个大写的单词，则应在这些**单词之间使用下划线划分表明**。

Classname Table Name 
模型类名  数据库表名
Order     orders
TaxAgency tax_agencies
Batch     batches
Diagnosis diagnoses
LineItem  line_items
Person    people
Datum     data
Quantity  quantities

• 276

These rules reflect Rails’ philosophy that class names should be singular while the names of tables should be plural.
这些原则反映了Rails的哲学，即模型类应该是单数形式，而对应的数据库表名则应是复数形式。
 Although Rails handles most irregular plurals correctly, occasionally you may stumble across one that is not handled correctly.
虽然Rails能够正确处理大多数的非规则英文单词复数形式，但有时也会偶然发现不能正确处理的情况。
If you encounter such a case, you can add to Rails’ understanding of the idiosyncrasies and inconsistencies of the English language by modifying the inflection file provided.
如果遇到这类情况，可以通过修改**词形变化文件**，补充英语语言的特异性和不一致性，使得Rails可以理解它们。

    Download rails40/depot_t/config/initializers/inflections.rb
    # Be sure to restart your server when you modify this file.
    # Add new inflection rules using the following format. Inflections
    # are locale specific, and you may define rules for as many different
    # locales as you wish. All of these examples are active by default:
    # ActiveSupport::Inflector.inflections(:en) do |inflect|
    #   inflect.plural /^(ox)$/i, '\1en'
    #   inflect.singular /^(ox)en/i, '\1'
    #   inflect.irregular 'person', 'people'
    #   inflect.uncountable %w( fish sheep )
    # end
    # These inflection rules are supported but not enabled by default:
    # ActiveSupport::Inflector.inflections(:en) do |inflect|
    # inflect.acronym 'RESTful'
    # end
    ActiveSupport::Inflector.inflections do |inflect|
      inflect.irregular 'tax', 'taxes'
    end

If you have legacy tables you have to deal with or don’t like this behavior, you can control the table name associated with a given model by setting the table_name for a given class.
如果有必要处理应用程序的遗留表或者不喜欢这种关系方式，通过对给定的类设置table_name的值，就可以**管理与已知模型类关联的表**：

    class Sheep < ActiveRecord::Base
      self.table_name = "sheep"
    end
    <kinder:note> 这个文件应该就是app/models/sheep.rb

• 277

-----------------------------
-----------------------------
David says: Where Are Our Attributes?  属性在哪里？
The notion of a database administrator (DBA) as a separate role from programmer has led some developers to see strict boundaries between code and schema.
由于区别对待程序员和数据库管理员，以致一些开发人员看到了在程序代码和数据库结构描述之间的严格界限。
Active Record blurs that distinction, and no other place is that more apparent than in the lack of explicit attribute definitions in the model.
Active Record模糊了这个界限，在模型中已不需要显式地定义属性。

But fear not.
但也不用担心。
Practice has shown that it makes little difference whether we’re looking at a database schema, a separate XML mapping file, or inline attributes in the model.
实践已经证明，无论是在看待数据库结构描述、单独XML映射文件中，还是模型的内联属性，这种差异都在变小。
The composite view is similar to the separations already happening in the ModelView-Control pattern—just on a smaller scale.
复合视图是类似于这种分离的概念，这种概念已经在“模型-视图-控制器”模式中出现了——只是在更小的范围内。

 Once the discomfort of treating the table schema as part of the model definition has dissipated, you’ll start to realize the benefits of keeping DRY.
处理表结构描述并不是一件令人愉快的事情，一旦把它作为模型定义的一部分，这种不快也就不存在了，这时你会开始体会到保持整洁的好处。
When you need to add an attribute to the model, you simply have to create a new migration and reload the application.
当需要添加属性到模型中时，就只需先创建新的迁移，然后把它重新加载到该应用程序中。

Taking the “build” step out of schema evolution makes it just as agile as the rest of the code.
以“构建”形式走出传统软件开发模式的这种演变，使其像使用其他代码一样敏捷。
It becomes much easier to start with a small schema and extend and change it as needed.
这样就更容易从少量的结构描述开始，当需要时再不断进行扩充和改变。

-----------------------------
-----------------------------

Instances of Active Record classes correspond to rows in a database table.
Active Record模型类对应于数据库表的行。
These objects have attributes corresponding to the columns in the table.
而对象的属性则对应于数据库表的字段。
You probably noticed that our definition of class Order didn’t mention any of the columns in the orders table.
你可能已经注意到了，这里并没有在Order类定义中涉及orders表的任何字段。
That’s because Active Record determines them dynamically at runtime.
这是因为Active Record可以在运行时动态地确定它们。
Active Record reflects on the schema inside the database to configure the classes that wrap tables.
**Active Record映射数据库表的内部模式，以配置封装的表的类**。

In the Depot application, our orders table is defined by the following migration:
在Depot应用程序中，下面的迁移代码定义了orders表：

    Download rails40/depot_r/db/migrate/20121130000007_create_orders.rb
    class CreateOrders < ActiveRecord::Migration
      def change
        create_table :orders do |t|
          t.string :name
          t.text :address
          t.string :email
          t.string :pay_type
          t.timestamps
        end
      end
    end

Let’s use the handy-dandy rails console command to play with this model.
可以在Rails console里先试一下这个模型。
First, we’ll ask for a list of column names.
首先查询字段名清单。

• 278


    depot> rails console
    Loading development environment (Rails 4.0.0)
    >> Order.column_names
    => ["id", "name", "address", "email", "pay_type", "created_at", "updated_at"]

Then we’ll ask for the details of the pay_type column.
然后查询字段pay_type的详细信息：

    >> Order.columns_hash["pay_type"]
    => #<ActiveRecord::ConnectionAdapters::SQLite3Column:0x00000003618228
    @name="pay_type", @sql_type="varchar(255)", @null=true, @limit=255,
    @precision=nil, @scale=nil, @type=:string, @default=nil,
    @primary=false, @coder=nil>

Notice that Active Record has gleaned a fair amount of information about the pay_type column.
注意，Active Record 已收集了有关pay_type字段的大量信息。
It knows that it’s a string of at most 255 characters, it has no default value, it isn’t the primary key, and it may contain a null value.
大家知道，这个字段最多可以有10个字符的字符串，没有默认值，不是主键，可能包含空值。
Rails obtained this information by asking the underlying database the first time we tried to use the Order class.
在前面首次尝试使用Order类时，Rails通过底层数据库得到了这一信息。

The attributes of an Active Record instance generally correspond to the data in the corresponding row of the database table.
Active Record对象的属性通常对应于数据库表相应行的数据记录。
For example, our orders table might contain the following data:
例如，表orders应该包含以下数据：

    depot> sqlite3 -line db/development.sqlite3 "select * from orders limit 1"
    id = 1
    name = Dave Thomas
    address = 123 Main St
    email = customer@example.com
    pay_type = Check
    created_at = 2013-01-29 14:39:12.375458
    updated_at = 2013-01-29 14:39:12.375458

If we fetched this row into an Active Record object, that object would have seven attributes.
如果把查询到的行记录存到Active Record对象中，那么该对象将有7个属性。
The id attribute would be 1 (a Fixnum), the name attribute would be the string "Dave Thomas", and so on.
属性id应该是1,（一个Fixnum对象），属性name应该是字符串“Dave Thomas”等，其他属性就不再一一罗列了。

We access these attributes using accessor methods.
通过accessor方法可以访问这些属性。
Rails automatically constructs both attribute readers and attribute writers when it reflects on the schema.
Rails映射到结构描述时，Rails自动构造属性的读与写方法。

    o = Order.find(1)
    puts o.name               #=> "Dave Thomas" 
    o.name = "Fred Smith"     # set the name

Setting the value of an attribute does not change anything in the database—we must save the object for this change to become permanent.
**设置属性值不会改变数据库的任何东西**——必须保持所修改的对象，如果需要固化这种更改。

• 279

The value returned by the attribute readers is cast by Active Record to an appropriate Ruby type if possible (so, for example, if the database column is a timestamp, a Time object will be returned).
Active
Record把读取属性返回值尽可能地转换为适当的Ruby类型。例如，如果数据库字段是时间戳，那么返回Time时间对象。
If we want to get the raw value of an attribute, we append _before_type_cast to its name, as shown in the following code:
如果想获得属性的原始值，就在其名称后追加`_before_type_cast`，如下列代码所示：

    product.price_before_type_cast      #=> 34.95, a float
    product.updated_at_before_type_cast #=> "2013-02-13 10:13:14"

Inside the code of the model, we can use the read_attribute() and write_attribute() private methods.
在模型的代码中，可以使用read_attribute()和write_attribute()私有方法。
These take the attribute name as a string parameter.
它们的字符串参数是属性名称。

We can see the mapping between SQL types and their Ruby representation in the following table.
下面的表格可以看到SQL语言类型和Ruby语言类型表达形式之间的映射。
Decimal and Boolean columns are slightly tricky.
Decimal和Boolean字段稍微棘手一点。

    SQL Type                 Ruby Class
    int, integer             Fixnum
    float, double            Float
    decimal, numeric         BigDecimal
    char, varchar, string    String
    interval, date           Date
    datetime, time           Time
    clob, blob, text         String
    boolean                  See text（参见test）
    Table 1—Mapping SQL types to Ruby types
    表格1, SQL类型和Ruby类型的映射

Rails maps columns with Decimals with no decimal places to Fixnum objects; otherwise, it maps them to BigDecimal objects, ensuring that no precision is lost.
Rails把无小数的Decimal字段映射为Fixnum对象；其他情况下，将它映射到BigDecimal对象，可以确保其精度不会丢失。

In the case of Boolean, a convenience method is provided with a question mark appended to the column name.
至于Boolean，可以给字段名附加一个问号替代这些值的直接使用。
<kinder:note> 第四版解释得更详细：
事实上，并非所有的数据库都有原生boolean类型。如在MySQL中，0代表false，而1代表true。
遗憾的是，Ruby把所有不是false或nil的对象都视为true，所以直接使用这些值是有问题的。
</kinder:note> 

    user = User.find_by(name: "Dave")
    if user.superuser?
      grant_privileges
    end

In addition to the attributes we define, there are a number of attributes that either Rails provides automatically or have special meaning.
除了上面的定义的属性外，还有大量具有特殊含义的属性，Rails也自动提供了属性。

### 19.1.2 Additional Columns Provided by Active Record 附加字段
A number of column names have special significance to Active Record. 
大量字段名对Active Record有着特殊意义。
Here’s a summary:
这里摘要如下：

• 280

#### created_at, created_on, updated_at, updated_on
These are automatically updated with the timestamp of a row’s creation or last update.
行记录的创建或最后更新的时间戳是自动更新的。
Make sure the underlying database column is capable of receiving a date, datetime, or string.
这样可确保底层数据库字段有接收日期、日期时间或字符串的能力。
Rails applications conventionally use the _on suffix for date columns and the _at suffix for columns that include a time.
Rails应用程序通常对于日期字段使用`_on`后缀，而时间字段采用`_at`后缀。

#### id
This is the default name of a table’s primary key column (in Identifying Individual Rows, on page 280).
这是表的主键字段的默认名称（在下面的“识别单行”一节中）。

#### xxx_id
This is the default name of a foreign key reference to a table named with the plural form of xxx.
这是外键引用表的默认名称，xxx是该表名称的复数形式。

#### xxx_count
This maintains a counter cache for the child table xxx.
这是维护子表xxx的计数器缓存。
Additional plugins, such as acts_as_list [1], may define additional columns.
附加的插件，如acts_as_list，可以用来定义补充的字段。
[1]. https://github.com/rails/acts_as_list

Both primary keys and foreign keys play a vital role in database operations and merit additional discussion.
在数据库操作中，主键和外键起到了至关重要的作用，并值得进一步讨论。

## 19.2 Locating and Traversing Records 查找和遍历记录
In the Depot application, LineItems have direct relationships to three other models: Cart, Order, and Product.
在Depot应用程序中，类LineItem直接关联到三个其他模型：Cart，Order，Product。
Additionally, models can have indirect relationships mediated by resource objects.
另外，借助于resource资源对象，也可实现模型间的关联。
The relationship between Orders and Products through LineItems is an example of such a relationship.
借助于模型LineItems，实现在模型Order和模型Product之间的关联就是这样的示例。

All of this is made possible through IDs.
所有这一切都离不开主键id。

### 19.2.1 Identifying Individual Rows 识别单行
Active Record classes correspond to tables in a database.
Active Record类对应着数据库的表。
Instances of a class correspond to the individual rows in a database table.
类的实例对应着数据库表的单个行记录。
Calling Order.find(1), for instance, returns an instance of an Order class containing the data in the row with the primary key of 1.
例如，调用Order.find(1)，返回Order类的实例，该实例包含主键id为1的行记录数据。

If you’re creating a new schema for a Rails application, you’ll probably want to go with the flow and let it add the id primary key column to all your tables.
如果正在创建新的Rails应用程序结构描述，那么就可能会顺其自然，让id主键字段添加到所有表中。
However, if you need to work with an existing schema, Active Record gives you a simple way of overriding the default name of the primary key for a table.
但是，如果需要使用已有的结构描述，那么Active Record提供了**覆盖表主键默认名**的简单方法。

• 281

For example, we may be working with an existing legacy schema that uses the ISBN as the primary key for the books table.
比如，也许会利用现有遗留结构描述的工作，使用ISBN作为books表的主键。

We specify this in our Active Record model using something like the following:
通过下面的Active Record模型代码，可以详细说明这一点。

    class LegacyBook < ActiveRecord::Base
      self.primary_key = "isbn"
    end

Normally, Active Record takes care of creating new primary key values for records that we create and add to the database—they’ll be ascending integers (possibly with some gaps in the sequence).
通常为了已创建的并添加到数据库的行记录，Active Record会小心创建新的递增整数主键值。
However, if we override the primary key column’s name, we also take on the responsibility of setting the primary key to a unique value before we save a new row.
不过，如果要覆盖主键字段名，那么，在保存新纪录前，也必须把主键设置为唯一值。
Perhaps surprisingly, we still set an attribute called id to do this.
这也许令人不可思议，但我们仍然设置属性名为id来做到这一点。
As far as Active Record is concerned, the primary key attribute is always set using an attribute called id.
**只要涉及Active Record，主键属性就始终为设置成称为id的属性**。
The primary_key= declaration sets the name of the column to use in the table.
声明primary_key=只是设定了用于表中的字段名。
In the following code, we use an attribute called id even though the primary key in the database is isbn:
即使数据库的主键是isbn，也可称为id属性，如下所示：

    book = LegacyBook.new
    book.id = "0-12345-6789"
    book.title = "My Great American Novel"
    book.save
    # ...
    book = LegacyBook.find("0-12345-6789")
    puts book.title # => "My Great American Novel"
    p book.attributes #=> {"isbn" =>"0-12345-6789",
                      #    "title"=>"My Great American Novel"}
    
Just to make life more confusing, the attributes of the model object have the column names isbn and title—id doesn’t appear.
但令人更难以理解的是，具有isbn和title字段的模型对象属性id并未出现。
When you need to set the primary key, use id.
只需要记住，在需要设置主键时使用id。
At all other times, use the actual column name.
而在其他情况下，就用实际的字段名。

Model objects also redefine the Ruby id() and hash() methods to reference the model’s primary key.
为了访问模型的主键，模型对象也重新定义了Ruby的id和hash方法。
This means that model objects with valid IDs may be used as hash keys.
这意味着，取得有效id的模型对象就可以作为hash键使用。
It also means that unsaved model objects cannot reliably be used as hash keys (because they won’t yet have a valid ID).
这也意味着，**未保存的模型对象**无法可靠地用作hash键（因为它们还没有有效的id）。

One final note: Rails considers two model objects as equal (using ==) if they are instances of the same class and have the same primary key.
最后一点，如果两个模型对象是同一个类的实例，并有相同的主键，那么Rails就认为它们是相等的（使用==方法）。
This means that unsaved model objects may compare as equal even if they have different attribute data.
这就是说，未保存的模型对象比较时会返回“是相等”的结果，即使它们具有不同的属性数据。
<kinder:note> 这是说未保存的模型对象的id都是nil，因此比较结果是相等。
If you find yourself comparing unsaved model objects (which is not a particularly frequent operation), you might need to override the == method.
如果发现自己正在比较未保存的模型对象（这不是特别常用的一种操作），那么可能需要重写==方法。

As we will see, IDs also play an important role in relationships.
正如下面将要看到的，主键属性ID在关联中扮演着重要的角色。

• 282

### 19.2.2 Specifying Relationships in Models 指定模型关联
Active Record supports three types of relationship between tables: one-to-one, one-to-many, and many-to-many.
Active Record支持三种表之间的关系：一对一，一对多，多对多。
You indicate these relationships by adding declarations to your models: has_one, has_many, belongs_to, and the wonderfully named has_and_belongs_to_many.
通过添加模型声明，可以表示这些关联，如has_one、has_many、belongs_to，以及更奇妙的函数has_and_belongs_to_many。

### 19.2.3 One-to-One Relationships 一对一的关联
A one-to-one association (or, more accurately, a one-to-zero-or-one relationship) is implemented using a foreign key in one row in one table to reference at most a single row in another table.
一对一关联（或者更准确点，一对零或一对一关联），是指通过使用一个表中任何一行的外键，引用另一个表中一行的记录来实现。
A one-to-one relationship might exist between orders and invoices: for each order there’s at most one invoice.
在表orders和表invoices之间应该存在一对一关联：每个订单最多有一张发票。

    invoices                         orders
    id                 +-----------> id
    order_id ----------+             name
    ...                              ...


    class Invoice < ActiveRecord::Base
      belongs_to :order
      #...
    end
    
    class Order < ActiveRecord::Base
      has_one :invoice
      #...
    end

As the example shows, we declare this in Rails by adding a has_one declaration to the Order model and by adding a belongs_to declaration to the Invoice model.
如上图所示，在Rails程序中，把has_one声明加入到模型Order，而把belongs_to声明加入到模型Invoice。
There’s an important rule illustrated here: the model for the table that contains the foreign key always has the belongs_to declaration.
上图还隐含一个重要规则：包含外键表的模型总是具有声明belongs_to的。

### 19.2.4 One-to-Many Relationships 一对多关联
A one-to-many association allows you to represent a collection of objects.
一对多的关联可以代表一个多对象集合。
For example, an order might have any number of associated line items.
比如，一个订单应该关联很多商品项目。
In the database, all the line item rows for a particular order contain a foreign key column referring to that order.
在数据库中，对于特定订单而言，所有的商品项目记录都包含引用订单的外键字段。

    line_items                   orders
    id                +---------> id
    order_id ---------+           name
    ...                          ...
    
    class LineItem < ActiveRecord::Base
      belongs_to :order
      #...
    end
    
    class Order < ActiveRecord::Base
      has_many :line_items
      #...
    end

• 283

In Active Record, the parent object (the one that logically contains a collection of child objects) uses has_many to declare its relationship to the child table, and the child table uses belongs_to to indicate its parent.
在 Active
Record中，父对象（逻辑上包含字对象集合的对象）使用has_many声明其与字对象的关联，而子对象使用belongs_to来指向其父对象。
In our example, class LineItem belongs_to :order, and the orders table has_many :line_items.
在上例中，类LineItem使用代码belongs_to :orders，类Order使用代码has_many :line_items。

Note that, again, because the line item contains the foreign key, it has the belongs_to declaration.
注意，因为表line_items包含外键，所以类LineItem要声明belongs_to。

### 19.2.5 Many-to-Many Relationships 多对多关联
Finally, we might categorize our products.
最后该把商品分门别类。
A product can belong to many categories, and each category may contain multiple products.
一个商品可以属于多个类别，而每个类别可能包含多个商品。
This is an example of a many-to-many relationship.
这是多对多关联的例子。
It’s as if each side of the relationship contains a collection of items on the other side.
似乎看起来，关联的任何一方都包含了对方的项目集合。

    categories    categories_products    products
    id  <-------- category_id     +----> id
    name          product_id ---- +      name
    ...                                  ...

    class Category< ActiveRecord::Base
      has_and_belongs_to_many :products
      #...
    end
    
    class Product< ActiveRecord::Base
      has_and_belongs_to_many :categories
      #...
    end

In Rails we can express this by adding the has_and_belongs_to_many declaration to both models.
在Rails中，可以把has_and_belongs_to_many声明添加到两个模型中。
Many-to-many associations are symmetrical—both of the joined tables declare their association with each other using “habtm.”
多对多关联是对称的——用“habtm”声明相关的两个表实现了相互关联。
Rails implements many-to-many associations using an intermediate join table.
Rails使用一个中间连接表实现多对多关联。
This contains foreign key pairs linking the two target tables.
这个中间连接表包含连接两个目标表的外键对。
Active Record assumes that this join table’s name is the concatenation of the two target table names in alphabetical order.
Active
Record假定，连接表的名称是由两个目标表按字母顺序连接组成，连接符采用下划线。
In our example, we joined the table categories to the table products, so Active Record will look for a join table named categories_products.
在上例中，把表categories和表products连接起来，这样Active Record会查找名称为categories_products的连接表。

We can also define join tables directly.
也可以直接定义连接表。
In the Depot application, we defined a LineItems join, which joined Products to either Carts or Orders.
在Depot应用程序中定义了LineItems连接，它把Products和Carts或Orders连接起来。
Defining it ourselves also gave us a place to store an additional attribute, namely, a quantity.
自己定义中间连接表的办法也提供了存储附加属性（如quantity）的地方。
<kinder:note> 这个好处是categories_products表所不能得到的吗？

Now that we have covered data definitions, the next thing you would naturally want to do is access the data contained within the database, so let’s do that.
现在解释完了数据定义的内容，接下来要做的是访问数据库内所包含的数据，让我们一起来做吧。

• 284

## 19.3 Creating, Reading, Updating, and Deleting (CRUD) 创建、读取、更新和删除操作
### 前言
Names such as SQLite and MySQL emphasize that all access to a database is via the Structured Query Language (SQL).
正如数据库SQLite和MySQL名称所强调的那样，访问数据库都是借助结构化查询语言。
In most cases, Rails will take care of this for you, but that is completely up to you.
大多数情况下，Rails将负责这一工作，不过是否使用SQL语句则完全取决于我们。
As you will see, you can provide clauses or even entire SQL statements for the database to execute.
像后面将要看到的，不仅可以提供SQL语言子句，而且还支持数据库可执行的完整SQL语句。

If you are familiar with SQL already, as you read this section take note of how Rails provides places for familiar clauses such as select, from, where, group by, and so on.
如果你已经熟悉SQL语言，在阅读本节时，就会注意到Rails是如何提供众所周知的SQL语言子句，如select from where和group by等。
If you are not already familiar with SQL, one of the strengths of Rails is that you can defer knowing more about such things until you actually need to access the database at this level.
如果你还不太熟悉SQL语言，那么Rails的优势之一就是可以把这方面的只是暂时搁置，直到真正需要在数据库层面才会这么做。

In this section, we’ll continue to work with the Order model from the Depot application for an example.
针对Depot应用程序的模型Order，在本节中将继续推进这一实例工作。
We will be using Active Record methods to apply the four basic database operations: create, read, update, and delete.
下面将使用ActiveRecord方法，以便应用这四个基本数据库操作：创建、读取、更新和删除。

### 19.3.1 Creating New Rows 创建新的行记录
Given that Rails represents tables as classes and rows as objects, it follows that we create rows in a table by creating new objects of the appropriate class.
鉴于Rails视表为类且视对象为行记录，过程是：先创建类的新对象，然后开始建立相应表的行记录。
We can create new objects representing rows in our orders table by calling Order.new().
例如，先调用Order.new，创建Order类的新对象，该对象对应于表orders的行记录。
We can then fill in the values of the attributes (corresponding to columns in the database).
然后输入属性值（对应到数据库中的字段值）。
Finally, we call the object’s save() method to store the order back into the database.
最后调用该订单对象的save方法，存储到数据库中。
Without this call, the order would exist only in our local memory.
如果不调用save方法，则订单对象只存在与本地计算机内存中。

    Download rails40/e1/ar/new_examples.rb
    an_order = Order.new
    an_order.name = "Dave Thomas"
    an_order.email = "dave@example.com"
    an_order.address = "123 Main St"
    an_order.pay_type = "check"
    an_order.save

Active Record constructors take an optional block.
**Active Record构造函数**接收一个可选的代码块
If present, the block is invoked with the newly created order as a parameter.
如果存在，通过调用作为参数的这段代码块，可创建新对象。
This might be useful if you wanted to create and save an order without creating a new local variable.
如果想要创建并保存该对象，则无需创建新的局部变量；这种方法应该是有用的。

    Download rails40/e1/ar/new_examples.rb
    Order.new do |o|
      o.name = "Dave Thomas"
      # . . .
      o.save
    end

• 285

Finally, Active Record constructors accept a hash of attribute values as an optional parameter.
最后，Active Record构造函数接收一个可选的参数，它是hash类的属性值。
Each entry in this hash corresponds to the name and value of an attribute to be set.
每个元素都对应着所要设置的属性名和值。
This is useful for doing things like storing values from HTML forms into database rows.
对把html表单数据存储到数据库的行记录这类的工作，这是很有用的。

    Download rails40/e1/ar/new_examples.rb
    an_order = Order.new(
      name: "Dave Thomas",
      email: "dave@example.com",
      address: "123 Main St",
      pay_type: "check")
    an_order.save

Note that in all of these examples we did not set the id attribute of the new row.
注意，在所有这些例子中，并没有设置新行记录的id属性。
Because we used the Active Record default of an integer column for the primary key, Active Record automatically creates a unique value and sets the id attribute as the row is saved.
因为前面曾经使用Active Record默认整数的字段作为主键，所以Active
Record会自动创建唯一值，且在保存该行记录时设置了id属性。
We can subsequently find this value by querying the attribute.
这样就可以通过查询该属性找到这个值。

    Download rails40/e1/ar/new_examples.rb
    an_order = Order.new
    an_order.name = "Dave Thomas"
    # ...
    an_order.save
    puts "The ID of this order is #{an_order.id}"

The new() constructor creates a new Order object in memory; we have to remember to save it to the database at some point.
**new()构造函数**在内存中创建新的Order对象；一定要记住在某个未来时刻把它保存到数据库中。
Active Record has a convenience method, create(), that both instantiates the model object and stores it into the database.
Active Record有一个**简便的create方法**，在创建实例模型对象的同时，也把它存储到数据库中。

    Download rails40/e1/ar/new_examples.rb
    an_order = Order.create(
      name: "Dave Thomas",
      email: "dave@example.com",
      address: "123 Main St",
      pay_type: "check")

You can pass create() an array of attribute hashes; it’ll create multiple rows in the database and return an array of the corresponding model objects.
可以传递对象属性为hash的数组，它将会在数据库中创建多个行记录，返回相应模型对象的数组。
Download rails40/e1/ar/new_examples.rb

    orders = Order.create(
      [ { name: "Dave Thomas",
          email: "dave@example.com",
          address: "123 Main St",
          pay_type: "check"
        },
        { name: "Andy Hunt",
          email: "andy@example.com",
          address: "456 Gentle Drive",
          pay_type: "po"
        } 
      ] )

• 286

The real reason that new() and create() take a hash of values is that you can construct model objects directly from form parameters.
new和create函数取数组元素为hash类型值的真正原因是，可以直接从表单参数中构造模型对象：

    @order = Order.new(order_params)

If you think this line looks familiar, it is because you have seen it before.
如果觉得这一行看起来眼熟，因为已经在此前看过了。
It appears in orders_controller.rb in the Depot application.
它出现在Depot应用程序orders_controller.rb文件中。

### 19.3.2 Reading Existing Rows 读取已有行记录
Reading from a database involves first specifying which particular rows of data you are interested in—you’ll give Active Record some kind of criteria, and it will return objects containing data from the row(s) matching the criteria.
要想从数据库中读取行记录，首先要详细列举你具体感兴趣的数据——给出Active Record的某些搜索条件，Active Record将会返回包含行记录数据、并且符合条件的对象。

The simplest way of finding a row in a table is by specifying its primary key.
寻找行记录的最简单方法是**列出主键**。
Every model class supports the find() method, which takes one or more primary key values.
每个模型类都提供了**find方法**，它接收一个或几个主键值。

If given just one primary key, it returns an object containing data for the corresponding row (or throws an ActiveRecord::RecordNotFound exception).
如果是给定几个主键值，那么函数find返回相应行记录的一个对象（否则抛出ActiveRecord::RecordNotFound异常）。
If given multiple primary key values, find() returns an array of the corresponding objects.
如果给定几个主键值，那么函数find返回相应对象的数组。
Note that in this case a RecordNotFound exception is raised if any of the IDs cannot be found (so if the method returns without raising an error, the length of the resulting array will be equal to the number of IDs passed as parameters).
注意如果无法找到其中任何一个id，那么会抛出RecordNotFound异常。（所以如果调用方法返回而没有抛出错误，那么数组的长度将等于作为参数传递的id个数）


    an_order = Order.find(27) # find the order with id == 27
                              # 找到id为27的order
    # Get a list of product ids from a form, then
    # find the associated Products
    # 从表单中获得产品id列表，并从Products中找出
    product_list = Product.find(params[:product_ids])

Often, though, you need to read in rows based on criteria other than their primary key value.
不过，通常读取行记录，需要的是搜索条件，若不是通过它们的主键值。
Active Record provides additional methods enabling you to express more complex queries.
Active Record提供了这些复杂查询的大量方法。

### 19.3.3 SQL and Active Record SQL语言和Active Record模块
<kinder:note> 这一章在4版是19.3.4。4版中的19.3.3 动态查询器在本书被删除了。
To illustrate how Active Record works with SQL, let’s pass a simple string to the where() method call corresponding to a SQL where clause.
为了说明如何使用Active Record模块与SQL语言进行交互，下面来比较一下，用简单字符串作为参数调用where方法与调用SQL语言where子句之间的对应关系。
For example, to return a list of all orders for Dave with a payment type of “po,” we could use this:
例如，要返回名字为Dave、支付方式为po的所有订单列表，可以这样做：

    pos = Order.where("name = 'Dave' and pay_type = 'po'")

• 287

------------------------------
------------------------------
David says: To Raise or Not to Raise?  抛出异常还是不抛出？
When you use a finder driven by primary keys, you’re looking for a particular record.
当**使用主键作为参数的查询器**时，你正在寻找特定的记录。
You expect it to exist.
你期望它存在。
A call to Person.find(5) is based on our knowledge of the people table.
调用Person.find(5)是基于对people表的了解。
We want the row with an ID of 5.
想要得到id为5的行记录。
If this call is unsuccessful—if the record with the ID of 5 has been destroyed—we’re in an exceptional situation.
如果调用没有成功，比如行记录已经被删除，则意味着处于异常情况。
This mandates the raising of an exception, so Rails raises RecordNotFound.
结果Rails调用RecordNotFound，抛出RecordNotFound。

On the other hand, finders that use criteria to search are looking for a match.
另外，**使用查询器**的搜索原则是为了寻找到相匹配的内容。
So, Person.where(name: 'Dave').first is the equivalent of telling the database (as a black box) “Give me the first person row that has the name Dave.” 
因此，Person.where(name: 'Dave').first相当于告诉数据库（相当于一个黑盒子）：“给我第一个且名为Dave的Person对象”。
This exhibits a distinctly different approach to retrieval; we’re not certain up front that we’ll get a result.
这表现出一种明显不同的检索方法，事先并不能肯定会得到结果。
It’s entirely possible the result set may be empty.
搜索结果为空也是完全有可能的。
Thus, returning nil in the case of finders that search for one row and an empty array for finders that search for many rows is the natural, nonexceptional response.
因此，当查询器搜索单行记录时，返回nil；而当搜索多行记录时，返回空数组；在这些情况下，没有异常响应是很自然的。

------------------------------
------------------------------

The result will be an ActiveRecord::Relation object containing all the matching rows, each neatly wrapped in an Order object.
结果将是包含所有相匹配行记录的ActiveRecord::Relation对象，每一个行记录包含了一个order对象。

That’s fine if our condition is predefined, but how do we handle it when the name of the customer is set externally (perhaps coming from a web form)?
虽然搜索条件是预定的，但如何处理设置来自外部（也许是从Web表单来的）的消费者名字？
One way is to substitute the value of that variable into the condition string.
一种方式是用**变量值替换条件字符串**。

    # get the name from the form
    name = params[:name]
    # DON'T DO THIS!!!
    pos = Order.where("name = '#{name}' and pay_type = 'po'")

As the comment suggests, this really isn’t a good idea.
就这个建议来说，算不上什么好主意。
Why? 
为什么？
It leaves the database wide open to something called a SQL injection attack, which the Rails Guides that you generated in A Place for Documentation, on page 265, describe in more detail.
因为这样会让数据库完全敞开，使得所谓的SQL语句注入攻击称为可能。前面265页生成的Rails指南中，有更详细的描述。
For now, take it as a given that substituting a string from an external source into a SQL statement is effectively the same as publishing your entire database to the whole online world.
眼下，把来自外部的字符串替代到SQL语句中，实际上就是把整个数据库向网络世界公开。

Instead, the safe way to generate dynamic SQL is to let Active Record handle it.
不同的是，生成动态SQL语句的一种安全方法是，**让Active Record处理它**。
Doing this allows Active Record to create properly escaped SQL, which is immune from SQL injection attacks.
要实现这一点，就要让Active Record生成合适转义的SQL语句，这是预防SQL注入攻击的错误。
Let’s see how this works.
下面来看看这怎么运行。

If we pass multiple parameters to a where() call, Rails treats the first parameter as a template for the SQL to generate.
如果将多个参数传递到where调用，Rails使用第一个参数作为生成SQL语句的模板。
Within this SQL, we can embed placeholders, which will be replaced at runtime by the values in the rest of the array.
在该SQL语句中，可以嵌入占位符，在实时运行时这些占位符将由第二个参数（数组剩余的值）来替代。

• 288

One way of specifying placeholders is to insert one or more question marks in the SQL.
指定占位符的方法之一是在SQL语句中插入单个或几个问号标记。
<kinder:note> 4版中文版译为：“单个或几个单个问号标记”。译注曰：原文“one or more question marks”，一个或者几个问号标记。每一个问号标记必须是单一符号。
The first question mark is replaced by the second element of the array, the next question mark by the third, and so on.
第一个问号标记所取代的是数组的第二个元素，接下来的问号是数组的第三个元素，以此类推。
<kinder:note> 4版中文译注：传递给where函数的第一个参数有三种可能性：字符串、数组和散列。
For example, we could rewrite the previous query as this:
<kinder:note> 比如，我们可以将之前的查询重写成这样：

    name = params[:name]
    pos = Order.where(["name = ? and pay_type = 'po'", name])

We can also use named placeholders.
还可以使用命名占位符。
We do that by placing placeholders of the form :name into the string and by providing corresponding values in a hash, where the keys correspond to the names in the query.
第一个参数是生成SQL语句的模板，把形式为“:name”作为SQL语句的占位符，而第二个参数是Hash类型的对象，键是占位符名，值是与占位符相对应的。
<kinder:note> 这个翻译真是太棒了。

    name = params[:name]
    pay_type = params[:pay_type]
    pos = Order.where("name = :name and pay_type = :pay_type",
                      pay_type: pay_type, name: name)

We can take this a step further.
还可以进一步。
Because params is effectively a hash, we can simply pass it all to the condition.
因为params事实上是hash变量，可以简单地把所有条件传递给它。
If we have a form that can be used to enter search criteria, we can use the hash of values returned from that form directly.
如果有一个可用于输入搜索条件的表单，那么就可以直接使用从表单中返回的这个hash变量。

    pos = Order.where("name = :name and pay_type = :pay_type",
                      params[:order])

We can take this even further.
再深入一点。
If we pass just a hash as the condition, Rails generates a where clause using the hash keys as column names and the hash values as the values to match.
如果给hash变量传递这个条件，那么Rails生成where子句，使用字符名作为hash变量的键，相应的传递值作为hash变量值。
Thus, we could have written the previous code even more succinctly.
因此，可以把前面的代码写得更简洁些：

    pos = Order.where(params[:order])

Be careful with this latter form of condition: it takes all the key-value pairs in the hash you pass in when constructing the condition.
需要小心对待后面所说的表单条件：在Rails内部构造这个条件时，将会使用Hash变量的所有键值对。
An alternative would be to specify which parameters to use explicitly.
另一种方法是明确指定使用该参数：

pos = Order.where(name: params[:name],
                  pay_type: params[:pay_type])

Regardless of which form of placeholder you use, Active Record takes great care to quote and escape the values being substituted into the SQL.
无论使用哪一种形式的占位符，Active Record都会非常谨慎地对待构造SQL语句值的引号和转义。
Use these forms of dynamic SQL, and Active Record will keep you safe from injection attacks.
使用这些动态SQL语句和Active Record，能够防御注入攻击。

### 19.3.4 Using Like Clauses 使用like查询子句
We might be tempted to do something like the code on the next page to use parameterized like clauses in conditions.
下面尝试了解这样的代码，即在查询条件中使用参数化的like字符：

• 289

    # Doesn't work 下面这一句不能运行
    User.where("name like '?%'", params[:name])

Rails doesn’t parse the SQL inside a condition and so doesn’t know that the name is being substituted into a string.
Rails既不解析SQL语句里的条件，也不允许在占位符前后增加除此之外的内容。
As a result, it will go ahead and add extra quotes around the value of the name parameter.
为此，可以在参数name的值前后添加额外的引号内容。
The correct way to do this is to construct the full parameter to the like clause and pass that parameter into the condition.
正确的做法是，构建完整like子句的参数，并将其传递到该搜索条件中。

    # Works 下面这一句可以运行
    User.where("name like ?", params[:name]+"%")

Of course, if we do this, we need to consider that characters such as percent signs, should they happen to appear in the value of the name parameter, will be treated as wildcards.
当然，如果要做到这一点，需要考虑到一些特殊字符，如百分号（%）；如果这些符号出现在参数name的值中，那么就应该使用通配符（#{}）
<kinder:note>译注：如代码"#{params[:name]}%"

### 19.3.5 Subsetting the Records Returned 构造返回记录的子句
Now that we know how to specify conditions, let’s turn our attention to the various methods supported by ActiveRecord::Relation, starting with first() and all().
现在已经知道如何指定查询条件，下面把注意力集中到ActiveRecord::Relation支持的各种方法；我们从first()和all()开始。
As you may have guessed, first() returns the first row in the relation.
你可能已经猜到，first返回关系集的第一行记录。
It returns nil if the relation is empty.
如果关系集为空，返回nil。

Similarly, to_a() returns all the rows as an array.
同样，to_a()以一个数组返回所有行。
ActiveRecord::Relation also supports many of the methods of Array objects, such as each() and map().
ActiveRecord::Relation也支持许多Array类的对象的方法，如each()和map()。
It does so by implicitly calling the all() first.
它们都先隐式地调用了all方法。

It’s important to understand that the query is not evaluated until one of these methods is used.
知道在使用任何一个这些方法之前，查询没有赋值是重要的。
This enables us to modify the query in a number of ways, namely, by calling additional methods, prior to making this call.
这允许我们以几种方法修改查询，比如，通过在调用这个方法之前调用另外的方法。
Let’s look at these methods now.
下面看看这些方法。

#### order  排序
SQL doesn’t require rows to be returned in any particular order unless we explicitly add an order by clause to the query.
SQL语句不会让返回的行记录按照某种方法排序，除非明确地把order by子句添加到查询中。
The order() method lets us specify the criteria we’d normally add after the order by keywords.
order方法允许指定查询条件，参数由一些关键词组成。
For example, the following query would return all of Dave’s orders, sorted first by payment type and then by shipping date (the latter in descending order).
比如，下面查询将返回所有“Dave”的订单，首先按照付款类型升序排列，然后由发货日期降序排序。

    orders = Order.where(name: 'Dave').order("pay_type, shipped_at DESC")

#### limit  有限个数
We can limit the number of rows returned by calling the limit() method.
通过调用limit方法，可以限定返回行记录的个数。
Generally when we use the limit method, we’ll probably also want to specify the sort order to ensure consistent results.
通常使用limit方法时，很可能还需要指定排列顺序，以确保得到一致结果。
For example, the following returns the first ten matching orders:
例如，下面返回前十个相匹配的订单

• 290

    orders = Order.where(name: 'Dave').
                   order("pay_type, shipped_at DESC").
                   limit(10)

#### offset  偏移
The offset() method goes hand in hand with the limit() method.
offset方法进一步补充了limit方法。
It allows us to specify the offset of the first row in the result set that will be returned.
它允许返回在结果集中我们指定的第一行的偏移量。

    # The view wants to display orders grouped into pages,
    # where each page shows page_size orders at a time.
    # This method returns the orders on page page_num (starting
    # at zero).
    def Order.find_on_page(page_num, page_size)
      order(:id).limit(page_size).offset(page_num*page_size)
    end


We can use offset in conjunction with limit to step through the results of a query n rows at a time.
可以把函数offset与函数limit一起使用，每一次查询得到下n行记录结果。

#### select  选择字段
By default, ActiveRecord::Relation fetches all the columns from the underlying database table—it issues a select * from...  to the database.
默认情况下，ActiveRecord::Relation从底层数据库表中获取所有字段名——它发出一个`select * from`语句到数据库中。
Override this with the select() method, which takes a string that will appear in place of the * in the select statement.
使用select方法重写这个select语句，该方法需要在SELECT语句的`*`位置上出现一个字符串。

This method allows us to limit the values returned in cases where we need only a subset of the data in a table.
这种方法能够限制返回值，例如只需要表中的子集数据。
For example, our table of podcasts might contain information on the title, speaker, and date and might also contain a large BLOB containing the MP3 of the talk.
如在podcasts表可能包含标题、主播人、日期等，且也可能包含较大的mp3的BLOB类型字段。
If you just wanted to create a list of talks, it would be inefficient to also load the sound data for each row.
如果只是想开始建立节目列表，那么把每行声音数据也加载上来，这将是低效的方法。
The select() method lets us choose which columns to load.
select()方法可以有机会选择加载哪些字段。

    list = Talk.select("title, speaker, recorded_on")

#### joins  合并
The joins() method lets us specify a list of additional tables to be joined to the default table.
joins()方法允许指定一组相关联表加入到默认表。
This parameter is inserted into the SQL immediately after the name of the model’s table and before any conditions specified by the first parameter.
把它的参数直接插入到SQL语句中，位置在模型表名之后、第一个参数指定的其他条件之前。
The join syntax is database-specific.
join语法因数据库而异。
The following code returns a list of all line items for the book called Programming Ruby:
下面的代码返回所有书名为“Programming Ruby”的商品项目清单：

    LineItem.select('li.quantity').
            where("pr.title = 'Programming Ruby 1.9'").
            joins("as li inner join products as pr on li.product_id = pr.id")
            # <kinder:note> 这第三行真难懂！as inner on都是关键词吧？参见后面的19.3.8 《编写自己的SQL语句》一节

<kinder:note> ruby on rails的文档：
 joins(*args)

Performs a joins on args:

    User.joins(:posts)
    => SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id"

You can use strings in order to customize your joins:

    User.joins("LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id")
    => SELECT "users".* FROM "users" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id

</kinder:note> 

• 291

#### readonly   只读
The readonly() method causes ActiveRecord::Resource to return Active Record objects that cannot be stored back into the database.
readonly()方法的作用是，不能把ActiveRecord::Resource返回的Active Record对象存储到数据库中。
If we use the joins() or select() method, objects will automatically be marked readonly.
如果使用joins或select方法，那么将对象自动标记为readonly。

<kinder:note> 同样下面是ror文档：
 readonly(value = true)

Sets readonly attributes for the returned relation. If value is true (default), attempting to update a record will result in an error.

    users = User.readonly
    users.first.save
    => ActiveRecord::ReadOnlyRecord: ActiveRecord::ReadOnlyRecord

</kinder:note> 

#### group  分组
The group() method adds a group by clause to the SQL.
group()方法把group子句添加到由查询器所生成的SQL语句中。

    summary = LineItem.select("sku, sum(amount) as amount").
                       group("sku")

#### lock   锁定
The lock() method takes an optional string as a parameter.
lock()方法接受一个可选的字符串作为参数。
If we pass it a string, it should be a SQL fragment in our database’s syntax that specifies a kind of lock.
如果把字符串传递给它，那么它应该是数据库语法的SQL代码段，且同时指定了一个锁。
With MySQL, for example, a share mode lock gives us the latest data in a row and guarantees that no one else can alter that row while we hold the lock.
比如使用MySQL，共享模式锁提供了行记录的最新数据，并且当持有该锁时，保证没人可以改变改行。
We could write code that debits an account only if there are sufficient funds using something like the following:
例如，只有在账户上有足够的资金时，才可扣除账户款。代码如下：

    Account.transaction do
      ac = Account.where(id: id).lock("LOCK IN SHARE MODE").first
      ac.balance -= amount if ac.balance > amount
      ac.save
    end

If we don’t specify a string value or we give lock() a value of true, the database’s default exclusive lock is obtained (normally this will be "for update").
如果没有指定字符串值或者给定锁true值，则获得数据库的默认独占锁（通常这将是更新）。
We can often eliminate the need for this kind of locking using transactions (discussed starting in Section 19.5, Transactions, on page 304).
经常可以使用事务来消除这种锁定的需要（将从后面304页19.5节《事务》开始讨论）。

Databases can do more than simply find and reliably retrieve data; they can also do a bit of data reduction analysis.
除了简单的查询和可靠地检索数据，数据库还可以做更多事情，比如数据的回归分析。
Rails provides access to these methods too.
Rails也提供了这些访问的方法。

### 19.3.6 Getting Column Statistics 获取字段统计
Rails has the ability to perform statistics on the values in a column.
Rails有能力完成字段值的统计工作。
For example, given a table of orders, we can calculate the following:3
例如，对于给定的orders表，可以计算出一下内容：

    average = Order.average(:amount) 
    # average amount of orders        
    # orders表中amount字段的平均值
    max     = Order.maximum(:amount)
    min     = Order.minimum(:amount)
    total   = Order.sum(:amount)
    number  = Order.count

• 292

These all correspond to aggregate functions in the underlying database, but they work in a database-independent manner.
所有这些方法对应着底层数据库的聚合函数，但它们以一种独立于数据库的方式运行。
As before, methods can be combined.
和之前一行，这些方法可以连用。

    Order.where("amount > 20").minimum(:amount)

These functions aggregate values.
这些函数都是合计值。
By default, they return a single result, producing, for example, the minimum order amount for orders meeting some condition.
默认情况下，它们返回一个结果，例如，为满足某些订单条件产生的最小订单金额。
However, if you include the group method, the functions instead produce a series of results, one result for each set of records where the grouping expression has the same value.
不过，如果包含group方法，则会产生一组结果；其结果存在每一分组记录，而每一分组表达式具有相似的值。
<kinder:note> 后面半句是否可以翻译为：每个结果登记每一分组表达式的记录，它们的值比较相似。
For example, the following calculates the maximum sale amount for each state:
比如，下面计算每个州的最大销售金额：

    result = Order.group(:state).maximum(:amount)
    puts result #=> {"TX"=>12345, "NC"=>3456, ...}

This code returns an ordered hash.
这段代码返回一个有序hash。
<kinder:note> 4版译注：具有散列类型的特点，但它们的数据类型是Array。
You index it using the grouping element ("TX", "NC", … in our example).
使用分组元素（在本例中是"TX", "NC"等）作为索引。
You can also iterate over the entries in order using each().
还可以使用each函数，按顺序遍历每一个分组。
The value of each entry is the value of the aggregation function.
每个分组包含聚合函数值。

The order and limit methods come into their own when using groups.
使用group方法时，也可以引入order和limit方法一起使用。
 For example, the following returns the three states with the highest orders, sorted by the order amount:
例如，下面返回三个州各自最高金额的订单，并且按照订单金额大小进行排序。

    result = Order.group(:state).
                   order("max(amount) desc").
                   limit(3)

This code is no longer database independent—in order to sort on the aggregated column, we had to use the SQLite syntax for the aggregation function (max, in this case).
这段代码随数据库而异的。——由于排序需要聚合的字段名，因此不得不使用SQLite语法的聚合函数（本例中是max）。

### 19.3.7 Scopes 范围函数
As these chains of method calls grow longer, making the chains themselves available for reuse becomes a concern.
由于这些方法调用链变得很长，所以使得链本身的重用性称为关注的问题。
Once again, Rails delivers.
Rails又一次提供了解决这种问题的可能性。
An Active Record scope can be associated with a Proc and therefore may have arguments:
可以把Proc类与Active Record模块的scope函数结合使用。

lambda ↪ on page 51

    class Order < ActiveRecord::Base
      scope :last_n_days, lambda { |days| where('updated < ?' , days) }
    end


Such a named scope would make finding the worth of last week’s orders a snap.
命名这样的范围函数可以十分轻松地找到上周的订单值。

    orders = Order.last_n_days(7)

Simpler scopes may have no parameters at all.
更简单的范围函数可以方便地调用一组方法。

• 293

    class Order < ActiveRecord::Base
      scope :checks, -> { where(pay_type: :check) }
    end

Scopes can also be combined.
范围也可以连用。
Finding the last week’s worth of orders that were paid by check is just as easy.
找到上周且支付类型为check的订单值，也很容易。

    orders = Order.checks.last_n_days(7)

In addition to making your application code easier to write and easier to read, scopes can make your code more efficient.
除此之外，范围也使得应用程序代码更易于编写和阅读，更高效。
The previous statement, for example, is implemented as a single SQL query.
例如，前面的语句，是作为单一的SQL查询语句执行。

ActiveRecord::Relation objects are equivalent to an anonymous scope.
ActiveRecord::Relation对象就相当于一个匿名的范围。

    in_house = Order.where('email LIKE "%@pragprog.com"')

Of course, relations can also be combined.
当然，这些relations对象也可以连用。

    in_house.checks.last_n_days(7)

Scopes aren’t limited to where conditions; we can do pretty much anything we can do in a method call: limit, order, join, and so on.
范围没有限制where条件；通过调用limit、order和join函数等，几乎可以做任何事情。。
Just be aware that Rails doesn’t know how to handle multiple order or limit clauses, so be sure to use these only once per call chain.
必须指出，Rails无法处理多个order或者limit子句，因此必须确保每次调用链只用它们一次。

In nearly every case, the methods we have been describing are sufficient.
在大部分查询中，这些方法已经够用。
But Rails is not satisfied with only being able to handle nearly every case, so for cases that require a human-crafted query, there is an API for that too.
但是Rails并不能完全满足处理所有查询；这样的情况下需要自己写查询语句，Rails也有这样的API。

### 19.3.8 Writing Our Own SQL 编写自己的SQL
Each of the methods we have been looking at contributes to the construction of a full SQL query string.
前面介绍的每一种方法都有助于构建完整的SQL查询字符串。
The method find_by_sql() lets our application take full control.
方法find_by_sql()完全能够控制应用程序。
It accepts a single parameter containing a SQL select statement (or an array containing SQL and placeholder values, as for find()) and returns an array of model objects (that is potentially empty) from the result set.
它接收包含SQL语言select语句（或一个包含SQL语句及其占位符值的数组，像find那样）的单个参数，并返回来自结果集合中模型对象的数组（可能为空）。
The attributes in these models will be set from the columns returned by the query.
查询返回的字段被设置为这些模型的属性。

We’d normally use the select * form to return all columns for a table, but this isn’t required.
通常可以使用“select * ”形式的语句返回表的所有列，但这不是必须的。

    Download rails40/e1/ar/find_examples.rb
    orders = LineItem.find_by_sql("select line_items.* from line_items, orders " +
                                  " where order_id = orders.id" +
                                  " and orders.name = 'Dave Thomas' "
                                 )

Only those attributes returned by a query will be available in the resulting model objects.
仅由查询所返回的那些属性会被应用于结果模型对象。
We can determine the attributes available in a model object using the attributes(), attribute_names(), and attribute_present?() methods.
使用函数attributes、attribute_names和attribute_present?，可以判断模型对象的这些属性是否有效。

• 294

The first returns a hash of attribute name-value pairs, the second returns an array of names, and the third returns true if a named attribute is available in this model object.
下面的代码三个p输出中，第一行返回属性的名/值对的hash对象；第二行返回属性的名称组成的数组；第三行返回name属性在这个模型对象中是否有效。

    Download rails40/e1/ar/find_examples.rb
    orders = Order.find_by_sql("select name, pay_type from orders")
    first = orders[0]
    p first.attributes
    p first.attribute_names
    p first.attribute_present?("address")

This code produces the following:
这段代码产生如下结果：

    {"name"=>"Dave Thomas", "pay_type"=>"check"}
    ["name", "pay_type"]
    false

find_by_sql() can also be used to create model objects containing derived column data.
find_by_sql()也可以用于创建包含派生字段数据的模型对象。
If we use the as xxx SQL syntax to give derived columns a name in the result set, this name will be used as the name of the attribute.
吴国使用“as xxx”的SQL语法来作为派生字段结果集合的名称，那么将把这个名称用作属性名。

    Download rails40/e1/ar/find_examples.rb
    items = LineItem.find_by_sql(
      "select *,                                   " +
      " products.price as unit_price,              " +
      " quantity*products.price as total_price,    " +
      " products.title as title                    " +
      " from line_items, products                  " +
      " where line_items.product_id = products.id  "
    )
    li = items[0]
    puts "#{li.title}: #{li.quantity}x#{li.unit_price} => #{li.total_price}"
    # <kinder:note> 这一句puts真有意思，产生的结果类似下面这样的吗？ 
    # Programming ruby: 1x39.9 => 39.9

As with conditions, we can also pass an array to find_by_sql(), where the first element is a string containing placeholders.
至于查询条件，也可以把它作为数组传递到函数find_by_sql，其中第一个元素是包含占位符的字符串。
The rest of the array can be either a hash or a list of values to be substituted.
其余部分可以是一个散列或一组要替换的值。

    Order.find_by_sql(["select * from orders where amount > ?", params[:amount]])

In the old days of Rails, people frequently resorted to using find_by_sql().
在Rails的早期版本中，经常使用find_by_sql()进行重新排序。
<kinder:note>后半句这样翻译是否更妥当？
人们经常使用了find_by_sql而需要重新排序。
</kinder:note> 
Since then, all the options added to the basic find() method mean you can avoid resorting to this low-level method.
从那时起，所有添加到find方法的选项，将意味着能够避免重新排序这种低级方法。

### 19.3.9 Reloading Data 重新加载数据
In an application where the database is potentially being accessed by multiple processes (or by multiple applications), there’s always the possibility that a fetched model object has become stale—someone may have written a more recent copy to the database.
多个进程（或多个应用程序）可能同时访问包含数据库的应用程序，这样得到的模型对象不再是最新的，这种可能性总是存在的——因为有人可能已经把更新的数据写入数据库中。

• 295

------------------------------
------------------------------
David says: But Isn’t SQL Dirty? SQL语句并不是很肮脏（麻烦）的吗？
Ever since developers first wrapped relational databases with an object-oriented layer, they’ve debated the question of how deep to run the abstraction.
自从开发者第一次用面向对象层封装关系数据库起，人们就已经开始辩论持久层抽象要达到怎样程度的封装问题。
Some object-relational mappers seek to eliminate the use of SQL entirely, hoping for object-oriented purity by forcing all queries through an OO layer.
有些对象关系映射器的查询可以完全不使用SQL语言，这迫使所有的查询通过面向对象层完成，寄希望于面向对象的纯洁性。

Active Record does not.
Active Record模块没有这样做。
It was built on the notion that SQL is neither dirty nor bad, just verbose in the trivial cases.
当时它是以这一概念建立起来的，即SQL语言既不肮脏也不是存在缺陷，只是在很简单的查询情况下太累赘。
The focus is on removing the need to deal with the verbosity in those trivial cases (writing a ten-attribute insert by hand will leave any programmer tired) but keeping the expressiveness around for the hard queries—the type SQL was created to deal with elegantly.
它的重点不再需要处理那些查询的累赘（对于任何程序员来说，通过手工编写含十个属性的insert演示，是令人厌烦的），但同时继续保持硬查询的可表达性——充分利用曾经创建的传统SQL语句。
<kinder:note> 4版译注：「硬查询」就是使用传统SQL语言查询。

Therefore, you shouldn’t feel guilty when you use find_by_sql() to handle either performance bottlenecks or hard queries.
因此，当使用find_by_sql处理性能瓶颈或硬查询时，你不应该感到内疚。
Start out using the object-oriented interface for productivity and pleasure and then dip beneath the surface for a close-to-the-metal experience when you need to do so.
使用面向对象接口的出发点，是为了提高生产力、让人身心愉悦，并且随着问题更加深入和复杂，你就需要这样做。

------------------------------
------------------------------

To some extent, this issue is addressed by transactional support (which we describe in Section 19.5, Transactions, on page 304).
从某种程度上说，事务支持（后面304页19.5章会描述）解决了这类问题。
However, there’ll still be times where you need to refresh a model object manually.
不过，需要手动刷新模型对象，这种事情还是会时而发生。
Active Record makes this easy—simply call its reload() method, and the object’s attributes will be refreshed from the database.
Active Record使之变得简单，简单地调用其重载方法，且将从数据库中刷新对象属性：

    stock = Market.find_by(ticker: "RUBY")
    loop do
      puts "Price = #{stock.price}"
      sleep 60
      stock.reload
    end

In practice, reload() is rarely used outside the context of unit tests.
在实践中，除了单元测试外很少使用重载。

### 19.3.10 Updating Existing Rows 更新现有行记录
After such a long discussion of finder methods, you’ll be pleased to know that there’s not much to say about updating records with Active Record.
经过这么长时间的讨论查询器方法之后，你会高兴地了解到，使用Active Record更新记录行的内容并不是太多了。

If you have an Active Record object (perhaps representing a row from our orders table), you can write it to the database by calling its save() method.
如果存在Active Record对象（比如orders表的行记录），那么**调用save方法**，就可以将它写入数据库中。
If this object had previously been read from the database, this save will update the existing row; otherwise, the save will insert a new row.
如果先前从数据库中读取该对象，那么此事保存对象将更新现有的行记录，否则，这种保存将是插入新的记录行。

If an existing row is updated, Active Record will use its primary key column to match it with the in-memory object.
如果更新现有记录行，那么Active Record模块将利用其与内存对象相匹配的主键字段。
The attributes contained in the Active Record object determine the columns that will be updated—a column will be updated in the database only if its value has been changed.
Active Record模块对象里的属性决定将这些将要更新的字段——只有改变了字段值，才能在数据库中更新该字段。

• 296 

In the following example, all the values in the row for order 123 can be updated in the database table:
下面的例子中，对于id为123的订单，在数据库表中可以更新改行记录的所有属性值：

    order = Order.find(123)
    order.name = "Fred"
    order.save

However, in the following example, the Active Record object contains just the attributes id, name, and paytype—only these columns can be updated when the object is saved.
不过，在下面的例子中，Active Record模块对象仅仅包含了这些属性id、name和pay_type——仅当保存该对象时，才可以更新这些字段。
(Note that you have to include the id column if you intend to save a row fetched using find_by_sql().)
（注意，如果打算保存由方法find_by_sql获取的行记录，那么必须包括id字段。）
<kinder:note> 是否这么理解：
下面第一行如果写成
    orders = Order.find_by_sql("select name, pay_type from orders where id=123") 
则无法更新行记录
</kinder:note> 

    orders = Order.find_by_sql("select id, name, pay_type from orders where id=123") 
    first = orders[0] 
    first.name = "Wilma" 
    first.save 

In addition to the save() method, Active Record lets us change the values of attributes and save a model object in a single call to update().
除了save方法之外，利用Active Record模块，也可以改变属性值，且**以单一调用函数 update()方式保存模型对象**。
<kinder:note> 4版是update_attribute()方法

    order = Order.find(321)
    order.update(name: "Barney", email: "barney@bedrock.com")

The update() method is most commonly used in controller actions where it merges data from a form into an existing database row.
update()方法是控制器行为中最常用的方法，它把表单数据合并到现有数据库行记录中。

    def save_after_edit
      order = Order.find(params[:id])
      if order.update(order_params)
        redirect_to action: :index
      else
        render action: :edit
      end
    end

We can combine the functions of reading a row and updating it using the class methods update() and update_all().
使用**类方法update()和`update_all()`**，可以把读取行记录和更新它的函数合并起来。
The update() method takes an id parameter and a set of attributes.
这种更新方法需要id参数和一组属性。
It fetches the corresponding row, updates the given attributes, saves the result to the database, and returns the model object.
它先获取相应的行记录，然后更新给定的属性，再把结果保存到数据库中，最后返回该模型对象。

    order = Order.update(12, name: "Barney", email: "barney@bedrock.com")

We can pass update() an array of IDs and an array of attribute value hashes, and it will update all the corresponding rows in the database, returning an array of model objects.
首先可以给update()传递id和属性值散列值的数组，然后更新数据库中所有相应的行记录，最后返回一个模型对象数组。

• 297

Finally, the update_all() class method allows us to specify the set and where clauses of the SQL update statement.
最后，利用类方法update_all()，可以指定在SQL语言update语句中的set和where子句。
For example, the following increases the prices of all products with Java in their title by 10 percent:
比如，下面的代码把所有标题含有Jave的商品的价格提高10%：

    result = Product.update_all("price = 1.1*price", "title like '%Java%'")

The return value of update_all() depends on the database adapter; most (but not Oracle) return the number of rows that were changed in the database.
方法update_all()的返回值取决于数据库适配器，大多数数据库系统（不包括Oracle）返回在数据库中已更改的行记录数。

### 19.3.11 save, save!, create, and create!
It turns out that there are two versions of the save and create methods.
现在把注意力转移到save和create方法的两种版本上。
The variants differ in the way they report errors.
它们报告错误的方式是不同的。

• save returns true if the record was saved; it returns nil otherwise.
  save方法成功保存行记录则返回true；否则返回nil。
• save! returns true if the save succeeded; it raises an exception otherwise.
  save!成功保存行记录则返回true，否则返回异常。
• create returns the Active Record object regardless of whether it was successfully saved. 
  不管create是否成功创建Active Record模块对象，都返回该对象。
You’ll need to check the object for validation errors if you want to determine whether the data was written.
如果想要确定是否写入数据，需要检查对象的错误。
• create! returns the Active Record object on success; it raises an exception otherwise.
  如果create!成功创建了ActiveRecord对象，返回该对象；否则返回异常。

Let’s look at this in a bit more detail.
下面更详细地看看它们。
Plain old save() returns true if the model object is valid and can be saved.
如果模型对象是有效、且可保存的，则方法返回true。

    if order.save
      # all OK
    else
      # validation failed
    end

It’s up to us to check on each call to save() to see that it did what we expected.
不仅要检查每次调用方法save的结果，还要查看期望的结果是否如我们所愿。
The reason Active Record is so lenient is that it assumes save() is called in the context of a controller’s action method and that the view code will be presenting any errors back to the end user.
之所以 **Active Record 模块不那么苛刻**，是因为在控制器的相关行文方法中调用方法save，并且在视图代码中将任何错误反馈给最终用户。
And for many applications, that’s the case.
对于许多应用来说，都应该这样做。

However, if we need to save a model object in a context where we want to make sure to handle all errors programmatically, we should use save!().
不过，在**需要保存模型对象，要求以编程方式确定处理所有错误的情况下**，就应该使用方法save!()。
This method raises a RecordInvalid exception if the object could not be saved.
如果这个方法无法保存该对象，那么该方法会出现异常类RecordInvalid。

    begin
      order.save!
    rescue RecordInvalid => error
      # validation failed
    end

• 298

### 19.3.12 Deleting Rows 删除行记录
Active Record supports two styles of row deletion.
Active Record模块支持两种风格的行删除。

First, it has two class-level methods, delete() and delete_all(), that operate at the database level.
第一种形式是两个类层面的方法delete()和delete_all()，其**操作层面是在数据库上的**。
The delete() method takes a single ID or an array of IDs and deletes the corresponding row(s) in the underlying table.
delete()方法接收单个id或多个id的数组，且删除底层数据表中相应的记录。
delete_all() deletes rows matching a given condition (or all rows if no condition is specified).
delete_all()删除给定条件的行记录（如果没有给定条件则删除所有行）。
The return values from both calls depend on the adapter but are typically the number of rows affected.
调用两个函数的额返回值取决于数据库适配器，通常是所涉及的行记录的数量。
An exception is not thrown if the row doesn’t exist prior to the call.
如果调用之前该行不存在，不会抛出异常。

    Order.delete(123)
    User.delete([2,3,4,5])
    Product.delete_all(["price > ?", @expensive_price])

The various destroy methods are the second form of row deletion provided by Active Record.
方法destroy是Active Record提供的的删除行记录的第二种形式。
These methods all work via Active Record model objects.
所有这些方法是**Active Record模型对象层面的操作**。

The destroy() instance method deletes from the database the row corresponding to a particular model object.
destroy()实例方法删除数据库中对应特定模型对象的行记录。
It then freezes the contents of that object, preventing future changes to the attributes.
然后冻结该对象的内容，防止以后改变其属性。

    order = Order.find_by(name: "Dave")
    order.destroy
    # ... order is now frozen

There are two class-level destruction methods, destroy() (which takes an ID or an array of IDs) and destroy_all() (which takes a condition).
有两个类层面的销毁方法：destroy方法（需要id或多个id的数组）和destroy_all（带一个条件）
Both methods read the corresponding rows in the database table into model objects and call the instance-level destroy() method of those objects.
两者都把数据表中相应的行记录读取到模型对象，并调用这些对象的实例级destroy()方法。
Neither method returns anything meaningful.
两者都不会返回任何有意义的东西。

    Order.destroy_all(["shipped_at < ?", 30.days.ago])

Why do we need both the delete and destroy class methods? 
为什么既需要delete有需要destroy类方法呢？
The delete methods bypass the various Active Record callback and validation functions, while the destroy methods ensure that they are all invoked.
**delete方法绕过了Active Record模块的各种回调和验证函数，destroy方法确保调用它们的一切过程**。
In general, it is better to use the destroy methods if you want to ensure that your database is consistent according to the business rules defined in your model classes.
一般如果要确保数据的一致性，并根据模型类中所定义的商业规则，最好使用destroy方法。

We covered validation in Chapter 7, Task B: Validation and Unit Testing, on page 77.
前面77页第7章《验证和单元测试》已经阐述过了验证。
We cover callbacks next.
下面探讨回调。

## 19.4 Participating in the Monitoring Process 干预跟踪过程
### 回调
Active Record controls the life cycle of model objects—it creates them, monitors them as they are modified, saves and updates them, and watches sadly as they are destroyed.
Active
Record模块控制了模型对象的生命周期——它创建它们、在修改时跟踪、储存和更新它们、删除时观察它们。
Using callbacks, Active Record lets our code participate  in the Monitoring Process in this monitoring process.
使用回调，Active Record允许用户代码加入干预这一跟踪进程中。

 • 299

We can write code that gets invoked at any significant event in the life of an object.
在对象的生命周期中，哦我们可以编写获取调用任何有效事件的代码。
With these callbacks we can perform complex validation, map column values as they pass in and out of the database, and even prevent certain operations from completing.
有了这些代码，可以完成复杂有效性验证；在字段值往返于数据库时映射它们；甚至可以阻止完成某些操作。

Active Record defines sixteen callbacks.
Active Record定义了十六种回调。
Fourteen of these form before/after pairs and bracket some operation on an Active Record object.
其中14种方法是以before或after为前缀形式，且把Active Record对象的一些操作视为同一类。
For example, the before_destroy callback will be invoked just before the destroy() method is called, and after_destroy will be invoked after.
比如，在调用destroy方法之前，将调用before_destroy回调方法，而之后将调用after_destroy方法。
The two exceptions are after_find and after_initialize, which have no corresponding before_xxx callback.
另外两个方法是after_initialize和after_initialize，它们没有相应的before_xxx回调方法。
(These two callbacks are different in other ways, too, as we’ll see later.)
（我们将在后面探讨这两种方法和其他方法的不同之处）
In the following figure we can see how Rails wraps the sixteen paired callbacks around the basic create, update, and destroy operations on model objects.
下图可以看到，Rails围绕针对模型对象的创建、更新和销毁等基本操作，打造出这16中回调方法。
Perhaps surprisingly, the before and after validation calls are not strictly nested.
可能令人惊讶的是，并没有严格地嵌套之前和之后的有效性验证调用。

     +------ model.save() ----+                     model.destroy()
     |new record              |existing record        |
     |新的记录                |已有记录               |
     |before_validation       |before_validation      |
     |validation operations   |validation operations  |
     |验证操作                |验证操作               |
     |after_validation        |after_validation       |
     |before_save             |before_save            |
     |before_create           |before_update          |before_destroy
     |insert operation        |update operation       | delete operation
     |插入操作                |更新操作               | 删除操作
     |after_create            |after_update           | after_destroy
     |after_save              |after_save             |
    \|/                      \|/                     \|/

Figure 57—Sequence of Active Record callbacks
表格57—— Active Record回调顺序
The before_validation and after_validation calls also accept the on: :create or on: :update parameter, which will cause the callback to be called only on the selected operation.
<kinder:note> before_validation和after_validation也接收on: :create或者on:
:update参数，只有在进行selected操作时才会回调。
In addition to these sixteen calls, the after_find callback is invoked after any find operation, and after_initialize is invoked after an Active Record model object is created.
除了这16个调用函数之外，在任何find操作之后，可调用after_find回调函数；在创建Active Record模型对象之后，可调用after_initialize回调函数。

• 300

To have your code execute during a callback, you need to write a handler and associate it with the appropriate callback.
为了在回调期间执行用户代码，需要写一个句柄，并与相应的回调函数关联在一起。
There are two basic ways of implementing callbacks.
实施回调有两种方式。
The preferred way to define a callback is to declare handlers.
<kinder:note> 定义回调的常用方法是声明句柄。
A handler can be either a method or a block.
句柄可以是方法或代码块。
You associate a handler with a particular event using class methods named after the event.
使用事件后命名的类方法，可把句柄与特定事件相关联。
To associate a method, declare it as private or protected, and specify its name as a symbol to the handler declaration.
要关联方法，声明其为private或protected，并把其作为符号的名字指定为句柄声明。
To specify a block, simply add it after the declaration.
要指定代码块，只需将其添加到声明之后。
This block receives the model object as a parameter.
这个代码块接收默默对象作为参数。

    class Order < ActiveRecord::Base
      before_validation :normalize_credit_card_number
      after_create do |order|
        logger.info "Order #{order.id} created"
      end
      protected
      def normalize_credit_card_number
        self.cc_number.gsub!(/[-\s]/, '')
      end
    end

You can specify multiple handlers for the same callback.
可以指定同一回调的多个句柄。
They will generally be invoked in the order they are specified unless a handler returns false (and it must be the actual value false), in which case the callback chain is broken early.
通常按照指定顺序调用它们，除非句柄返回false（且它必须是实际值false），在这种情况下，提前中断回调链。

Alternately, you can define the callback instance methods using callback objects, inline methods (using a proc), or inline eval methods (using a string).
还有一种可选的方法，可使用回调对象定义回调实例方法。包括行内方法（使用proc）或非行内方法（使用字符串）。
See the online documentation for more details.[2]
更多细节参见在线文档。
[2].  http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html#labelTypes+of+callbacks

<kinder:note> 下面是4版出现、本版被删的一段，这一段在本版下文有所提及。
鉴于性能优化，定义after_find和after_initialize事件回调函数的唯一途径就是，将其定义为方法。
如果尝试使用第二种方法（<kinder:note> 本版的第一种“声明句柄”）把其声明为句柄，那么将无需对其进行说明。
（
有时有人会问为什么这样做。
Rails必须使用反射来确定是否存在要调用的回调函数。
在操作实际数据库时，与数据库的开销相比，这样做的成本通常并不是很显著。
不过，单一数据库的select语句返回几百行记录，并且两个回调函数都必须互相协调对方。
这使得查询速度明显下降。
Rails团队决定，在这种情况下，性能重于一致性。
）
</kinder:note> 

### 19.4.1 Grouping Related Callbacks Together 成组的相关回调
If you have a group of related callbacks, it may be convenient to group them into a separate handler class.
如果有一组相关回调，可方便得使之组合成单独的句柄类。
These handlers can be shared between multiple models.
这些句柄可在多个模型之间共享。
A handler class is simply a class that defines callback methods (before_save(), after_create(), and so on).
句柄类是定义回调方法（before_save()，after_create()等等）的简单类。
Create the source files for these handler classes in app/models.
在app/models目录下可创建这些句柄类的源代码。

In the model object that uses the handler, you create an instance of this handler class and pass that instance to the various callback declarations.
在使用句柄的模型对象中，可以创建此句柄类的实例，并把该实例传递到各种回调声明。
A couple of examples will make this clearer.
下面几个例子能说得更清楚。

• 301

If our application uses credit cards in multiple places, we might want to share our normalize_credit_card_number() method across multiple models.
如果在应用程序中多处信用卡，可能要在多个模型中共享normalize_credit_card_number方法。
To do that, we’d extract the method into its own class and name it after the event we want it to handle.
要做到这一点，将该方法移到自己的类中，且在需要它去处理的事件之后给出其名称。
This method will receive a single parameter, the model object that generated the callback.
这个方法将接收一个参数，生成回调的模型对象。

    class CreditCardCallbacks
      # Normalize the credit card number
      def before_validation(model)
        model.cc_number.gsub!(/[-\s]/, '')
      end
    end
    <kinder:note> 放在app/models/credit_card_callbacks.rb吗？

Now, in our model classes, we can arrange for this shared callback to be invoked.
现在，在模型类中可以为调用这种共享回调做准备。

    class Order < ActiveRecord::Base
      before_validation CreditCardCallbacks.new
      # ...
    end

    class Subscription < ActiveRecord::Base
      before_validation CreditCardCallbacks.new
      # ...
    end
    <kinder:note> 放在app/models/substription.rb吗？

In this example, the handler class assumes that the credit card number is held in a model attribute named cc_number; both Order and Subscription would have an attribute with that name.
在这个例子中，句柄类假设信用卡号码放在模型属性名为cc_number下；Order类和Subscription类将都有该名称的属性。
But we can generalize the idea, making the handler class less dependent on the implementation details of the classes that use it.
但可以推广一下这个想法，句柄类很少依赖使用着它的类的实现细节。

For example, we could create a generalized encryption and decryption handler.
比如，可以创建通用的加密和解密句柄。
 This could be used to encrypt named fields before they are stored in the database and to decrypt them when the row is read back.
其用途可以是，在把已命名的字段存储到数据库之前，对它进行加密，而当读取行记录时，对其进行解密。
You could include it as a callback handler in any model that needed the facility.
在任何需要这种功能的模型中，可以将其作为回调句柄引用。

The handler needs to encrypt a given set of attributes in a model just before that model’s data is written to the database.
在模型数据写入数据库之前，句柄需要加密该模型的一组给定属性。
Because our application needs to deal with the plain-text versions of these attributes, it arranges to decrypt them again after the save is complete.
因为应用程序需要处理这些属性的纯文件本版本，所以它在完成保存后为其再次进行解密作准备。
It also needs to decrypt the data when a row is read from the database into a model object.
当从数据库读取一行记录到模型对象时，也需要解密数据。
These requirements mean we have to handle the before_save, after_save, and after_find events.
这些需求意味着，必须处理before_save, after_save和after_find事件。
Because we need to decrypt the database row both after saving and when we find a new row, we can save code by aliasing the after_find() method to after_save()—the same method will have two names.
因为需要解密数据库的行记录，既在保存后又在找到新纪录行时，所以通过给after_find方法别名after_save方法可节省代码——一个方法有两个名字。

• 302

    Download rails40/e1/ar/encrypt.rb
    class Encrypter
      # We're passed a list of attributes that should
      # be stored encrypted in the database
      # 传入一串将被加密存储在数据库里的属性清单
      def initialize(attrs_to_manage)
        @attrs_to_manage = attrs_to_manage
      end
      # Before saving or updating, encrypt the fields using the NSA and
      # DHS approved Shift Cipher
      # 保存或更新之前，使用NSA和DHS增强移位加密算法来加密字段
      def before_save(model)
        @attrs_to_manage.each do |field|
          model[field].tr!("a-z", "b-za")
        end
      end
      # After saving, decrypt them back
      # 保存之后，解密回来
      def after_save(model)
        @attrs_to_manage.each do |field|
          model[field].tr!("b-za", "a-z")
        end
      end
      # Do the same after finding an existing record
      # 找到已有记录时，也要解密回来
      alias_method :after_find, :after_save
    end

This example uses trivial encryption—you might want to beef it up before using this class for real.
这个例子使用简单的加密方法——在真正使用这个类之前，应该要对其进行强化。
We can now arrange for the Encrypter class to be invoked from inside our orders model.
现在可为从订单模型内调用encrypter类做准备。

    require "encrypter"
    class Order < ActiveRecord::Base
      encrypter = Encrypter.new([:name, :email])
      before_save encrypter
      after_save encrypter
      after_find encrypter
      protected
      def after_find
      end
    end

We create a new Encrypter object and hook it up to the events before_save, after_save, and after_find.
我们创建了一个新Encrypter对象，并把它挂到事件before_save, after_save和after_find。
This way, just before an order is saved, the method before_save() in the encrypter will be invoked, and so on.
这样，在保存订单对象之前，将调用针对对象encrypter的方法before_save，其他也是一样。

So, why do we define an empty after_find() method? 
那么，为什么要定义空的after_find方法呢？
Remember that we said that for performance reasons after_find and after_initialize are treated specially.
记得前面曾经说过，出于性能的考虑，特殊处理了函数after_find和after_initialize。

• 303

One of the consequences of this special treatment is that Active Record won’t know to call an after_find handler unless it sees an actual after_find() method in the model class.
这种特殊处理的后果之一是，Active Record并不知道调用after_find句柄，除非它发现模型类中实际存在的after_find方法。
We have to define an empty placeholder to get after_find processing to take place.
必须定义一个空占位符来触发after_find过程。
<kinder:note> 怎么没有示例？这个所谓的“空占位符”指的就是Order.rb中的after_find方法吧？

This is all very well, but every model class that wants to use our encryption handler would need to include some eight lines of code, just as we did with our Order class.
这样做固然很好，但每一个模型类都要使用加密句柄，都需要引用这8行代码；就像上面Order类用的那样。
We can do better than that.
可以做得更好一些。
We’ll define a helper method that does all the work and make that helper available to all Active Record models.
我们将定义一个完成所有这些工作的帮助方法，并将其提供给所有Active Record模型。
To do that, we’ll add it to the ActiveRecord::Base class.
要实现的话，可以将它添加到ActiveRecord::Base类中。

    Download rails40/e1/ar/encrypt.rb
    class ActiveRecord::Base
      def self.encrypt(*attr_names)
        encrypter = Encrypter.new(attr_names)
        before_save encrypter
        after_save encrypter
        after_find encrypter
        define_method(:after_find) { }
      end
    end

Given this, we can now add encryption to any model class’s attributes using a single call.
根据这个代码，现在可以单个调用，把加密方法添加到任何模型类的属性中。

    class Order < ActiveRecord::Base
      encrypt(:name, :email)
    end

A simple driver program lets us experiment with this.
用上面的代码做个简单的驱动程序：

    o = Order.new
    o.name = "Dave Thomas"
    o.address = "123 The Street"
    o.email = "dave@example.com"
    o.save
    puts o.name
    o = Order.find(o.id)
    puts o.name

On the console, we see our customer’s name (in plain text) in the model object.
在控制台上，可以看到模型对象的消费者姓名（纯文本）

    ar> ruby encrypt.rb
    Dave Thomas
    Dave Thomas

• 304

In the database, however, the name and email address are obscured by our industrial-strength encryption.
而在数据库中，姓名和电子邮件地址都是通过工业强化加密算法来掩盖的。

    depot> sqlite3 -line db/development.sqlite3 "select * from orders"
    id = 1
    user_id =
    name = Dbwf Tipnbt
    address = 123 The Street
    email = ebwf@fybnqmf.dpn

Callbacks are a fine technique, but they can sometimes result in a model class taking on responsibilities that aren’t really related to the nature of the model.
回调是一门优秀的技术，但它们有时可能产生模型类的结果，并不是模型本身所固有的。
For example, in Section 19.4, Participating in the Monitoring Process, on page 298, we created a callback that generated a log message when an order was created.
比如前面298页19.4节《干预跟踪进程》所示，创建订单对象时，创建了产生日志消息的回调。
That functionality isn’t really part of the basic Order class—we put it there because that’s where the callback executed.
这个功能并不真实基本的Order类的一部分——放在那里，是因为那时回调执行的地方。
When used in moderation, such an approach doesn’t lead to significant problems.
<kinder:note> 适度使用时，这样的倾向不是导致什么重大问题。
If, however, you find yourself repeating code, consider using Concerns [3] instead.
<kinder:note> 不过，如果你发现重复了，还是考虑Concerns吧。
[3].  http://37signals.com/svn/posts/3372-put-chubby-models-on-a-diet-with-concerns
<kinder:note> 本书没有进一步介绍吗？ 下面是这个页面的介绍

------------------------------
------------------------------

Put chubby models on a diet with concerns  用concern帮你的胖模型瘦身
David
David wrote this on Dec 18 2012 47 comments

Different models in your Rails application will often share a set of cross-cutting concerns.
你的Rails程序的不同模型经常会共享一组横跨各个模型的concern。
In Basecamp, we have almost forty such concerns with names like Trashable, Searchable, Visible, Movable, Taggable.
在 Basecamp，有接近40个类似的concern，名称有Trashable(可转换)，Searchable（可搜索）, Visible（可见）, Movable（可移动）, Taggable（可标签）。
 
These concerns encapsulate both data access and domain logic about a certain slice of responsibility. 
这些concerns压缩了数据访问和域逻辑的一部分确定的职责。
Here’s a simplified version of the taggable concern:
这里是一个taggable concern的简化版本。

    module Taggable
      extend ActiveSupport::Concern
    
      included do
        has_many :taggings, as: :taggable, dependent: :destroy
        has_many :tags, through: :taggings 
      end
    
      def tag_names
        tags.map(&:name)
      end
    end

This concern can then be mixed into all the models that are taggable and you’ll have a single place to update the logic and reason about it.
这个concern能混入所有可标签的模型类中，你就有了一个简单的地方来更新关于它的逻辑和动机。
Here’s a similar concern where all we add is a single class method:
这里是一个类似的concern，里面添加的是一个类方法。

    # current_account.posts.visible_to(current_user)
    module Visible
      extend ActiveSupport::Concern
    
      module ClassMethods
        def visible_to(person)
          where \
            "(#{table_name}.bucket_id IN (?) AND #{table_name}.bucket_type = 'Project') OR
             (#{table_name}.bucket_id IN (?) AND #{table_name}.bucket_type = 'Calendar')",
            person.projects.pluck('projects.id'), 
            calendar_scope.pluck('calendars.id')
        end
      end
    end

Concerns are also a helpful way of extracting a slice of model that doesn’t seem part of its essence (what is and isn’t in the essence of a model is a fuzzy line and a longer discussion) without going full-bore Single Responsibility Principle and running the risk of ballooning your object inventory.
Concern也是抽出模型非必要部分的片段的有效方法，无需违背“单一功能原则”，还冒着运行对象总量过大的风险。当然，“是否模型的必要部分”则是一个值得斟酌的灰色地带。
Here’s a Dropboxed concern that we mix into just the Person model, which allows us to later to route incoming emails to be from the right person:
这是一个Dropboxed concern，我们将只它混入Person模型类，允许我们在后面路由从正确的人那里收到邮件。

    module Dropboxed
      extend ActiveSupport::Concern
    
      included do
        before_create :generate_dropbox_key
      end
    
      def rekey_dropbox
        generate_dropbox_key
        save!
      end
    
      private
        def generate_dropbox_key
          self.dropbox_key = SignalId::Token.unique(24) do |key| 
            self.class.find_by_dropbox_key(key)
          end
        end
    end

Now this is certainly not the only way to slice up chubby models.
现在，这当然不是胖模型瘦身的唯一方法。
For Visible concern, you could have Viewer.visible(current_account.posts, to: current_user) and encapsulate the query in a stand-alone object.
对于Visible concern，可以用Viewer.Visible(current_account.posts, to: current_user)，将查询装入一个独立的对象中。
For Dropboxed, you could have a Dropbox stand-alone class.
对于Dropboxed,可以用独立的Dropbox类。

But I find that concerns are often just the right amount of abstraction and that they often result in a friendlier API.
但我发现，concerns经常是正确的抽象总量，经常产出一个更友好的API。
I far prefer current_account.posts.visible_to(current_user) to involving a third query object.
我非常喜欢current_account.posts.visible_to(current_user)来调用第三个查询对象。
And of course things like Taggable that needs to add associations to the target object are hard to do in any other way.
当然，像Taggable这样需要添加目标对象的，很难用其他方式做到。 

It’s true that this will lead to a proliferation of methods on some objects, but that has never bothered me.
毫无疑问这会导致一些对象方法上的增加，但不会令人心烦。
I care about how I interact with my code base through the source.
我留心怎么通过源代码和代码基础交互。
That concerns happen to mix it all together into a big model under the hood is irrelevant to the understanding of the domain model.
将众多concern在钩子之下混入一个大的模型，与理解主模型之间毫无瓜葛。 

We’ve been using this notion of extracting concerns from chubby models in all the applications at 37signals for years.
在37singnals的所有应用程序中，我们已经好几年使用这个方法来从臃肿的模型中抽出concern来。
It’s resulted in a domain model that’s simple and easy to understand without needless ceremony.
这发生在主模型上面，理解起来十分简单容易，无需什么花招。
Basecamp Classic’s domain model is 8+ years old now and still going strong with the use of concerns.
Basecamp Classic的主模型已经用了8年，仍然在使用concerns上运行得十分健壮。
 
This approach to breaking up domain logic into concerns is similar in some ways to the DCI notion of Roles.
这种将主逻辑放入concern的倾向在某些方面接近于Roles的DCI的概念。
<kinder:note> DCI (Data-Context-Interaction)数据-上下文-交互架构。
It doesn’t have the run-time mixin acrobatics nor does it have the “thy models shall be completely devoid of logic themselves” prescription, but other than that, it’ll often result in similar logic extracted using similar names.
这既没有运行时混入的“杂技”也没有“模型将完全缺乏自身的逻辑”的规定，而且，它将经常会导向使用近似的名称抽象近似的逻辑。
 
In Rails 4, we’re going to invite programmers to use concerns with the default app/models/concerns and app/controllers/concerns directories that are automatically part of the load path.
在 Rails 4，我们要邀请程序员们使用concern。默认app/models/concerns和app/concerns/concerns，这是自动装载路径的部分。
Together with the ActiveSupport::Concern wrapper, it’s just enough support to make this light-weight factoring mechanism shine.
和ActiveSupport::Concern包装器合用，就足够支持使用这个轻量级的因子机制。
But you can start using this approach with any Rails app today.
但你今天就可以开始使用Rails应用这个快速通道了。
Enjoy!
祝你愉快。

------------------------------
------------------------------
</kinder:note> 

## 19.5 Transactions 数据库事务
A database transaction groups a series of changes in such a way that either the database applies all of the changes or it applies none of the changes.
数据库事务把一系列数据库记录修改组合在一起，其处理方式是，要么数据库接收所有改变，要么什么也不接收。
The classic example of the need for transactions (and one used in Active Record’s own documentation) is transferring money between two bank accounts.
需要事务（在Active Record自己的文档中所使用的）的典型例子是两个银行账户之间的资金转移。
The basic logic is simple.
基本逻辑很简单。

account1.deposit(100)
account2.withdraw(100)

However, we have to be careful.
但必须小心。
What happens if the deposit succeeds but for some reason the withdrawal fails (perhaps the customer is overdrawn)?
当存款成功而由于某种原因取款失败（也许透支了）时，会发生什么？
We’ll have added $100 to the balance in account1 without a corresponding deduction from account2.
这样将不得不在account1增加100美元达到平衡，而没有从account2上扣减相应款项。
In effect, we’ll have created $100 out of thin air.
实际上已经凭空增加了100美元。

Transactions to the rescue.
事务是一种援救。
A transaction is something like the Three Musketeers with their motto “All for one and one for all.” 
事务有点像三剑客座右铭“我为人人，人人为我”。
Within the scope of a transaction, either every SQL statement succeeds or they all have no effect.
在一个事务范围内，要么每个SQL语句都成功，要么所有都没有效果。
Putting that another way, if any statement fails, the entire transaction has no effect on the database.
换言之，如果任何一个语句失败，那么整个事务对数据库就没有影响。

In Active Record we use the transaction() method to execute a block in the context of a particular database transaction.
在Active Record中，使用事务方法可以在数据库特定事务范围内执行一个代码块。
At the end of the block, the transaction  is committed, updating the database, unless an exception is raised within the block, in which case the database rolls back all of the changes.
在代码块结束时，就提交事务，进行数据库更新，除法代码块抛出异常情况，这种情况下数据库可以回滚所有改变。

• 305

Because transactions exist in the context of a database connection, we have to invoke them with an Active Record class as a receiver.
由于事务存在于一个数据库连接范围内，所以必须借助于作为接收器的Active Record类调用它们。

Thus, we could write this:
因此可以这样写：

    Account.transaction do
      account1.deposit(100)
      account2.withdraw(100)
    end

Let’s experiment with transactions. 
下面用事务做个实验。
We’ll start by creating a new database table. 
首先创建一个新的数据库表。
(Make sure your database supports transactions, or this code won’t work for you.)
（确保数据库支持事务功能，否则下面的代码不能运行。）

    Download rails40/e1/ar/transactions.rb
    create_table :accounts, force: true do |t|
      t.string :number
      t.decimal :balance, precision: 10, scale: 2, default: 0
    end

Next, we’ll define a simple bank account class.
接着定义简单的银行账户类。
This class defines instance methods to deposit money to and withdraw money from the account.
这个类定义了实例方法，以便在账户中存款而后提款。
It also provides some basic validation—for this particular type of account, the balance can never be negative.
它还提供了一些基本的有效性验证——对于这个特定类型的账户，余额永远不能为负数。

    Download rails40/e1/ar/transactions.rb
    class Account < ActiveRecord::Base
      validates :balance, numericality: {greater_than_or_equal_to: 0}
      def withdraw(amount)
        adjust_balance_and_save!(-amount)
      end
      def deposit(amount)
        adjust_balance_and_save!(amount)
      end
      private
      def adjust_balance_and_save!(amount)
        self.balance += amount
        save!
      end
    end

Let’s look at the helper method, adjust_balance_and_save!().
看看帮助方法adjust_balance_and_save!()。
The first line simply updates the balance field.
第一行更新余额字段。
The method then calls save! to save the model data.
然后该方法调用save!方法保存模型数据。
(Remember that save!() raises an exception if the object cannot be saved—we use the exception to signal to the transaction that something has gone wrong.)
（记住，如果不能保存对象，那么方法save!抛出异常——使用异常事务报告，可以了解出错的问题。）

• 306

So, now let’s write the code to transfer money between two accounts.
现在可以编写在两个账户之间转账的代码了。
It’s pretty straightforward.
非常简单的。

    Download rails40/e1/ar/transactions.rb
    peter = Account.create(balance: 100, number: "12345")
    paul = Account.create(balance: 200, number: "54321")
    Account.transaction do
      paul.deposit(10)
      peter.withdraw(10)
    end

We check the database, and, sure enough, the money got transferred.
通过检查数据库，果然完成转账：

    depot> sqlite3 -line db/development.sqlite3 "select * from accounts"
    id = 1
    number = 12345
    balance = 90
    id = 2
    number = 54321
    balance = 210

Now let’s get radical.
更彻底一点。
If we start again but this time try to transfer $350, we’ll run Peter into the red, which isn’t allowed by the validation rule.
再来一次，这次转出350美元，而有效性验证规则不允许客户进行转账。
Let’s try it:
试试：

    Download rails40/e1/ar/transactions.rb
    peter = Account.create(balance: 100, number: "12345")
    paul = Account.create(balance: 200, number: "54321")
    Download rails40/e1/ar/transactions.rb
    Account.transaction do
      paul.deposit(350)
      peter.withdraw(350)
    end

When we run this, we get an exception reported on the console.
运行代码时，控制台报告异常：

    .../validations.rb:736:in `save!': Validation failed: Balance is negative
    from transactions.rb:46:in `adjust_balance_and_save!'
    : : :
    from transactions.rb:80

Looking in the database, we can see that the data remains unchanged.
看看数据库，可得知该数据保持不变。

    depot> sqlite3 -line db/development.sqlite3 "select * from accounts"
    id = 1
    number = 12345
    balance = 100
    id = 2
    number = 54321
    balance = 200

• 307

However, there’s a trap waiting for you here.
不过，这里有个陷阱。
The transaction protected the database from becoming inconsistent, but what about our model objects? 
To see what happened to them, we have to arrange to intercept the exception to allow the program to continue running.
虽然事务防止了数据不一致，但模型对象如何处理呢？
要看到发生了什么事，就必须为拦截异常、允许程序继续运行做准备。

    Download rails40/e1/ar/transactions.rb
    peter = Account.create(balance: 100, number: "12345")
    paul = Account.create(balance: 200, number: "54321")

    Download rails40/e1/ar/transactions.rb
    begin
      Account.transaction do
        paul.deposit(350)
        peter.withdraw(350)
      end
    rescue
      puts "Transfer aborted"
    end
    puts "Paul has #{paul.balance}"
    puts "Peter has #{peter.balance}"

What we see is a little surprising.
<kinder:note> 眼前的一切令人吃惊。

    Transfer aborted
    Paul has 550.0
    Peter has -250.0

Although the database was left unscathed, our model objects were updated anyway.
**虽然数据库没有改变，但模型对象已经更新**。
This is because Active Record wasn’t keeping track of the before and after states of the various objects—in fact, it couldn’t, because it had no easy way of knowing just which models were involved in the transactions.
这是因为对于不同对象的前后状态，Active Record没有保持跟踪——事实上这是不可能的，因为没有简便的方法知道究竟在事务中调用了哪些模型。

### Built-in Transactions 内建事务
When we discussed parent and child tables in Specifying Relationships in Models, on page 282, we said that Active Record takes care of saving all the dependent child rows when you save a parent row.
前面282页19.2.2节《指定模型关联》中曾经讨论过父表和子表，当储存父表记录行时，Active Record保存所有关联的子表行记录。
This takes multiple SQL statement executions (one for the parent and one each for any changed or new children).
这需要执行几个SQL语句（父表的一行记录和子表的每一个已改变的或新的行记录）。
Clearly, this change should be atomic, but until now we haven’t been using transactions when saving these interrelated objects.
显然，这种改变应该是原子的，但到现在为止，当保存这些关联的对象时，并没有用事务。
Have we been negligent?
是Rails的疏忽吗？

Fortunately, no.
幸运的是，没有。
Active Record is smart enough to wrap all the updates and inserts related to a particular save() (and also the deletes related to a destroy()) in a transaction; either they all succeed or no data is written permanently to the database.
Active Record是足够精明的，它在事务中把所有更新和插入打包到特殊函数save（如果是删除则是destroy）中；要么全部成功永久地写入到数据库中，没有没有数据写入。
You need explicit transactions only when you manage multiple SQL statements yourself.
仅当自己管理几个SQL语句时，才需要明确的事务。

• 308

While we have covered the basics, transactions are actually very subtle.
虽然我们已经介绍了基础知识，但事务其实很微妙。
They exhibit the so-called ACID properties: they’re Atomic, they ensure Consistency, they work in Isolation, and their effects are Durable (they are made permanent when the transaction is committed).
它们表现出来所谓ACID特性：原子、一致、孤立、持久（事务提交时它们是持久的）。
It’s worth finding a good database book and reading up on transactions if you plan to take a database application live.
如果打算使得数据库应用程序更具活力，那就找一本好的数据库图书，读读事务；这是很值得的。

## What We Just Did 本章小节
We learned the relevant data structures and naming conventions for tables, classes, columns, attributes, IDs, and relationships.
首先，在本章中学习了相关的数据结构和命名表、类、字段、属性、主键id和模型关联。
We saw how to create, read, update, and delete this data.
其次，了解到如何创建、读取、更新和删除这些数据。
Finally, we now understand how transactions and callbacks can be used to prevent inconsistent changes.
最后，明白了如何使用事务和回调防止数据的不一致。

This, coupled with validation as described in Chapter 7, Task B: Validation and Unit Testing, on page 77, covers all the essentials of Active Record that every Rails programmer needs to know.
加上在第7章所描述的有效性验证，这样已经覆盖了每个Rails程序员都需要知道的所有Active Record的基础知识。
If you have specific needs beyond what is covered here, look to the Rails Guides that you generated in A Place for Documentation, on page 265, for more information.
如果你有特殊需要，超出这里所介绍的内容，那么在前面265页18.1节生成的Rails指南中，有更详细的描述。

The next major subsystem to cover is Action Pack, which covers both the view and controller portions of Rails.
下面介绍重要的子系统Action Pack，其中包括Rils视图和控制器的一部分内容。

# CHAPTER 20 Action Dispatch and Action Controller  动作调度和动作控制
## In this chapter, we’ll see
  在本章中，我们将学习
• Representational State Transfer (REST);
  表述性状态转义（REST）；
• defining how requests are routed to controllers;
  定义如何使得请求路由到控制器；
• selecting a data representation;
  选择数据表述性；
• testing routes;
  测试路由；
• the controller environment;
  控制器环境；
• rendering and redirecting; and
  呈现和转向
• sessions, flash, and callbacks.
  会话、闪存和回调（过滤器）

Action Pack lies at the heart of Rails applications.
Action Pack是Rails应用程序的核心。
It consists of three Ruby modules: ActionDispatch, ActionController, and ActionView.
它由三个Ruby模块组成：ActionDispatch, ActionController, 和 ActionView。
Action Dispatch routes requests to controllers.
Action Dispatch 模块使请求路由到控制器。
Action Controller converts requests into responses.
Action Controller模块使请求转换成响应。
Action View is used by Action Controller to format those responses.
Action View被Action Controller用来格式化响应。

As a concrete example, in the Depot application, we routed the root of the site (/) to the index() method of the StoreController.
在Depot应用程序的例子中，就曾经把根网站（/）路由到StoreController类的index方法。
At the completion of that method, the template in app/views/store/index.html.erb was rendered.
在执行完该方法后，再呈现到模板文件app/views/store/index.html.erb。
Each of these activities was orchestrated by modules in the Action Pack component.
上述每一项活动都由Action Pack组件精心策划。

Working together, these three submodules provide support for processing incoming requests and generating outgoing responses.
三个子模块一起工作时，它们提供处理输入请求、生成输出相应的支持。
In this chapter, we’ll look at both Action Dispatch and Action Controller.
在本章中，将先介绍Action Dispatch模块和Action Controller模块。
In the next chapter, we will cover Action View.
下一章再介绍Action View模块。

When we looked at Active Record, we saw it could be used as a freestanding library; we can use Active Record as part of a nonweb Ruby application.
在前面介绍Active Record时，曾将它视为完全独立的库；其实也可以视为非web的ruby应用程序的一部分。
Action Pack is different.
Action Pack则不同。
Although it is possible to use it directly as a framework, you probably won’t.
虽然它可以直接用作框架，但一般不会这样做。
Instead, you’ll take advantage of the tight integration offered by Rails.
相反，可以利用Rails提供的紧密一体化功能。
Components such as Action Controller, Action View, and Active Record handle the processing of requests, and the Rails environment knits them together into a coherent (and easy-to-use) whole.
处理请求的过程使用一系列组件，如Action Controller模块、Action View模块和Active Record模块等，而Rails环境把它们编织成一个连贯（且易用）的整体。
For that reason, we’ll describe Action Controller in the context of Rails.
处于这样的原因，这里将描述在Rails范围内的Action Controller。
Let’s start by looking at how Rails applications handle requests.
首先看看rails应用程序是如何处理请求的。
We’ll then dive down into the details of routing and URL handling.
然后将会深入路由和URL处理的细节。
We’ll continue by looking at how you write code in a controller.
接着看看如何编写控制器代码。
Finally, we will cover sessions, flash, and callbacks.
最后将涵盖会话、闪存和过滤器（回调）三个方面的话题。

## 20.1 Dispatching Requests to Controllers  分派请求到控制器
### 两种方式
At its simplest, a web application accepts an incoming request from a browser, processes it, and sends a response.
简单地讲，Web应用程序从浏览器接收输入请求，对它进行处理，并发送生成的响应。

• 310

The first question that springs to mind is, how does the application know what to do with the incoming request? 
回顾一下，第一个问题是，应用程序如何直到输入请求做什么用呢？
A shopping cart application will receive requests to display a catalog, add items to a cart, create an order, and so on.
购物车应用程序将接收请求以显示目录、将商品项目添加到购物车、创建订单等等。
How does it route these requests to the appropriate code?
该应用程序如何将这些请求路由到相应的代码呢？

It turns out that Rails provides two ways to define how to route a request: a comprehensive way that you will use when you need to and a convenient way that you will generally use whenever you can.
原来，Rails提供了定义路由请求的两种方式：一种综合方式是当需要时使用的；另一种便捷方式是在一般情况下经常使用的。
The comprehensive way lets you define a direct mapping of URLs to actions based on pattern matching, requirements, and conditions.
**综合方式**可定义URL直接映射，基于模式匹配、需求和条件的动作。
The convenient way lets you define routes based on resources, such as the models that you define.
**便捷方式**可定义基于资源的路由，如用户所定义的模型。
And because the convenient way is built on the comprehensive way, you can freely mix and match the two approaches.
因为便捷方式是以综合方式为基础的，所以可自由搭配使用这两种方法。

In both cases, Rails encodes information in the request URL and uses a subsystem called Action Dispatch to determine what should be done with that request.
在上述两种情况下，Rails编码URL请求的信息，并使用Action Dispatch子系统，以确定这一请求应该做什么。
The actual process is very flexible, but at the end of it Rails has determined the name of the controller that handles this particular request, along with a list of any other request parameters.
实际过程是非常灵活的，但在这一过程结束时，Rails已经确定了处理这个特殊请求的控制器名，以及该请求的其他参数的列表。
In the process, either one of these additional parameters or the HTTP method itself is used to identify the action to be invoked in the target controller.
在这一过程中，无论是这些额外的参数，还是HTTP方法本身，都是识别调用目标控制器的行为。

Rails routes support the mapping between URLs and actions based on the contents of the URL and on the HTTP method used to invoke the request.
Rails路由支持URL和动作之间的映射；它们是基于URL内容和调用请求所使用的HTTP方法。
We’ve seen how to do this on a URL-by-URL basis using anonymous or named routes.
我们已经看到了如何以URL网址为基础使用匿名或命名路由进行操作。
Rails also supports a higher-level way of creating groups of related routes.
Rails还支持更高层次的方式，创建一组相关的路由。
To understand the motivation for this, we need to take a little diversion into the world of Representational State Transfer.
为了搞清楚这样做的目的，需要暂时先观察"表述性状态转移"的世界。

### 20.1.1 REST: Representational State Transfer 表述性状态转移
The ideas behind REST were formalized in Chapter 5 of Roy Fielding’s 2000 PhD dissertation.[1] 
2000年年由Roy Fielding先生在其博士论文第5章正式提出REST的想法。
[1].  http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
In a REST approach, servers communicate with clients using stateless connections.
在REST方式中，服务器端与客户端之间的通信使用无状态的连接。
All the information about the state of the interaction between the two is encoded into the requests and responses between them.
两者之间所有互动状态的编码信息存放到请求和响应之中。
Long-term state is kept on the server as a set of identifiable resources.
在服务器端把长期状态作为一组可识别的资源保存。
Clients access these resources using a well-defined (and severely constrained) set of resource identifiers (URLs in our context).
客户端使用一组定义良好（并受到严格限制）的资源标识符（这里是URL）访问这些资源。
REST distinguishes the content of resources from the presentation of that content.
REST从该内容的表象区分资源的内容。
REST is designed to support highly scalable computing while constraining application architectures to be decoupled by nature.
REST被设计来支持高度可扩展计算，同时本身能兼容对应用程序架构的制约。

• 311

There’s a lot of abstract stuff in this description.
上面种种解释存在着大量抽象的内容。
What does REST mean in practice?
实践中REST意味着什么？

First, the formalities of a RESTful approach mean that network designers know when and where they can cache responses to requests.
不限，RESTful方法的表达形式是指网络设计师直到何时何地可以缓存请求的响应。
This enables load to be pushed out through the network, increasing performance and resilience while reducing latency.
这能够负载网络的压力，并且在降低延迟的同时提高性能和弹性。

Second, the constraints imposed by REST can lead to easier-to-write (and maintain) applications.
其次，经过REST外加荷载的约束，使应用程序变得更容易编写（和维护）。
RESTful applications don’t worry about implementing remotely accessible services.
RESTful应用程序不必担心实施远程访问服务。
Instead, they provide a regular (and simple) interface to a set of resources.
相反，针对一组资源，它们提供了有规律的（简单的）接口。
Your application implements a way of listing, creating, editing, and deleting each resource, and your clients do the rest.
应用程序实现列表、创建、编辑和删除每个资源的方法，并且由客户端完成剩余的部分。

Let’s make this more concrete.
下面的解释更详细写。
In REST, we use a simple set of verbs to operate on a rich set of nouns.
在 REST中， 使用一组简单的动词， 以一组丰富的名词形成动宾结构。
If we’re using HTTP, the verbs correspond to HTTP methods (GET, PUT, PATCH, POST, and DELETE, typically).
如果使用http，则这些东西对应HTTP方法（通常是GET PUT POST和DELETE）。
The nouns are the resources in our application.
这些名词都是应用程序中的资源。
We name those resources using URLs.
我们把这些资源作为URL。

The Depot application that we produced contained a set of products.
Depot应用程序已经有了一组产品。
There are implicitly two resources here.
这里隐藏着两种资源。
First, there are the individual products.
首先是单个产品。
Each constitutes a resource.
每个产品构成一种资源。
There’s also a second resource: the collection of products.
还有第二种资源：产品的集合。

To fetch a list of all the products, we could issue an HTTP GET request against this collection, say on the path /products.
为了获取所有产品的列表，可以对这个集合发出HTTP GET请求，路径是/products。
To fetch the contents of an individual resource, we have to identify it.
为了获取单个资源的内容，必须明确地指出它。
The Rails way would be to give its primary key value (that is, its ID).
Rails的方法将基于其主键值（就是id）。
Again we’d issue a GET request, this time against the URL /products/1.
这就可以发出一个GET请求，这次的URL是/products/1。

To create a new product in our collection, we use an HTTP POST request directed at the /products path, with the post data containing the product to add.
要创建新产品到集合中，使用HTTP
POST请求，这种请求是以/products路径定向，且包含要添加产品的post数据。
Yes, that’s the same path we used to get a list of products.
是，获得产品清单，也使用相同的路径。
If you issue a GET to it, it responds with a list, and if you do a POST to it, it adds a new product to the collection.
如果把GET发给它，则回应列表；进行POST，则增家新产品到集合。

Take this a step further.
更进一步说明。
We’ve already seen you can retrieve the content of a product—you just issue a GET request against the path /products/1.
上面已经看到了可检索产品内容——只是发出GET请求，路径为/products/1。
To update that product, you’d issue an HTTP PUT request against the same URL.
为了更新该产品，可发出学生的URL的HTTP PUT请求。
And, to delete it, you could issue an HTTP DELETE request, again using the same URL.
而删除它，可发出HTTP DELETE请求，还是使用相同的URL。

Take this further.
再进一步。
Maybe our system also tracks users.
可能系统要对用户进行跟踪。
Again, we have a set of resources to deal with.
这就还要处理一组资源来。
REST tells us to use the same set of verbs (GET,  POST, PATCH, PUT, and DELETE) against a similar-looking set of URLs (/users, /users/1, and so on).
REST告诉我们，可以对一组看上去类似的URL（如/users, users/1等），使用一组相同的动词（GET POST PATCH PUT DELETE）。

• 312

Now we see some of the power of the constraints imposed by REST.
现在我们看到了REST施加的约束能力。
We’re already familiar with the way Rails constrains us to structure our applications a certain way.
我们已经熟悉了Rails的方法，它限制我们以某种方式构造应用程序。
Now the REST philosophy tells us to structure the interface to our applications too.
REST哲学告诉我们，可用这种接口构造应用程序。
Suddenly our world gets a lot simpler.
突然之间世界变得简单了许多。

Rails has direct support for this type of interface; it adds a kind of macro route facility, called resources.
Rails提供了直接支持这种类型的接口；增加了一种宏路由工具，称为资源路由。
Let’s take a look at how the config/routes.rb file might have looked back in Creating a Rails Application, on page 61.
看看前面61页《创建Rails应用程序》里面config/routes.rb文件的内容吧：

      Depot::Application.routes.draw do
    ➤   resources :products
      end

The resources line caused seven new routes to be added to our application.
resources 行产生了添加到应用程序的七个新路由。
Along the way, it assumed that the application will have a controller named ProductsController, containing seven actions with given names.
假定该应用程序有个ProductsController控制器，它包含七个给定名称的动作。
You can take a look at the routes that were generated for us.
这里可以看到新生的路由。
We do this by making use of the handy rake routes command.
通过`rake routes`命令可以看到：

                         URI Pattern 网址模式
    Prefix Verb前置动词  Controller#Action  控制器#动作
        products GET     /products(.:format)
                         {:action=>"index", :controller=>"products"}
                POST     /products(.:format)
                         {:action=>"create", :controller=>"products"}
     new_product GET     /products/new(.:format)
                         {:action=>"new", :controller=>"products"}
    edit_product GET     /products/:id/edit(.:format)
                         {:action=>"edit", :controller=>"products"}
         product GET     /products/:id(.:format)
                         {:action=>"show", :controller=>"products"}
               PATCH     /products/:id(.:format)
                         {:action=>"update", :controller=>"products"}
              DELETE     /products/:id(.:format)
                         {:action=>"destroy", :controller=>"products"}

All the routes defined are spelled out in a columnar format.
所有已定义的路由是以列格式显示的。
The lines will generally wrap on your screen; in fact, they had to be broken into two lines per route to fit on this page.
一般情况下，屏幕上的这些行会化妆一番；事实上在这个页上每个路由已经折成两行。
The columns are (optional) route name, HTTP method, route path, and (on a separate line on this page) route requirements.
这些列都是（可选的）路由名称、HTTP方法、路由路径以及（在这一页占一行的）路由需求。

Fields in parentheses are optional parts of the path.
括号中的字段是路径里可选的部分。
Field names preceded by a colon are for variables into which the matching part of the path is placed for later processing by the controller.
<kinder:note> 前置了冒号的字段名是变化的，它在匹配路径部分中，让控制器随后进行处理。
<kinder:note> 4版译文：使用:format参数让控制器可以根据不同的格式请求作出不同的处理。

• 313

Now let’s look at the seven controller actions that these routes reference.
现在看看与这些路由相关联的7个控制器动作。
Although we created our routes to manage the products in our application, let’s broaden this to talk about resources—after all, the same seven methods will be required for all resource-based routes.
虽然在应用程序中已经创建了管理产品的路由，但是下面进一步说明这一点，并且讨论一下资源——毕竟，对于所有以资源为基础的路由，都将需要这七个相同的方法。
index
Returns a list of the resources.
返回资源列表。
create
Creates a new resource from the data in the POST request, adding it to the collection.
从POST请求的数据中创建新资源，再将其添加到集合中。
new
Constructs a new resource and passes it to the client. 
构造新资源，并把它传递给客户端。
This resource will not have been saved on the server. 
在服务器上不会保存这种资源。
You can think of the new action as creating an empty form for the client to fill in.
可考虑新的动作、为客户端创造可填写的空表格。
show
Returns the contents of the resource identified by params[:id].
返回由params[:id]所确定的资源内容。
update
Updates the contents of the resource identified by params[:id] with the data associated with the request.
更新由params[:id]所确定的、与请求相关数据的资源。
edit
Returns the contents of the resource identified by params[:id] in a form suitable for editing.
返回由params[:id]所确定的资源内容，为客户端创造可编辑的表单。
destroy
Destroys the resource identified by params[:id].
删除由params[:id]所确定的资源内容。

You can see that these seven actions contain the four basic CRUD operations (create, read, update, and delete).
可以看到，这七项动作包含四个基本的CRUD操作（创建、读取、更新和删除）。
They also contain an action to list resources and two auxiliary actions that return new and existing resources in a form suitable for editing on the client.
它们还包括列出资源的动作，两个返回新的和现有的资源辅助动作，可客户端创造可编辑的表格。

If for some reason you don’t need or want all seven actions, you can limit the actions produced using :only or :except options on your resources.
如果由于某种原因，不需要或不希望所有七个动作，则可以使用资源**选项:only或:except**来限制这些动作。

    resources :comments, except: [:update, :destroy]

Several of the routes are named routes enabling you to use helper functions such as products_url and edit_product_url(id:1).
有几个路由都是使用**辅助函数命名路由**，如products_url和edit_product_url(id: 1)。
Note that each route is defined with an optional format specifier.
注意，用可选的**格式符:format**，每条路由都可以定义。
We will cover formats in more detail in Selecting a Data Representation, on page 318.
下面318页20.1.6节《选择数据表述》会更详细的说明这种格式。

Let’s take a look at the controller code:
下面看看控制器代码：

• 314

    Download rails40/depot_a/app/controllers/products_controller.rb
    class ProductsController < ApplicationController
      before_action :set_product, only: [:show, :edit, :update, :destroy]
      # GET /products
      # GET /products.json
      def index
        @products = Product.all
      end
      # GET /products/1
      # GET /products/1.json
      def show
      end
      # GET /products/new
      def new
        @product = Product.new
      end
      # GET /products/1/edit
      def edit
      end
      # POST /products
      # POST /products.json
      def create
        @product = Product.new(product_params)
        respond_to do |format|
          if @product.save
            format.html { redirect_to @product,
            notice: 'Product was successfully created.' }
            format.json { render action: 'show', status: :created,
                          location: @product }
          else
            format.html { render action: 'new' }
            format.json { render json: @product.errors,
                          status: :unprocessable_entity }
          end
        end
      end
      # PATCH/PUT /products/1
      # PATCH/PUT /products/1.json
      def update
        respond_to do |format|
          if @product.update(product_params)
            format.html { redirect_to @product,
                          notice: 'Product was successfully updated.' }
            format.json { head :no_content }

• 315

          else
            format.html { render action: 'edit' }
            format.json { render json: @product.errors,
                          status: :unprocessable_entity }
          end
        end
      end
      # DELETE /products/1
      # DELETE /products/1.json
      def destroy
        @product.destroy
        respond_to do |format|
          format.html { redirect_to products_url }
          format.json { head :no_content }
        end
      end
      private
      # Use callbacks to share common setup or constraints between actions.
      def set_product
        @product = Product.find(params[:id])
      end
      # Never trust parameters from the scary internet, only allow the white
      # list through.
      def product_params
        params.require(:product).permit(:title, :description, :image_url, :price)
      end
    end

Notice how we have one action for each of the RESTful actions.
注意，对于RESTful的每个动作，我们如何作出一个行动。
The comment before each shows the format of the URL that invokes it.
每一动作前的注释显示了调用URL的格式。

Notice also that many of the actions contain a respond_to() block.
还要注意到这些动作中的大多数都包含了respond_to()代码块。
As we saw in Chapter 11, Task F: Add a Dash of Ajax, on page 135, Rails uses this to determine the type of content to send in a response.
正如前面135页11章所示，Rails使用它来确定相应发送的内容类型。
The scaffold generator automatically creates code that will respond appropriately to requests for HTML or JSON content.
支架生成器自动创建代码，它们针对HTML或JSON内容请求作出适当的响应。
We’ll play with that in a little while.
这里将做一点小小的发挥。

The views created by the generator are fairly straightforward.
由生成器所产生的视图代码是相当简单的。
The only tricky thing is the need to use the correct HTTP method to send requests to the server.
唯一棘手的事情是需要使用正确的HTTP方法，将请求发送到服务器。
For example, the view for the index action looks like this:
例如，index行为的视图代码如下所示：

    Download rails40/depot_a/app/views/products/index.html.erb
    <h1>Listing products</h1>
    <table>
    <% @products.each do |product| %>
      <tr class="<%= cycle('list_line_odd', 'list_line_even') %>">

• 316

        <td>
          <%= image_tag(product.image_url, class: 'list_image') %>
        </td>
        <td class="list_description">
          <dl>
            <dt><%= product.title %></dt>
            <dd><%= truncate(strip_tags(product.description), length: 80) %></dd>
          </dl>
        </td>
        <td class="list_actions">
          <%= link_to 'Show', product %><br/>
          <%= link_to 'Edit', edit_product_path(product) %><br/>
          <%= link_to 'Destroy', product, method: :delete,
              data: { confirm: 'Are you sure?' } %>
        </td>
      </tr>
    <% end %>
    </table>
    <br />
    <%= link_to 'New product', new_product_path %>

The links to the actions that edit a product and add a new product should both use regular GET methods, so a standard link_to works fine.
编辑产品，并添加新产品的动作连接应该使用普通的GET方法，这样标准函数link_to就能很好地工作。
However, the request to destroy a product must issue an HTTP DELETE, so the call includes the method: :delete option to link_to.
然而，删除产品的请求必须发出HTTP DELETE，因此这个调用要包括link_to的method: delete选项。

### 20.1.2 Adding Additional Actions 添加额外动作
Rails resources provide you with an initial set of actions, but you don’t need to stop there.
Rails资源提供了一组初始的动作，但你可以进一步扩充自己的动作。
In Section 12.2, Iteration G2: Atom Feeds, on page 172, we added an interface to allow people to fetch a list of people who bought any given product.
在前面172页的12.2节，我们增加了接口，允许人们获取购买任何已知产品的清单。
To do that with Rails, we use an extension to the resources call.
要利用Rails来做，可以使用resources调用的扩展。

    Depot::Application.routes.draw do
      resources :products do
        get :who_bought, on: :member
      end
    end

That syntax is straightforward.
语法很简单。
It says “We want to add a new action named who_bought, invoked via an HTTP GET. It applies to each member of the collec- tion of products.” 
要添加新的who_bought动作，通过HTTP GET调用，适用于产品集合的每个成员。
Instead of specifying :member, if we instead specified :collection, then the route would apply to the collection as a whole.
如果不指定:menber，而指定:collection，那么路由将适用于作为一个整体的集合。
This is often used for scoping; for example, you may have collections of products on clearance or products that have been discontinued.
这经常应用于scoping（范围）；例如允许有些产品集合，而另一些则不通过。
<kinder:note> 还是语焉不详。

• 317

### 20.1.3 Nested Resources 嵌套路由
Often our resources themselves contain additional collections of resources.
通常，资源本身包含附加的资源集合。
For example, we may want to allow folks to review our products.
例如，可能希望消费者评论我们的产品。
Each review would be a resource, and collections of review would be associated with each product resource.
每次评论都将是一个资源，评论集合将与每个产品的资源相关。
Rails provides a convenient and intuitive way of declaring the routes for this type of situation.
Rails对于这种类型的情况，提供了方便和直观的声明路由的方式。

    resources :products do
      resources :reviews
    end

This defines the top-level set of product routes and additionally creates a set of subroutes for reviews.
这定义了一组顶级的产品路由，另外还创建了对于评论的一组子路由。
Because the review resources appear inside the products block, a review resource must be qualified by a product resource.
因为评论资源出现于产品代码块内，因此评论资源必须附属于产品资源。
This means that the path to a review must always be prefixed by the path to a particular product.
这意味着评论的路径必须始终以特定产品的路径为前缀。
To fetch the review with ID 4 for the product with an ID of 99, you’d use a path of /products/99/reviews/4.
为了获取对id为4、产品id为99的评论，应该使用路径/products/99/reviews/4。

The named route for /products/:product_id/reviews/:id is product_review, not simply review.
对于所命名的路由是product_review，而不是简单的review。
This naming simply reflects the nesting of these resources.
这种命名只是反映了这些资源的嵌套。

As always, you can see the full set of routes generated by our configuration by using the rake routes command.
通常，可以使用`rake routes`命令看看我们的配置所生成的路由。

### 20.1.4 Routing Concerns 路由关注
<kinder:note> 这一节是本版新增的。
So far, we have been dealing with a fairly small set of resources.
现在，我们已经见过了一组相当小的资源。
On a larger system there may be types of objects for which a review may be appropriate or to which a who_bought action might reasonably be applied.
而更大的系统可能存在多个对象类型，每个类型都要适当的评论，或每个类型都要who_bought动作得到合理地应用。
Instead of repeating these instructions for each resource, consider refactoring your routes using concerns to capture the common behavior.
那就不再重复每种资源的表述了，而是考虑使用关注来重组路由，从而捕获共同的行为。

    concern :reviewable do
      resources :reviews
    end
    resources :products, concern: :reviewable
    resources :users, concern: :reviewable

The preceding definition of the products resource is equivalent to the one in the previous section.
产品资源的定义的前面部分，还是上一节的那个。

### 20.1.5 Shallow Route Nesting 浅路由嵌套
At times, nested resources can produce cumbersome URLs.
有时，嵌套资源会导致繁杂的URL。
A solution to this is to use shallow route nesting.
解决方法是使用浅路由嵌套：

• 318

    resources :products, shallow: true do
      resources :reviews
    end

This will enable the recognition of the following routes:
这样，下面的路由也就认可了：

    /products/1 => product_path(1)
    /products/1/reviews => product_reviews_index_path(1)
    /reviews/2 => reviews_path(2)

Try the rake routes command to see the full mapping.
尝试使用命令`rake routes`来看看完整的映射吧。

### 20.1.6 Selecting a Data Representation 选择一个数据表述
One of the goals of a REST architecture is to decouple data from its representation.
REST架构的目标之一就是从数据的表述解耦数据。
If a human uses the URL path /products to fetch some products, they should see nicely formatted HTML.
如果使用URL路径/products来获取一些产品，那么就应该看到很好的格式化的HTML。
If an application asks for the same URL, it could elect to receive the results in a code-friendly format (YAML, JSON, or XML, perhaps).
如果应用程序询问同一个URL，那么它会选择“代码友好”的格式结果（如YAML JSON XML等）。

We’ve already seen how Rails can use the HTTP Accept header in a respond_to block in the controller.
前面已经看到，Rails可以使用在控制器的respond_to代码块的HTTP接收标头。
However, it isn’t always easy (and sometimes it’s plain impossible) to set the Accept header.
但是，设置HTTP接收标头，并不总是很容易（有时完全不可能）
To deal with this, Rails allows you to pass the format of response you’d like as part of the URL.
为了解决这个问题，Rails允许你传递响应的格式，这种格式可以作为URL的一部分。
As you have seen, Rails accomplishes this by including a field called :format in your route definitions.
<kinder:note> 你前面已经看到，Rails通过在路由定义中包含一个:format字段来实现。
To do this, set a :format parameter in your routes to the file extension of the MIME type you’d like returned.
要做到这一点，把在路由中的参数:format设置为所要返回的MINE类型的文件扩展名。

    GET /products(.:format)
        {:action=>"index", :controller=>"products"}

Because a full stop (period) is a separator character in route definitions, :format is treated as just another field.
因为在路由中定义中，句点（.）是分隔符；这样把format视为另一字段。
Because we give it a nil default value, it’s an optional field.
因为它的默认值是nil，所以这是一个可选字段。

Having done this, we can use a respond_to() block in our controllers to select our response type depending on the requested format.
要是这样做，就可以把控制器中的respond_to代码块应用于选择响应类型，这种类型依赖于请求格式

    def show
      respond_to do |format|
        format.html
        format.xml { render xml: @product.to_xml }
        format.yaml { render text: @product.to_yaml }
      end
    end

Given this, a request to /store/show/1 or /store/show/1.html will return HTML content, while /store/show/1.xml will return XML, and /store/show/1.yaml will return YAML.
考虑到这点，对于/store/show/1或者/store/show/1.html的请求将返回html内容；/store/show1.xml将返回XML；/store/show/1.yaml将返回YAML。
You can also pass the format in as an HTTP request parameter.
也可以HTTP请求参数进行格式传递。

• 319

    GET HTTP://pragprog.com/store/show/123?format=xml

The routes defined by resources have this facility enabled by default.
资源定义的路由默认开启这个功能。

Although the idea of having a single controller that responds with different content types seems appealing, the reality is tricky.
**单一控制器响应不同的内容类型**，虽然这种想法似乎具有吸引力，但现实情况下这是非常棘手的。
In particular, it turns out that error handling can be tough.
尤其要指出的是，**错误处理可能很困难**。
Although it’s acceptable on error to redirect a user to a form, showing them a nice flash message, you have to adopt a different strategy when you serve XML.
错误发生时，把用户重定向到一个表单，同时对其显示一个闪存信息；尽管这个做法可以接受，但当为XML提供服务时，必须采取不同的策略。
Consider your application architecture carefully before deciding to bundle all your processing into single controllers.
在决定把所有过程捆绑成单一控制器之前，要仔细考虑应用程序的架构。

Rails makes it simple to develop an application that is based on resourcebased routing.
在基于资源的路由的基础上，Rails使开发应用程序变得简单。
Many claim it greatly simplifies the coding of their applications.
许多人声称，这样大大简化了应用程序的开发。
However, it isn’t always appropriate.
然而，这种说明并不总是恰当的。
Don’t feel compelled to use it if you can’t find a way of making it work.
即使找不到一种运行的方法，也不要以为必须使用它。
And you can always mix and match.
总是可以混合和匹配的。
Some controllers can be resource based, and others can be based on actions.
有些控制器是基于资源的，而有些是基于动作的。
Some controllers can even be resource based with a few extra actions.
甚至有些控制器可以带一些额外的动作作为基础资源。
<kinder:note> 怎么理解？说得是前面的“添加额外动作”吗？
### 20.1.7 测试路由 
<kinder:note> 
这一章在本版已被删除。但后面的“本章小结”却意外提到了。
因此这里将4版的本节补录起来。仅供参考。吐槽一下，译文真是有些难以理解！
</kinder:note> 
到目前为止，我们一直通过命令rake routes查看路由方式，进行探讨。
但是，推出应用程序时，可能还要多一些形式，包括验证路由如期运行的单元测试。
Rails包括了一系列测试帮助程序，使其变得更容易：
#### assert_generates(path, options, defaults={}, extras={}, message=nil)
验证一组给定的选项，这些选项生成指定的路径。

    def test_generates
      assert_generates("/", controller: "store", action: "index")
      assert_generates("/products", {controller: "products", action: "index"})
      assert_generates("/line_items", 
                      {controller: "line_items", action: "create", product_id: 1}
                      {method: :post},
                      {product_id: 1}
      )
    end

参数extras用来传递附加请求参数的名称和值的请求（在前面代码的第三个断言中，这将是product_id=1）。
这些测试框架没有把作为字符串添加所生成的URL，而是测试这些已添加的值，这些值出现在散列类型参数extras中。
参数defaults用来指明HTTP方法。

#### assert_recognizes(options, path, extras={}, message=nil)
验证路由，返回一组给定路径的特定选项。
def test_recognizes
  # 检查默认index动作的get的生成
  assert_recognizes({controller: 'store', action: 'index'}, "/")
  # 检查路由到一个动作
  assert_recognizes({controller: 'products', action: 'index'}, "/products")
  # 使用一个参数来路由
  assert_recognizes(
    {controller: 'line_items', action: 'create', product_id: 1},
    {path: '/line_items', method: :post},
    {product_id: 1}
  )
end
参数path可指定路由，该路由是以请求HTTP动词为条件的。
作为方法assert_recognizes的第二个参数，可以传递散列对其进行测试，而不是字符串。
散列应该包含两个元素： path将包含输入的请求路径，method包含要使用的HTTP动词。

参数extras也包含了附加的URL参数，在前面代码的第三个断言中，使用参数extras来验证以product_id=1结尾的URL，产生的散列params将包含适当的值。

#### assert_routing(path, options, defaults={}, extras={}, message=nil)
结合前面两个断言，先验证路径生成的选项，接着核实选项生成的路径。

    def test_routing
      assert_routing('/', controller: 'store', action: 'index')
      assert_routing('/products', controller: 'products', action: 'index')
      assert_routing(
        {path: '/line_items', method: :post},
        {controller: 'line_items', action: 'create', product_id: 1},
        {},
        {product_id: 1}
      )
    end

重要的是，在选项散列中，要使用符号作为键，而字符串作为值。
如果不是这样，一旦比较这些从路由返回的选项，结果会是失败。

## 20.2 Processing of Requests 处理请求
In the previous section, we worked out how Action Dispatch routes an incoming request to the appropriate code in your application.
上一节探讨了行为调度是如何把外部请求路由到应用程序相应代码中。
Now let’s see what happens inside that code.
下面看看代码里面发生了什么。

### 20.2.1 Action Methods 动作方法
When a controller object processes a request, it looks for a public instance method with the same name as the incoming action.
当控制器对象处理请求时，该对象会寻找同名的公共实例方法作为输入动作。
If it finds one, that method is invoked.
如果找到，调用该方法。
If it doesn’t find one and the controller implements method_missing(), that method is called, passing in the action name as the first parameter and an empty argument list as the second.
如果没有找到，且控制器实现method_missing，那么调用这种方法，传递动作名作为第一个参数，空的参数列表作为第二个。
If no method can be called, the controller looks for a template named after the current controller and action.
如果没有方法可调用，那么该控制器寻找在当前控制器动作之后所命名的模板。
If found, this template is rendered directly.
如果找到，直接呈现该模板。
If none of these things happens, an AbstractController::ActionNotFound error is generated.
如果没有找到，则生成一个AbstractController::ActionNotFound错误。

### 20.2.2 Controller Environment 控制器环境
The controller sets up the environment for actions (and, by extension, for the views that they invoke).
控制器设置了动作及其调用视图（借助于扩展库）的环境。
Many of these methods provide direct access to information contained in the URL or request.
这些方法中的大多数提供了直接访问URL或请求中所包含的信息。
<kinder:note> 搞不清这一节的知识涉及到Rails程序哪个文件的。

#### action_name
The name of the action currently being processed.
当前正要处理的动作名称。

• 320

#### cookies
The cookies associated with the request.
请求相关联的甜饼。
Setting values into this object stores cookies on the browser when the response is sent.
发送响应时，设置这个对象的值存储在浏览器的甜饼。
Rails support for sessions is based on cookies.
Rails支持会话就是基于甜饼的。
We discuss sessions in Rails Sessions, on page 331.
后面331页会讨论会话。

#### headers
A hash of HTTP headers that will be used in the response.
HTTP头散列将被用于响应。
By default, Cache-Control is set to no-cache.
默认情况下，Cache-Control设置为no-cache。
<kinder:note> 怎么说到缓存来了？
You might want to set Content-Type headers for special-purpose applications.
对于特殊用途的应用程序，要设置好Content-Type标头。
Note that you shouldn’t set cookie values in the header directly—use the cookie API to do this.
注意，不应该直接在标头中设置甜饼的值——应该用甜饼API来做。

#### params
A hash-like object containing request parameters (along with pseudoparameters generated during routing).
一个类似散列的对象，包含着请求参数（和路由过程中产生的伪参数一起）。
It’s hash-like because you can index entries using either a symbol or a string—params[:id] and params['id'] return the same value.
之所以类似于散列，是因为可以使用符号或字符串条目进行索引——params[:id]和params['id']返回相同的值。
Idiomatic Rails applications use the symbol form.
习惯上Rails应用程序使用符号形式。

#### request
The incoming request object. 
输入请求对象。
It includes these attributes:
包含以下属性：
• request_method returns the request method, one of :delete, :get, :head, :post, or :put.
  request_method返回一个请求方法：:delete, :get, :head, :post, or :put。
• method returns the same value as request_method except for :head, which it returns as :get because these two are functionally equivalent from an application point of view.
  method和request_method返回相同的值，除了:head。之所以返回与get一样，是因为从应用程序的角度来看它们两个在功能上是相同的。
• delete?, get?, head?, post?, and put? return true or false based on the request method.
  delete?, get?, head?, post?和put?在request_method基础上返回true或false。
• xml_http_request? and xhr? return true if this request was issued by one of the Ajax helpers.
  如果任何一个Ajax辅助器发出了这个请求，则xml_http_request?和xhr?返回true。
Note that this parameter is independent of the method parameter.
注意，这个参数是独立于method参数的。

• url(), which returns the full URL used for the request.
  url(),它返回请求所使用的完整URL。
• protocol(), host(), port(), path(), and query_string(), which return components of the URL used for the request, based on the following pattern: protocol://host:port/path?query_string.
  protocol(), host(), port(), path()和query_string()返回用于请求的URL组成部分，它基于以下模式：protocol://host:port/path?query_string。
• domain(), which returns the last two components of the domain name of the request.
  domain()，返回请求域名中最后两个组成部分。
• host_with_port(), which is a host:port string for the request.
  host_with_port(),是对于请求的host:port字符串。

• 321

• port_string(), which is a :port string for the request if the port is not the default port (80 for HTTP, 443 for HTTPS).
  port_string()，如果该端口不是默认端口（对于HTTP协议是80,对于HTTPS协议是443），那么它是请求的:port字符串。
• ssl?(), which is true if this is an SSL request; in other words, the request was made with the HTTPS protocol.
  ssl?()。如果这是SSL请求（就是使用HTTPS协议请求），值为true。
• remote_ip(), which returns the remote IP address as a string.
  remote_ip(), 返回作为字符串的远程IP地址。
The string may have more than one address in it if the client is behind a proxy.
如果客户端处于代理之后，则该字符串可能有多于一个的地址。
• env(), the environment of the request. 
  env(),请求的环境。
You can use this to access values set by the browser, such as this:
<kinder:note> 可用它访问浏览器所设定的值，比如

    request.env['HTTP_ACCEPT_LANGUAGE']

• accepts(), which is an array with Mime::Type objects that represent the MIME types in the Accept header.
<kinder:note>   accepts()，是Mime::Type对象的数组，这些对象表示Accept头里的Mime类型。
• format(), which is computed based on the value of the Accept header, with Mime::HTML as a fallback.
<kinder:note>   format()，基于Accept头的值的计算，Mime::HTML是备件。
• content_type(), which is the MIME type for the request. 
  content_type(),请求的MIME类型。
This is useful for put and post requests.
对于put和post请求，这是很有用的。
• headers(), which is the complete set of HTTP headers.
  headers(), 一组完整的HTTP标头。
• body(), which is the request body as an I/O stream.
  body()，这是I/O流的请求主体。
• content_length(), which is the number of bytes purported to be in the body.
  content_length()，说明了主题内的字节数。

Rails leverages a gem named Rack to provide much of this functionality.
Rails充分利用名为Rack的软件包，为此提供了大量功能。
See the documentation of Rack::Request for full details.
完整细节参见Rack::Request的文档。

#### response
The response object, filled in during the handling of the request.
响应对象，在请求处理过程中填补空缺。
Normally, this object is managed for you by Rails.
通常这个对象是由Rails进行管理的。
As we’ll see when we look at callbacks in Callbacks, on page 337, we sometimes access the internals for specialized processing.
正如后面337页将看到的，有时会为特殊进程访问内部。

#### session
A hash-like object representing the current session data.
类似散列的对象，表示当前会话数据。
We describe this in Rails Sessions, on page 331.
后面331页会进行阐述。

In addition, a logger is available throughout Action Pack.
此外，日志器可用于整个Action Pack。

### 20.2.3 Responding to the User 响应用户
Part of the controller’s job is to respond to the user.
控制器工作的一部分是为了响应用户。
There are basically four ways of doing this.
响应用户有**四种基本方式**：

• 322

• The most common way is to render a template.
最常见的方式是呈现模板。
In terms of the MVC paradigm, the template is the view, taking information provided by the controller and using it to generate a response to the browser.
在MVC概念中，模板就是视图，由控制器提供的信息，用它来生成浏览器的相应。

• The controller can return a string directly to the browser without invoking a view.
控制器可以直接向浏览器返回字符串，无需调用视图。
This is fairly rare but can be used to send error notifications.
这是相当罕见的，但可以用来发送错误通知。

• The controller can return nothing to the browser.
控制器可以不向浏览器返回任何代码。
This is sometimes used when responding to an Ajax request.
在响应Ajax请求时，会用到这个方式。
In all cases, however, the controller returns a set of HTTP headers, because some kind of response is expected.
然而，所有情况下，之所以控制器返回一组HTTP标头，是因为期望得到某种响应。

• The controller can send other data to the client (something other than HTML).
控制器可以把其他数据（HTML之外的数据）发送到客户端中。
This is typically a download of some kind (perhaps a PDF document or a file’s contents).
通常这是某种形式的下载（可能是PDF文档或文件的内容）。

A controller always responds to the user exactly one time per request.
控制器总是仅响应一次用户的一个请求。
This means you should have just one call to a render(), redirect_to(), or send_xxx () method in the processing of any request.
这意味着，在处理任何请求时，只有一次调用render(), redirect_to,或send_xxx()方法的机会。
(A DoubleRenderError exception is thrown on the second render.) 
（第二次呈现时，会抛出DoubleRenderError异常。）

Because the controller must respond exactly once, it checks to see whether a response has been generated just before it finishes handling a request.
因为控制器必须只响应一次，所以在处理请求完成之前，它会检查是否已生成了回应。
If not, the controller looks for a template named after the controller and action and automatically renders it.
如果没有，那么控制器寻找在控制器的行为后所命名的模板，并且自动呈现到该模板。
This is the most common way that rendering takes place.
这是最常见的呈现方式。
You may have noticed that in most of the actions in our shopping cart tutorial we never explicitly rendered anything.
你可能已经注意到，在购物车教程的大多数动作中，从来没有明确地呈现到哪里。
Instead, our action methods set up the context for the view and return.
相当，动作方法建立起视图和返回的前后关系。
The controller notices that no rendering has taken place and automatically invokes the appropriate template.
控制器提示我们，没有任何呈现发生，并自动调用了相应的模板。

You can have multiple templates with the same name but with different extensions (for example, .html.erb, .xml.builder, and .js.coffee).
可以使用同名但不同扩展的多个模板，例如.html.erb, xml.builder, js.coffee。
If you don’t specify an extension in a render request, Rails assumes html.erb.
如果不指定呈现请求的扩展名，Rails默认html.erb模板。

### 20.2.4 Rendering Templates 呈现模板
A template is a file that defines the content of a response for our application.
模板是定义为应用程序响应内容的文件。
Rails supports three template formats out of the box: erb, which is embedded Ruby code (typically with HTML); builder, a more programmatic way of constructing XML content; and RJS, which generates JavaScript.
Rails支持三种模板格式：erb，嵌入ruby代码（通常与HTML一起使用）；builder，构建XML内容的更程序化的方式；RJS，生成JavaScript代码。
<kinder:note> 这一句是否过时了？应该介绍JSON了吧。
We’ll talk about the contents of these files starting in Section 21.1, Using Templates, on page 341.
我们将从后面341页的21.1节谈论这些文件的内容。

By convention, the template for action action of controller controller will be in the file app/views/controller/action.type.xxx (where type is the file type, such as html, atom, or js; and xxx is one of erb, builder, coffee or scss).
按照惯例，动作action和控制器controller的模板将在app/views/controller/action.type.xxx中（其中type是文件类型，如html, atom或js；xxx是erb, builder或rjs之一）
The app/views part of the name is the default.
名称中app/views的部分是默认的。
You can override this for an entire application by setting this:
对于整个程序，通过下面设置可以重新定义：
<kinder:note> 在哪个文件中定义？

• 323

    ActionController.prepend_view_path dir_path

The render() method is the heart of all rendering in Rails.
render()方法是Rails所有呈现方法的核心。
It takes a hash of options that tell it what to render and how to render it.
它需要选项的散列，散列告诉它该呈现什么、如何呈现。
It is tempting to write code in our controllers that looks like this:
在控制器中编写如下所示代码，

    # DO NOT DO THIS
    def update
      @user = User.find(params[:id])
      if @user.update(user_params)
        render action: show
      end
      render template: "fix_user_errors" # <kinder:note> 如果更新成功，这是第二次render
    end

It seems somehow natural that the act of calling render (and redirect_to) should somehow terminate the processing of an action.
调用render()（以及redirect_to）的行动应该以某种方式结束动作过程，这似乎是非常自然的。
This is not the case.
情况并非如此。
The previous code will generate an error (because render is called twice) in the case where update succeeds.
在更新成功的情况下，上面的代码会产生错误（因为调用了两次render）。

Let’s look at the render options used in the controller here (we’ll look separately at rendering in the view starting in Partial-Page Templates, on page 363):
下面看看在控制器中所使用的render选项（到后面363页专门看看视图中的呈现）

#### render()
With no overriding parameter, the render() method renders the default template for the current controller and action.
没有重新定义任何参数，render方法将呈现到当前控制器的动作的默认模板。
The following code will render the template app/views/blog/index.html.erb:
下面代码将呈现模板app/views/blog/index.html.erb。

    class BlogController < ApplicationController
      def index
        render
      end
    end

So will the following (as the default behavior of a controller is to call render() if the action doesn’t):
也有下面的（如果没有动作存在，则控制器默认调用render）：

    class BlogController < ApplicationController
      def index
      end
    end

And so will this (because the controller will call a template directly if no action method is defined):
还有下面的（因为如果没有定义任何动作方法，控制器直接调用模板）

    class BlogController < ApplicationController
    end

• 324

#### render(text: string)
Sends the given string to the client.
将给定的字符串发送到客户端。
No template interpretation or HTML escaping is performed.
没有执行模板解析或HTML转义。

    class HappyController < ApplicationController
      def index
        render(text: "Hello there!")
      end
    end

#### render(inline: string, [ type: "erb"|"builder"|"coffee"|"scss" ], [ locals: hash] )

Interprets string as the source to a template of the given type, rendering the results back to the client.
将作为代码的字符串解析成给定类型的模板，并把结果呈现到客户端。
You can use the :locals hash to set the values of local variables in the template.
可以使用:locals散列来设置模板的局部变量值。

The following code adds method_missing() to a controller if the application is running in development mode.
如果在开发模式下运行应用程序，那么下面的代码将method_missing添加到控制器。
If the controller is called with an invalid action, this renders an inline template to display the action’s name and a formatted version of the request parameters.
如果用无效动作调用控制器，那么将呈现到内联模板，以显示该动作名称和请求参数的格式化版本。

    class SomeController < ApplicationController
      if RAILS_ENV == "development"
        def method_missing(name, *args)
          render(inline: %{
            <h2>Unknown action: #{name}</h2>
            Here are the request parameters:<br/>
            <%= debug(params) %> 
          })
        end
      end
    end

#### render(action: action_name)
Renders the template for a given action in this controller.
呈现到在此控制器中给定动作的模板。
Sometimes folks use the :action form of render() when they should use redirects.
有时当应用重定向时，使用render的:action形式。
See the discussion starting in Redirects, on page 327, for why this is a bad idea.
但这是一个坏注意，详见后面327页的讨论。

    def display_cart
      if @cart.empty?
        render(action: :index)
      else
        # ...
      end
    end

Note that calling render(:action...) does not call the action method; it simply displays the template.
注意**调用render(:action...)并不调用动作方法，只是显示模板。**，
If the template needs instance variables, these must be set up by the method that calls the render() method.
如果模板需要实例变量，则这种调用render的方法必须设置它们。

• 325

Let’s repeat this, because this is a mistake that beginners often make:
再重复一次，因为这是初学者经常发生的错误。
calling render(:action...) does not invoke the action method.
调用render(:action...)不会调用动作方法。
It simply renders that action’s default template.
只会调用动作的默认模板。

#### render(template: name, [locals: hash] )
Renders a template and arranges for the resulting text to be sent back to the client.
呈现模板，并安排要送回客户端所产生的文本。
The :template value must contain both the controller and action parts of the new name, separated by a forward slash.
:template值必须包含控制器和动作的新名称部分，用正斜杠分隔。
The following code will render the template app/views/blog/short_list:
下面代码将呈现到模板app/views/blog/short_list：

    class BlogController < ApplicationController
      def index
        render(template: "blog/short_list")
      end
    end

#### render(file: path)
Renders a view that may be entirely outside of your application (perhaps one shared with another Rails application).
<kinder:note> 呈现一个完全在应用程序之外的视图（可能是另一个应用程序共享的视图）。
By default, the file is rendered without using the current layout.
<kinder:note> 默认情况下，file无需使用当前布局来呈现。
This can be overridden with layout: true.
<kinder:note> 这一点可以通过`layout: true`来覆盖。

#### render(partial: name, …)
Renders a partial template.
呈现局部模板。
We talk about partial templates in depth in Partial-Page Templates, on page 363.
后面363页会深入讨论局部模板。

#### render(nothing: true)
Returns nothing—sends an empty body to the browser.
返回无任何内容——将一个空的主体发送给浏览器。
#### render(xml: stuff)
Renders stuff as text, forcing the content type to be application/xml.
呈现文本形式的内容，强制使内容类型转为application/xml。

#### render(json: stuff, [callback: hash] )
Renders stuff as JSON, forcing the content type to be application/json.
呈现JSON形式的内容，强制使内容类型转为application/json。
Specifying :callback will cause the result to be wrapped in a call to the named callback function.
指定:callback将出现调用callback函数封装的结果。

#### render(:update) do |page| ... end
Renders the block as an RJS template, passing in the page object.
呈现RJS模板的代码块，传递到页面对象。

    render(:update) do |page|
      page[:cart].replace_html partial: 'cart', object: @cart
      page[:cart].visual_effect :blind_down if @cart.total_items == 1
    end

#### 参数
All forms of render() take optional :status, :layout, and :content_type parameters.
所有render()的形式都采用:status, :layout, :content_type参数。

##### :status
The :status parameter provides the value used in the status header in the HTTP response.
:status参数提供了在HTTP响应的状态标头中所使用的值。
It defaults to "200 OK".
默认为"200 OK"。
Do not use render() with a 3xx status to do redirects; Rails has a redirect() method for this purpose.
不要使用带重定向的3xx状态的render；Rails提供了用于此目的的重定向方法。

• 326

##### :layout
The :layout parameter determines whether the result of the rendering will be wrapped by a layout.
:layout参数确定是否使用布局封装呈现的结果。
(We first came across layouts in Section 8.2, Iteration C2: Adding a Page Layout, on page 96.
（前面96页8.2节已经见过布局。
We’ll look at them in depth starting in Section 21.6, Reducing Maintenance with Layouts and Partials, on page 358.) 
后面358页21.6节会渗入讨论）
If the parameter is false, no layout will be applied.
如果参数false，那么不会应用布局。
If set to nil or true, a layout will be applied only if there is one associated with the current action.
如果设置为nil或true，那么将仅当存在与当前动作相关的布局时，应用布局。
If the :layout parameter has a string as a value, it will be taken as the name of the layout to use when rendering.
如果:layout有字符串的值，则将它视为呈现时使用的布局名称。
A layout is never applied when the :nothing option is in effect.
:nothing选项生效时，不应用布局。

##### :content_type
The :content_type parameter lets you specify a value that will be passed to the browser in the Content-Type HTTP header.
:content_type参数指定一个值，以Content-Type HTTP标头方式将其传递到浏览器中。

Sometimes it is useful to be able to capture what would otherwise be sent to the browser in a string.
有时它能够获取并不是以字符串形式发送到浏览器的内容。

The render_to_string() method takes the same parameters as render() but returns the result of rendering as a string—the rendering is not stored in the response object and so will not be sent to the user unless you take some additional steps.
render_to_string方法与render采用了相同参数，但返回的结果是作为字符串呈现——这一呈现并不存储于响应对象，因此不会发送到用户，除非采取一些附加步骤。

Calling render_to_string does not count as a real render.
调用render_to_string不能算真正的呈现。
You can invoke the real render method later without getting a DoubleRender error.
可以调用真正的呈现方法，后面不会出现DoubleRender错误。

### 20.2.5 Sending Files and Other Data 发送文件和其他数据
We’ve looked at rendering templates and sending strings in the controller.
前面已经见过在控制器中呈现模板、发送字符串。
The third type of response is to send data (typically, but not necessarily, file contents) to the client.
第三种响应类型是向客户端发送数据（通常是文件内容，但也并非必须）。

#### send_data
Sends a string containing binary data to the client.
发送包含客户端二进制数据的字符串。

    send_data(data, options…)

Sends a data stream to the client.
将数据流发送到客户端。
Typically the browser will use a combination of the content type and the disposition, both set in the options, to determine what to do with this data.
通常，浏览器使用内容类型和内容处置的组合，它们在选项中设置，以确定这个数据的用途。

    def sales_graph
      png_data = Sales.plot_for(Date.today.month)
      send_data(png_data, type: "image/png", disposition: "inline")
    end

• 327

Options:
选项：

:disposition string
Suggests to the browser that the file should be displayed inline (option inline) or downloaded and saved (option attachment, the default).
建议浏览器内嵌（选项inline）或下载保存（选项attachment，默认）来显示文件。

:filename string
A suggestion to the browser of the default filename to use when saving this data.
建议当浏览器保存此数据时，使用的默认文件名。

:status string
The status code (defaults to "200 OK").
状态代码（默认为“200 OK”）

:type string
The content type, defaulting to application/octet-stream.
内容类型，默认值是application/octet-stream。（八进制数据流）

:url_based_filename boolean 
If true and :filename are not set, this option prevents Rails from providing the basename of the file in the Content-Disposition header. 
如果设置为true，而:filename没有设置，则阻止Rails提供在Content-Disposition标头中的文件基本名。
Specifying the basename of the file is necessary in order to make some browsers handle i18n filenames correctly.
指定基本名称是必要的，以便使一些浏览器正确处理国际化文件名。

#### send_file
Sends the contents of a file to the client.
向客户端发送文件内容。

    send_file(path, options…)

Sends the given file to the client.
向客户端发送指定文件。
The method sets the Content-Length, Content-Type, Content-Disposition, and Content-Transfer-Encoding headers.
该方法设置内容长度、内容类型、内容处置以及内容传输编码标头。

 Options:
选项：
:buffer_size number
The amount sent to the browser in each write if streaming is enabled (:stream is true).
<kinder:note> 如果启用流（steam: true），按每次写入方式将总量发送到浏览器

:disposition string
Suggests to the browser that the file should be displayed inline (option inline) or downloaded and saved (option attachment, the default).
建议浏览器内嵌（选项inline）或下载保存（选项attachment，默认）来显示文件。

:filename string
A suggestion to the browser of the default filename to use when saving the file.
建议当浏览器保存此数据时，使用的默认文件名。
If not set, defaults to the filename part of path.
如果没有设置，默认是路径的文件名称部分。

:status string

The status code (defaults to "200 OK").
状态代码（默认为“200 OK”）

:stream true or false 
If false, the entire file is read into server memory and sent to the client.
如果设置为false，就把整个文件读入服务器内存，并发送给客户端。
Otherwise, the file is read and written to the client in :buffer_size chunks.
否则，以:buffer_size段数把文件读取，并写入到客户端。

:type string
The content type, defaulting to application/octet-stream.
内容类型，默认值是application/octet-stream。（八进制数据流）

You can set additional headers for either `send_` method by using the headers attribute in the controller.
对于在控制器中使用标头属性的任何一个`send_` 方法，可设置附加标头：

    def send_secret_file
      send_file("/files/secret_list")
      headers["Content-Description"] = "Top secret"
    end

We show how to upload files starting in Section 21.4, Uploading Files to Rails Applications, on page 348.
后面348页21.4节开始展示如何上传文件。

• 328

### 20.2.6 Redirects 重定向
#### 概述
An HTTP redirect is sent from a server to a client in response to a request.
HTTP重定向是从服务器发送响应给客户的的请求。
In effect, it says, “I’m done processing this request, and you should go here to see the results.” 
The redirect response includes a URL that the client should try next along with some status information saying whether this redirection is permanent (status code 301) or temporary (307).
实际上它是说：“我不能处理这个请求，但这里有一些可处理的网址。”
重定向响应包含URL，客户端应该尝试寻找随后附加的一些状态信息，这些信息明确了重定向是永久性的（状态代码301）还是临时的（307）。
Redirects are sometimes used when web pages are reorganized; clients accessing pages in the old locations will get referred to the page’s new home.
有时用重定向来重组网页；客户端访问旧的位置的页面，将会引入到网站首页。
More commonly, Rails applications use redirects to pass the processing of a request off to some other action.
更常见的是，Rails应用程序使用重定向，目的是将请求过程传递到其他的一些动作中去。

#### 浏览器处理重定向
Redirects are handled behind the scenes by web browsers.
**网络浏览器的后台会处理重定向**。
Normally, the only way you’ll know that you’ve been redirected is a slight delay and the fact that the URL of the page you’re viewing will have changed from the one you requested.
通常要知道已经重定向的唯一方法是轻微延迟，而事实上正在浏览页面的URL已经从请求的那个发生了变化。
This last point is important—as far as the browser is concerned, a redirect from a server acts pretty much the same as having an end user enter the new destination URL manually.
最后这一点是重要的——对浏览器而言，服务器重定向的作用等同于最终用户手动输入新的URL目标。

Redirects turn out to be important when writing well-behaved web applications.
编写表现良好的web应用程序时，重定向结果是重要的。
Let’s look at a simple blogging application that supports comment posting.
看看简单的博客应用程序，它支持发表评论。
After a user has posted a comment, our application should redisplay the article, presumably with the new comment at the end.
在用户发表评论之后，该程序应该重新显示文章，可能在其后带有新的评论。

It’s tempting to code this using logic such as the following:
按照这个想法编写如下代码：

    class BlogController
      def display
        @article = Article.find(params[:id])
      end
      def add_comment
        @article = Article.find(params[:id])
        comment = Comment.new(params[:comment])
        @article.comments << comment
        if @article.save
          flash[:note] = "Thank you for your valuable comment"
        else
          flash[:note] = "We threw your worthless comment away"
        end
        # DON'T DO THIS
        render(action: 'display')
      end
    end

The intent here was clearly to display the article after a comment has been posted.
上面代码的目的是，在已经发布评论之后明确地显示该文章。
To do this, the developer ended the add_comment() method with a call to render(action:'display').
要实现这点，开发者借助调用render终止add_comment方法。
This renders the display view, showing the updated article to the end user.
这呈现到显示视图，向最终用户显示更新文章。
But think of this from the browser’s point of view.
但请从浏览器的视角考虑这一点。
It sends a URL ending in blog/add_comment and gets back an index listing.
它发出以blog/add_comment结尾的网址，并得到索引列表。
As far as the browser is concerned, the current URL is still the one that ends in  blog/add_comment.
就浏览器而言，当前URL仍然是以blog/add_comment结尾的。

• 329

This means that if the user hits Refresh or Reload (perhaps to see whether anyone else has posted a comment), the add_comment URL will be sent again to the application.
这意味着，如果用户单击刷新或者重新加载（也许为了看看其他人是否已经发表了评论），那么add_comment的URL将被再次发送给网站。
The user intended to refresh the display, but the application sees a request to add another comment.
虽然用户打算刷新显示，但应用程序收到了添加另一评论的请求。
In a blog application, this kind of unintentional double entry is inconvenient.
博客应用程序中，这种无意的两次切入是不便的。
In an online store, it can get expensive.
在在线商店里，它会变得代价昂贵。

In these circumstances, the correct way to show the added comment in the index listing is to redirect the browser to the display action.
在这种处境下，显示索引列表添加评论的正确方法是，将浏览器重定向到dispaly动作。
We do this using the Rails redirect_to() method.
具体做法是用Rails的redirect_to()方法。
If the user subsequently hits Refresh, it will simply reinvoke the display action and not add another comment.
如果用户随后单击刷新，那么会简单地重新调用display动作，并没有添加另一评论。

    def add_comment
      @article = Article.find(params[:id])
      comment = Comment.new(params[:comment])
      @article.comments << comment
      if @article.save
        flash[:note] = "Thank you for your valuable comment"
      else
      flash[:note] = "We threw your worthless comment away"
      end
    ➤ redirect_to(action: 'display')
    end

#### 三种形式
Rails has a simple yet powerful redirection mechanism.
Rails具有简单而强大的重定向机制。
It can redirect to an action in a given controller (passing parameters), to a URL (on or off the current server), or to the previous page.
它可以重定向到指定浏览器（传递参数）的动作、URL（打开或关闭当前服务器）或前一页。
Let’s look at these three forms in turn.
下面看看这三种形式。

#### redirect_to(action: ..., options…)

Sends a temporary redirection to the browser based on the values in the options hash.
基于选项散列值，将临时重定向发送到浏览器。
The target URL is generated using url_for(), so this form of redirect_to() has all the smarts of Rails routing code behind it.
使用url_for方法生成URL目标，所以这种重定向形式的背后具有Rails路由代码的智慧。

#### redirect_to(path)
Redirects to the given path.
重定向到给定路径。
If the path does not start with a protocol (such as http://), the protocol and port of the current request will be prepended.
如果路径开始没有协议（如http://），那么将添加当前请求的协议和端口。

This method does not perform any rewriting on the URL, so it should not be used to create paths that are intended to link to actions in the application (unless you generate the path using url_for or a named route URL generator).
这个方法没有重写任何URL，因此它也不应该用来创建以连接到程序动作为目标的路径（除非使用url_for方法或给路由命名的URL生成器生成该路径）。
  
• 330

    def save
      order = Order.new(params[:order])
      if order.save
        redirect_to action: "display"
      else
        session[:error_count] ||= 0
        session[:error_count] += 1
        if session[:error_count] < 4
          self.notice = "Please try again"
        else
          # Give up -- user is clearly struggling
          # 放弃，用户明显怀有恶意
          redirect_to("/help/order_entry.html")
        end
      end
    end

#### redirect_to(:back)
Redirects to the URL given by the HTTP_REFERER header in the current request.
重定向到当前请求的通过HTTP_REFERER标头的指定的URL中。

    def save_details
      unless params[:are_you_sure] == 'Y'
        redirect_to(:back)
      else
        ...
      end
    end

#### 永久化
By default all redirections are flagged as temporary (they will affect only the current request).
默认情况下，所有重定向都被标记为临时的（它们只会影响当前请求）。
When redirecting to a URL, it’s possible you might want to make the redirection permanent.
当重定向到URL时，可能你想让重定向永久化。
In that case, set the status in the response header accordingly.
那样，可相应地在响应标头中设置该状态。

    headers["Status"] = "301 Moved Permanently"
    redirect_to("http://my.new.home")

Because redirect methods send responses to the browser, the same rules apply as for the rendering methods—you can issue only one per request.
因为重定向方法将响应发送给浏览器，所以呈现方法同样的规则适用于它——每个请求只能发出一次。

So far, we have been looking at requests and responses in isolation.
到目前为止，我们一直在寻找采用隔离方式的请求和响应。
Rails also provides a number of mechanisms that span requests.
Rails也提供了许多持续请求的机制。

## 20.3 Objects and Operations That Span Requests 持续请求的对象和操作
### 多种机制
While the bulk of the state that persists across requests belongs in the database and is accessed via Active Record, some other bits of state have different life spans and need to be managed differently.
虽然大部分存留持续请求的状态属于数据库，且通过Active Record访问，但其他一些状态有不同的寿命跨度，需要不同的管理。
In the Depot application, while the Cart itself was stored in the database, knowledge of which cart is the current cart was managed by sessions.
在Depot程序，购物车本身是存储在数据库中的，用于了解哪个购物车是由会话管理的当前购物车。
Flash notices were used to communicate simple messages such as “Can’t delete the last user” to the next request after a redirect.
闪存警告用于将简单信息（如“无法删除最后一个用户”）传送到重定向之后的下一个请求。
And callbacks were used to extract locale data from the URLs themselves.
过滤器曾经用来提取URL本身的本地数据。

In this section, we will explore each of these mechanisms in turn.
在本节中将一次探讨这里的每一个机制。

• 331

### 20.3.1 Rails Sessions  Rails会话
A Rails session is a hash-like structure that persists across requests.
Rails会话是存留持续请求的类似于散列的结构。
Unlike raw cookies, sessions can hold any objects (as long as those objects can be marshaled), which makes them ideal for holding state information in web applications.
不同于原始的甜饼，会话可以容纳任何对象（只要可以序列化这些对象），这使它成为容纳web应用程序的状态信息的理想之选。
For example, in our store application, we used a session to hold the shopping cart object between requests.
比如，在store程序中，就使用了会话来保存请求之间的购物车对象。
The Cart object could be used in our application just like any other object.
应用程序中Cart对象可像其他对象那样使用。
But Rails arranged things such that the cart was saved at the end of handling each request and, more important, that the correct cart for an incoming request was restored when Rails started to handle that request.
但Rails不仅在处理每个请求结束后保存购物车，更重要的是，当Rails处理请求时会根据那个输入的请求重现出该请求需要的那个购物车。
Using sessions, we can pretend that our application stays around between requests.
使用会话，似乎程序继续保留这些请求。

marshal ↪ on page 48

#### 会话的存在形式
And that leads to an interesting question: exactly where does this data stay around between requests? 
One choice is for the server to send it down to the client as a cookie.
于是产生了一个有趣的问题：究竟这些请求之间的数据保存在何处呢？
一个选择是从服务器发送到客户端，将其作为甜饼保存下来。
This is the default for Rails 4.
这是Rails4的默认选择。
It places limitations on the size and increases the bandwidth but means that there is less for the server to manage and clean up.
它限制了数据大小，增加了带宽占用，也意味着少点服务器来管理和清理。
Note that the contents are (by default) encrypted, which means that users can neither see nor tamper with the contents.
注意加密甜饼的内容（默认），意味着用户既不能看到也不能干预这些内容。

The other option is to store the data on the server.
另一种选择是在服务器上存储数据。
There are two parts to this.
对此有两个部分。
 First, Rails has to keep track of sessions.
第一部分，Rails必须保持跟踪会话。
It does this by creating (by default) a 32-hex character key (which means there are 1632 possible combinations).
方法是创建32进制的字符串键（意味着存在16^32种组合）。
This key is called the session ID, and it’s effectively random.
这个字符串键就是所谓的会话id，事实上它是随机的。
Rails arranges to store this session ID as a cookie (with the key _session_id) on the user’s browser.
Rails负责把会话id作为甜饼（_session_id键）存储到用户浏览器上。
Because subsequent requests come into the application from this browser, Rails can recover the session ID.
因为后续请求从该浏览器到达应用程序，所以Rails可以回复会话id。

Second, Rails keeps a persistent store of session data on the server, indexed by the session ID.
第二部分，Rails在服务器上保持持久性存储会话数据，通过会话id进行索引。
When a request comes in, Rails looks up the data store using the session ID.
当请求来到时，Rails会使用会话id查找数据存储。
The data that it finds there is a serialized Ruby object.
它找到的数据是一个序列化的ruby对象。
It deserializes this and stores the result in the controller’s session attribute, where the data is available to our application code.
程序把这个序列化数据进行解析，在控制器的会话属性中存储解析的结果，这些数据对应用程序代码来说是可用的。
The application can add to and modify this data to its heart’s content.
程序可以把这个数据添加和修改到它的核心内容中。
When it finishes processing each request, Rails writes the session data back into the data store.
当完成每次请求的处理时，Rails把会话数据写回到数据存储中。
There it sits until the next request from this browser comes along.
这些数据在那里存储，直到该浏览器的下次请求到来。

#### 会话的内容
What should you store in a session? You can store anything you want, subject to a few restrictions and caveats.
应该在会话中存储什么？
可以存储任何东西，也有一些限制和需要注意的地方。

• There are some restrictions on what kinds of object you can store in a session.
会话中存储对象存在一些限制。
The details depend on the storage mechanism you choose (which we’ll look at shortly).
细节取决于选择的存储机制（下面会看到）。
In the general case, objects in a session must be serializable (using Ruby’s Marshal functions).
一般在会话中的对象必须是可序列化的（使用ruby的Marshal函数）。
This means, for example, that you cannot store an I/O object in a session.
这意味着，例如，不能在会话中存储I/O对象。

serialize ↪ on page 48

• 332 

------------------------------
------------------------------
David says: The Wonders of a Cookie-Based Session 基于甜饼的奇迹
The default Rails session store sounds like a crazy idea when you hear it at first.
默认的Rails会话存储，一开始听起来像是一个疯狂的想法。
 You’re going to actually store the values on the client?! 
实际上将值存储到客户端上吗？
But what if I want to store the nuclear launch codes in the session and I can’t have the client actually knowing them?
如果想要在会话中存储核弹发射代码，又不能让客户端真实地知道这些信息，可能吗？

Yes, the default store is not suitable for storing secrets you need to keep from the client.
是的，默认存储不适合存储需要那些保存到客户端的机密。
But that’s actually a valuable constraint that’ll lead you to avoid the perils of keeping complex objects that can go out of date in the session.
但实际上这是一种有价值的约束，避免了保存复杂对象的风险，这些对象在会话中可能会过时。
And the paper dragon of the nuclear launch codes is pretty much never a real, relevant concern.
至于核弹发射代码只是夸大其辞和虚无缥缈的事情。

Neither is the size constraint.
没有任何大小限制。
Cookies can be only about 4KB big, so you can’t stuff them with all sorts of malarkey.
甜饼只允许约4kb，所以不能容纳所有的东西。
That again fits the best practices of storing only references, like a cart_id, not the actual cart.
再说会话的最佳实践只适合存储引用，比如cart_id，而不是实际的购物车。

The key security concern you should be worried about is whether the client is actually able to change the session.
应该关心的关键安全问题是，在实际客户端中能否改变会话。
You want to ensure the integrity of the values that you put.
你要确保你放置的值的完整性。
It’d be no good if the client could change his cart_id from a 5 to an 8 and get someone else’s cart.
如果客户端可以将cart_id从5变为8，这样他能得到别人的购物车，将是一个灾难。
Thankfully, Rails protects you against exactly this case by signing the session and raising an exception that warns of the tampering if it doesn’t match.
值得庆幸的是，通过签名会话，Rails完全防范了这种风险；如果它不匹配，将抛出干预数据警告的异常。

The benefits you get back is that there is no load on the database from fetching and saving the session on every request, and there are no cleanup duties either.
这样做得到的回报是，在获取和保存每次请求的会话过程中，没有给数据库添加负载，也没有清理的工作。
If you keep your session on the filesystem or in the database, you’ll have to deal with how to clean up stale sessions, which is a real hassle.
如果把会话保存在文件系统或数据库中，那么必须面对如何清理过期会话的问题，那可真是麻烦。
No one likes to be on cleanup duty.
没人喜欢清理的工作。
The cookie-based sessions know how to clean up after themselves.
基于甜饼的会话知道如何清理自己。
What’s not to love about that?
有什么理由不喜欢它呢？

------------------------------
------------------------------

• If you store any Rails model objects in a session, you’ll have to add model declarations for them.
<kinder:note> 如果在会话中存储了Rails模型对象，必须在模型中声明它们。
This causes Rails to preload the model class so that its definition is available when Ruby comes to deserialize it from the session store.
<kinder:note> 这会让Rils预先装载模型类，以便ruby从会话存储中对它进行解析时，可以正确使用它的定义。
If the use of the session is restricted to just one controller, this declaration can go at the top of that controller.
<kinder:note> 如果会话的运用只限于一个控制器时，这个声明会到达那个控制器的顶部。

    class BlogController < ApplicationController
      model :user_preferences
    # . . .


However, if the session might get read by another controller (which is likely in any application with multiple controllers), you’ll probably want to add the declaration to application_controller.rb in app/controllers.
<kinder:note> 不过，如果会话为其他控制器（类似于程序中多个控制器）准备时，要在app/controllers的application_controller.rb文件声明。

• 333

• You probably don’t want to store massive objects in session data—put them in the database, and reference them from the session.
  不在会话中存储大量对象——这些对象可以放在数据库中，在会话中引用它们。
This is particularly true for cookie-based sessions, where the overall limit is 4KB.
准确说这是针对基于甜饼的会话，总额限定为4kb。

• You probably don’t want to store volatile objects in session data.
  不在会话数据中存储不稳定的对象。
For example, you might want to keep a tally of the number of articles in a blog and store that in the session for performance reasons.
比如在博客程序中，处于性能的考虑，可能想在会话中存储文章的总数。
But, if you do that, the count won’t get updated if some other user adds an article.
但如果真这么做，会导致其他用户添加文章时，数量不能得到更新。

It is tempting to store objects representing the currently logged-in user in session data.
在会话数据中存储表示当前登录用户的对象，是非常诱人的。
This might not be wise if your application needs to be able to invalidate users.
但如果程序需要无效用户的参与，这样做就不明智了。
Even if a user is disabled in the database, their session data will still reflect a valid status.
因为即使在数据库中没有该用户，会话数据仍将承认它的激活状态。
Store volatile data in the database, and reference it from the session instead.
应该在数据库中存储易变数据，并在会话中引用它。

• You probably don’t want to store critical information solely in session data.
可能不希望在会话数据中仅仅存储关键信息。
For example, if your application generates an order confirmation number in one request and stores it in session data so that it can be saved to the database when the next request is handled, you risk losing that number if the user deletes the cookie from their browser.
比如，如果应用程序在请求中生成确认订单数量，并把它存储到会话数据中，这样处理下一个请求时，可以把它保存到数据库中；但这时如果用户从浏览器中删除了这个甜饼，那么可能会失去这个数字。
Critical information needs to be in the database.
关键信息需要保存到数据库中。

#### 会话和关键信息
There’s one more caveat, and it’s a big one.
特别要留心。
If you store an object in session data, then the next time you come back to that browser, your application will end up retrieving that object.
如果在会话数据中存储对象，那么下次回到浏览器时，应用程序将最终索回该对象。
However, if in the meantime you’ve updated your application, the object in session data may not agree with the definition of that object’s class in your application, and the application will fail while processing the request.
可是如果在此期间已经更新了应用程序，那么在应用程序中，会话数据的对象可不会与该对象类的定义相一致；这样应用程序将无法处理该请求。

There are three options here.
这里存在三个选项。
One is to store the object in the database using conventional models and keep just the ID of the row in the session.
第一个选择是使用传统模型在数据库中存储对象，只是在会话中保持行记录id。
Model objects are far more forgiving of schema changes than the Ruby marshaling library.
与Ruyb序列库相比，模型对象对于数据库纲要改变更为宽松一点。
The second option is to manually delete all the session data stored on your server whenever you change the definition of a class stored in that data.
第二个选择是，一旦改变了在会话数据中所存储的类定义，就手动删除所有在服务器上存储的会话数据。
The third option is slightly more complex.
第三个选择稍微复杂些。
If you add a version number to your session keys and change that number whenever you update the stored data, you’ll only ever load data that corresponds with the current version of the application.
如果把版本号添加到会话密钥中，一旦更新存储的数据，将更改这个数字，那么将永远只能装载与应用程序当前版本对应的程序。
You can potentially version the classes whose objects are stored in the session and use the appropriate classes depending on the session keys associated with each request.
可以偷偷地为在会话中存储对象的类加上版本，并根据与每个请求关联的会话的键，使用适当的类。
This last idea can be a lot of work, so you’ll need to decide whether it’s worth the effort.
这最后一种需要大量工作，所以需要决定是否值得这么付出。

• 334

Because the session store is hash-like, you can save multiple objects in it, each with its own key.
因为会话存储类似于散列，所以可以让它保存多个对象，每个对象都有自己的键。
There is no need to also disable sessions for particular actions.
没有必要因为特定动作而禁用会话。
Because sessions are lazily loaded, simply don’t reference a session in any action in which you don’t need a session.
<kinder:note> 因为会话加载起来会较慢，所以如果你不需要会话，在动作上不引用会话就行了。

### 20.3.2 Session Storage 会话存储
Rails has a number of options when it comes to storing your session data.
涉及存储会话数据时，Rails提供了多个选项。
Each has good and bad points.
每一项都有优缺点。
We’ll start by listing the options and then compare them at the end.
先将选项列出，最后再做比较。
The session_store attribute of ActionController::Base determines the session storage mechanism—set this attribute to a class that implements the storage strategy.
ActionController::Base类的session_store属性决定了会话存储机制——将这个属性设置在实现存储策略的类。
This class must be defined in the ActiveSupport::Cache::Store module.
这个类必须定义在ActiveSupport::Cache::Store模块中。
You use symbols to name the session storage strategy; the symbol is converted into a CamelCase class name.
可以用符号来命名会话存储策略；符号被转化为骆驼命名法形式的类名。

#### session_store = :cookie_store
This is the default session storage mechanism used by Rails, starting with version 2.0.
从2.0起，这是Rails使用的默认会话存储机制。
This format represents objects in their marshaled form, which allows any serializable data to be stored in sessions but is limited to 4KB total.
这个格式代表以列集为形式的对象，允许在会话中保存任何可序列化的数据，但总量仅限4kb。
This is the option we used in the Depot application.
这是在Depot程序中使用的选项。

#### session_store = :active_record_store
You can use the activerecord-session_store gem [2] to store your session data in your application’s database using ActiveRecordStore.
可以使用activerecord-session_store软件包，在程序的数据库中使用ActiveRecordStore来存储会话数据。
[2]. https://github.com/rails/activerecord-session_store#installation

<kinder:note> 下面是4版的介绍，或许已经过期——要不怎么会在本版删除了呢。
可以使用Rake命令创建名为sessions表的迁移：

  $ rake db:sessions:create

运行rake db:migrate命令来创建实际的表。
如果观察一下迁移文件，那么将看到，Rails创建字段为session_id的索引，这是因为它是用来寻找会话数据的。
Rails还定义了update_at字段，这样Active Record会自动在会话表行记录中留下时间戳——后面将看到这为什么是个好主意。
</kinder:note> 

#### session_store = :drb_store
DRb is a protocol that allows Ruby processes to share objects over a network connection.
DRb是一个允许通过网络连接共享对象的Ruby进程协议。
Using the DRbStore database manager, Rails stores session data on a DRb server (which you manage outside the web application).
通过使用DRbStore数据库管理器，Rails在DRb服务器（位于程序外）中存储会话数据。
Multiple instances of your application, potentially running on distributed servers, can access the same DRb store.
运行在分布式服务器上的应用程序的多个实例，可以访问相同的DRb存储。
DRb uses Marshal to serialize objects.
DRb使用列集来序列化对象。

####　session_store = :mem_cache_store
memcached is a freely available, distributed object caching system maintained by Dormando.[3] 
memcached是一个可自由使用、分布式的对象缓存系统，由Dormando维护。
[3]. http://memcached.org/
memcached is more complex to use than the other alternatives and is probably interesting only if you are already using it for other reasons at your site.
memcached比其他选择更复杂、有趣，仅当你的网站有其他理由并且已经准备好了，才使用它。

• 335

#### session_store = :memory_store
This option stores the session data locally in the application’s memory.
这个选项将会话数据存储到本地的程序内存中。
Because no serialization is involved, any object can be stored in an in-memory session.
因为没有序列化，任何对象都可以存储在一个内存会话中。
As we’ll see in a minute, this generally is not a good idea for Rails applications.
正如前面看到的，这对于Rails程序来说通常不是一个好主意。

#### session_store = :file_store
Session data is stored in flat files.
会话数据存储在文本文件中。
It’s pretty much useless for Rails applications, because the contents must be strings.
对于Rails程序来说，这几乎毫无用处，因为其内容必须是字符串。
This mechanism supports the additional configuration options :prefix, :suffix, and :tmpdir.
这种机制支持附加的配置选项：:prefix, :suffix, 和 :tmpdir。

### 20.3.3 Comparing Session Storage Options 比较会话存储选项
With all these session options to choose from, which should you use in your application? 
面对所有这些可供选择的会话选项，应该在程序中使用哪些呢？
As always, the answer is “It depends.” 
与往常一样，答案是“看情况”。

There are few absolutes when it comes to performance, and everyone’s context is different.
当涉及性能时，不会有绝对正确的答案。
Your hardware, network latencies, database choices, and possibly even the weather will impact how all the components of session storage interact.
硬件、网络延迟、数据库甚至天气，都可能会影响所有会话存储组件如何交互。
Our best advice is to start with the simplest workable solution and then monitor it.
最好的建议是先从最简单可行的解决方案开始，然后监视方案成效。
If it starts to slow you down, find out why before jumping out of the frying pan.
如果它开始慢下来，就在宕机之前找出原因。

If you have a high-volume site, keeping the size of the session data small and going with cookie_store is the way to go.
如果是高流量网站，那么出路就是：会话数据尽量的小，使用cookie_store选项。
If we rule out memory store as being too simplistic, file store as too restrictive, and memcached as overkill, the server-side choices boil down to CookieStore, Active Record store, and DRb-based storage.
如果认为内存储存过于简单、文件存储过于限制、memcached存储过于强大，那么服务端可以选择甜饼存储、Active Record存储和基于DRb的存储。
Should you need to store more in a session than you can with cookies, we recommend you start with an Active Record solution.
如果需要在会话中存储比甜饼更多的内容，推荐从Active Record解决方案开始考虑。
If, as your application grows, you find this becoming a bottleneck, you can migrate to a DRb-based solution.
如果程序不断增长，渐渐成为瓶颈，那么可以迁移到以DRb为基础的解决方案。

### 20.3.4  Session Expiry and Cleanup 会话过期和清除
One problem with all the server-side session storage solutions is that each new session adds something to the session store.
所有服务器端会话存储解决方案的问题在于，每个新会话把一些东西添加到会话存储中。
This means you’ll eventually need to do some housekeeping or you’ll run out of server resources.
这意味着最终需要做一些清理工作，否则将耗尽服务器资源。
There’s another reason to tidy up sessions.
清理会话还有另一个原因。
Many applications don’t want a session to last forever.
许多应用程序不希望会话永远持续下去。
Once a user has logged in from a particular browser, the application might want to enforce a rule that the user stays logged in only as long as they are active; when they log out or some fixed time after they last use the application, their session should be terminated.
一旦用户从特定的浏览器登录了，那么应用程序就可能强制执行一种规则：只有活跃的用户才能保留登录状态；用户注销或用户最后使用程序之后的固定时间后，会话应终止。

• 336

You can sometimes achieve this effect by expiring the cookie holding the session ID.
让保留会话id的甜饼失效，可以达到这个效果。
However, this is open to end-user abuse.
不过，这等于开放给终端用户了。
Worse, it is hard to synchronize the expiry of a cookie on the browser with the tidying up of the session data on the server.
更糟的是，很难做到让浏览器甜饼过期和服务器会话数据清理之间保持同步。
We therefore suggest you expire sessions by simply removing their server-side session data.
因此建议，只要删除服务端的会话数据，会话就算过期。
Should a browser request subsequently arrive containing a session ID for data that has been deleted, the application will receive no session data; the session will effectively not be there.
如果浏览器随后达到的请求中包含会话id，但已删除了它的数据，那么应用程序将不会接收会话数据；会话已经不存在了。

Implementing this expiration depends on the storage mechanism being used.
实现这个过期取决于正在使用的存储机制。
For Active Record–based session storage, use the updated_at columns in the sessions table.
对于基于Active Record的会话存储，在会话表中使用updated_at字段。
You can delete all sessions that have not been modified in the last hour (ignoring daylight saving time changes) by having your sweeper task issue SQL such as this:
可以删除所有在最近时间内没有修改的会话（忽略对夏令时的更改），通过发出这样的SQL语句来清除：

    delete from sessions where now() - updated_at > 3600;

For DRb-based solutions, expiry takes place within the DRb server process.
对于基于DRb的解决方案，过期是DRb服务器进程内进行的。
You’ll probably want to record timestamps alongside the entries in the session data hash.
或许你想要会话数据散列的所有项一起记录时间戳。
You can run a separate thread (or even a separate process) that periodically deletes the entries in this hash.
可以运行独立线程（甚至是独立进程），定期删除该散列的所有项目。

In all cases, your application can help this process by calling reset_session() to delete sessions when they are no longer needed (for example, when a user logs out).
在所有情况下，不需要会话时，程序可以帮助这个进程通过调用reset_session方法来删除会话。

### 20.3.5 Flash: Communicating Between Actions 闪存：动作之间的通信
When we use redirect_to() to transfer control to another action, the browser generates a separate request to invoke that action.
当使用redirect_to将控制器转移到另外的动作时，浏览器会生成独立的请求来调用该行为。
That request will be handled by our application in a fresh instance of a controller object—instance variables that were set in the original action are not available to the code handling the redirected action.
应用程序借助于控制器对象-实例变量的新生实例，处理该请求；这些变量已经在原有动作中得到设置，但还没用于处理重定向的代码。
But sometimes we need to communicate between these two instances.
但有时需要在这两个实例之间进行通信。
We can do this using a facility called the flash.
使用闪存方法可以实现。

The flash is a temporary scratchpad for values.
闪存是临时的数值暂存器。
It is organized like a hash and stored in the session data, so you can store values associated with keys and later retrieve them.
它以散列方式进行组织，以会话数据的形式进行存储，因此，可以存储与键关联的值，并在后面找回它们。
It has one special property.
它有一个特别的属性。
By default, values stored into the flash during the processing of a request will be available during the processing of the immediately following request.
默认情况下，在处理请求期间存入的闪存值将用于处理紧接随后的请求。
Once that second request has been processed, those values are removed from the flash.
一旦处理了第二个请求，就从闪存中删除这些值。

• 337

Probably the most common use of the flash is to pass error and informational strings from one action to the next.
**最常见的使用闪存的方法**可能是，把错误和信息字符串从一个动作传递到下一个。
The intent here is that the first action notices some condition, creates a message describing that condition, and redirects to a separate action.
这里的目的是，第一个动作通告了一些条件、创建一条描述该条件的消息，并重定向另一个独立的行为。
By storing the message in the flash, the second action is able to access the message text and use it in a view.
通过存储闪存中的消息，第二个动作可以访问该消息文本，并在视图中使用它。
An example of such usage can be found in Iteration E1 on page 125.
这种用法在前面125页有实例。

It is sometimes convenient to use the flash as a way of passing messages into a template in the current action.
有时可以**简单地使用闪存**，方法是把消息传递到当前动作的模板中。
For example, our display() method might want to output a cheery banner if there isn’t another, more pressing note.
比如，方法display想要输出活泼的横幅广告，如果没有另一个横幅，它就会获得更多关注。
It doesn’t need that message to be passed to the next action—it’s for use in the current request only.
它不需要把消息传递给下一个动作——仅仅为了在当前请求中使用。
To do this, it could use flash.now, which updates the flash but does not add to the session data.
要实现的话，可以使用方法flash.now，它更新闪存，但不会添加到会话数据中。

While flash.now creates a transient flash entry, flash.keep does the opposite, making entries that are currently in the flash stick around for another request cycle.
方法flash.now创建了短暂的闪存项，但方法flash.keep则相反，它让当前处于闪存的项目停留着，用于另外的请求周期。
If you pass no parameters to flash.keep, then all the flash contents are preserved.
如果没有传递参数到方法flash.keep中，那么将保留所有的闪存内容。

Flashes can store more than just text messages—you can use them to pass all kinds of information between actions.
闪存可以存储比文本消息更多的信息——可以使用它们在各种动作之间传递各种不同的信息。
Obviously, for longer-term information you’d want to use the session (probably in conjunction with your database) to store the data, but the flash is great if you want to pass parameters from one request to the next.
显然，对于较长期保存的信息，要使用会话（可能要与数据库相连接）来存储数据，但想要从一个请求把参数传递到下一个，闪存是很重要的。

Because the flash data is stored in the session, all the usual rules apply.
因为闪存数据存储在会话中，所以适用于所有一般规则。
In particular, every object must be serializable.
特别是，每一个对象必须是可序列化的。
We strongly recommend passing only simple objects in the flash.
这里强烈建议，闪存中只传递一些简单的对象。

### 20.3.6 Callbacks 回调（过滤器）
Callbacks enable you to write code in your controllers that wrap the processing performed by actions—you can write a chunk of code once and have it be called before or after any number of actions in your controller (or your controller’s subclasses).
回调（过滤器）可以使你编写控制器代码，这些代码封装着由动作所完成的处理过程——可以一次编写一段代码，在控制器（括控制器的子类）中任何动作之前或之后调用它们。
This turns out to be a powerful facility.
这是一个强大的工具。
Using callbacks, we can implement authentication schemes, logging, response compression, and even response customization.
使用回调（过滤器）可以**实现身份验证方案，日志记录、响应压缩甚至相应定制**。

Rails supports three types of callbacks: before, after, and around.
Rails支持三种类型的回调过滤器：前置、后置和环绕。
Such callbacks are called just prior to and/or just after the execution of actions.
回调过滤器会在执行动作之前、之后以及前后被调用。
Depending on how you define them, they either run as methods inside the controller or are passed the controller object when they are run.
这取决于如何定义它们，它们要么作为控制器内方法运行，要么当运行它们时传递个控制器对象。
Either way, they get access to details of the request and response objects, along with the other controller attributes.
无论哪种方式，它们都能获得请求和相应对象的细节，以及其他控制器的属性。

• 338

### 20.3.7 Before and After Callbacks 前置和后置回调过滤器
#### 前置回调过滤器
As teir names suggest, before and after callbacks are invoked before or after an action.
正如从标题所看到的，在动作之前或之后调用前置或后置回调过滤器。
Rails maintains two chains of callbacks for each controller.
Rails为每个控制器维护两种回调过滤器链。
When a controller is about to run an action, it executes all the callbacks on the before chain.
控制器即将运行动作时，它执行在链前的所有前置回调过滤器。
It executes the action before running the callbacks on the after chain.
执行动作，然后运行链后的后置回调过滤器。

Callbacks can be passive, monitoring activity performed by a controller.
回调过滤器可以被触发，由控制器进行监视。
They can also take a more active part in request handling.
这样它们可以在处理请求时更主动参与。
If a before action callback returns false, then processing of the callback chain terminates, and the action is not run.
如果前置回调过滤器返回false，则这个回调过滤器链处理将终止，该动作也无法执行。
A callback may also render output or redirect requests, in which case the original action never gets invoked.
过滤器可能呈现输出或重定向请求，这样的情况下，将永远不会调用原来的动作。

We saw an example of using callbacks for authorization in the administration part of our store example in Section 14.3, Iteration I3: Limiting Access, on page 202.
前面202页14.3节关于商店示例的管理授权部分曾经使用了回调过滤器。
We defined an authorization method that redirected to a login screen if the current session didn’t have a logged-in user.
我们在那里定义了授权方法，如果当前会话没有用户登录，则重定向到登录页面。
We then made this method a before action callback for all the actions in the administration controller.
接着编写了前置回调过滤器的方法，以达到对管理控制器的所有动作进行监视。

Callback declarations also accept blocks and the names of classes.
回调过滤器声明页接收代码块和类名。
If a block is specified, it will be called with the current controller as a parameter.
如果指定了代码块，那么用当前控制器作为参数调用它。
If a class is given, its filter() class method will be called with the controller as a parameter.
如果是类名，则用控制器作为参数，调用其过滤器类方法。

By default, callbacks apply to all actions in a controller (and any subclasses of that controller).
默认情况下，回调过滤器适用于控制器的所有动作（以及该控制器的任何子类）。
You can modify this with the :only option, which takes one or more actions on which the callback is invoked, and the :except option, which lists actions to be excluded from callback.
可以使用选项:only修改它，参数是需要调用回调过滤的一个或多个动作；而选项:except，则列出回调过滤器需要排除的动作清单。

The before_action and after_action declarations append to the controller’s chain of callbacks.
before_action和after_action声明追加到控制器的回调过滤器链条。
Use the variants prepend_before_action() and prepend_after_action() to put callbacks at the front of the chain.
变种方法prepend_before_action和prepend_after_action可以把回调过滤器放到该链条的最前面。

#### 后置回调过滤器
After callbacks can be used to modify the outbound response, changing the headers and content if required.
后置回调过滤器可被用来修改已经发出的响应，如果需要可更改标头和内容。
Some applications use this technique to perform global replacements in the content generated by the controller’s templates (for example, by substituting a customer’s name for the string `<customer/>` in the response body).
有些程序使用这个技术来全局替代控制器模板生成的内容（例如，在响应主体中，用字符串`<customer/>`代替客户名。
Another use might be compressing the response if the user’s browser supports it.
另一个用途是，如果用户浏览器支持这种响应，那么压缩响应。

#### 环绕回调过滤器
Around callbacks wrap the execution of actions.
环绕回调过滤器封装了动作的执行。
You can write an around callback in two different styles.
可以采用**两种不同的风格**来编写环绕回调过滤器。
In the first, the callback is a single chunk of code.
第一种，回调过滤器是单独一段代码。
That code is called before the action is executed.
执行动作之前，调用该代码。
If the callback code invokes yield, the action is executed.
如果回调过滤器代码调用yield方法，就执行该动作。
When the action completes, the callback code continues executing.
动作执行完毕之后，继续执行回调过滤器的代码。

• 339 

Thus, the code before the yield is like a before action callback, and the code after the yield is the after action callback.
因此，该yield之前的代码像是前置回调过滤器，yield之后的代码像是后置回调过滤器。
If the callback code never invokes yield, the action is not run—this is the same as having a before action callback return false.
如果该过滤器代码从未调用yield，则这个动作不会运行——和前置回调过滤器返回false一样。

The benefit of around callbacks is that they can retain context across the invocation of the action.
环绕回调过滤器的好处是可以横跨动作调用、保持上下文环境。
As well as passing around_action the name of a method, you can pass it a block or a filter class.
除了可以给环绕回调过滤器传递方法名，还可传入代码块或过滤器类。
If you use a block as a callback, it will be passed two parameters: the controller object and a proxy for the action.
如果使用代码块作为回调过滤器，那它会传递两个参数：控制器对象和一个动作的代理。
Use call() on this second parameter to invoke the original action.
在第二个参数上使用call()可调用原有动作。

A second form allows you to pass an object as a callback.
第二种，是传入对象作为回调过滤器。
This object should implement a method called filter().
这个对象应该实现一种名字为filter()的方法。
This method will be passed the controller object.
该方法将被传入控制器对象。
It yields to invoke the action.
它会调用动作。

Like before and after callbacks, around callbacks take :only and :except parameters.
就像前置和后置回调过滤器，环绕回调过滤器也接受:only和:except参数。
Around callbacks are (by default) added to the callback chain differently: the first around action callback added executes first.
默认情况下，环绕回调过滤器以不同于前两者的方式添加到回调过滤链中：先添加的环绕过滤器先执行。
Subsequently added around callbacks will be nested within existing around callbacks.
随后添加的环绕回调过滤器将被嵌套到现有的环绕回调过滤器的里面。

### 20.3.8 Callback Inheritance 回调过滤器的继承
If you subclass a controller containing callbacks, the callbacks will be run on the child objects as well as in the parent.
如果包含回调过滤器的控制器有子类，则回调过滤器将在父对象和子对象上运行。
However, callbacks defined in the children will not run in the parent.
不过，定义在子类的回调过滤器不能在父类上运行。

If you don’t want a particular callback to run in a child controller, you can override the default processing with the skip_before_action and skip_after_action declarations.
如果你不想特定的回调过滤器在子类控制器上运行，可以用skip_before_action和skip_after_action声明来重写默认处理过程。
These accept the :only and :except parameters.
它们接收:only和:except参数。

You can use skip_action to skip any action callback (before, after, and around).
可以使用方法skip_action来屏蔽任何回调过滤器（包括前置、后置、环绕回调控制器）。
However, it works only for callbacks that were specified as the (symbol) name of a method.
不过，只有具体指定为（符号）方法名的过滤器，才能实现这一点。
We made use of skip_before_action in Section 14.3, Iteration I3: Limiting Access, on page 202.
前面202页14.3节我们已经用了skip_before_action。

• 340

## What We Just Did 本章小结
We learned how Action Dispatch and Action Controller cooperate to enable our server to respond to requests.
本章介绍了动作调用和动作控制器是如何合作使服务器响应请求的。
The importance of this can’t be emphasized enough.
这一点很重要，但总是没有被认真对待。
In nearly every application, this is the primary place where the creativity of your application is expressed.
在几乎所有程序中，这是程序创造力表现的主要地方。
While Active Record and Action View are hardly passive, our routes and our controllers are where the action is.
活动记录和动作视图几乎从不被动，而路由和控制器正是动作的所在。

We started this chapter by covering the concept of REST, which was the inspiration for the way in which Rails approaches the routing of requests.
本章开始时涵盖了REST的概念，这是Rails进行路由请求的灵感所在。
We saw how this provided seven basic actions as a starting point and how to add more actions.
我们看到了这提供了作为起点的七种基本动作，还允许添加更多动作。
We also saw how to select a data representation (for example, JSON or XML).
还看到了如何选择数据来表述（比如JSON或XML）。
And we covered how to test routes.
并且讨论了测试路由。
<kinder:note> 本版没有测试路由一节了！等一下补上吧。

We then covered the environment that Action Controller provides for your actions, as well as the methods it provides for rendering and redirecting.
接下来讨论了环境，包括动作控制器为动作而提供的，方法为呈现和重定向提供的。
Finally, we covered sessions, flash, and callbacks, each of which is available
for use in your application’s controllers.
最后还介绍了会话、闪存和回调过滤器，每一个都可在程序的过滤器用到。

Along the way, we showed how these concepts were used in the Depot application.
在这过程中，还展现了这些概念在Depot程序中如何应用。

Now that you have seen each in use and have been exposed to the theory behind each, how you combine and use these concepts is limited only by your own creativity.
现在你已经看到每个概念的应用和每个概念背后的理论，如何组合、使用这些概念就看你自己的创造力了。

In the next chapter, we will cover the remaining component of Action Pack, namely, Action View, which handles the rendering of results.
在下一章，将涵盖动作包装的其他组件，即动作视图，它将处理结果的呈现。

# CHAPTER 21 Action View  动作视图
## In this chapter, we’ll see
• templates,
  模板，
• forms including fields and uploading files,
  表单：字段和文件上传
• helpers, and
  辅助器
• layouts and partials.
  布局和局部模板

We’ve seen how the routing component determines which controller to use and how the controller chooses an action.
前面已经解释了路由组件如何确定要使用的控制器，控制器如何选择动作。
We’ve also seen how the controller and action between them decide what to render to the user.
还知道了该控制器及其动作如何为用户决定呈现什么。
Normally that rendering takes place at the end of the action, and typically it involves a template.
呈现过程发生在动作结束部分，通常都会调用模板。
That’s what this chapter is all about.
这是本章要探讨的全部内容。

Action View encapsulates all the functionality needed to render templates, most commonly generating HTML, XML, or JavaScript back to the user.
动作视图模块封装了所有要呈现模板所需要的功能，这些功能主要是生成HTML XML
JavaScript，并返回给客户端。
As its name suggests, Action View is the view part of our MVC trilogy.
顾名思义，动作视图模块是MVC模式中的视图部分。

In this chapter, we will start with templates, for which Rails provides a range of options.
本章首先介绍模板，Rails为其提供了大量选项。
We will then cover a number of ways in which users provide input: forms, file uploads, and links.
然后阐述一系列不同的输入类型：表单、文件上传和连接，
We will complete this chapter by looking at a number of ways to reduce maintenance using helpers, layouts, and partials.
最后解释一些减少维护成本的方法，如辅助器、布局和局部模板。

## 21.1 Using Templates 使用模板
When you write a view, you’re writing a template: something that will get expanded to generate the final result.
编写视图其实就是编写模板：它被扩充以后才能成为最终的结果。
To understand how these templates work, we need to look at three areas.
为了理解模板怎么工作，需要学习下面的内容：

• Where the templates go
  模板的存放位置。
• The environment they run in
  模板运行的环境。
• What goes inside them
  模板包含的内容。

### 21.1.1  Where Templates Go 模板存放的位置
The render() method expects to find templates in the app/views directory of the current application.
render方法期望在当前程序的app/views目录下找到模板。
Within this directory, the convention is to have a separate subdirectory for the views of each controller.
在目录下，按惯例是每个控制器的视图都有独立的子目录。
Our Depot application, for instance, includes products and store controllers.
比如，Depot程序包含了products和store控制器。
As a result, our application has templates in app/views/products and app/views/store.
于是，模板就放在app/views/products和app/views/store里。
Each directory typically contains templates named after the actions in the corresponding controller.
通常用相应的控制器动作名称来命名每个目录里的模板。

• 342

You can also have templates that aren’t named after actions.
**也可以不按动作名称来命名模板**。
You render such templates from the controller using calls such as these:
对于这样的模板，应该在控制器中这样调用：

    render(action: 'fake_action_name')
    render(template: 'controller/name')
    render(file: 'dir/template')

The last of these allows you to store templates anywhere on your filesystem.
最后一个调用表明，可以把模板存放在文件系统的任何位置。
This is useful if you want to share templates across applications.
如果想在程序之间共享模板，这样做就很有用了。

### 21.1.2 The Template Environment 模板的运行环境
Templates contain a mixture of fixed text and code.
模板是由固定文本和代码混合而成的。
The code in the template adds dynamic content to the response.
模板代码将动态内容添加到响应中。
That code runs in an environment that gives it access to the information set up by the controller.
运行代码的环境使得代码可访问控制器所设置的信息。

• All instance variables of the controller are also available in the template.
  模板中可以使用控制器的所有实例变量。
This is how actions communicate data to the templates.
这是动作向模板传递数据的方式。
• The controller object’s flash, headers, logger, params, request, response, and session are available as accessor methods in the view.
  视图中可以把控制器对象的方法flash, headers, logger, params, request, response和session用作accessor方法。
Apart from the flash, view code probably should not use these directly, because the responsibility for handling them should rest with the controller.
不过，除了flash方法之外，视图代码通常不应该直接使用这些方法，因为处理它们的责任在控制器。
However, we do find this useful when debugging.
然而，在调试时，使用这些方法还是很有用的。
For example, the following html.erb template uses the debug() method to display the contents of the session, the details of the parameters, and the current response:
比如，下面的html.erb模板使用debug方法来显示会话内容、参数的细节和当前响应：

    <h4>Session</h4> <%= debug(session) %>
    <h4>Params</h4> <%= debug(params) %>
    <h4>Response</h4> <%= debug(response) %>

• The current controller object is accessible using the attribute named controller. 
  使用属性名controller可以访问当前控制器对象。
This allows the template to call any public method in the controller (including the methods in ActionController::Base).
这使得模板可以调用该控制器的所有公共方法（包括ActionController::Base里的方法）。
• The path to the base directory of the templates is stored in the attribute base_path.
  属性base_path存储着模板的基本目录路径。

### 21.1.3 What Goes in a Template 模板包含的内容
Out of the box, Rails supports four types of templates.
默认情况下，Rails支持四种模板类型。
• Builder templates use the Builder library to construct XML responses.
  Builder模板使用Builder库来构建XML响应。
We talk more about Builder in Section 24.1, Generating XML with Builder, on page 393.
后面393页24.1节将更详细地探讨Builder。

• 343

• CoffeeScript templates create JavaScript, which can change both the presentation and the behavior of your content in the browser.
<kinder:note> CoffeeScript模板创建JavaScript，可以改变浏览器中内容的表述和表现。
• ERB templates are a mixture of content and embedded Ruby.
  ERB模板是内容和内嵌ruby代码的混合体。
They are typically used to generate HTML pages.
通常用来生成HTML页面。
We talk more about ERB in Section 24.2, Generating HTML with ERB, on page 395.
后面395页24.2会进行更详细的探讨。

• SCSS templates create CSS stylesheets to control the presentation of your content in the browser.
<kinder:note>   SCSS模板创建CSS样式表，控制内容在浏览器的表述。

By far, the one that you will be using the most will be ERB.
现在为止用得最多的模板还是ERB。
In fact, you made extensive use of ERB templates in developing the Depot application.
事实上，开发Depot程序时大规模运用了ERB模板。

So far in this chapter, we have focused on producing output.
本章讲到现在，重点是构建输出内容。
In Chapter 20, Action Dispatch and Action Controller, on page 309, we focused on processing input.
而前面309页20章的重点是处理输入。
In a well-designed application, these two are not unrelated: the output we produce contains forms, links, and buttons that guide the end user to producing the next set of inputs.
在一个设计优良的程序里，输入和输出不是毫不相干的：程序的输出包含了表单、链接和按钮，同时它们也引导了用户下一步的输入操作。
As you might expect by now, Rails provides a considerable amount of help in this area too.
正如期待的那样，这里领域里Rails提供了相当多的帮助。

## 21.2 Generating Forms 生成表单
HTML provides a number of elements, attributes, and attribute values that control how input is gathered.
HTML提供了许多元素、属性和值，它们控制了怎样采集输入。
You certainly could hand-code your form directly into the template, but there really is no need to do that.
虽然可以在模板里强行编写表单代码，但实现了没有必要。

In this section, we will cover a number of helpers that Rails provides that assist with this process.
本节将介绍一些Rails提供的辅助器，用来辅助生成表单。
In Section 21.5, Using Helpers, on page 351, we will show you how you can create your own helpers.
在后面351页21.5节将展示怎样创建自己的辅助器。

HTML provides a number of ways to collect data in forms.
HTML提供了不少从表单采集数据的方法。
A few of the more common means are shown in Figure 58, Some of the common ways to enter data into forms, on page 345.
下面345页的表格58展示了几个比较常用的方法。
Note that the form itself is not representative of any sort of typical use; in general, you will use only a subset of these methods to collect data.
注意，这些表单自身不是任何典型使用的类别的代表；通常，只有用到其中一部分方法来收集数据。

Let’s look at the template that was used to produce that form:
下面来看看生成这个表单的模板文件：

    Download rails40/views/app/views/form/input.html.erb
    01  <%= form_for(:model) do |form| %>
    02    <p> <!-- 单行输入框 -->
    03      <%= form.label :input %>
    04      <%= form.text_field :input, :placeholder => 'Enter text here...' %>
    05    </p>
    06    <p> <!-- 多行输入框 -->
    07      <%= form.label :address, :style => 'float: left' %>
    08      <%= form.text_area :address, :rows => 3, :cols => 40 %>
    09    </p>
    10    <p> <!-- 单选按钮 -->
    11      <%= form.label :color %>:
    12      <%= form.radio_button :color, 'red' %>
    13      <%= form.label :red %>
    14      <%= form.radio_button :color, 'yellow' %>
    15      <%= form.label :yellow %>
    16      <%= form.radio_button :color, 'green' %>
    17      <%= form.label :green %>
    18    </p>
    19
    20    <p> <!-- 多选按钮 -->
    21      <%= form.label 'condiment' %>:
    22      <%= form.check_box :ketchup %>
    23      <%= form.label :ketchup %>
    24      <%= form.check_box :mustard %>
    25      <%= form.label :mustard %>
    26      <%= form.check_box :mayonnaise %>
    27      <%= form.label :mayonnaise %>
    28    </p>
    29
    30    <p> <!-- 下拉列表 -->
    31      <%= form.label :priority %>:
    32      <%= form.select :priority, (1..10) %>
    33    </p>
    34
    35    <p> <!-- 日期下拉列表 -->
    36      <%= form.label :start %>:
    37      <%= form.date_select :start %>
    38    </p>
    39
    40    <p> <!-- 时间下拉列表-->
    41      <%= form.label :alarm %>:
    42      <%= form.time_select :alarm %>
    43    </p>
    44  <% end %>

• 344

In that template, you will see a number of labels, such as the one on line 3.
在这个模板里，可以到看到使用了若干标签，例如第3行。
You use labels to associate text with an input field for a specified attribute.
使用标签可将文本内容和特定属性的输入框关联起来。
The text of the label will default to the attribute name unless you specify it explicitly.
如果不设定，标签的文本将默认设置为对应的属性名称。

You use the text_field() and text_area() helpers (on lines 4 and 8, respectively) to gather single-line and multiline input fields.
辅助方法text_field和text_area（第4行和第8行）用来采集单行或多行输入框。
You may specify a placeholder, which will be displayed inside the field until the user provides a value.
<kinder:note> 可以指定占位符，用户输入数据之前输入框会显示着它。
Not every browser supports this function, but those that don’t simply will display an empty box.
不是所有浏览器都支持这个功能，但不支持的会只显示一个空框。
Since this will degrade gracefully, there is no need for you to design to the least common denominator—make use of this feature, because those who can see it will benefit from it immediately.
由于在输入框中能不能显示占位符对用户的影响微乎其微，所以没有必要太纠结于这个问题，放心使用这个特性就好了。

• 345

Figure 58—Some of the common ways to enter data into forms
图表58 —— 表单中输入数据的几种常见方式

Placeholders are one of the many small “fit and finish” features provided with HTML5, and once again, Rails is ready even if the browser your users have installed is not.
占位符是HTML5所提供的诸多小“贴身成品”的特性之一；还是那句话，Rails已经为支持新特性做好了准备，即便用户安装的浏览器还没准备好。
You can use the search_field(), telephone_field(), url_field(), email_field(), number_field(), and range_field() helpers to prompt for a specific type of input.
使用辅助方法search_field, telephone_field, url_field, email_field, number_field和range_field，可对特殊类型的输入进行提示。
How the browser will make use of this information varies.
各个浏览器怎么利用这些信息，是很不同的。
Some may display the field slightly differently in order to more clearly identify its function.
有些浏览器会出现不同的显示效果，以便更清楚地展现它的功能。
Safari on Mac, for example, will display search fields with rounded corners and will insert a little x for clearing the field once data entry begins.
例如，Mac的Safari，浏览器将显示成圆角效果，并插入一个小x，让用户可以在输入时清空输入框。
Some may provide added validation.
某些浏览器会提供附加的验证功能。
For example, Opera will validate URL fields prior to submission.
比如，Opera会验证URL的输入再提交。
The iPad will even adjust the virtual onscreen keyboard to provide ready access to characters such as the @ sign when entering an email address.
iPad甚至会针对邮件地址输入框而自动改变虚拟键盘的布局，将@之类的字符列出。

Although the support for these functions varies by browser, those that don’t provide extra support for these functions simply display a plain, unadorned input box.
对于这些功能的支持，虽然不同的浏览器不尽相同，但那些不提供额外支持的浏览器并不会受到什么影响，它们显示未加修饰的普通输入框。
Once again, nothing is gained by waiting.
机会留给有准备的人。
If you have an input field that’s expected to contain an email address, don’t simply use text_field()—go ahead and start using email_field() now.
如果输入框用来接收邮件地址，那就不要单纯使用text_field，往前一步，使用email_field吧。


Lines 12, 22, and 32 demonstrate three different ways to provide a constrained set of options.
第12 22 32行说明了提供一组限制选项的三种不同形式。
Although the display may vary a bit from browser to browser, these approaches are all well supported across all browsers.
虽然显示结果可能因为浏览器而不同，但所有浏览器都能很好地支持这些功能。
The select() method is particularly flexible—it can be passed a simple Enumeration as shown here, an array of pairs of name-value pairs, or a Hash.
select方法非常灵活——可以传入简单的列集，比如这里显示的，也可以传入键值对数组，或者散列。

• 346 

A number of form options helpers[1] are available to produce such lists from various sources, including the database.
利用不同的数据源，包括数据库，大量的表单选项辅助器生成这样的表单。
[1].http://api.rubyonrails.org/classes/ActionView/Helpers/FormOptionsHelper.html

Finally, lines 37 and 42 show prompts for a date and time, respectively.
最后， 37和42行分别列举了日期和时间的提示。

As you might expect by now, Rails provides plenty of options here too.[2] 
正如现在期待的那样，Rils也提供大量的选项。
[2].http://api.rubyonrails.org/classes/ActionView/Helpers/DateHelper.html
Not shown in this example are hidden_field() and password_field().
这个例子没有展示hidden_field和password_field。
A hidden field is not displayed at all, but the value is passed back to the server.
虽然隐藏输入框完全不会显示，但它的值会传送到服务器。
This may be useful as an alternative to storing transient data in sessions, enabling data from one request to be passed onto the next.
这可以作为在会话中存储瞬态数据的一种方式，使请求数据传送到下一个。
Password fields are displayed, but the text entered in them is obscured.
密码框虽然显示出来，但具体内容会被隐藏起来。

This is more than an adequate starter set for most needs.
对于大多数初学者来说，这些内容已经可以满足大部分需求了。
Should you find that you have additional needs, you are quite likely to find a helper or gem is already available for you.
如果还有其他需求，可以去找一些可以直接使用的辅助器或软件包。
A good place to start is with the Rails Guides.3 
可以从Rails指南开始。
Meanwhile, let’s explore how the data forms submit is processed.
同时，看看怎么处理数据表单的提交。
[3].http://guides.rubyonrails.org/form_helpers.html

## 21.3 Processing Forms 处理表单
In the following figure we can see how the various attributes in the model pass through the controller to the view, on to the HTML page, and back again into the model.
在下面的图表上，可以看到模型的各种属性，它们从控制器传到视图中，再传到HTML页面，再次返回模型。
The model object has attributes such as name, country, and password.
模型对象拥有若干属性，如name country password。
The template uses helper methods to construct an HTML form to let the user edit the data in the model.
模板使用辅助器来创建HTML表单，这样用户可以编辑模型的数据。
Note how the form fields are named.
注意表单框是怎么命名的。
The country attribute, for example, maps to an HTML input field with the name user[country].
比如，属性country对应于user[country]命名的HTML输入框。

When the user submits the form, the raw POST data is sent back to our application.
用户提交表单时，原始的POST数据返回给应用程序。
Rails extracts the fields from the form and constructs the params hash.
Rails提取表单框并构建params散列。

Simple values (such as the id field, extracted by routing from the form action) are stored directly in the hash.
它只是将值（比如id字段，是从表单动作的路由中提取出来的）直接存入散列中。
But, if a parameter name has brackets in it, Rails assumes that it is part of more structured data and constructs a hash to hold the values.
但是，如果参数名含有方括号的话，Rails会认为它是更复杂数据的一部分，并构建散列来存储它。
Inside this hash, the string inside the brackets acts as the key.
在这个散列内，方括号里的字符串将作为键。
This process can repeat if a parameter name has multiple sets of brackets in it.
当参数本身具有多组方括号时，这一过程会重复下去。

    Form Parameters 表单参数    Params
    id=123                      { id: "123" }
    user[name]=Dave             { user: { name: "Dave" }}
    user[address][city]=Wien    { user: { address: { city: "Wien" }}}

• 347

    +--(1)-----------------+
    | myapp_controller.rb  |
    |   def edit           |
    | end                  |
    +----------------------+
    +--(2)--------------------------------------------------+
    | edit.html.erb                                         |
    | <% form_for :user,                                    |
    | :url => { :action => 'save', :id => @user } do |f| %> |
    |   ...                                                 |
    | <% end %>                                             |
    +----------------------------------------------------- -+
    +--(3)-----------------------------------+           [1]. The application receives a request to edit a user.
    | <form action="/myapp/save/1234">       |           程序接收一个编辑user的请求
    |   <input name="user[name]" ... >       |           It reads the data into a new User model object.
    |   <input name="user[country]" ... >    |           将数据读入一个新的User模型对象中。
    |   <input name="user[password]" ... >   |           [2]. The edit.html.erb template is called.
    |   ...                                  |           调用edit.html.erb模板。
    | </form>                                |           It uses the information in the user object to generate...
    +----------------------------------------+           使用user对象的信息来生成表单。
    +--(4)-------------------------+                     [3]. the HTML is sent to the browser.
    | @params = {                  |                     HTML被发送到浏览器。
    |   :id => 1234,               |                      When the response is received...
    |   :user => {                 |                     收到请求时，
    |     :name => " ... ",        |                     [4]. the parameters are extracted into a nested hash.
    |     :country => " ... ",     |                     参数被提取为嵌套散列。
    |     :password => " ... " }   |                     [5]. The save action uses the and update it.
    |   }                          |                     使用save动作并更新对象。
    +------------------------------+
    +--(5)----------------------------------------+
    | def save                                    |
    |   if user.update_attributes(params[:user])  |
    |     ...                                     |
    |   end                                       |
    | end                                         |
    +---------------------------------------------+
    Figure 59—Models, controllers, and views work together.
    图表59, 模型控制器和视图协同工作

In the final part of the integrated whole, model objects can accept new attribute values from hashes, which allows us to say this:
在整个集成的最后部分，模型对象和接收散列中新的属性值，使用下面的语句：

    user.update(user_params)

Rails integration goes deeper than this.
Rails的集成要比这个更深入。
Looking at the .html.erb file in the preceding figure, we can see that the template uses a set of helper methods to create the form’s HTML; these are methods such as form_for() and text_field().
看看上面图表的.htm.erb文件，可以发现模板使用一系列辅助器（如form_for和text_field），来创建表单的HTML内容。

Before moving on, it is worth noting that params may be used for more than simple text.
在继续学习之前，需要提醒一下：变量params不仅可以作为简单文本来用。
Entire files can be uploaded.
它还可以用来上传整个文件。
We’ll cover that next.
下面对此进行介绍。

• 348

## 21.4 Uploading Files to Rails Applications 上传文件到Rails程序
Your application may allow users to upload files.
应用程序可能会允许用户上传文件。
For example, a bug-reporting system might let users attach log files and code samples to a problem ticket, or a blogging application could let its users upload a small image to appear next to their articles.
比如，程序缺陷报告系统将附加日志文件以及代码示例到报告中，又如博客应用程序可以上传小幅图片给文章配图。

In HTTP, files are uploaded as a multipart/form-data POST message.
在 HTTP中，文件被作为multipart或form-data的POST消息进行上传。
As the name suggests, forms are used to generate this type of message.
顾名思义，表单就是用来生成这类信息的。
Within that form, you’ll use one or more <input> tags with type="file".
在表单中，可以使用一个或几个具有`type="file"`属性的<input>标签。
When rendered by a browser, this tag allows the user to select a file by name.
浏览器呈现它们时，这些标签让用户通过名称选择一个文件。
When the form is subsequently submitted, the file or files will be sent back along with the rest of the form data.
随后提交表单时，就将一个或多个文件随同表单其他数据一起传回服务器。

To illustrate the file upload process, we’ll show some code that allows a user to upload an image and display that image alongside a comment.
为了阐明文件上传过程，这里展示一些上传图片并显示评论的代码。
To do this, we first need a pictures table to store the data.
为了实现这个效果，需要一个pictures表来储存相关数据。

    Download rails40/e1/views/db/migrate/20121130000004_create_pictures.rb
    class CreatePictures < ActiveRecord::Migration
      def change
        create_table :pictures do |t|
          t.string :comment       # 文件注释
          t.string :name          # 文件名称
          t.string :content_type  # 文件类型
          # If using MySQL, blobs default to 64k, so we have to give
          # an explicit size to extend them
          t.binary :data, :limit => 1.megabyte   # 文件二进制数据
        end
      end
    end

We’ll create a somewhat artificial upload controller just to demonstrate the process.
下面将创建一个假的用来演示这个过程的上传控制器。
The get action is pretty conventional; it simply creates a new picture object and renders a form.
这里的动作get和通常用法一样，只是创建新的图片对象并呈现表单。

    Download rails40/e1/views/app/controllers/upload_controller.rb
    class UploadController < ApplicationController
      def get
        @picture = Picture.new
      end
      # . . .
      private
      # Never trust parameters from the scary internet, only allow the white
      # list through.
      def picture_params
        params.require(:picture).permit(:comment, :uploaded_picture)
      end
    end

• 349

The get template contains the form that uploads the picture (along with a comment).
get模板包含用来上传图片的表单及其评论。
Note how we override the encoding type to allow data to be sent back with the response.
注意这里如何重写编码类型，允许数据同响应一起返回。
Download rails40/e1/views/app/views/upload/get.html.erb

    <%= form_for(:picture, url: {action: 'save'},
      html: {multipart: true}) do |form| %>
      Comment:
      <%= form.text_field("comment") %><br/>
      Upload your picture: <%= form.file_field("uploaded_picture") %><br/>
      <%= submit_tag("Upload file") %>
    <% end %>

The form has one other subtlety.
这个表单另有精妙之处。
The picture uploads into an attribute called uploaded_picture.
图片上传给属性uploaded_picture。
However, the database table doesn’t contain a column of that name.
不过，数据库表并没有包含该属性的字段。
That means that there must be some magic happening in the model.
这意味着该模型后面另有门道。

    Download rails40/e1/views/app/models/picture.rb
    class Picture < ActiveRecord::Base
      validates_format_of :content_type,
        with: /^image/,
        message: "must be a picture"
      def uploaded_picture=(picture_field)
        self.name = base_part_of(picture_field.original_filename)
        self.content_type = picture_field.content_type.chomp
        self.data = picture_field.read
      end
      def base_part_of(file_name)
        File.basename(file_name).gsub(/[^\w._-]/, '')
      end
    end

We define an accessor called uploaded_picture=() to receive the file uploaded by the form.
这里定义了存取方法uploaded_picture=()，用来接收该表单上传的文件。
The object returned by the form is an interesting hybrid.
这个表单所返回的对象是很有趣的混合体。
It is filelike, so we can read its contents with the read() method; that’s how we get the image data into the data column.
一方面，形式像文件，可以用read来读取内容；另一方面，可将获取的图片数据并入到data字段中。
It also has the attributes content_type and original_filename, which let us get at the uploaded file’s metadata.
它还有两个属性content_type和original_filename，可以在以上传文件的元数据中获得它们。
Accessor methods pick all this apart, resulting in a single object stored as separate attributes in the database.
存取方法把所有的属性分离出来，生成单一对象并保存在数据库中。

Note that we also add a simple validation to check that the content type is of the form image/xxx.
注意，这里还添加了简单的验证，检查内容类型是否具有image/xxx形式。
We don’t want someone uploading JavaScript.
可不要用户上传JavaScript文件。

The save action in the controller is totally conventional.
 控制器动作save是完全依照惯例的。

• 350

    Download rails40/e1/views/app/controllers/upload_controller.rb
    def save
      @picture = Picture.new(picture_params)
      if @picture.save
        redirect_to(action: 'show', id: @picture.id)
      else
        render(action: :get)
      end
    end

So, now that we have an image in the database, how do we display it? 
现在数据库中已经存储了一张图片，该怎么显示它呢？
One way is to give it its own URL and simply link to that URL from an image tag.
一种方式是使用自己的URL，并简单地在标签image中链接该URL。
For example, we could use a URL such as upload/picture/123 to return the image for picture 123.
例如，使用类似的upload/picture/123的URL，可以返回图片123的图像。
This would use send_data() to return the image to the browser.
这需要send_data方法将图像返回到浏览器中。

Note how we set the content type and filename—this lets browsers interpret the data and supplies a default name should the user choose to save the image.
注意怎么设置内容类型和文件名称的——让浏览器解析这些数据，提供默认名称，让用户保存图像。

    Download rails40/e1/views/app/controllers/upload_controller.rb
    def picture
      @picture = Picture.find(params[:id])
      send_data(@picture.data,
                filename: @picture.name,
                type: @picture.content_type,
                disposition: "inline")
    end

Finally, we can implement the show action, which displays the comment and the image.
最后，实现显示评论和图片的动作show。
The action simply loads the picture model object.
这个动作简单地加载图片模型对象。

    Download rails40/e1/views/app/controllers/upload_controller.rb
    def show
      @picture = Picture.find(params[:id])
    end

In the template, the image tag links back to the action that returns the picture content.
在模板中，image标签链接到返回图片内容的那个动作。
In Figure 60, Uploading a file, on page 351, we can see the get and show actions in all their glory.
在后面351页的图表60中，可以看到get和show动作运作正常。

    Download rails40/e1/views/app/views/upload/show.html.erb
    <h3><%= @picture.comment %></h3>
    <img src="<%= url_for(:action => 'picture', :id => @picture.id) %>"/>

If you’d like an easier way of dealing with uploading and storing images, take a look at thoughtbot’s Paperclip[4] or Rick Olson’s attachment_fu[5] plugins.
如果想要更简单的方法来处理图像的上传和存储，可以看看thoughtbot开发的Paperclip或者Rick Olson的attachment_fu插件。
[4].https://github.com/thoughtbot/paperclip#readme
[5].https://github.com/technoweenie/attachment_fu

• 351

Figure 60—Uploading a file
图示——上传一个文件。

Create a database table that includes a given set of columns (documented on Rick’s site), and the plugin will automatically manage storing both the uploaded data and the upload’s metadata.
先创建包含一组给定字段的数据库（参见Rick的文章），插件将自动管理存储已上传的数据和元数据。
Unlike our previous approach, it handles storing the uploads in either your filesystem or a database table.
与之前的方法不同，它既可以在文件系统中，也可以在数据库表中存储上传的内容。

Forms and uploads are just two examples of helpers that Rails provides.
表单和上传只是Rails提供的辅助器的两个例子。
Next we will show you how you can provide your own helpers and introduce you to a number of other helpers that come with Rails.
下一节将阐述如何提供自己的辅助器，并介绍Rails的一些其他辅助器。

## 21.5 Using Helpers  使用辅助器
### 为什么要用辅助器
Earlier we said that it’s OK to put code in templates.
前面说过可以在模板中放入代码。
Now we’re going to modify that statement.
现在得更改这个观点了。
It’s perfectly acceptable to put some code in templates—that’s what makes them dynamic.
在模板里加入一些代码完全是可以接受的——这让模板更加动态。
However, it’s poor style to put too much code in templates.
不过，在模板中添加太多是一种糟糕的习惯。

There are three main reasons for this.
对此有三个主要理由。
First, the more code you put in the view side of your application, the easier it is to let discipline slip and start adding application-level functionality to the template code.
第一，越多代码在视图中，越容易乱了规矩，很容易将程序级别的功能添加到模板代码中。
This is definitely poor form; you want to put application stuff in the controller and model layers so that it is available everywhere.
那实在太低效了；应用程序级别的内容应该放在控制器和模型里，这样它们才会变得通用。
This will pay off when you add new ways of viewing the application.
当添加显示应用该程序的新方法时，这样做是很值得的。

The second reason is that html.erb is basically HTML.
第二个理由是html.erb基本上是HTML。
When you edit it, you’re editing an HTML file.
编辑它时，其实就是编辑HTML文件。
If you have the luxury of having professional designers • 352 create your layouts, they’ll want to work with HTML.
如果由专业设计人员对页面进行布局，那么他们希望同HTML打交道。
Putting a bunch of Ruby code in there just makes it hard to work with.
放上一大堆ruby代码，只会让他们难以工作。

The final reason is that code embedded in views is hard to test, whereas code split out into helper modules can be isolated and tested as individual units.
第三个理由，在视图中嵌入代码难以进行测试，把代码拆分到辅助模块里，既独立又便于进行单独的单元测试。

Rails provides a nice compromise in the form of helpers.
Rails在辅助器的形式上提供了一个很妙的这种方案，
A helper is simply a module containing methods that assist a view.
辅助器只是一个包含一些辅助视图的方法的模块。
Helper methods are outputcentric.
辅助方法都是以输出为中心的。
They exist to generate HTML (or XML, or JavaScript)—a helper extends the behavior of a template.
其存在目的就是生成HTML、XML、JavaScript——扩展模板的表现。

### 21.5.1 Your Own Helpers 自定义辅助器
By default, each controller gets its own helper module.
默认情况下，每个控制器都有自己的辅助器。
Additionally, there is an application-wide helper named application_helper.rb.
另外，还有应用程序层面的辅助器application_helper。
It won’t be surprising to learn that Rails makes certain assumptions to help link the helpers into the controller and its views.
这一点不值得惊讶，Rails做了一些默认设置：把辅助器连接到控制器及其视图。
While all view helpers are available to all controllers, it often is good practice to organize helpers.
所有的控制器可以使用所有的视图辅助器，通常这是一个比较实际的管理方式。
Helpers that are unique to the views associated with the ProductController tend to be placed in a helper module called ProductHelper in the file product_helper.rb in the app/helpers directory.
对于关联到控制器ProductController的视图来说，辅助器只有一个ProductHelper，通常放在app/helpers目录下，文件名称为product_helper。
You don’t have to remember all these details—the rails generate controller script creates a stub helper module automatically.
不用记住所有细节——rails generate controller命令会自动生成辅助器模块文件。

In Section 11.4, Iteration F4: Hiding an Empty Cart, on page 149, we created such a helper method named hidden_div_if(), which enabled us to hide the cart under specified conditions.
前面149页11.4节中，曾经创建过这样自定义的辅助器hidden_div_if方法，作用是在特定条件下隐藏图标。
We can use the same technique to clean up the application layout a bit.
这里可以使用同样的方法，对应用程序的页面布局加以整理。
Currently we have the following:
如下所示：

    <h3><%= @page_title || "Pragmatic Store" %></h3>

Let’s move the code that works out the page title into a helper method.
下面移动代码，把页面标题放到辅助器方法里。
Because we’re in the store controller, we edit the file store_helper.rb in app/helpers.
由于代码在store控制器中，所以需要编辑app/helpers目录下的store_helper文件：

    module StoreHelper
      def page_title
        @page_title || "Pragmatic Store"
      end
    end

Now the view code simply calls the helper method.
现在视图代码可以简单调用辅助器方法了。

    <h3><%= page_title %></h3>

(We might want to eliminate even more duplication by moving the rendering of the entire title into a separate partial template, shared by all the controller’s views, but we don’t talk about partial templates until Partial-Page Templates, on page 363.)
把呈现整个标题移到单独的局部模板中，并且共享所有控制器视图，会进一步减少重复，后面363页的21.6节会深入讨论这一点。

• 353 

### 21.5.2 Helpers for Formatting and Linking  格式和链接辅助器
Rails comes with a bunch of built-in helper methods, available to all views.
Rails自带了一套所有视图都可以使用的辅助器方法。
 In this section, we’ll touch on the highlights, but you’ll probably want to look at the Action View RDoc for the specifics—there’s a lot of functionality in there.
这一节只介绍其中比较重要的部分，更多详情参见Action View的RDoc文档——那里介绍了很多的功能。

### 21.5.3 Formatting Helpers 格式辅助器
One set of helper methods deals with dates, numbers, and text.
一组处理日期、数字和文本的辅助器方法：
#### 日期、数字
<%= distance_of_time_in_words(Time.now, Time.local(2013, 12, 25)) %>
返回：
4 months

<%= distance_of_time_in_words(Time.now, Time.now + 33, include_seconds: false) %>
返回：
1 minute

<%= distance_of_time_in_words(Time.now, Time.now + 33, include_seconds: true) %>
返回：
Half a minute

<%= time_ago_in_words(Time.local(2012, 12, 25)) %>
返回：
7 months

<%= number_to_currency(123.45) %>
返回：
$123.45

<%= number_to_currency(234.56, unit: "CAN$", precision: 0) %>
返回：
CAN$235

<%= number_to_human_size(123_456) %>
返回：
120.6 KB

<%= number_to_percentage(66.66666) %>
返回：
66.667%

<%= number_to_percentage(66.66666, precision: 1) %>
返回：
66.7%

<%= number_to_phone(2125551212) %>
返回：
212-555-1212

<%= number_to_phone(2125551212, area_code: true, delimiter: " ") %>
返回：
(212) 555 1212

<%= number_with_delimiter(12345678) %>
返回：
12,345,678

<%= number_with_delimiter(12345678, delimiter: "_") %>
返回：
12_345_678

<%= number_with_precision(50.0/3, precision: 2) %>
返回：
16.67

• 354

#### debug
The debug() method dumps out its parameter using YAML and escapes the result so it can be displayed in an HTML page.
debug方法在输出其参数时使用YAML转义结果，这样就可以在HTML页面中显示。
This can help when trying to look at the values in model objects or request parameters.
对于查看模型对象里的值或者请求参数，这样做很有用。

<%= debug(params) %>
返回：
--- !ruby/hash:HashWithIndifferentAccess
name: Dave
language: Ruby
action: objects
controller: test

#### 文本
Yet another set of helpers deals with text.
另外，还有一组处理文本的辅助器。
There are methods to truncate strings and highlight words in a string.
有截断字符串和高亮字符串单词的方法。

##### <%= simple_format(@trees) %>
Formats a string, honoring line and paragraph breaks.
格式字符串，划线和分段。

You could give it the plain text of the Joyce Kilmer poem Trees, and it would add the HTML to format it as follows.
下面提供Joyce Kilmer的诗《树》的文本，增加HTML来格式化。

<p> 
  I think that I shall never see <br />
  A poem lovely as a tree.
</p> 
<p>
  A tree whose hungry mouth is prest <br />
  Against the sweet earth’s flowing breast; 
</p>

##### <%= excerpt(@trees, "lovely", 8) %>
返回：
...A poem lovely as a tre...

##### <%= highlight(@trees, "tree") %>
返回：
I think that I shall never see A poem lovely as a <strong class="highlight">tree</strong>. A <strong class="highlight">tree</strong> whose
hungry mouth is prest Against the sweet earth’s flowing breast;

##### <%= truncate(@trees, length: 20) %>
返回：
I think that I sh...

There’s a method to pluralize nouns.
还有名词变为复数的方法
##### <%= pluralize(1, "person") %> but <%= pluralize(2, "person") %>
返回：
1 person but 2 people

#### 链接
If you’d like to do what the fancy websites do and automatically hyperlink URLs and email addresses, there are helpers to do that.
想要完成那些漂亮网站所做的事情，比如自动为URL和邮件地址加上超链接，也要相应的辅助器。
There’s another that strips hyperlinks from text.
还有辅助器可以从文本里面提取超链接。

#### 表格或列表
Back in Iteration A2 on page 73, we saw how the cycle() helper can be used to return the successive values from a sequence each time it’s called, repeating the sequence as necessary.
回顾前面73页的6.2节迭代A2，曾经看过使用辅助器cycle，从一个序列中调用它，每次返回连续值，并且在必要时重复该连续值。
This is often used to create alternating styles for the rows in a table or list.
在处理表或列表、产生行记录的交替风格时，这是常用的方法。
The current_cycle() and reset_cycle() methods are also available.
current_cycle和reset_cycle方法也很有用。

• 355

#### 文本编辑
Finally, if you’re writing something like a blog site or you’re allowing users to add comments to your store, you could offer them the ability to create their text in Markdown (BlueCloth)[6] or Textile (RedCloth)[7] format.
最后，如果编写类似博客的网站应用，或者想要用户对商店添加评论，那么可让它们使用Markdown(BlueCloth)或者Textile(RedCloth)格式的文本。
[6].https://github.com/rtomayko/rdiscount
[7].http://redcloth.org/
These are simple formatters that take text with very simple, human-friendly markup and convert it into HTML.
这两款简单的文本格式工具，能以非常简单和人性化的标记处理文本，并转为HTML。

### 21.5.4 Linking to Other Pages and Resources 链接到其他页面和资源
The ActionView::Helpers::AssetTagHelper and ActionView::Helpers::UrlHelper modules contain a number of methods that let you reference resources external to the current template.
模块ActionView::Helpers::AssetTagHelper和模块ActionView::Helpers::UrlHelper包含了大量方法，它们将外部资源引用到当前模板中，。

#### link_to
Of these, the most commonly used is link_to(), which creates a hyperlink to another action in your application.
其中最常用的是link_to方法，它创建指向应用程序其他动作的链接。

    <%= link_to "Add Comment", new_comments_path %>

The first parameter to link_to() is the text displayed for the link.
第一个参数是该链接显示的文本内容。
The next is a string or hash specifying the link’s target.
第二个是指向连接目标的字符串或散列。
An optional third parameter provides HTML attributes for the generated link.
可选的第三个参数是所生成的链接的HTML属性

    <%= link_to "Delete", product_path(@product),
                { class: "dangerous", method: 'delete' }
    %>

This third parameter also supports two additional options that modify the behavior of the link.
这第三个参数还支持两个附加选项，它们可以修改该链接的反应形式。
Each requires JavaScript to be enabled in the browser.
每个请求都要求浏览器能够运行JavaScript。

The :method option is a hack—it allows you to make the link look to the application as if the request were created by a POST, PUT, PATCH, or DELETE, rather than the normal GET method.
:method选项是黑客手段——使该链接窥视应用程序，就像POST PUT DELETE而不是GET方法发出的链接。
This is done by creating a chunk of JavaScript that submits the request when the link is clicked—if JavaScript is disabled in the browser, a GET will be generated.
这是通过创建一系列JavaScript代码来实现的，单击链接时提交该请求——如果浏览器禁用JavaScript的话，将生成GET方法。

The :data parameter allows you to set custom data attributes.
<kinder:note> :data参数允许定制数据属性。
The most commonly used one is the :confirm option, which takes a short message.
<kinder:note> 最常用的是:confirm选项，该选项带有一个简短的信息。
If present, an unobtrusive JavaScript driver will display the message and get the user’s confirmation before the link is followed.
如果消息存在，就生成JavaScript在链接执行之前显示该消息，让用户确认。

    <%= link_to "Delete", product_path(@product),
      method: :delete,
      data: { confirm: 'Are you sure?' }
    %>

#### button_to
The button_to() method works the same as link_to() but generates a button in a self-contained form, rather than a straight hyperlink.
button_to方法的工作原理与link_to方法一样，不同的是它生成了一个放在自己的表单里的按键，而不仅是按钮。
This is the preferred  method of linking to actions that have side effects.
这是具有边际效应的动作链接的首选方法。

• 356
However, these buttons live in their own forms, which imposes a couple of restrictions: they cannot appear inline, and they cannot appear inside other forms.
不过，这些按钮都有自己的表单，这就产生了一系列限制：它们不能内联，也不能出现在其他表单内。

#### link_to_if link_to_unless
Rails has conditional linking methods that generate hyperlinks if some condition is met or just return the link text otherwise.
Rails还有条件链接方法，只有当某些条件满足时才能生成相应的超链接，否则只显示链接名称。
link_to_if() and link_to_unless() take a condition parameter, followed by the regular parameters to link_to.
link_to_if()和link_to_unless多了一个条件参数，其他的参数与link_to方法相同。
If the condition is true (for link_to_if) or false (for link_to_unless), a regular link will be created using the remaining parameters.
如果条件为true（对于link_to_if）或false（对于link_to_unless），那么使用剩余的参数生成普通连接。
If not, the name will be added as plain text (with no hyperlink).
否则只显示文本（无超链接）。

#### link_to_unless_current
The link_to_unless_current() helper creates menus in sidebars where the current page name is shown as plain text and the other entries are hyperlinks.
link_to_unless_current方法创建侧边栏菜单，其中将当前页面名称仅显示为链接名称，而其他的是超链接及其名称。

    <ul>
    <% %w{ create list edit save logout }.each do |action| %>
      <li>
        <%= link_to_unless_current(action.capitalize, action: action) %>
      </li>
    <% end %>
    </ul>

The link_to_unless_current() helper may also be passed a block that is evaluated only if the current action is the action given, effectively providing an alternative to the link.
如果当前动作就是指定动作，同时有效地提供了该连接的一个替代，那么可以将link_to_unless_current方法传递到可计算的代码块中。
<kinder:note> 听起来很玄。不懂。

#### current_page
There also is a current_page() helper method that simply tests whether the current request URI was generated by the given options.
还有current_page辅助器方法，它可以简单测试当前请求URL是否由给定选项生成。

As with url_for(), link_to() and friends also support absolute URLs.
就像url_for方法，link_to方法以及类似方法也支持**绝对路径**。

    <%= link_to("Help", "http://my.site/help/index.html") %>

#### image_tag
The image_tag() helper creates <img> tags.
image_tag辅助器创建<img>标签。
Optional :size parameters (of the form widthxheight) or separate width and height parameters define the size of the image.
可选:size参数（格式是宽×高）用来定义图片的大小，也可以分别用:width和:height给出宽度和高度。

    <%= image_tag("/assets/dave.png", class: "bevel", size: "80x120") %>
    <%= image_tag("/assets/andy.png", class: "bevel",
      width: "80", height: "120") %>

If you don’t give an :alt option, Rails synthesizes one for you using the image’s filename.
如果没有指定:alt选项，那么Rails将使用图片文件名作为该选项。
If the image path doesn’t start with a / character, Rails assumes that it lives under the app/assets/images directory.
如果图片路径不以/符号开头，Rails就假设它存于/images目录下。

You can make images into links by combining link_to() and image_tag().
通过组合link_to方法和image_tag方法，可以将图片变成超链接。

    <%= link_to(image_tag("delete.png", size: "50x22"),
      product_path(@product),
      data: { confirm: "Are you sure?" },
      method: :delete)
    %>

• 357

#### mail_to
The mail_to() helper creates a mailto: hyperlink that, when clicked, normally loads the client’s email application.
mail_to辅助器用来创建mailto超链接，具体地说，在单击后会加载客户端的邮件程序。
It takes an email address, the name of the link, and a set of HTML options.
它需要邮箱地址、链接名称和一个HTML选项。
Within these options, you can also use :bcc, :cc, :body, and :subject to initialize the corresponding email fields.
这些选项包括:bcc, :cc, :body, 和 :subject，用来初始化对应的邮件输入框。
Finally, the magic option encode: "javascript" uses client-side JavaScript to obscure the generated link, making it harder for spiders to harvest email addresses from your site.
最后，奇妙的`encode: "javascript"`选项使用客户端JavaScript来隐藏所生成的链接，屏蔽web爬虫搜集邮箱地址。
Unfortunately, it also means your users won’t see the email link if they have JavaScript disabled in their browsers.
遗憾的是，这也意味着，一旦浏览器禁用JavaScript，用户就看不到邮件链接了。

    <%= mail_to("support@pragprog.com", "Contact Support",
                subject: "Support question from #{@user.name}",
                encode: "javascript") %>

As a weaker form of obfuscation, you can use the :replace_at and :replace_dot options to replace the at sign and dots in the displayed name with other strings.
也可以使用弱隐藏形式，选项:replace_at和:replace_dot可以用其他字符来替代所要显示邮件名称的`@`和`.`字符。
This is unlikely to fool harvesters.
但这样做不能骗过搜索爬虫。

#### stylesheet_link_tag和javascript_link_tag
The AssetTagHelper module also includes helpers that make it easy to link to stylesheets and JavaScript code from your pages and to create autodiscovery Atom feed links.
AssetTagHelper模块还包含了一些辅助器，可以很轻松地实现从页面链接到样式表和JavaScript文件，自动创建Atom feed连接。
We created links in the layouts for the Depot application using the stylesheet_link_tag() and javascript_link_tag() methods in the head.
在前面的的Depot程序的页面布局中曾经创建过样式链接，在头部使用stylesheet_link_tag和javascript_link_tag方法。

    Download rails40/depot_r/app/views/layouts/application.html.erb
    <!DOCTYPE html>
    <html>
    <head>
      <title>Pragprog Books Online Store</title>
      <%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true %>
      <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
      <%= csrf_meta_tags %>
    </head>

<kinder:note> 与4版相比，本版少了下面一段，是误删还是真的不需要？
函数stylesheet_link_tag还可以接收:all参数，指明包含样式表目录的所有样式表文件。
添加recursive: true也将让Rails包含所有子目录的样式表文件。
</kinder:note> 
The javascript_include_tag() method takes a list of JavaScript filenames (assumed to live in assets/javascripts) and creates the HTML to load these into a page.
javascript_include_tag方法接收一个javascript_include_tag文件名列表（假定路径在assets/javascripts目录），创建html加载到页面中。
In addition to :all, javascript_include_tag accepts as a parameter the value :defaults, which acts as a shortcut and causes Rails to load jQuery.js.
除了:all参数，javascript_include_tag还接收:defaults的值作为参数，它就像一种快捷方式，让Rails加载jQuery.js。

#### auto_discovery_link_tag
An RSS or Atom link is a header field that points to a URL in our application.
RSS或者Atom链接是一个HTML的头部，指向应用程序的URL。
When that URL is accessed, the application should return the appropriate RSS or Atom XML.
URL可访问时，程序会返回合适的RSS或者Atom XML。

    <html>
      <head>
        <%= auto_discovery_link_tag(:atom, products_url(format: 'atom')) %>
      </head>
      . . .

• 358

#### javascripts辅助器
Finally, the JavaScriptHelper module defines a number of helpers for working with JavaScript.
最后JavaScriptHelper模板定义与JavaScript一起运行的JavaScript。
These create JavaScript snippets that run in the browser to generate special effects and to have the page dynamically interact with our application.
它们会创建可在浏览器运行的JavaScript片段，用来生特特定的效果，让页面同程序动态互动。

#### 配置asset资源目录
By default, image and stylesheet assets are assumed to live in the images and stylesheets directories relative to the application’s assets directory.
默认情况下，图像和样式表资源都在程序的images和stylesheets目录下。
If the path given to an asset tag method starts with a forward slash, then the path is assumed to be absolute, and no prefix is applied.
如果给定资源tag方法的路径以正斜杠开始，则该目录采用绝对路径，不会添加前缀。
Sometimes it makes sense to move this static content onto a separate box or to different locations on the current box.
有时把这些静态内容移到独立的服务器中或当前服务器的其他路径下，这很有必要。
Do this by setting the configuration variable asset_host.
设置配置变量asset_host可实现这一点：

    config.action_controller.asset_host = "http://media.my.url/assets"

Although this list of helpers may seem to be comprehensive, Rails provides many more, new helpers are introduced with each release, and a select few are retired or moved off into a plugin where they can be evolved at a different pace than Rails.
虽然这些辅助器看起来比较全面，但Rails还能提供更多选择，每一新版本发行都会引入新的辅助器，并挑选少量退出或移到插件里——这样它们的演变会有别于Rails的版本。
Now would be a good time to review the online documentation that you produced in A Place for Documentation, on page 265, to see what other goodies Rails provides for you.
现在是时候回顾一下前面265页18.1节所生成的在线手册，看看Rails提供的其他东西了。

## 21.6 Reducing Maintenance with Layouts and Partials 用页面布局和局部模板减轻维护工作
### 三种重复
So far in this chapter we’ve looked at templates as isolated chunks of code and HTML.
在本章前面已经介绍过已分离的HTML片段代码的模板。
But one of the driving ideas behind Rails is honoring the DRY principle and eliminating the need for duplication.
但是，Rails背后的驱动理念之一是忠实于DRY原则，排除需要重复的东西。
The average website, though, has lots of duplication.
不过，普通网站里面却有大量的重复。

• Many pages share the same tops, tails, and sidebars.
  许多页面共享同样的页首、页尾、侧边栏。
• Multiple pages may contain the same snippets of rendered HTML (a blog site, for example, may display an article in multiple places).
  多个页面包含同样的要呈现的HTML片段（比如，博客网站可能会在多个地方显示同一篇文章）。
• The same functionality may appear in multiple places.
  多个地方出现同样的功能。
Many sites have a standard search component or a polling component that appears in most of the sites’ sidebars.
很多网站都有标准搜索组件或者投票组件，它们会出现在大多数网站的侧边栏里。

Rails provides both layouts and partials that reduce the need for duplication in these three situations.
Rails提供了页面布局和局部模板，用来减少上面三种情况下需要重复的东西。

### 21.6.1 Layouts 页面布局
Rails allows you to render pages that are nested inside other rendered pages.
Rails可呈现页面，里面还可嵌入其他所要呈现页面。
Typically this feature is used to put the content from an action within a standard site-wide page frame (title, footer, and sidebar).
通常，使用该特性可把来自动作的内容放入整个网站的标准页面框架（包括标题、页脚、侧边栏）。
In fact, if you’ve  been using the generate script to create scaffold-based applications, then you’ve been using these layouts all along.
事实上，如果已经使用过generate脚本来创建基于脚手架的应用程序，那么就一直使用这样的布局。

• 359

When Rails honors a request to render a template from within a controller, it actually renders two templates.
当Rails接收到要呈现来自控制器内模板的请求时，实际上呈现了两个模板。
Obviously, it renders the one you ask for (or the default template named after the action if you don’t explicitly render anything).
显然它呈现了所要求的模板（或者当没有明确要求呈现任何东西时，就是呈现以动作名称所命名的默认模板）。
But Rails also tries to find and render a layout template (we’ll talk about how it finds the layout in a second).
但Rails还会尝试去寻找和呈现布局模板（马上将介绍如何寻找布局模板）。
If it finds the layout, it inserts the action-specific output into the HTML produced by the layout.
如果找到了该布局，就把与动作相关的输出插入由布局模板所生成的HTML中。

Let’s look at a layout template:
看看布局模板吧：

    <html>
      <head>
        <title>Form: <%= controller.action_name %></title>
        <%= stylesheet_link_tag 'scaffold' %>
      </head>
      <body>
        <%= yield :layout %>
      </body>
    </html>

The layout sets out a standard HTML page, with the head and body sections.
这个布局输出了具有head和body的标准html页面。
It uses the current action name as the page title and includes a CSS file.
使用当前的动作名作为页面标题，包含一个样式表文件。
In the body, there’s a call to yield.
在页面主体，它调用了yield。
This is where the magic takes place.
这就是神奇的地方。
When the template for the action was rendered, Rails stored its content, labeling it :layout.
在呈现动作模板时，Rails将其内容储存起来并标为:layout。
Inside the layout template, calling yield retrieves this text.
在布局模板内部，调用yield取回这些内容。
In fact, :layout is the default content returned when rendering, so you can write yield instead of yield :layout.
事实上，:layout是当呈现时返回的默认内容，这样就可以写作yield，而不用写yield
:layout了。
We personally prefer the slightly more explicit version.
就个人来说，我们更喜欢明确点的版本。

If the my_action.html.erb template contained this:
如果模板my_action.html.erb包含这样的内容：

    <h1><%= @msg %></h1>

the browser would see the following HTML:
则浏览器会看到如下内容：

    <html>
      <head>
        <title>Form: my_action</title>
        <link href="/stylesheets/scaffold.css" media="screen"
          rel="Stylesheet" type="text/css" />
      </head>
      <body>
        <h1>Hello, World!</h1>
      </body>
    </html>

• 360

### 21.6.2 Locating Layout Files 放置布局文件
As you’ve probably come to expect, Rails does a good job of providing defaults for layout file locations, but you can override the defaults if you need something different.
你可能会想但，Rails做好了提供默认布局文件位置的工作，如果想要放在其他地方，可以重写默认设置。
<kinder:note> 怎么重写？

#### 布局和控制器
Layouts are controller-specific.
布局是与控制器相关的。
If the current request is being handled by a controller called store, Rails will by default look for a layout called store (with the usual .html.erb or .xml.builder extension) in the app/views/layouts directory.
如果store控制器正在处理请求，则在默认情况下Rails将在目录app/views/layouts下寻找布局store（文件扩展名通常为.html.erb或者.xml.builder）。
If you create a layout called application in the layouts directory, it will be applied to all controllers that don’t otherwise have a layout defined for them.
如果在目录layouts下创建名称为application的布局，那么它将作用于所有没有定义布局的控制器，除非你为它们定义布局。

You can override this using the layout declaration inside a controller.
在控制器中使用layout声明可以重写布局文件名称。
At its simplest, the declaration takes the name of a layout as a string.
在最简单的情况下，声明采用字符串类型的布局名称作为参数。
The following declaration will make the template in the file standard.html.erb or standard.xml.builder the layout for all actions in the store controller.
下面的声明将使得模板文件standard.html.erb或者standard.xml.builder称为store控制器所有动作的布局。
The layout file will be looked for in the app/views/layouts directory.
Rails将在目录app/views/layouts目录下寻找。

    class StoreController < ApplicationController
      layout "standard"
      # ...
    end

You can qualify which actions will have the layout applied to them using the :only and :except qualifiers.
使用限定词:only和:except，可以限定该布局服务于哪些动作。

    class StoreController < ApplicationController
      layout "standard", except: [ :rss, :atom ]
      # ...
    end

Specifying a layout of nil turns off layouts for a controller.
指定为nil的布局将不会服务于该控制器。

#### 动态布局
Sometimes you need to change the appearance of a set of pages at runtime.
又是需要实时改变自足页面的外观。
For example, a blogging site might offer a different-looking side menu if the user is logged in, or a store site might have different-looking pages if the site is down for maintenance.
例如，博客网站可以在用户登录后提供不同的侧边栏菜单，在线商店可以在其停机维护时显示不同的页面。
Rails supports this need with dynamic layouts.
Rails提供了动态布局来支持这一需求。
If the parameter to the layout declaration is a symbol, it’s taken to be the name of a controller instance method that returns the name of the layout to be used.
如果layout声明的参数是符号，则它将引向控制器实例参数，该函数返回要使用的布局名称。

• 361

    class StoreController < ApplicationController
      layout :determine_layout
      # ...
      private
      def determine_layout
        if Store.is_closed?
          "store_down"
        else
          "standard"
        end
      end
    end

Subclasses of a controller use the parent’s layout unless they override it using the layout directive.
控制器的子类使用其父类的布局，除非它们使用了layout指令。

#### render方法
Finally, individual actions can choose to render using a specific layout (or with no layout at all) by passing render() the :layout option.
最后，通过向render方法传递:layout的选项，不同的行为可以使用特定的布局（或完全没有使用布局）来呈现。

    def rss
      render(layout: false)
      # never use a layout 不使用布局
    end
    def checkout
      render(layout: "layouts/simple")
    end

### 21.6.3 Passing Data to Layouts 传递数据到布局
Layouts have access to all the same data that’s available to conventional templates.
布局可以和传统模板一样，访问所有传统模板所能访问的数据。
<kinder:note> 这里的“传统模板”可以理解为views目录下的erb文件。这里的“数据”应该是控制器中的变量。
In addition, any instance variables set in the normal template will be available in the layout (because the regular template is rendered before the layout is invoked).
此外，在普通模板中设定的任何实例变量是可以在布局中使用的（因为在调用layout之前，将呈现常规模板）。
This might be used to parameterize headings or menus in the layout.
这可以用来对布局的页头和菜单进行参数化处理。
For example, the layout might contain this:
比如，布局可能包括以下内容：

    <html>
      <head>
        <title><%= @title %></title>
        <%= stylesheet_link_tag 'scaffold' %>
      </head>
      <body>
        <h1><%= @title %></h1>
        <%= yield :layout %>
      </body>
    </html>

An individual template could set the title by assigning to the @title variable.
特殊的模板可以通过分配变量@titile来设置标题。
<kinder:note> 下面这些erb代码是放在哪里的？八成放在控制器对应的视图模板中。

    <% @title = "My Wonderful Life" %>
    <p>
      Dear Diary:
    </p>
    <p>
      Yesterday I had pizza for dinner. It was nice.
    </p>

• 362

In fact, we can take this further.
实际上可以更深入一步。
The same mechanism that lets us use yield :layout to embed the rendering of a template into the layout also lets you generate arbitrary content in a template, which can then be embedded into any other template.
之前使用yield
:layout将呈现模板嵌入布局中，这样的机制也可以用来生成模板的任何内容，这些内容将被嵌入任意其他模板中。

For example, different templates may need to add their own template-specific items to the standard page sidebar.
例如，不同的模板有可能需要向标准页面侧边栏添加与自己模板相关的菜单项。
We’ll use the content_for mechanism in those templates to define content and then use yield in the layout to embed this content into the sidebar.
在这些模板中采用content_for机制来定义内容，并用yield在布局中将内容嵌入侧边栏。

In each regular template, use a content_for to give a name to the content rendered inside a block.
在每一个常规模板中，可以使用content_for来给代码块所呈现的内容一个名称。
This content will be stored inside Rails and will not contribute to the output generated by the template.
这些内容将会在Rails中储存起来，而不会对该模板所生成的输出起作用。
<kinder:note> 下面代码也应该是放在控制器对应的视图模板中。

    <h1>Regular Template</h1>
    <% content_for(:sidebar) do %>
      <ul>
        <li>this text will be rendered</li>
        <li>and saved for later</li>
        <li>it may contain <%= "dynamic" %> stuff</li>
      </ul>
    <% end %>
      <p>
        Here's the regular stuff that will appear on
        the page rendered by this template.
      </p>

Then, in the layout, you use yield :sidebar to include this block into the page’s sidebar.
然后，在布局中，可以使用yield :sidebar来把该代码块包含到页面侧边栏中。
<kinder:note> 这里当然是布局模板了。

    <!DOCTYPE .... >
    <html>
      <body>
        <div class="sidebar">
          <p>
            Regular sidebar stuff
          </p>
          <div class="page-specific-sidebar">
    ➤       <%= yield :sidebar %>
          </div>
        </div>
      </body>
    </html>

This same technique can be used to add page-specific JavaScript functions into the `<head>` section of a layout, create specialized menu bars, and so on.
同样的技术可以把与页面相关的JavaScript函数添加到布局的`<head>`部分，用于创建特殊菜单之类的功能。

• 363

### 21.6.4 Partial-Page Templates 局部页面模板
Web applications commonly display information about the same application object or objects on multiple pages.
一般Web程序显示相同程序对象或不同页面的多个对象信息。

A shopping cart might display an order line item on the shopping cart page and again on the order summary page.
购物车可能在购物车页面上和订单汇总页面上显示订单项目。
A blog application might display the contents of an article on the main index page and again at the top of a page soliciting comments.
博客应用程序可能在索引主页面上和评论页面的上方显示文章内容。
Typically this would involve copying snippets of code between the different template pages.
典型情况是，这会引起不同模板页面之间进行代码片段的复制。

Rails, however, eliminates this duplication with the partial-page templates (more frequently called partials).
Rails使用局部模板避免这一重复。
You can think of a partial as a kind of subroutine.
可以把局部模板看作子程序。
You invoke it one or more times from within another template, potentially passing it objects to render as parameters.
可以在其他模板中一次或多次地调用它，同时有可能将以参数的形式呈现传递到对象中。
When the partial template finishes rendering, it returns control to the calling template.
局部模板完成呈现后，返回调用模板的控制。

Internally, a partial template looks like any other template.
从内部来看，局部模板看起来像任意其他模板一样。
Externally, there’s a slight difference.
从外部来看，存在着细微的差别。
The name of the file containing the template code must start with an underscore character, differentiating the source of partial templates from their more complete brothers and sisters.
包含模板代码的文件名必须以下划线字符开始，这将局部模板的源代码与同类型完整模板区分开来。

For example, the partial to render a blog entry might be stored in the file `_article.html.erb` in the normal views directory, app/views/blog.
比如，在默认视图路径app/views/blog文件的
`_article.html.erb`中存放呈现博客文章的局部模板。

    <div class="article">
      <div class="articleheader">
        <h3><%= article.title %></h3>
      </div>
      <div class="articlebody">
        <%= article.body %>
      </div>
    </div>

Other templates use the render(partial:) method to invoke this.
其他模板使用render(partial:)方法来调用它;

    <%= render(partial: "article", object: @an_article) %>
    <h3>Add Comment</h3>
    . . .

The :partial parameter to render() is the name of the template to render (but without the leading underscore).
render的:partial参数呈现模板的名称（但没有前置的下划线）。
This name must be both a valid filename and a valid Ruby identifier (so a-b and 20042501 are not valid names for partials).
该名称必须是有效文件名和有效Ruby标识符（如a-b和20042501都不是局部模板的有效名称）。
The :object parameter identifies an object to be passed into the partial.
:object参数将该对象传递给局部模板。
This object will be available within the template via a local variable with the same name as the template.
通过与与该模板同名的本地变量，这一对象在该模板内是可用的。
In this example, the @an_article object will be passed to the template, and the template can access it using the local variable article.
本例中，对象@an_article传递到该模板中的本地变量article，该模板就可使用它了。

That’s why we could write things such as article.title in the partial.
这就是为什么局部模板中可以编写类似article.title那样的代码。

• 364

You can set additional local variables in the template by passing render() a :locals parameter.
通过给render传递:locals参数，可以在模板中设置更多的局部变量。
This takes a hash where the entries represent the names and values of the local variables to set.
它可用散列，每一项代表要设置的本地变量的名称和值。

    render(partial: 'article',
      object: @an_article,
      locals: { authorized_by: session[:user_name],
        from_ip: request.remote_ip 
      }
    )

### 21.6.5 Partials and Collections 局部模板和集合
Applications commonly need to display collections of formatted entries.
应用程序通常需要显示被格式化的项目的集合。
A blog might show a series of articles, each with text, author, date, and so on.
博客程序可能要显示一系列文章，每一篇文章都有文本、作者和日期等。
A store might display entries in a catalog, where each has an image, a description, and a price.
商店程序应该按目录显示商品，每一种商品都有图片、描述和价格等。

The :collection parameter to render() works in conjunction with the :partial parameter.
reder的:Collection参数是和:partial协同工作的。
The :partial parameter lets us use a partial to define the format of an individual entry, and the :collection parameter applies this template to each member of the collection.
:partial参数可以使用局部模板来定义单独项目的格式，而:collection参数将模板应用于集合的每一项目。
To display a list of article model objects using our previously defined `_article.html.erb` partial, we could write this:
为了显示一组文章模型对象，可以使用前面定义的`_article.html.erb`模板，可以这些来写：

    <%= render(partial: "article", collection: @article_list) %>

Inside the partial, the local variable article will be set to the current article from the collection—the variable is named after the template.
在这个局部模板中，本地变量article将被从集合中设置为当前文章——这个变量是用模板名称来命名的。
In addition, the variable article_counter will have its value set to the index of the current article in the collection.
此外，将变量article_counter设置为该集合中当前文章的索引值。

The optional :spacer_template parameter lets you specify a template that will be rendered between each of the elements in the collection.
可选的:spacer_template参数可以指定该集合每一项之间所要呈现的模板。
For example, a view might contain the following:
例如视图应该包含一下内容：

    Download rails40/e1/views/app/views/partial/_list.html.erb
    <%= render(partial: "animal",
      collection:
        %w{ ant bee cat dog elk },
        spacer_template: "spacer"
      )
    %>

This uses `_animal.html.erb` to render each animal in the given list, rendering the partial `_spacer.html.erb` between each.
这里使用`_animal.html.erb`来呈现给定列表中的每一个动物，同时为每个动作呈现局部模板`_spacer.htm.erb`。
If `_animal.html.erb` contains this:
如果`_animal.html.erb`包含如下内容：

    Download rails40/e1/views/app/views/partial/_animal.html.erb
    <p>The animal is <%= animal %></p>

and `_spacer.html.erb` contains this:
`_spacer.html.erb`模板包含：

• 365

    Download rails40/e1/views/app/views/partial/_spacer.html.erb
    <hr />

your users would see a list of animal names with a line between each.
则用户将看到动物名称的列表，它们之间用线条分开。

### 21.6.6 Shared Templates 共享模板
If the first option or :partial parameter to a render call is a simple name, Rails assumes that the target template is in the current controller’s view directory.
如果调用方法render的第一个选项或`:partial`参数是个简单的名称，则Rails认为目标模板就在当前控制器的视图目录下面。
However, if the name contains one or more / characters, Rails assumes that the part up to the last slash is a directory name and the rest is the template name.
但是，如果名称包含一个或多个/字符，则Rails认为直到最后一个斜线部分都是目录名，剩余的是模板名称。
The directory is assumed to be under app/views.
该目录被假定为app/views之下。
This makes it easy to share partials and subtemplates across controllers.
这样可以很容易地在控制器之间共享局部模板及其子模板。

The convention among Rails applications is to store these shared partials in a subdirectory of app/views called shared.
Rails程序的约定是将共享局部模板存放在路径app/views下的shared中。
Render shared partials using statements such as these:
使用这样的语句来呈现共享局部模板。

    <%= render("shared/header", locals: {title: @article.title}) %>
    <%= render(partial: "shared/post", object: @article) %>
    . . .

In this previous example, the @article object will be assigned to the local variable post within the template.
在前面的例子里，对象@article将分配到该模板的局部变量post中。

### 21.6.7 Partials with Layouts 局部模板和布局
Partials can be rendered with a layout, and you can apply a layout to a block within any template.
局部模板可以和布局一起呈现，且可以将布局应用于任何模板内的代码块中。
<kinder:note> 这个应用有些令人费解，到底怎么使用？

    <%= render partial: "user", layout: "administrator" %>
    <%= render layout: "administrator" do %>
      # ...
    <% end %>

Partial layouts are to be found directly in the app/views directory associated with the controller, along with the customary underbar prefix, such as `app/views/users/_administrator.html.erb`.
可以在控制器相关的路径app/views下直接找到局部模板布局，名称通常使用下划线作为前缀，比如`app/views/users/_administrator.html.erb`。

### 21.6.8 Partials and Controllers 局部模板和控制器
It isn’t just view templates that use partials.
不仅视图模板是帅是局部模板。
Controllers also get in on the act.
控制器参与其中。

Partials give controllers the ability to generate fragments from a page using the same partial template as the view.
局部模板让控制器能够生成页面的片段代码。
This is particularly important when you are using Ajax support to update just part of a page from the controller—use partials, and you know your formatting for the table row or line item that you’re updating will be compatible with that used to generate its brethren initially.
特别重要的是，当使用Ajax支持来更新在控制器中的部分页面时，使用局部模板，可以清楚地知道，更新表格的商品项目和最初用来生成同类内容的商品项目，格式是相互兼容的。

• 366

Taken together, partials and layouts provide an effective way to make sure that the user interface portion of your application is maintainable.
综上所述，局部模板和布局提供了一种有效的方式，以确保程序的用户界面部分是可维护的。
But being maintainable is only part of the story; doing so in a way that also performs well is also crucial.
但可维护只是软件的一部分，这么做的同时，保证运行效率也是至关重要的。

## What We Just Did 本章小结
Views are the public face of Rails applications, and we have seen that Rails delivers extensive support for what you need to build robust and maintainable user and application programming interfaces.
视图是Rails程序的对外窗口，我们也已经了解到Rails提供了广泛的支持，其中包括用来建立健全和可维护的用户界面和程序界面。

We started with templates, of which Rails provides built-in support for four types: ERB, Builder, CoffeeScript, and SCSS.
Rails支持四种内建的模板类型：ERB, Builder, CoffeeScript, SCSS。
Templates make it easy for us to provide HTML, XML, CSS, and JavaScript responses to any request.
模板很容易对任何请求提供HTML XML CSS JavaScript响应。
We will discuss adding another option in Section 25.2, Beautifying Our Markup with Haml, on page 413.
后面413页25.2节将讨论添加另一个选项。
<kinder:note> 说的是haml吧。

We dove into forms, which are the primary means by which users will interact with your application.
接着渗入探讨了表单，这是用户与程序交互的主要手段。
Along the way, we covered uploading files.
还顺便介绍了上传文件。

We continued with helpers, which enable us to factor out complex application logic to allow our views to focus on presentation aspects.
然后继续讨论了辅助器，它将程序复杂的逻辑分解的重点放到表达外观的视图上。
We explored a number of helpers that Rails provides, ranging from simple formatting to hypertext links, which are the final way in which users interact with HTML pages.
我们考察了Rails所提供的大量辅助器，从简单的格式化定义到超链接，这些都是用户与HTML页面互动的最后方式。
We completed our tour of Action View by covering two related ways of factoring out large chunks of content for reuse.
最后通过把大量内容分解为可重用的两种相关方法，从而完成了动作视图之旅。
We use layouts to factor out the outermost layers of a view and provide a common look and feel.
使用布局可分离视图的最外层，并提供了一致的外观和感觉。
We use partials to factor out common inner components, such as a single form or table.
使用局部模板可分离通用的内部组件，例如单一表单或表格。

That covers how a user with a browser will access our Rails application.
所有这些包括了用户怎么使用浏览器来访问Rails程序。
Next up: covering how we define and maintain the schema of the database our application will use to store data.
下一步涉及如何定义和维护用来存储数据的数据库的纲要。

# CHAPTER 22 Migrations 迁移
## In this chapter, we’ll see
本章中，我们将学习
• naming migration files,
  命名迁移文件
• renaming and columns,
  重命名和字段
• creating and renaming tables,
  创建和重命名数据表
• defining indices and keys, and
  定义索引和键
• using native SQL.
  使用原生SQL。

Rails encourages an agile, iterative style of development.
Rails鼓励灵活、迭代的开发方式。
We don’t expect to get everything right the first time.
我们并不指望第一次就能把每件事都做好。
Instead, we write tests and interact with our customers to refine our understanding as we go.
相反，我们在开发过程中编写测试，与客户交互，以此增进理解。

For that to work, we need a supporting set of practices.
要完成这项工作，需要一系列实践的支持。
We write tests to help us design our interfaces and to act as a safety net when we change things, and we use version control to store our application’s source files, allowing us to undo mistakes and to monitor what changes day to day.
可以编写测试来帮忙设计接口，当作出改变时，这些测试就像一张安全网；还可以使用使用版本控制来保存应用程序的源文件，以便撤销错误的修改，并监控每天的变化。

But there’s another area of the application that changes, an area that we can’t directly manage using version control.
但是，应用程序中仍然有一个地带，其变化是无法用版本控制直接管理的。
The database schema in a Rails application constantly evolves as we progress through the development: we add a table here, rename a column there, and so on.
在整个开发过程中，Rails程序的数据库纲要一直在变化：这里添加一个表，那里重命名一个字段等。
The database changes in step with the application’s code.
数据库与应用程序的代码一起改变。

With Rails, each of those steps is made possible through the use of a migration.
在Rails中，可以通过使用迁移来完成每一步。
You saw this in use throughout the development of the Depot application, starting when we created the first products table in Generating the Scaffold, on page 62, and when we performed such tasks as adding a quantity to the line_items table in Section 10.1, Iteration E1: Creating a Smarter Cart, on page 119.
开发Depot程序的过程中就使用了迁移，从前面62页6.1节创建第一个products表开始，到119页10.1节在line_items表添加一个数量字段，都涉及到迁移的使用。
Now it is time to dig deeper into how migrations work and what else you can do with them.
现在是时候学习有关迁移更深层的工作原理，看看它们还能做什么。

## 22.1 Creating and Running Migrations 创建和运行迁移
### 什么是迁移
A migration is simply a Ruby source file in your application’s db/migrate directory.
迁移只是一个Ruby源文件，这个文件在该程序的db/migrate目录下。
Each migration file’s name starts with a number of digits (typically fourteen) and an underscore.
每个迁移文件的名称都以大量数字开头（通常是十四位），随后是一个下划线。
Those digits are the key to migrations, because they define the sequence in which the migrations are applied—they are the individual migration’s version number.
这些数字是迁移的密钥，因为它们定义了迁移应用的顺序——它们是单个迁移的版本号。

• 368

The version number is the Coordinated Universal Time (UTC) timestamp at the time the migration was created.
这个版本号是迁移创建时以世界时间定义的时间戳。
These numbers contain the four-digit year, followed by two digits each for the month, day, hour, minute, and second, all based on the mean solar time at the Royal Observatory in Greenwich, London.
这些数字包含四位数的年份，之后各两位月份、日期、小时、分钟、秒数，这是伦敦格林尼治时间的阳历表示法。
Because migrations tend to be created relatively infrequently and the accuracy is recorded down to the second, the chances of any two people getting the same timestamp is vanishingly small.
由于迁移创建的频率相对较低，并且记录精确到秒，因此任意两人得到时间戳的几率微乎其微。
And the benefit of having timestamps that can be deterministically ordered far outweighs the miniscule risk of this occurring.
使用时间戳的好处在于可以确定地排列这些文件，这个优点的收益远远超过了所承担的那点风险。
Here’s what the db/migrate directory of our Depot application looks like:
下面是Depot程序db/migrate目录的例子：

    depot> ls db/migrate
    20121130000001_create_products.rb
    20121130000002_create_carts.rb
    20121130000003_create_line_items.rb
    20121130000004_add_quantity_to_line_items.rb
    20121130000005_combine_items_in_cart.rb
    20121130000006_create_orders.rb
    20121130000007_add_order_id_to_line_item.rb
    20121130000008_create_users.rb

Although you could create these migration files by hand, it’s easier (and less error prone) to use a generator.
虽然可以手动创建这些迁移文件，但使用生成器会更轻松（且不容易出错）。
As we saw when we created the Depot application, there are actually two generators that create migration files.
就像创建Depot程序那样，实际中有两个生成器用来创建迁移文件。

• The model generator creates a migration to in turn create the table associated with the model (unless you specify the --skip-migration option).
  模型生成器创建一个迁移，用于一次创建与这个模型相关的表（除非执行中定义了skip-migration选项，否则将自动创建这个迁移）。
As the example that follows shows, creating a model called discount also creates a migration called yyyyMMddhhmmss_create_discounts.rb:
正如下面例子所示，创建discount模型的同时，也创建了一个称为yyyyMMddhhmmss_create_discounts.rb的迁移文件。

    depot> rails generate model discount
      invoke active_record
    ➤ create db/migrate/20121113133549_create_discounts.rb
      create app/models/discount.rb
      invoke test_unit
      create test/models/discount_test.rb
      create test/fixtures/discounts.yml

• You can also generate a migration on its own.
  也可以自己生成一个迁移。

    depot> rails generate migration add_price_column
      invoke active_record
    ➤ create db/migrate/20121113133814_add_price_column.rb

Later, starting in Anatomy of a Migration, we’ll see what goes in the migration files.
接着，开始迁移剖析，可以看到迁移生成的文件。
But for now, let’s jump ahead a little in the workflow and see how to run migrations.
但现在，先跳过流程中的第一步，来看看如何运行迁移。

• 369

###  Running Migrations 运行迁移
Migrations are run using the db:migrate Rake task.
用Rake任务`db:migrate`可以运行迁移。

    depot> rake db:migrate

To see what happens next, let’s dive down into the internals of Rails.
要想看到下一步会发生什么，需要渗入Rails内部。
The migration code maintains a table called schema_migrations inside every Rails database.
迁移代码在在每个Rails数据库中都维护着一个称为schema_migrations的表。
This table has just one column, called version, and it will have one row per successfully applied migration.
这个表只有一个version字段，每成功应用一个迁移，该表就会为其添加一行新内容。

When you run rake db:migrate, the task first looks for the schema_migrations table.
运行`rake db:migrate`时，该任务会先寻找schema_migrations表。
<kinder:note> 这是第一步
 If it doesn’t yet exist, it will be created.
如果该表不存在，就创建它。
The migration code then looks at all the migration files in db/migrate and skips from consideration any that have a version number (the leading digits in the filename) that is already in the database.
接着迁移代码会查看db/migrate目录下的所有迁移文件；倘若版本号（文件名中的数字）已经在数据库中，则跳过这个文件。
<kinder:note> 这是第二步
It then proceeds to apply the remainder of the migrations, creating a row in the schema_migrations table for each.
然后把筛选后剩余的迁移一一处理，并为每个迁移在schema_migrations表中创建一条新记录。
<kinder:note> 这是第三也是最后一步
If we were to run migrations again at this point, nothing much would happen.
如果在这个时候再次运行迁移，则不会发生什么。
Each of the version numbers of the migration files would match with a row in the database, so there would be no migrations to apply.
由于每个迁移文件的版本号都将和数据库中的一条记录匹配，因此不会应用迁移。
However, if we subsequently create a new migration file, it will have a version number not in the database.
但是，如果随后创建一个新的迁移文件，那么这个文件的版本号不会在数据库内。
<kinder:note> 就是说运行迁移之后创建的文件。
This is true even if the version number was before one or more of the already applied migrations.
即使这时该版本号的时间出现在一个或多个已经应用过的迁移之前。
This can happen when multiple users are using a version control system to store the migration files.
在多个用户、使用版本控制器系统来存储迁移文件时，可能会发生这种情况。
If we then run migrations, this new migration file—and only this migration file—will be executed.
如果这时运行迁移，将只会执行这个新的迁移文件。
This may mean that migrations are run out of order, so you might want to take care and ensure that these migrations are independent.
这意味着迁移运行秩序出现混乱，因此得小心一点，确保这些迁移互相独立。
<kinder:note> 不懂。为什么混乱，处理新的迁移文件不就可以了？
<kinder:note> 这里的混乱说的是新迁移文件的版本号比schema_migrations表里的记录要旧。
Or you might want to revert your database to a previous state and then apply the migrations in order.
或者可以回到上一个版本的数据库，然后再按顺序应用迁移。
<kinder:note> 用rake db:rollback命令回滚？
<kinder:note> 还是下面的Rails的自动回滚？
You can force the database to a specific version by supplying the VERSION= parameter to the rake db:migrate command.
可以为rake db:migrate命令提供VERSION=参数来强制数据库执行特定版本。

    depot> rake db:migrate VERSION=20121130000009

If the version you give is greater than any of the migrations that have yet to be applied, these migrations will be applied.
如果给定的版本比任何已应用过的迁移版本都高，那么将应用这些迁移。
If, however, the version number on the command line is less than one or more versions listed in the schema_migrations table, something different happens.
但是，倘若命令行中的版本号比schema_migrations表中列出的一个或多个版本号大，那么将会有不同的事情发生。
In these circumstances, Rails looks for the migration file whose number matches the database version and undoes it.
这些情况下，Rails会寻找那个和数据库中版本号相符的迁移文件，然后撤销它。
It repeats this process until • 370 there are no more versions listed in the schema_migrations table that exceed the number you specified on the command line.
这个步骤持续循环，直到schema_migrations表中列出的版本号都不超过命令行中给定的版本号。
That is, the migrations are unapplied in reverse order to take the schema back to the version that you specify.
就是说，迁移以相反的顺序运行，让纲要回到指定的版本。

You can also redo one or more migrations.
也可以重做一个或多个迁移。

    depot> rake db:migrate:redo STEP=3

By default, redo will roll back one migration and rerun it.
默认情况下，redo将回滚一个迁移，并重新运行它。
To roll back multiple migrations, pass the STEP= parameter.
要回滚多个迁移，可以修改STEP=的参数。


## 22.2 Anatomy of a Migration
### up down change
Migrations are subclasses of the Rails class ActiveRecord::Migration. 
迁移是Rails中ActiveRecord::Migration的子类。
When necessary, migrations can contain methods up() and down().
创建一个类时至少应该包含两个类的方法，up和down。
<kinder:note>想着change方法吧？别急，下面会谈到。

    class SomeMeaningfulName < ActiveRecord::Migration
      def up
        # ...
      end
      def down
        # ...
      end
    end

The name of the class, after all uppercase letters are downcased and preceded by an underscore, must match the portion of the filename after the version number.
类名必须与版本号的那部分文件名匹配，类名中所有大写字母都变为小写字母，每个词之间用下划线连接。
For example, the previous class could be found in a file named 20121130000017_some_meaningful_name.rb.
比如，上面这个类可以在先前的文件20121130000017_some_meaningful_name.rb中找到。
No two migrations can contain classes with the same name.
任意两个迁移不能包含相同的类名。

The up() method is responsible for applying the schema changes for this migration, while the down() method undoes those changes.
up方法负责应用这个迁移的纲要改变，down方法则负责撤销这些改变。
Let’s make this more concrete.
下面具体点来说。
Here’s a migration that adds an e_mail column to the orders table:
这个迁移在orders表中添加email字段。

    class AddEmailToOrders < ActiveRecord::Migration
      def up
        add_column :orders, :e_mail, :string
      end
      def down
        remove_column :orders, :e_mail
      end
    end

See how the down() method undoes the effect of the up() method?
看到down方法如何撤销up方法的改变了？

• 371

You can also see that there is a bit of duplication here.
<kinder:note> 这里是有些重复了。
In many cases, Rails can detect how to automatically undo a given operation.
<kinder:note> 在很多情况下，Rails知道怎么自动撤销一个指定的操作。
For example, the opposite of add_column() is clearly remove_column().
<kinder:note> 例如，add_column的对面显然就是remove_column。
In such cases, by simply renaming up() to change(), you can eliminate the need for a down().
<kinder:note> 在这样的情况下，up被重命名为change，也不需要down了。

    class AddEmailToOrders < ActiveRecord::Migration
      def change
        add_column :orders, :e_mail, :string
      end
    end

Now isn’t that much cleaner?
<kinder:note> 是不是更干净了？

### 23.2.1 Column Types 字段的类型
The third parameter to add_column specifies the type of the database column.
add_column的第三个参数指定了这个数据库字段的类型。
In the previous example, we specified that the e_mail column has a type of :string.
在先前的例子中，指定e_mail的类型为:string。
But just what does this mean? 
但这是什么意思呢？
Databases typically don’t have column types of :string.
通常数据库没有string这个类型的字段。

Remember that Rails tries to make your application independent of the underlying database; you could develop using SQLite 3 and deploy to Postgres if you wanted, for example.
记得Rails尝试让程序和底层数据库相互独立的事情吧；例如可以使用SQLite3开发，然后根据个人喜好部署到Postgres上。
But different databases use different names for the types of columns.
但不同的数据库使用不同的名称作为字段的类型。
If you used a SQLite 3 column type in a migration, that migration might not work if applied to a Postgres database.
如果在迁移中使用SQLite 3的字段类型，那么这个迁移在应用到Postgres数据库后可能无法运行。
So, Rails migrations insulate you from the underlying database type systems by using logical types.
所以，Rails通过使用逻辑类型来把用户和底层数据库类型系统隔离开。
If we’re migrating a SQLite 3 database, the :string type will create a column of type varchar(255).
如果迁移到SQLite 3数据库，那么:string类型将创建一个varchar(255)的字段。
On Postgres, the same migration adds a column with the type charvarying(255).
而在Postgres，相同的迁移会添加一个charvarying(255)的字段。

#### 数据库适配器的类型映射
The types supported by migrations are :binary, :boolean, :date, :datetime, :decimal, :float, :integer, :string, :text, :time, and :timestamp.
迁移支持的类型有:binary, :boolean, :date, :datetime, :decimal, :float, :integer, :string, :text, :time, :timestamp。
The default mappings of these types for the database adapters in Rails are shown in Table 2, Default mappings of types for database adapters, part 1, on page 372 and Table 3, Default mappings of types for database adapters, part 2, on page 372.
<kinder:note> 下面2个表格展示Rails里数据库适配器这些类型的默认映射。
Using these tables, you could work out that a column declared to be :integer in a migration would have the underlying type integer in SQLite 3 and number(38) in Oracle.
查看这个图，会发现在迁移中声明为:integer的字段将在SQLite 3中变成了integer类型，而在Oracle中则为number（38）。

• 372

            db2            mysql         openbase     oracle
:binary     blob(32768)    blob          object       blob
:boolean    decimal(1)     tinyint(1)    boolean      number(1)
:date       date           date          date         date
:datetime   timestamp      datetime      datetime     date
:decimal    decimal        decimal       decimal      decimal
:float      float          float         float        number
:integer    int            int(11)       integer      number(38)
:string     varchar(255)   varchar(255)  char(4096)   varchar2(255)
:text       clob(32768)    text          text         clob
:time       time           time          time         date
:timestamp  timestamp      datetime      timestamp    date
Table 2—Default mappings of types for database adapters, part 1
表格2——数据库适配器的默认类型映射，第一部分

            postgresql    sqlite        sqlserver     sybase
:binary     bytea         blob          image         image 
:boolean    boolean       boolean       bit           bit 
:date       date          date          date          datetime
:datetime   timestamp     datetime      datetime      datetime
:decimal    decimal       decimal       decimal       decimal
:float      float         float         float(8)      float(8) 
:integer    integer       integer       int           int 
:string     (note 1)      varchar(255)  varchar(255)  varchar(255)
:text       text          text          text          text 
:time       time          datetime      time          time 
:timestamp  timestamp     datetime      datetime      timestamp
Table 3—Default mappings of types for database adapters, part 2
表格3——数据库适配器的默认类型映射，第二部分

• 373

There are three options you can use when defining most columns in a migration; decimal columns take an additional two options.
迁移中定义大多数字段时，可以指定至多三个选项；decimal字段可以有多两个选项。
Each of these options is given as a key: value pair.
每个选项以键:值对的形式给出。
The common options are as follows: 
常用选项如下：
#### null: true or false
If false, the underlying column has a not null constraint added (if the database supports it).
如果定义为false，则这个底层字段有一个not nul的约束（如果数据库支持not
null约束）。

Note: this is independent of any presence: true validation, which may be performed at the model layer.
<kinder:note> 注意，这个选项依赖`presence: true`验证，该验证模型层面上执行。

#### limit: size
This sets a limit on the size of the field.
为字段设置一个大小限制。
This basically appends the string (size) to the database column type definition.
这个基本上用于追加字符串（size）到数据库的字段类型定义中。

### default: value
This sets the default value for the column.
为该字段设置默认值。
As this is performed by the database, you don’t see this in a new model object when you initialize it or even when you save it.
<kinder:note> 由于这是数据库操作的，初始化甚至保存新模型对象时，你看不到这一点。
You have to reload the object from the database to see this value.
<kinder:note> 你必须从数据库中重载对象才能看到这个值。
Note that the default is calculated once, at the point the migration is run, so the following code will set the default column value to the date and time when the migration was run:
注意，在迁移时，这个默认值将进行一次计算，因此下面这行代码把默认字段的值设置为迁移运行时的日期和时间。

    add_column :orders, :placed_at, :datetime, default: Time.now

In addition, decimal columns take the options :precision and :scale.
另外，十进制数字字段还有两个选项:precision和:scale。
The :precision option specifies the number of significant digits that will be stored, and the :scale option determines where the decimal point will be located in these digits (think of the scale as the number of digits after the decimal point).
:precision用来指定要保存的有效位数，而:scale选项决定这些数字中小数点的所在位置（可以把它看作是小数点后的有效数字）。
A decimal number with a precision of 5 and a scale of 0 can store numbers from -99,999 to +99,999.
一个precision为5,scale为0的十进制数可以存储从-99999到+99999的数。
A decimal number with a precision of 5 and a scale of 2 can store the range -999.99 to +999.99.
一个precision为5 scale为2的十进制数可以存储-999.99到+999.99的数。

The :precision and :scale parameters are optional for decimal columns.
:precision和:scale参数是十进制数字字段的选项。
However, incompatibilities between different databases lead us to strongly recommend that you include the options for each decimal column.
但是，由于不同数据库间的不兼容，这里**强力推荐每个十进制数字字段都包含这两个选项**。

Here are some column definitions using the migration types and options:
下面是使用迁移类型和选项定义的一些字段：

    add_column :orders, :attn, :string, limit: 100
    add_column :orders, :order_type, :integer
    add_column :orders, :ship_class, :string, null: false, default: 'priority'
    add_column :orders, :amount, :decimal, precision: 8, scale: 2

### 23.2.2 Renaming Columns 重命名字段
When we refactor our code, we often change our variable names to make them more meaningful.
在重构代码时，经常会改变变量名，让它们更有意义。
Rails migrations allow us to do this to database column names, too.
Rails迁移也允许修改数据库字段名。
For example, a week after we first added it, we might decide that e_mail isn’t the best name for the new column.
比如，在添加e_mail字段一周后，可能会觉得它不是最后的名称。
We can create a migration to rename it using the rename_column() method.
那就可以创建一个迁移，使用rename_column方法：

    class RenameEmailColumn < ActiveRecord::Migration
      def change
        rename_column :orders, :e_mail, :customer_email
      end
    end

• 374

As rename_column() is reversible, separate up() and down() methods are not required in order to use it.
<kinder:note> 因为rename_column是可逆的，就没有必要使用up和down方法了。
Note that the rename doesn’t destroy any existing data associated with the column.
注意重命名没有损坏任何与这个字段相关的现存数据。
Also be aware that renaming is not supported by all the adapters.
另外要知道，不是所有的适配器都支持重命名。
<kinder:note> 哪些不支持？详细的资料有没有？

### 23.2.3 Changing Columns 修改字段
Use the change_column() method to change the type of a column or to alter the options associated with a column.
使用change_column方法可以修改字段的类型，或者改变与字段相关的选项。

Use it the same way you’d use add_column, but specify the name of an existing column.
change_column的使用方法与add_column相同，但它要指定一个现有的字段名。
Let’s say that the order type column is currently an integer, but we need to change it to be a string.
例如，现在是整数类型的订单字段要改为字符串类型。
We want to keep the existing data, so an order type of 123 will become the string "123".
因为想要保存现有数据，因此订单类型123的将改为字符串123。
Later, we’ll use noninteger values such as "new" and "existing".
之后将使用非整数值，如new和existing。
Changing from an integer column to a string is easy.
从整数字段转到字符串字段很简单。

    def up
      change_column :orders, :order_type, :string
    end

However, the opposite transformation is problematic.
不过，反向转换就有问题了。
We might be tempted to write the obvious down() migration.
可能需要尝试编写显式的down迁移。

    def down
      change_column :orders, :order_type, :integer
    end

But if our application has taken to storing data like "new" in this column, the down() method will lose it—"new" can’t be converted to an integer.
如果程序已经在这个字段中储存了new这样的数据，down函数将删除它——因为new不能转为一个数字。
If that’s acceptable, then the migration is acceptable as it stands.
如果这种做法可以接受，那么迁移也会进行。
If, however, we want to create a one-way migration—one that cannot be reversed—we’ll want to stop the down migration from being applied.
但如果想创建一个单向的迁移，即无法逆转的迁移，就需要在进行迁移时停止down迁移。
In this case, Rails provides a special exception that we can throw.
在这个例子中，Rails提供了一个特殊的异常供用户抛出。

    class ChangeOrderTypeToString < ActiveRecord::Migration
      def up
        change_column :orders, :order_type, :string, null: false
      end
      def down
        raise ActiveRecord::IrreversibleMigration
      end
    end

ActiveRecord::IrreversibleMigration is also the name of the exception that Rails will raise if you attempt to call a method that can’t be automatically reversed from within a change() method.
ActiveRecord::IrreversibleMigration也是异常的名称，如果在change方法里尝试调用一个不能自动删除方法时，Rails就会抛出该异常。

• 375

## 22.3 Managing Tables 表的管理
### 表的创建和删除
So far we’ve been using migrations to manipulate the columns in existing tables.
至此，已经使用了迁移来管理现存表中的字段。
Now let’s look at creating and dropping tables.
现在来看一看创建和删除表。

    class CreateOrderHistories < ActiveRecord::Migration
      def change
        create_table :order_histories do |t|
          t.integer :order_id, null: false
          t.text :notes
          t.timestamps
        end
      end
    end

create_table() takes the name of a table (remember, table names are plural) and a block.
create_table将取得表名（记住它是复数的）和块。
(It also takes some optional parameters that we’ll look at in a minute.) 
（它也会取得一些选项参数，这些参数马上会讨论到）
The block is passed a table definition object, which we use to define the columns in the table.
用于定义表中字段的表定义对象将被传入块中。

Generally the call to drop_table() is not needed, as add_table() is reversible.
<kinder:note> 一般没有必要调用drop_table，因为add_table是可逆的。
 drop_table() accepts a single parameter, which is the name of the table to drop.
<kinder:note> drop_table接受一个参数，即要删除的表的名称。

The calls to the various table definition methods should look familiar—they’re similar to the add_column method we used previously except these methods don’t take the name of the table as the first parameter, and the name of the method itself is the data type desired.
各种各样的表定义方法调用看起来很熟悉——它们和先前用过的add_column方法类似，只是这些方法不把表名作为第一个参数，方法本身的名称则是所需的数据类型。
This reduces repetition.
这可以减少重复。

Note that we don’t define the id column for our new table.
注意，新表里没有定义id字段。
Unless we say otherwise, Rails migrations automatically add a primary key called id to all tables they create.
除非明确指定，否则Rails迁移会自动在所有创建的表中添加一个id的主键。
For a deeper discussion of this, see Primary Keys, on page 378.
更多讨论看后面378页的23.3节

The timestamps method creates both the created_at and updated_at columns, with the correct timestamp data type.
timestamp方法创建了created_at和updated_at字段，这两个字段的数据类型均为正确的timestamp。
Although there is no requirement to add these columns to any particular table, this is yet another example of Rails making it easy for a common convention to be implemented easily and consistently.
尽管没有必要往任何特定表添加这些字段，但这是Rails方便、一致实施共同约定，从而简化开发过程的另一个例子。


### 23.3.1 Options for Creating Tables 表的创建选项
You can pass a hash of options as a second parameter to create_table.
可以将一个散列选项作为create_table的第二个参数传给它。
If you specify force: true, the migration will drop an existing table of the same name before creating the new one.
如果定义force: true选项，迁移会在创建这个新表前删除已有的同名表。
This is a useful option if you want to create a migration that forces a database into a known state, but there’s clearly a potential for data loss.
倘若想要创建一个迁移，并且这个迁移会强制数据库回到已知状态，这将是一个有用的选项，但显然也存在数据丢失的可能。

The temporary: true option creates a temporary table—one that goes away when the application disconnects from the database.
temporary: true选项将创建一个临时表——这个表将在应用程序与数据库断开时删除。
This is clearly pointless in the context of a migration, but as we will see later, it does have its uses elsewhere.
显然这在迁移中毫无意义，但后面可以看到它在某些其他方面还是有用的。

• 376

The options: "xxxx" parameter lets you specify options to your underlying database.
optins: "xxxx"参数用于为底层数据库指定选项。
They are added to the end of the CREATE TABLE statement, right after the closing parenthesis.
这些选项添加在CREATE TABLE语句的最后，紧接着在该语句结束的右括号后。
Although this is rarely necessary with SQLite 3, it may at times be useful with other database servers.
尽管这在SQLite3中没有必要，但有时这个选项对其他数据库还是游泳的。
For example, some versions of MySQL allow you to specify the initial value of the autoincrementing id column.
比如MySQL数据库的某些版本允许为自动递增的id属性指定初始值。
We can pass this in through a migration as follows:
可以这样通过迁移传入下列内容：

    create_table :tickets, options: "auto_increment = 10000" do |t|
      t.text :description
      t.timestamps
    end

Behind the scenes, migrations will generate the following DDL from this table description when configured for MySQL:
这种情况下，为MySQL配置时，从这个表的描述中，迁移会生成下面的DDL：

    CREATE TABLE "tickets" (
      "id" int(11) default null auto_increment primary key,
      "description" text,
      "created_at" datetime,
      "updated_at" datetime
    ) auto_increment = 10000;

Be careful when using the :options parameter with MySQL.
在MySQL中要小心使用options参数。
The Rails MySQL database adapter sets a default option of ENGINE=InnoDB.
Rails MySQL数据库适配器设置的默认选项为ENGINE=InnoDB。
This overrides any local defaults you may have and forces migrations to use the InnoDB storage engine for new tables.
刚才的命令重写了所有本地存在的默认值，强制迁移新表使用InnoDB存储引擎。
However, if you override :options, you’ll lose this setting; new tables will be created using whatever database engine is configured as the default for your site.
但是，如果重写了:options，这些设置都将遗失；创建新表时将使用该电脑配置的默认数据库引擎。
You may want to add an explicit ENGINE=InnoDB to the options string to force the standard behavior in this case.
这种情况下，需要显性添加ENGINE=InnoDB选项来强制定义标准行为。
You probably want to keep using InnoDB if you’re using MySQL, because this engine gives you transaction support.
如果使用MySQL，或许还想继续使用InnoDB，因为这个引擎支持事务。
You might need transaction support in your application, and you’ll definitely need it in your tests if you’re using the default of transactional test fixtures.
也许在应用程序中也需要支持事务，并且，如果使用默认的事务测试夹具，连测试都肯定需要事务。

### 23.3.2 Renaming Tables 重命名表
If refactoring leads us to rename variables and columns, then it’s probably not a surprise that we sometimes find ourselves renaming tables, too.
如果知道重构可以重命名变量和字段，重命名表也就不会那么令人吃惊了。
Migrations support the rename_table() method.
迁移支持rename_table方法。

    class RenameOrderHistories < ActiveRecord::Migration
      def change
        rename_table :order_histories, :order_notes
      end
    end

Rolling back this migration undoes the change by renaming the table back.
回滚迁移将撤销改变这个表的重命名。

• 377

### 23.3.3 Problems with rename_table rename_table方法的问题
There’s a subtle problem when we rename tables in migrations.
重命名表时有一个小问题。
For example, let’s assume that in migration 4 we create the order_histories table and populate it with some data.
例如，假设迁移4创建了order_histories表，并且保存了一些数据。

    def up
      create_table :order_histories do |t|
        t.integer :order_id, null: false
        t.text :notes
        t.timestamps
      end
      order = Order.find :first
      OrderHistory.create(order_id: order, notes: "test")
    end

Later, in migration 7, we rename the table order_histories to order_notes.
随后的迁移7中将表order_histories重命名为order_notes。
At this point we’ll also have renamed the model OrderHistory to OrderNote.
这是，也已经将模型OrderHistory改名为OrderNote。

Now we decide to drop our development database and reapply all migrations.
现在决定删除开发数据库，重新应用所有迁移。
<kinder:note> 这里说的是前面的《任务K：部署和产品环境》中16.1.4《加载数据库》一节中的迁移。
 When we do so, the migrations throw an exception in migration 4: our application no longer contains a class called OrderHistory, so the migration fails.
我们这么做时，迁移在迁移4中抛出一个异常：该应用程序不再包含OrderHistory类，因此迁移失败。

One solution, proposed by Tim Lucas, is to create local, dummy versions of the model classes needed by a migration within the migration.
Tim Lucas提出一种解决方案：创建一个在迁移过程中需要的本地虚拟版本模型类。
For example, the following version of the fourth migration will work even if the application no longer has an OrderHistory class.
例如，即使该应用程序不再包含OrderHistory类，下面的迁移4仍然有效。

    class CreateOrderHistories < ActiveRecord::Migration
    ➤ class Order < ActiveRecord::Base; end
    ➤ class OrderHistory < ActiveRecord::Base; end
      def change
        create_table :order_histories do |t|
          t.integer :order_id, null: false
          t.text :notes
          t.timestamps
        end
        order = Order.find :first
        OrderHistory.create(order: order_id, notes: "test")
      end
    end

This works as long as our model classes do not contain any additional functionality that would have been used in the migration—all we’re creating here is a bare-bones version.
只要该模型类中不包含任何额外的在迁移中使用的功能，那么上述内容都将正常工作——这里创建的所有内容是最基本的版本。

• 378

### 23.3.4 Defining Indices 定义索引
Migrations can (and probably should) define indices for tables.
迁移可以（或者可能说“应该”）为表定义索引。
For example, we might notice that once our application has a large number of orders in the database, searching based on the customer’s name takes longer than we’d like.
例如，我们可能注意到，一旦应用程序在数据库中有大量订单，使用顾客名称进行搜索将浪费过多的时间。
It’s time to add an index using the appropriately named add_index() method.
这就应该使用刚好叫做add_index的方法来添加一个索引：


    class AddCustomerNameIndexToOrders < ActiveRecord::Migration
      def change
        add_index :orders, :name
      end
    end

If we give add_index the optional parameter unique: true, a unique index will be created, forcing values in the indexed column to be unique.
如果给add_index传入可选参数unique: true，将会创建唯一索引，强制索引字段中的所有值变成唯一值。

By default the index will be given the name index_table_on_column.
默认情况下，索引的名字为index_table_on_column。
We can override this using the name: "somename" option.
可以使用name: "xxxx"选项来重命名名称。
If we use the :name option when adding an index, we’ll also need to specify it when removing the index.
如果在添加索引时使用:name选项， 也需要定义何时删除这个索引。

We can create a composite index—an index on multiple columns—by passing an array of column names to add_index.
通过在add_index中传入一个包含字段名的数组，可以创建一个复合索引，即多个字段的索引。
In this case, only the first column name will be used when naming the index.
在这种情况下，命名该索引时只使用第一个字段名。
<kinder:note> 如在需要索引a b c d四个字段，则索引命名为"index_table_on_a"，而不是“index_table_on_a_b_c_d”。

Indices are removed using the remove_index() method.
使用remove_index方法可删除索引。

### 23.3.5 Primary Keys 主键
Rails assumes every table has a numeric primary key (normally called id) and ensures the value of this column is unique for each new row added to a table.
Rails假设每个表都有一个数字主键（通常为id），并且确保每个新加入到这个表中的行在这个字段的值是唯一的。
We’ll rephrase that.
下面将措辞修改一下：
Rails really doesn’t work too well unless each table has a numeric primary key.
除非每个表都有一个数字主键，否则Rails真的不能工作。
It is less fussy about the name of the column.
它对字段名不挑剔。
So, for your average Rails application, our strong advice is to go with the flow and let Rails have its id column.
所以，对于一般的Rails程序来说，强烈推荐这样做：跟随流程，让Rails自己拥有自己的id字段。

If you decide to be adventurous, you can start by using a different name for the primary key column (but keeping it as an incrementing integer).
如果想要冒险，可以从使用不同的主键字段名开始（但得先保证这个字段是递增的数字）。
Do this by specifying a :primary_key option on the create_table call.
通过在create_table调用中指定:primary_key选项可以做到。

    create_table :tickets, primary_key: :number do |t|
      t.text :description
      t.timestamps
    end

• 379

This adds the number column to the table and sets it up as the primary key.
这段代码把number字段添加到表中，并且设置为主键。

    $ sqlite3 db/development.sqlite3 ".schema tickets"
    CREATE TABLE tickets ("number" INTEGER PRIMARY KEY AUTOINCREMENT
    NOT NULL, "description" text DEFAULT NULL, "created_at" datetime
    DEFAULT NULL, "updated_at" datetime DEFAULT NULL);

The next step in the adventure might be to create a primary key that isn’t an integer.
冒险的下一步是尝试创建一个不是整数的主键。
Here’s a clue that the Rails developers don’t think this is a good idea:
Rails开发者们并不认为这是一个好主意，原因大概是：
migrations don’t let you do this (at least not directly).
迁移不允许这么做（至少不能直接这么做）。
<kinder:note> 间接呢？是指把字段从数字类型改为string类型？

### 23.3.6 Tables with No Primary Key 没有主键的表
Sometimes we may need to define a table that has no primary key.
有时可能需要定义一个没有主键的表。
The most common case in Rails is for join tables—tables with just two columns where each column is a foreign key to another table.
在Rails中最常见的情况是连接表——这些表只有两个字段，每个字段是另一个表的外键。
<kinder:note> 参见前面19.2节介绍一对多关联
To create a join table using migrations, we have to tell Rails not to automatically add an id column.
要使用迁移创建一个连接表，必须告诉Rails不要自动添加id字段。

    create_table :authors_books, id: false do |t|
      t.integer :author_id, null: false
      null: false
      t.integer :book_id,
    end

In this case, you might want to investigate creating one or more indices on this table to speed navigation between books and authors.
在这种情况下，可能会想在表中创建一个或多个索引，用以提高books表和authors之间 的导航速度。

## 22.4 Advanced Migrations 高级迁移
Most Rails developers use the basic facilities of migrations to create and maintain their database schemas.
大多数Rails开发者使用基本的迁移设施来创建和维护数据库纲要。
However, every now and then it’s useful to push migrations just a bit further.
但是，无论现在还是将来，使用高级迁移都是有用的。
This section covers some more advanced migration usage.
这一节介绍一些更高级的迁移用法。

### 23.4.1 Using Native SQL 使用原生SQL
Migrations give you a database-independent way of maintaining your application’s schema.
迁移让数据库与应用程序的纲要之间互相独立。
However, if migrations don’t contain the methods you need to be able to do what you need to do, you’ll need to drop down to databasespecific code.
但是，如果迁移没有包含所需的方法，就得深入到数据库的特定代码中。
Rails provides two ways to do this.
Rails提供了两种方法。
One is with options arguments to methods like add_column().
第一种是在诸如add_column方法中加入options参数。
The second is the execute() method.
第二种是execute方法。

When you use options or execute(), you might well be tying your migration to a specific database engine, because any SQL you provide in these two locations uses your database’s native syntax.
使用options和execute时，由于所提供的这两个位置的所有SQL都使用数据库的原生语法，因此可以尝试把迁移与一个特定的数据库引擎紧密地结合起来。
A common example in our migrations is the addition of foreign key constraints to a child table.
一个常见的迁移例子是**将外键约束添加到子表中**。

• 380

We could do this by adding a method such as the following to our migration source file:
可以把如下方法添加到迁移的源文件中来完成这个例子。

    def foreign_key(from_table, from_column, to_table)
      constraint_name = "fk_#{from_table}_#{to_table}"
    
      execute %{
        CREATE TRIGGER #{constraint_name}_insert
        BEFORE INSERT ON #{from_table}
        FOR EACH ROW BEGIN
          SELECT
            RAISE(ABORT, "constraint violation: #{constraint_name}")
          WHERE
            (SELECT id FROM #{to_table} WHERE
              id = NEW.#{from_column}) IS NULL;
        END;
      }
    
      execute %{
        CREATE TRIGGER #{constraint_name}_update
        BEFORE UPDATE ON #{from_table}
        FOR EACH ROW BEGIN
          SELECT
            RAISE(ABORT, "constraint violation: #{constraint_name}")
          WHERE
            (SELECT id FROM #{to_table} WHERE
              id = NEW.#{from_column}) IS NULL;
        END;
      }
    
      execute %{
        CREATE TRIGGER #{constraint_name}_delete
        BEFORE DELETE ON #{to_table}
        FOR EACH ROW BEGIN
          SELECT
            RAISE(ABORT, "constraint violation: #{constraint_name}")
          WHERE
            (SELECT id FROM #{from_table} WHERE
              #{from_column} = OLD.id) IS NOT NULL;
        END;
      }
    end

Within the up() migration, we can call this new method using this:
在up迁移中，可以使用下面的方法调用新方法：

    def up
      create_table ... do
      end
      foreign_key(:line_items, :product_id, :products)
      foreign_key(:line_items, :order_id, :orders)
    end

• 381

However, we may want to go a step further and make our foreign_key() method available to all our migrations.
不过，也许可以更进一步，让所有迁移都可以使用foreign_key方法。
To do this, create a module in the application’s lib directory, and add the foreign_key() method.
要实现它，可以在程序的lib目录下创建一个模板，然后添加foreign_key方法。

This time, however, make it a regular instance method, not a class method.
这时，foreign_key方法变成了一个普通的实例方法，不是一个类方法了。

    module MigrationHelpers
        def foreign_key(from_table, from_column, to_table)
          constraint_name = "fk_#{from_table}_#{to_table}"
          execute %{
            CREATE TRIGGER #{constraint_name}_insert
            BEFORE INSERT ON #{from_table}
            FOR EACH ROW BEGIN
              SELECT
                RAISE(ABORT, "constraint violation: #{constraint_name}")
              WHERE
                (SELECT id FROM #{to_table} WHERE id = NEW.#{from_column}) IS NULL;
            END;
          }
          execute %{
            CREATE TRIGGER #{constraint_name}_update
            BEFORE UPDATE ON #{from_table}
            FOR EACH ROW BEGIN
              SELECT
                RAISE(ABORT, "constraint violation: #{constraint_name}")
              WHERE
                (SELECT id FROM #{to_table} WHERE id = NEW.#{from_column}) IS NULL;
            END;
          }
          execute %{
            CREATE TRIGGER #{constraint_name}_delete
            BEFORE DELETE ON #{to_table}
            FOR EACH ROW BEGIN
              SELECT
                RAISE(ABORT, "constraint violation: #{constraint_name}")
              WHERE
                (SELECT id FROM #{from_table} WHERE #{from_column} = OLD.id) IS NOT NULL;
            END;
          }
          end
        end

We can now add this to any migration by adding the following lines to the top of our migration file:
现在，在该迁移文件的最上方添加如下内容，就可以将它添加到任何迁移中了。

    ➤ require "migration_helpers"

    class CreateLineItems < ActiveRecord::Migration
    ➤ extend MigrationHelpers


• 382

The require line brings the module definition into the migration’s code, and the extend line adds the methods in the MigrationHelpers module into the migration as class methods.
包含require的一行将模块定义添加到迁移代码中，extend那一行将MigrationHelpers模块的方法作为类的方法添加到迁移中。
We can use this technique to develop and share any number of migration helpers.
使用这个技术，就可以开发并且共享任何数量的迁移辅助器了。

(And, if you’d like to make your life even easier, someone has written a plugin1 that automatically handles adding foreign key constraints.) 
（另外，有人写了一个插件，可以自动处理添加外键约定的事情；如果生活更简单，可以参考它。）

[1].  https://github.com/matthuhiggins/foreigner

### 23.4.3 Custom Messages and Benchmarks 自定义消息和基准测试程序
Although not exactly an advanced migration, something that is useful to do within advanced migrations is to output our own messages and benchmarks.
虽然这不全是一个高级迁移该有的内容，但有时在高级迁移中输出自己的信息和基准测试程序是很有用的。
We can do this with the say_with_time() method.
可以用say_with_time方法来实现：

    def up
      say_with_time "Updating prices..." do
        Person.all.each do |p|
          p.update_attribute :price, p.lookup_master_price
        end
      end
    end

say_with_time() prints the string passed before the block is executed and prints the benchmark after the block completes.
say_with_time方法将输出块代码执行前传入的字符串，并且在该块完成后输出基准测试程序。
<kinder:note> 不大能理解。什么时候运行一下？嗯，怎么运行？

## 22.5 When Migrations Go Bad 迁移变糟时
Migrations suffer from one serious problem.
迁移有一个严重的问题。
The underlying DDL statements that update the database schema are not transactional.
用于更新数据库纲要的底层DDL语句并不是事务性的。
This isn’t a failing in Rails—most databases just don’t support the rolling back of create table, alter table, and other DDL statements.
当然，这不是Rails的缺陷——大多数的数据库都不支持创建表、更改表或其他DDL语句的回滚。

Let’s look at a migration that tries to add two tables to a database:
看看迁移尝试在数据库中添加两个表的情况。

    class ExampleMigration < ActiveRecord::Migration
      def change
        create_table :one do ...
        end
        create_table :two do ...
        end
      end
    end

In the normal course of events, the up() method adds tables, one and two, and the down() method removes them.
在事件的正常过程中，up方法添加表one和表two，down方法则删除它们。

• 383

But what happens if there’s a problem creating the second table? 
倘若在创建第二个表的时候出现问题，将会发生什么？
We’ll end up with a database containing table one but not table two.
我们会最终得到一个包含表one但不含表two的数据库。
We can fix whatever the problem is in the migration, but now we can’t apply it—if we try, it will fail because table one already exists.
当然，迁移中的任何问题都可以修复，但这个问题除外——如果想再试一次，也会失败，因为表one已经存在。

We could try to roll the migration back, but that won’t work.
可以尝试回滚迁移，但也不会奏效。
Because the original migration failed, the schema version in the database wasn’t updated, so Rails won’t try to roll it back.
因为初始的迁移失败，数据库的纲要版本并没有更新，因此Rails不会回滚。

At this point, you could mess around and manually change the schema information and drop table one.
这时，也许事情已经一团糟了，那就手动修改纲要信息，删除表one。
But it probably isn’t worth it.
但这么做太不值得。
Our recommendation in these circumstances is simply to drop the entire database, re-create it, and apply migrations to bring it back up-to-date.
我们推荐的做法是，删除整个数据库，再重建这个数据库，接着应用迁移让他回滚到先前的版本。
<kinder:note> 整个？之前的数据都得放到种子里了，要不肯定丢失。
<kinder:note> 还有，这个工程是不是太大了——假如数据库里面已经有了上百个表。
You’ll have lost nothing, and you’ll know you have a consistent schema.
这样毫无损失，还可以得到一个一致的纲要。
All this discussion suggests that migrations are dangerous to use on production databases.
在这个讨论中的所有内容都表明，在生产数据中使用迁移是很危险的。
Should you run them? We really can’t say.
该不该运行它们？还真说不准。
If you have database administrators in your organization, it’ll be their call.
如果在组织中有数据库管理员，请他帮忙会是很好的办法。
If it’s up to you, you’ll have to weigh the risks.
如果必须自己解决问题，那就得衡量风险了。
But, if you decide to go for it, you really must back up your database first.
但是，如果决定这么做，请切记一定要先备份数据库。
Then, you can apply the migrations by going to your application’s directory on the machine with the database role on your production servers and executing this command:
然后才可以到那台承载生产的服务器上，在该程序目录下执行迁移，输入下面的命令。

    depot> RAILS_ENV=production rake db:migrate

This is one of those times where the legal notice at the start of this book kicks in.
这是本书开始时的免责声明所述内容的一种情况。
We’re not liable if this deletes your data.
如果该操作删除了你的数据，我们不承担任何责任哦。

## 22.6 Schema Manipulation Outside Migrations 迁移外的纲要管理
<kinder:note> 挺有意思。除了下面索引的例子，还有什么例子呢？
All the migration methods described so far in this chapter are also available as methods on Active Record connection objects and so are accessible within the models, views, and controllers of a Rails application.
到目前为止，**本章内讨论过的所有迁移都可以作为Active Record模块connection对象上的方法使用**，因此也支持Rails应用程序模型、视图和控制器内的访问。
For example, you might have discovered that a particular long-running report runs a lot faster if the orders table has an index on the city column.
比如，如果orders表在city字段有一个索引，你可能会发现某个详细的长期运行报告的运行速度提高了很多。
However, that index isn’t needed during the day-to-day running of the application, and tests have shown that maintaining it slows the application appreciably.
不过，在日常的应用程序运行中并不需要那个索引，并且还有测试表明，对该索引的维护明显减慢了该程序的速度。

Let’s write a method that creates the index, runs a block of code, and then drops the index.
可以编写一个方法，这个方法将创建这个索引，然后运行一个代码块，最后删除这个索引。
This could be a private method in the model or could be implemented in a library.
它可以是一个模型内的私有方法，也可以是库里执行的方法。

• 384

    def run_with_index(*columns)
      connection.add_index(:orders, *columns)
      begin
        yield
      ensure
        connection.remove_index(:orders, *columns)
      end
    end

The statistics-gathering method in the model can use this as follows:
模型中统计数据收集的方法，可以使用如下代码：

    def get_city_statistics
      run_with_index(:city) do
        # .. calculate stats
      end
    end

## What We Just Did 本章小结
While we had been informally using migrations throughout the development of the Depot application and even into deployment, in this chapter we saw how migrations are the basis for a principled and disciplined approach to configuration management of the schema for your database.
在Depot程序的整个开发过程中，甚至在部署过程中，已经非正式地使用了迁移，而在本章中展示了迁移如何作为基础，来有原则、有纪律地配置管理数据库纲要。
You learned how to create, rename, and delete columns and tables; to manage indices and keys; to apply and back out entire sets of changes; and even to mix in your own custom SQL into the mix, all in a completely reproducible manner.
本章讨论了如何创建、重命名、删除字段和表；管理索引和键；应用和撤销整组改变；甚至是混合自定义的SQL，所有操作步骤都是完全可重现的。
At this point we’ve covered the externals of Rails.
到这里，已经介绍完了Rails的外部。
The next few chapters are going to delve deeper.
接下来的几章会更深入些。
We are going to show you how to take Rails apart and put it back together.
这些章节会展示如何将Rails拆散，以及如何将其重组在一起。
The first stop along the way is to show you how to use select Rails classes and methods outside the context of a web server.
第一站会讨论在Web服务器环境外，如何使用选择Rails类和方法。

# CHAPTER 23 Nonbrowser Applications 非浏览器应用
## In this chapter, we’ll see
   在这一章，我们将学习：
• invoking Rails methods,
  调用Rails的方法
• accessing Rails application data, and
  访问Rails程序的数据
• manipulating databases remotely.
  操作远程数据库

Previous chapters focused primarily on server-to-human communications, mostly via HTML.
之前的章节主要关注服务器和使用者之间的通信，这种通信主要是通过html协议进行的。
But not all web interactions need to directly involve a person.
然而并非所有基于web的通信都需要用户直接参数。
This chapter focuses on accessing your Rails application and data from within a stand-alone script.
本章将集中讨论如何从一个独立的脚本程序里访问你的Rails程序及其数据。

There are a variety of reasons why you might want to access portions of your Rails application from outside a browser.
不想使用浏览器访问Rails程序的原因有很多。
For example, you may desire to have your database loaded or synchronized periodically using a background job kicked off by a utility like cron.
例如，如果只想装载数据库或者周期性地同步数据库，使用cron这样的后台工具就可以了。
You may have existing applications, perhaps even Rails applications, that want to directly access the data in (another) Rails application, possibly even on a different machine.
又如，现有程序甚至是Rails程序想要直接访问另一个或同一个机器上的Rails程序的数据。
You might just want a command-line interface, not because it is required but just because.
因为某种必要的原因只想要命令行界面。

Whatever your reasons, Rails is there for you.
无论理由是什么，Rails始终都在那里。
As you will see, you will be able to pull in as little or as much of Rails as you need to get your job done.
正如下文可见，下面的工作或多或少都会和Rails相关。
We will start with the assumption that your application is on the same machine as your installation of Rails and your data, and then we will proceed to describing how you can do the same things on a remote machine.
开始之前，先假设程序和安装Rails以及存储的数据，三者都在同一台机器上。然后阐述怎么在远程机器上做相同的工作。

## 23.1 A Stand-Alone Application Using Active Record 开发独立程序
One of the first things you will want unfettered access to is your data.
第一件想要做的事情是不受制约地访问数据。
You will be pleased to know that you can make full use of Active Record from within a stand-alone application.
可以在独立程序内充分利用Active Record的特性轻松完成这件事。
First, we will show you the “hard” way to do so (the “scare quotes” is because it isn’t all that hard—remember it is Rails we are talking about here, after all).
首先看看如何实现“硬”编程方式（之所以加上引号，是因为它们并不是真的难以扩展——毕竟这里是Rails）。
Then we will show you the easy way.
然后使用简易方法进行编程。

We will start with a stand-alone program that uses Active Record to wrap a table of orders in a SQLite 3 database.
下面将编写独立程序，使用Active Record来封装SQLite3数据库订单表。

• 386 

After finding the order with a particular id, it modifies the purchaser’s name and saves the result in the database, updating the original row.
该独立程序在找到特定id订单后，修改购买者姓名，且在数据库中保存其结果，同时更新原始记录。

    require "active_record"
    ActiveRecord::Base.establish_connection(adapter: "sqlite3",
      database: "db/development.sqlite3")
      class Order < ActiveRecord::Base
      end
      order = Order.find(1)
      order.name = "Dave Thomas"
      order.save

That’s all there is to it—in this case no configuration information (apart from the database connection stuff) is required.
这就是全部代码——这种情况不需要什么配置信息（除了数据库连接部分）。
Active Record figured out what we needed based on the database schema and took care of all the necessary details.
Active Record从数据库纲要本身已获得了所有需要的信息，且已考虑到了所有必要的细节。

Now that you have seen the “hard” way, let’s see the easy way—the one where Rails will handle the connection for you and load all of your models.
现在已经看到了“硬”的方式，接着来看看简单的方式，Rails将处理数据库的连接，并载入所有模型。

    require "config/environment.rb"
    order = Order.find(1)
    order.name = "Dave Thomas"
    order.save

For this to work, Ruby will need to find the config/environment.rb file for the application you want to load.
为了装载程序，ruby需要查找到config/environment.rb文件，它包含了此程序的有关设置。
You can do this by specifying the full path to this file on the require statement or by including the path in the RUBYLIB environment variable.
可以require语句将此泛民的完整路径列出来，或在RUBYLIB环境变量中包含该文件的路径。
Another environment variable to watch out for is RAILS_ENV, which is used to select from the development, test, and production environments.
需要注意的另一个环境变量是RAILS_ENV，用来区分开发、测试和生产环境。

Once we have required this one file, we have access to roughly the same parts of our applications as we did when we used rails console in Would the Last Admin to Leave…, on page 205.
一旦导入了文件，就可以在大体上访问程序的上述组件，这种做法和前面205页14.4节《最后一个管理员》的介绍是一样的。

That was done all with a single require.
使用单个require语句就已经完成。
It couldn’t be easier.
再也没有比这更容易的事情了。
But believe it or not, at times you will want to access only a portion of the features that Rails provides, outside the context of a Rails application.
不过不管是否相信，有时只想访问Rails所提供的部分功能，这些功能在rails程序的环境之外。
We cover that next.
接下来将讨论这个问题。

## 23.2 A Library Function Using Active Support 使用Active Support库功能
### 在非rails程序中不能运行的秘密
Active Support is a set of libraries shared by all Rails components.
Active Support是所有Rails组件的共享库。
Some of what’s in there is intended for Rails’ internal use; however, all of it is available for use by non-Rails applications.
里面有些库专在rails内部使用，不过所有的共享库都可用于非rails程序。

• 387

This could be important if you develop a Rails application and in the course of that development you produce a set of classes or even just a set of methods that you would like to make use of in a non-Rails application.
认识这一点很重要，例如开发rails程序过程中，产生一组类或者只是一组方法，但想在非rails程序中使用它们。
You start by copying and pasting this code into a separate file and then find out that it doesn’t run—not because this logic is dependent on your application in any way but because it uses other methods and classes that Rails provides.
你开始复制并粘帖这段代码到单独的文件中，发现不能运行——这不是因为代码在逻辑上与原先的程序有任何依赖，而是它使用了Rails所提供的其他方法和类。

We will start with a brief survey of some of the most important of these and
along the way show how they can be made available to your application.
下面将开始简短说明这个库的一些最重要的内容，以及这些内容如何为程序服务。

### 24.2.1 Core Extensions (core-ext) 核心扩展
Active Support extends some of Ruby’s built-in classes in interesting and useful ways.
Active Support扩展了一些ruby内置类，有趣又有用。
In this section, we’ll quickly list the most popular of these core extensions.
这一节将列出最常见的核心扩展。

• Array: second(), third(), fourth(), fifth(), and forty_two().
  数组：第二个、第三个、第四个、第五个，第四十二个
These complement the first() and last() methods provided by Ruby.
这些方法补充了ruby提供的fist、last方法。

• CGI: escape_skipping_slashes().
  CGI: 正斜杠不转义的转义方法
As the name implies, it differs from escape() in that it doesn’t escape slashes.
顾名思义，和escape的区别是不能转义斜杠。

• Class: Accessors for class attributes, delegating accessors, inheritable readers and writers, and descendants (aka subclasses).
  类：类属性的存取方法、代理存取方法、继承读写方法和子类方法。
These methods are too numerous to enumerate; see the documentation for details.
这些方法太多，无法一一列举，详见相关文档。


• Date: yesterday(), future?(), next_month(), and many, many more.
  日期：昨日、是否未来、下个月等等。

• Enumerable: group_by(), sum(), each_with_object(), index_by(), many?(), and exclude?().
  可枚举：按什么分组、总计、带对象的每一个、按什么索引，是否多个、是否包含

• File: atomic_write() and path().
  文件：原子方式写入、文件路径

• Float: Adds an optional precision argument to round().
  浮点精度数： 为round方法添加可选的精度参数。

• Hash: deep_merge(), except(), stringify_keys(), symbolize_keys(), reverse_merge(), and slice(). 
  散列：深度合并、除外、键字符化、键符号化、反向合并、切片。

Many of these methods also have variants ending in an exclamation point.
这些方法的大部分都有感叹号结尾的变体方法。

• Integer: ordinalize(), multiple_of?(). months(), years(). See also Numeric.
  整数： 整数序数、是否倍数、月、年。另见Numeric。

• Kernel: debugger(), breakpoint(). silence_warnings(), enable_warnings().
  内核： 调试器、断点、警告静默、启用警告

• Module: Accessors for module attributes, aliasing support, delegation, deprecation, internal readers and writers, synchronization, and parentage.
  模块：模块属性的存储器、别名支持、代理、过时、内部读写器、同步、亲缘。

• Numeric: bytes(), kilobytes(), megabytes(), and so on; seconds(), minutes(), hours(), and so on.
  数字：字节、千字节、兆字节等；秒、分、时等。


• 388

• Object: blank?(), present?(), duplicable?(), instance_values(), instance_variable_names(), returning(), and try().
  对象：是否为空、是否存在、是否可复制、实例变量的值、实例变量的名称、返回中、尝试。
<kinder:note> 原文是`instance_variable_() names()`。是笔误。
<kinder:note> 2版中文译者注：最新Rails3.0.3以后版本源代码已经没有returning方法，最好用tag方法。

• String: exclude?(), pluralize(), singularize(), camelize(), titleize(), underscore(), dasherize(), demodulize(), parameterize(), tableize(), classify(), humanize(), foreign_key(), constantize(), squish(), mb_chars(), at?(), from(), to(), first(), last(), to_time(), to_date(), and try().
  字符串：是否不包含、名词复数、名词单数、转为骆驼拼法、单词首字大写、下划线分割、短横线分割、去掉模块名双冒号之前的名称、参数化（替换特殊符号可组成URL）、转成下划线分割、去下划线、去下划线、下划线转空格、外键id、常数、挤压空行空格、多字节字符、字符位置、从、到、第一个字母、最后一个字母、转成时间、转成日期、尝试。
<kinder:note> 2版中文译注：其实Rails中并没有英文原版书中的at?方法。
<kinder:note> 应该是at方法。at?方法应该也是笔误。
• Time: yesterday(), future?(), advance(), and many, many more.
  时间：昨日，是否未来，之前等等。

As you can see, this is a fairly long list.
正如你所见到的，这个清单很长。
These methods tend to be fairly small; many are only a single line of code.
这些方法相当简洁，其中很多方法的源代码只有一行。
Although you will probably only ever use a small percentage of these methods, all of them are available for use in your Rails application.
虽然你用到它们的机会很少，但它们在程序中已经准备就绪了。

As you can also see, there is a lot there.
也正如你所见，还有许多方法。
Most of it you won’t ever directly use.
大部分方法你不会直接用到。
 However, you’ll quickly find yourself adopting a small portion of these additional methods as if they were part of the Ruby language.
不过，这些附加方法的一小部分用起来就像ruby语言自身的方法一样。
Although all of these methods are documented online,[1] the best way to learn is often to experiment directly by using rails console.
尽管可以在在线文档中找到所有方法，但最好的学习方式仍是直接在控制台里多加练习。
[1].  http://api.rubyonrails.org/classes/ActiveSupport.html
Here are a few things to try:
这里是一些例子。

• 2.years.ago
• [1,2,3,4].sum
• 5.gigabytes
• "man".pluralize
• String.methods.sort

Because there is no one best way to identify what subset works for you, simply be aware that these methods exist, and check the documentation when you find yourself with what seems to be a common need because the Rails developers may have already added the method that you find missing.
因为没有一种最好的方式来确定哪些子集是有用的，所以只能让你知道这些方法的存在，当发现自己需要时，就检查这些文档；Rails开发人员可能已经添加了所需要的方法。

### 24.2.2 Additional Active Support Classes 附加的Active Support类
In addition to extending the base objects provided by Ruby, Active Support provides plenty of additional functionality.
除了扩展Ruby语言本身提供的基本对象外，Active Support还提供了大量附加功能。
More so than with the core extensions, these classes tend to support specific needs of other Rails components, but you are welcome to make use of these functions directly.
与核心扩展不同，这些类倾向于为其他的Rails组件提供特定的支持，但也可直接利用这些功能。

• 389

------------------------------
------------------------------
David says: Why Extending Base Classes Doesn’t Lead to the Apocalypse
扩展基类会不会导致灾难
The awe that seeing 5.months + 30.minutes for the first time is usually replaced by a state of panic shortly thereafter.
第一次看到代码5.months+30.munites，通常心情会由惊讶变成恐慌。
If everyone can just change how integers work, won’t that lead to an utterly unmaintainable spaghetti land of hell? 
如果每个人都可以改变整数类的运行，会不会导致一种完全不可维护的糟糕局面？
Yes, if everyone did that all the time, it would.
是的，如果每个人都这么做。
But they don’t, so it doesn’t.
但大家没有，也就不会发生。

Don’t think of Active Support as a collection of random extensions to the Ruby language that invites everyone and their brother to add their own pet feature to the string class.
别把ActiveSupport看成ruby语言扩展的随机集合，允许任何人把自己喜欢的特性添加到字符串类中。
Think of it as a dialect of Ruby spoken universally by all Rails programmers.
应该把它当作ruby语言中一种在Rails程序员中广泛传播的方言。
Because Active Support is a required part of Rails, you can always rely on that 5.months will work in any Rails application.
因为ActiveSupport是rails必不可少的一部分，在任何rails程序中都可以使用5.month代码。
That negates the problem of having a thousand personal dialects of Ruby.
那就否定了存在大量个人ruby方言的问题。

Active Support gives us the best of both worlds when it comes to language extensions.
Active Support扩展了ruby语言，并且提供了rails和Ruby两者最好的特性。
 It’s contextual standardization.
这实际上是对语言的语境的标准化。

------------------------------
------------------------------

• Benchmarkable: Measures the execution time of a block in a template and records the results to the log.
  可测评：       可在模板中测量代码块的执行时间，把结果记录到日志文件。         
• Cache::Store: Offers various implementations of caches, based on files or memory; with synchronized or compressed as options.
  缓存存放      多种缓存实现，基于文件或内存；可选选项有synchronized同步和compressed压缩。
• Callbacks: Provide hooks into the life cycle of an object.
  回调：     在对象生命周期里提供钩子方法。
• Concern and Dependencies: Help manage dependencies in a modular way.
  关注和依赖：              以模块化方式辅助依赖管理。
• Configurable: Provides a config Hash class variable.
  配置：        提供散列类变量的配置方式。
• Deprecation: Provides behavior, reporting, and wrapping to support deprecation of methods.
  折旧：       为过期的方法提供表现、报告和封装支持。
• Duration: Offers additional methods such as ago() and since().
  时段：    提供附加方法，例如在之前和自从。
• Gzip: Offers convenience methods to compress() and decompress() a String.
  压缩：为了方便压缩和解压字符串的方法。
• HashWithIndifferentAccess: Allows both params[:key] and params['key'].
  不同方法访问散列：         同时可以用参数params[:key]和params['key']。
• I18n: Provides internationalization support.
  国际化： 提供国际化支持。
• Inflections: Handles English’s inconsistent rules for pluralization.
  词形变化：   处理英语里复数不一致规则。
• JSON: Provides JavaScript Object Notation encoding and decoding methods.
  JSON: 提供Javascript对象标记编码和解码方法。
• LazyLoadHooks: Provides support for deferred initialization of modules.
  惰性加载钩子： 提供模块的延迟初始化支持。
• MessageEncryptor: Encrypts values that are to be stored someplace untrustworthy.
  消息加密：        将存放在不可信位置的值进行加密
• MessageVerifier: Generates and verifies signed messages (to prevent tampering).
  消息验证：       生成并验证签名消息（防止篡改）
• MultiByte: Provides encoding support (primarily for Ruby 1.8.7).
  多字节：   提供编码支持（主要针对ruby1.8.7）

• 390

• Notifications: Offers an instrumentation API.
  通知：         仪表测量接口
• OptionMerger: Offers deep merge lambda expressions.
  选项合并：    深度合并lambda表达式
• OrderedHash and OrderedOptions: Provides ordered hash support (primarily for Ruby 1.8.7).
  有序散列和有序选项：            提供有序的散列支持（主要针对ruby 1.8.7）
• Railtie: Defines core objects that the rest of the framework can depend on.
  枕木：   定义框架其余部分的可依赖的核心对象。
• Rescueable: Eases exception handling.
  可救援：    简化异常处理。
• StringInquirer: Provides a prettier way to test for equality.
  字符串询问器：  提供了一种相当好的等同测试的方式。
• TestCase: Provides a variety of methods for testing rubygems and gemrelated behavior in a secure sandbox.
  测试案例：提供了多种在安全沙箱里测试ruby软件包和相关的行为。
• Time and TimeWithZone: Offer even more support for time calculations and conversions.
  时间和时区时间：       支持更多时间计算和转换

Although this book will not go into the (currently) forty-nine methods and more that, for example, TimeWithZone alone provides, the previous list will enable you to find the functions you need in the guides and API documentation.
尽管本书不会深度涉及所有（现有）的类和方法，并且也不会逐个去分析某个方法，例如TimeWithZone，但是前面的列表足以在rails指南和api文档中找到所需的函数。
But what this book will do is show you how you can use these methods in your stand-alone application.
下面本书也将展示如何在独立程序里使用这些方法。

    require "active_support/time"
    Time.zone = 'Eastern Time (US & Canada)'
    puts Time.zone.now

If you, like most people, find yourself addicted to one or more of these extensions, you can simply require what you need (for example, require "active_ support/basic_object" or require "active_support/core_ext") or pull in everything with require "active_support/all".
因此，如果认为自己对一个或多个扩展感兴趣，就可以简单地加载所需要的扩展（例如`require "active_ support/basic_object"`或者`require "active_support/core_ext"`），或者用`require "active_support/all"`调用整个库。

### 24.2.3 Using Action View Helpers 使用动作视图辅助器
Although this doesn’t exactly fall under the category of Active Support, it is close enough.
虽然这并不完全属于Active Support的范围，但它比较接近。
What applies to Active Support also applies to other parts of Rails, though most routing, controllers, and Action View methods tend to be relevant only to the processing of an active web request.
凡是适用于Active Support的，同样也适用于Rails的其他部分，只不过，路由、控制器和动作视图的方法往往都只与处理活动的web请求有关。

One notable exception is some of the Action View helpers.
值得注意的一个例外是动作视图辅助器。
Here’s an example of how you can access an Action View helper from a stand-alone application:
下面的例子说明如何从独立程序访问动作视图辅助器。

    require "action_view"
    require "action_view/helpers"
    include ActionView::Helpers::DateHelper
    puts distance_of_time_in_words_to_now(Time.parse("December 25"))

• 391

All in all, this is only slightly more work than getting access to the much more commonly needed Active Support methods, but it’s still quite doable.
总之，虽然这里比通常获得Active Support方法需要稍多做点工作，但仍然是切实可行的。

## 24.3 使用Active Resource开发远程程序 <kinder:note> 本节原在4版中译本，但本英文版已经删除。
## What We Just Did 本章小结
Finally, we broke free from the constraints of the browser and accessed Active Support, Action View, and Active Record methods directly from stand-alone scripts.
最后，我们打破了从浏览器直接访问Active Support、Active View和Active Record方法的方式，而直接从独立脚本完成这种访问。
This enables us to produce scripts that can be run from the command line, integrated into existing applications, or run periodically and automatically using facilities such as cron.
这可以把在命令行运行的脚本集成到现有程序中来，或者使用如cron的工具定期、自动地运行脚本。

Next up, we will explore other separately installable components that are included in the bundle when you install Rails.
接下来将探讨其他单独可安装的组件，这些组件是与Rails捆绑在一起的。

# CHAPTER 24 Rails’ Dependencies  Rails包依赖
## In this chapter, we’ll see
   在本章中，我们将学习
• using XML and HTML templates,
  使用xml和html模板
• managing application dependencies,
  管理程序的包依赖关系
• scripting tasks, and
  任务脚本
• interfacing with a web server.
  与web服务器交互
At this point, we have covered base Rails.
到目前为止，我们已经讨论了rails本身的基础。
But there is much more to the story.
但仍然有很多东西没有介绍。
Much of what makes Rails great is functionality provided by components that Rails builds upon.
Rails之所以如此强大，是因为Rails提供了构建组件的功能。

These components should be familiar, because you have used each one.
这些组件我们一点都不陌生，因为前面已经逐个用过了。
Atom templates, HTML templates, rake db:migrate, bundle install, and rails server were all used in the development of the Depot application.
Depot程序的开发过程中已经用过Atom模板，HTML模板，rake db:migrate，bundle install和rails server。

Although this chapter goes beyond your normal day-to-day activities and shows how each component can be used in isolation, it is not meant to be an exhaustive description of any of these components.
虽然本章内容不仅超出了日常开发所需的知识，还将展示如何单独使用每个组件，但这不代表要对所有组件作出详尽的描述。
Each component requires a small book in itself to do it justice.
每个组件都需要一本小书的篇幅来介绍全面的功能。
Instead, the intent of this chapter is to introduce you to a number of key components in order to provide the background necessary for you to begin self-directed explorations.
相反，本章的目的是介绍一些关键性组件，以便读者能够自己展开探索这方面的知识。

We start by introducing you to a number of such dependencies, beginning with the underlying templating engines that power views.
下面从介绍若干个这样的包依赖开始，再进一步进入驱动视图的底层模板引擎。
Then we will explore Bundler, which is the component that is used to manage dependencies.
然后学习捆绑器，它用来管理包依赖关系。

Finally, we will show how these pieces are put together using Rack and Rake.
最后，将展示如何用Rack和Rake把这些代码片段组装在一起。
 
## 24.1 Generating XML with Builder  用构建器生成XML
Builder is a freestanding library that lets you express structured text (such as XML) in code.
Builder构建器是一个独立库，可以在代码中表示结构化的文本（例如XML）。
A Builder template (in a file with an .xml.builder extension) contains Ruby code that uses the Builder library to generate XML.
构建器模板（文件扩展名为.xml.builder）包含ruby代码，利用Builder库，生成XML。

Here’s a simple Builder template that outputs a list of product names and prices in XML:
下面是一个简单的构建器模板，它将货品名称和价格列表以xml格式输出：

• 394

    Download rails40/depot_t/app/views/products/index.xml.builder
    xml.div(class: "productlist") do
      xml.timestamp(Time.now)
      @products.each do |product|
        xml.product do
          xml.productname(product.title)
          xml.price(product.price, currency: "USD")
        end
      end
    end

If this reminds you of the template you created for use with the Atom helper in Section 12.2, Iteration G2: Atom Feeds, on page 172, that’s because the Atom helper is built upon the functionality of Builder.
如果这段代码让人想起前面172页的12.2节所创建的与Atom辅助器相关的模板，那是因为Atom辅助器就是在Builder的功能上搭建的。

With an appropriate collection of products (passed in from the controller), the template might produce something such as this:
有了适当数量的货品集合（通过从控制器传入），模板可能会生成如下内容：

    <div class="productlist">
      <timestamp>2013-01-29 09:42:07 -0500</timestamp>
      <product>
        <productname>CoffeeScript</productname>
        <price currency="USD">36.0</price>
      </product>
      <product>
        <productname>Programming Ruby 1.9</productname>
        <price currency="USD">49.5</price>
      </product>
      <product>
        <productname>Rails Test Prescriptions</productname>
        <price currency="USD">43.75</price>
      </product>
    </div>

Notice how Builder has taken the names of methods and converted them to XML tags; when we said xml.price, it created a tag called <price> whose contents were the first parameter and whose attributes were set from the subsequent hash.
注意Builder怎么取得方法名并把它们转成xml标签；当一提到xml.price时，就创建了<price>标签，内容是第一个参数，属性由后续的散列来设定。
If the name of the tag you want to use conflicts with an existing method name, you’ll need to use the tag!() method to generate the tag.
如果要用的标签名和现存方法名存在冲突，就需要使用tag!方法来生成标签。

    xml.tag!("id", product.id)

Builder can generate just about any XML you need.
Builder几乎可以生成任何所需的XML。
It supports namespaces, entities, processing instructions, and even XML comments.
它支持命名空间、实体、处理指令甚至XML注释。
Take a look at the Builder documentation for details.
详情请查阅Builder文档。

• 395

Although HTML looks superficially a lot like XML, it is enough of a different beast that a different templating engine is generally used to produce HTML.
尽管HTML看起来很像xml，但用来生成html的模板引擎不同，带来的差别十分显著。
We cover that next.
接下来就 讨论这个话题。

## 24.2 Generating HTML with ERB  用ERB生成HTML
At its simplest, an ERB template is just a regular HTML file.
简单点说，ERB模板只是普通的html文件。
If a template contains no dynamic content, it is simply sent as is to the user’s browser.
如果模板没有包含动态内容，它只会原封不动地发送到用户浏览器。

The following is a perfectly valid html.erb template:
下面是个完全有效的html.erb模板：

    <h1>Hello, Dave!</h1>
    <p>
      How are you, today?
    </p>

However, applications that just render static templates tend to be a bit boring to use.
不过，只是呈现静态模板的程序使用起来有点沉闷。
We can spice them up using dynamic content.
可以使用动态内容来给它们增添趣味：

    <h1>Hello, Dave!</h1>
    <p>
      It's <%= Time.now %>
    </p>

If you’re a JSP programmer, you’ll recognize this as an inline expression.
JSP程序员会认出这是内联表达式。
ERB evaluates any code between <%= and %> and converts the results into a string using to_s(), escapes HTML special characters, and finally substitutes the resulting string into the resulting page.
ERB对<%=
%>之间的所有代码进行评估求值，将结果用to_s转成字符串，最后把字符串替换到结果页面里去。
The expression inside the tags can be arbitrary code.
标签内的表达式可以是任何代码。

    <h1>Hello, Dave!</h1>
    <p>
      It's <%= require 'date'
        DAY_NAMES = %w{ Sunday Monday Tuesday Wednesday
                        Thursday Friday Saturday }
        today = Date.today
        DAY_NAMES[today.wday]
      %>
    </p>

Putting lots of business logic into a template is generally considered to be a Very Bad Thing, and you’ll risk incurring the wrath of the coding police should you get caught.
普遍认为，把大量商业逻辑放到模板中，是一件非常糟糕的事情，这样会导致代码混乱，要是真有“代码警察”的话，它们肯定会抓你。
We discussed a much better way of handling this with helpers in Section 21.5, Using Helpers, on page 351.
前面351页21.5节中曾讨论使用辅助器来处理这个问题，那是个好办法。

Sometimes you need code in a template that doesn’t directly generate any output.
有时需要在这样的模板里存放不会直接生成任何输出的代码。
If you leave the equals sign off the opening tag, the contents are executed, but nothing is inserted into the template.
如果把起始标签中的等号去掉，里面内容仍会执行，但不会有结果插入模板中。
We could have written the previous example as follows:
可以把前面的例子这样写：

• 396

    <% require 'date'
      DAY_NAMES = %w{ Sunday Monday Tuesday Wednesday
        Thursday Friday Saturday }
      today = Date.today
    %>
    <h1>Hello, Dave!</h1>
    <p>
      It's <%= DAY_NAMES[today.wday] %>.
      Tomorrow is <%= DAY_NAMES[(today + 1).wday] %>.
    </p>

In the JSP world, this is called a scriptlet.
在JSP圈子里这个叫脚本小程序。
Again, many folks will chastise you if they discover you adding code to templates.
再说一遍，很多人要是发现你把代码往模板里放，一定会严厉地责骂你。
Ignore them—they’re falling prey to dogma.
别管——他们都是教条主意者。
There’s nothing wrong with putting code in a template.
把代码放在模板里没有错。
Just don’t put too much code in there (and especially don’t put business logic in a template).
只是不要放太多这样的代码（尤其是别把业务逻辑搅在模板里）。
As we have already seen, you can use helper methods to successfully resist this temptation.
前面见过，可以使用辅助器方法来抵抗这种诱惑。

You can think of the HTML text between code fragments as if each line were being written by a Ruby program.
可以想象，代码段之间的html文本，每一行代码仿佛都是ruby程序写出来的。
The <%…%> fragments are added to that same program.
<%…%>代码段会被加到同一个程序里。
The HTML is interwoven with the explicit code that you write.
编写的显式代码与html文本交织在一起。
As a result, code between <% and %> can affect the output of HTML in the rest of the template.
结果，<%和%>之间的代码可以影响模板其他部分的html输出结果。
For example, consider this template:
例如这个模板：

    <% 3.times do %>
      Ho!<br/>
    <% end %>

When you insert a value using <%=…%>, the results will be HTML escaped before being placed directly into the output stream.
出于安全考虑，当用<%=...%>插入值时，其结果是html，但在直接放到输出流之前进行转义。
This is generally what you want.
这通常符合人们的想法。
If, however, the text you’re substituting contains HTML that you want to be interpreted, this will cause the HTML tags to be escaped—if you create a string containing <em>hello</em> and then substitute it into a template, the user will see <em>hello</em> rather than hello.
但是，如果要替换的文本里包含html，并打算解析这些html，就会造成html标签发生转义处理——假如创建了包含<em>hello</em>的字段，然后替换到模板里，用户看到的将是<em>hello</em>，而不是斜体的“hello”。
Rails provides a number of helpers to address this case.
Rails有两个辅助器来处理这种情况。
The following are a few examples.
下面是些例子。

The raw() method will cause the string to pass right on through to the output without escaping.
原生方法使字符串没有转义、正确地输出。
This provides the most amount of flexibility, as well as the least amount of security.
这种方法灵活性最大，安全性则最低。
The raw() method will HTML escape items in the array that are not HTML safe, join the results with the provided string, and return an HTML-safe result.
<kinder:note> 原生方法将对不安全的html项放入数组进行转义，并添加一些预备的字符串到结果中，然后输出安全的html结果。

• 397

The sanitize() method offers some protection.
消毒方法则提供了一些保护。
It takes a string containing HTML and cleans up dangerous elements: `<form>` and `<script>` tags are escaped, and on= attributes and links starting javascript: are removed.
它取得包含html的字符串，并清除危险的元素：转义处理`<fomr>`和`<script>`标签，并把`on=`属性和以`javascript:`开头的链接移除。

The product descriptions in our Depot application were rendered as HTML (that is, they were marked as safe using the raw() method).
Depot程序中货品描述以html方式呈现（也就是说曾经用raw方法将它们打上安全标记）。
This allowed us to embed formatting information in them.
这允许在其中嵌入格式信息。
If we allowed people outside our organization to enter these descriptions, it would be prudent to use the sanitize() method to reduce the risk of our site being attacked successfully.
如果允许自己的机构之外的人员输入这些描述，就要谨慎的使用sanitize方法，以便成功地降低黑客攻击网站的风险。

These two templating engines are just two of the many gems that Rails depends on.
这两个模板引擎只是Rails框架依赖的众多gem中的两个。
At this point, it makes sense to talk about how such dependencies are managed.
说道这里，下面就顺便讨论如何管理这些包的依赖关系。

## 24.3 Managing Dependencies with Bundler 用Bundler管理包依赖关系
Dependency management is a deceptively hard problem.
依赖关系管理看似是个难题。
During development, you may choose to install updated versions of gems that you depend on.
开发过程中，可以选择安装所依赖的gem的更新版本。
Once you do this, you may find yourself not being able to reproduce problems that occur in production because your runs are picking up different versions of the gems your application depends on.
一旦这么做，可能会发现不能再现那些产品中存在的问题了，因为每次运行都选择了不同的gem版本，这些gem是该程序所依赖的。
Or perhaps you see problems that don’t exist in production.
或者看到原来了产品中并不存在的问题。
It turns out that dependencies are every bit as important to manage as your application source code or database schemas.
事实证明，包依赖的管理，与对待程序源代码或数据库纲要的管理同样重要。
If you are developing as part of a team, you want every member of the team to be using the same version of the dependencies.
如果身处开发团队中，会希望每个成员都使用相同版本的包依赖关系。
When you deploy, you want to ensure that the version of the dependencies that you tested with are installed on the target machine and are the ones actually used in production.
部署时，要确保测试所用的包依赖关系版本安装到目标机器上，并且它们实际上就是产品环境中使用的那些包依赖关系。

Bundler [1] takes care of this, based on a file named Gemfile that is placed in the top of your application directory.
Bundler根据程序名录下名为Gemfile的文件控制着包依赖关系。
[1].  http://gembundler.com/
In this file, you list the dependencies of your application.
在这个文件里，列出了程序所需的库。
Let’s take a closer look at the Gemfile for the Depot application:
下面详细查看Depot程序中的Gemfile的内容：

    Download rails40/depot_u/Gemfile
    source 'https://rubygems.org'
    # Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
    gem 'rails', '4.0.0'
    # Use sqlite3 as the database for Active Record
    gem 'sqlite3'
    group :production do
      gem 'mysql2'
    end

• 398

    # Use SCSS for stylesheets
    gem 'sass-rails', '~> 4.0.0'
    # Use Uglifier as compressor for JavaScript assets
    gem 'uglifier', '>= 1.3.0'
    # Use CoffeeScript for .js.coffee assets and views
    gem 'coffee-rails', '~> 4.0.0'
    # See https://github.com/sstephenson/execjs#readme for more supported runtimes
    # gem 'therubyracer', platforms: :ruby
    # Use jquery as the JavaScript library
    gem 'jquery-rails'
    gem 'jquery-ui-rails'
    # Turbolinks makes following links in your web application faster.
    # Read more: https://github.com/rails/turbolinks
    gem 'turbolinks'
    # Build JSON APIs with ease. Read more: https://github.com/rails/jbuilder
    gem 'jbuilder', '~> 1.2'
    group :doc do
      # bundle exec rake doc:rails generates the API under doc/api.
      gem 'sdoc', require: false
    end
    # Use ActiveModel has_secure_password
    gem 'bcrypt-ruby', '~> 3.0.0'
    # Use unicorn as the app server
    # gem 'unicorn'
    # Use Capistrano for deployment
    gem 'rvm-capistrano', group: :development
    # Use debugger
    # gem 'debugger', group: [:development, :test]


The first line specifies where to find new gems and new versions of existing gems.
第一行说明在哪里可以找到新的gem包，以及现存gem的新版本。
Feel free to repeat this line in order to list your own private gem repositories.
可以任意重复这一行，以列出私有gem存储库。

The next line lists what version of Rails to load.
下一行说的是载入的rails的版本。
Note that it specifies a specific version.
注意它指定了特定的版本号。
After this is a comment that you could use as an alternative in order to run the latest version of Rails.
后面两行是注释，可以使用这两行来运行rails的最新版本。

• 399

The remaining lines list a few gems that you are using and a few gems that you might consider using.
剩余的行列出了一些正在使用的gem和考虑使用的gem。
Some are placed in groups named :development, :test, or :production and will be made available only in those environments.
有些gem放在分组里，如:development :test :production，并只在相应的环境中有效。
Others include an optional :require parameter, which specifies the name to use on a require statement for the cases where it differs from the gem name.
另一些gem包含可选择的参数:require，用来在require语句的装载名与gem名有区别时，指定require语句要使用的名称。

On the line for sass-rails you see a version specifier that is preceded by a comparison operator.
sass这一行——有个以比较符号开始的版本定义符。
Although Gemfile files support a number of such operators, only two are commonly used.
虽然Gemfile文件支持许多这样的操作符，但常用的只有两种。
>= is for the unfortunately all too rare condition where the author of the Gemfile can be trusted to maintain strict backward compatibility so all that is needed to be specified is a minimum version number.
>=使用的条件实在十分少见，这是因为在那里可以使Gemfile开发者维护的严格向后兼容性得到可靠保证，所以需要定义的是最小版本号。

~> is more widely recommended.
广泛推荐使用~> 。
Essentially all of the parts of the version, with the exception of the last part, must be matched exactly, and the last part specifies a minimum.
除了最后一部分，基本上所有的版本部分都必须完全匹配，而最后一部分指定了一个最小值。
So, ~> 3.1.4 matches any version that starts with a 3.1 and is not less than 3.1.4.
所以， ~> 3.1.4 与所有以3.1开头的版本匹配，但不能小于3.1.4。
Similarly, ~> 3.0 means any version string that starts with a 3..
同样，~> 3.0意味着所有以3.0开头的版本字符串。

A Gemfile has a companion file, named Gemfile.lock.
与Gemfile相伴的文件叫Gemfile.lock。
This second file is generally updated by one of two commands: bundle install and bundle update.
后者通常由两个命令来更新：`bundle install`和`bundle update`。
The difference between the two is rather subtle.
两个命令的差别相当微妙。

Before proceeding, it is helpful to look at a Gemfile.lock file.
动手操作前，先看一看Gemfile.lock文件是很有帮助的。
Here is a small excerpt:
下面是一部分节选：
GEM
  remote: https://rubygems.org/
  specs:
    actionmailer (4.0.0)
      actionpack (= 4.0.0)
      mail (~> 2.5.3)
    actionpack (4.0.0)
      activesupport (= 4.0.0)
      builder (~> 3.1.0)
      erubis (~> 2.7.0)
      rack (~> 1.5.2)
      rack-test (~> 0.6.2)
    activemodel (4.0.0)
      activesupport (= 4.0.0)
      builder (~> 3.1.0)

bundle install will use the Gemfile.lock as a starting point, and it will install only the versions of the various gems as specified in this file.
bundle install使用Gemfile.lock作为出发点，只安装在该文件里定义的各种gem版本。
For this reason, it is important that this file gets checked into your version control system, because this will ensure that your colleagues and deployment targets will all be using the same configuration.
因此，把这个文件放入版本控制系统中检查十分重要，因为它将保证你的同事和部署目标都会使用完全相同的配置。

• 400

bundle update will (unsurprisingly) update one or more named gems and will update the Gemfile.lock accordingly.
bundle update会变更一个或多个已命名的软件包，并变更相应的Gemfile.lock文件。

If you want to use a specific version of a particular gem, the workflow would be to edit the Gemfile to express your constraints and then run bundle update listing the gems that you want to update.
如果想使用某个特定版本的gem，请按照一下流程进行：修改Gemfile文件来表达约束条件，然后运行bundle update列出想要更新的软件包。

If you don’t specify a list of gems, Bundler will attempt to update all gems—this is generally not recommended, particularly when close to deployment.
如果没有指定gem列表，Bundler将尝试更新所有的软件包——通常不推荐这种做法，尤其是临近部署的时候。

Bundler also has a runtime component that is used to ensure that your application strictly loads only the versions of the gems listed in Gemfile.lock.
Bundler也有运行时组件，用来保证程序严格地只加载了在Gemfile.lock里列出的软件包版本。

We will explore that further by looking into how the server operates.
下面将进一步探索服务器如何运行。

## 24.4 Interfacing with the Web Server with Rack 用Rack实现与Web服务器交互
Rails runs your application in the context of a web server.
Rails在服务器环境里运行程序。
So far, we have used two separate web servers: WEBRick, which comes built into the Ruby language, and Phusion Passenger, which integrates with the Apache HTTP web server.
到目前为止，曾使用过两个独立的web服务器：WEBRick来自ruby语言内置的服务器。Phusion Passenger是整合了Apache HTTP的web服务器。

A number of other choices are available, including Mongrel, Lighttpd, Unicorn, and Thin.
还有许多其他可用的选择，包括Mongrel、Lighttpd， Unicorn和Thin。
Based on this, you might come to the conclusion that Rails has code that allows it to plug into each of these web servers.
由此可能会得出这样的结论：Rails具有可接入这些web服务器的代码。
In earlier releases of Rails, this was true; as of Rails 2.3, this integration was delegated to a gem named Rack.
在Rails的早期版本里，这是正确的。但到了Rails2.3,这种整合托付给了名为Rack的软件包。
<kinder:note> 4版中文译注: rack是机柜和机架的意思。
So, Rails integrates with Rack, Rack integrates with (for example) Passenger, and Passenger integrates with Apache httpd.
所以，Rails和Rack整合、Rack和Passenger等整合，Passenger和Apache httpd服务器整合。
Although generally this integration is invisible and taken care of for you when you run the command rails server, a file named config.ru is provided that allows you to directly start your application under Rack.
虽然通常情况下这种整合是看不见的，但当启动命令rails server发出之后，就在起作用了。config.ru文件还可以直接在Rack下启动程序。

    Download rails40/depot_u/config.ru
    # This file is used by Rack-based servers to start the application.
    require ::File.expand_path('../config/environment', __FILE__)
    run Rails.application

You can use this file to start your Rails server with the following command:
用以下命令和上面的配置文件，启动rails服务器：

    rackup

Starting your server in this way is completely equivalent to running rails server.
以这种方式启动完全相当于运行命令rails server。
To demonstrate the power of what you can do with Rack alone, let’s start over with a bare-bones Rack application.
为了演示单独应用Rack时的强大功能，可以从单纯的Rack应用重新开始。

• 401

    Download rails40/depot_u/app/store.rb
    # <kinder:note>  rails new命令产生的depot程序的app目录下没有所谓store.rb的文件
    require 'builder'
    require 'active_record'

    ActiveRecord::Base.establish_connection(
      adapter: 'sqlite3',
      database: 'db/development.sqlite3'
    )

    class Product < ActiveRecord::Base
    end

    class StoreApp
      def call(env)
        x = Builder::XmlMarkup.new :indent=>2
        x.declare! :DOCTYPE, :html
        x.html do
          x.head do
            x.title 'Pragmatic Bookshelf'
          end
          x.body do
            x.h1 'Pragmatic Bookshelf'
            Product.all.each do |product|
              x.h2 product.title
              x << "#{product.description}\n"
              x.p product.price
            end
          end
        end
        response = Rack::Response.new(x.target!)
        response['Content-Type'] = 'text/html'
        response.finish
      end
    end

In this application, we are taking advantage of a number of things we have learned so far.
这个程序利用了许多学过的知识。
The first thing we do is to directly require active_record and builder.
第一步，直接用require语句载入两个库。

Then we establish a connection with our database and define a class for our Product.
第二步，建立数据库连接，并定义Product类。
We won’t need to do any of this once we integrate this application with our Rails application, but for now we are going totally bare-bones.
倘若把这个程序和Rails程序结合为一体，就不必再做什么事情了；但这里，使用的是单纯的Rack程序。

Then comes the application.
然后看程序本身。
It is a simple class that defines a single method named call().
这是一个简单的类，定义了一个call的方法。
This method accepts a single parameter named env that contains information about the request and is not used by this application.
这个方法接收一个env参数，包含请求的信息，且该参数并不为这个程序所用。

This application uses Builder to create a simple HTML rendering of a product list and then builds a response, sets the content type, and calls finish().
这个程序使用Builder创建了简单的HTML，用来呈现产品列表，然后创建响应，设置内容类型，并调用finish方法。

• 402

By creating a new rackup file, we can run this as a stand-alone application.
再创建新的rackup文件，就能运行这个单独的应用了。

    Download rails40/depot_u/store.ru
    require 'rubygems'
    require 'bundler/setup'
    require './app/store'
    use Rack::ShowExceptions
    map '/store' do
      run StoreApp.new
    end

The first thing this script does is to initialize Bundler, which will make available the right versions of all the gems that will be required.
这段脚本的第一件事是初始化Bundler，这将另所需的所有软件包有正确版本可用。
Then it requires the store application.
然后用require语句加载商店程序。

Next, it pulls one of the standard middleware classes provided with Rack; this one formats a stack traceback when things go wrong.
接下来，它触发Rack所提供的这些标准中间件类中的显示异常类，出错时，该类负责对栈对追踪进行格式化。
Middleware in Rack is like filters in Rails—both can inspect requests and adjust the responses produced.
这个中间件就像rails的过滤器——都能检查请求并调整生成的响应。

You can see the list of middlewares that Rails provides for Rails applications using the command rake middleware.
可以用命令`rake middleware`查看Rack为Rails程序所提供的中间件列表。
Finally, we map the store URI to this application.
最后，将store的URI映射到这个程序上。
We can start this application using the rackup command.
在命令行输入rackup命令，启动应用：

    rackup store.ru

By default, this rackup starts servers using port 9292 instead of port 3000.
默认情况下，rackup在端口9292启动服务器，不是3000端口。
You can select the port using the -p option.
可以用-p参数指定端口。
Visiting this page using your browser results in the rather plain rendering of the product listings, as shown in Figure 61, A minimal, but workable, product listing, on page 403.
通过浏览器访问页面，呈现出简洁的商品列表，如下图表61所示。
The disadvantage of a native Rack application as compared to a Rails application is that less is taken care of for it.
与Rails程序相比，原生的Rack程序的缺点是为本身考虑得太少。
The primary advantage is that it is possible to avoid some of the overhead of Rails and therefore process more requests per second.
主要优点是可避免一些Rails开销，因此可以在单位时间里处理更多请求。
In most cases, you won’t want to create a completely stand-alone application but will want to have portions of your site bypass Rails’ controller processing.
大多数情况下，你不打算创建完整的独立程序，只想绕过Rails的控制器处理网站的一部分。
You do this by defining a route.
可以通过定义路由来实现：

• 403

Figure 61—A minimal, but workable, product listing
图表61 —— 简单但切实可用的商品列表


    Download rails40/depot_u/config/routes.rb
    ➤ require './app/store'
      Depot::Application.routes.draw do
    ➤   match 'catalog' => StoreApp.new, via: :all
        get 'admin' => 'admin#index'
        controller :sessions do
          get 'login' => :new
          post 'login' => :create
          delete 'logout' => :destroy
        end
        get "sessions/create"
        get "sessions/destroy"
        resources :users
        resources :products do
          get :who_bought, on: :member
        end
        scope '(:locale)' do
          resources :orders
        resources :line_items
        resources :carts
        root 'store#index', as: 'store', via: :all
      end
    end

• 404

The server is not the only place where Rails components are used.
服务器不是Rails组件唯一发挥作用的地方。
We complete this chapter with a description of a tool you can use to orchestrate the execution of tasks.
本章最后部分将阐述用来协调任务执行的工具。

## 24.5 Automating Tasks with Rake 自动执行任务工具Rake
Rake is a program that often is taken for granted.
Rake是一款经常使用的程序。
It is used to automate tasks, particularly tasks that may have a number of dependencies.
它用来自动执行任务，特别是那些有许多包依赖关系的任务。
The tasks are defined by the Rakefile that you will find in your application’s root directory.
在程序根目录里，可以找到定义这些任务的Rakefile文件。

db:setup is an example of such a task.
db:setup就是这样一任务命令的示例。
To see what subtasks are involved, run Rake with the --trace and --dry-run options.
如果要看涉及的子任务命令，可以像下面那样运行rake：

    $ rake --trace --dry-run db:setup
    (in /home/rubys/work/depot)
    ** Invoke db:setup (first_time)
    ** Invoke db:create (first_time)
    ** Invoke db:load_config (first_time)
    ** Invoke rails_env (first_time)
    ** Execute (dry run) rails_env
    ** Execute (dry run) db:load_config
    ** Execute (dry run) db:create
    ** Invoke db:schema:load (first_time)
    ** Invoke environment (first_time)
    ** Execute (dry run) environment
    ** Execute (dry run) db:schema:load
    ** Invoke db:seed (first_time)
    ** Invoke db:abort_if_pending_migrations (first_time)
    ** Invoke environment
    ** Execute (dry run) db:abort_if_pending_migrations
    ** Execute (dry run) db:seed
    ** Execute (dry run) db:setup

Executing the right steps in the right order is vital for repeatable deployments; that’s why this particular task was used in Loading the Database, on page 240.
对于可重复的部署，按照正确的顺序执行正确的步骤至关重要，这就是为什么前面240页16.1节曾使用过这个特殊的任务。
<kinder:note> 16.1.4产品部署之加载数据库
You can see a list of available tasks using rake --tasks.
运行rake --tasks后，可以看到一个有效的任务清单。
The tasks that Rails provides are just a starter set; you are welcome to create more tasks.
Rails提供的这个任务仅仅只是一个启动设置，可以自由创建更多任务。
You do so simply by creating new files in the lib/tasks directory containing Ruby code.
在lib/tasks目录下，创建新的ruby代码文件就可以了。
Here’s an example that will back up the production database:
下面是备份生产环境数据库的例子：

• 405

    Download rails40/depot_u/lib/tasks/db_backup.rake
    namespace :db do
      desc "Backup the production database"
      task :backup => :environment do
        backup_dir = ENV['DIR'] || File.join(Rails.root, 'db', 'backup')
        source = File.join(Rails.root, 'db', "production.db")
        dest = File.join(backup_dir, "production.backup")
        makedirs backup_dir, :verbose => true
        require 'shellwords'
        sh "sqlite3 #{Shellwords.escape source} .dump > #{Shellwords.escape dest}"
      end
    end

The first line contains a namespace.
第一行包含命名空间。
We put this backup task in the db namespace.
把备份任务放到的db命名空间里。
The second line contains a description.
第二行是描述。
This description will show up when you list tasks.
执行list任务时会将描述显示出来。
If you run the rake --tasks command again, you will see that your new task is included along with the ones that Rails provided.
如果再次运行命令`rake --tasks`，会看到刚写的任务包含在Rails所提供的任务当中。

The next line contains the task as well as any dependencies it might have.
下一行包含任务以及该任务可能有的包依赖关系。
Depending on environment is roughly equivalent to loading everything that rails console provides.
依赖环境和加载rails console提示的东西相当。
The block passed to the task is standard Ruby code.
传递给任务的代码块是标准的rubyblam。
In our example, we determine the source and destination directories (where the destination will default to db/backup but can be overridden by a DIR parameter on the command line), then proceed to make the backup directory (if necessary), and finally execute the sqlite3 dump command.
在这个例子中，先确定源代码目录和目标目录，然后处理要备份的目录，最后执行命令sqlite3 dump。

Note that we take care to escape arguments passed to the shell.
<kinder:note> 注意一定要转义传递给shell的参数。
This is important in case any of the directories in question have a space in their name.
<kinder:note> 这是很重要的一点，如果有的目录名字中间包含空格。

## 24.6 Survey of Rails’ Dependencies 解密包依赖
You can find a list of your Rails dependencies in the Gemfile.lock file.
一个很好的出发点是回顾Gemfile.lock文件。
Some of the names you find in there will be obvious; others will not.
你会发现有些名字很古怪，有的则易懂。
To assist with this exploration, the following is a brief description of the names you will find in there.
为了进一步深入学习，下面列出常用名称的简单描述。
Of course, as Rails evolves, this list will inevitably change.
当然，随着Rails的不断发展，清单必然会发生变化。
But by knowing the name of the component, you have the starting point for further exploration.
但知道这些组件的名称，就为进一步理解建立了一个良好的开端。
A good way to find out more given the name is to go to RubyGems.org,[2] enter the gem name in the search field, select the gem, and then click either the Documentation or Homepage link.
找到更多名称的好办法是访问RubyGems.org，输入想要的软件包名称，然后单击文档连接，或者单击主页链接。
[2].  http://rubygems.org

• 406

actionmailer
  Part of Rails; see Chapter 13, Task H: Sending Mail, on page 177
  Rails的组成，参见前面177页13章
actionpack
  Part of Rails; see Chapter 20, Action Dispatch and Action Controller, on page 309
  Rails的组成，参见前面309页20章
activemodel
  Support for Active Record and Active Resource
  对活性记录和活性资源的支持
activerecord
  Part of Rails; see Chapter 19, Active Record, on page 275
  Rails的组件，参见前面275页19章
activesupport
  Part of Rails; see Section 23.2, A Library Function Using Active Support, on page 386
  Rails的组件，参见前面386页23.2节
rails
  Container for the entire framework
  整个框架的容器。
railties
  Part of Rails; see Section 25.4, Finding More at RailsPlugins.org, on page 418 for links to more information on the subject
  Rails的组件，参见后面418页25.4节，还有很多关于这个主题的网络链接。

arel
A relational algebra; used by Active Record
关系代数，由活性记录使用
atomic
Provides an Atomic class that guarantees atomic updates to its contained value
<kinder:note> 提供一个原子类，保证原子地更新它所包含的值。
bcrypt-ruby
Secure hash algorithm; used by Active Model
<kinder:note> 安全散列运算；由活性模型使用。
builder
A simple way to create XML markup; see Section 24.1, Generating XML with Builder, on page 393
创建xml标记的简洁方式，参见前面393页24.1节
capistrano
Welcome to easy deployment; see Section 16.2, Iteration K2: Deploying Remotely with Capistrano, on page 242
易于部署的工具，参见前面242页16.2节。
coffee-script
Bridge to the JS CoffeeScript compiler
<kinder:note> js的CoffeeScript编译器的桥
erubis
The implementation of ERB that Rails uses; see Section 24.2, Generating HTML with ERB, on page 395
在Rails里用于实现ERB的功能。参见前面395页的24.2

• 407

execjs
Lets you run JavaScript code from Ruby; used by coffee-script
<kinder:note> 在ruby中运行JavaScript；由coffee脚本使用。
highline
I/O library for command-line interfaces
命令行界面的输入输出库。
hike
Finds files in a set of paths; used by sprockets
<kinder:note> 在一组路径中寻找文件；有sprockets使用。
i18n
Internationalization support; see Chapter 15, Task J: Internationalization, on page 211
提供国际化支持；参见前面211页15章。
jquery-rails
Provides jQuery and the jQuery-ujs driver
<kinder:note> 提供jQuery和jQuery-ujs驱动。
jbuilder
Provides a simple DSL for declaring JSON structures that beats massaging giant hash structures
<kinder:note> 提供一个简单的深度映射层用来声明JSON结构，解析巨量散列结构。
json
An implementation of the JSON specification according to RFC 4627
<kinder:note> 根据RFC 4627进行JSON说明的实现。
mail
Mail support; see Chapter 13, Task H: Sending Mail, on page 177
邮件支持；参见前面177页13章
mime-types
Determines file type based on extension, used by mail
根据扩展名确定文件类型，由mail使用
multi-json
Provides swappable JSON backends
<kinder:note> 提供了JSON后端的可交换特性
mysql
Production database supported by Active Record; see Using MySQL for the Database, on page 239
由活性记录模块支持的生产数据库，参见前面239页。
minitest
Provides a complete suite of testing facilities supporting TDD, BDD, mocking, and benchmarking
<kinder:note> 提供了一套完整的测试设施支持TDD, BDD, mocking, 和benchmarking。
net-scp
Copies files securely
文件安全复制
net-sftp
Transfers files securely
文件安全传输
net-ssh
Connects to remote servers securely
安全连接远程服务器

• 408

net-ssh-gateway
Tunneling connections over SSH
通过SSH隧道连接。
nokogiri
An HTML, XML, SAX, and Reader parser
<kinder:note> 一个html xml sax和Reader解析器。
polyglot
Custom language loaders
自定义语言装载器。
rack
Interface between Rails and web servers; see Section 24.4, Interfacing with the Web Server with Rack, on page 400
Rails和网络服务器之间的界面，参考前面400页24.4节。
rack-test
Testing API for routes
测试路由的api接口
rake
Task automation; see Section 24.5, Automating Tasks with Rake, on page 404
自动化任务工具；参见前面404页24.5节。
sass
<kinder:note> Provides extensions to CSS3
提供css3扩展
sass-rails
Generator and Asset support for Sass
<kinder:note> sass生成器和资产支持
sprockets
Preprocesses and concatenates JavaScript source files
<kinder:note> JavaScript源文件的预处理和连接。
thread_safe
A collection of thread-safe versions of common core Ruby classes
<kinder:note> 普通核心ruby类的线程安全版的集合。
tilt
Generic interface to multiple Ruby template engines; used by sprockets
<kinder:note> 多ruby模板引擎的一般接口；由sprockets使用。
sqlite3
Development database supported by Active Record
活性记录支持的开发环境数据库。
thor
Scripting framework used by the rails command
rails命令行使用的脚本框架
treetop
Text parsing library, used by mail
文字解析库，由邮件使用。
tzinfo
Time zone support
时区支持。
uglifier
Compresses JavaScript files
<kinder:note> 压缩Javascript文件。

• 409

## What We Just Did 本章小节
We explored a small number of Rails’ dependencies and then showed how dependencies themselves can be managed, integrated with a web server, and finally orchestrated from the command line.
我们探索了少量的rails包依赖关系，并展示了如何管理这些依赖，实现与网络服务器的集成，从命令行界面进行整合这些包依赖关系。
Along the way, we finally found out what the Rakefile, Gemfile, and Gemfile.lock files are that are in the top of our application directory.
顺便，我们找出了程序根目录下的Rakefile、Gemfile和Gemfile.lock文件所起的作用。

Now that we have gone deeper into Rails, the next place to go is to branch out and to cover external plugins that can be used to extend the base Rails package that you get when you install Rails.
现在，探索之旅已经深入了rails框架的内部，下一站将开阔眼界，学习在安装Rails时就开始发挥作用的外部插件，依靠外部插件来扩展Rails框架。

# CHAPTER 25 Rails Plugins    Rails插件
## In this chapter, we’ll see
   在本章中，我们将学习：
• adding new classes to your application and
  添加新类到程序中。
• adding a new templating language.
  添加新的模板语言。

Since the beginning of this book, we’ve talked incessantly about convention over configuration in that Rails has sensible defaults for just about everything.
本书开头就不断强调rails约定优于配置的原则；在该原则下，Rails为几乎所有事情准备了切合实际的默认约定。
And more recently in the book, we’ve described Rails in terms of the underlying gems that you get when you install Rails.
在前面的内容里，还深入讨论了基础软件包（安装Rails时已经默认安装了）。
Now it is time to put those two thoughts together and reveal that the initial set of gems that Rails provides you with is a sensible set of defaults—a group of gems that you can both add to and change.
现在我们把上面的两个部分整合起来，以揭示Rails提供的一组初始gem本身就是一组切换实际的默认插件——它们既是可添加的也是可改变的。

With Rails, gems are the primary way in which you plug in new functionality.
伴随着Rails，软件包成了添加新功能的主要渠道。
Instead of describing this in the abstract, we will select a few plugins and use them to illustrate different aspects of how plugins are installed and what plugins can do.
为了避免抽象的泛泛描述，这里选择了几个插件，实际使用它们，展示如何安装它们，它们能做什么。
The fact that many of these plugins turn out to be immediately useful for your day-to-day work is simply a bonus!
事实上，在日常工作中这些插件大多数都能产生立竿见影的效果，真是意外收获！
Let’s start with a simple plugin that can make you money.
下面从介绍简单但确实可以赚钱的插件开始。

## 25.1 Credit Card Processing with Active Merchant 信用卡业务处理插件
In Iteration G1 on page 161 we mentioned that we were temporarily punting on handling credit cards.
回顾前面161页12.1节G1临时搁置了“信用卡处理”程序。
Being able to charge a customer is clearly an important part of taking an order.
能够真正向顾客首款显然是订单的重要部分。
Although this functionality isn’t built into the core of Rails, there is a gem that provides this.
尽管这不是Rails的内置核心功能，但软件包中存在这种功能。

You’ve already seen how you control what gems get loaded by your application; you do this by editing your Gemfile.
上面已经看到了程序如何控制载入哪些软件包；即编辑Gemfile。
Since we are going to cover a number of such gems in this chapter, let’s add all of the ones that we’ll cover at once.
既然本章涉及若干这种软件包，索性就把所有马上要用到的插件一次性添加进来。
You can add these any place you like; we’ve chosen to do so at the end of the file.
可以将这些软件包添加到任何你愿意的地方；现在选择放在文件的结尾。

    Download rails40/depot_v/Gemfile
    gem 'activemerchant', '~> 1.31'
    gem 'haml', '~> 4.0'
    gem 'kaminari', '~> 0.14'

• 412

You will note that we follow best practices by specifying a minimum version and effectively specifying an upper bound on the version number so that this demo will pick a version that is unlikely to contain an incompatible change.
你注意到，这里遵循了最佳实践方法：指定了最小版本号，更高的版本号，这样挑选版本号的目的是不想在范例中产生不兼容的情况。
As for the gems we added, we will cover each in a separate section.
至于所添加的软件包，后面每一节都会详细介绍。
This section will focus on Active Merchant.[1] 
这一节主要关注Active Merchant。
[1].  http://www.activemerchant.org/
With this in place, we can use the bundle command to install our dependencies.
<kinder:note> 这样就可以使用bundle命令来安装依赖。

    depot> bundle install

Depending on your operating system and your setup, you may need to run this command as root.
<kinder:note> 可能需要管理员root权限来运行这个命令，这取决于操作系统和设置。
The bundle command will actually do much more.
<kinder:note> bundle命令实际上做得更多。
It will cross-check gem dependencies, find a configuration that works, and download and install whatever components are necessary.
<kinder:note> 它会检查所有软件包依赖，找到软件包运行的配置，并下载安装所需的组件。
But this needn’t concern us now; we added only one component, and we can rest assured that this one is included in the gems that the bundler installed.
<kinder:note>
不过我们已经不关心这些了；我们只添加了一个组件，可以保证这个软件包已经包含其中并已安装。

We must do one last thing after updating or installing a new gem: restart the server.
<kinder:note> 升级和安装新软件包后，还需要重启服务器。
Although Rails does a good job of detecting and keeping up with your latest changes to your application, it is impossible to predict what needs to be done when an entire gem is added or replaced.
<kinder:note> 虽然Rails在检测和保持程序最新变化方面很在行，但要在新增或替换软件包时预知未来所需，还是无能为力。
We won’t be using the server in this section but will shortly.
本节中还没用到服务器，不过马上就用了。
Make sure that the server is running the Depot application.
确保该服务器正在运行Depot程序。

To demonstrate this functionality, we will create a small script, which we will place in the script directory.
为了演示这个功能，将创建一个短小的脚本程序，放在script目录下：

    Download rails40/depot_v/script/creditcard.rb
    credit_card = ActiveMerchant::Billing::CreditCard.new(
      number: '4111111111111111',
      month: '8',
      year: '2009',
      first_name: 'Tobias',
      last_name: 'Luetke',
      verification_value: '123'
    )
    puts "Is #{credit_card.number} valid? #{credit_card.valid?}"

There is not much to this script.
这段代码不长。
It creates an instance of an ActiveMerchant:: Billing::CreditCard class and then calls valid?() on this object.
先创建ActiveMerchant:: Billing::CreditCard类的实例，调用该对象的方法valid?。
Let’s run it.
运行一下：
    $ rails runner script/creditcard.rb
    Is 4111111111111111 valid? false

• 413

There’s not much to it; it just worked.
过程简单，但已经运行起来了。
Note that no require statements were necessary; simply listing the gem you want in your Gemfile makes the function available to your application.
注意，没有必要使用require语句；只要在文件Gemfile中列出想要的软件包，就可以在程序里应用软件包的功能了。

At this point, you should be able to see how you could use this functionality in the Depot application.
现在应该可以看到在Depot程序里如何使用这个功能了。
You know how to add a field to the Orders table via a migration.
应该明白如何怎么将一个字段通过迁移添加到表Orders中。
You know how to add that field to the view.
应该直到怎么将该字段添加到视图。
You know how to add validation logic to your model, which calls the valid?() method that we used earlier.
应该知道怎么添加验证逻辑到模型中去，调用刚才的valid?方法。
If you go to the merchant site, you can even find out how to authorize() and capture() a payment, though this does require you to have a login and a password with an existing commerce gateway.
如果浏览该插件网站，甚至可能发现如何授权和付款；当然这需要有支付网关的登录用户名和密码。
Once that is set up, you know how to call this logic from your controller.
一旦设置完成，就知道如何从控制器调用这一逻辑了。

Just think: all of that was made possible by the addition of a single line to your Gemfile.
只在Gemfile里添加一行代码，一切就都可能了。

As we stated at the beginning of this chapter, adding gems to your Gemfile is the preferred way to extend Rails.
正如本章开头所说，添加软件包到Gemfile文件里，是Rails扩展的首选方法。
The advantages of doing so are numerous: all of your dependencies are tracked by Bundler, are all preloaded for immediate use by your application, and can be packed for easy deployment.
这种方法的好处很多：所有依赖关系都可以用Bundler追踪管理；所有预装插件都可以直接为程序所用；为了方便部署还可打包。

This was a very simple addition.
这是一种简单的添加方式。
Let’s move on to something more significant, something that provides a clear alternative to one of the gems that Rails depends on.
下面转到更有意思的事情来：提供一个替代Rails依赖的软件包。

## 25.2 Beautifying Our Markup with Haml 用haml美化标记
Let’s take a look once again at a simple view that we use in the Depot application, in this case, one that presents our storefront:
下面再看一下Depot里使用的简单视图，以展示店面为例：

    Download rails40/depot_u/app/views/store/index.html.erb
    <% if notice %>
      <p id="notice"><%= notice %></p>
    <% end %>
    <h1><%= t('.title_html') %></h1>
    <% cache ['store', Product.latest] do %>
      <% @products.each do |product| %>
        <% cache ['entry', product] do %>
          <div class="entry">
            <%= image_tag(product.image_url) %>
            <h3><%= product.title %></h3>
            <%= sanitize(product.description) %>
            <div class="price_line">
              <span class="price"><%= number_to_currency(product.price) %></span>
              <%= button_to t('.add_html'), line_items_path(product_id: product),
              remote: true %>
            </div>
          </div>
        <% end %>
      <% end %>
    <% end %>

• 414

This code gets the job done.
这段代码效果不错。
It contains the basic HTML, with interspersed bits of Ruby code enclosed in <% and %> markup.
它包含了基本的HTML语句，在<%和%>标记中间散布了ruby代码片段。
Inside that markup, an equal sign is used to indicate that the value of the expression is to be converted to HTML and displayed.
在标记里面，等号用来标示要转成HTML并显示出来的表达式的值。

This is not only an adequate solution to the problem at hand; it is also all that is really needed for a large number of Rails applications.
这个办法不仅能解决手边的问题，同时完全可满足多数Rails程序的需要。
Additionally, it is an ideal place to start for books—like this one—where some knowledge of HTML may be presumed, but many of the readers are new to Rails and often to Ruby.
另外，很多书都假定读者具备一定的html知识——本书就是如此——但对Rails甚至Ruby都只是刚刚接触到。
The last thing you would want to do in that situation is to introduce yet another new language.
如果是这种情况，现在应该学习一门新的语言。

But now that you are past that learning curve, let’s explore a new language—one that more closely integrates the production of markup with Ruby code, namely, HTML Abstraction Markup Language (Haml).
现在假设你通过了那段学习曲线，向前探寻一门新的语言——用ruby代码更紧凑地生成标记语言：html抽象标记语言（Haml）。
To start with, let’s remove the file we just looked at.
先删除刚才的那个视图文件吧。

    $ rm app/views/store/index.html.erb

In its place, let’s create a new file.
在原来的地方新建一个新的文件。

    Download rails40/depot_v/app/views/store/index.html.haml
    - if notice
      %p#notice= notice
    %h1= t('.title_html')
    - cache ['store', Product.latest] do
      - @products.each do |product|
        - cache ['entry', product] do
          .entry
          = image_tag(product.image_url)
          %h3= product.title
          = sanitize(product.description)
          .price_line
            %span.price= number_to_currency(product.price)
            = button_to t('.add_html'), line_items_path(product_id: product),
              remote: true

Note the new extension: .html.haml.
注意新的扩展名.htm.haml。
This indicates that the template is a Haml template instead of an ERB template.
这表示Haml模板而不是ERB模板。

• 415

The first thing you should notice is that the file is considerably smaller.
首先注意文件变得相当小了。
Here’s a quick overview of what is going on, based on what the first character is on each line:
下面就快速概览代码的作用，分析每行第一个字符：

• Dashes indicate a Ruby statement that does not produce any output
  破折号表示不产生任何结果的ruby语句。
• Percent signs (%) indicate an HTML element.
  百分号表示HTML元素。
• Equal signs (=) indicate a Ruby expression that does produce output to be displayed.
  等于号表示会生成显示结果的Ruby表达式。
This can be used either on lines by themselves or following HTML elements.
这既可以是数行Ruby语句，也可以紧接着多个HTML元素。

• Dots (.) and hash (#) characters may be used to define class and id attributes, respectively.
  点和井号字符可分别用于定义HTML语言的class和id属性。
This can be combined with percent signs or used stand-alone.
既可以和百分号结合，也可以单独使用。
When used by itself, a div element is implied.
单独使用时，代表div元素。

• A comma at the end of a line containing an expression implies a continuation.
  逗号出现在包含表达式的行的结尾，意味着一种延续。
In the previous example, the button_to() call is continued across two lines.
在上面代码示例中，button_to调用延续跨了两行。

An important thing to note is that indentation is important in Haml.
Haml的缩进至关重要。
Returning to the same level of indentation closes the if statement, loop, or tag that is currently open.
返回到相同层级的缩进，就关闭了当前处于开放状态的条件语句、循环或标签。
In this example, the paragraph is closed before the h1, the h1 is closed before the first div, but the div elements nest, with the first containing an h3 element and the second containing both a span and a button_to().
在上面的实例中，在h1之前关闭段落，而在第一个div之前关闭h1,但div元素是嵌套结构，其中包含的第一部分是h3元素，第二部分是span和button_to。

As you can also see, all of your familiar helpers are available, things like t(), image_tag(), and button_to().
正如上面已看的，所有熟悉的辅助器都是可用的，如方法t，image_tag和button_to。
In every meaningful way, Haml is as integrated into your application as ERB is.
跟ERB一样，可以用各种有意义的方式把Haml集成到程序中。
You can mix and match: you can have some templates using ERB and others using Haml.
可以采用混合和搭配的方式，一部分采用ERB模板，另一部分采用haml。

As you have already installed the Haml gem, there truly is nothing more you need to do.
由于已经安装了软件包Haml，所以已经不需要再做什么了。
To see this in action, all you need to do is to visit your storefront.
要看到效果，只要访问在线商店即可。

What you should see should match Figure 62, Storefront using Haml, on page 416.
看到的内容应该如下页图表62所示。

If that looks unremarkable, that’s because it should look exactly like it did before.
似乎看起来没有什么特别，那是因为设计本应该与以前一模一样。
And that, if you think about it, is all the more remarkable because the application layout continues to be implemented as an ERB template and the index is implemented using Haml.
如果你仔细思考一下前面对程序的修改，就能明白，程序的布局继续使用ERB模板，而索引页面本身用的还是Haml模板，这已经非常了不起了。
Despite this, everything integrates seamlessly and effortlessly.
尽管如此，所有一切都无缝、轻松地集合在了一起。

Although this clearly is a deeper level of integration than simply adding a task or a helper, it still is an addition.
虽然这种集成明显比简单添加任务或辅助器更深入一层，但实际上仍然是一种补充措施。
Next, let’s explore a plugin that changes a core object in Rails.
下面，让我们探索一种改变Rails核心对象的插件。

• 416

Figure 62—Storefront using Haml

## 25.3 Pagination 分页
At the moment, we have a few products, a few carts at any one time, and a few line items per cart or order, but we can have essentially an unlimited number of orders, and we hope to have many—enough so that displaying all of them on an orders page will quickly become unwieldy.
现在我们只有少量的商品和购物车，每个购物车或订单中只有少量的商品，但在本质上可以有任意多的订单，而且我们当然希望有足够多的订单，自然而然地我们会发现把所有这些显示在一个订单页面上十分笨拙。
Enter the kaminari plugin.
我们可以借助kaminari插件。
This plugin extends Rails to provide this much-needed function.
这个插件扩展了Rails，提供了一个十分有用的功能。

Now let’s generate some test data.
现在我们生成一些测试数据。
We could click repeatedly on the buttons we have, but computers are good at this.
我们可以重复单击已有按钮，但计算机更擅长做这件事。
This isn’t exactly seed data, simply something done once and thrown away.
这不完全是十个数据，只不过是需要做一次便可丢弃。
Let’s create a file in the script directory.
我们在script目录下创建一个文件。

    Download rails40/depot_v/script/load_orders.rb
    Order.transaction do
      (1..100).each do |i|
        Order.create(
          name: "Customer #{i}", 
          address: "#{i} Main Street",
          email: "customer-#{i}@example.com", 
          pay_type: "Check"
        )
      end
    end

This will create a hundred orders with no line items in them.
它会创建100个无商品的订单。
Feel free to modify the script to create line items if you are so inclined.
如果你想创建一些商品，尽管修改这个脚本。
Note that this code does all this work in one transaction.
注意，该代码在一个事务中完成所有这些工作。
This isn’t precisely required for this activity but does speed up the processing.
这虽然不是该活动百分百所需，但却可以加速整个进程。

Note that we don’t have any require statements or initialization to open or close the database.
注意，这里没有任何require语句或初始化来打开和关闭数据库。
We will allow Rails to take care of this for us.
我们让Rails来处理这个：

    rails runner script/load_orders.rb

• 417

Now that the setup is done, we are ready to make the changes necessary to our application.
现在设置完毕，可以开始对应用程序作出必要的修改了。
First, we modify our controller to call paginate(), passing it in the page and the order in which we want the results displayed.
首先，修改控制器以调用paginate()，并将我们想要显示结果的页面和订单传递给这个参数。

    Download rails40/depot_v/app/controllers/orders_controller.rb
    def index
    ➤ @orders = Order.order('created_at desc').page(params[:page])
    end

Next, we add links to the bottom of our index view.
然后，在索引视图的底部添加链接。

    Download rails40/depot_v/app/views/orders/index.html.erb
    <h1>Listing orders</h1>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Address</th>
          <th>Email</th>
          <th>Pay type</th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <% @orders.each do |order| %>
          <tr>
            <td><%= order.name %></td>
            <td><%= order.address %></td>
            <td><%= order.email %></td>
            <td><%= order.pay_type %></td>
            <td><%= link_to 'Show', order %></td>
            <td><%= link_to 'Edit', edit_order_path(order) %></td>
            <td><%= link_to 'Destroy', order, method: :delete,
              data: { confirm: 'Are you sure?' } %></td>
          </tr>
        <% end %>
      </tbody>
    </table>
    <br>
    <%= link_to 'New Order', new_order_path %>
    ➤ <p><%= paginate @orders %></p>


And that is all there is to it! 
这就完成了。
The default is to show thirty entries per page, and the links will show up only if there are more than one page of orders.
默认是每页显示30项，且仅当有多于一页的订单时链接才会出现。

• 418

The controller specifies the number of orders to display on a page using the :per_page option. 
利用:per_page选项，控制器指定了每页显示的订单数量。
See the following figure:
正如下图所示：

Figure 63—Showing ten orders out of more than a hundred

## What We Just Did 本章小结
Although this chapter did cover a few plugins, the purpose of this chapter wasn’t to cover any particular plugin in depth but to introduce you to some of the capabilities that plugins can provide.
虽然本章的确介绍了一些插件，但目的并不是要涵盖任何某个插件的内部细节，只是介绍了一些插件所提供的功能。
If we include the gems that we saw in previous chapters, we have seen plugins that simply add new features (Active Merchant and Capistrano), add some methods to model objects (kaminari), add a new templating language (Haml), and even add an interface to a new database (mysql).
如果把前面章节软件包页一并理解的话，插件就是：可以让你简单地添加新的功能（Active Merchant和Capistrano），给一些模型对象添加方法（kaminari），添加一些新的模板语言（Haml），甚至提供新的额数据库接口（mysql）。
If you think about it, there really isn’t all that much that a plugin can’t do.
如果仔细想想，插件真的没有什么做不到。

## 25.4 Finding More at RailsPlugins.org 在网站找到更多插件
<kinder:note> 真奇怪这一小节放在《本章小结》之后。但原文如此。本节为自译。
At this point, we have covered three plugins.
到目前已经介绍了三种插件。
Here are a few more to explore, grouped by categories:
这里列出更多的一些插件，分组如下：

• 419

• Some plugins implement behavior that was previously in the core of Rails and has since been moved out.
  一些插件实现的功能之前包含在Rails核心中，但现在已经移出核心。
As an example, instead of jQuery, the Prototype library was the one supported by default by previous versions of Rails.
比如，Prototype库；之前的Rails版本是默认支持它的，现在则是默认支持jQuery。
This has moved into a plugin named prototype-rails.[2] 
这个库已经移到一个叫prototype-rails的插件中。
[2].  https://github.com/rails/prototype-rails#readme

Others, like acts_as_tree [3] , have thrived as plugins.
其他的，比如acts_as_tree，也变成了插件。
[3].  https://github.com/rails/acts_as_tree#readme
And still others, like rails_xss [4], backport essential functionality from future versions of Rails in order to help with migration.
还有其他的，比如rails_xss，将在未来的Rails版本中保留基本功能，以便辅助迁移。
[4].  https://github.com/rails/rails_xss

• Some plugins actually implement significant pieces of common application logic and even user interface.
  一些插件实际上实现普通程序逻辑甚至是用户界面的关键片段。
The devise [5] and authlogic [6] plugins implement user authentication and session management.
devise和authentication插件实现了用户认证和会话管理。
[5].  https://github.com/plataformatec/devise#readme
[6].  https://github.com/binarylogic/authlogic#readme
We implemented these functions ourselves in Depot, but this is generally something we don’t recommend.
在Depot中我们自己实现了这些功能，但这种做法通常不推荐。
We’ve found that laziness pays: if somebody else has written a plugin for a function that you need to implement, that’s all the more time you can spend on your application.
我们已经发现了那个偷懒的方式：如果有人写了一个实现某项功能的插件，你刚好需要这个功能，那就拿过来吧。

• Some plugins replace large portions of rails.
  一些插件替换了rails的大部分功能。
For example, datamapper [7] replaces ActiveRecord.
比如用datamapper替换ActiveRecord。
[7].  http://datamapper.org/
The combination of cucumber,[8] rspec[9], and webrat [10] can be used separately or together to replace test scripts with plain test stories, specifications, and browser simulation.
cucumber，rspec和webrat可以独立使用，也可以组合在一起，以便用平面测试故事、规格和浏览器模拟来替换测试脚本。
[8].  http://cukes.info/
[9].  http://rspec.info/
[10]. https://github.com/brynary/webrat#readme

• airbrake [11] and exception_notification [12] will help you monitor errors in your deployed servers.
  airbrake和exception_notification可以帮你在检测在部署服务器的错误。
[11]. https://airbrakeapp.com/pages/home
[12]. https://github.com/rails/exception_notification#readme

Of course, this is but a small fraction of the set of plugins available.
当然，这是可用插件的一小部分而已。
And this list is continually growing; there undoubtedly will be many more available by the time you read this.
这个清单还会继续变长；等你读到这里时，一定有更多的可用插件。
Finally, you can obviously create your own plugins. 
最后，还可以创建自己的插件。
Although doing so is beyond the scope of this book, you can find out more in the Rails Guides [13] and documentation.[14]
尽管这么做已经超出本书的范围，但仍能在指南和文档中找到更多资料。
[13]. http://guides.rubyonrails.org/plugins.html
[14]. http://api.rubyonrails.org/classes/Rails/Railtie.html

# CHAPTER 26 Where to Go from Here  整装进发
 In this chapter, we’ll see
 在本章中，我们将学习：
• reviewing Rails concepts: model, view, controller, configuration, testing, and deployment; and
  复习rails的概念：模型、视图、控制器、配置、测试和部署。
• links to places for further exploration.
  连接到其他地方，继续探索

Congratulations! 
恭喜！
We’ve covered a lot of ground together.
大家已经完成了基础知识的学习。
In Part I, you installed Rails, verified the installation using a simple application, got exposed to the architecture of Rails, and got acquainted (or maybe reacquainted) with the Ruby language.
第一部分首先安装了Rails，然后通过简单的程序验证了安装过程，介绍了Rails框架的体系结构，认识了（或者说重新认识了）Ruby语言的知识。
In Part II, you iteratively built an application, built up test cases along the way, and ultimately deployed it using Capistrano.
第二部分，开始用迭代的方式建立程序，然后一句敏捷开发的模式搭建了测试案例，最终用Capistrano完成部署。
We designed this application to touch on all of the aspects of Rails that every developer needs to be aware of.
这个程序的设计目的就是让开发者接触到Rails应知应会的各个方面。

Whereas Parts I and II of this book each served a single purpose, Part III of this book served a dual role.
第一部分和第二部分目的单纯，第三部分则担负着双重目的。
For some of you, Part III methodically filled in the gaps and covered enough for you to get real work done.
对于一些读者来说，第三部分有条不紊地补充缺少的知识，涵盖足以应付真实环境的日常工作。
For others, this will be the first steps of a much longer journey.
对于其他读者来说，这正是漫漫长路的第一步而已。

For most of you, the real value is a bit of both.
对于大部分读者来说，真实的价值兼而有之。
A firm foundation is required in order for you to be able to explore further.
为了让读者有能力去进一步学习和探索，坚实的基础是必需的。
And that’s why we started this part with a chapter that not only covered the convention and configuration of Rails but also covered the generation of documentation.
这正是我们用了整整一章的内容来叙述的原因：不仅包括了Rails的惯例和配置，，还包含了文档生成。

Then we proceeded to devote a chapter each to the model, views, and controller, which are the backbone of the Rails architecture.
接着对模型、视图和控制器各用了一章的篇幅进行介绍，它们是Rails架构的基石。
We covered topics ranging from database relationships to the REST architecture to HTML forms and helpers.
涉及从数据库关联关系到REST架构，再到表单HTML和辅助器等话题。

We covered migration as an essential maintenance tool for the deployed application’s database.
涵盖了迁移，这是用于部署程序数据库的基本的维护工具。

• 422

Finally, we split Rails apart and explored the concept of gems from a number of perspectives, from making use of individual Rails components separately to making full use of the foundation upon which Rails is built and finally to building and extending the framework to suit your needs.
最后掰开Rails，从不同角度考察了软件包额概念：从分开使用Rails单独组件到完整利用Rails的基础功能；Rails本身就是搭建在其上并最终构建和扩展成适应实际需要的框架。

At this point, you have the necessary context and background to explore deeper whatever areas suit your fancy or are needed to solve that vexing problem you face.
这样，一旦拥有了贯通上下文环境的基础和背景，就会在面对任何复杂需求或棘手问题时，有能力在更深层面上找出解决实际应用的恰当途径。
We recommend you start by visiting the Ruby on Rails site [1] and exploring each of the links across the top of that page.
推荐访问Ruby on Rails，浏览网页上的每个连接。
[1]. http://rubyonrails.org/
Some of this will be quick refreshers of materials presented in this book, but you will also find plenty of links to current information on how report problems, learn more, and keep up-to-date.
其中会经常更新本书所提到的材料，还可找到大量有关报告问题，深入学习、保持与时俱进的信息。

Additionally, please continue to contribute to the wiki and forums mentioned in the book’s introduction.
另外，请继续参与本书所提到的wiki和论坛。
Pragmatic Bookshelf has more books on related Ruby and Rails subjects.[2] 
Pragmatic书架里有更多关于Ruby和Rails的书籍。
[2]. http://www.pragprog.com/categories/ruby_and_rails
There also are plenty of related categories that go beyond Ruby and Rails, such as Agile Practices; Testing, Design, and Cloud Computing; and Tools, Frameworks, Languages.
除了Ruby和Rails之外，包括大量相关的分类，比如敏捷实践、测试、设计、云计算、工具、框架、语言。

You can find these and other categories at http:// www.pragprog.com/categories.
可以在http:// www.pragprog.com/categories找到这些种类的书籍。

We hope you have enjoyed learning about Ruby on Rails as much as we have enjoyed writing this book!
希望你愉快地学习Ruby on Rails，正如我们以快乐的心情写完这本书。

# APPENDIX 1  附录
# Bibliography  参考书目
[Bur11]

Trevor Burnham. CoffeeScript: Accelerated JavaScript Development. The
Pragmatic Bookshelf, Raleigh, NC and Dallas, TX, 2011.

[CC11]

Hampton Catlin and Michael Lintorn Catlin. Pragmatic Guide to Sass. The
Pragmatic Bookshelf, Raleigh, NC and Dallas, TX, 2011.

[TFH13]

David Thomas, Chad Fowler, and Andrew Hunt. Programming Ruby: The
Pragmatic Programmer’s Guide. The Pragmatic Bookshelf, Raleigh, NC and
Dallas, TX, Fourth Edition, 2013.

# Index   索引
SYMBOLS
! suffix, 50
#, 39
#{…}, 40
%r{…}, 42
%{…}, 69
& prefix, 44
/…/, 42
: prefix, 38
<%=…%>, 21
<%=…>, 395
<<, 41
=>, 41
=~, 42
? suffix, 50
[’a’,’b’,’c’], 41
[…], 40, 42
{…}, 41
|, 42
||, 50
||=, 50

A
accepts attribute, 321
ACID properties, 308
Action Controller, 309, 319–
330
action_name attribute, 319
after_action, 338
asset_host (config), 358
before_action, 203, 338
flash attribute, 342
headers attribute, 320,
327, 330, 342
layout method, 360
logger attribute, 321, 342

method_missing, 319, 324
model method, 332
params attribute, 114,

288, 320, 342, 346
redirect_to, 126, 322, 329
render, 137, 322–323,

341, 361, 363
render_to_string, 326
request attributes, 320–

321, 342
respond_to, 315, 318
response attribute, 321,

342
send_data, 265, 326
send_file, 327
session attribute, 321,

331, 342
template_root (config), 322

Action Dispatch, 309–319
Action Mailer, 177–183
delivery_method (config), 177
receive, 184
smtp_settings (config), 178
action methods, 319
Action Pack, 34, 309
:action parameter, 324
Action View, 341–366
base_path attributes, 342
button_to, 128, 355
controller attributes, 342
link_to, 355
link_to_if, 356
link_to_unless, 356
link_to_unless_current, 356
using Action View
helpers, 390
action_name attribute, 319
Active Merchant, 411–413

Active Record, 275–308
after_create method, 299
after_destroy method, 207,
299
after_find method, 299, 302
after_initialize method, 299
after_save method, 299
after_update method, 299
after_validation method, 299
attribute_names, 293
attribute_present?, 293
attributes, 293
average, 291
before_create method, 299
before_destroy method, 299
before_save method, 299
before_update method, 299
before_validation method,
299
belongs_to method, 282–
283
count, 291
create, 285, 297
create!, 297
creating new rows, 284–
286
custom SQL queries, 293
data validation, 77–82,
165
delete, 298
delete_all, 298
deleting rows, 298
destroy, 298, 307
destroy_all, 298
find, 286
find_by_sql, 293–295
group method, 291
has_and_belongs_to_many

method, 283
has_many method, 109,

283

Index
has_one method, 282
hook methods, 207
joins method, 290
lock method, 291
maximum, 291
minimum, 291
object-relational mapping, 33–34
offset method, 290
order method, 289
plugin to replace, 419
primary keys, 275, 280–
281
primary_key= method, 281
read_attribute, 279
readonly method, 291
RecordNotFound exception,
125
reload, 295
save, 284, 295, 297, 307
save!, 297, 305
scopes, 292
select method, 290
and SQL, 286–298
in stand-alone applications, 385–386
sum, 291
tables, 275–283
transaction, 304
update, 296
update_all, 296
updating rows, 295–297
write_attribute, 279
Active Support libraries, 386–
390
adapters, database, 13
add_column method, 370
add_index method, 378
add_table method, 375
after callbacks, 338
after_action method, 338
:except parameter, 338
:only parameter, 338
after_create method, 299
after_destroy method, 207, 299
after_find method, 299, 302
after_initialize method, 299
after_save method, 299
after_update method, 299
after_validation method, 299
Agile Manifesto, xiii
Ajax
coining of, 135
request to application,
142

response from application, 143–144
testing, 154–157
troubleshooting, 145
animate method, 149
Apache web server, 236–239
app/ directory, 263
application.html.erb, 71, 96
applications
analysis and design, 56–
60
basic workflow, 24
creating, 15, 61
deployment, 233–250
directory structure, 262,
264
documentation, 256
exception handling, 124–
126
integration testing, 184–
189
internationalization of,
211–230
monitoring, 248
nonbrowser, 385–391
performance tweaking,
250
reloading code, 23
RESTful, 310
URL of, 19, 24, 92
around callbacks, 338–339
assert method, 83
assert_select method, 102
assertions, 83–84
asset_host (config), 358
assigns method, 114
Atom feeds, 172–176, 357
attachment_fu plugin, 350
attribute_names method, 293
attribute_present? method, 293
attributes, 277–280
accepts (request object),
321
action_name (Action Controller), 319
base_path (Action View),
342
body (request object), 321
content_length (request object), 321
content_type (request object), 321
controller (Action View), 342
domain (request object),
320
env (request object), 321

• 426

flash (Action Controller),

342
format (request object),

321
headers (Action Controller),

320, 327, 330, 342
headers (request object),

321
host (request object), 320
host_with_port (request ob-

ject), 320
logger (Action Controller),

321, 342
method (request object),

320
params (Action Controller),

114, 288, 320, 342,
346
path (request object), 320
port (request object), 320
port_string (request object),
321
protocol (request object),
320
query_string (request object), 320
remote_ip (request object),
321
request (Action Controller),
320–321, 342
request_method (request object), 320
response (Action Controller), 342
session (Action Controller),
321, 331, 342
ssl? (request object), 321
url (request object), 320
attributes method, 293
authlogic plugin, 419
auto_discovery_link_tag method,
357
average method, 291

B
:back parameter, 330

bang methods, 50
base_path attributes, 342
:bcc parameter, 357
before action, 202
before callbacks, 338
before_action method, 203, 338
:only parameter, 338
before_create method, 299
before_destroy method, 299
before_save method, 299

Index
before_update method, 299
before_validation method, 299
belongs_to method, 282–283
bin/ directory, 267
blind effect, 149
BlueCloth, 355
body attribute, 321
:body parameter, 357

browsers
disabling JavaScript, 145
DOM inspectors, 158
Firefox NoScript plugin,
158
Internet Explorer quirks
mode, 145
reloading pages, 144
:buffer_size parameter, 327
Builder templates, 342, 393
Bundler
for dependency management, 397–400
installing Capistrano,
244
pack command, 244
update command, 400
button_to method, 128, 355

C
callbacks, 202–204, 298–
304, 337–339
sequence, 299
skipping, in child controllers, 203, 339
Capistrano, 242–248
:cc parameter, 357
change method, 371
change_column method, 374
class methods, 46
classes, 37, 45–47
in Active Record, 276
automatic loading, 271
naming conventions, 270
CoffeeScript, 153–154, 156,
343
:collection parameter, 137, 316,
364
command line
learning, 9
multiple-line commands,
62
tab completion, 9
config.ru, 262, 400
config/ directory, 268

configuration parameters
asset_host (Action Controller), 358
delivery_method (Action
Mailer), 177
smtp_settings (Action Mailer), 178
template_root (Action Controller), 322
:confirm parameter, 355
console window, 17
console, Rails, 206, 248, 267
constructors, 38
content_length attributes, 321
content_tag helper, 151
content_type attribute, 321
:content_type parameter, 326
continuous integration system, 9
controller attributes, 342
controllers
accessing request information, 319–321
and Action Controller,
319–330
action methods, 319
callbacks, 202–204, 337–
339
default behavior, 19
defined, 30
in Depot application, 254
error logging, 126
flash data, 336
functional testing, 185
generating, 18
grouping into modules,
271
helper methods, 352–358
layout declaration, 360
model declaration, 49
naming conventions, 270
and partial templates,
365
in Rails, 35
redirects, 126, 129, 327–
330
responding to user, 321–
330
returning files, 326
standard location, 21
convention over configuration, xii, 255
cookies, 320, 332
count method, 291
create method, 285, 297
create! method, 297

• 427

create_table method, 375
credit card processing, 411–
413
cross-site request forgery attacks, 97
CRUD methods, 275, 284
css method, 149
CSS stylesheets
Sassy CSS, 71, 99, 140
selector notation, 102
standard location, 70
tables, 130
currency
converting numbers to,
100, 353
localizing, 221
current_page method, 356
cycle method, 73, 354

D
data types
database columns, 371–
373
in Ruby, 39–43
SQL to Ruby mappings,
279
data validation
in models, 77–82, 165
unit testing, 83–89
databases, see also Active
Record
adapters for Rails, 13
column types, 371–373
configuration troubleshooting, 241
creating, 62–64
development vs. production, 239
foreign keys, 109, 169,
282, 379–382
importing seed data, 69
join tables, 283
managing tables, 375–
379
model-table mappings,
62, 277–280
object-relational mapping, 32–34
preconfigured by Rails,
87
primary keys, 275, 280
rollback, 207, 382
row locking, 291
supported by Rails, 12–
13

Index
table names, 270, 273–
275
transactions, 304–308
datamapper plugin, 419
DB2, 13
debug method, 342, 354
declarations
after_create (Active Record),
299
after_destroy (Active
Record), 299
after_find (Active Record),
299
after_initialize (Active
Record), 299
after_save (Active Record),
299
after_update (Active Record),
299
after_validation (Active
Record), 299
before_create (Active
Record), 299
before_destroy (Active
Record), 299
before_save (Active Record),
299
before_update (Active
Record), 299
before_validation (Active
Record), 299
belongs_to (Active Record),
282–283
has_and_belongs_to_many (Active Record), 283
has_many (Active Record),
283
has_one (Active Record),
282
layout (Action Controller),
360
model (Action Controller),
332
primary_key= (Active
Record), 281
default_url_options, 213, 215
delete method, 298
delete? method, 320
delete_all method, 298
delivery_method (config), 177
:dependent parameter, 109
deployment, 233–250
deployment servers, 242–
244
Depot application
access control, 202–204

analysis, 56–60
cart design, 59
cart, basic, 107–115,
119–123, 128–132
cart, in sidebar, 136–142
cart, with Ajax, 142–152
catalog display, 91–106
checkout, 159–172
credit card processing,
411–413
data analysis, 58–59
data validation, 77–82
data, seed, 69
deployment, 233–250
development approach,
55, 60
directory structure, 264
emails, 177–183
error handling, 124–128
functional testing, 101–
106, 130, 154–157,
169–170, 183, 201
integration testing, 184–
189
internationalization of,
211–230
MVC architecture, 253–
255
order creation, 159–172
order reporting, 172
page flows, 57–58
page layout, 96–99
pagination, 416–417
prices, 59, 100, 131
product listing, 70–73
products database, 62–64
products maintenance
application, 61–73
quantities, 119–123
unit (model) testing, 82–
89
use cases, 56
users, administering,
192–196, 204–208
users, authenticating,
197–204
users, logging in, 191–
192
destroy method, 298, 307
destroy_all method, 298
development
development database,
88
environment, 9–13
incremental, 55, 61
recover actions, 60
reloading application
code, 23

• 428

runtime environment
setting, 269
use cases, 56
devise plugin, 419
directory listing, 16
:disposition parameter, 326–327
distance_of_time_in_words method,
353
doc/ directory, 265
DOCTYPE header, 145
documentation
application, 256
for Rails, xvii, 13, 265
DOM inspectors, 158
DOM manipulation, 143
domain attribute, 320
down method, 122, 370
drop_table method, 375
DRY (Don’t Repeat Yourself),
xii

E
editors, 9–11
Emacs, 9
email
creating mailers, 179
delivery method, 177–178
multiple content types,
182
receiving, 184
sending, 179–182
SMTP settings, 178
templates, 180
:encode parameter, 357
encryption, using callback
handler, 301–304
entity names, 212, 219, 226
env attribute, 321
environments, runtime
custom, 269
development, 23
and email delivery, 177–
178
and Gemfile, 239, 399
purpose of, 269
switching, 256, 269
ERB (Embedded Ruby) templates, 21, 24, 35, 343,
395–397
.erb extension, 21
error messages
comparing to built-in, 89
errors object, 110
logging, in controller, 126

Index
testing, 84
translating, 224–228
using flash, 125, 337
:except parameter, 338
exception handling
in Active Record searches, 287
automatic rollback, 207
in Rails applications,
124–126
rescue statement, 45, 126
in Ruby, 45
excerpt method, 354
execute method, 379

F
feeds, 172–176
file_field method, 349
:filename parameter, 326–327
files
returning, 326
uploading, 348–351
filter method, 338
find method, 286
:order parameter, 289
:select parameter, 290
find_by_sql method, 293–295
Firebird, 13
fixtures, 85–89
fixtures method, 87
flash attributes, 342
flash data, 336
sending error messages,
125
translating messages,
227
form_for method, 162
form_tag method, 198
:multipart parameter, 349
format attribute, 321
:format parameter, 318
format.atom, 173
forms
data flows, 199
data validation, 165
file_field, 349
form helpers, 162, 343–
346
form_for, 162–163
form_tag, 198, 229
label_tag, 198
login page, 198
password_field_tag, 198

G
gem server, xvii
Gemfile, 8, 239, 262, 397–400
Gemfile.lock, 263

H
Haml, 413–415
handler classes, 300–304
has_and_belongs_to_many method,
283
has_many method, 109, 168,
283
has_one method, 282
has_secure_password method, 192
head? method, 320
headers attribute, 320–321,
327, 330, 342
helper methods, 26
default, 352
for emailing, 357
for formatting, 353–355
for forms, 343–346
for JavaScript, 358
for linking, 355–357
location of, 151, 264, 352
as modules, 47
writing, 150–151, 352
helpers
auto_discovery_link_tag, 357

429

current_page, 356
cycle, 73, 354
debug, 342, 354
distance_of_time_in_words, 353
excerpt, 354
highlight, 354
image_tag, 94, 356
j, 144
javascript_include_tag, 357
javascript_link_tag, 357
link_to, 26
mail_to, 357
number_to_currency, 100, 353
number_to_human_size, 353
number_to_percentage, 353
number_to_phone, 353
number_with_delimiter, 353
number_with_precision, 353
pluralize, 354
raw, 396
safe_join, 396
sanitize, 94, 397
simple_format, 354
strip_tags, 73
stylesheet_link_tag, 97, 357
time_ago_in_words, 353
truncate, 73, 354

processing submitted data, 346–347
select_tag, 229
submit_tag, 229
text_area, 164
text_field, 162
text_field_tag, 198
translating, 222–224

gems, 397–400, 405, 411–412
generator scripts
controller, 18, 91
integration_test, 185
mailer, 179
migration, 368
model, 368
scaffold, 62, 110
get method, 186
get? method, 320
Git
for deployment, 242–244
for development, 74
.gitignore file, 75
Gmail SMTP settings, 178
:greater_than_or_equal_to parameter, 79

• highlight method, 354

hook methods, 110, 207
host attribute, 320

host name mapping, 238
host_with_port attribute, 320
HTML Abstraction Markup
Language (Haml), 413–415
HTML entity names, 212,
219, 226
html method, 144
.html.erb files, 21, 136
html_safe, 212
HTTP
Content-Type header, 326
file uploading, 348
method selection, 75,
111, 200–201
redirects, 129, 327–330
Status header, 326
hyperlinks, generate with
link_to, 26

I
I18n module, 212–215

IDEs, 11–12
image_tag method, 94, 356
inflections.rb, 276
:inline parameter, 324

Index
installation, 3–8
instance methods, 46–47
instance variables, 38, 46
integration testing, 184–189
internationalization, 211–230

J
j method, 144
jEdit, 11
jQuery
alias to $, 144
html, 144
loading, 357
jQuery-UI library, 146–147
animate, 149
blind effect, 149
show, 149
JavaScript
and Ajax, 135
helper methods, 358
JSON, 142, 325, 389
RJS templates, 325
javascript_include_tag method,
357
javascript_link_tag method, 357
joins method, 290
.js.erb files, 144
JSON (JavaScript Object Notation), 142, 325, 389

K
kaminari plugin, 416
keys
foreign, 109, 169, 282,
379–382
primary, 275, 280, 378
Komodo IDE, 11

L
label_tag method, 198
language translation, 211–
230
layout method, 360
:layout parameter, 326, 361
layouts, 96–99, 358–362, 365
lib/ directory, 265
limit method, 289
link_to method, 26, 355
:confirm parameter, 355
:method parameter, 75,
316, 355
link_to_if method, 356
link_to_unless method, 356

link_to_unless_current method,

356
Linux
commands, multiple-line,
62
installing Rails, 6–8
log file viewing, 126
locale files, 217–222
locales
defining, 211
switching, 229–230
localization, 211–230
lock method, 291
log files
rolling over, 249
standard location, 267
viewing, 126, 248
log/ directory, 267
logger, 321, 342
logging in (users), 191–204

M
Mac OS X
commands, multiple-line,
62
enabling Apache, 236
installing MySQL, 239
installing Rails, 4–6
log file viewing, 126
mail_to method, 357
:bcc parameter, 357
:cc parameter, 357
:encode parameter, 357
mailers, 179–181
maximum method, 291
method attribute, 320
:method parameter, 75, 316,
355
method_missing method, 319,
324
methods (HTTP), 75, 111,
200–201
methods (Ruby), 38–39, 46–
47
private, 47, 108
migrations
add_column, 370
add_index, 378
adding columns, 119,
159
applying, 64, 369
change method, 371, 374
change_column, 374
column types, 371–373
create_table, 375

• 430

creating, 368
creating tables, 375–376
custom messages, 382
defined, 63
defining indices, 378
down, 370–371
execute, 379
irreversible, 374
naming convention, 367
and primary keys, 378
remove_column, 370
remove_index, 378
rename_column, 373
rename_table, 376
rolling back, 123, 369,
383
serious problem with,
382
up, 370
up vs. change, 371
using SQL, 379–382
MIME types, 318
minimum method, 291
MiniTest framework, 82
model method, 332
models
data validation, 77–82
defined, 29
in Depot application, 253
foreign keys, 109, 169,
282
mapping to forms, 162–
163
mapping to tables, 62
marshaling, 48
model object comparison,
281
naming conventions, 270
in Rails, 32–34
relationships between,
109, 282–283
scaffolds for, 62–63
standard location, 264
testing, 82–89
translating names, 226
modules, 47
grouping controllers into,
271
mixing in, 47
:multipart parameter, 349
MVC (Model-View-Controller),
29–30
in Depot application,
253–255
MySQL
adapter for, 13

Index
and InnoDB storage engine, 376
installing, 239
loading migrations, 240

N
naming conventions, 270–271
modifying the inflection
file, 276
:nothing parameter, 325
number_to_currency method,
100, 353
number_to_human_size method,
353
number_to_percentage method,
353
number_to_phone method, 353
number_with_delimiter method,
353
number_with_precision method,
353
numbers
formatting and converting, 100, 353
localizing, 221
precision, 353, 373
validating, 79

O
objects, 37
marshaling, 48
:only parameter, 338
Oracle, 13
:order parameter, 289
ORM (Object-Relational Mapping), 32, 275

P
page flows, 57
page layouts, 96–99, 358–362
pagination, 416–417
Paperclip plugin, 350
parameters
:action (render), 324
:back (redirect_to), 330
:bcc (mail_to), 357
:body (subject), 357
:buffer_size (send_file), 327
:cc (mail_to), 357
:collection (render), 137,
364
:collection (resources), 316
:confirm (link_to), 355
:content_type (render), 326

:disposition (send_data),

port attribute, 320

326–327
:disposition (send_file), 327
:encode (mail_to), 357
:except (after_action), 338
:filename (send_data), 326–
327
:filename (send_file), 327
:format (resource), 318
:inline (render), 324
:layout (render), 326, 361
:method (link_to), 75, 316,
355
:multipart (form_tag), 349
:nothing (render), 325
:only (after_action), 338
:only (before_action), 338
:order (find), 289
:partial (render), 137, 325,
363–365
:select (find), 290
:spacer_template (render),
364
:status (render), 325
:status (send_data), 327
:streaming (send_file), 327
:template (render), 325
:text (render), 324
:type (send_data), 326–327
:type (send_file), 327
:update (render), 325

port_string attribute, 321

:url_based_filename

(send_data), 327
:xml (render), 325
params attribute, 342, 346
params object, 114, 199, 288,

320, 346
:partial parameter, 137, 325,

363–365
partial-page templates, 136–
141, 363–366
with layouts, 365
shared, 365
Passenger, 236
password_field_tag method, 198
passwords
confirmation, 192, 194
obscuring, 346
_path, 26, 111, 129
path attribute, 320
Phusion Passenger, 236
placeholders, 345
plugins, 411–419
finding more, 418
Haml, 413–415
pluralize method, 354

• 431

post? method, 320
post_via_redirect method, 186

Postgres, 13
predicate methods, 50
prepend_after_action method, 338
prepend_before_action method,
338
:presence parameter, 78
primary_key= method, 281
private methods, 47, 108
production, see deployment
:prompt parameter, 164
protected methods, 47
protocol attribute, 320
Prototype, 419
public/ directory, 267
put? method, 320

Q
query_string attribute, 320

R
Rack, 262, 400–404
rackup command, 400, 402
Rails
agile practices in, xiii
application directory
structure, 16, 262
basic workflow, 24
dependency list, 405–409
documentation, xiii, xvii,
13, 256, 265
editors for, 9–11
IDEs for, 11–12
installing, 3–8
MVC architecture, xi, 17,
23, 30–35
naming conventions,
270–271
nonbrowser applications,
385–391
origin of, xiii
plugins, 411–419
README, 263
REST support, 312–315
test infrastructure, xi,
68–69
trends in use of, xi
using Rails methods,
386–390
versions, 8

Index
rails commands
test controllers, 104
test models, 83
rails scripts
console, 206, 248, 267
dbconsole, 267
destroy, 267
generate, 268
new, 15
runner, 268, 416
server, 17, 268–269
RAILS_ENV environment vari-

able, 240, 324, 386
rails_xss plugin, 419

RailsInstaller, 4
Rake
documentation for, 267
listing available tasks,
404
Rakefile, 263
writing tasks for, 266,
404
rake commands
db:migrate, 64, 369
db:schema_migrations, 266
db:seed, 69
doc:app, 256
doc:guides, 265
doc:rails, 265
middleware, 402
routes, 312
stats, 257
test, 68
Rakefile, 404
raw method, 396
RDoc, 256
read_attribute method, 279
README.rdoc, 256
readonly method, 291
receive method, 184
RecordNotFound exception, 286
redcarpet, 265
RedCloth, 355
redirect_to method, 126, 322,
329
:back parameter, 330
redirects (HTTP), 126, 129,
327–330
reload method, 295
:remote parameter, 142
remote_ip attribute, 321
remove_column method, 370
remove_index method, 378
rename_column method, 373

• 432

rename_table method, 376

require, 266

render method, 137, 322–323,

rescue statement, 45, 126

341, 361, 363
:action parameter, 324
:collection parameter, 137,
364
:content_type parameter,
326
:inline parameter, 324
:layout parameter, 326,
361
:nothing parameter, 325
:partial parameter, 137,
325, 363–365
:spacer_template parameter,
364
:status parameter, 325
:template parameter, 325
:text parameter, 324
:update parameter, 325
:xml parameter, 325
render_to_string method, 326
request attributes
accepts, 321
body, 321
content_length, 321
content_type, 321
delete?, 320
domain, 320
env, 321
format, 321
get?, 320
head?, 320
headers, 321
host, 320
host_with_port, 320
method, 320
path, 320
port, 320
port_string, 321
post?, 320
protocol, 320
put?, 320
query_string, 320
remote_ip, 321
request_method, 320
ssl?, 321
url, 320
xhr?, 320
xml_http_request?, 320
requests
handling, 30–32
processing by controllers,
319–330
response object, 321
routing to applications,
309–319
session object, 321

resource method
:collection parameter, 316
:format parameter, 318

resources
controller actions, 313–
316
defined, 311
nested, 317
routes generated, 312
respond_to method, 315, 318
response attribute, 342
response object, 321
REST (Representational State
Transfer), 310
Rails support for, 312–
315
verbs, 311
RJS templates, 325
routes
and locale, 213
editing config/routes.rb, 92,
200, 212
feeds, 175
HTTP method selection,
75, 111, 200–201
MIME types in, 318
nesting, 317
_path, 26, 129
redirect, 126, 129
resource-based, 312–319
selecting data representation, 318
set root URL, 92
_url, 129
URL parsing, 24, 31
RSS feeds, 173, 357
Ruby
accessors, 46
array literals, 40
arrays, 40–42
assignment shortcuts, 50
bang methods, 50
class methods, 46
classes, 45–47
code blocks, 44
collections, 40–42
comments, 39
compound statements,
39
conditional evaluation, 50
control structures, 43–45
data types, 39–43
declarations, 46
do, 44
end, 43

Index
exceptions, 45
expression interpolation,
40
hash literals, 41
hashes, 40–42
idioms and gotchas, 50–
52
if, 43
indentation, 39
installing, 4–7
instance methods, 46–47
instance variables, 46
iterators, 44
lambda, 51
marshaling objects, 48
methods, 39, 46–47
modules, 47
names, 38, 270
nil, 40
object orientation, 37–38
predicate methods, 50
private methods, 47
protected methods, 47
Rails core extensions to,
387–388
RDoc utility, 256
regular expressions, 42
require, 51, 266
rescue statement, 45, 126
scope declaration, 213
self.new, 50
sprintf, 100
statement modifiers, 43
string literals, 39, 69
strings, 39
symbols, 38
unless, 43
until, 43
while, 43
yield statement, 44, 97,
359
RubyGems, xvii
RUBYLIB environment variable,
386
RubyMine IDE, 11
RVM (Ruby Version Manager),
4–8, 246

S
safe_join method, 396
sanitize method, 94, 397
save method, 284, 295, 297,

307
save! method, 297, 305

scaffolds, 62–63, 110

schemas
manipulating in applications, 383
vs. models, 277
primary keys, 280
updating, 63, 119, 370,
382
scopes
Active Record, 292
Ruby, 213
scriptlets, 396
SCSS (Sassy CSS), 71, 99,
140, 343
security
application access control, 202–204
cross-site request attacks, 97
exception handling, 124–
126
form data validation, 166
SQL injection attack, 287
user authentication, 191–
204
seeds.rb, 69
:select parameter, 290
select_tag helper, 229
send_data method, 265, 326
:disposition parameter, 326–
327
:filename parameter, 326–
327
:status parameter, 327
:type parameter, 326–327
:url_based_filename parameter, 327
send_file method, 327
:buffer_size parameter, 327
:disposition parameter, 327
:filename parameter, 327
:streaming parameter, 327
:type parameter, 327
sendmail, 178
session attributes, 342
session object, 321, 331
sessions, 331–336
and cookies, 332
expiry and cleanup, 335
flash data storage, 125
login support, 197–201
and model declaration, 49
session object, 321, 331
shopping cart implementation, 107–108
storage options, 331,
334–335

• 433

show method, 149
simple_format method, 354
skip_before_action, 203

SMTP, 178
smtp_settings (config), 178
:spacer_template parameter, 364

SQL (Structured Query Language), 286–298, 379–382
data types, mapping to
ruby, 279
SQL Server, 13
SQLite 3
adapter, 13
advantages, 62
limitations, 239
ssl? method, 321
:status parameter, 325, 327
:streaming parameter, 327
strip_tags method, 73
Struts, xi
stylesheet_link_tag method, 97,
357
subject method, 357
submit_tag helper, 229
Subversion, 242
sum method, 291

T
tables
column statistics, 291
columns and migrations,
119, 159, 371–374
columns and models,
277–280
creating, 62–64
creating rows, 284–286
defining indices, 378
deleting rows, 298
derived columns, 294
join tables, 283
managing with migrations, 375–379
names of, 270, 273–275
object-relational mapping, 32–34
without primary key, 379
primary keys, 280
queries by primary key,
286
reading, 286–294
relationships between,
282–283
renaming, 376
updating rows, 295–297
Tapestry, xi

Index
tasks/ directory, 266
:template parameter, 325
template_root (config), 322
templates
accessing controller object, 342
Builder, 342, 393
CoffeeScript, 153–154,
343
and collections, 364
drawbacks of code in,
351
email, 180
environment of, 342
ERB, 21, 24, 35, 343,
395–397
file uploading, 348–351
form helpers, 343–346
Haml, 413–415
HTML, 20, 65–67
layouts, 96–99, 358–362
location of, 341
partial, 136–141, 363–
366
rendering, 322–326, 363–
366
RJS, 325
SCSS, 71, 99, 140, 343
translating, 215–220
XML, 393
test/ directory, 263
testing
assert, 83
assertions, 83–84
automatic test generation, 68
controller tests, 81
in Depot application, 255
fixtures, 85–89
functional tests, 101–
106, 130, 154–157,
201
get, 186
integration tests, 184–
189
model unit tests, 82–89
post_via_redirect, 186
runtime environment
setting, 178
test database, 88
xml_http_request, 186
:text parameter, 324
text_area method, 164
text_field method, 162
text_field_tag method, 198

TextMate, 10, 12
time
calculations and conversions, 353, 390
displaying, 22–23
time_ago_in_words method, 353
tmp/ directory, 268
transaction method, 304
transactions, 304–308
truncate method, 73, 354
:type parameter, 326–327

• 434

standard location, 21
static HTML templates,
20, 65–67
writing helper methods,
150–151
Vim, 9
visual effects
blind effect, 149
hide/reveal items, 149–
151
highlight changes, 146–
149

U

W

:uniqueness parameter, 80

Web 2.0, xi
web server
development vs. production, 236
Rails interface to, 400–
404
restarting, 60
starting, 17, 65, 268
stopping, 17
WEBrick, 17
-e environment option,
269
Windows
commands, multiple-line,
62
Cygwin and MySQL, 242
installing Rails, 4
log file viewing, 126
tail command, 126
write_attribute method, 279

unit testing, 82–89
up method, 370
update method, 296
:update parameter, 325
update_all method, 296
_url, 313
url attribute, 320
:url_based_filename parameter,
327
URLs
of applications, 19, 24
default_url_options, 213, 215
redirect, 126, 129
setting website root, 92
_url vs. _path, 129
validating, 80
use cases, 56
user authentication, 191–204

V
validates method, 78
vendor/ directory, 268

version control system, 9
Git, 74
views
adding buttons, 110–
112, 128
defined, 29
in Depot application, 254
dynamic page updates,
142–144
HTML forms, 162–166,
198, 343–347
location of, 341
pathnames to, 93
in Rails, 34–35
rendering templates,
322–326
for RESTful actions, 315

X
xhr? method, 320

XML
request response types,
318
templates, 393
:xml parameter, 325
xml_http_request method, 186
xml_http_request? method, 320

Y
YAML
defined, 48
for test data, 85–86
for locale files, 217
request response types,
318
tab sensitivity, 242
yield statement, 44, 97, 359

# The Modern Web  现代web
Get up to speed on the latest HTML, CSS, and JavaScript techniques.

HTML5 and CSS3 are more than just buzzwords—they’re the foundation for today’s web applications. This book gets you up to speed on the HTML5
elements and CSS3 features you can use right now in
your current projects, with backwards compatible solutions that ensure that you don’t leave users of older
browsers behind. This new edition covers even more
new features, including CSS animations, IndexedDB,
and client-side validations.
Click Watch Me for a free screencast on Web Workers.
Brian P. Hogan
(300 pages) ISBN: 9781937785598. $38
http://pragprog.com/book/bhh52e

With the advent of HTML5, front-end MVC, and
Node.js, JavaScript is ubiquitous—and still messy.
This book will give you a solid foundation for managing
async tasks without losing your sanity in a tangle of
callbacks. It’s a fast-paced guide to the most essential
techniques for dealing with async behavior, including
PubSub, evented models, and Promises. With these
tricks up your sleeve, you’ll be better prepared to
manage the complexity of large web apps and deliver
responsive code.
Trevor Burnham
(104 pages) ISBN: 9781937785277. $17
http://pragprog.com/book/tbajs

# Put the “Fun” in Functional and Dive Deeper into Rails 函数式编程和深入Rails
Elixir puts the “fun” back into functional programming. And by the creator of Elixir: go
further into the depths of Rails itself.

You want to explore functional programming, but are
put off by the academic feel (tell me about monads just
one more time). You know you need concurrent applications, but also know these are almost impossible to
get right. Meet Elixir, a functional, concurrent language
built on the rock-solid Erlang VM. Elixir’s pragmatic
syntax and built-in support for metaprogramming will
make you productive and keep you interested for the
long haul. This book is the introduction to Elixir for
experienced programmers.
Dave Thomas
(240 pages) ISBN: 9781937785581. $36
http://pragprog.com/book/elixir

Get ready to see Rails as you’ve never seen it before.
Learn how to extend the framework, change its behavior, and replace whole components to bend it to your
will. Eight different test-driven tutorials will help you
understand Rails’ inner workings and prepare you to
tackle complicated projects with solutions that are
well-tested, modular, and easy to maintain.
This second edition of the bestselling Crafting Rails
Applications has been updated to Rails 4 and discusses
new topics such as streaming, mountable engines, and
thread safety.
José Valim
(200 pages) ISBN: 9781937785550. $36
http://pragprog.com/book/jvrails2

# The Joy of Math and Healthy Programming 数学和健康编程的乐趣
Rediscover the joy and fascinating weirdness of pure mathematics, and learn how to take
a healthier approach to programming.

Mathematics is beautiful—and it can be fun and exciting as well as practical. Good Math is your guide to
some of the most intriguing topics from two thousand
years of mathematics: from Egyptian fractions to Turing machines; from the real meaning of numbers to
proof trees, group symmetry, and mechanical computation. If you’ve ever wondered what lay beyond the
proofs you struggled to complete in high school geometry, or what limits the capabilities of the computer on
your desk, this is the book for you.
Mark C. Chu-Carroll
(282 pages) ISBN: 9781937785338. $34
http://pragprog.com/book/mcmath

To keep doing what you love, you need to maintain
your own systems, not just the ones you write code
for. Regular exercise and proper nutrition help you
learn, remember, concentrate, and be creative—skills
critical to doing your job well. Learn how to change
your work habits, master exercises that make working
at a computer more comfortable, and develop a plan
to keep fit, healthy, and sharp for years to come.
This book is intended only as an informative guide for
those wishing to know more about health issues. In no
way is this book intended to replace, countermand, or
conflict with the advice given to you by your own
healthcare provider including Physician, Nurse Practitioner, Physician Assistant, Registered Dietician, and
other licensed professionals.
Joe Kutner
(254 pages) ISBN: 9781937785314. $36
http://pragprog.com/book/jkthp

# The Pragmatic Bookshelf  实务书架
The Pragmatic Bookshelf features books written by developers for developers. The titles
continue the well-known Pragmatic Programmer style and continue to garner awards and
rave reviews. As development gets more and more difficult, the Pragmatic Programmers will
be there with more titles and products to help you stay on top of your game.

Visit Us Online
This Book’s Home Page
http://pragprog.com/book/rails4

Source code from this book, errata, and other resources. Come give us feedback, too!

Register for Updates
http://pragprog.com/updates

Be notified when updates and new books become available.

Join the Community
http://pragprog.com/community

Read our weblogs, join our online discussions, participate in our mailing list, interact with
our wiki, and benefit from the experience of other Pragmatic Programmers.

New and Noteworthy
http://pragprog.com/news

Check out the latest pragmatic developments, new titles and other offerings.

Buy the Book
If you liked this eBook, perhaps you'd like to have a paper copy of the book. It's available
for purchase at our store: http://pragprog.com/titles/rails4

Contact Us
Online Orders:

http://pragprog.com/catalog

Customer Service:

support@pragprog.com

International Rights: translations@pragprog.com
Academic Use:

academic@pragprog.com

Write for Us:

http://pragprog.com/write-for-us

Or Call:

+1 800-699-7764

