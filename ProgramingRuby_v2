Programming Ruby version 2nd
# 本书基本情况

    作 者：（美）托马斯，（美）弗沃尔，（美）亨特　著，
            孙勇，姚延栋，张海峰　译
    出 版 社：电子工业出版社
    出版时间：2007-3-1
    版 次：1 页 数：830 字 数：1000000
    印刷时间：2007-3-1 开 本： 纸 张：胶版纸
    印 次： I S B N：9787121038150 包 装：平装

## 第1版序
## 第2版序
## 前言
你可以集中精力于解决手头上的问题而不是与编译和语言本身周旋。
本文阐述的是
## 路线图
# 第1部分　Ruby面面观
# 　第1章　入门
## 　　1.1　安装Ruby
## 　　1.2　运行Ruby
###      1.2.1 交互式Ruby

    $ irb
    ...

irb(interactive ruby)是一个ruby shell。包括命令行历史、行编辑、作业控制。详见”15.1 命令行“ 的介绍。
运行已经存在的代码示例：
1. 在irb中装载程序文件。如：`> load "code/path/example.rb"`
2. 调用其中包含的方法。 如：`>  Fibonacci.upto(20)`
###      1.2.2 Ruby程序
1. 使用ruby解释：

    $ ruby my.rb

2. 使用#!，最好使用`chomd +x program.rb`，这样就可以使用`./program.rb`直接运行：

    #! /usr/local/bin/ruby -w
    ...

## 　　1.3　Ruby文档：RDoc和ri

许多库由内部RDoc系统进行文档化。其中的文档可以被提取出来，并转化为HTML或者ri格式
输入`$ ri 类名或方法名`，如`$ ri GC.start`或`$ ri Gc`或`$ ri start`

ri的帮助信息：`$ ri --help`

使用`--format ansi`选项可现实好看多彩的画面。
<kinder:note> 我的实践是没有没有必要，加入这个选项变得更糟。

# 　第2章　Ruby.new
## 　　2.1　Ruby是一门面向对象语言
你所操作的每样东西都是对象，操作结果本身也是对象。
编写面向对象的代码时，通常你得根据真实世界对概念进行建模...要挖掘出需要在代码中所表达的事物种类...需要定义**类（class）**来表示实体。类是状态和使用这些状态的方法的组合。
一旦建立了类，通常要为每个类创建若干**实例(instances)**。**“对象(object)”**这个概念和“类的实体(class instance)”等同互用，常用“对象”。

**构造函数**可以创建对象。标准的构造函数被称为new。
1. 每个对象有一个唯一的**对象标识符(object identifier,objectID)**
2. 可以定义一些**实例变量(instance variables)**。这些变量的值对于每个实体来说是独一无二的，持有对象的状态。

可以为每个类定义**实例方法(instance methods)**。
每个方法是一组功能。可能会在类的内部或从类的外部——依赖于访问约束——被调用。
这些实例方法反过来访问对象的实例变量及其状态。

方法是通过向对象发送消息来唤起调用的。消息包括方法名称和需要的参数。
当对象接收到一条消息时，它在自己的类中查找相应的方法，如找到则执行该方法。

## 　　2.2　Ruby的一些基本知识
**换行**无需分号；
**注释**以#开始，行尾结束；
**缩进**最好为两个空格；

**方法**：

    def method_name(arg1, arg2, ...)
    ...
    end

ruby方法返回的值，是最后一个被求值的表达式的值。

**字符串对象**
单引号串
双引号串：
1. 用二进制值替代反斜线序列，如\n
2. 替换表达式内插`#{表达式}`

**命名**惯例：
局部变量、方法参数、方法名称必须以小写字母或下划线开始。
$全局变量
@实例变量
@@类变量
类名称、模块名称、常量以大写字母开头。
包含多个单词的变量名称在词间使用下划线相连。
方法名称可以用?、!、=结束。
## 　　2.3　数组和散列表
数组和散列是被索引的收集，可以保存不同类型的对象（比如一个数组可以包含整数、字符串、浮点数）。
两者通过键来访问，数组的键是整数，散列则支持任何对象做键。
两者会按需调整大小来保存新的元素。
访问数组元素高效，但散列提供了灵活性。

**创建数组**

    a = [ 1, 'cat', 3.14 ]
    a[0] -> 1
    a[2] = nil
    a   -> [ 1, 'cat', nil ]  #注意很多语言nill指“没有对象”，ruby中nil是一个对象，表示没有任何东西的对象。

创建一**单词的数组**
a = [ 'ant', 'bee', 'cat' ]
a = %w{ant bee cat dog elk}  # <kinder:note> 要是单词包含空格就不行了。

**创建散列**
注意：在一个散列中，键必须是唯一的！

    inst_section = {
      'key'        => 'value'
      'clarinet'   => 'woodwind',
      'oboe'       => 'woodwind',
      'violin'     => 'string'
    }

**索引散列**
如果用散列中没有包含的键进行索引，就会返回nil

    p inst_section['oboe'] -> woodwind

**方法**
数组和散列包含大量方法，详见第四章和参考手册

##     2.4  symbols 符号(1.9版新增)
编程有时需要创建一些有意义的名称，例如东南西北的名称，一般需要使用常量。
这可以用符号来替代。符号提供了一个简单的常量名称，但无需预先声明，保证是唯一的。

    之前的写法：          现在的写法
    NORTH = 1             walk(:north)
    EAST  = 2             look(:east)
    SOUTH = 3
    WEST  = 4
    walk(NORTH)
    look(EAST)

hash的创建和索引也有了新的写法：

    第一种：                                                   第二种：
    inst_section = {                                           inst_section = {
    :cello => 'string',                                        cello: 'string',
    :clarinet => 'woodwind',                                   clarinet: 'woodwind',
    :drum => 'percussion',                                     drum: 'percussion',
    :oboe => 'woodwind',                                       oboe: 'woodwind',
    :trumpet => 'brass',                                       trumpet: 'brass',
    :violin => 'string'                                        violin: 'string'
    }                                                          }
    inst_section[:oboe] # => "woodwind"                        puts "An oboe is a #{inst_section[:oboe]} instrument"
    inst_section[:cello] # => "string"
    # Note that strings aren't the same as symbols...
    inst_section['cello'] # => nil

## 　　2.4　控制结构
ruby具有所有常见的控制结构：if语句，while循环，并以end表示结束。

    today = Time.now
    if today.saturday?
      puts "Do chores around the house"
    elsif today.sunday?
      puts "Relax"
    else
      puts "Go to work"
    end

大多数ruby语句会返回值，这意味可以把他们当作条件使用。

    while line = gets
      puts line.downcase
    end

**语句修饰符**statement modifier：

    puts "Danger, Will Robinson" if radiation > 3000
    square = 4
    square = square*square while square < 1000

## 　　2.5　正则表达式
正则表达式是一个强大的文本处理工具。
可惜只有脚本语言提供内建支持。通过内建而不是通过程序接口来支持它，有很大的不同。
介绍正则表达式：《精通正则表达式》Master RegularExpressions第二版。
本书的介绍在后面5.4节。

匹配操作符`~=`
如果在字符串中发现了模式，`~=`返回模式的开始位置，否则返回nil

字符串替换。

## 　　2.6　Block和迭代器
block,一种可以和“方法调用”想关联的代码块，几乎就像参数一样。
可以用block实现回调，传递一组代码，实现迭代器。

**语法形式**：

    { puts "Hello" }   # 第一种形式，单行，绑定更紧密写。
    do                 # 第二种形式，多行
      club.enroll(person)
      person.socialize
    end

**方法调用**
把block的开始放在含有方法调用的源码行的结尾，就可实现关联。如：

    greet { puts "Hi" }
    verbose_greet("Dave", "loyal customer") { puts "Hi"}  # 如果方法有参数

使用yield语句，可以一次或多次调用想关联的block。

    def call_block
      puts "Start of method"
      yield
      yield
      puts "End of method"
    end
    call_block { puts "In the block" }

输出:
Start of method
In the block
In the block
End of method

可以提供参数给yield调用，参数会传递到block中。。

    def who_says_what
      yield("Dave", "hello")
      yield("Andy", "goodbye")
    end
    who_says_what {|person, phrase| puts "#{person} says #{phrase}"}

输出:
Dave says hello
Andy says goodbye

ruby库中大量使用了大量block来**实现迭代器**。迭代器是从某种collection如数组中连续返回元素的方法。

     animals.each { |animal| puts animal }
     [ 'cat', 'dog', 'horse' ].each {|name| print name, " " }
     5.times { print "*" }
     3.upto(6) {|i| print i }
     ('a'..'e').each {|char| print char }

## 　　2.7　读/写文件
ruby有一个完备的I/O库。
但本书的大多数例子只使用其中一些简单的方法。

**puts**输出它的参数，并且在每个参数后面添加回车换行符。
**print**也输出它的参数，但没有添加回车换行符。
两者都可以用来向任何I/O对象进行输出，默认输出到标准输出。
**printf**在一个格式化的字符串控制下输出它的参数。

    `printf("Number: %5.2f, \nString: %s\n", 1.23, "Hello")
    # 输出：
    # Number: 1.23,  一个浮点数，最多五个字符，其中小数点后两个字符。\n 表示换行。
    # String: Hello`

**gets**函数
有很多方式可以把输入读到程序中。这是最传统的函数。
gets从程序的标准输入流中读取下一行。

    line = gets
    print line

##     2.9  命令行参数（1.9新增）
如果你在命令行运行一个ruby程序，你可以传递一个参数给他。
第一种方法，使用ARGV数组变量

    $ cat cmd_line.rb
    puts "You gave #{ARGV.size} arguments"
    p ARGV
    $ ruby cmd_line.rb ant bee car dog
    You gave 4 arguments
    ["ant", "bee", "cat", "dog"]

第二种方法，将ARGF变量作为一种特殊的I/O对象（就像文件的内容一样），其名称在命令行里传入。

详情见第二部分“ruby和ruby世界”中“命令行参数”一节。

## 　　2.8　更高更远

# 　第3章　类、对象和变量
**先创建一个基础的类**
首先包括一个**initialize**方法。
当调用new创建一个对象时，ruby首先分配一些内存来保存未初始化的对象，然后调用对象initialize方法，并把new的参数传入该方法。

    class BookInStock
      def initialize(isbn, price)
        @isbn = isbn
        @price = Float(price)
      end
    end

**@实例变量**
对象内的所有方法都可以访问实例变量，每个对象都有实例变量的一份拷贝。

    b1 = BookInStock.new("isbn1", 3)
    p b1    #<BookInStock:0x007fac4910f3e0 @isbn="isbn1", @price=3.0>
    b2 = BookInStock.new("isbn2", 3.14)
    p b2    #<BookInStock:0x007fac4910f0c0 @isbn="isbn2", @price=3.14>#
    b3 = BookInStock.new("isbn3", "5.67")
    p b3    #<BookInStock:0x007fac4910eda0 @isbn="isbn3", @price=5.67>

**`to_s`**
这是一个标准消息，可以发送给任何一个想要输出字符串表示的对象。

    class BookInStock
      def initialize(isbn, price)
        @isbn = isbn
        @price = Float(price)
      end
      def to_s                # 重写了to_s方法，以按照指定方式输出。
        "ISBN: #{@isbn}, price: #{@price}"
      end
    end
    b1 =  BookInStock.new("isbn1", 3)
    puts  b1  # ISBN: isbn1, price: 3.0 
    b2 =  BookInStock.new("isbn2", 3.14)
    puts  b2  # ISBN: isbn2, price: 3.14
    b3 =  BookInStock.new("isbn3", "5.67")
    puts  b3  # ISBN: isbn3, price: 5.67

## 　　3.1　继承和消息 (第四版删去)
继承允许你创建一个类，作为另一个类的精炼和特化。
如果定义一个类时没有指定其父类，ruby默认以object类作为其父类。这意味着object的实例方法（超过35个，详见27章内置类object节）对于ruby的所有对象都可用。

    class KaraokeSong < Song
      def initialize(name, aritst, duration, lyrics)
        super(name, artist, duration)  # super关键字，ruby向当前对象的父类发送一个消息，要求它调用子类中的同名方法，并将参数传递给父类的方法。
        @lyrics = lyrics
      end
      def to_s
        "KS: #@name--#@artist (#@duration [#@lyrics]"  
        # 因此可简化为：super + " [#@lyrics]"
      end
    end
    song = KaraokeSong.new("My Way", "Sinatra", 225, "And now, the ...")
    song.to_s    -->  "Ks: My Way--Sinatra (225 [And now, the ...])"

直接戳进父类的内部结构，并且显式得检验它的实例变量，会使代码和父类的实现仅仅绑在一起。
 
## 　　3.2　对象和属性
**属性**
定义一些方法来访问及操作对象的状态，让外部世界得以与之交流。一个对象的外部可见部分给称为其属性（attribute）
ruby中，只有一个直接父类，但可以从任何数量的mixin中include功能。这提供了可控的类似多继承的能力。

    # 因此这样的代码：                                这样就可以完成：
    class BookInStock                                class BookInStock
      def initialize(isbn, price)                      attr_reader :isbn, :price
        @isbn = isbn                                   def initialize(isbn, price)
        @price = Float(price)                            @isbn = isbn
      end                                                @price = Float(price)
      def isbn                                         end
        @isbn                                          # ..
      end                                            end
      def price                                      book = BookInStock.new("isbn1", 12.34)
        @price                                       puts "ISBN = #{book.isbn}"
      end                                            puts "Price = #{book.price}"
      # ..
    end
    book = BookInStock.new("isbn1", 12.34)
    puts "ISBN = #{book.isbn}"
    puts "Price = #{book.price}"

`attr_reader`实际上是ruby的一个方法，:name等symbol符号是其参数。它会通过代码求解动态地在song类中加入实例方法体。
`attr_reader :isbn`是一个表达式，返回对应isbn的一个symbol对象。可以将:isbn看作变量artist的名字，而普通的artist是变量的值。

### 3.2.1 可写属性
有时需要能够在一个对象外部设置它的属性。
一般的写法：                                  ruby常见的写法，使用`attr_accessor`

    class BookInStock                               class BookInStock
      attr_reader :isbn, :price                       attr_reader :isbn
      def initialize(isbn, price)                     attr_accessor :price
        @isbn = isbn                                  def initialize(isbn, price)
        @price = Float(price)                           @isbn = isbn
      end                                               @price = Float(price)
      def price=(new_price)                           end
        @price = new_price                            # ...
      end                                           end
      # ...
    end

    book = BookInStock.new("isbn1", 33.80)
    puts "ISBN = #{book.isbn}"     # ISBN = isbn1
    puts "Price = #{book.price}"   # Price = 33.8
    book.price = book.price * 0.75       # discount price
    puts "New price = #{book.price}"   # New price = 25.349999999999998

### 3.2.2 虚拟属性
这类属性访问（attribute-accesing）方法并不必须是对象实例变量的简单包装（wrapper）

    class BookInStock
      attr_reader :isbn
      attr_accessor :price
      def initialize(isbn, price)
        @isbn = isbn
        @price = Float(price)
      end
      def price_in_cents
        Integer(price*100 + 0.5)    # `+0.5`是浮点数×100之后出现误差的校正。33.8*100，结果是3379.9999。取整后结果为3379,需要0.5来校正。
      end
      def price_in_cents=(cents)
        @price = cents / 100.0
      end
      # ...
    end
    
    book = BookInStock.new("isbn1", 33.80)
    puts "Price = #{book.price}"                     # Price = 33.8
    puts "Price in cents = #{book.price_in_cents}"   # Price in cents = 3380
    book.price_in_cents = 1234                       # 这里看起来有个price_in_cents变量。实际上没有。这是个虚拟变量。
    puts "Price = #{book.price}"                     # Price = 12.34
    puts "Price in cnets = #{book.price_in_cens}"    # Price in cnets =1234

这里我们使用属性方法创建了一个虚拟的实例变量`price_in_cents`。然而，它没有对应的实例变量。
这远非出于讨巧。在Object-Oriented Software Construction(Bertrand Meyer,1997)中，称为统一访问原则（Uniform Access Principle）。通过隐藏实例变量与计算的值的差异，你可以向外部世界屏蔽类的实现！将来你可以自由更改对象如何运作，而不会影响使用了你的类的、数以百万行计的代码。这是一种很大的成功。

### 3.2.3 属性、实例变量及方法
从某种程度上，属性就是一个方法。某些时候，属性简单地返回实例变量的值；某些时候，属性返回计算后的结果；有些时候，那些名字以等号结尾的古怪方法，被用来更新对象的状态。
是什么使之成为属性，而非普通老式的方法呢？
当你设计一个类时，你决定其具有什么样的内部状态（保存在实例变量中），并决定这内部状态对外界（类的用户）的表现形式。
通过方法暴露出来的外部状态，就是属性（attributes）
通过把一个对象的外部状态称为属性，可以帮助人们了解你所编写的类。

## 　　3.3　类变量和类方法 (第四版删去)
到目前为止，所有我们创建的类都包括有实例变量和实例方法：变量被关联到类的某个特定实例，以及操作这些变量的方法。
但有时候，类本身需要他们自己的状态。
### 3.3.1 类变量
@@类变量是被类的所有对象所共享，与类方法相关联。
与全局变量和实例变量不同，类变量在使用之前必须被初始化。通常就是类定义中的简单赋值。
类变量对类和实例都是私有的，如果你想他们能够被外部世界访问，需要编写访问方法：可以是一个实例方法，也可以是下面的类方法。

### 3.3.2 类方法
有时类需要提供不束缚于任何特定对象的方法。如new方法。
类方法遍布于ruby库中。
类方法和实例变法是通过它们的定义区别开来的：在方法名之前放置类名以及一个句点

    class Example

      def instance_method   #实例方法
      end

      def Example.class_method # 类方法, 理解下面的写法见24章类与对象
      end

      def self.class_method2  # 类方法
      end

      def <<self # 类方法
      end
    end

### 3.3.3 单件与其他构造函数
有时希望覆写ruby默认的创建对象的方式。
使用Singleton模式，使得只有一种方式来创建对象，并保证只有一个对象被创建。

    class MyLogger
      private_class_method :new   #将new方法标记为私有，阻止所有人使用传统构造函数来创建。
      @@logger = nil
      def MyLogger.create
        @@logger = new unless @@logger   # 如果@@logger为false，@@logger为new
        @@loger                          # 返回@@logger
      end
    end
    # 注释：这个例子并非线程安全的，多线程环境可以使用Singleton mixin，见第四部分介绍。
    MyLogger.create.object_id  --> 946790
    MyLogger.create.object_id  --> 946790

使用类方法作为伪构造函数(preudo-constructors)，可以让使用类的用户更轻松写。
类方法还有许多有趣并强大的用途。


##     3.2  和其他类一起工作 （第四版新增）
Our original challenge was to read in data from multiple CSV files and produce various simple reports. So far, all we have is BookInStock, a class that represents the data for one book.
我们原本的挑战是从多个CSV文件中读取数据，并产生各种简单的报告。到目前为止，我们拥有的是BookInStock，一类表示一本书的数据。

During OO design, you identify external things and make them classes in your code. 
在面向对象设计期间，您识别外部的东西，让他们在你的代码中用类表示。
But there’s another source of classes in your designs. 
但在您的设计还有另一种类的资源。
There are the classes that correspond to things inside your code itself. 
你的代码里面本身有对应着东西的类。
For example, we know that the program we’re writing will need to consolidate and summarize CSV data feeds.
例如，我们知道，我们正在编写的程序将需要合并和总计CSV数据源。
 But that’s a very passive statement.
 但是，这是一个非常被动的语句。
Let’s turn it into a design by asking ourselves what does the summarizing and consolidating.
让我们把它转化为一个设计，通过问我们自身总计和合并什么。
And the answer (in our case) is a CSV reader. 
答案（在我们的案例）是一个CSV读卡器。
Let’s make it into a class as follows:
让我们把它归为一类，如下：

    class CsvReader
      def initialize
      # ...
      end
      def read_in_csv_data(csv_file_name)
      # ...
      end
      def total_value_in_stock
      # ...
      end
      def number_of_each_isbn
      # ...
      end
    end

We’d call it using something like this:
我们这样来调用它：

    reader = CsvReader.new
    reader.read_in_csv_data("file1.csv")
    reader.read_in_csv_data("file2.csv")
    : : :
    puts "Total value in stock = #{reader.total_value_in_stock}"

 We need to be able to handle multiple CSV files, 
我们需要能够处理多个CSV文件，
so our reader object needs to accumulate the values from each CSV file it is fed.
所以我们的reader对象需要从每个CSV文件反馈的累积值。
 We’ll do that by keeping an array of values in an instance variable. 
 我们会通过一个数组的值保持在一个实例变量来实现。
And how shall we represent each book’s data?
我们怎能代表每本书的数据？
 Well, we just finished writing the BookInStock class, so that problem is solved. 
 好了，我们刚写完的BookInStock类，从而解决这个问题。
The only other question is how we parse data in a CSV file. Fortunately, Ruby comes with a good CSV library (which has a brief description on page 741).
唯一的问题是我们如何解析一个CSV文件中的数据。幸运的是，Ruby有一个很好的CSV库（其中第741页有一个简短的描述，）。
Given a CSV file with a header line, we can iterate over the remaining rows and extract values by name:
给出一个CSV文件的标题行，我们可以遍历剩余的行并通过名称提取值：

    class CsvReader
      def initialize
        @books_in_stock = []
      end
      def read_in_csv_data(csv_file_name)
        CSV.foreach(csv_file_name, headers: true) do |row|
          @books_in_stock << BookInStock.new(row["ISBN"], row["Price"])
        end
      end
    end

Just because you’re probably wondering what’s going on, let’s dissect that `read_in_csv_data` method. 
仅仅因为你可能想知道发生了什么事情，让我们解剖`read_in_csv_data`方法。
On the first line, we tell the CSV library to open the file with the given name.
在第一行，我们给定名称告诉CSV库来打开该文件。
The headers: true option tells the library to parse the first line of the file as the names of the columns.
`headers: true`选项告诉库来解析该文件的第一行作为列名。

The library then reads the rest of the file, passing each row in turn to the block (the code 3 between do and end). 
然后库读取文件的其余部分，将每一行依次传给block块（do和end之间的代码）[3]。
Inside the block, we extract the data from the ISBN and Price columns and use that data to create a new BookInStock object. 
block内我们从ISBN和price列中提取数据，并使用这些数据来创建一个新的BookInStock对象。
We then append that object to an instance variable called `@books_in_stock`. 
我们再追加该对象到一个称为`@books_in_stock`的实例变量。
And just where does that variable come from? 
只是那个变量从何而来？
It’s an array that we created in the initialize method.
这是我们初始化方法创建的一个数组。

[3]
If you encounter an error along the lines of "‘Float’: can’t convert nil into Float (TypeError)" when you run this code, you likely have extra spaces at the end of the header line in your CSV data file. 
如果你遇到一个错误“浮点：不能将nil转化为浮点（类型错误）”，当你运行这个代码，你可能在你的CSV数据文件的第一行的结尾放了一个多余的空白符。
The CSV library is pretty strict about the formats it accepts.
CSV库对所接受的格式非常严格。

Again, this is the pattern you want to aim for.
再次，这是您想要的目标模式。
Your initialize method sets up an environment for your object, leaving it in a usable state. 
你的initialize方法为你的对象设置了一个环境，把它留在可用状态。
Other methods then use that state.
然后其他的方法使用该状态。

So, let’s turn this from a code fragment into a working program. 
所以，让我们把这从一个代码片段转换到一个工作程序。
We’re going to organize our source into three files. 
我们要将我们的源代码分成三个文件。
The first, `book_in_stock.rb`, will contain the definition of the class BookInStock. 
第一，`book_in_stock.rb`，将包含类BookInStock的定义。
The second, `csv_reader.rb`, is the source for the CsvReader class. 
第二，`csv_reader.rb`，是CsvReader类的源。
Finally, a third file, `stock_stats.rb`, is the main driver program. 
最后，第三个的文件，`stock_stats.rb`，是主要的驱动程序。
We’ll start with `book_in_stock.rb`:
我们先从`book_in_stock.rb`开始：

    #tut_classes/stock_stats/book_in_stock.rb
    class BookInStock
      attr_reader :isbn, :price
      def initialize(isbn, price)
        @isbn = isbn
        @price = Float(price)
      end
    end

Here’s the `csv_reader.rb` file. 
这是`csv_reader.rb`文件。
The CsvReader class has two external dependencies: 
CsvReader类有两个外部的依赖关系：
it needs the standard CSV library, and it needs the BookInStock class that’s in the file `book_in_stock.rb`. 
它需要标准CSV库，需要的在文件`book_in_stock.rb`的BookInStock类。
Ruby has a couple of helper methods that let us load external files. 
Ruby有一对辅助方法，让我们加载外部文件。
In this file, we use require to load in the Ruby CSV library and `require_relative` to load in the `book_in_stock` file we wrote. 
在这个文件中，我们使用require加载Ruby CSV库,`require_relative`加载我们写的`book_in_stock`文件。
(We use `require_relative` for this because the location of the file we’re loading is relative to the file we’re loading it from—they’re both in the same directory.)
（我们使用`require_relative`，这是因为我们加载中的文件的位置相对于我们正在从中加载的文件 - 它们都在同一个目录。）

    # tut_classes/stock_stats/csv_reader.rb
    require 'csv'
    require_relative 'book_in_stock'
    
    class CsvReader
      def initialize
        @books_in_stock = []
      end
      def read_in_csv_data(csv_file_name)
        CSV.foreach(csv_file_name, headers: true) do |row|
          @books_in_stock << BookInStock.new(row["ISBN"], row["Price"])
        end
      end
      def total_value_in_stock       # 稍后我们将看看如何使用inject来总计一个收集。
        sum = 0.0
        @books_in_stock.each {|book| sum += book.price}
        sum
      end
      def number_of_each_isbn
      # ...
      end
    end

And finally, here’s our main program, in the file `stock_stats.rb`:
最后，是主程序，在`stock_stats.rb`文件：

    # tut_classes/stock_stats/stock_stats.rb
    require_relative 'csv_reader'
    reader = CsvReader.new
    ARGV.each do |csv_file_name|
      STDERR.puts "Processing #{csv_file_name}"    # <kinder:note> 如果出现错误，则在终端输出错误。
      reader.read_in_csv_data(csv_file_name)
    end
    puts "Total value = #{reader.total_value_in_stock}"

Again, this file uses `require_relative` to bring in the library it needs (in this case, the `csv_reader.rb` file). 
再次，此文件使用`require_relative`带入需要的库（在这例子中，是`csv_reader.rb`文件）。
It uses the ARGV variable to access the program’s command-line arguments, loading CSV data for each file specified on the command line.
它使用ARGV变量来访问程序的命令行参数，为在命令行上指定的每个文件加载CSV数据。

We can run this program using the simple CSV data file as we showed on page 29:
我们可以用29页出现的简单的CSV数据文件运行这个程序：

    # 29页的数据文件：tut_classes/stock_stats/data.csv
    "Date","ISBN","Price"
    "2013-04-12","978-1-9343561-0-4",39.45
    "2013-04-13","978-1-9343561-6-6",45.67
    "2013-04-14","978-1-9343560-7-4",36.95
    Our job is to take all the CSV files and work o

    $ ruby stock_stats.rb data.csv
    Processing data.csv
    Total value = 122.07000000000001

Do we need three source files for this? No. 
我们**需要这三个源文件**？不。
In fact, most Ruby developers would probably start off by sticking all this code into a single file—it would contain both class definitions as well as the driver code. 
事实上，大多数Ruby开发人员可能会开始将所有这些代码粘帖到一个单一的文件，它将包含两个类定义以及驱动程序代码。
But as your programs grow (and almost all programs grow over time), you’ll find that this starts to get cumbersome. 
但是，你的程序变大（以及几乎所有的程序随着时间的推移），你会发现，这开始变得繁琐。
You’ll also find it harder to write auto-mated tests against the code if it is in a monolithic chunk. 
您还可以发现，如果是在一个单片的大块，很难对代码编写**自动化测试**。
Finally, you won’t be able to reuse classes if they’re all bundled into the final program
最后，您将不能够重复使用类，如果他们都捆绑到最终的程序

Anyway, let’s get back to our discussion of classes.
无论如何，让我们回到我们类的讨论。

## 　　3.4　访问控制
当我们设计类的接口时，需要着重考虑你的类想要向外部世界暴露何种程度的访问。
如果允许过多访问，会增加耦合风险——类的用户可能依赖于类实现的细节，而非逻辑性的借口。
好消息是ruby改变一个对象的状态，唯一的方式是调用发放。控制对方法的访问，就得以控制对对象的访问。

- public（公有）方法
可以被任何人调用，没有限制访问控制。这是除了initailize之外的所有方法的默认状态。
- protected（保护）方法
只能被定义了该方法的类或其子类的对象所调用。整个家族均可访问。
- private（私有）方法
不能被明确的接收者调用，接收者只能是self。
这意味着私有方法只能在当前对象的上下文中被调用：你不能调用另一个对象的私有方法。

和其他语言不同，控制访问是在程序运行时动态判定的。只有代码试图执行受限方法，才会得到一个访问违规
### 3.4.1 指定访问控制
第一种方式：没有参数——设置后续定义的默认访问控制。
第二种方式：将方法名作为参数。如`public :method1, :method2`

    class Account
      attr_accessor :balance
      def initialize(balance)   # 账户，用余额表示。
        @balance = balance
      end
    end

    class Transaction
      def initialize(account_a, account_b)
        @account_a = account_a
        @account_b = account_b
      end
      private
      def debit(account, amount)  # 借方，支出
        account.balance -= amount
      end
      def credit(account, amount)  # 贷方，存款
        account.balance += amount
      end
      public
      #...
      def transfer(amount)            # <kinder:note> 转帐，为什么是个public？
        debit(@account_a, amount)
        credit(@account_b, amount)
      end
      #...
    end

    savings = Account.new(100)
    checking = Account.new(200)
    trans = Transaction.new(checking, savings)
    trans.transfer(50)

当对象需要访问同属类的其他对象的内部状态时，使用保护访问方式。
比如，希望单个的account对象能比较他们的原始余额，而对其他所有对象隐藏这些余额（可能因为我们要以一种不同的形式表现它们）。

    class Account
      attr_reader :cleared_balance   # accessor method 'cleared_balance'
      protected :cleared_balance     # but make it protected 因此只有account对象才可以访问它。
      def greater_balance_than?(other)
        @cleared_balance > other.cleared_balance
      end
    end

## 　　3.5　变量

    person = "Tim"
    puts "The object in 'person' is a #{person.class}"   # The object in 'person' is a String
    puts "The object has an id of #{person.object_id}"   # The object has an id of 70230663692980
    puts "and a value of '#{person}'"                    # and a value of 'Tim'

ruby使用Tim创建了一个string对象，这个对象的一个引用（reference）被保存在局部变量person中，它具有对象的ID，类和值。

那么变量是一个对象吗？不是。变量只是对象的引用。对象漂浮在某处一个很大的池中（大多数时候是堆，heap中），并由变量指向它们。

    person1 = "Tim"
    person2 = person1     # 这只是让对象有了另一个名字person2。
    person1[0] = 'J'
    puts "person1 is #{person1}"  # person1 is Jim
    puts "person2 is #{person2}"  # person2 is Jim  # 尽管没有操作person2，但person2指向的对象已经改变为Jim。

赋值别名对象，潜在地给所引用的对象多了个变量。
你可以通过使用String的dup方法来避免创建别名，它会创建一个新的、具有相同内容的String对象。
你也可以通过冻结一个对象来阻止其他人对其进行改动（见24.5节冻对象）。试图更改一个被冻结的对象，ruby将引发一个TypeError异常。

# 　第4章　容器、Blocks和迭代器
## 　　4.1　容器
容器是含有一个或多个对象引用的对象。
### 4.1.1 数组
数组类含有一组对象引用。每个对象引用占据数组中的一个位置，并由一个非负的整数索引来标识。
**创建**Array对象：1.通过字面量创建；2.显式创建。

    a = [ 3.14159,"pie", 99 ] 
    a.class # =>   Array
    a.length # =>  3
    a[0] # =>      3.14159
    a[1] # =>      "pie"
    a[2] # =>      99
    a[3] # =>      nil
    
    b = Array.new
    b.class # => Array
    b.length # => 0
    b[0] = "second"
    b[1] = "array"
    b # => ["second", "array"]

数组由[]操作符进行**索引**。它实际是一个实例方法，因此可以被子类重载。
数组下标从0开始。
1. 可以使用非负整数或负整数访问数组。如果该位置没有对象，返回nil。

    a = [ 1, 3, 5, 7, 9 ]
    a[-1] # => 9
    a[-2] # => 7
    a[-99] # => nil

2. 还可以使用一对数字[sart, count]来访问数组。

    a = [ 1, 3, 5, 7, 9 ]
    a[1, 3] # => [3, 5, 7]
    a[3, 1] # => [7]
    a[-3, 2] # => [5, 7]

3. 最后还可使用range来对数组进行索引。

    a = [ 1, 3, 5, 7, 9 ]
    a[1..3] #   => [3, 5, 7]
    a[1...3] #  => [3, 5]
    a[3..3] #   => [7]
    a[-3..-1] # => [5, 7, 9]

**使用[]=设置数组元素**

    a = [ 1, 3, 5, 7, 9 ]  #=>  [1, 3, 5, 7, 9]
    a[1] = 'bat'           #=>  [1, "bat", 5, 7, 9]
    a[-3] = 'cat'          #=>  [1, "bat", "cat", 7, 9]
    a[3] = [ 9, 8 ]        #=>  [1, "bat", "cat", [9, 8], 9]
    a[6] = 99              #=>  [1, "bat", "cat", [9, 8], 9, nil, 99]

    a = [ 1, 3, 5, 7, 9 ]   #=> [1, 3, 5, 7, 9]
    a[2, 2] = 'cat'         #=> [1, 3, "cat", 9]   使用了数字表示位置。
    a[2, 0] = 'dog'         #=> [1, 3, "dog", "cat", 9]
    a[1, 1] = [ 9, 8, 7 ]   #=> [1, 9, 8, 7, "dog", "cat", 9]
    a[0..3] = []            #=> ["dog", "cat", 9]   使用了range表示位置。
    a[5..6] = 99, 98        #=> ["dog", "cat", 9, nil, nil, 99, 98]

数组还有**大量有用的方法**。使用这些方法，你可以用数组来实现栈(stack)、收集(set)、队列(queue)、双向队列(dequeue)、先进先出队列(fifo)。

    # 操作栈的例子：
    stack = []
    stack.push "red"
    stack.push "green"
    stack.push "blue"
    stack # => ["red", "green", "blue"]
    stack.pop  # =>  "blue"
    stack.pop  # =>  "green"
    stack.pop  # =>  "red"
    stack      # =>  []

    # 操作fifo队列的例子：
    queue = []
    queue.push "red"
    queue.push "green"
    queue.shift # => "red"
    queue.shift # => "green"

    array = [ 1, 2, 3, 4, 5, 6, 7 ]
    array.first(4) # => [1, 2, 3, 4]   # 数组最前4个
    array.last(4) # => [4, 5, 6, 7]    # 数组最后4个

数组类的方法列表见第四部分。很值得用irb来操作。

### 4.1.2 散列表
Hashes散列表，也称关联数组(associative arrays)、图(maps)或者词典(dictionaries)
hash可以用任何类型的对象进行索引，比如字符串、正则表达式等等。
hash中的值可以是任意类型的对象。

    h = { 'dog' => 'canine', 'cat' => 'feline', 'donkey' => 'asinine' }
    h.length # => 3
    h['dog'] # => "canine"
    h['cow'] = 'bovine'
    h[12]    = 'dodecine'
    h['cat'] = 99
    h        # => {"dog"=>"canine", "cat"=>99, "donkey"=>"asinine", "cow"=>"bovine",
             # .. 12=>"dodecine"}

ruby1.9版新的简短的语法：

    h = { :dog => 'canine', :cat => 'feline', :donkey => 'asinine' }

或者更简明的：

    h = { dog: 'canine', cat: 'feline', donkey: 'asinine' }

对比数组，散列表的优点：可以用任何对象做索引。
缺点也很突出：它的元素是无序的，因此很难实现栈和队列。
不过，ruby记得元素加入散列表的顺序。<kinder:note> 4.0版增。这是否可以说明hash也可实现栈和队列？见下面4.1.3的例子。

你会发现散列表是ruby最常用的数据结构之一，完整的方法列表在第四部分。

### 4.1.3 实现一个SongList容器

    # Sample code from Programing Ruby, page 45
      class WordIndex
        def initialize
          @index = {}                       # 这是一个hash
        end
        def add_to_index(obj, *phrases)       #添加歌曲到列表中, *phraes代表不定个数的歌曲。
          phrases.each do |phrase|
            phrase.scan(/\w[-\w']+/) do |word|   # extract each word  字符类的scan方法，见618页第三部分string类。
              word.downcase!
              @index[word] = [] if @index[word].nil?    如果存在则建立一个空值。
              @index[word].push(obj)       # hash可以使用push吗？这里看起来可以。
            end
          end
        end
        def lookup(word)   # 查找歌曲
          @index[word.downcase]       # 如果没有找到则返回一个nil
        end
      end
    
    class SongList
      def initialize  # 创建歌曲列表类。
        @songs = Array.new  #为什么不用hash呢？ 1.无序，2.不支持多个键对应相同的值。
        @index = WordIndex.new
      end
      def append(song)    # 添加给定的歌曲到列表中。
        @songs.push(song)
        @index.add_to_index(song, song.name, song.artist)   # 调用WorkIndex类。
        self            # 返回self，即当前SongList对象的引用。这是一个惯用法，可以让我们把对append的多个调用链接在一起。
      end
      def delete_first   # 删除列表的第一首歌曲，并返回该歌曲。
        @songs.shift
      end
      def delete_last  # 删除列表的最后一首歌曲，并返回歌曲
        @songs.pop
      end
      def [](index)   # 返回index处的歌曲
        @songs[index]
      end
      def with_title(title)  # 返回指定名字的歌曲
        for i in 0...@songs.length
          return @songs[i] if title == @songs[i].name
        end
        return nil
      end
      def with_title(title)   # 为什么这个方法名可以和上一个一样？是第二次调用该方法时的补充吗？
        @songs.find {|song| title == song.name }
      end
      def lookup(word)
        @index.lookup(word)
      end
      def create_search(name, params)
        # ...
      end
    end  
    
    class Song
      include Comparable
      @@plays = 0
      attr_reader :name, :artist, :duration
      attr_writer :duration
      def initialize(name, artist, duration)
        @name     = name
        @artist   = artist
        @duration = duration
        @plays    = 0
      end
      def to_s
        "Song: #@name--#@artist (#@duration)"
      end
      def name
        @name
      end
      def artist
        @artist
      end
      def duration
        @duration
      end
      def duration=(new_duration)
        @duration = new_duration
      end
      def duration_in_minutes
        @duration/60.0   # force floating point
      end
      def duration_in_minutes=(new_duration)
        @duration = (new_duration*60).to_i
      end
      def play
        @plays  += 1   # same as @plays = @plays + 1
        @@plays += 1
        "This  song: #@plays plays. Total #@@plays plays."
      end
      def record
        "Recording..."
      end
      def inspect
        self.to_s
      end
      def <=>(other)
        self.duration <=> other.duration
      end
    end
    
    require 'test/unit'
    class TestSongList < Test::Unit::TestCase
      def test_delete
        list = SongList.new                    # 建立一个歌曲列表
        s1 = Song.new('title1', 'artist1', 1)  # 建立四首歌曲
        s2 = Song.new('title2', 'artist2', 2)
        s3 = Song.new('title3', 'artist3', 3)
        s4 = Song.new('title4', 'artist4', 4)
    
        list.append(s1).append(s2).append(s3).append(s4)  #将四首歌曲添加到列表中
    
        assert_equal(s1, list[0])
        assert_equal(s3, list[2])
        assert_nil(list[9])
    
        assert_equal(s1, list.delete_first)
        assert_equal(s2, list.delete_first)
        assert_equal(s4, list.delete_last)
        assert_equal(s3, list.delete_last)
        assert_nil(list.delete_last)
      end
    end

运行结果：

    Loaded suite -
    Started
    .
    Finished in 0.002314 seconds.
    1 tests, 8 assertions, 0 failures, 0 errors

## 　　4.2　Blocks和迭代器
**find方法**
实现`with_title`方法，该方法接受一个字符串参数，并返回以此为歌名的歌曲：

    class SongList
      def with_title(title)
        for i in 0...@songs.length
          return @songs[i] if title == @songs[i].name
        end
        return nil
      end
    end

在某种程度上，for循环和数组的耦合过于紧密：需要知道数组的程度，然后依次获得其元素的值，直到找到一个匹配为止。
为什么不只是请求数组对它的每一个元素执行一个测试呢？
find方法是一种迭代器，反复调用block的代码。

    class SongList
      def with_title(title)
        @songs.find {|song| title == song.name }
      end
    end

### 4.2.1 实现迭代器
ruby的迭代器只不过是可以调用block的方法而已。
**block的形式**
block的形式一，使用{}：

    some_array.each {|value| puts value * 3 }

block的形式二，使用do~end，这种形式的绑定低于{...}，见356页22.12Block，Closures和Proc对象一节：

    sum = 0
    other_array.each do |value|
      sum += value
      puts value / sum
    end

**block的特点**
但，block不是传统意义上的、将语句组织在一起的一种方式：
首先，block在代码中只和方法调用一起出现；
其次，在遇到block的时候并不立刻执行其中的代码。ruby会记住block出现时的上下文（局部变量、当前对象等）然后执行方法调用。
例子一：

    def three_times
      yield
      yield
      yield
    end
    three_times { puts "Hello" }
    # 结果：输出三次Hello。

例子二，Fibonacci数：


    def fib_up_to(max)
      i1, i2 = 1, 1 # 并列赋值 (i1 = 1 and i2 = 1)
      while i1 <= max
        yield i1    # <kinder:note> 这个yield i1 是什么意思？
        i1, i2 = i2, i1+i2  # 并列赋值 i1 = i2 ; i2 = i1 + i2
      end
    end
    fib_up_to(1000) {|f| print f, " " }
    # 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

在第二个例子中，yield带有一个参数（任意数量的参数列表位于两个竖线之间），参数值传送给block。

**block的变量**
如果传递给block的参数是已存在的局部变量，这些变量即为block的参数，他们的值可能因block的执行而改变。
同样的规则适用于block内的变量：
如果第一次出现在block内，他们就是block的局部变量。
如果他们先出现在block外，则block与其外部环境共享这些变量。[3]
[3]这个特性会造成意外行为，ruby2可能会改变这种继承局部变量的方式。
<kinder:note> 下面是第四版对ruby2的描述：
First, parameters to a block are always local to a block, even if they have the same name as locals in the surrounding scope. (You’ll get a warning message if you run Ruby with the -w option.)
首先，一个块的参数总是局限于一个块，即使它们在周边范围作为局部变量具有相同的名称。 （你会得到一个警告消息，如果你运行Ruby-w选项）。
Second, you can define block-local variables by putting them after a semicolon in the block’s parameter list. 
第二，你可以将变量放在一个用分号隔开的块参数列表中，以定义块内局部变量。
<kinder:note> 这样看来，第二版的规定并没有被更改。第四版只是进行了更详细的说明。
例子一：

    a = [1, 2]
    b = 'cat'
    a.each {|b| c = b * a[1] }    # 运算：第一步b=1,c=1*1，第二步b=2,c=2*1。注意变量b已经被管道封住，所以这是一个block变量，而不是上一行的变量b。
    p a #   [1, 2]，没有被改变;block没有对a进行运算，当然没有改变。
    p b #   "cat", 也没被改变。大概在1.8版中，b会被改变，因此本书第二版的答案是2。
    p defined?(c)   # nil, c只是在block中被定义

例子二：

    square = "some shape"
    sum = 0
    [1, 2, 3, 4].each do |value; square|
      square = value * value # this is a different variable
      sum += square
    end
    puts sum      # 30。 这个变量已经被改变。
    puts square   # some shape。这个变量没有被改变。 

**常用的迭代器**
数组类是迭代器擅长的事情，比如访问数组元素，让应用程序代码集中经历处理特殊需求。
一些迭代器是ruby的许多收集(collections)类型所共有的，比如**find**方法，还有each和collection。
**each**是最简单的迭代器，103页7.6循环一节描述了它如何被用来实现ruby语言的for循环。120页9.4组合模块一节描述定义each方法来自动为类添加一大堆额外的功能。
**collect**迭代器从收集中获得各个元素并传递给block，block返回的结果被用来生成一个新的数组。
这个功能被I/0类所使用，这些类实现了一个迭代器接口以返回I/0流中的连续相继的行或字节。
迭代器并不局限与访问数组和hash中的已有数据，它还可以返回得到的值。
**inject**方法（定义在Enumerable模块）可以遍历收集的所有成员以累计出一个值。

    [1,3,5,7].inject(0) {|sum, element| sum+element} # => 16 计算过程：(0+1) => (1+3) => (4+5) => (9+7)=16
    [1,3,5,7].inject(1) {|product, element| product*element} # => 105 计算过程：(1*1) => (1*3) => (3*5) => (15*7)=105
    # 执行时，sum为inject参数，element为收集的第一个元素。接下来每次执行block，sum为上次block被调用时的返回值。
    [1,3,5,7].inject {|sum, element| sum+element} # => 16
    [1,3,5,7].inject {|product, element| product*element} # => 105
    # 如果没有参数，那么它使用收集的第一个元素作为初始值，并从第二个元素开始迭代。
    [1,3,5,7].inject(:+) # => 16
    [1,3,5,7].inject(:*) # => 105
    # 这种方法在第四版ruby2中。


### Enumerator, 外在迭代器
内迭代器和外迭代器
在ruby中，迭代器继承于收集内部，它只不过一个方法，只是每当产生新的值的时候调用yield。
在其他语言中，收集本身没有迭代器，它们生成外部辅助对象来传送迭代器状态。

不过，内部迭代器并不总是最好的解决方案。
当你需要把迭代器本身作为一个对象时，例如将迭代器传递给一个方法，该方法需要访问由迭代器返回的每一个值——它的表现就欠佳了。
另外，内建迭代器模式也难以实现并行迭代两个收集。
<kinder:note> 下面这段文字来自网络，可以帮助理解内外的概念和作用。
一个基本的问题是决定到底由哪一方来控制迭代，是迭代器自身还是使用迭代器的客户代码？当客户代码控制迭代时，该迭代器被称为外部迭代器，反之当迭代器控制迭代时，该迭代器就是一个内部迭代器。那些使用外部迭代器的客户代码必须负责推进整个遍历过程并且显式的从迭代器中获得下一个元素。相比之下，在使用内部迭代器时，客户代码将一个操作传递给一个内部迭代器，该迭代器依次在每个元素上应用该操作。
外部迭代器比内部迭代器更灵活。比如，使用外部迭代器可以很容易的比较两个集合的相等性，如果用内部迭代器则不太可能。但是从另一个角度来看，内部迭代器更容易使用，因为它们已经为你定义好了迭代逻辑。
在Ruby中，像each这样的迭代器方法是内部迭代器，它们控制着迭代并且将值“推送”给那个与方法调用相关联的代码块。Enumerator枚举器具有一个each方法，可用于内部迭代，但是在Ruby1.9及其后的版本里，它们还能充当外部迭代器，客户代码可以使用next方法顺序的从一个枚举器中“取出"值。 
</kinder:note> 

ruby 1.8提供了**Generator**库（683页28章有详细描述），从而实现了外部迭代器。

ruby 2.0提供了**Enumerator**类  <kinder:note>这下面的内容是第四版新增的。

    a = [ 1, 3, "cat" ]
    h = { dog: "canine", fox: "vulpine" }
    # Create Enumerators
    enum_a = a.to_enum    # 调用to_enum或enum_for方法可以在收集上创建Enumerator对象。
    enum_h = h.to_enum
    enum_a.next # => 1
    enum_h.next # => [:dog, "canine"]
    enum_a.next # => 3
    enum_h.next # => [:fox, "vulpine"]

Most of the internal iterator methods—the ones that normally yield successive values to a block—will also return an Enumerator object if called without a block:
大多数内部迭代器的方法 -- 那些方法通常产生一个连续的值到block里 —— 如果没有块调用，也将返回一个Enumerator对象

    a = [ 1, 3, "cat" ]
    enum_a = a.each           # 使用内部迭代器产生一个 Enumerator 
    enum_a.next # => 1
    enum_a.next # => 3

loop循环处理Enumerator对象时会变得聪明些。

    short_enum = [1, 2, 3].to_enum
    long_enum = ('a'..'z').to_enum
    loop do
      puts "#{short_enum.next} - #{long_enum.next}"
    end

输出：

    1 - a
    2 - b
    3 - c

You can also handle this in your own iterator methods by rescuing the StopIteration exception, but because we haven’t talked about exceptions yet, we won’t go into details here.
你也可以在你自己的迭代器方法中处理这个，通过修补StopIteration例外，但因为我们还未学习例外，这里就不做详解了。

### Enumerators Are Objects   第四版新增
Enumerators take something that’s normally executable code (the act of iterating) and turn it into an object. This means you can do things programmatically with enumerators that aren’t easily done with regular loops.  
Enumerators可以进行一些正常执行的代码（迭代作用），并转换为一个对象。这意味着你可以用Enumerators做一些其他常见的loops不容易的编程工作。
**`each_with_index`**
它调用其主类的each方法，返回一系列值连同一个索引。

    result = []
    [ 'a', 'b', 'c' ].each_with_index {|item, index| result << [item, index] }
    result # => [["a", 0], ["b", 1], ["c", 2]]

如果是字符类：

    result = []
    "cat".each_char.each_with_index {|item, index| result << [item,index] } 
    result # => [["c", 0], ["a", 1], ["t", 2]]

**`with_index`**方法会更易读：

    result = []
    "cat".each_char.with_index {|item, index| result << [item,index] } 
    result # => [["c", 0], ["a", 1], ["t", 2]]

你甚至可以直接创建一个Enumerators对象，**`enum_for`**：

    enum = "cat".enum_for(:each_char)
    enum.to_a # => ["c", "a", "t"]

If the method we’re using as the basis of our enumerator takes parameters, we can pass them to`enum_for` 
如果我们正在使用的enumerator的基础有参数，它们将被传递到`enum_for`里:

    enum_in_threes = (1..10).enum_for(:each_slice, 3)    # each_slice是range类的方法。见后面ruby库参考部分
    enum_in_threes.to_a # => [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]

### Enumerators Are Generators and Filters   第四版新增
(This is more advanced material that can be skipped on first reading.) 
（这一节的功能高级，第一次读的时候可以跳过）
As well as creating enumerators from existing collections, you can create an explicit enumerator, passing it a block. 
除了从已有的收集新建Enumerators，你可以明确地创建Enumerators，给它传一个block。
The code in the block will be used when the enumerator object needs to supply a fresh value to your program. 
block里的代码将被使用，当Enumerators对象需要提供一个新的值给程序时。
However, the block isn’t simply executed from top to bottom. 
不过，block不是简单地从顶部执行到底部。
Instead, the block is executed in parallel with the rest of your program’s code. 
相反，block将和程序的其他代码并行执行。
Execution starts at the top and pauses when the block yields a value to your code. 
执行在顶部开始，在block yield一个值给代码时暂停。
When the code needs the next value, execution resumes at the statement following the yield. 
代码需要下一个值时，恢复执行yeild之后的语句。
This lets you write enumerators that generate infinite sequences (among other things):
这让你写出产生无限序列（在其他东西中间）的Enumerators，.

    triangular_numbers = Enumerator.new do |yielder|   # 这个yielder变量从0开始，可以理解为一个序号。
      number = 0
      count = 1
      loop do
        number += count   # 1 3 6 10 15
        count += 1        # 2 3 4 5  6
        yielder.yield number   #这一句怎么理解？ 对于Enumerator序列的每个成员都调用block的代码。number将传做triangular_numbers。
      end
    end
     5.times { print triangular_numbers.next, " " }
    puts    # 1 3 6 10 15  不过这个puts没有参数，怎么回事？原来是为了换行！

Enumerator objects are also enumerable (that is to say, the methods available to enumerable objects are also available to them). 
Enumerator对象也是可以枚举的（这就是说，枚举对象可用的方法对于他们也是可用的）
That means we can use Enumerable’s methods (such as first) on them:
那意味着我们可以使用Enumerator的方法在它们上面：

    triangular_numbers = Enumerator.new do |yielder|
      number = 0
      count = 1
      loop do
        number += count
        count += 1
        yielder.yield number   # 后面没有block，这个yield不觉得寂寞吗？不过从结果来看，最后的p语句也可以被调用。
      end
    end
    p triangular_numbers.first(5)    # [1, 3, 6, 10, 15]

**2.0的新内容**
You have to be slightly careful with enumerators that can generate infinite sequences. 
你要稍微小心，enumerators可以产生无限序列。
Some of the regular Enumerator methods such as count and select will happily try to read the whole enumeration before returning a result. 
一些规范的enumerator方法，如count和select，在返回一个结果之前，会很乐意尝试读取整个枚举。
If you want a version of select that works with infinite sequences, in Ruby 1.9 you’ll need to write it yourself. 
如果你想在Ruby 1.9中使用无穷序列的select版本，你需要自己写。
(Ruby 2 users have a better option, which we discuss in a minute.) 
（Ruby  2用户有一个更好的选择，这是我们在一分钟内讨论。）
Here’s a version that gets passed an enumerator and a block and returns a new enumerator containing values from the original for which the block returns true.  
这里有一个版本，得到通过一个枚举和块，并返回一个新的枚举值从原来的块返回true。
We’ll use it to return triangular numbers that are multiples of 10:
我们将用它来返回三角数是10的倍数：

    triangular_numbers = Enumerator.new do |yielder|
      number = 0
      count = 1
      loop do
        number += count
        count += 1
        yielder.yield number 
      end
    end
    def infinite_select(enum, &block)   # 这个例子是怎么回事？是将上一例子的输出作为参数，再次筛选！
      Enumerator.new do |yielder|       # 这一句规定最后的输出是一个enumerator序列。
        enum.each do |value|            # 传入上一例子的输出。
          yielder.yield(value) if block.call(value)    #  这是说“如果block可以调用，就调用吧”的意思吗？
        end
      end
    end
    p infinite_select(triangular_numbers) {|val| val % 10 == 0}.first(5)   #   [10, 120, 190, 210, 300]

Here we use the &block notation to pass the block as a parameter to the `infinite_select` method.
这里我们使用了&block的符号来传递block作为参数到`infinite_select`方法中。
As Brian Candler pointed out in the ruby-core mailing list (message 19679), you can make this more convenient by adding filters such as `infinite_select` directly to the Enumerator class.
就像Brian Candler在ruby-core邮件列表（消息19679）指出的那样，你可以让它更方便些，通过直接增加诸如`infinite_select`的过滤器到Enumerator类。
Here’s an example that returns the first five triangular numbers that are multiples of 10 and that have the digit 3 in them：
下面是个例子，返回前五个三角数组，并且是10倍，拥有阿拉伯数字3。

    triangular_numbers = Enumerator.new do |yielder|
      # ... as before
    end
    class Enumerator
      def infinite_select(&block)
        Enumerator.new do |yielder|
          self.each do |value|
            yielder.yield(value) if block.call(value)
          end
        end
      end
    end
    p triangular_numbers
      .infinite_select {|val| val % 10 == 0}         # 可以被10整除
      .infinite_select {|val| val.to_s =~ /3/ }      # 包含3
      .first(5)

产生：

    [300, 630, 1830, 3160, 3240]

### Lazy Enumerators in Ruby 2   第四版新增
**2.0的新内容**
As we saw in the previous section, the problem with enumerators that generate infinite sequences is that we have to write special, non-greedy, versions of methods such as select.
正如我们前面所看到的。使用enumerators产生无限序列出现的问题是我们必须编写特殊的，非贪婪的，多版本的方法，如select。
Fortunately, if you’re using Ruby 2.0, you have this support built in.
幸运的是，如果你在使用Ruby 2.0，就会有这个内建支持。
<kinder:note> 怎么理解这个Lazy Enumerator呢？下面这段文字来自：http://www.oschina.net/translate/functional-programming-techniques-with-ruby-part-iii
枚举器是大多数Ruby循环问题的解决方案，但是他们有个限制。如果说我们需要一个类产生无尽的质数列表。有一个应用，我们想找到前20个包含数字3的质数，另一个应用，我们想找到前10个质数-每个质数的每一位数字加起来的和也是质数。使用标准的Enumerable函数来写这些功能即使不是不可能，但是也是很费力。让我们看看惰性枚举器吧。 
 惰性枚举器
在Haskell之类的函数式语言，惰性计算(lazy evaluation) 是一个特性只在需要时才计算一个值。在Haskell, 这对于代码里无限长的列表很有效，在任意时刻，只产生这些列表需要的数据。在像Ruby这样严格计算的语言中，这不可能。Ruby会尝试计算整个无限的列表，最终耗尽进程中的内存。 
对于新的Ruby 2.0增加了一个新的类Enumerator::Lazy 来支持枚举器额惰性计算。这意味着在Ruby中也可以处理无限长度列表的数据了。 
</kinder:note> 
If you call Enumerator#lazy on any Ruby enumerator, you get back an instance of class Enumerator::Lazy. 
如果你在Ruby enumerator中调用Enumerator#lazy，会返回一个Enumerator::Lazy的实例。
This enumerator acts just like the original, but it reimplements methods such as select and map so that they can work with infinite sequences. 
这个 enumerator的作用就像原本的，但它重新实现了方法，比如select和map，以便他们可以在无限序列中工作。
Putting it another way, none of the lazy versions of the methods actually consume any data from the collection until that data is requested, and then they only consume enough to satisfy that request.
换言之，没有一个方法的lazy版本在实际上从收集销毁数据，直到那些数据是被要求的，然后他们只会用足够的消耗来满足那个要求。

To work this magic, the lazy versions of the various methods do not return arrays of data.
要实现这个魔法，不同方法的惰性版本不会返回数据数组。
Instead, each returns a new enumerator that includes its own special processing—the select method returns an enumerator that knows how to apply the select logic to its input collection, the map enumerator knows how to handle the map logic, and so on. 
相反，每个返回一个新的enumerator，包含它特有的特殊过程--select方法返回一个enumerator，它知道怎样使用select的逻辑到它输出的收集中，map enumerator知道怎样处理map逻辑，等等。
The result is that if you chain a bunch of lazy enumerator methods, what you end up with is a chain of enumerators—the last one in the chain takes values from the one before it, and so on.
结果是：如果你连用一束惰性enumerators方法，用来结束的就是一个enumerators链--链里最后一个将从前面的那个取得数值，以此类推。

Let’s play with this a little. To start, let’s add a helper method to the Integer class that generates a stream of integers.
让我们玩弄一下。开始，增加一个辅助方法到integer类，产生一个整数流。

    def Integer.all
      Enumerator.new do |yielder, n: 0|
        loop { yielder.yield(n += 1) }
      end.lazy
    end
    p Integer.all.first(10)     #  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

There are a couple of things to note here. 
这里有两点需要注意。
First, see how I used a keyword parameter on the block both to declare and initialize a local variable n [7]. 
首先，看看在block中怎么使用一个keyword参数，以描述和初始化一个局部变量n。[7]
Second, see how we convert the basic generator into a lazy enumerator with the call to lazy after the end of the block.
其次，看看怎么将一个基本的generator转化为一个惰性enumerator，带有调用到lazy，在block的结尾之后。

[7]It would be nice to be able to define a true block-local variable using the semicolon separator, but Ruby doesn’t allow these variables to have initializers.
能够使用分号分隔符定义一个真正的块变量，是很好的，但ruby不允许这些变量初始化。

Calling the first method on this returns the numbers 1 through 10, but this doesn’t exercise the method’s lazy characteristics. 
调用第一个方法返回数字1到10,但这没有行使该方法的lazy特性。
Let’s instead get the first 10 multiples of three.
让我们转而获得前十个3的倍数吧。

    p Integer
      .all
      .select {|i| (i % 3).zero? }
      .first(10)
    # produces:
    # [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]

Remember that our lazy filter methods simply return new Enumerator objects? 
还记得我们的lazy过滤器方法只返回新Enumerator对象吗？
That means we can split up the previous code:
那意味着我们可以分割之前的代码

    multiple_of_three = Integer
            .all
            .select { |i| (i % 3).zero? }
    
    p multiple_of_three.first(10)
    
    m3_palindrome = multiple_of_three
      .select { |i| palindrome?(i) }
    p m3_palindrome.first(10)
    # produces:
    # [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
    # [3, 6, 9, 33, 66, 99, 111, 141, 171, 222]

You could also code up the various predicates as free-standing procs, if you feel it aids readability or reusablility.
你也可以编写各种断言作为独立的过程，如果你觉得它有助于可读性或可用性。

    multiple_of_three = -> n { (n % 3).zero? }
    palindrome = -> n { n = n.to_s; n == n.reverse }   # 回文特性
    p Integer
             .all
             .select(&multiple_of_three)
             .select(&palindrome)
             .first(10)
    # produces:
    # [3, 6, 9, 33, 66, 99, 111, 141, 171, 222]

If you’ve ever played with ActiveRelation in Rails, you’ll be familiar with this pattern—lazy enumeration methods let us build up a complex filter one piece at a time.
如果你在Rails玩过ActiveRelation，你会熟悉这个模式 -- lazy枚举的方法，让我们一次性建立一个复杂的过滤器。


### 4.2.2 事务block
尽管block通常和迭代器合用，但它还有其他用处。

block可以用来定义必须运行在事务控制环境下的代码。比如打开文件后的关闭处理：

    class File
      def self.open_and_process(*args)
        f = File.open(*args)
        yield f
        f.close()
      end
    end
    File.open_and_process("testfile", "r") do |file|
      while line = file.gets
        puts line
      end
    end

`open_and_process`是一个类方法，可以独立于任何file对象被使用。
我们希望它接受与传统File.open一样的参数，并不关心这些参数到底是什么。所以用`*args`表示参数，这意味着“把传递给这个方法的实际参数收集到名字为args的数组中”。

让文件管理自己的生命周期的技术是如此重要，以至于ruby的File类直接支持了这项技术。
如果File.open有个关联的block，那么该block将被调用，且参数是该文件对象，block执行结束时文件会被关闭。
这意味着File.open有两种不同的行为：当和block一起调用时，会执行该block并关闭文件；当单独调用时，会返回文件对象。
使得这种行文成为可能的是`Kernel.block_given?`方法，当某方法和block关联在一起调用时`Kernel.block_given?`将返回真。因此下面的代码实现了类似标准的File.open方法。

    class File
      def self.my_open(*args)
        result = file = File.new(*args)
        # If there's a block, pass in the file and close the file when it returns
        if block_given?
          result = yield file
          file.close
        end
        result
      end
    end

还有点不足：前面的例子在使用block来控制资源时，我们没有解决错误处理问题。第八章107页的异常处理可以解决这个问题。

### block可以作为对象 第四版新增
Blocks are like anonymous methods, but there’s more to them than that. 
block很像匿名方法，但比他们更多特性。
You can also convert a block into an object, store it in variables, pass it around, and then invoke its code later.
你也可以将block转换为一个对象，保存在变量中，传下去，然后稍后调用它的代码。

Remember we said that you can think of blocks as being like an implicit parameter that’s passed to a method? 
记得我们说过你可以将block想成类似传给方法的暗含的参数吗？
Well, you can also make that parameter explicit. 
对了，你也可以让那些参数更明确些。
If the last parameter in a method definition is prefixed with an ampersand (such as &action), Ruby looks for a code block whenever that method is called. 
如果方法定义的最后一个参数前缀以一个&符号，比如&action，ruby将寻找一个代码block，无论该方法何时调用。
That code block is converted to an object of class Proc and assigned to the parameter. 
代码block被转换为一Proc类的对象，并分配给参数。
You can then treat the parameter as any other variable.
你可以将那个参数当作其他变量。

Here’s an example where we create a Proc object in one instance method and store it in an instance variable. 
这是一个例子，我们创建一个Proc对象在一个实例方法中，并存入一个实例变量里。
We then invoke the proc from a second instance method.
然后我们从第二个实例方法调用proc。

    class ProcExample
      def pass_in_block(&action)
        @stored_proc = action
      end
      def use_proc(parameter)
        @stored_proc.call(parameter)
      end
    end
    eg = ProcExample.new
    eg.pass_in_block { |param| puts "The parameter is #{param}" }
    eg.use_proc(99)
    # produces:
    # The parameter is 99

See how the call method on a proc object invokes the code in the original block?
看看在一个proc对象中的call方法怎样调用原生block里的代码：
Many Ruby programs store and later call blocks in this way—it’s a great way of implementing callbacks, dispatch tables, and so on. 
很多ruby程序保存，稍后用这种方法调用block -- 这是实现回调、调度表等等的好方法。
But you can go one step further. 
沿着这个思路你可以走得更远。
If a block can be turned into an object by adding an ampersand parameter to a method, what happens if that method then returns the Proc object to the caller?
如果一个block可以被转换进一个对象中，通过给方法添加一个&参数，如果那个方法稍后返回Proc对象给调用程序，会发生什么呢？

    def create_block_object(&block)
      block
    end
    bo = create_block_object { |param| puts "You called me with #{param}" }
    bo.call 99
    bo.call "cat"
    produces:
    # You called me with 99
    # You called me with cat

In fact, this is so useful that Ruby provides not one but two built-in methods that convert a block to an object.[8] 
事实上，这是很有用的，ruby提供两个而不是一个的内建方法来将block转换为对象。
Both lambda and Proc.new take a block and return an object of class Proc.
lambda和Proc.new接受block并返回一个Proc类的对象。
The objects they return differ slightly in how they behave, but we’ll hold off talking about that until later on page 336.
他们返回的对象稍微有些不同：在如何表现上，但我们推迟那个话题，直到336页的22.13一节。

[8] There’s actually a third, proc, but it is effectively deprecated.
实际上还有第三种，proc，但不赞成使用。

    bo = lambda { |param| puts "You called me with #{param}" }
    bo.call 99
    bo.call "cat"
    # produces:
    # You called me with 99
    # You called me with cat

### 4.2.3 block可以作为闭包

    songlist = SongList.new
    class JukeboxButton < Button
      def initialize(label, &action)    # 这里是关键。
        super(label)
        @action = action
      end
      def button_pressed
        @action.call(self)
      end
    end
    start_button = JukeboxButton.new("Start") { songlist.start }
    pause_button = JukeboxButton.new("Pause") { songlist.pause }

上面代码的关键之处在于JukeboxButton#initialize的第二个参数。
如果定义方法时在最后一个参数前加一个&，那么当调用该方法时，ruby会寻找一个block；block会被转换为Proc类的一个对象，并赋值给参数。
但是我们创建我们创建Proc对象时，到底获得了什么呢？
我们得到的不仅仅是一堆代码。和block（以及Proc对象）关联在一起的还有定义block时的上下文，即self的值、作用域内的方法、变量和常量；即使block被定义时的环境早已消失。
这种特性称之为“闭包”。
<kinder:note> 第四版的定义：
This is called a closure -- variables in the surrounding scope that are referenced in a block remain accessible for the life of that block and the life of any Proc object created from that block
这就是闭包 -- 块中引用的周边作用域内的变量，对于该块的存在，和任何从该块创建的Proc对象的存在，仍然可以访问
<kinder:note> 我这个翻译真是狗屁——不通！

如果不用闭包，可以这样：

    class StartButton < Button
      def initialize
        super("Start")   # invoke Button's initialize
      end
      def button_pressed
        # do start actions...
      end
    end
    start_button = StartButton.new

但这样首先会导致大量的子类。如果Button类的接口发生变化，维护代价将会很高。
其次按下按钮引发的动作所处层次不当：他们不是按钮的功能，而是使用按钮的点唱机的功能。

    def n_times(thing)
      lambda {|n| thing * n }
    end
    p1 = n_times(23)    # n_times方法返回引用了其参数thing的Proc对象。尽管block被调用时，这个thing参数已经出了作用域，但block仍然可以访问它。
    p1.call(3) # => 69
    p1.call(4) # => 92
    p2 = n_times("Hello ")
    p2.call(3) # => "Hello Hello Hello "

<kinder:note> 下面是第四版新增：
Here’s another example—a method that returns a Proc object that returns successive powers of 2 when called:
下面是另一个例子—— 这个方法返回一个Proc对象，该对象在调用时返回一系列2的倍数：

    def power_proc_generator
      value = 1
      lambda { value += value }
    end
    power_proc = power_proc_generator
    puts power_proc.call      # 2
    puts power_proc.call      # 4
    puts power_proc.call      # 8

#### An Alternative Notation   一种可选的符号  第四版新增
Ruby has another way of creating Proc objects. Rather than write this:
ruby有另一个方法来创建Proc对象。比起这种：

    lambda { |params| ... }

you can now write the following:[9]
你现在可以像下面那样：
[9] Let’s start by getting something out of the way. Why ->? 
让我们通过让什么东西不正常开始吧。为什么是-> ?
For compatibility across all the different source file encodings, Matz is restricted to using pure 7-bit ASCII for Ruby operators, and the choice of available characters is severely limited by the ambiguities inherent in the Ruby syntax. 
为了兼容所有不同资源的文件编码，Matz被限定使用纯粹7比特ASCII字符做Ruby操作符，不同字符的选择被ruby语法的内在模糊性严重限制了。
He felt that -> was (kind of) reminiscent of a Greek lambda character λ.
他觉得-> 很像希腊lambda字符λ

    -> params { ... }

The parameters can be enclosed in optional parentheses. Here’s an example:
参数可以被关闭在可选的圆括号内。比如：

    proc1 = -> arg { puts "In proc1 with #{arg}" }
    proc2 = -> arg1, arg2 { puts "In proc2 with #{arg1} and #{arg2}" }
    proc3 = ->(arg1, arg2) { puts "In proc3 with #{arg1} and #{arg2}" }
    proc1.call "ant"                # In proc1 with ant
    proc2.call "bee", "cat"         # In proc2 with bee and cat
    proc3.call "dog", "elk"         # In proc3 with dog and elk

The -> form is more compact than using lambda and seems to be in favor when you want to pass one or more Proc objects to a method:
这种 -> 的形式比使用lambda更简洁，当你想传递一个或更多Proc对象到一个方法时，看起来更讨人喜欢。

     def my_if(condition, then_clause, else_clause)
       if condition
         then_clause.call    # 调用第一个lambda
       else
         else_clause.call    # 调用第二个lambda
       end
     end
     5.times do |val|
       my_if val < 2,
       -> { puts "#{val} is small" },   # 这个逗号可不能省略！
       -> { puts "#{val} is big" }
     end

结果：

    0 is small
    1 is small
    2 is big
    3 is big
    4 is big

One good reason to pass blocks to methods is that you can reevaluate the code in those blocks at any time. 
传递block给方法的一个好理由是：你可以随时在那些block中重新评估代码
Here’s a trivial example of reimplementing a while loop using a method.
下面是一个琐碎的例子，使用一个方法重新实现一个while循环。
Because the condition is passed as a block, it can be evaluated each time around the loop:
因为条件被传做一个block，它在循环中可以每次被求值。

    def my_while(cond, &body)       # cond就是condition，条件。这句话的意思是，符合条件，则调用body
      while cond.call               # 这个cond.call是调用了下面的{ a < 3 }
        body.call
      end
    end
    a = 0
    my_while -> { a < 3 } do
      puts a
      a += 1
    end

结果:

    0
    1
    2

#### Block Parameter Lists  block参数列表 第四版新增
**New in 2.0**
Blocks written using the old syntax take their parameter lists between vertical bars. 
用旧语法写block要将参数列在两个垂直线的中间。
Blocks written using the -> syntax take a separate parameter list before the block body. 
使用->语法写block，则应将隔开的参数列表写在block主体之前。
In both cases, the parameter list looks just like the list you can give to methods. 
这两种情况下，参数列表看起来像是你传给方法那样的的列表。
It can take default values, splat args (described later on page 120), keyword args, and a block parameter (a trailing argument starting with an ampersand). 
可以使用默认值，长条参数（后面120页介绍），关键字参数，和一个block参数（以&符号开始的尾部参数）
You can write blocks that are just as versatile as methods.[10] 
你可以像通用方法那样来写block。
[10] Actually, they are more versatile, because these blocks are also closures, while methods are not.
实际上，他们更通用；因为这些block也是闭包，但方法不是。
Here’s a block using the original block notation:
这些是使用原来的block符号的block。

    proc1 = lambda do |a, *b, &block|
      puts "a = #{a.inspect}"
      puts "b = #{b.inspect}"
      block.call
    end
    proc1.call(1, 2, 3, 4) { puts "in block1" }

结果:

    a = 1
    b = [2, 3, 4]
    in block1

And here’s one using the new -> notation:
这是使用新的->符号：

    proc2 = -> a, *b, &block do
      puts "a = #{a.inspect}"
      puts "b = #{b.inspect}"
      block.call
    end
    proc2.call(1, 2, 3, 4) { puts "in block2" }

结果:

    a = 1
    b = [2, 3, 4]
    in block2


## 　　4.3　处处皆是容器
容器、block和迭代器是ruby的核心概念。
ruby代码写得越多，对传统循环结构用得越少，你会更多地写支持迭代自身内容的类，而且你会发现这些代码精简易读、易于维护。

# 　第5章　标准类型
## 　　5.1　数字
ruby支持整数和浮点数。
整数可以是任何长度，最大值取决于系统可用内存的大小。
**整数**
一定范围内的整数（`-2**30`到`2**30-1`或者`-2**62`到`2**62-1`）在内部以二进制形式存储。它们是Fixnum类的对象。
范围之外的整数存储在Bignum类的对象中（目前实现为一个可变长度的短整型集合）。
这个处理是透明的，ruby会自动管理她们之间的来回切换。

    num = 10001
     4.times do
      puts "#{num.class}: #{num}"
      num *= num
    end
    # produces:
    # Fixnum:  10001
    # Fixnum:  100020001
    # Fixnum:  10004000600040001
    # Bignum:  100080028005600700056002800080001

**书写整数**
你可以使用一个可选的前导符号，可选的进制指示符（0表示八进制，0d表示十进制【默认】，0x表示十六进制，0b表示二进制），后面跟一串符合适当进制的数字。下划线在数字中被忽略——一些人在更大的数值上使用它们来替代逗号。

    123456                         =>  123456 # Fixnum
    0d123456                       =>  123456 # Fixnum
    123_456                        =>  123456 # Fixnum - 忽略下划线
    -543                           =>  -543 # Fixnum - 负数
    0xaabb                         =>  43707 # Fixnum - 十六进制
    0377                           =>  255 # Fixnum - 八进制
    -0b10_1010                     =>  -42 # Fixnum - 二进制(负数)
    123_456_789_123_456_789        =>  123456789123456789 # Bignum

**特殊字符的整数值**
控制字符的整数值可以使用?\C-x和？\cx生成。
元字符可以使用?\M-x生成。
元字符和控制字符的组合可以使用?\M-\C-x生成。
可以使用?\\得到反斜线字符的整数值。

    ?a          =>  97    # ASCII character
    ?\n         =>  10    # code for a newline (0x0a)
    ?\C-a       =>  1     # control a = ?A & 0x9f = 0x01
    ?\M-a       =>  225   # meta sets bit 7
    ?\M-\C-a    =>  129   # meta and control a
    ?\C-?       =>  127   # delete character

<kinder:note> 这一节在4版中没有了。是因为编码的存在吗？反正移到了5.2“字符串”的“字符常量”
下面是irb中的表现：

    irb(main):001:0> ?a
    => "a"
    irb(main):002:0> ?\n
    => "\n"
    irb(main):003:0> ?\C-a
    => "\u0001"
    irb(main):004:0> ?\M-a
    => "\xE1"
    irb(main):005:0> ?\M-\C-a
    => "\x81"
    irb(main):006:0> ?\C-?
    => "\u007F"

**浮点数、有理数和复数**
与原生体系结构的double数据类型相对应，带有小数点和/或幂的数字字面量被转换成浮点对象。必须在小数点之前和之后都给出数字。如果把1.0e3写成1.e3,ruby会试图调用Fixnum类的e3方法。

Ruby includes support for rational and complex numbers. 
ruby同时支持有理数和复数。
Rational numbers are the ratio of two integers—they are fractions—and hence have an exact representation (unlike floats). 
有理数是两个整数的比例 -- 他们是分数 -- 所以有一个准确的代表（而不像浮点数）
 Complex numbers represent points on the complex plane. 
复数代表复平面上的点。
They have two components, the real and imaginary parts.
它们有两部分，实部和虚部。

Ruby doesn’t have a literal syntax for representing rational and complex numbers. 
ruby并没有字面语法来表现有理数和复数。
Instead, you create them using explicit calls to the constructor methods Rational and Complex (although, as we’ll see, you can use the mathn library to make working with rational numbers easier).
相反，你可使用明确的调用构造方法Rational和Complex来创建。虽然如你所见，使用mathn库来运行有理数更容易一些。

    Rational(3, 4) * Rational(2, 3)     # => (1/2)
    Rational("3/4") * Rational("2/3")   # => (1/2)
    Complex(1, 2) * Complex(3, 4)       # => (-5+10i)
    Complex("1+2i") * Complex("3+4i")   # => (-5+10i)

所有的数字都是对象，并且可以对各种形式的消息（见后面的参考441 484 487 501 562）做出响应。
因此，ruby使用num.abs而不是abs(num)来得到数字的绝对值。

**Perl用户要注意了**
<kinder:note> 这一段2版有了，只是放在后面，哎，还花了时间把它翻译了一遍。嘿嘿。
Finally, we’ll offer a warning for Perl users. 
最后，我们将对perl用户提出一个警告。
Strings that contain just digits are not automatically converted into numbers when used in expressions. 
**只包含数字的字符串用于表达式时，不会自动转化为数字。**
This tends to bite most often when reading numbers from a file. 
当从一个文件读入数字时，这往往会出错。
For example, we may want to find the sum of the two numbers on each line for a file such as the following:
比如，我们可能想算出同一行的两个数字的总和，就像下面这样：

    3 4
    5 6
    7 8

The following code doesn’t work:
下面的代码是无法完成任务的：

    some_file.each do |line|
      v1, v2 = line.split       # 以空白符为标志分割行的内容
      print v1 + v2, " "
    end
    # produces:
    # 34 56 78

The problem is that the input was read as strings, not numbers. 
问题就处在从文件中读入的是字符串，而不是数字。
The plus operator concatenates strings, so that’s what we see in the output. 
加号操作符会将字符串连接在一起，所以结果变成那样。
To fix this, use the Integer method to convert the strings to integers:
要解决这个问题，使用Integer方法可将字符串转化为整数：

    some_file.each do |line|
      v1, v2 = line.split
      print Integer(v1) + Integer(v2), " "
    end
    # produces:
    # 7 11 15

**数字是怎么互动的？**
How Numbers Interact
Most of the time, numbers work the way you’d expect. 
大多数时间，数字会按你所期望的那样运行。
If you perform some operation between two numbers of the same class, the answer will typically be a number of that same class (although, as we’ve seen, fixnums can become bignums, and vice versa). 
如果你对同类的两个数字进行一些运算，答案一般会是同类的一个数字（虽然，正如你见过的那样，fixnum可以变成bignum，反之亦然）
If the two numbers are different classes, the result will have the class of the more general one. 
如果两个数字属于不同类，结果将会是更普通的那个的类。
If you mix integers and floats, the result will be a float; if you mix floats and complex numbers, the result will be complex.
如果你混合了整数和浮点数，结果将会是个浮点数；如果混合了浮点数和复数，结果将是复数。

    1 +  2                    #  =>  3
    1 +  2.0                  #  =>  3.0
    1.0  + 2                  #  =>  3.0
    1.0  + Complex(1,2)       #  =>  (2.0+2i)
    1 +  Rational(2,3)        #  =>  (5/3)
    1.0  + Rational(2,3)      #  =>  1.6666666666666665

The return-type rule still applies when it comes to division. 
除法时，返回类型的规则亦然适用。
However, this often confuses folks, because division between two integers yields an integer result:
不管怎样，这经常会出错。因为两个整数的除法就产生另一个整数：

    1.0 / 2   # => 0.5
    1 / 2.0   # => 0.5
    1 / 2     # => 0

If you’d prefer that integer division instead return a fraction (a Rational number), require the mathn library (described in the library section on page 768). 
如果你更喜欢整数的除法返回一个分数（有理数），可以require下mathn库（在后面库部分有介绍）
This will cause arithmetic oper- ations to attempt to find the most natural representation for their results. 
这将导致一个算法操作来试图为结果找到最自然的表达。
For integer division where the result isn’t an integer, a fraction will be returned.
对于整数除法，结果将是一个分数，而不再是整数。

    22 / 7 # => 3
    Complex::I * Complex::I # => (-1+0i)
    require 'mathn'
    22 / 7 # => (22/7)
    Complex::I * Complex::I # => -1

Note that 22/7 is effectively a rational literal once mathn is loaded (albeit one that’s calculated at runtime).
注意一旦加载了mathn（虽然是在运行时计算的），22/7实际上是一个有理数字符，

**使用数字进行循环**
Looping Using Numbers 
整数也支持几种有用的迭代器。如`6.times`
别的迭代器还有upto和downto，它们在两个整数之间分别向上和向下迭代。
另外Numeric类提供了更通用的step方法，更像传统的for循环

     3.times          { print "X  " }
     1.upto(5)        {|i| print  i, " " }
     99.downto(95)    {|i| print  i, " " }
     50.step(80, 5)   {|i| print  i, " " }
     # produces:
     # X X X 1 2 3 4 5 99 98 97 96 95 50 55 60 65 70 75 80

As with other iterators, if you leave the block off, the call returns an Enumerator object:
和其他迭代器一样，如果你让block闭合，调用将返回一个Enumerator对象：

     10.downto(7).with_index {|num, index| puts "#{index}: #{num}"}
     # produces:
     # 0: 10
     # 1: 9
     # 2: 8
     # 3: 7

## 　　5.2　字符串
Ruby字符串只是字符的序列。(Ruby strings are simply sequences of characters.)1.9版之前，ruby字符串是8比特字节的序列。
通常它们包含可打印字符，但也可以包含二进制数据。字符串是String类的对象。

**字符串字面量**
是处于分界符之间的字符序列，常常用来创建字符串。
可以在字符串字面量中放置各种转义序列。
要不然，就无法在程序源文件中表示二进制数据
程序被编译时，它们会被相应的二进制值替换
字符串分界符的类型决定要被替换的程度：单引号字符串中，两个连续的反斜线会被一个反斜线替换，而后面跟有一个单引号的反斜线变成一个单引号。

    'escape using "\\"'  →  escape using "\"
    'That\'s right'      →  That's right

双引号字符串支持更多的转义序列。完整的转义序列见22.2节
双引号还可以使用#{expr}序列把任何ruby代码的值放进字符串中。如果代码只是全局变量、类变量或实例变量，花括号可以忽略。

    "Seconds/day: #{24*60*60}"             →  Seconds/day: 86400
    "#{'Ho! '*3}Merry Christmas!"          →  Ho! Ho! Ho! Merry Christmas!   # <kinder:note> 真是没想到还有这种写法！
    "This is line #$."                     →  This is line 3       # 这个#$.是行号。

要插入替换的代码可以是一条或多条语句，而不仅仅是一个表达式。

    puts  "now is #{ def the(a)
                       'the ' + a
                     end
                     the('time')   # 调用上面的方法，返回：the time。
                   } for all good coders..."
    # 结果:
    # now is the time for all good coders...

另外还有3种方式来构建字符串字面量：%q %Q和here documents
%q和%Q分别界定单引号和双引号的字符串

    %q/general single-quoted string/  →  general single-quoted string
    %Q!general double-quoted string!  →  general double-quoted string
    %Q{Seconds/day: #{24*60*60}}      →  Seconds/day: 86400

跟在q或者Q后面的字符是定界符。
如果定界符是`[{(<`，字符串被一直读取直到发现匹配的结束符号。
也可以是任何一个非字母数字的单字节字符，字符串要读取到下一个相同的分界符。

最后，可以使用here document构建字符串。

    string = <<END_OF_STRING
      The body of the string
      is the input lines up to
      one ending with the same
      text that followed the '<<'
    END_OF_STRING

here document由源文件中的那些行但没有包含在`<<`字符后面指明“终结符”的行组成。一般，终结符必须在第一列出现。
如果把一个减号放在`<<`字符后面，就可以缩进编排终结符：

    print <<-STRING1, <<-STRING2
      Concat
      STRING1
        enate
        STRING2
    # produces:
    #   Concat
    #     enate

注意，在这些例子中，ruby没有从这些字符串中去掉这些前导空格。
### Strings and Encodings 字符串和编码
⇡New in 2.0⇣
Every string has an associated encoding. 
每个字符串都有相应的编码。
The default encoding of a string literal depends on the encoding of the source file that contains it. 
一个字符串字面量的默认编码依赖包含它的源文件的编码。
With no explicit encoding, a source file (and its strings) will be US-ASCII in Ruby 1.9 and UTF-8 in Ruby 2.
如果没有指定编码，源文件以及其中的字符串将是US-ASCII（ruby1.9版）和UTF-8（ruby2版）

    plain_string = "dog"
    puts RUBY_VERSION
    puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}"
    # produces:
    # 2.0.0
    # Encoding of "dog" is UTF-8

If you override the encoding, you’ll do that for all strings in the file:
如果你重写了编码，你应该对文件中的所有字符串这样处理：

    #encoding: utf-8
    plain_string = "dog"
    puts "Encoding of #{plain_string.inspect} is #{plain_string.encoding}"
    utf_string = "δog"
    puts "Encoding of #{utf_string.inspect} is #{utf_string.encoding}"
    # produces:
    # Encoding of "dog" is UTF-8
    # Encoding of "δog" is UTF-8

We’ll have a lot more to say about encoding in Chapter 17, Character Encoding, on page 239.
我们还有很多要说的，详见17章 字符编码，在en4版239页。
### Character Constants 字符常量
Technically, Ruby does not have a class for characters—characters are simply strings of length one. 
技术上说，ruby没有一种长度为1的字符类别。
For historical reasons, character constants can be created by preceding the character (or sequence that represents a character) with a question mark:
因为历史的原因，字符常量可以通过前置问号来创建。

    ?a          # => "a" (printable character)
    ?\n         # => "\n" (code for a newline (0x0a))
    ?\C-a       # => "\u0001" (control a)
    ?\M-a       # => "\xE1" (meta sets bit 7)
    ?\M-\C-a    # => "\x81" (meta and control a)
    ?\C-?       # => "\u007F" (delete character)

Do yourself a favor and forget this section. 
帮自己一个忙，忘了这部分吧。
It’s far easier to use regular octal and hex escape sequences than to remember these ones. 
使用普通的八进制和十六进制逃脱符序列要比记住这个更容易些。
Use "a" rather than ?a, and use "\n" rather than ?\n.
使用"a"而不是?a，使用"\n"而不是?\n
<kinder:note> 这一节真是没搞懂。</kinder:note> 

### 5.2.1 操作字符串
字符串可能是ruby中最大的内建类，有75个以上的标准方法。

例子一：索引点唱机的歌曲列表

    # songdata文件
    # /jazz/j00132.mp3  | 3:45 | Fats Waller         | Ain't Misbehavin'
    # /jazz/j00319.mp3  | 2:58 | Louis Armstrong     | Wonderful World
    # /bgrass/bg0732.mp3| 4:09 | Strength in Numbers | Texas Red
    # :                   :         :                    :
    #
    File.open("songdata") do |song_file|
      songs = SongList.new
      song_file.each do |line|
        file, length, name, title = line.chomp.split(/\s*\|\s*/)  #以` | `为标志将每行分割为字段。并删除行尾回车换行符
        name.squeeze!(" ")  # 删除多余空格
        mins, secs = length.scan(/\d+/)   # 将`分：秒`的格式赋值给mins和secs。
        songs.append(Song.new(title, name, mins.to_i*60+secs.to_i))
      end
    puts songs[1]
    end
    # produces:
    # Song: Wonderful World--Louis Armstrong (178)

例子二：点唱机的关键字搜索能力。通过创建索引类来实现。

    class WordIndex
      def initialize
        @index = {}
      end
      def add_to_index(obj, *phrases)
        phrases.each do |phrase|
          phrase.scan(/\w[-\w']+/) do |word| # 从字符串中抽取出匹配正则表达式的元素
            word.downcase!                   # 为了让搜索与大小写无关，查找时将所有词转化为小写。
            @index[word] = [] if @index[word].nil?
            @index[word].push(obj)
          end
        end
      end
      def lookup(word)    # 为了让搜索与大小写无关，查找时将所有词转化为小写。
        @index[word.downcase]
      end
    end

例子三：扩展SongList类，完成功能测试：

    class SongList
      def initialize
        @songs = Array.new
        @index = WordIndex.new
      end
      def append(song)
        @songs.push(song)
        @index.add_to_index(song, song.name, song.artist)
        self
      end
      def lookup(word)
        @index.lookup(word)
      end
    end
    # 测试：
    songs = SongList.new
    song_file.each do |line|
      file, length, name, title = line.chomp.split(/\s*\|\s*/)
      name.squeeze!(" ")
      mins, secs = length.scan(/\d+/)
      songs.append(Song.new(title, name, mins.to_i*60+secs.to_i))
    end
    puts songs.lookup("Fats")
    puts songs.lookup("ain't")
    puts songs.lookup("RED")
    puts songs.lookup("WoRlD")
    # 结果:
    # Song: Ain't Misbehavin'--Fats Waller (225)
    # Song: Ain't Misbehavin'--Fats Waller (225)
    # Song: Texas Red--Strength in Numbers (249)
    # Song: Wonderful World--Louis Armstrong (178)

<kinder:note> 第四版只有一个例子：

    Song = Struct.new(:title, :name, :length)
    File.open("songdata") do |song_file|
      songs = []
      song_file.each do |line|
        file, length, name, title = line.chomp.split(/\s*\|\s*/)
        name.squeeze!(" ")
        mins, secs = length.scan(/\d+/)
        songs << Song.new(title, name, mins.to_i*60 + secs.to_i)
      end
      puts songs[1]
    end
    # produces:
    # #<struct Song title="Wonderful World", name="Louis Armstrong", length=178>


## 　　5.3　区间range
ruby使用区间实现3种不同的特性：序列(sequence)条件(conditionals)和间隔(intervals)
### 5.3.1 区间作为序列
序列有起点、终点和序列中间产生连续值的方法。
`..`创建闭合区间（不包括右端的值）。
`...`创建不包括右端的值的区间。
和Perl的早期版本不一样，ruby中区间没有在内部用列表表示：1..100000序列被存储为Range对象，包含对两个Fixnum对象的引用。
`to_s`方法可以吧区间转换成列表

    (1..10).to_a        →  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    ('bar'..'bat').to_a →  ["bar", "bas", "bat"]

区间实现了许多方法可以让我们迭代他们，并且以多种方式测试他们的内容。

    digits = 0..9
    digits.include?(5)                   →  true
    digits.min                           →  0
    digits.max                           →  9
    digits.reject {|i| i < 5 }           →  [5, 6, 7, 8, 9]
    digits.each {|digit| dial(digit) }   →  0..9

ruby可以根据所定义的对象来创建区间。
唯一的限制是这些对象必须返回在序列中的下一个对象作为对succ的相应，而且这些对象必须可以使用`<=>`来比较。
`<=>`比较两个值，根据第一个值是否小于、等于、大于第二个值分别返回-1, 0, +1

2版的例子：音量类

    class VU
      include Comparable
      attr :volume
      def initialize(volume)
        @volume = volume  # 0..9
      end
      def inspect
        '#' * @volume
      end
      # Support for ranges
      def <=>(other)
        self.volume <=> other.volume
      end
      def succ
        raise(IndexError, "Volume too big") if @volume >= 9
        VU.new(@volume.succ)
      end
    end

因为VU类实现了succ和`<==>`方法，因此可以作为区间。

    medium_volume = VU.new(4)..VU.new(7)
    medium_volume.to_a                → [####, #####, ######, #######]
    medium_volume.include?(VU.new(3)) → false                         

4版的例子，给出数字的2倍：

    class PowerOfTwo
      attr_reader :value
      def initialize(value)
        @value = value
      end
      def <=>(other)
        @value <=> other.value
      end
      def succ
        PowerOfTwo.new(@value + @value)  # 自身相加
      end
      def to_s
        @value.to_s
      end
    end
    p1 = PowerOfTwo.new(4)
    p2 = PowerOfTwo.new(32)
    puts (p1..p2).to_a
    # produces:
    # 4
    # 8
    # 16
    # 32

### 5.3.2 区间作为条件
区间在这里表现得就像某种双向开关--区间第一部分条件为true，就打开，第二部分的条件为true，就关闭。

    # 打印从标准输入得到的行的集合。
    # 每组第一行包含start这个词，最后一行包含end这个词。
    while line = gets
      puts line if line =~ /start/ .. line =~ /end/
    end

在幕后，区间跟踪了每种测试的状态。
7.6循环和22.5表达式中会有其他例子。

### 5.3.2 区间作为间隔
间隔测试看看一些值是否会落入区间表达的间隔内。使用`===`（case equlity）可以做到这一点。
<kinder:note> 注意，===符号的两边不可以颠倒！

    (1..10)    ===  5          →  true 
    (1..10)    ===  15         →  false
    (1..10)    ===  3.14159    →  true
    ('a'..'j') ===  'c'        →  true
    ('a'..'j') ===  'z'        →  false

7.6 Case表达式显示了这种测试。
这是第4版的内容：

    car_age = gets.to_f    # 假设值为 9.5
    case car_age
      when 0...1     # 等同于(0...1) === 9.5
        puts "Mmm.. new car smell"
      when 1...3
        puts "Nice and new"
      when 3...10          # 就是这个区间。区间的表述非常关键，假如改为：`3..9`，则9.5不会落入这个区间
        puts "Reliable but slightly dinged"  
      when 10...30
        puts "Clunker"
      else
        puts "Vintage gem"
    end
    # produces:
    # Reliable but slightly dinged

## 　　5.4　正则表达式
<kinder:note> 这一节在第4版中单独作为第7章出现。
**创建**
正则表达式是Regexp类型的对象，可以通过显式的调用构造函数或使用字面量/pattern/和%r{pattern}来创建。

    a = Regexp.new('^\s*[a-z]') → /^\s*[a-z]/
    b = /^\s*[a-z]/             → /^\s*[a-z]/
    c = %r{^\s*[a-z]}           → /^\s*[a-z]/

**匹配**
一旦有了正则表达式对象，可以使用Regexp#match(string)或匹配操作符`=～``！～`对字符串进行匹配。
匹配操作符对String和Regexp对象均有定义。至少一个操作数必须为正则表达式。
早期版本中，两个操作数可能都是字符串，第二个操作数会被转换成正则表达式。

    name = "Fats Waller"
    name =~ /a/  → 1
    name =~ /z/  → nil
    /a/ =~ name  → 1

**匹配变量**
匹配操作符返回匹配发生的字符位置。除此还有些副产品，会设置一些ruby变量。
$&是与模式匹配的那部分字符串，$`是匹配之前的那部分字符串，$'是匹配之后的那部分字符串。
因此可以使用这些变量来编写一个``show_regexp`方法，说明具体的模式在何处发生匹配。

    def show_regexp(a, re)
      if a =~ re
        "#{$`}<<#{$&}>>#{$'}"
      else
        "no match"
      end
    end
    show_regexp('very interesting', /t/) → very in<<t>>eresting 
    show_regexp('Fats Waller', /a/)      → F<<a>>ts Waller
    show_regexp('Fats Waller', /ll/)     → Fats Wa<<ll>>er
    show_regexp('Fats Waller', /z/)      → no match

这个匹配也设置了线程局部变量(thread-local variables),$~、$1..$9。
$~变量是MatchData对象（见537页27章的内置类和模块），持有你想知道的有关匹配的所有信息。
$1等持有匹配个部分的值。

**正则表达式选项**
Regular Expression Options
A regular expression may include one or more options that modify the way the pattern matches strings. 
正则表达式可能包含一个或多个选项，可改变模式匹配字符串的方式。
If you’re using literals to create the Regexp object, then the options are one or more characters placed immediately after the terminator. 
如果你使用字面量来创建Regexp对象，选项是一个或多个字符紧接着放置在结束符之后。
If you’re using Regexp.new, the options are constants used as the second parameter of the constructor.
如果你使用Regexp.new，选项是常数，是构造器的第二个参数。
i
Case insensitive. 
忽略大小写。
The pattern match will ignore the case of letters in the pattern and string. 
模式匹配将忽视模式和字符串里面字符大小写的情况。
 (The old technique of setting $= to make matches case insensitive no longer works.)
旧的设置`$=`来使匹配忽略大小写的技术不再使用。
o
Substitute once. 
只替换一次。
Any #{...} substitutions in a particular regular expression literal will be performed just once, the first time it is evaluated. 
任何在特定正则表达式字面量的#{}替换将只被执行一次， 即第一次被求出值的时候。？？
Otherwise, the substitutions will be performed every time the literal generates a Regexp object.
其他情况下，替换将每次都被执行，字面量产生Regexp对象。
m
Multiline mode. 
多行模式。
Normally, “.” matches any character except a newline. 
平常，点号匹配除了换行符外的任何字符。
With the /m option, “.” matches any character.
有了/m选项，点号匹配任何字符。
x
Extended mode. 
扩展模式。
Complex regular expressions can be difficult to read. 
复杂的正则表达式很难阅读。
The x option allows you to insert spaces and newlines in the pattern to make it more readable. 
x选项允许你插入空白符和换行符在模式中，更加易读。
You can also use # to introduce comments.
你也可以使用#进行注释。
<kinder:note> 扩展模式详见7.4高级正则表达式的相关

Another set of options allows you to set the language encoding of the regular expression. 
另一组选项允许你设置正则表达式的语言编码。
If none of these options is specified, the regular expression will have US-ASCII encoding if it contains only 7-bit characters. 
如果没有指定任何选项，又包含着7比特字符，正则表达式将使用US-SCII编码。
Otherwise, it will use the default encoding of the source file containing the literal: n: no encoding (ASCII), e: EUC, s: SJIS, and u: UTF-8.
其他情况，将使用包含着字面的源文件的默认编码：n是没有编码（ASCII），e是EUC，s是SJIS，u是UTF-8。
 
### 5.4.1 模式
在模式内，除了` ., |, (, ), [, ], {, }, +, \, ^, $, *, ? `之外，所有字符均匹配他们自身。
在这些特殊字符之前放置一个反斜线可以匹配它们的字面量。
反斜线后面跟着一个分母数字的字符被用来引入一个特殊的匹配构造。<kinder:note> ？
另外，正则表达式可能包含`#{}`表达式替换。<kinder:note> ？
#### 锚点
默认情况下，正则表达式会试图发现模式在字符串中出现的第一个匹配。
^匹配行首
$匹配行尾
\A匹配字符串的开始
\Z匹配以\n结束的字符串的结尾
\z匹配字符串的结尾
\b匹配词的边界
\B匹配非词的边界

    show_regexp("this is\nthe time", /^the/)   → this is\n<<the>> time
    show_regexp("this is\nthe time", /is$/)    → this <<is>>\nthe time
    show_regexp("this is\nthe time", /\Athis/) → <<this>> is\nthe time
    show_regexp("this is\nthe time", /\Athe/)  → no match
    show_regexp("this is\nthe time", /\bis/)   → this <<is>>\nthe time
    show_regexp("this is\nthe time", /\Bis/)   → th<<is>> is\nthe time

#### 字符类
这是处于方括号之间字符的集合
`[characters]`匹配方括号内的任何单个字符。
如：`[aeiou]``[,.:;!?]`
连特殊正则表达式字符的意义，如`.|()[{+^$*?`在方括号里也是关闭的。

不过，正常的**字符串替换**仍然发生。
如\b回退空格、\n回车换行，详见22.2基本类型一节
\#{code} Value of code    \b Backspace (0x08)      \t Tab (0x09)   
\nnn Octal nnn            \cx Control-x            \uxxxx Unicode character  <kinder:note> 4版新增
\x x                      \e Escape (0x1b)         \u{xx xx xx} Unicode characters <kinder:note>4版新增
\C-x Control-x            \f Formfeed (0x0c)       \v Vertical tab (0x0b)
\M-x Meta-x               \n Newline (0x0a)        \xnn Hex nn
\M-\C-x Meta-control-x    \r Return (0x0d)        
\a Bell/alert (0x07)      \s Space (0x20) 

下面**缩写形式**也是有效。
\d  [0-9]          数字字符
\D  [^0-9]         非数字字符
\h                 十六进制 <kinder:note> 第四版
\H                 非十六进制 <kinder:note> 第四版
\R                 普通的换行序列。匹配两字符的\r\n。<kinder:note> （ruby2新）
\s  [ \t\r\n\f]    空格字符
\S  [^ \t\r\n\f]   非空格字符
\w  [A-Za-z0-9]    组词字符
\W  [^A-Za-z0-9]   非组词字符
\X                 扩展的Unicode字形（两个或更多字符的结合以形成单个可见字符）。<kinder:note> ruby2新
**Posix字符类**
Posix character classes
[:alnum:]          字母和数字
[:alpha:]          大小写字母
[:ascii:]           7比特字符，包含非打印字符。<kinder:note> 第4版
[:blank:]           空格和制表符
[:cntrl:]           控制字符（至少0x00-0x1f，0x7f）
[:digit:]           数字
[:graph:]           除了空格的可打印字符
[:lower:]           小写字母
[:print:]           任何可打印字符（包括空格）
[:punct:]           除了空格、字母、数字之外的可打印字符
[:space:]           空格（等同于\s）
[:upper:]           大写字母
[:xdigit:]          16进制数字（0-9, a-f, A-F）
[:word:]            字母数字，下划线，多比特字符 <kinder:note> 第4版
举例：

    show_regexp('Price $12.', /[aeiou]/)           → Pr<<i>>ce $12.
    show_regexp('Price $12.', /[\s]/)              → Price<< >>$12.
    show_regexp('Price $12.', /[[:digit:]]/)       → Price $<<1>>2.
    show_regexp('Price $12.', /[[:space:]]/)       → Price<< >>$12.
    show_regexp('Price $12.', /[[:punct:]aeiou]/)  → Pr<<i>>ce $12.
    a = 'see [Design Patterns-page 123]'
    show_regexp(a, /[A-F]/)        → see [<<D>>esign Patterns-page 123]
    show_regexp(a, /[A-Fa-f]/)     → s<<e>>e [Design Patterns-page 123]
    show_regexp(a, /[0-9]/)        → see [Design Patterns-page <<1>>23]
    show_regexp(a, /[0-9][0-9]/)   → see [Design Patterns-page <<12>>3]
    show_regexp(a, /[]]/)          → see [Design Patterns-page 123<<]>>  这是2版的例子。
    show_regexp(a, /[\]]/)          #  see [The PickAxe-page 123<<]>>  这是4版的例子。
    show_regexp(a, /[-]/)          → see [Design Patterns<<->>page 123] 这是2版的例子。
    show_regexp(a, /[\d\-]/)        #  see [The PickAxe<<->>page 123]  这是4版的例子。但这个\d有些奇怪。明显是错误吧。<kinder:note> 
    show_regexp(a, /[^a-z]/)       → see<< >>[Design Patterns-page 123]
    show_regexp(a, /[^a-z\s]/)     → see <<[>>Design Patterns-page 123]
    show_regexp('It costs $12.', /\s/) → It<< >>costs $12.
    show_regexp('It costs $12.', /\d/) → It costs $<<1>>2.
    show_regexp('Price $12.', /[^A-Z]/)       # => P->r<-ice $12.
    show_regexp('Price $12.', /[^\w]/)        # => Price-> <-$12.
    show_regexp('Price $12.', /[a-z][^a-z]/)  # => Pric->e <-$12.

**字符设置选项 ⇡New in 2.0⇣**
If you look at the table, you’ll see that some of the character classes have different interpretations depending on the character set option defined for the regular expression. 
如果你看到了表格，你会看到一些字符类有不同的解释，依赖正则表达式的字符设置选项的定义。
Basically, these options tell the regexp engine whether (for example) word characters are just the ASCII alphanumerics, or whether they should be extended to include Unicode letters, marks, numbers, and connection punctuation. 
基本上，那些选项告诉正则表达式引擎，词汇字符是否只是ASCII字母数字，或者是否他们应该被扩展为包括Unicode字符，标记，数字和连接标点。
The options are set using the sequence (?option), where the option is one of d (for Ruby 1.9 behavior), a for ASCII-only support, and u for full Unicode support. 
选项使用序列（?选项）来设置，里面的选项是d（对于ruby1.9来说），a是支持纯ASCII，u支持全Unicode。
If you don’t specify an option, it defaults to (?d).
如果你没有指定选项，默认为(?d)。

    show_regexp('über.', /(?a)\w+/) # => ü->ber<-.
    show_regexp('über.', /(?d)\w+/) # => ü->ber<-.
    show_regexp('über.', /(?u)\w+/) # => ->über<-.
    show_regexp('über.', /(?d)\W+/) # => ->ü<-ber.
    show_regexp('über.', /(?u)\W+/) # => über->.<-

**交集**
You can create the intersection of character classes using &&. So, to match all lowercase ASCII letters that aren’t vowels, you could use this:
你可以使用`&&`来创建字符类的交集。这样，要匹配所有非元音的小写ASCII字母，你可以这样：

    str = "now is the time"
    str.gsub(/[a-z&&[^aeiou]]/, '*') # => "*o* i* **e *i*e"

**\p构造**
The \p construct gives you an encoding-aware way of matching a character with a particular Unicode property (shown in Table 4, Unicode character properties, on page 114):
`\p`构造给你一个用特定编码属性来匹配字符的清醒的编码方式。

    # encoding: utf-8
    string = "∂y/∂x = 2πx"
    show_regexp(string, /\p{Alnum}/)  # => ∂->y<-/∂x = 2πx
    show_regexp(string, /\p{Digit}/)  # => ∂y/∂x = ->2<-πx
    show_regexp(string, /\p{Space}/)  # => ∂y/∂x-> <-= 2πx
    show_regexp(string, /\p{Greek}/)  # => ∂y/∂x = 2->π<-x
    show_regexp(string, /\p{Graph}/)  # => ->∂<-y/∂x = 2πx

**字符属性**
Character Properties
\p{name}   Matches character with named property  匹配指定的特性的字符
\p{^name}  Matches any character except named property  匹配除了指定的特性之外的字符
\P{name}   Matches any character except named property  匹配除了指定的特性之外的字符

**属性名称**
Property names.
Spaces, underscores, and case are ignored in property names.
空格、下划线，和在属性名称里被忽略的情况
- All encodings
Alnum, Alpha, Blank, Cntrl, Digit, Graph, Lower, Print, Punct, Space, Upper, XDigit, Word, ASCII
- EUC and SJIS
Hiragana, Katakana
- UTF-n
Any, Assigned, C, Cc, Cf, Cn, Co, Cs, L, Ll, Lm, Lo, Lt, Lu, M, Mc, Me, Mn, N, Nd, Nl, No, P, Pc, Pd, Pe, Pf, Pi, Po, Ps, S, Sc, Sk, Sm, So, Z, Zl, Zp, Zs, Arabic, Armenian, Bengali, Bopomofo, Braille, Buginese, Buhid, Canadian_ Aboriginal, Cherokee, Common, Coptic, Cypriot, Cyrillic, Deseret, Devana- gari, Ethiopic, Georgian, Glagolitic, Gothic, Greek, Gujarati, Gurmukhi, Han, Hangul, Hanunoo, Hebrew, Hiragana, Inherited, Kannada, Katakana, Kharoshthi, Khmer, Lao, Latin, Limbu, Linear_B, Malayalam, Mongolian, Myanmar, New_Tai_Lue, Ogham, Old_Italic, Old_Persian, Oriya, Osmanya, Runic, Shavian, Sinhala, Syloti_Nagri, Syriac, Tagalog, Tagbanwa, Tai_Le, Tamil, Telugu, Thaana, Thai, Tibetan, Tifinagh, Ugaritic, Yi
<kinder:note> 对了这里面的`Han`就是汉字了！ruby万岁！

最后，出现在**方括号外面的点号（.）**表示除了回车换行符外的任何字符（尽管在多行模式下它也匹配回车换行符）。

    a = 'It costs $12.'
    show_regexp(a, /c.s/) → It <<cos>>ts $12.
    show_regexp(a, /./)   → <<I>>t costs $12.
    show_regexp(a, /\./)  → It costs $12<<.>>

#### 重复
如果r代表模式内的正则表达式，那么：
`r*`     匹配零个或多个r。默认会匹配尽可能多的字符串。即贪婪匹配。
`r+`     匹配一个或多个r。默认会匹配尽可能多的字符串。
`r?`     匹配零个或一个r。一般和`*``+`结合使用，表示不贪婪匹配。
`r{m,n}` 匹配至少m次和最多n次的r
`r{m,}`  匹配至少m次r
`r{,n}`  匹配最多m次r   <kinder:note> 4版增
`r{m}`   匹配m次r
重复构造有更高的优先级 -- 它们只绑定到模式内先前的正则表达式。
如/ab+/匹配a后面各着一个或多个b，而不是ab序列。
必须小心使用`*`，会匹配任何字符串，包括0个。
可以通过添加问号后缀让它匹配最少的字符串来改变这个默认行为。
The repetition is then called lazy—it stops once it has done the minimum amount of work required.
这种重复被称为惰性 -- 它一旦已经完成了所要求的最小数量的工作就会停止 。

    a = "The moon is made of cheese"
    show_regexp(a, /\w+/)             → <<The>> moon is made of cheese
    show_regexp(a, /\s.*\s/)          → The<< moon is made of >>cheese  #贪婪匹配
    show_regexp(a, /\s.*?\s/)         → The<< moon >>is made of cheese  #不贪婪匹配
    show_regexp(a, /[aeiou]{2,99}/)   → The m<<oo>>n is made of cheese
    show_regexp(a, /mo?o/)            → The <<moo>>n is made of cheese
    show_regexp(a, /mo??o/)           → The <<mo>>on is made of cheese

#### 替换（选择）
竖线（|）是特别字符，行分割模式必须使用反斜线来转义；未转义的竖线要么匹配在它之前的正则表达式，要么匹配在它之后的正则表达式。
竖线的优先级非常低， 这经常是个陷阱。

    a = "red ball blue sky"
    show_regexp(a, /d|e/)                     →  r<<e>>d ball blue sky
    show_regexp(a, /al|lu/)                   →  red b<<al>>l blue sky
    show_regexp(a, /red ball|angry sky/)      →  <<red ball>> blue sky

#### 编组（分组）
你可以使用括号在正则表达式中编组词目，组内的所有东西被当作单个正则表达式对待。

    show_regexp('banana', /an*/)     → b<<an>>ana
    show_regexp('banana', /(an)*/)   → <<>>banana
    show_regexp('banana', /(an)+/)   → b<<anan>>a
    a = 'red ball blue sky'
    show_regexp(a, /blue|red/)       → <<red>> ball blue sky
    show_regexp(a, /(blue|red) \w+/) → <<red ball>> blue sky
    show_regexp(a, /(red|blue) \w+/) → <<red ball>> blue sky
    show_regexp(a, /red|blue \w+/)   → <<red>> ball blue sky   # 没有编组，所以前面是red，后面是blue \w+ 
    show_regexp(a, /red (ball|angry) sky/)  → no match
    a = 'the red angry sky'
    show_regexp(a, /red (ball|angry) sky/) → the <<red angry sky>>

括号也收集模式匹配的结果。ruby计算开始括号的数目，保存每个开始括号和相应的关闭括号之间部分匹配的结果。
可以在模式的剩余部分和ruby程序中使用这种匹配。
模式内部\1序列是第一个组的匹配，\2序列指的是第二个组的匹配。在模式外面特殊变量$1和$2等起到相同的作用。

    "12:50am" =~ /(\d\d):(\d\d)(..)/    → 0
    "Hour is #$1, minute #$2"           → "Hour is 12, minute 50"
    "12:50am" =~ /((\d\d):(\d\d))(..)/  → 0
    "Time is #$1"                       → "Time is 12:50"
    "Hour is #$2, minute #$3"           → "Hour is 12, minute 50"
    "AM/PM is #$4"                      → "AM/PM is am"

在匹配的剩余部分使用当前部分匹配的能力，能够在字符串中寻找各种形式的重复。

    # match duplicated letter
    show_regexp('He said "Hello"', /(\w)\1/    → He said "He<<ll>>o")
    # match duplicated substrings
    show_regexp('Mississippi', /(\w+)\1/)    → M<<ississ>>ippi

也可以使用向后引用匹配定界符： <kinder:note> 这一段在4版被删除。应该译为反向引用吧。

    show_regexp('He said "Hello"', /(["']).*?\1/) →  He said <<"Hello">>
    show_regexp("He said 'Hello'", /(["']).*?\1/) →  He said <<'Hello'>>

**命名编组**
Rather than use numbers, you can also use names to refer to previously matched content.
与其使用数字，你也可以使用名字来引用先前匹配的内容。
You give a group a name by placing ?<name> immediately after the opening parenthesis.
你可以将?<name>直接放在圆括号的后面，给编组一个名字。
You can subsequently refer to this named group using \k<name> (or \k'name').
随后就可引用这个已经命名的分组：\k<name>或者\k'name'。

    # match duplicated letter  匹配重复字符
    str = 'He said "Hello"'
    show_regexp(str, /(?<char>\w)\k<char>/) # => He said "He->ll<-o"   ?<char>\w是将匹配的\w部分命名为<char>，然后用\k<char>来重复这个匹配的\w
    # match duplicated adjacent substrings  匹配临近的重复字符
    str = 'Mississippi'
    show_regexp(str, /(?<seq>\w+)\k<seq>/) # => M->ississ<-ippi

The named matches in a regular expression are also available as local variables, but only if you use a literal regexp and that literal appears on the left hand side of the =~ operator. 
正则表达式里已经命名的匹配也可用作局部变量，但只有你使用字面量正则表达式，并且字面量处在`=～`的左边的时候才行。
(So you can’t assign a regular expression object to a variable, match the contents of that variable against a string, and expect the local variables to be set.)
（所以你不能将一个正则表达式对象赋值给一个变量，将那个变量的内容和字符串匹配，并期待局部变量可以设置）

    /(?<hour>\d\d):(?<min>\d\d)(..)/ =~ "12:50am" # => 0    因为这个命名变量在左边？
    "Hour is #{hour}, minute #{min}"    # => "Hour is 12, minute 50"
    # You can mix named and position-based references  你可以混用命名变量和位置变量。
    "Hour is #{hour}, minute #{$2}"     # => "Hour is 12, minute 50"
    "Hour is #{$1}, minute #{min}"      # => "Hour is 12, minute 50"

### 5.4.2 基于模式的替换
查找匹配第一个参数的那部分字符串，同时用第二个参数替换它们。
String#sub -- 进行一次替换
String#gsub -- 每次匹配都替换

    a = "the quick brown fox"
    a.sub(/[aeiou]/, '*') →    "th* quick brown fox" 
    a.gsub(/[aeiou]/, '*') →   "th* q**ck br*wn f*x"
    a.sub(/\s\S+/, '') →       "the brown fox"
    a.gsub(/\s\S+/, '') →      "the"

第二个参数可以是String或block。
如果是block，匹配的子字符串会被传递给block，block的结果值会替换原先的字符串中。

    a = "the quick brown fox"
    a.sub(/^./) {|match| match.upcase }        → "The quick brown fox"
    a.gsub(/[aeiou]/) {|vowel| vowel.upcase }  → "thE qUIck brOwn fOx"
    # 点唱机：让作者的首字符大写。
    def mixed_case(name)
      name.gsub(/\b\w/) {|first| first.upcase }
    end
    mixed_case("fats waller")           → "Fats Waller"
    mixed_case("louis armstrong")       → "Louis Armstrong"
    mixed_case("strength in numbers")   → "Strength In Numbers"

**更高级的写法：符号和散列表**
There’s an idiomatic way to write the substitution in Ruby 1.9, but we’ll have to wait until The `Symbol.to_proc` Trick, on page 352 to see why it works:
在ruby1.9中已经有了惯用的方式来写替代，但我们只有等到352页的`Symbol.to_proc`方法，才能知道为什么可以：

    def mixed_case(name)
      name.downcase.gsub(/\b\w/, &:upcase)
    end
    mixed_case("dAvE tHoMas") # => "Dave Thomas"

You can also give sub and gsub a hash as the replacement parameter, in which case they will look up matched groups and use the corresponding values as replacement text:
你也可以给sub和gsub一个散列表作为替换参数，这样他们将寻找匹配的分组，并使用相应的值作为替换文本：

    replacement = { "cat" => "feline", "dog" => "canine" }
    replacement.default = "unknown"
    "cat and dog".gsub(/\w+/, replacement) # => "feline unknown canine"

**替换中的反斜线序列**
\1\2等序列可以作为sub和gsub的第二个参数。
其他的反斜线序列在替换中也起了作用：\&(最后的匹配)\+(最后匹配的组)\`(匹配之前的字符串)\'(匹配之后的字符串)\\(字面量反斜线)

    "fred:smith".sub(/(\w+):(\w+)/, '\2, \1') → "smith, fred"
    "nercpyitno".gsub(/(.)(.)/, '\2\1')       → "encryption"

You can also reference named groups:
你也可以引用命名分组：

    puts "fred:smith".sub(/(?<first>\w+):(?<last>\w+)/, '\k<last>, \k<first>')
    puts "nercpyitno".gsub(/(?<c1>.)(?<c2>.)/, '\k<c2>\k<c1>')
    # produces:
    # smith, fred
    # encryption

但如果在替换中包含字面量反斜线，会变得很困惑。
例如`str.gsub(/\\/, '\\\\\\')`。这个代码用两个反斜线替换一个反斜线。第二个字符不写成`\\\\`这是因为替换发生时，正则表达式引擎把\\转换成\字符串。
如果利用\&，可以写成:

    str = 'a\b\c'               → "a\b\c"
    str.gsub(/\\/, '\\\\\\\\')  → "a\\b\\c"
    str = 'a\b\c'              → "a\b\c"
    str.gsub(/\\/, '\&\&')     → "a\\b\\c"

如果使用gsub的block形式，替换的字符串仅被分析一次，因此更简便：

    str = 'a\b\c'              → "a\b\c"
    str.gsub(/\\/) { '\\\\' }  → "a\\b\\c"

**例子**
这个例子极好地表达了结合使用正则表达式和block，出自WaKou Aoyama编写的CGI库模块的代码片段。
这段代码接受包含HTML转义序列的字符串并把它转换成普通的ASCII。
为了支持日本用户，在正则表达式上使用了n修饰符关闭了宽字符的处理。

    def unescapeHTML(string)
      str = string.dup
      str.gsub!(/&(.*?);/n) {
        match = $1.dup                # $1代表括号里(.*?)的内容。依次是lt amp amp gt；quot quot #65 #x41
        case match
          when /\Aamp\z/ni             then  '&'
          when /\Aquot\z/ni            then  '"'
          when /\Agt\z/ni              then  '>'
          when /\Alt\z/ni              then  '<'
          when /\A#(\d+)\z/n           then  Integer($1).chr
          when /\A#x([0-9a-f]+)\z/ni   then  $1.hex.chr
        end
      }
      str
    end
    puts unescapeHTML("1&lt;2 &amp;&amp; 4&gt;3")
    puts unescapeHTML("&quot;A&quot; = &#65; = &#x41;")
    # produces:
    # 1<2 && 4>3
    # "A" = A = A    <kinder:note> 为什么是A？

### 5.4.3 面向对象的正则表达式
ruby有一个完全面向对象的正则表达式处理系统，在之上包装所有这些$变量。
Regexp#match方法对字符串匹配正则表达式，如果失败返回nil；成功返回MatchData类的一个实例。
matchData对象让你访问关于这次匹配的所有可用信息，这是通过$变量得到的。

    re = /(\d+):(\d+)/ # 匹配时间 hh:mm
    md = re.match("Time: 12:34am")
    md.class                → MatchData
    md[0]          # == $& → "12:34"
    md[1]          # == $1 → "12"
    md[2]          # == $2 → "34"
    md.pre_match   # == $` → "Time: "
    md.post_match  # == $' → "am"

匹配数据存储在自己的对象里，这样可以同时保留两个或多个模式匹配的结果。这可是使用$变量做不出来的。

    re = /(\d+):(\d+)/ # match a time hh:mm
    md1 = re.match("Time: 12:34am")
    md2 = re.match("Time: 10:30pm")
    md1[1, 2] → ["12", "34"]
    md2[1, 2] → ["10", "30"]

ruby在匹配结束后把结果nil或MatchData对象的引用保存在线程局部变量($~)中。所有其他的正则表达式变量都是从这个对象派生出来的。

    re = /(\d+):(\d+)/
    md1 = re.match("Time: 12:34am")
    md2 = re.match("Time: 10:30pm")
    [ $1, $2 ] # 这是最后一次成功匹配的   → ["10", "30"]
    $~ = md1                             
    [ $1, $2 ] # 这是之前成功匹配的 → ["12", "34"]

## 7.4 高级正则表达式 Advanced Regular Expressions
You may never need the information in the rest of this chapter. 
这章剩下部分的信息，你可能永远也不需要。
But, at the same time, knowing some of the real power in the Ruby regular expression implementation might just dig you out of a hole. [4]
但同时，知道一些ruby正则表达式实现里的真正能力，可能让你摆脱困境。

#### Regular Expression Extensions 正则表达式扩展`(?# comment)``(?:re)`
⇡New in 2.0⇣
Ruby uses the Onigmo regular expression library. 
ruby使用Onigmo正则表达式库。
This offers a large number of extensions over traditional Unix regular expressions. 
它在传统Unix正则表达式之外提供了大量的扩展。
Most of these extensions are written between the characters (? and ). 
这些扩展中的大多数写在字符（? and）之间。
The parentheses that bracket these extensions are groups, but they do not necessarily generate backreferences—some do not set the values of \1, $1, and so on.
扩起这些扩展的圆括号是分组的，但它们没有必要产生反向引用 -- 一些不设置\1 $1的值，以此类推。
[4]. Onigmo is an extension of the Oniguruma regular expression engine.
Onigmo是Onigruma正则表达式引擎的扩展。

The sequence (?# comment) inserts a comment into the pattern. 
序列**(?# comment)**插入一个注释到模式里面。
The content is ignored during pattern matching. 
在模式匹配期间内容被忽略。
As we’ll see, commenting complex regular expressions can be as helpful as commenting complex code.
正如我们将看到的，注释复杂的正则表达式是十分有用的，正如注释复杂代码一样。

**(?:re)** makes re into a group without generating backreferences. 
(?:re)使得re进入分组，无需产生反向引用。
This is often useful when you need to group a set of constructs but don’t want the group to set the value of $1 or whatever. 
当你需要分组一组构造，但不想分组设置$1或其他变量的值，这常常有用。
In the example that follows, both patterns match a date with either colons or slashes between the month, day, and year. 
下面的例子中，两个模式都匹配一个日期，这个日期在年月日之间带有冒号或者反斜线。
The first form stores the separator character (which can be a slash or a colon) in $2 and $4, but the second pattern doesn’t store the separator in an external variable.
第一种形式存储了分隔符（可以是冒号或者反斜线）在$2和$4，但第二个模式不会存储分隔符在内建变量中。

    date = "12/25/2010"
    date =~ %r{(\d+)(/|:)(\d+)(/|:)(\d+)}
    [$1,$2,$3,$4,$5] # => ["12", "/", "25", "/", "2010"]
    date =~ %r{(\d+)(?:/|:)(\d+)(?:/|:)(\d+)}   # 使用了(?:)
    [$1,$2,$3]       # => ["12", "25", "2010"]

#### Lookahead and Lookbehind 先行断言`(?=re)``(?!re)`和后行断言`(?<=re)``(?<!re)`
You’ll sometimes want to match a pattern only if the matched substring is preceded by or followed by some other pattern. 
你有时候需要匹配一个模式，只要匹配的子字符串在前面或被一些其他的模式所跟随。
That is, you want to set some context for your match but don’t want to capture that context as part of the match.
这就是，你想设置一些文本给你的匹配，但不想让这些文本成为匹配的一部分。

For example, you might want to match every word in a string that is followed by a comma, but you don’t want the comma to form part of the match. 
比如，你可能想匹配每个词语在一个字符串，这个串被一个都逗号跟随，但你不想逗号来形成匹配的一部分。
Here you could use the charmingly named zero-width positive lookahead extension. 
这里你可以使迷人的**零宽正向先行断言**扩展
(?=re) matches re at this point but does not consume it—you can look forward for the context of a match without affecting $&. 
(?=re)匹配re在这个点上但不会耗尽它 -- 你可以向前查找一个匹配的内容，无需取出$&变量。
In this example, we’ll use scan to pick out the words:
在这个例子中，我们将使用scan来检出词汇。

    str = "red, white, and blue"
    str.scan(/[a-z]+(?=,)/) # => ["red", "white"]

You can also match before the pattern using `(?<=re)` (zero-width positive lookbehind). 
你也可以匹配之前的模式，使用`(?<=re)`(**零宽正向后行**)
This lets you look for characters that precede the context of a match without affecting $&. 
这让你寻找在匹配内容之前的字符，无需取出$&变量。 <kinder:note> 这样的翻译的意思应该和上一段的不同，但怎么读都不顺，表达不好吧。
The following example matches the letters dog but only if they are preceded by the letters hot:
下面的例子匹配字符dog，但只在前置了字母hot的情况下。

    show_regexp("seadog hotdog", /(?<=hot)dog/) # => seadog hot->dog<-

For the lookbehind extension, re either must be a fixed length or consist of a set of fixed- length alternatives. 
对于后行扩展，re或有一个固定长度，或包含固定长度的可选集合
That is, `(?<=aa)` and `(?<=aa|bbb)` are valid, but `(?<=a+b)` is not.
这就是说，`(?<=aa)`和`(?<=aa|bbb)`是有效的，但`(?<=a+b)`则无效。
Both forms have negated versions, `(?!re)` and `(?<!re)`, which are true if the context is not present in the target string.
这两种形式都有负向版本，`(?!re)`和`(?<!re)`，即：如果内容在目标字符串中不存在为真。

**⇡New in 2.0⇣**
The \K sequence is related to backtracking. 
\K序列和**回溯**有关。
If included in a pattern, it doesn’t affect the matching process. 
如果包含在模式中，它不影响匹配进程。
However, when Ruby comes to store the entire matched string in $& or \&, it only stores the text to the right of the \K.
然而，当ruby存储整个匹配字符串在$&或\&时，它只存储\K右边的文本。

    show_regexp("thx1138", /[a-z]+\K\d+/) # => thx->1138<-

#### Controlling Backtracking 控制回溯`(?>re)``(++)`
Say you’re given the problem of searching a string for a sequence of Xs not followed by an O. 
比如说你遇到了麻烦，要查找一个字符串，带有一系列的X，但不能被O跟着。
You know that a string of Xs can be represented as X+, and you can use a lookahead to check that it isn’t followed by an O, so you code up the pattern /(X+)(?!O)/. 
你知道，X系列字符串可以表示为X+，你可以使用先行来检查是否被O所跟随，所以你写出了模式`/(X+)(?!O)/`。
Let’s try it:
让我们试一试：

    re = /(X+)(?!O)/
    # 在这个例子运行良好
    re =~ "test XXXY" # => 5
    $1                # => "XXX"
    # 但很不幸，这个不行了
    re =~ "test XXXO" # => 5
    $1                # => "XX"

Why did the second match succeed? 
为什么第二个匹配可以成功？
Well, the regular expression engine saw the X+ in the pattern and happily gobbled up all the Xs in the string. 
好吧，正则表达式引擎看到模式里的X+，因此高兴地吞下了字符串里所有的X。
It then saw the pattern (?!O), saying that it should not now be looking at an O. 
然后看到(?!O)，它说不应该现在查找O。
Unfortunately, it is looking at an O, so the match doesn’t succeed. 
不幸的是，它找到了O，所以匹配不能成功。
But the engine doesn’t give up. 
但引擎没有放弃。
No sir! 
不行！
Instead it says, “Maybe I was wrong to consume every single X in the string. Let’s try consuming one less and see what happens.”  
相反她说：“可能我销毁了字符串里每个单个的X。让我们尝试少销毁一个，看看会发生什么。“
This is called backtracking—when a match fails, the engine goes back and tries to match a different way. 
这就是**回溯 -- 当一个匹配失败了，引擎会退回，并用另一位不同的方式尝试匹配**。
In this case, by backtracking past a single character, it now finds itself looking at the last X in the string (the one before the final O). 
在这种情况下，通过回溯到一个单字符，它现在发现自身看到了字符串里的最后一个X（就是在O前面的那个）
And that X is not an O, so the negative lookahead succeeds, and the pattern matches. 
因为X不是O，所以负向先行成功了，模式匹配了。
Look carefully at the output of the previous program: there are three Xs in the first match but only two in the second.
看清楚前面程序的输出：有三个X在第一个匹配，但第二个只有2个匹配。

But this wasn’t the intent of our regexp. 
但这并不是正则表达式的意思。
Once it finds a sequence of Xs, those Xs should be locked away. 
一旦他找到一系列的X，那些X应该被锁定。
We don’t want one of them being the terminator of the pattern. 
我们不需要他们成为模式的终结。
We can get that behavior by telling Ruby not to backtrack once it finds a string of Xs. 
我们可以得到这样的行为，通过告诉ruby不要回溯，一旦找到了一个X字符。
There are a couple of ways of doing this.
有两种方式来做。

The sequence `(?>re)` nests an independent regular expression within the first regular expression. 
**`(?>re)`**序列将独立的正则表达式套入第一个正则表达式。
This expression is anchored at the current match position. 
这个表达式被锚定在当前匹配的位置。
If it consumes characters, these will no longer be available to the higher-level regular expression. 
如果它销毁了字符，对于高水平的正则表达式，这些不再有用
This construct therefore inhibits backtracking.
这个构造因此抑制了回溯。
Let’s try it with our previous code:
我们用之前的代码试一下：

    re = /((?>X+))(?!O)/
    # This one works
    re =~ "test XXXY"  # => 5
    $1                 # => "XXX"
    # Now this doesn't match
    re =~ "test XXXO" # => nil
    $1                # => nil
    # And this finds the second string of Xs
    re =~ "test XXXO XXXXY" # => 10
    $1                      # => "XXXX"

You can also control backtracking by using a third form of repetition. 
你也可以使用第三种重复的形式来控制回溯。
We’re already seen greedy repetition, such as re+, and lazy repetition, re+?. 
我们已经看到了贪婪重复，比如re+，和惰性重复re+?
The third form is called possessive. 
第三种形式名叫所有格。
 You code it using a plus sign after the repetition character. 
你使用一个加号在重复字符的后面来表示。
It behaves just like greedy repe- tition, consuming as much of the string as it can. 
他表现为贪婪重复，将尽可能多的字符串销毁。
But once consumed, that part of the string can never be reexamined by the pattern—the regular expression engine can’t backtrack past a possessive qualifier. 
但一旦销毁，字符串的那部分不再被模式重新检查 -- 正则表达式引擎不能回溯一个所有者限定符。
This means we could also write our code as this:
这意味我们也能这样写代码：

    re = /(X++)(?!O)/
    re =~ "test XXXY" # => 5
    $1 # => "XXX"
    re =~ "test XXXO" # => nil
    $1 # => nil
    re =~ "test XXXO XXXXY" # => 10
    $1 # => "XXXX"

#### Backreferences and Named Matches 反向引用和命名匹配`\n``\k'n'``\k<n>`;`(?<name>)``(?'name')``\k<name>``\k'name'`;`\g<name>``\g<n>`
Within a pattern, the sequences \n (where n is a number), \k'n', and \k<n> all refer to the n-th captured subpattern. 
模式内部，序列\n（n是数字），\k'n'，和\k<n>全部指向第n个捕获的子模式。
Thus, the expression `/(...)\1/` matches six characters with the first three characters being the same as the last three.
因此，表达式 `/(...)\1/`匹配六个字符，这六个字符的前三位和后三位一样。

Rather than refer to matches by their number, you can give them names and then refer to those names. 
除了通过数字来指向匹配，你可以给他们命名，然后用引用这些名字。
A subpattern is named using either of the syntaxes (?<name>...) or (?'name'...). 
子模式的命名可以用两种语法：(?<name>)或:(?'name')。
 You then refer to these named captures using either \k<name> or \k'name'.
然后你可以使用\k<name>或者\k'name'来指向这些命名了的捕捉

For example, the following shows different ways of matching a time range (in the form hh:mm-hh:mm) where the hour part is the same:
比如，下面显示了，匹配一个时间范围（用hh:mm-hh:mm的形式）的不同方式，小时部分是一样的。

    same = "12:15-12:45"
    differ = "12:45-13:15"
    # use numbered backreference使用编号来反向引用
    same =~ /(\d\d):\d\d-\1:\d\d/     # => 0
    differ =~ /(\d\d):\d\d-\1:\d\d/   # => nil
    # use named backreference使用命名来反向引用
    same =~ /(?<hour>\d\d):\d\d-\k<hour>:\d\d/ # => 0
    differ =~ /(?<hour>\d\d):\d\d-\k<hour>:\d\d/ # => nil

Negative backreference numbers count backward from the place they’re used, so they are relative, not absolute, numbers. 
**负向反向引用**的数字从使用它们的地方反向来数，因此他们是相对的，不是绝对的数字。
The following pattern matches four-letter palindromes (words that read the same forward and backward).
下面的模式匹配4字回文（正向和反向读起来都一样的词语）

    "abab" =~ /(.)(.)\k<-1>\k<-2>/ # => nil
    "abba" =~ /(.)(.)\k<-1>\k<-2>/ # => 0

You can invoke a named subpattern using \g<name> or \g<number>. 
你可以使用**\g<name>或者\g<number>**调用一个命名子模式
Note that this reexecutes the match in the subpattern, in contrast to \k<name>, which matches whatever is matched by the subpattern:
注意这将在子模式里面重新执行匹配，可以和\k<name>对比，后者匹配被子模式匹配的东西。
<kinder:note> 不是\k就可以调用了吗？这个\g有什么不同？

    re = /(?<color>red|green|blue) \w+ \g<color> \w+/
    re =~ "red sun blue moon" # => 0
    re =~ "red sun white moon" # => nil

You can use \g recursively, invoking a pattern within itself. 
你可以递归地使用\g，在自身里面调用模式
The following code matches a string in which braces are properly nested:
下面的代码匹配一个字符串，花括号被适当套入：

    re = /
      \A
        (?<brace_expression>
          {
            (
              [^{}]                    # anything other than braces
            |                          # ...or...
              \g<brace_expression>     # a nested brace expression
            )*
          }
        )
      \Z
    /x

We use the x option to allow us to write the expression with lots of space, which makes it easier to understand. 
使用x选项允许我们用许多空格写出表达式，让代码更易读。
We also indent it, just as we would indent Ruby code.
也可以缩进，因为我们可以缩进ruby代码。 
And we can also use Ruby-style comments to document the tricky stuff. 
我们也可以使用ruby风格的注释来记录棘手的东西。
You can read this regular expression as follows: a brace expression is an open brace, then a sequence of zero or more characters or brace expressions, and then a closing brace.
我们可以像下面说的那样读这些正则表达式：花括号表达式是一个开放的花括号，一系列的0或者更多字符或花括号表达式，之后是关闭的花括号。
<kinder:note> 说得很妙。来个例子嘛！

#### Nested Groups  嵌套分组 +n -n
The ability to invoke subpatterns recursively means that backreferences can get tricky. 
递归调用子模式的能力意味着反向引用可以更聪明。
Ruby solves this by letting you refer to a named or numbered group at a particular level of the recursion—add a +n or -n for a capture at the given level relative to the current level. 
ruby解决这个问题，通过让你指向一个命名或编号的分组在递归的特定水平上 -- 为捕获物添加一个 +n或者-n在一个相对当前水平的给定水平上。

Here’s an example from the Oniguruma cheat sheet. 
这是一个例子，来自Oniguruma cheat sheet
It matches palindromes:
它匹配回文：

    /\A(?<a>|.|(?:(?<b>.)\g<a>\k<b+0>))\z/

That’s pretty hard to read, so let’s spread it out:
那相当难读，让我们把他展开来：

    # tut_regexp/palindrome_re.rb
    palindrome_matcher = /
    \A                     # 字符串的开头
      (?<palindrome>       # nothing, or
      | \w                 # a single character, or
      | (?:                # x <palindrome> x
        (?<some_letter>\w)       # 回文的前面部分
          \g<palindrome>         # 递归调用子模式。
          \k<some_letter+0>      # 回文的后面部分，+0指定了什么水平？
        )
      )
    \z                     # 字符串的结尾
    /x                     # 扩展模式
    palindrome_matcher.match "madam" # => madam
    palindrome_matcher.match "m" # => m
    palindrome_matcher.match "adam" # =>

A palindrome is an empty string, a string containing a single character, or a character followed by a palindrome, followed by that same character. 
回文是一个空白字符串，一个字符串包括一个字符，或一个字符被一个回文跟着，被相同的字符所跟随。
The notation `\k<some_letter+0>` means that the letter matched at the end of the inner palindrome will be the same letter that was at the start of it. 
符号`\k<some_letter+0>`意味着在内部回文的最后匹配的字母，将是和开头的那个相同的字母。<kinder:note>迷迷糊糊，不能理解 
Inside the nesting, however, a different letter may wrap the interior palindrome.
在嵌套里面，不同的字母可能包装着内部回文。
<kinder:note> 看得迷迷糊糊了。

#### Conditional Groups  有条件分组`(?(n)subpattern)``(?(<name>)subpattern)``(?('name')subpattern)``
⇡New in 2.0⇣
Just because it’s all been so easy so far, Onigmo adds a new twist to regular expressions—conditional subexpressions.
只因为这太简单了，Onigmo添加了一个新的手法到正则表达式中 -- 条件子表达式
Say you were validating a list of banquet attendees:
比如你在验证一个宴会出席者的清单：

    Mr Jones and Sally
    Mr Bond and Ms Moneypenny
    Samson and Delilah
    Dr Jekyll and himself
    Ms Hinky Smith and Ms Jones
    Dr Wood and Mrs Wood
    Thelma and Louise

The rule is that if the first person in the list has a title, then so should the second. 
规则是：如果列表中的第一个人有头衔，则第二个也是这样。
This means that the first and fourth lines in this list are invalid.
这意味着列表中的第一和第四行是无效的。

**第一步**
We can start with a pattern to match a line with an optional title and a name. 
我们可以用一个模式开始，来匹配一行，带有可选头衔和一个名字。
We know we’ve reached the end of the name when we find the word and with spaces around it.
我们知道我们已经到达名字的最后，然后发现了词语，两边都是空格。

    re = %r{ (?:(Mrs | Mr | Ms | Dr )\s)? (.*?) \s and \s }x
    "Mr Bond and Ms Monneypenny" =~ re # => 0
    [ $1, $2 ]                         # => ["Mr", "Bond"]
    "Samson and Delilah" =~ re         # => 0
    [ $1, $2 ]                         # => [nil, "Samson"]

We’ve defined the regexp with the x (extended) option so we can include whitespace. 
我们已经用x（扩展）选项定义了正则表达式，因此我们能包含空白符。
We also used the ?: modifier on the group that defines the optional title followed by a space. 
我们也使用`?:`修饰符，在分组，定义可选头衔被空格跟随。
 This stops that group getting captured into $1. 
这将阻止分组被捕获进$1。
<kinder:note> 为什么要阻止？
We do however capture just the title part.
我们只需要捕获头衔部分。

**第二步**
So now we need to match the second name. We can start with the same code as for the first.
所以，现在我们需要匹配第二个名字。我们可以用和第一个一样的代码来处理。

    re = %r{
      (?:(Mrs | Mr | Ms | Dr )\s)? (.*?)
      \s and \s
      (?:(Mrs | Mr | Ms | Dr )\s)? (.+)
    }x
    "Mr Bond and Ms Monneypenny" =~ re # => 0
    [ $1, $2, $3, $4 ]                 # => ["Mr", "Bond", "Ms", "Monneypenny"]
    "Samson and Delilah" =~ re         # => 0
    [ $1, $2, $3, $4 ]                 # => [nil, "Samson", nil, "Delilah"]

Before we go any further, let’s clean up the duplication using a named group:
在我们走得更远之前，让我们使用命名分组来清理副本。

    re = %r{
      (?:(?<title>Mrs | Mr | Ms | Dr )\s)? (.*?)
      \s and \s
      (\g<title>\s)? (.+)
    }x
    re.match("Mr Bond and Ms Monneypenny") # => #<MatchData "Mr Bond and Ms
                                           # .. Monneypenny" title:"Ms">
    re.match("Samson and Delilah")
                                           # => #<MatchData "Samson and Delilah"
                                           # .. title:nil>

But this code also matches a line where the first name has a title and the second doesn’t:
但这个代码也匹配、第一个名字有一个头衔，第二个名字没有头衔的行。

    re = %r{
      (?:(?<title>Mrs | Mr | Ms | Dr )\s)? (.*?)
      \s and \s
      (\g<title>\s)? (.+)
    }x
    re.match("Mr Smith and Sally") # => #<MatchData "Mr Smith and Sally" title:"Mr">

**第三步 条件子模式**
We need to make the second test for a title mandatory if the first test matches. 
如果第一个测试已经匹配，我们需要强制进行第二个头衔测试。
That’s where the conditional subpatterns come in.
这就是条件子模式出现的地方。

The syntax (?(n)subpattern) will apply the subpattern match only if a previous group number n also matched. 
语法(?(n)subpattern)将应用子模式匹配，一旦前n组已经匹配。
You can also test named groups using the syntaxes (?(<name>)subpattern) or (?('name')subpattern).
你也可以测试命名分组使用语法(?(<name>)subpattern)或者(?('name')subpattern)。

In our case, we want to apply a test for the second title if the first title is present. 
在我们的案例中，如果第一个头衔存在，我们要对第二个头衔应用一个测试。
That first title is matched by the group named title, so the condition group looks like `(?<title>...)`:
第一个头衔通过命名为title的分组进行匹配，所以条件分组应该是`(?<title>...)`：

    re = %r{
      (?:(?<title>Mrs | Mr | Ms | Dr )\s)? (.*?)
      \s and \s
      (?(<title>)\g<title>\s) (.+)   # 如果(<title>)成功，则强制测试\g<title>\s
    }x
    re.match("Mr Smith and Sally") # => #<MatchData "Mr Smith and Sally" title:nil>

This didn’t work—the match succeeded when we expected it to fail. 
运行错误。我们希望它失败时，它成功了。
That’s because the regular expression applied backtracking. 
这是因为正则表达式应用了回溯。
It matched the optional first name, the and, and then was told to match a second title (because group 1 matched the first). 
她匹配了可选的第一个名字和and，卷后被告知去匹配第二个头衔（因为1分组匹配了第一个）
There’s no second title, so the match failed. 
没有第二个，所以匹配失败了。
But rather than stopping, the engine went back to explore alternatives.
但它没有停下来，引擎返回浏览可选方案。

**第四步 控制回溯**
It noticed that the first title was optional, and so it tried matching the whole pattern again, this time skipping the title. 
它注意到第一个头衔是可选的，所以它尝试再次匹配整个模式，这回它跳过了头衔。
<kinder:note> “第一个头衔是可选的”？这从何说起啊！`(?:)`表达可选的意思吗？
It successfully matched Mr Smith using the `(.*?)` group, and matched Sally with the second name group. 
他使用`(.*?)`分组成功匹配了Mr Smith，然后匹配用第二个名字分组匹配了Sally。
<kinder:note> `(.*?)`分组不是只能匹配Mr吗？
So we want to tell it never to backtrack over the first name—once it has found a title there, it has to use it. 
所以我们想告诉它不要回溯第一个名字，一旦它发现了那里的一个头衔，它只能使用它。

    (?>...) to the rescue:
    re = %r{
      ^(?>                            # <kinder:note> 对这个大分组关闭回溯。^符号代表开头
      (?:(?<title>Mrs | Mr | Ms | Dr )\s)? (.*?)
      \s and \s
      )
      (?(<title>)\g<title>\s) (.+)
    }x
    re.match("Mr Smith and Sally")    #  => nil
    re.match("Mr Smith and Ms Sally") #  => #<MatchData "Mr Smith and Ms Sally"
                                      #  .. title:"Ms">

The match failed, as we expected, but when we add a title to Sally, it succeeds.
正如我们期待的那样，匹配失败了，但我们增加了一个头衔给Sally，匹配成功。
Let’s try this on our list:
让我们在列表中尝试这个代码：

    DATA.each do |line|
      re = %r{ ^(?>
                  (?:(?<title>Mrs | Mr | Ms | Dr )\s)? (.*?) \s and \s
                )
                  (?(<title>)\g<title>\s) (.+)
          }x
      if line =~ re
        print "VALID: "
      else
        print "INVALID: "
      end
      puts line
    end
    __END__
    Mr Jones and Sally
    Mr Bond and Ms Moneypenny
    Samson and Delilah
    Dr Jekyll and himself
    Ms Hinky Smith and Ms Jones
    Dr Wood and Mrs Wood
    Thelma and Louise
    # produces:
    # INVALID: Mr Jones and Sally
    # VALID:   Mr Bond and Ms Moneypenny
    # VALID:   Samson and Delilah
    # INVALID: Dr Jekyll and himself
    # VALID:   Ms Hinky Smith and Ms Jones
    # VALID:   Dr Wood and Mrs Wood
    # VALID:   Thelma and Louise

#### Alternatives in Conditions 条件轮换 `(?(group_id) true-pattern | fail-pattern)`
Being British, I have a national duty to emulate my compatriates on informercials and shout “But Wait! There’s More!”
在英国，我有国家性义务来效仿我的同胞在商业信息上，并大喊“等一等，还有更多”
Conditional subpatterns can also have an else clause.
条件子模式也可以有子句。

    (?(group_id) true-pattern | fail-pattern )

If the identified group was previously matched, the true pattern is applied. 
如果标识分组前面已经被匹配，true-模式就可被应用。
If it failed, the fail pattern is applied.
如果失败了，fail-模式可被应用。

Here’s a regular expression that deals with red or blue balls or buckets. 
这是一个正则表达式，处理red或blue的balls或buckets。
The deal is that the colors of the ball and bucket must be different.
要处理的是ball和bucket的颜色必须是不同的。

    re = %r{(?:(red)|blue) ball and (?(1)blue|red) bucket}      #前面的?:可以删除吗？
    re.match("red ball and blue bucket") # => #<MatchData "red ball and blue bucket"
                                         # .. 1:"red">
    re.match("blue ball and red bucket") # => #<MatchData "blue ball and red bucket"
                                          # .. 1:nil>
    re.match("blue ball and blue bucket") #=> nil

If the first group, the red alternative, matched, then the conditional subpattern is blue, otherwise it is red.
如果第一分组匹配的是red，则条件性子模式就是blue，否则是red

#### Named Subroutines  命名子程序 {0}
There’s a trick that allows us to write subroutines inside regular expressions. 
有一个秘诀允许我们在正则表达式里写出子程序。
Recall that we can invoke a named group using \g<name>, and we define the group using (?<name>...).
想想我们能使用\g<name>调用一个命名分组，我们使用(?<name>...)定义一个分组。

Normally, the definition of the group is itself matched as part of executing the pattern.
正常情况下，分组的定义是自身匹配作为执行模式的一部分。
However, if you add the suffix {0} to the group, it means “zero matches of this group,” so the group is not executed when first encountered:
然而，如果你增加了后缀{0}给分组，它意味着“这个分组的0次匹配”，所以分组在第一个遇到的时候不会执行。

    sentence = %r{
      (?<subject>     cat   | dog   | gerbil   ){0}     #这些分组起到了声明的作用！
      (?<verb>        eats  | drinks| generates){0}
      (?<object>      water | bones | PDFs     ){0}
      (?<adjective>   big   | small | smelly   ){0}
      (?<opt_adj>     (\g<adjective>\s)?       ){0}
      The\s\g<opt_adj>\g<subject>\s\g<verb>\s\g<opt_adj>\g<object>
    }x
    md = sentence.match("The cat drinks water")
    puts "The subject is #{md[:subject]} and the verb is #{md[:verb]}"
    md = sentence.match("The big dog eats smelly bones")
    puts "The last adjective in the second sentence is #{md[:adjective]}"
    sentence =~ "The gerbil generates big PDFs"
    puts "And the object in the last sentence is #{$~[:object]}"
    # produces:
    # The subject is cat and the verb is drinks
    # The last adjective in the second sentence is smelly
    # And the object in the last sentence is PDFs

#### Setting Options 设置选项 `(?option)``(?-option)`
⇡New in 2.0⇣
We saw earlier that you can control the characters matched by \b, \d, \s, and \w (along with their negations). 
我们之前看到，你可以通过\b, \d, \s和\w(连同他们的否定形式)来控制字符匹配。
To do that, we embedded a sequence such as (?u) in our pattern. 
要那样做，我们在我们匹配中嵌入一个系列，例如(?u)。
That sequence sets an option inside the regular expression engine.
序列设置一个选项在正则表达式引擎的内部。

We also saw at the start of this chapter that you can add one or more of the options i (case insensitive), m (multiline), and x (allow spaces) to the end of a regular expression literal. 
我们也看到在本章的开头，可以添加一个或多个选项i(大小写不敏感)m(多行)x(允许空格)到正则表达式字面量的结尾。
You can also set these options within the pattern itself. 
你也可以设置这些选项在模式自身内部。
As you’d expect, they are set using (?i), (?m), and (?x). 
正如你所期待，使用(?i)(?m)和(?x)来设置。
You can also put a minus sign in front of these three options to disable them. 
你也可放一个负号在三种选项的前面了关闭这些选项。

(?adimux)     Turns on the corresponding option. If used inside a group, the effect is limited to that group.
              启动相应的选项。如果使用了分组里面，效果则限定在分组范围内。
(?-imx)        Turns off the i, m, or x option.
               关闭imx选项。
(?adimux:re)   Turns on the option for re.
               为re分组开启这些选项。
(?-imx:re)     Turns off the option for re.
               为re分组关闭这些选项。

## 7.5 \z
So, that’s it. 
就是这样。
If you’ve made it this far, consider yourself a regular expression ninja. 
如果你已经来到这里，你已经是个正则表达式高手了。
Get out there and match some strings.
出来吧，匹配一下字符串。

# 　第6章　关于方法的更多细节
## 　　6.1　定义一个方法
### 概述
关键字def，
方法名以小写字母开头。如果使用大写字母，ruby可能会当作常数。
表示查询的以？结尾。
会直接修改接收者的，以！结尾。
可以被赋值的，以=结尾。

形参argument，方法后面用括号中列出的局部变量。
实参parameter。ruby可以指定默认值。

    def cool_dude(arg1="Miles", arg2="Coltrane", arg3="Roach")
      "#{arg1}, #{arg2}, #{arg3}."
    end
    cool_dude                                → "Miles, Coltrane, Roach."
    cool_dude("Bart")                        → "Bart, Coltrane, Roach."
    cool_dude("Bart", "Elwood")              → "Bart, Elwood, Roach."
    cool_dude("Bart", "Elwood", "Linus")     → "Bart, Elwood, Linus."

方法体内是普通的ruby表达式，不能在方法内定义非单件类或模块。
如果一个方法内定义另一个方法，内部的方法只有在外部方法执行时才得到定义。

方法的返回值是执行的最后一个表达式的值，或者是return表达式显式返回的值。

### 6.1.1 可变长度的参数列表
如果你想希望传入可变个数的实参，或者想用一个形参接收多个参数，可以在普通参数名字前面放置一个星号`*`。
<kinder:note> 星号意味者最后一个参数是个数列。

    def varargs(arg1, *rest)
      "Got #{arg1} and #{rest.join(', ')}"
    end
    varargs("one")                   → "Got one and "
    varargs("one", "two")            → "Got one and two"
    varargs "one", "two", "three"    → "Got one and two, three"

### 6.1.2 方法和block
正如在前面4.2节“Block与迭代器”所说的：
调用一个方法时，可以用一个block与之相关，通常在方法内使用yield调用这个block。
不过，如果定义方法的最后一个参数前缀`&`，则关联的block会被转换为一个Proc对象，然后赋值给这个参数。

    class TaxCalculator
      def initialize(name, &block)
        @name, @block = name, block
      end
      def get_tax(amount)
        "#@name on #{amount} = #{ @block.call(amount) }" # 为什么不把代码写死一些？灵活得让人受不了。呵呵。
      end
    end
    tc = TaxCalculator.new("Sales tax") {|amt| amt * 0.075 }
    tc.get_tax(100) → "Sales tax on 100 = 7.5"
    tc.get_tax(250) → "Sales tax on 250 = 18.75"

##     6.2    调用方法
可以通过指定接收者、方法名称、可选参数和block，来调用一个方法。
对类方法和模块方法来说，接收者是类和模块的名字。
如果省略了接收者，默认为self，也就是当前对象。

    self.class    → Object  # class是一个关键字，单独使用会产生语法错误。
    self.frozen?  → false
    frozen?       → false
    self.id       → 967900
    id            → 967900

ruby正是用这种默认机制实现私有方法调用的。我们无法调用某个接收者对象的私有方法，它们只在当前对象self中是可用的。

可选参数紧跟随在方法名之后（中间不应该空格）。如果没有歧义，可以省略参数两侧的括号。

### 6.2.1 方法返回值
每个被调用的方法都会返回一个值，尽管没有规定说你必须使用这个值。
方法的值，是方法执行中最后一个语句执行的结果。
如果返回多个参数，方法会将它们以数组的形式返回。你可以使用并行赋值来收集返回值。
例子：

    def meth_one
      "one"
    end
    meth_one → "one"

    def meth_two(arg)
      case
      when arg > 0
        "positive"
      when arg < 0
        "negative"
      else
        "zero"
      end
    end
    meth_two(23)  → "positive"
    meth_two(0)   → "zero"

    def meth_three
      100.times do |num|     # 从0开始循环，直到99
        square = num*num
        return num, square if square > 1000    # 到了32×32=1024，符合了大于1000的条件，于是return。
      end
    end
    meth_three → [32, 1024]         # <kinder:note> 32是哪里来的？
    num, square = meth_three        # 并行赋值
    num → 32
    square → 1024

**在方法调用中的数组展开**

    def five(a, b, c, d, e)
      "I was passed #{a} #{b} #{c} #{d} #{e}"
    end
    five(1, 2, 3, 4, 5 )          → "I was passed 1 2 3 4 5"
    five(1, 2, 3, *['a', 'b'])    → "I was passed 1 2 3 a b"    # 这个需要很在意。去掉数组前面的星号就会报错了。
    five(*(10..14).to_a)          → "I was passed 10 11 12 13 14"

**让block更加动态**
有时你希望教授一些算法技法，学生可能想要一个n次相加或相乘的表。

    print "(t)imes or (p)lus: "
    times = gets
    print "number: "
    number = Integer(gets)
    if times =~ /^t/
      calc = lambda {|n| n*number }
    else
      calc = lambda {|n| n+number }
    end
    puts((1..10).collect(&calc).join(", "))
    # produces:
    # (t)imes or (p)lus: t
    # number: 2
    # 2, 4, 6, 8, 10, 12, 14, 16, 18, 20

当然你可以采用下面的写法，但那样会丑陋一些：

    print "(t)imes or (p)lus: "
    times = gets
    print "number: "
    number = Integer(gets)
    if times =~ /^t/
      puts((1..10).collect {|n| n*number }.join(", "))
    else
      puts((1..10).collect {|n| n+number }.join(", "))
    end
    # produces:
    # (t)imes or (p)lus: t
    # number: 2
    # 2, 4, 6, 8, 10, 12, 14, 16, 18, 20

<kinder:note> 看起来得复习前面的lambda了。
**收集散列参数**

    class SongList
      def create_search(name, params)  # 第一个参数是搜索名，第二个是散列
        # ...
      end
    end
    list.create_search("short jazz songs",
                      {
                      'genre'              => "jazz",
                      'duration_less_than' => 270
                      })

使用散列表意味着我们可以模拟关键字：查询类别为“爵士乐”，且时长小于4分半的歌曲。
不过，这种方式有些笨重，而且一组大括号容易被写成一个和方法关联的block。因此ruby提供了一种快捷方式：
只要在参数列表中，**散列数组位于正常参数之后，并位于任何数组或block参数之前**，就可以使用`key => value`对。这些对儿会被集合到一个散列数组中，并作为方法的一个参数传入，因此无需大括号。

    list.create_search("short jazz songs",
                      'genre'              => "jazz",
                      'duration_less_than' => 270
                      )

最后，你可以使用符号而非字符串作为参数。符号清楚表达你所引用的某个事物的名字：

    list.create_search("short jazz songs",
                      :genre              => :jazz,
                      :duration_less_than => 270
                      )

**关键字参数列表 Keyword Argument Lists**    ⇡New in 2.0⇣
Let’s look inside our search method. 
让我们看看搜索方法的内部。
It gets passed a field name and an options hash. 
它得到传给的一个字段名和一个可选的散列表。
Maybe we want to default the duration to 120 seconds, and validate that no invalid options are passed. 
可能我们想默认120秒的间隔，验证没有无效选项被传递。
Pre Ruby 2.0, the code would look something like:
在ruby2之前，代码看起来应该像这样：

    def search(field, options)
      options = { duration: 120 }.merge(options)
      if options.has_key?(:duration)
        duration = options[:duration]
        options.delete(:duration)
      end
      if options.has_key?(:genre)
        genre = options[:genre]
        options.delete(:genre)
      end
      fail "Invalid options: #{options.keys.join(', ')}" unless options.empty?
      # rest of method
    end

Do this enough times, and you end up writting a helper function to validate and extract hash parameters to methods.
足够的次数来做，你可以写一个辅助函数来验证和解压散列表参数到方法中。

Ruby 2 to the rescue. 
ruby2有救援招数。
You can now define keyword arguments to your methods. 
你现在可以定义关键词参数到方法了。
You still pass in the hash, but Ruby now matches the hash contents to your keyword argument list. 
你还是传入散列表，但ruby现在匹配散列表的内容到你的关键词参数列表了。
It also validates that you don’t pass in any unknown arguments.
它也验证了你不传入任何未知参数。

    def search(field, genre: nil, duration: 120)
      p [field, genre, duration ]
    end
    search(:title)
    search(:title, duration: 432)
    search(:title, duration: 432, genre: "jazz")
    # produces:
    # [:title, nil, 120]
    # [:title, nil, 432]
    # [:title, "jazz", 432]

Pass in an invalid option, and Ruby complains:
传入一个未验证的选项，ruby会解释：

    def search(field, genre: nil, duration: 120)
      p [field, genre, duration ]
    end
    search(:title, duraton: 432)  # duration被写成duraton
    # produces:
    # prog.rb:5:in `<main>': unknown keyword: duraton (ArgumentError)

You can collect these extra hash arguments as a hash parameter—just prefix one element of your argument list with two asterisks (a double splat).
你可以收集这些额外的散列表参数作为一个散列表参数 -- 只需要用**两个星号**前缀你的参数的一个元素。

    def search(field, genre: nil, duration: 120, **rest)  # rest就是前缀了双星号。
      p [field, genre, duration, rest ]
    end
    search(:title, duration: 432, stars: 3, genre: "jazz", tempo: "slow")
    # produces:
    # [:title, "jazz", 432, {:stars=>3, :tempo=>"slow"}]

And, just to prove that all we’re passing in is a hash, here’s the same calling sequence:
而且，只需要证明，所有我们传入的是一个散列表，这里就会出现同样的调用序列：

    def search(field, genre: nil, duration: 120, **rest)
      p [field, genre, duration, rest ]
    end
    options = { duration: 432, stars: 3, genre: "jazz", tempo: "slow" }  # 将第二个和之后的参数放在一个散列表中。
    search(:title, options)
    # produces:
    # [:title, "jazz", 432, {:stars=>3, :tempo=>"slow"}]    结果是和上例一样。太灵活了！

A well-written Ruby program will typically contain many methods, each quite small, so it’s worth getting familiar with the options available when defining and using them. 
一个潜心编写的ruby程序通常包括许多方法，每个都很短小。因此在定义和使用他们时，熟悉有用的选项是非常值得的。
At some point you’ll probably want to read Method Arguments, on page 324 to see exactly how arguments in a method call get mapped to the method’s formal parameters when you have combinations of default parameters and splat parameters.
在一些点上，你将可能想阅读方法参数，在324页22章中方法定义一节，可以更准确的看到方法里的形参怎么被映射到方法外面的实参，当你联合了默认实参和带星参数的时候。

# 　第7章　表达式   <kinder:note> 4版为第九章
Ruby和其他语言一个不同之处就是任何东西都能返回一个值：几乎所有东西都是表达式。
## 好处：

1. 实现链式语句

    a = b = c = 0                   #  0
    [ 3, 1, 7, 0 ].sort.reverse     #  [7, 3, 1, 0]

2. C和Java中的普通语句也是表达式，例如if和case，详见后面7.4条件执行。

    song_type = if song.mp3_type == MP3::Jazz           # 这种用条件控制赋值的写法太酷了。
                  if song.written < Date.new(1935, 1, 1)
                    Song::TradJazz
                  else
                    Song::Jazz
                  end
                else
                  Song::Other
                end
    rating = case votes_cast
             when 0...10 then Rating::SkipThisOne
             when 10...50 then Rating::CouldDoBetter
             else Rating::Rave
             end

## 　　7.1　运算符表达式
运算符和优先级的完整列表：

    方法  操作符                       描述
    是    [ ] [ ]=                     引用元素
    是    **                           求幂
    是    ! ~ + -                      非、求补、一元加、一元减（最后两个的方法名为+@ -@）
    是    * / %                        乘、除、求模
    是    + -                          加减
    是    >> <<                        右移、左移
    是    &                            “与”（对整数是一位一位的操作）
    是    ^ |                          异或、或（对整数是一位一位的操作）
    是    <= < > >=                    比较操作
    是    <=> == === != =~ !~          等于和模式匹配操作符（!=和!~可能不是作为方法定义的）
          &&                           逻辑“与”
          ||                           逻辑“或”
          .. ...                       Range（包含右边界和不包含右边界）
          ? :                          三元运算符（if~then~else）
          = %= ~= /= -= += |= &=       赋值运算符
          >>= <<= *= &&= ||= **=
          defined?                     检查符号是否被定义  
          not                          逻辑非
          or and                       逻辑比较
          if unless while until        表达式修饰符
          begin/end                    Block表达式

实际上，ruby的许多运算符是由方法调用来实现的。
因为任何东西都是对象，你可以**重新定义实例方法**，重新定义任何不满足你需求的基本算数方法。

    class Fixnum
      alias old_plus +
      # Redefine addition of Fixnums. This  重新定义Fixnums的加法，这可是个坏注意。
      # is a BAD IDEA!
      def +(other)
        old_plus(other).succ     # succ是整数的方法，表示加一
      end
    end
    1 + 2         → 4
    a = 3         
    a += 4        → 8  就是： 3+4 +1
    a + a + a     → 26  就是： 8 +8+1 +8+1

更有用的是，你写的类可以**像内建对象那样参与到运算符表达式中**。
例子一：你可能想从歌曲中间剪辑一段，这可以用索引操作符[]来实现。

    class Song
      def [](from_time, to_time)                       #增加了一个方法。
        result = Song.new(self.title + " [extract]",
                          self.artist,
                          to_time - from_time)
        result.set_start_time(from_time)
        result
      end
    end
    song[10, 15].paly

例子二：<kinder:note> 来自第四版
the left shift operator, `<<`, is often used to mean append to receiver. Arrays support this:
左移操作符`<<`，经常用于在接受者后面添加对象。数组支持这个：

    a = [ 1, 2, 3 ]
    a << 4      # => [1, 2, 3, 4]

You can add similar support to your classes:
你可以添加类似的支持到你的类中：

    class ScoreKeeper
      def initialize
        @total_score = @count = 0
      end
      def <<(score)
        @total_score += score
        @count += 1
        self
      end
      def average
        fail "No scores" if @count.zero?   #<kinder:note> fail在这里是什么意思？
        Float(@total_score) / @count
      end
    end
    scores = ScoreKeeper.new
    scores << 10 << 20 << 40
    puts "Average = #{scores.average}"
    # produces:
    # Average = 23.333333333333332

Note that there’s a subtlety in this code—the `<<` method explicitly returns self. 
注意代码中微妙的地方 -- `<<`方法明确地返回自身。
It does this to allow the method chaining in the line scores `<< 10 << 20 << 40`. 
它做这个，允许方法将一行`<< 10 << 20 << 40`得分链起来。
Because each call to `<<` returns the scores object, you can then call `<<` again, passing in a new score.
因为每个调用`<<`返回score对象，你可以再次调用`<<`，传递一个新的score。
As well as the obvious operators, such as `+`, `*`, and `<<`, indexing using square brackets is also implemented as a method call. 
和显式操作符一样，比如`+`, `*`, 和`<<` 使用方括号索引也可以用方法调用来实现。
When you write this:
当你写这些：

    some_obj[1,2,3]

you’re actually calling a method named [] on `some_obj`, passing it three parameters. 
你实际上调用一个对象的[]方法，并将3个参数传递给它。
You’d define this method using this:
你已经使用这个来定义一个方法

    class SomeClass
      def [](p1, p2, p3)
        # ...
      end
    end

Similarly, assignment to an element is implemented using the []= method. 
类似的，赋值一个元素可以使用[]=方法来完成。
This method receives each object passed as an index as its first n parameters and the value of the assignment as its last parameter:
这个方法接受每个传递过来的对象，当索引作为它的第一个n参数，所赋的值作为它的最后一个参数。

    class SomeClass
      def []=(*params)
        value = params.pop
        puts "Indexed with #{params.join(', ')}"
        puts "value = #{value.inspect}"
      end
    end
    s = SomeClass.new
    s[1] = 2
    s['cat', 'dog'] = 'enemies'
    # produces:
    # Indexed with 1
    # value = 2
    # Indexed with cat, dog
    # value = "enemies"

## 　　7.2　表达式之杂项
### 7.2.1 命令展开
如果你用反引号（`）或者以`%x`为前缀的分界形式，括起一个字符串，默认会被当作底层操作系统命令来执行。该命令的标准输出是表达式的返回值。
由于没有取出新行符，返回值结尾可能包含回车符或者换行符。

    `date`                  → "Thu Aug 26 22:36:31 CDT 2004\n"
    `ls`.split[34]          → "book.out"
    %x{echo "Hello there"}  → "Hello there\n"

在命令字符串中使用表达式展开和所有普通的转义序列。

    for i in 0..3
      status = `dbmanager status id=#{i}`  #<kinder:note> dbmanager是什么东西？
      # ...
    end

命令的退出状态保存在全局变量$?中。
**重新定义反引号**
反引号括起的字符默认当作命令来执行。实际上，字符串是给传递给了名为Kernel.`的方法。

    alias old_backquote `
    def `(cmd)
      result = old_backquote(cmd)
      if $? != 0
        fail "Command #{cmd} failed: #$?"
      end
      result
    end
    print `date`
    print `data`
    produces:
    Thu Aug 26 22:36:31 CDT 2004
    prog.rb:10: command not found: data
    prog.rb:5:in ``': Command data failed: 32512 (RuntimeError) from prog.rb:10

## 　　7.3　赋值
赋值语句将左侧的变量或者属性设置为右侧的值，然后返回该值，作为表达式的结果。
这意味着可以**链接赋值语句**，并可在某些特殊的地方执行赋值操作。

    a = b = 1 + 2 + 3
    a                 → 6
    b                 → 6
    a = (b = 1 + 2) + 3
    a → 6
    b → 3
    File.open(name = gets.chomp)

赋值语句有**两种基本形式**。
第一种，将一个对象引用赋值给变量或者常量。这种形式是直接执行的。

    instrument = "piano"
    MIDDLE_A   = 440

第二种，等号左边是对象属性或者元素的引用。

    song.duration     = 234
    instrument["ano"] = "ccolo"

这是通过左值的方式来实现的，这意味着你可以**重载**他们：只要简单地定义一个以等号为结尾的方法即可。

    class Song
      def duration=(new_duration)
        @duration = new_duration
      end
    end

下面是第四版的例子：

    class ProjectList
      def initialize
        @projects = []
      end
      def projects=(list)                # 定义数组赋值方法
        @projects = list.map(&:upcase)   # store list of names in uppercase 存储大写名字列表。这里使用一个proc来处理每个元素的转换。
      end
      def [](offset)
        @projects[offset]
      end
    end
    list = ProjectList.new
    list.projects = %w{ strip sand prime sand paint sand paint rub paint }
    list[3] # => "SAND"
    list[4] # => "PAINT"

这种设置属性的方法**不必和内部的实例变量相对应**，并且具有赋值方法的属性也**并非必须要有读取该属性的方法**。

    class Amplifier
      def volume=(new_volume)
        self.left_channel = self.right_channel = new_volume   
        # 为什么使用self.left_channel？因为如果不是类方法，而是实例方法，则会出现下面的“可写属性有个隐藏的陷阱”。
      end
    end

可写属性的陷阱：
通常，类中的方法可以通过函数形式（即带有一个隐式self作为接受者）调用同一个类的其他方法和它的父类的方法。
然而，这不适用于属性赋值函数：ruby看到赋值语句时，会认为左边的名字是局部变量，而不是一个为属性赋值的方法调用。

    class BrokenAmplifier
      attr_accessor :left_channel, :right_channel
      def volume=(vol)
        left_channel = self.right_channel = vol
      end
    end
    ba = BrokenAmplifier.new
    ba.left_channel = ba.right_channel = 99    # 将两个变量设置为99
    ba.volume = 5                              # 将两个变量设置为5，但ruby会把这一句的volume当作局部变量，而不是调用volume=(vol)方法
    ba.left_channel # 99                       # 所以不成功
    ba.right_channel # 5

**赋值语句的值总是参数的值**，而方法的返回值会被丢掉。1.8版之前则会返回方法的返回值。

    class Test
      def val=(val)
        @val = val
        return 99
      end
    end
    t = Test.new
    a = t.val = 2
    a → 2

### 7.3.1 并行赋值
赋值实际上是以并行方式执行的，所以赋值语句右边的值不受赋值语句本身的影响。左边的任意一个变量或属性在赋值之前，右边的值按出现的顺序被计算出来。

    x = 0
    a, b, c = x, (x+1), (x+2) # [0 1 2]
    a, b = b, a               # 1 0

**不对称赋值**
赋值语句仅有一个左值，多个右值，则右值将被转化为数组，赋值给左值。
赋值语句左值多于一个时，表达式将返回由右值组成的数组。
如果左值多于右值，多余的左值将被忽略。
如果右值多于左值，额外的右值将被忽略。

**叠起和展开数组** Splats and Assignment
如果左值有一个`*`前缀，则所有多余的右值将被集合在一起，作为一个数组赋给左值。
如果最后一个右值是一个数组，可以在前面加一个`*`前缀，会被适当地展开成元素的值。

    a = [1, 2, 3, 4]
    b, c =  a       # b == 1,  c == 2
    b, *c = a       # b == 1,  c == [2, 3, 4]
    b, c =  99, a   # b == 99, c == [1, 2, 3, 4]
    b, *c = 99, a   # b == 99, c == [[1, 2, 3, 4]]
    b, c =  99, *a  # b == 99, c == 1
    b, *c = 99, *a  # b == 99, c == [1, 2, 3, 4]

**嵌套赋值**
赋值语句的左边可以含有一个由括号括起来的变量列表。
在处理更高层级的赋值语句之前，ruby会提取**对应的右值**，并赋值给括起来的变量。

    b, (c, d), e = 1,2,3,4      # b == 1, c == 2, d == nil,    e == 3
    b, (c, d), e = [1,2,3,4]    # b == 1, c == 2, d == nil,    e == 3
    b, (c, d), e = 1,[2,3],4    # b == 1, c == 2, d == 3,      e == 4
    b, (c, d), e = 1,[2,3,4],5  # b == 1, c == 2, d == 3,      e == 5
    b, (c,*d), e = 1,[2,3,4],5  # b == 1, c == 2, d == [3, 4], e == 5

### 7.3.2 赋值语句的其他形式
前置加 a += 2  等同于 a = a + 2
前置减 a -= 2  等同于 a = a - 2
内部处理时，第一种形式会先转化为第一种形式。这意味在你自己类中作为方法定义的操作符，和你预期的效果是一样的。

    lass Bowdlerize
      def initialize(string)
        @value = string.gsub(/[aeiou]/, '*')
      end
      def +(other)
        Bowdlerize.new(self.to_s + other.to_s)
      end
      def to_s
        @value
      end
    end
    a = Bowdlerize.new("damn ")  # d*mn
    a += "shame"                 # d*mn sh*m*

注意：ruby不支持C或者Java中的`++`（自加）和`--`（自减），可以用`+=`和`-=`替代。

## 　　7.4　条件执行
### 7.4.1 布尔表达式
**真值和假值**
任何不是nil或者false的值都是真值。
ruby库程序经常利用这一事实。例如IO#gets方法返回文件的下一行，遇到文件尾部返回nil。
但C、C++、Perl程序员可能会落入陷阱：数字0不被解释为假值，长度为0的字符串也不是假值。
**Defined?、与、或、非**
ruby支持所有的标准布尔操作符，并引入了一个新的操作符defined?。

and和&&仅当两个操作数都为真时结果才为真。
并且仅当第一个操作数为真时才求解第二个操作数的值（这称为短路求解，shortcircuit evaluation）
这两种形式的唯一区别在于优先级不同（and低于&&）

同样，如果一个操作数为真，那么or和||的结果为真。
仅当第一个操作数为假时才求解第二个操作数。
or的优先级低于||

and和or有相同的优先级，而&&高于||

not和！返回它们操作数的相反数（如果操作数为真，则返回假；如果操作数为假，则返回真）
not的优先级低于！

如果任意表达式未被定义，defined?操作符返回nil；否则返回对参数的描述。
如果参数yield，而且有一个block和当前上下文想关联，那么返回defined?返回字符串yield。
**比较方法**
`= === <=> =~ eql? equal`
除了`<=>`，其他方法都是类Object中定义的，但经常被子类重载以提供适当的语义。如Array重定义了==，当两个数组对象有相同的元素个数，且对应的元素有都相等时，才认为它们相等。

    操作符号        含义
    ==              测试是否相等
    ===             表达case语句的目标和每个when从句的项
    <=>             通用比较操作符，根据接受者小于、等于、大于参数，分别返回1、0和+1
    <, <=, >=, >    小于、小于等于、大于等于、大于
    =~              正则表达式模式匹配操作符
    eql?            如果接受者和参数具有相同的类型和相等的值，则返回真。如 1==1.0为真，eql?(1.0)为假
    equal?          如果接受者和参数相同的对象ID，返回真

==和=～都有相反形式：!=和!~。
但ruby读取程序时候，会对它们进行转换：
a != b等价于!(a = b)   <kinder:note> 为什么不是等价于!(a == b)？
a !~ b等价于!(a =~ b)
这意味着你的类重载了==或者=～，则会自动得到!=和!~。（另一个角度讲，不能定义!=和!~）
下面是第四版的例子和补充。

    class T
      def ==(other)
        puts "Comparing self == #{other}"
        other == "value"
      end
    end
    t = T.new
    p(t == "value")
    p(t != "value")
    # produces:
    # Comparing self == value
    # true
    # Comparing self == value
    # false

If instead we explicitly define !=, Ruby calls it:
如果我们反过来明确地定义`!=`，ruby会调用它：

    class T
      def ==(other)
        puts "Comparing self == #{other}"
        other == "value"
      end
      def !=(other)
        puts "Comparing self != #{other}"
        other != "value"
      end
    end
    t = T.new
    p(t == "value")
    p(t != "value")
    # produces:
    # Comparing self == value
    # true
    # Comparing self != value
    # false

**range**
你还可以用range作为布尔表达式。
像exp1...exp2这样的range，在exp1变为真之前，range对象的值为假，在exp2变为真之前，range被求解为真。一旦exp2变为真，range将重置，准备再次重新计算。
具体例子:

    file = File.open("ordinal")
    while line = file.gets
      puts(line) if line =~ /third/ .. line =~ /fifth/   # 从包含third的那一行开始，在包含fifth的那一行结束。
    end
    输出结果：third fourth fifth   # 当然，third和fifth的中间不一定是fourth。

1.8版之前，可以用裸正则表达式（bare regular expression）作为布尔表达式。
现在这种方式已经过时。但仍可用操作符～和`$_`和一个模式进行匹配。

### 7.4.2 逻辑表达式的值
操作符and or && ||实际上是返回首个决定条件真伪的参数的值。

    nil    and true   → nil
    false  and true   → false
    99     and false  → false
    99     and nil    → nil
    99     and "cat"  → "cat"

    false or nil    → nil
    nil or   false  → false
    99 or    false  → 99

ruby的惯用技法利用了这个特性：

    words[key] ||= [] << word

<kinder:note> 4版的例子：

    var ||= "default value"      # 等同于下面两种写法
    var = "default value" unless var
    var ||  var = "default value"


### 7.4.3 If和Unless表达式
标准的if表达式

    if song.artist == "Gillespie" then
      handle = "Dizzy"
    elsif song.artist == "Parker" then
      handle = "Bird"
    else
      handle = "unknown"
    end

如果将if语句分布到多行，可以不用then

    if song.artist == "Gillespie"
      handle = "Dizzy"
    elsif song.artist == "Parker"
      handle = "Bird"
    else
      handle = "unknown"
    end

紧凑些，可以使用then

    if song.artist == "Gillespie" then handle = "Dizzy"
    elsif song.artist == "Parker" then handle = "Bird"
    else handle = "unknown"
    end

用:替代then，可以让代码更简洁  <kinder:note> 这个特性在ruby2.0已经消失。

    if song.artist == "Gillespie": handle = "Dizzy"
    elsif song.artist == "Parker": handle = "Bird"
    else handle = "unknown"
    end

if是表达式而不是语句，它会返回一个值，即使你不必非要这个值

    handle = if song.artist == "Gillespie" 
                 "Dizzy"
               elsif song.artist == "Parker"
                 "Bird"
               else
                 "unknown"
               end

否定形式的if：unless
The unless statement does support else, but most people seem to agree that it’s clearer to switch to an if statement in these cases.
unless也支持else，但大部分人看起来同意，在这种情况下用if更干净。

    unless song.duration > 180
      cost = 0.25
    else
      cost = 0.35
    end

C风格的条件表达式

    cost = song.duration > 180 ? 0.35 : 0.25

if和unless修饰符

    mon, day, year = $1, $2, $3 if date =~ /(\d\d)-(\d\d)-(\d\d)/
    puts "a = #{a}" if debug
    print total unless total.zero?

    File.foreach("/etc/fstab") do |line|
      next if line =~ /^#/ # Skip comments
      parse(line) unless line =~ /^$/ # Don't parse empty lines
    end

因为if本身也是一个表达式，下面的用法让人抓狂：
<kinder:note> 如果use_nicknames不等于no，就查看artist是不是等于John Coltrane，若是，则将artist赋值为Trane。

    if artist == "John Coltrane"
      artist = "Trane"
    end unless use_nicknames == "no"

## 　　7.5　Case表达式
ruby的case表达式相当于多路的if，两种形式使它更加强大。
第一种形式，接近于一组连续的if语句：
让你列出一组条件，执行第一个为真的条件表达式所对应的语句。

    leap = case
           when year % 400 == 0: true
           when year % 100 == 0: false
           else year % 4   == 0
           end

第二种形式，更加常见
在case语句的顶部指定一个目标，而每个when从句列出一个或者多个比较条件。

    case input_line
    when "debug"
      dump_debug_info
      dump_symbols
    when /p\s+(\w+)/
`      dump_variable($1)
    when "quit", "exit"
      exit
    else
      print "Illegal command: #{input_line}"
    end

和if一样，case返回执行的最后一个表达式的值；如果表达式和条件在同一行，可以用then或者：来区分。<kinder:note> 冒号的用法也被ruby2.0取消了。
case通过比较目标（case后面的表达式）和when关键字后面的比较表达式来运作。
这个测试通过comparison === target来完成。
只要类为===提供了有意义的语义（内建的类都有），则该类的对象可以在case表达式中使用。

    case line
    when /title=(.*)/
      puts "Title is #$1"
    when /track=(.*)/
      puts "Track is #$1"
    when /artist=(.*)/
      puts "Artist is #$1"
    end

ruby的所有类都是类Class的实例，它定义了===以测试参数是否为该类或者父类的一个实例。所以放弃了多态的好处，并把重构的复印带到你的耳侧，你可以测试对象到底于哪个类。

    case shape
    when Square, Rectangle
      # ...
    when Circle
      # ...
    when Triangle
      # ...
    else
      # ...
    end

## 　　7.6　循环
ruby内建的循环结构相当原始。
只要条件为真，while循环就会执行循环体。

    while line = gets
      # ...
    end

until循环相反，执行循环体直到条件变真。

    until play_list.duration > 60
      play_list.add(song_list.pop)
    end

while和until也可以作为修饰符

    a = 1
    a *= 2 while a < 100
    a -= 10 until a < 100
    a → 98

和Range结合使用

    file = File.open("ordinal")
      while line = file.gets
      puts(line) if line =~ /third/ .. line =~ /fifth/
    end
    produces:
    third
    fourth
    fifth

类似Perl的语法可以这样：

    file = File.open("ordinal")
      while file.gets
      print if ~/third/ .. ~/fifth/
    end
    produces:
    third
    fourth
    fifth

原来gets将读取的最后一行赋值给全局变量`$_`，～操作符对`$_`执行正则表达式匹配。不带参数的print将输出`$_`。不过这种写法已经过时了。

用在布尔表达式中的range的起点和终点本身也可以是表达式。
每次求解总体布尔表达式时就会求解起点和终点表达式的值。
例如下面的代码利用了变量`$.`包含当前输入行号的事实，来显示1到3行以及位于/eig/和/nin/之间的行：

    File.foreach("ordinal") do |line|
      if (($. == 1) || line =~ /eig/) .. (($. == 3) || line =~ /nin/)   
      # <kinder:note> 很难想到这样也可以工作。写成两个if其实会更易读。不是吗？
      # <kinder:note> 好吧，完全不能理解上面这一句代码了！                                                                   
      # 比如（($. == 1 ) || line=～ /eig/ ），($. == 1 )是查看是否行号为1，是即返回true。然后查看 line是否匹配/eig/，答案是否nil，所以||运算应该是返回nil。
      # 用nil作为起点？怎么去理解啊？
      print line
    end
    end
    ## produces:
    # first
    # second
    # third
    # eighth
    # ninth

当使用while和until做语句修饰符时，如果**修饰符的语句是一个begin～end块**，那么不管布尔表达式的值是什么，块内的代码至少会执行一次。

    print "Hello\n" while false
    begin
      print "Goodbye\n"   # 这一行会输出
    end while false    

### 7.6.1 迭代器
ruby不需要内建任何复杂的循环，因为迭代器实现了所有有趣的东西。
**times方法**

     3.timeds.do 
       print "Ho! "
     end
     # Ho! Ho! Ho!

**downto upto方法**，让整数在指定的range上循环，所有数字都可以使用**step**来循环。

     0.upto(9) do |x|
       print x, " "
     end
     #  0 1 2 3 4 5 6 7 8 9
     0.step(12, 3){|x| print x, " "} # 0 3 6 9 12

**each方法**遍历数组和其他容器

    [1, 1, 2, 3, 5].each {|val| print val, " "}  # 1 1 2 3 5

并且，如果一个类支持each方法，那么也会自动支持**Enumerable模块**（详见9.4组合模块一节）中的方法。

    File.open("ordinal").grep(/d$/) do |line|
      puts line
    end

**loop迭代器**

    loop do
      # block
    end

### 7.6.2 For ... In
for是一个语法块，ruby会将他转化在一个each方法。

    for song in songlist
      song.play
    end
    等同于：
    songlist.each do |song|
      song.play
    end

for循环和each形式的唯一区别是循环体中局部变量的作用域。见下面7.7节。
反之，只要你的类支持each方法，就可以使用for循环去遍历它的对象。

    for i in ['fee', 'fi', 'fo', 'fum']
      print i, " "
    end
    for i in 1..3
      print i, " "
    end
    for i in File.open("ordinal").find_all {|line| line =~ /d$/}
      print i.chomp, " "
    end
    # produces:
    # fee fi fo fum 1 2 3 second third

    class Periods
      def each                    # <kinder:note> 又是一个陌生的写法。这是在重定义each方法。
        yield "Classical"
        yield "Jazz"
        yield "Rock"
      end
    end
    periods = Periods.new
    for genre in periods
      print genre, " "      # <kinder:note> 打印periods里面的元素。
    end
    # produces:
    # Classical Jazz Rock


### 7.6.3 Break, Redo和Next
break 终止最近的封闭循环体，执行block后面的语句。
redo 从循环头重新执行循环，但不重计算循环条件表达式或获得迭代中的下一个元素。
next 跳到本次循环的末尾，开始下一次迭代。

    while line = gets
      next if line =~ /^\s*#/                     # skip comments
      break if line =~ /^END/                     # stop at end
                                                  # substitute stuff in backticks and try again
      redo if line.gsub!(/`(.*?)`/) { eval($1) }  # process line ...
    end

这几个关键字还可以和任意基于迭代的循环机制一起使用。

    i=0
    loop do
      i += 1
      next if i < 3
      print i
      break if i > 4
    end
    # produces:
    # 345

可以传递一个值给break和next。
在传统循环中，可能只对break有意义，此时break将设置循环的返回值。传递给next的值会被丢弃。
如果传统循环没有执行break，值为nil。

    result = while line = gets
               break(line) if line =~ /answer/
             end
    process_answer(result) if result

如果你想了解break和next如何与block和proc协同工作的本质细节，可以参考22.12。
如果你想从嵌套的block或者循环中退出，请参考22.14节和27.1内置类kenel一节。
### 7.6.4 Retry
redo语句使得一个循环重新执行当前的迭代。
有时你需要从头执行一个循环。

    for i in 1..100
      print "Now at #{i}. Restart? "
      retry if gets =~ /^y/i
    end
    # 交互式运行这段代码：
    # Now at 1. Restart? n
    # Now at 2. Restart? y
    # Now at 1. Restart? n

retry在重新执行之前会重新计算传递给迭代的所有参数。

    def do_until(cond)
      break if cond     # 如果cond为真则跳出循环。注意这个方法不是循环。
      yield             # 执行block的内容
      retry             # <kinder:note> 这个语句会将将新i带入这个方法重新计算
    end
    i = 0
    do_until(i > 10) do   # <kinder:note> 注意这个1>10不是do～end的执行条件，而是上面的cond。
      print i, " "
      i += 1
    end
    # produces:
    # 0 1 2 3 4 5 6 7 8 9 10

## 　　7.7　变量作用域、循环和Blocks
while until for循环内建到ruby中，但没有引入新的作用域：前面已经存在的局部变量可以在循环中使用，循环中新建的局部变量也可以在循环后使用。
被迭代器使用的block（比如loop each）略有不同，这些block中创建的局部变量无法在block外使用。

    [ 1, 2, 3 ].each do |x|
      y = x + 1
    end
    [ x, y ]
    # produces:
    # prog.rb:4: undefined local variable or method `x' for main:Object (NameError)

如果执行block的时候，一个局部变量已经存在且与block中的变量同名，则block使用已有的局部变量。因而，它的值在block后面仍然可以使用。
下面是第二版的例子：

    x = nil
    y = nil
    [ 1, 2, 3 ].each do |x|
      y = x + 1
    end
    [ x, y ] → [3, 4]

下面是第四版的例子，x的作用域已经改变！

    x = "initial value"
    y = "another value"
    [ 1, 2, 3 ].each do |x|
      y = x + 1
    end
    [ x, y ] # => ["initial value", 4]

Note that the assignment to the variable doesn’t have to be executed; the Ruby interpreter just needs to have seen that the variable exists on the left side of an assignment
注意变量的赋值并不一定要执，：ruby解释器只需要看到它在赋值的左边即可。

    a = "never used" if false
    [99].each do |i|
      a = i # this sets the variable in the outer scope 这设置了外部作用域的变量。
    end
    a # => 99

<kinder:note> 下面是第二版的表述和例子。
Note that the variable need not have been given a value in the outer scope: the Ruby interpreter just needs to have seen it.
注意在外部作用域中变量不必有值：ruby解释器只需要看到它即可。

    if false
      a = 1
    end
    3.times (|i| a = 1)   # 三次，第一次0第二次1第三次2
    a  # 2

变量作用域和block的问题在社区引起广泛的讨论。特别当block的变量和外部变量同名的时候，这个模式有一定的问题。ruby2.0会对此进行改进。

You can list block-local variables in the block’s parameter list, preceded by a semicolon. Contrast this code, which does not use block-locals:
你可以在block的参数列表中列出块内变量，用一个分号做前缀。对比没有使用块内变量的这个代码：

    square = "yes"
    total = 0
    [ 1, 2, 3 ].each do |val|
      square = val * val
      total += square
    end
    puts "Total = #{total}, square = #{square}"
    # produces:
    # Total = 14, square = 9

with the following code, which uses a block-local variable, so square in the outer scope is not affected by a variable of the same name within the block:
在下面的代码中，使用了**块内变量**，所以外部作用域的square不受块内同名变量的影响。

    square = "yes"
    total = 0
    [ 1, 2, 3 ].each do |val; square|
      square = val * val
      total += square
    end
    puts "Total = #{total}, square = #{square}"
    # produces:
    # Total = 14, square = yes

If you are concerned about the scoping of variables with blocks, turn on Ruby warnings, and declare your block-local variables explicitly.
如果你担心block的变量作用域，打开ruby的warning选项，明确声明你的块内变量。

# 　第8章　异常，捕获和抛出
**异常的必要性**
在现实世界中，错误总会发生，好的程序和程序员可以预见它们的发生，然后优雅的处理这些错误。但并非总像听起来那么简单。
通常检测到错误出现的那部分代码，缺少有关如何处理它的上下文信息。比如试图去打开一个不存在的文件，在一些情况下是可行的，但别的情况下却是致命的错误。
传统的做法是使用返回码。open方法在失败时会返回一些特定值，这个值会沿着调用例程的层次往回传播，直到有函数要处理它。
这种做法的问题是管理所有这些错误码是一件痛苦的事情。如果函数首先调用了open，然后read，最后close，而且每个方法都有可能返回错误标识，那么该如何区分这些错误码呢？
异常类很大程度上解决了这个问题。异常允许把错误信息打包到一个对象中，然后该一场对象被自动传播回调用栈，直到运行系统找到明确声明知道如何处理这类异常的代码为止。
## 　　8.1　异常类
含有异常信息的数据包是异常类、或其子类的一个对象。
ruby预定义了一个简洁的**异常层次结构**，如下，使得处理异常变得相当简单。
Exception
  fatal (used internally by Ruby,ruby内部使用)
  NoMemoryError     没有内存
  ScriptError       脚本错误
    LoadError           载入错误
    NotImplementedError 不完整错误
    SyntaxError         语法错误
  SignalException   信号异常
    Interrupt           中断
  StandardError     标准错误
    ArgumentError       参数错误
    IOError             输入输出错误
      EOFError              文件结尾错误  
    IndexError          索引错误
    LocalJumpError      本地跳转错误
    NameError           名字错误
      NoMethodError         无方法错误
    RangeError          范围错误
      FloatDomainError       浮动域名错误
    RegexpError         正则表达式错误
    RuntimeError        运行时错误
    SecurityError       安全错误
    SystemCallError     系统调用错误
      system-dependent exceptions (Errno::xxx)   系统依赖异常
    ThreadError         线程错误
    TypeError           类型错误
    ZeroDivisionError   零分隔错误
  SystemExit        系统退出
  SystemStackError  系统栈错误
当需要引发异常时，可以使用某个内建的异常类，或者创建自己的异常类——创建时应该让它从StandardError类或其子类派生；否则默认情况下不会被捕捉。
每个异常都关联一个消息字符和栈回溯信息(backtrace)。如果定义自己的异常，可以添加额外的信息。
## 　　8.2　处理异常
**基本用法**
在一个begin～end块中，使用一个或多个rescue语句告诉ruby希望处理的异常类型。

    op_file = File.open(opfile_name, "w")
    begin
    # Exceptions raised by this code will
    # 这段代码引发的异常
    # be caught by the following rescue clause
    # 会被下面的rescue捕获。
      while data = socket.read(512)
        op_file.write(data)
      end
    rescue SystemCallError
      $stderr.print "IO failed: " + $!      # 标准错误输出报告问题。ruby会将相关Exception对象的引用放在全局变量$!中。
      op_file.close                         # 关闭文件
      File.delete(opfile_name)              # 删除文件
      raise                                 # 抛出异常
    end

不用任何参数调用raise，会重新引发$!中的异常。这是一个有用的技术。允许我们先编写代码过滤掉一些异常，再把不能处理的异常传递到更高的等次 。这几乎就像实现了一个错误处理的继承层次结构。
在begin～end块中可以有多个rescue子句，每个rescue子句可以指示捕获多个异常。
rescue子句的结束处，可以提供一个ruby的局部变量名来接收匹配的异常。这比使用$!更好读。
ruby如何决定执行哪个rescue子句呢？这个处理非常类似于对case语句的处理：用引发的异常依次比较begin块中的每个rescue子句的每个参数。
如果匹配，就执行rescue程序体，停止比较。匹配使用`parameter===$!`完成的。
对于大多数异常来说，如果rescue子句给出的类型与当前引发的异常的类型相同，或者它是引发异常的超类(superclass)，意味着匹配是成功的。
如果rescue子句不带参数，默认为StandardError。
如果没有任何rescue子句与之匹配，或者异常在begin～end块外面被引发，ruby就会沿着调用栈向上查询，在调用者上寻找异常的处理者，接着在调用者的调用者上寻找，依次类推。
尽管rescue子句的参数通常是Exception类的名称，实际上可以是任何返回Exception类的表达式（包括方法调用）。

    begin
      eval string
    rescue SyntaxError, NameError => boom
      print "String doesn't compile: " + boom
    rescue StandardError => bang
      print "Error running script: " + bang
    end

### 8.2.1 系统错误
对操作系统的调用返回错误码时，会引发系统错误。
在POSIX系统上这些错误名称诸如EAGAIN和EPERM（UNIX错误列表详见`$ man error`的输出）。
ruby得到这些错误，把每个错误包装到特定对象中。每个错误都是SystemCallError的子类，定义在Errno模块中。这意味着，你会发现Errno::EAGAIN Errno::EIO Errno::EPERM等的异常。
如果想得到底层的系统错误码，见每个Errono异常对象Errno类常量，它包括相应的系统错误。

    Errno::EAGAIN::Errno       → 35
    Errno::EPERM::Errno        → 1
    Errno::EIO::Errno          → 5
    Errno::EWOULDBLOCK::Errno  → 35

注意到EWOULDBLOCK和EAGAIN有相同的错误码。这是我电脑操作系统的一个特性：两个常量映射到相同的错误码。
为了处理这种情况，ruby作出了安排，让这两个错误码在rescue子句中被等同对待。如果你要求rescue其中一个，那么另一个也会被rescue。
通过重定义SystemCallError#===可以做到这一点。
因此如果要比较SystemCallError的两个子类，是比较它的错误码而不是在层次结构中的位置。
<kinder:note> 不懂。需要故意安排吗？还是防止这种情况？

### 8.2.2 善后
有时你需要保证一些处理在block结束时能够被执行，而不管是否有异常引发。
ensure子句跟在最后的rescue子句后面，包含一段block退出时总是要执行的代码。

    f = File.open("testfile")
    begin
      # .. process
      rescue
        # .. handle error
      ensure
        f.close unless f.nil?
    end

尽管不是那么有用，else子句是一个类似于ensure子句的构造。
else出现在rescue和ensure子句之间。else子句的程序体，只要当主体代码没有引发任何异常时才会被执行。

    f = File.open("testfile")
    begin
      # .. process
    rescue
      # .. 处理错误
    else
      puts "Congratulations-- no errors!"   # 当然这一句话跳出了异常检查的返回，必须确保这一行没有异常；否则嘿嘿。
    ensure
      f.close unless f.nil?
    end

### 8.2.3 再次执行
在rescue子句中retry语句重复执行整个begin～end区块。
显然很可能导致无限循环，使用这个特性应该倍加小心。

    @esmtp = true
    begin
      # 首先尝试扩展登录。如果因为服务器不支持而失败，
      # 则使用正常登录。
      if @esmtp then
        @command.ehlo(helodom)     # 使用ehlo命令试图连接SMTP服务器。如果失败跳转到rescue语句
      else
        @command.helo(helodom)
      end
    rescue ProtocolError
      if @esmtp then
        @esmtp = false
        retry              # 扩展连接失败，将执行上面的helo命令来连接服务器。
      else
        raise  # 如果第二次连接失败，则引发异常给他的调用者。
      end
    end

## 　　8.3　引发异常
可以使用Kernel.raise（或者Kernel.fail）方法在代码中引发异常。

    raise
    raise "bad mp3 encoding"
    raise InterfaceException, "Keyboard failure", caller

第一种形式只是简单重新引发当前异常（如果没有当前异常，引发RuntimeError）。这种形式用于先截获异常再将其继续传递。
第二种形式创建新的RuntimeError异常，把它的消息设置为指定的字符串。然后异常随着调用栈向上引发。
第三种形式使用第一个参数创建异常，然后把想关联的消息设置给第二个参数，同时把栈消息（trace）设置给第三个参数。第一个参数通常是Exception层次结构中的某个类的名称，或者是某个异常类的对象实例的引用。[2]通常使用Kernel.caller方法产生栈信息。
[2]从技术层面上讲，这个参数可以是任何对象，只要能响应消息exception，且这个消息返回一个能够满足`object.kind_of?(Exception)`为真的对象。

    raise
    raise "Missing name" if name.nil?
    if i >= names.size
      raise IndexError, "#{i} >= size (#{names.size})"
    end
    raise ArgumentError, "Name too big", caller

这个例子从栈回溯信息删除当前函数，这在程序库模块中十分有用。<kinder:note> 什么是“删除当前函数”？
可以更进一步：只将调用栈的子集传递给新异常，从而达到从栈回溯信息中删除两个函数的目的。<kinder:note> “传递给新异常”“删除两个函数”？怎么看不出来？

    raise ArgumentError, "Name too big", caller[1..-1]

### 8.3.1 添加信息到异常
你可以定义自己的异常，保存任何需要从错误发生地传递出去的信息。

例如，某种类型的网络错误可能是暂时的，如果这种错误发生了，可以在异常中设置一个标志，告诉异常处理程序重试这个操作可能是值得的。

    class RetryException < RuntimeError
      attr :ok_to_retry
      def initialize(ok_to_retry)
        @ok_to_retry = ok_to_retry
      end
    end

在下面的代码中，发生了一个暂时的错误：

    def read_data(socket)
      data = socket.read(512)
      if data.nil?
        raise RetryException.new(true), "transient read error"
      end
      # 正常处理
    end

在上一级的调用栈处理了异常。

    begin
      stuff = read_data(socket)
      #  .. 处理stuff
    rescue RetryException => detail
      retry if detail.ok_to_retry
      railse
    end

## 　　8.4　捕获和抛出
尽管raise和rescue的异常机制对程序出错时终止执行已经够用，但如果在正常处理过程期间能够从一些深度嵌套的结构中跳转出来，则是很棒的。
catch和throw可以方便地做到这点。
第一个例子

    catch (:done) do
      while line = gets
        throw :done unless fields = line.split(/\t/)   # 如果输入没有包含正确格式化的行，throw会跳到相应的catch代码块的结束处，不仅终止了while循环，而且跳过了歌曲列表的播放。如果调用throw时指定了可选的第二个参数时，这个值会作为catch的值返回。
        songlist.add(Song.new(*fields))
      end
      songlist.play
    end

catch定义了以给定名称（符号或字符串）为标签的block，这个block会正常执行直到遇到throw为止。
当ruby碰到throw，迅速回溯调用栈，用匹配的符号寻找catch代码块。
发现之后，ruby将栈清退到这个位置并终止该block。

第二个例子：
如果在响应任意提示符时键入感叹号，使用throw终止与用户的交互。
这个例子说明throw没必要出现在catch的静态作用域中。<kinder:note> "静态作用域"？

    def prompt_and_get(prompt)
      print prompt
      res = readline.chomp
      throw :quit_requested if res == "!"
      res
    end
    catch :quit_requested do
      name = prompt_and_get("Name: ")   # 首先执行这一句，调用promt_and_get方法，将“Name”传入方法中。
      age = prompt_and_get("Age: ")
      sex = prompt_and_get("Sex: ")
      # ..
      # process information
    end
    # 运行结果：
    # $ ruby rbs
    # Name: djfid
    # Age: dkjfidj!
    # Sex: fidjfid
    # $ ruby rbs
    # Name: !
    # $ 



# 　第9章　模块
## 共享功能：继承、模块和混合 第四版新增
在本书第四版，这一章被改为第五章：Sharing Functionality: Inheritance,Modules, and Mixins 共享功能：继承、模块和混合
One of the accepted principles of good design is the elimination of unnecessary duplication.
良好设计的一个可接受原则是减少不必要的重复。
We work hard to make sure that each concept in our application is expressed just once in our code. [1]
在我们的代码中，我们努力确保一点：程序中的每个概念只表达一次。
[1].Why? Because the world changes. 
为什么？因为世界在改变。
And when you adapt your application to each change, you want to know that you’ve changed exactly the code you need to change. 
当你改变你的程序来适应每个变化时，你想知道你确实已经更改了那些你想更改的代码。
If each real-world concept is implemented at a single point in the code, this becomes vastly easier.
如果代码中每个真实世界的概念在一个单点里面实现，这将会非常简单。

We’ve already seen how classes help. 
我们已经看到类怎么帮助我们。
All the methods in a class are automatically accessible to instances of that class. 
类里所有的方法对于该类的实例来说是自动可使用的。
But there are other, more general types of sharing that we want to do. 
但还有另一些更一般的共享类型，我们想要的。
Maybe we’re dealing with an application that ships goods. 
可能我们面对一个运载商品的程序。
Many forms of shipping are available, but all forms share some basic functionality (weight calculation, perhaps). 
有很多形式的运载，但多有的运载共享一些基本的功能（比如重量计算）
We don’t want to duplicate the code that implements this functionality across the implementation of each shipping type. 
我们不想将这个实现功能的代码复制到每个运载类型中去。
Or maybe we have a more generic capability that we want to inject into a number of different classes. 
或者我们可能有一个更一般的能力，我们想诸如一些不同的类型。
For example, an online store may need the ability to calculate sales tax for carts, orders, quotes, and so on. 
比如，一个在线商店可能需要为购物车、订单、报价等等添加一种计算销售税的功能。
Again, we don’t want to duplicate the sales tax code in each of these places.
还是那样，我们不想将销售税的代码复制到每个地方去。

In this chapter, we’ll look at two different (but related) mechanisms for this kind of sharing in Ruby. 
在这一章，我们在ruby中看看两种不同（但是相关）的机制来实现这种共享。
The first, class-level inheritance, is common in object-oriented languages. 
首先是类级的继承，在面向对象语言里面很常见。
We’ll then look at mixins, a technique that is often preferable to inheritance. 
然后我们看看混合，一个更好的继承技巧。
We’ll wind up with a discussion of when to use each.
当使用它们时，我们认真讨论清理一遍。

## 5.1 Inheritance and Messages  继承和消息  第四版新增

In the previous chapter, we saw that when puts needs to convert an object to a string, it calls that object’s `to_s` method. 
在前一节，我们看到，当需要将一个对象转化为字串时，要调用对象的`to_s`方法。
But we’ve also written our own classes that don’t explicitly implement `to_s`. 
但我们也写了自己的类，并没有明确地实现`to_s`方法。
Despite this, objects of these classes respond successfully when we call `to_s` on them. 
尽管这样，当我们调用`to_s`方法时，这些类的对象成功回应了。
How this works has to do with inheritance, subclassing, and how Ruby determines what method to run when you send a message to an object.
这个怎么用继承、子类来运行，ruby怎么决定当你发送一个消息到一个对象时该运行什么方法。

Inheritance allows you to create a class that is a refinement or specialization of another class.
**继承**允许你创建一个类，作为对另一个类的提炼或特殊化。
This class is called a subclass of the original, and the original is a superclass of the subclass.
这个类被称作元类的子类，元类则是那个子类的超类。
People also talk of child and parent classes.
人们也用父类和子类来谈论他们。

The basic mechanism of subclassing is simple. 
子类的基本机制是简单的。
The child inherits all of the capabilities of its parent class—all the parent’s instance methods are available in instances of the child.
子类继承了父类的所有能力 -- 所有父类的实例方法对于子类的实例来说都是可用的。
Let’s look at a trivial example and then later build on it. Here’s a definition of a parent class and a child class that inherits from it:
让我们看看一个琐碎的例子，然后在其上建立子类。这是一个父类的定义，子类将继承它。

    class Parent
      def say_hello
        puts "Hello from #{self}"
      end
    end
    p = Parent.new
    p.say_hello  # Hello from #<Parent:0x007fb87110fd98> 
    # Subclass the parent...
    class Child < Parent
    end
    c = Child.new 
    c.say_hello    # Hello from #<Child:0x007fb87110fac8>
    
The parent class defines a single instance method, `say_hello`. 
父类定义了一个实例方法`sya_hello`。
We call it by creating a new instance of the class and store a reference to that instance in the variable p.
我们调用它，通过创建一个类的新实例，并将实例的引用保存在变量p中。
We then create a subclass using class Child < Parent. 
我们然后使用**`class Child < Parent`**创建一个子类。
The < notation means we’re creating a subclass of the thing on the right; the fact that we use less-than presumably signals that the child class is supposed to be a specialization of the parent.
`<`符号的意思是：我们正在创建右类的一个子类，事实是我们使用小于是大概发出信号：子类被假设是父类的特殊化。
Note that the child class defines no methods, but when we create an instance of it, we can call `say_hello`.
注意子类没有定义方法，但我们创建了一个实例，我们可以调用`say_hello`。
That’s because the child inherits all the methods of its parent. 
那是因为子类继承父类的所有方法。
Note also that when we output the value of self—the current object—it shows that we’re in an instance of class Child, even though the method we’re running is defined in the parent.
也注意，当我们输出self（当前对象）的值时，它显示我们在一个子类的实例中，即使这个运行的方法被定义在父类中。
The superclass method returns the parent of a particular class:
**`superclass`方法**返回一个类的父类：

    class Parent
    end
    class Child < Parent
    end
    Child.superclass # => Parent

But what’s the superclass of Parent?
但父类的超类呢？

    class Parent
    end
    Parent.superclass # => Object

If you don’t define an explicit superclass when defining a class, Ruby automatically makes the built-in class Object that class’s parent. Let’s go further:
如果你定义一个类时不明确指定一个超类，ruby会自动将内建的Object类作为它的父类。让我们更深入些：

    Object.superclass # => BasicObject

Class BasicObject is used in certain kinds of metaprogramming, acting as a blank canvas.
**BasicObject类**用于一些元编程中，用作一个空白的画布。
What’s its parent?
它的子类呢》

    BasicObject.superclass.inspect # => "nil"

So, we’ve finally reached the end. 
这样，我们到了尽头。
BasicObject is the root class of our hierarchy of classes.
BasicObject是我们类层的根类。
Given any class in any Ruby application, you can ask for its superclass, then the superclass of that class, and so on, and you’ll eventually get back to BasicObject.
指定ruby程序中的任何一个类，我们可以请求其超类，超类的超类，直到你最后得到BasicObject。
We’ve seen that if you call a method in an instance of class Child and that method isn’t in Child’s class definition, Ruby will look in the parent class. 
我们已经看到，如果我们调用一个方法在Child类的实例，该方法没有在Child定义，ruby将在父类中寻找。
It goes deeper than that, because if the method isn’t defined in the parent class, Ruby continues looking in the parent’s parent, the parent’s parent’s parent, and so on, through the ancestors until it runs out of classes.
如果该方法没有在父类中定义，ruby会往深处查找，父类的父类，以此类推，直到找遍所有的父类。

And this explains our original question. 
这解释了我们原来的问题。
We can work out why `to_s` is available in just about every Ruby object. 
我们终于知道为什么`to_s`几乎在每个ruby对象中都可用。
`to_s` is actually defined in class Object. 
Because Object is an ancestor of every Ruby class (except BasicObject), instances of every Ruby class have a `to_s` method defined:
`to_s`实际上在Object类中定义。因为Object是每个ruby类（BasicObject除外）的祖先，因此ruby的每个实例都有定义好的`to_s`方法。

    class Person
      def initialize(name)
        @name = name
      end
    end
    p = Person.new("Michael")
    puts p   #<Person:0x007fa08b8643f8>

We saw in the previous chapter that we can override the `to_s` method:
在前一章中我们可以**重写**`to_s`方法:

    class Person
      def initialize(name)
        @name = name
      end
      def to_s
        "Person named #{@name}"
      end
    end
    p = Person.new("Michael")
    puts p     # Person named Michael

Armed with our knowledge of subclassing, we now know there’s nothing special about this code. 
有了这些子类的知识，我们现在对这些代码不觉特别了。
The puts method calls `to_s` on its arguments. 
puts方法对参数调用了`to_s`。
In this case, the argument is a Person object.
在这个情况下，参数是Person对象。
Because class Person defines a `to_s` method, that method is called. 
因为Person类定义了一个`to_s`方法，该方法被调用。
If it hadn’t defined a `to_s` method, then Ruby looks for (and finds) `to_s` in Person’s parent class, Object.
如果没有定义`to_s`方法，ruby将在Person的父类Object中寻找`to_s`。
It is common to use subclassing to add application-specific behavior to a standard library or framework class. 
使用子类将应用特有的行为加入到标准库或框架类中，是常见的。
If you’ve used Ruby on Rails, you’ll have subclassed ActionController when writing your own controller classes. 
如果你已经使用Ruby on Rails，你将使用ActionController的子类，当你写下你自己的控制器类。
Your controllers get all the behavior of the base controller and add their own specific handlers to individual user actions. 
你的控制器得到基本控制器的表现，并加入自己特有的对个别用户行为的处理。
If you’ve used the FXRuby GUI framework, you’ll have used subclassing to add your own application-specific behavior to FX’s standard GUI widgets.
如果已经使用过FXRuby GUI框架，你将使用子类来添加你自己的应用程序特有的行为到FX的标准GUI部件中。

Here’s a more self-contained example. 
这里是一个更自我包含的例子。
Ruby comes with a library called GServer that implements basic TCP server functionality. 
Ruby开始一个叫做GServer的标准库，实现基本的TCP服务器功能。
You add your own behavior to it by subclassing the GServer class. 
你向它添加自己的行为，通过GServer类的子类。
Let’s use that to write some code that waits for a client to connect on a socket and then returns the last few lines of the system log file. 
让我们使用它，写一些代码来等待一个客户端的套接字连接，然后返回系统log文件最后几行。
This is an example of something that’s actually quite useful in long-running applications—by building in such a server, you can access the internal state of the application while it is running (possibly even remotely).
这是一个例子，对于长时间运行的程序实际上相当有用 -- 通过建构这个服务器，你可得到应用程序的内在状态，在运行的同时（即使是远程的）。
The GServer class handles all the mechanics of interfacing to TCP sockets. 
GServer类处理所有TCP套接字接口的过程。
When you create a GServer object, you tell it the port to listen on.[4] 
当你创建一个GServer对象时，你告诉它监听的端口。
Then, when a client connects, the GServer object calls its serve method to handle that connection. 
然后，当一个客户端连接时，GServer对象调用它的serve方法来处理那个连接。
Here’s the implementation of that serve method in the GServer class:
这是一个GServer类serve方法的实现：
[4] You can tell it a lot more, as well. We chose to keep it simple here.
你可以告诉它更多东西，这里只是选择让它简单些。

    def serve(io)
    end

As you can see, it does nothing. 
就像你看到的，它什么也干不了。
That’s where our own LogServer class comes in:
那是我们自己的LogServer类进来的地方：

    # tut_modules/gserver-logger.rb
    require 'gserver'
    class LogServer < GServer
      def initialize
        super(12345)
      end
      def serve(client)
        client.puts get_end_of_log_file
      end
    private
      def get_end_of_log_file
        File.open("/var/log/system.log") do |log|
          log.seek(-500, IO::SEEK_END)         # back up 500 characters from end
          log.gets                             # ignore partial line
          log.read                             # and return rest
        end
      end
    end
    server = LogServer.new
    server.start.join

I don’t want to focus too much on the details of running the server. 
我不想太专注于运行这个服务器的细节。
Instead, let’s look at how inheritance has helped us with this code. 
相反，让我们看看这些代码里继承如何帮助我们。
Notice that our LogServer class inherits from GServer.
注意我们的LogServer类继承自GServer。
This means that a log server is a kind of GServer, sharing all the GServer functionality. 
这意味着一个log服务器是一种GServer，共享这GServer所有的功能。
It also means we can add our own specialized behavior.
这也意味着我们可以添加我们的特殊化行为。

The first such specialization is the initialize method. 
第一个特殊化是initialize方法。
We want our log server to run on TCP port 12345. 
我们要我们的log服务器运行在TCP端口12345之上。
That’s a parameter that would normally be passed to the GServer constructor. 
这个参数会正常地传递给GServer构造器。
So, within the initialize method of the LogServer, we want to invoke the initialize method of GServer, our parent, passing it the port number. 
所以，在LogServer的initailize方法里面，我们要调用GServer的initialize方法，我们的父类，传递它的端口号。
We do that using the Ruby keyword super. 
我们使用了一个ruby关键字super。
When you invoke super, Ruby sends a message to the parent of the current object, asking it to invoke a method of the same name as the method invoking super. 
你调用super时，ruby发送一个消息给当前对象的父类，要求它调用super所在方法的同名方法。
It passes this method the parameters that were passed to super.
super将会它的参数传递这个方法。

This is a crucial step and one often forgotten by folks new to OO. 
这是关键的一步，人们总会忘记这一步，分叉new给OO。
When you subclass another class, you are responsible for making sure the initialization required by that class gets run. 
当你写其他类的子类时，你应该确保那个类运行时必须初始化。
This means that, unless you know it isn’t needed, you’ll need to put a call to super somewhere in your subclass’s initialize method. 
这意味着，除非你知道不需要，你应该放一个super调用在你子类初始化方法的某个地方。
(If your subclass doesn’t need an initialize method, then there’s no need to do anything, because it will be the parent class’s initialize method that gets run when your objects get created.)
如果你的子类不需要一个初始化方法，那么没有必要做任何事情，因为当你的对象被创建时，那会是父类的初始化方法在运作。

So, by the time our initialize method finishes, our LogServer object will be a fully fledged TCP server, all without us having to write any protocol-level code. 
所以到我们的初始化方法完成时，我们的LogServer对象将是一个完全可用的TCP服务器，完全不需要我们再写任何协议级别的代码。
Down at the end of our program, we start the server and then call join to wait for the server to exit.
程序的结尾，我们启动服务器，然后调用加入以等待服务器的退出。

Our server receives connections from external clients. 
我们的服务器接收从外部客户端的连接。
These invoke the serve method in the server object. 
这些调用server对象的serve方法。
Remember that empty method in class GServer? 
记得GServer类里的空方法吗？
Well, our LogServer class provides its own implementation. 
对了，我们的LogServer类提供了自己的实现。
And because it gets found by Ruby first when it’s looking for methods to execute, it’s our code that gets run whenever GServer accepts a connection. 
当查找方法来执行时，因为ruby首先发现，我们的代码就会运作起来，不管GServer合适接收一个连接。
And our code reads the last few lines of the log file and returns them to the client: [5] 
我们的代码读取log文件的最后几行，将他们返回给客户端。
[5].You can also access this server from a web browser by connecting to http://127.0.0.1:12345.
你也可以访问这个服务器，从浏览器连接http://127.0.0.1:12345。

    $ telnet 127.0.0.1 12345
    Trying 127.0.0.1...
    Connected to localhost.
    Escape character is '^]'.
    Jul 9 12:22:59 doc-72-47-70-67 com.apple.mdworker.pool.0[49913]: PSSniffer error
    Jul 9 12:28:55 doc-72-47-70-67 login[82588]: DEAD_PROCESS: 82588 ttys004
    Connection closed by foreign host.

The use of the serve method shows a common idiom when using subclassing. 
server方法的使用显示了一个普通的用语，当使用子类时。
A parent class assumes that it will be subclassed and calls a method that it expects its children to implement. 
父类假定，它会被子类化，并调用一个方法期待其子类来完成。
This allows the parent to take on the brunt of the processing but to invoke what are effectively hook methods in subclasses to add application-level functionality. 
这允许父类发生过程的冲击，但在子类中调用什么有效钩子方法，来添加应用程序级别的功能。
As we’ll see at the end of this chapter, just because this idiom is common doesn’t make it good design.
我们将看这一章的结尾，只因为这个用于太过普通，不能让它做出一个好设计。

So, instead, let’s look at mixins, a different way of sharing functionality in Ruby code. 
所以相反，让我们看看混合，ruby代码中一种不同的共享功能的方式。
But, before we look at mixins, we’ll need to get familiar with Ruby modules.
不过，在看混合之前，我们需要熟悉ruby的模块。

## 　　9.1　命名空间
模块是一种将方法、类与常量组织在一起的方式，主要有两个好处：

1. 提供命名空间来防止命名冲突。
2. 实现了mixin混合功能

当你编写了许多可重用的代码，将相关例程组成一个库通常是合适的。
你会希望将这些代码分解到不同的文件，通常代码会被组织为类，可能让一个类对应一个文件。
不过，有时你想把那些无法自然构成类的部分集合到一起。
一种初步的方式是将所有内容放到一个文件中，然后简单的在任何需要它的程序中加载（load）它。
但如果方法重名，糟了。
**答案是使用模块机制**。模块定义了一个命名空间，是一个沙箱，你的方法和常量可以在其中任意发挥，无需担心被其他方法或常量干扰。

模块常量的命名和类常量一样，都以大写字母开头。
模块方法的定义也类似于类方法的定义。

    tut_modules/trig.rb
    module Trig
      PI = 3.141592654
      def Trig.sin(x)
        # ..
      end
      def Trig.cos(x)
        # ..
      end
    end

    tut_modules/moral.rb
    module Moral
      VERY_BAD = 0
      BAD = 1
      def Moral.sin(badness)
      # ...
      end
    end

第三方程序想要使用这些模块，可以简单加载(require语句，在后面123页9.5节)这两个文件并引用他们的完整名称。

    tut_modules/pin_head.rb
    require_relative 'trig'
    require_relative 'moral'
    y = Trig.sin(Trig::PI/4)
    wrongdoing = Moral.sin(Moral::VERY_BAD)

和类方法一样，可以用模块名和句点来调用模块方法，使用模块名和两个冒号来了引用常量。

## 　　9.2　Mixin
mixin以雷霆之势消除了对多重继承的需要。
模块并没有实例，但你可以**在类的定义中include一个模块**，模块所有的实例方法瞬间在类中也可以使用了。

    module Debug
      def who_am_i?
        "#{self.class.name} (id: #{self.object_id}): #{self.name}"
      end
    end
    class Phonograph
      include Debug
      attr_reader :name
      def initialize(name)
        @name = name
      end
      # ...
    end
    class EightTrack
      include Debug
      attr_reader :name
      def initialize(name)
        @name = name
      end
      # ...
    end
    ph = Phonograph.new("West End Blues")
    et = EightTrack.new("Surrealistic Pillow")
    ph.who_am_i?  # => "Phonograph (id: 70266478767560): West End Blues"
    et.who_am_i?  # => "EightTrack (id: 70266478767520): Surrealistic Pillow"

**include**语句。
第一，include与文件无关。只是产生一个指向指定模块的引用。如果模块位于另一个文件中，必须先使用require/load将文件加载进来。
第二，include并非简单将模块的实例方法拷贝到类中，相反，它建立一个由类到所包含模块的引用。如果多个类包含这个模块，即便程序正在运行时，如果改变模块中的一个方法的定义，所有包含这个模块的类都会表现出新的行为。

当mixin中的代码**和使用它的类的代码开始交互**时，真正的力量会迸发出来。
比如你使用Comparable mixin向类中添加比较操作符和between?方法：

    class Person
      include Comparable
      attr_reader :name
      def initialize(name)
        @name = name
      end
      def to_s
        "#{@name}"
      end
      def <=>(other)
        self.name <=> other.name
      end
    end
    p1 = Person.new("Matz")
    p2 = Person.new("Guido")
    p3 = Person.new("Larry")
    # Compare a couple of names
    if p1 > p2
      puts "#{p1.name}'s name > #{p2.name}'s name"
    end
    # Sort an array of Person objects
    puts "Sorted list:"
    puts [ p1, p2, p3].sort
    # 结果:
    # Matz's name > Guido's name
    # Sorted list:
    # Guido
    # Larry
    # Matz

## 　　9.3　迭代器与可枚举模块 Iterators and the Enumerable Module
ruby收集（collection）类支持大量针对收集的各种操作：遍历、排序等等，你可能也想让自己的类也支持这些出色的特性。
因为mixin和Enumerable模块的魔力，你可以编写一个**each迭代器**，包含入Enumerable，然后你的类瞬间支持诸如map、include?和`find_all`等操作。如果在你的收集对象中使用`<=>`方法实现了有意义的排序语义，你还会得到诸如min max和sort等方法。

## 　　9.4　组合模块
Enumerable是另一个标准的mixin，基于宿主类(host class)中的each实现了许多方法。
前面我们提到inject方法，就是Enumerable模块里的一种方法。因此我们可以在任何包含了Enumerable模块并定义了each方法的类中使用inject。
许多内建的类都是如此：

    [ 1, 2, 3, 4, 5 ].inject(:+) # => 15
    ( 'a'..'m').inject(:+)       # => "abcdefghijklm"

我们还可以**定义自己的类包含Enumerable模块**，从而得到inject的支持。

    # tut_modules/vowel_finder.rb
    class VowelFinder
      include Enumerable
      def initialize(string)
        @string = string
      end
      def each
        @string.scan(/[aeiou]/) do |vowel|
          yield vowel     # 这个yield将调用Enumerable模块里面的代码
        end
      end
    end
    vf = VowelFinder.new("the quick brown fox jumped")
    vf.inject(:+)             # => "euiooue"

注意，我们使用了和前面示例中调用inject的相同模式 -- 求和。用作数字时，返回算术和，用于字符串时，返回串联的字符串。
我们也可以使**用一个模块来封装**这个功能。

    module Summable
      def sum
        inject(:+)
      end
    end
    class Array
      include Summable
    end
    class Range
      include Summable
    end
    require_relative "vowel_finder"
    class VowelFinder
      include Summable
    end
    [ 1, 2, 3, 4, 5 ].sum    # => 15
    ('a'..'m').sum           # => "abcdefghijklm"
    vf = VowelFinder.new("the quick brown fox jumped")
    vf.sum                   # => "euiooue"

### 9.4.1 Mixin中的实例变量
对于mixin来说，你要混入客户类中的模块，可能会在客户对象中创建实例变量，并可能使用`attr_reader`或类似方法，定义这些实例变量的访问方法：

    # tut_modules/observer_impl.rb
    module Observable
      def observers
        @observer_list ||= []   # 设置默认值为[]
      end
      def add_observer(obj)
        observers << obj       # 在数组observers的后面加入元素obj
      end
      def notify_observers
        observers.each {|o| o.update }   # 这个update是什么方法？参见后面28章的观察者（Observable）模块。
      end
    end

不过，一个mixin中的实例变量可能会和宿主类或其他mixin中的实例变量相冲突。运行时，程序可能产生某些难以诊断的错误行为。

多数时候，mixin模块不带有自己的实例数据 -- 它们只是使用访问方法从客户对象中去的数据。
但如果你创建的mixin不得不持有自己的状态，确保这个实例变量具有唯一的名字。也许使用模块名作为变量的一部分，
或者模块可以使用模块一级的散列表，以当前对象的ID作为索引，来保持特定于实例的数据，而不必使用ruby的实例变量。

    module Test
      State = {}           # 这是一个散列表，因此无需定义实例变量。
      def state=(value)
        State[object_id] = value        # 散列表中的object_id键对应value这个值。
      end
      def state
        State[object_id]
      end
    end
    class Client
      include Test
    end
    c1 = Client.new
    c2 = Client.new
    c1.state = 'cat'
    c2.state = 'dog'
    c1.state # => "cat"
    c2.state # => "dog"

A downside of this approach is that the data associated with a particular object will not get automatically deleted if the object is deleted. 
这种方法的一个缺点是与特定对象相关联的数据将不会被自动删除，如果该对象被删除。
In general, a mixin that requires its own state is not a mixin—it should be written as a class.
在一般情况下，混入需要其自身的状态时，不是一个mixin，它应该写成一类。

### 9.4.2 解析有歧义的方法名
ruby首先会从对象的直属类中查找，然后是类所包含的mixin，之后是超类以及超类的mixin。
如果一个类中有多个混入的模块，**最后一个**包含的模块将会被第一个搜索到。

## 　　9.5　包含其他文件
因为ruby可以使我们轻松编写良好的、模块化的代码，你会将这些文件组织为类或者库。
ruby有两个语句让我们在新的程序中结合使用它们。

每次当**load**方法执行时，都会将指定的ruby源文件包含进来。

    load 'filename.rb'

更常见的是**require**方法来加载制定的文件，且**只加载一次**。[4]

    require 'filename'

[4]严格来说并不是。ruby在数组$"中保存了被require所加载的文件列表。不过这个列表只包括了调用reuire时所指定的文件名。欺骗ruby让它多次加载同一个文件，是有可能的。如下面例子。但这个性能未来可能会更改：

    require '/usr/lib/ruby/1.9/English.rb'
    require '/usr/lib/ruby/1.9/rdoc/../English.rb'
    # $" → ["/usr/lib/ruby/1.9/English.rb", "/usr/lib/ruby/1.9/rdoc/../English.rb"]

被加载文件中的**局部变量不会蔓延**到加载它们所在的范围内。例如：

    # included.rb
    a = 1
    def b
      2
    end

当我们包含到另一文件中：

    a = "cat"
    b = "dog"
    require_relative 'included'
    p a    # "cat"
    p b    # "dog"
    p b()  # 2

require有额外功能：它可以**加载共享的二进制库**。

两者都可以**接受相对或绝对的路径**。
如果指定了一个相对路径，或者只是简单的名字，将会在当前加载路径中$:（见下面14.5编译环境一节）的每个目录下搜索这个文件。
使用load或者require所加载的文件，当然也可包含其他文件，而这些文件可以包含别的文件，以此类推。

要注意：require是一个**可执行的语句**。
它可能在一个if语句内，或者可能包含一个刚刚拼合的字符串。
搜索路径也可以在运行时更改，只需将目录添加到$:数组中。

因为**load会无条件地包含源文件**，可以使用它来重新加载一个程序开始执行后可能更改的源文件。如：

     5.times do |i|
       File.open("temp.rb","w") do |f|  # 写入一个temp.rb文件。
         f.puts "module Temp"
         f.puts " def Temp.var"
         f.puts " #{i}"   # 这个方法会输出i的值。
         f.puts " end"
         f.puts "end"
       end
       load "temp.rb"
       puts Temp.var   # 调用上面的方法，输出i的值。
     end
     # 输出:
     # 0
     # 1
     # 2
     # 3
     # 4

对于这个功能，可以考虑：web应用重新加载正在运行的模块。这让她能够动态更新自己；不需要重新启动来集成软件的新版本！

##     5.6 Inheritance, Mixins, and Design  继承、混合和设计 第四版新增
Inheritance and mixins both allow you to write code in one place and effectively inject that code into multiple classes. 
继承和混合都允许你将一个地方写就的代码注入到多个类中。
So, when do you use each?
那么你该在什么时候用上哪一个呢？

As with most questions of design, the answer is, well...it depends. 
很像设计的很多问题，答案是看看……
However, over the years developers have come up with some pretty clear general guidelines to help us decide. 
不管怎样，这么多年来开发者提供了一些相当清晰的准则来帮助我们做出决定。
 First let’s look at subclassing. 
先看看子类。
Classes in Ruby are related to the idea of types. 
ruby中的类和类型的理念相关。
It would be natural to say that "cat" is a string and [1,2] is an array. 
说cat是字符串，把[1,2]是数组，是很自然的事情。
And that’s another way of saying that the class of "cat" is String and the class of [1,2] is Array. 
也就是说cat属于String类，[1,2]属于Array类。
When we create our own classes, you can think of it as adding new types to the language. 
当我们创建自己的类别时，可以认为是将新的类别添加到语言中。
And when we subclass either a built-in class or our own class, we’re creating a subtype.
我们创建一个内建类或者自建类的子类时，我们创造了一个子类别。

Now, a lot of research has been done on type theories. 
现在，人们对类型理论做了很多探索。
One of the more famous results is the Liskov Substitution Principle. 
其中最出名的结果就是里氏替换原则。
Formally, this states, “Let q(x) be a property provable about objects x of type T.  Then q(y) should be true for objects y of type S where S is a subtype of T.” 
它的正式表述为：“”
<kinder:note> http://zh.wikipedia.org/wiki/Liskov%E4%BB%A3%E6%8F%9B%E5%8E%9F%E5%89%87的解释：
里氏替换原则的内容可以描述为： “派生类（子类）对象能够替换其基类（超类）对象被使用。” 以上内容并非利斯科夫的原文，而是译自罗伯特·马丁（Robert Martin）对原文的解读。
</kinder:note> 
What this means is that you should be able to substitute an object of a child class wherever you use an object of the parent class—the child should honor the parent’s contract.
这句话的意思是：你应该能够替换子类的对象，无论你使用父类的对象 -- 子类对象应该接受父类对象的抽象。

There’s another way of looking at this: we should be able to say that the child object is a kind of the parent. 
这可以从另一方面理解：我们应该能够说，子类是父类的一种。
We’re used to saying this in English: a car is a vehicle, a cat is an animal, and so on. 
我们在英语里经常说：car是轮子车，cat是动物，等等。
This means that a cat should, at the very least, be capable of doing everything we say that an animal can do.
这意味着一个cat应该，至少，能够做任何一个动物能做的事情。

So, when you’re looking for subclassing relationships while designing your application, be on the lookout for these is-a relationships.
这样，我们设计应用程序的同时查找子类关系的时候，一定留意这些属于关系。

But...here’s the bad news. 
不过，这里有个坏消息。
In the real world, there really aren’t that many true is a relationships. 
真实世界里，并不是真的就是关系。
 Instead, it’s far more common to have has a or uses a relationships between things. 
相反，更多的情况是在事物之间有一个或使用一个关系。
The real world is built using composition, not strict hierarchies.
真实世界是混合而成的，而不是层次分明的。

In the past, we’ve tended to gloss over that fact when programming. 
过去我们编程时，总是倾向于掩饰那个事实。
Because inheritance was the only scheme available for sharing code, we got lazy and said things like “My Person class is a subclass of my DatabaseWrapper class.” 
因为继承是共享代码唯一可以的方案，我们变得懒惰，说出类似“我的Person类是我的DatabaseWrapper类的子类”这样的话儿来。
(Indeed, the Rails framework makes just this mistake.) 
真的，Rails框架就是犯了这样的错误。
But a person object is not a kind of database wrapper object. 
但一个person对象不是一种数据库包装对象。
A person object uses a database wrapper to provide persistence services.
person对象使用数据库包装是为了提供一致服务。

Is this just a theoretical issue? No! 
这只是一个理论性的问题吗？不是。
Inheritance represents an incredibly tight coupling of two components. 
继承代表两个组件极其紧密的耦合。
Change a parent class, and you risk breaking the child class. 
改变一个父类，你可能会破坏子类。
But, even worse, if code that uses objects of the child class relies on those objects also having methods defined in the parent, then all that code will break, too. 
不过，更糟的是，如果子类对象使用的代码依赖那些将方法定义在父类中的对象，那所有那些代码也都会变坏。
The parent class’s implementation leaks through the child classes and out into the rest of the code. 
父类的执行将让所有子类产生漏洞，并退出后面的代码。
With a decent-sized program, this becomes a serious inhibitor to change.
作为一个大小体面的程序，这已经对更改代码造成一个严重的障碍。

And that’s why we need to move away from inheritance in our designs. 
这就是为什么我们在设计中要**远离继承**。
Instead, we need to be using composition wherever we see a case of A uses a B, or A has a B. 
相反，我们需要使用合成，无论我们看到a使用b的情况，还是a拥有一个b。
Our persisted Person object won’t subclass DataWrapper. 
我们坚持Person对象不能是DataWrapper的子类。
Instead, it’ll construct a reference to a database wrapper object and use that object reference to save and restore itself.
相反，这将，对数据库包装对象构成一个参考，并使用那些对象参考来保存和恢复自身。

But that can also make code messy. 
但那也会使代码变得凌乱。
And that’s where a combination of mixins and metaprogramming comes to the rescue, because we can say this:
这也是要联合混合和元编程来补救的地方，因为我们可以这样说：

    class Person
      include Persistable
      # ...
    end

instead of this:
而不是这样：

    class Person < DataWrapper
      # ...
    end

If you’re new to object-oriented programming, this discussion may feel remote and abstract.
如果你是面向对象编程的新手，这个讨论可能显得遥远和抽象。
But as you start to code larger and larger programs, we urge you to think about the issues discussed here. 
但你开始编写更大更大的程序代码，我们劝你考虑这个讨论的事情。
Try to reserve inheritance for the times where it is justified. 
尝试在正当的地方保留继承。
And try to explore all the cool ways that mixins let you write decoupled, flexible code.
尝试探索所有的酷炫方法，混合让你写出解藕的、弹性的代码。


# 　第10章　基本输入和输出
ruby提供了**两套乍看完全不同的I/O例程（routine）**。
第一套接口很简单：
print "Enter you name:"
name = gets
kernel模块实现了一整套I/O相关的方法：gets, open, print, printf, putc, puts, readline, readlines, test。它们使得ruby编程简便。
她们通常对标准输入和标准输出进行操作，因而很适合用它们来编写过滤器。详见后面27章内建类的相关文档。
## 　　10.1　什么是 IO 对象
ruby定义了一个IO基类来处理输入和输出。
类File和BasicSocket都是该基类的子类；虽然她们提供了更具体的行为，但基本原则是相同的。
IO对象是ruby程序和某些外部资源[1]之间的一个双向通道；最终你所要做的只是向它写入或者从中读取。
本章重点介绍IO类和最常用子类File。
使用套接字类进行网络操作参见后面763页附录A套接字库。
[1]对那些想知道实现细节的人来说，这意味着一个IO对象可以管理操作系统的多个文件描述符。
## 　　10.2　文件打开和关闭
可以使用**File.new**来创建一个新的文件对象。

    file = File.new("testfile", "r")
    # ... 处理该文件
    file.close

根据打开模式，你可以创建一个用来读、写或者兼有两者的文件对象。（完整模式列表见后面504页）
创建一个文件时，你还可以指定文件的许可权限。详见470页的描述。
打开文件后，我们可以写入或者读取所需的数据。
最后我们需要关闭文件，确保所有缓存的数据被写入文件，释放所有相关资源。

在new方法之下，处理文件的过程如果发生异常，可能file.close不会被调用。
一旦file变量出了其作用域，垃圾收集器最终会把它关闭，但可能一时半会不会发生，资源一直被占用。
**File.open**也可以打开文件。通常它和File.new行为相似，但和block一起调用时有区别。
它不会返回一个新的File对象，而是以刚打开的文件为参数调用相关联的block，block退出时，文件自动关闭。

    File.open("testfile", "r") do |file|
      # ... 文件处理
    end

open方法类似实现下面的代码：

    class File
      def File.open(*args)
        result = f = File.new(*args)
        if block_given?
          begin
            result = yield f
          ensure
            f.close
          end
        end
        return result
      end
    end

## 　　10.3　文件读写
用于简单I/O的所有方法都适用于文件对象。
**gets**从标准输入读取一行，或者从执行脚本的命令行上指定的任意文件

    $ cat copy.rb
    while line = gets
      puts line
    end
    $ ruby copy.rb
    These are lines
    These are lines
    that I am typing
    that I am typing
     

**file.gets**从文件对象file中读取一行。

    $ ruby copy.rb testfile
    This is line one
    This is line two
    This is line three
    And so on ...

还可以**显式的打开文件**，并从中提取数据。

    File.open("testfile") do |file|
      while line = file.gets
        puts line
      end
    end

### 10.3.1 读取迭代器
既可以使用普通循环从IO流中读取数据，也可使用各种迭代器读取，它们使变成更容易。
`IO#each_byte`从IO对象中获得下一个8位字节为参数，调用关联的block

    File.open("testfile") do |file|
      file.each_byte {|ch| putc ch; print "." }
    end
    # produces:
    # T.h.i.s. .i.s. .l.i.n.e. .o.n.e.
    # .T.h.i.s. .i.s. .l.i.n.e. .t.w.o.
    # .T.h.i.s. .i.s. .l.i.n.e. .t.h.r.e.e.
    # .A.n.d. .s.o. .o.n.......

    # 这是第四版的例子：
    File.open("testfile") do |file|
      file.each_byte.with_index do |ch, index|
        print "#{ch.chr}:#{ch} "
        break if index > 10
      end
    end
    # produces:
    # T:84 h:104 i:105 s:115
    # :32 i:105 s:115
    # :32 l:108 i:105 n:110 e:101


`IO#each_line`以文件的一行为参数调用想关联的block

    File.open("testfile") do |file|
      file.each_line {|line| puts "Got #{line.dump}" }
      # String#dump方法显示换行符
    end
    # produces:
    # Got "This is line one\n"
    # Got "This is line two\n"
    # Got "This is line three\n"
    # Got "And so on...\n"

    File.open("testfile") do |file|
      file.each_line("e") {|line| puts "Got #{ line.dump }" }
      # 将e设置为行分隔符
    end
    # produces:
    # Got "This is line"
    # Got " one"
    # Got "\nThis is line"
    # Got " two\nThis is line"
    # Got " thre"
    # Got "e"
    # Got "\nAnd so on...\n"

`IO.foreach`方法以IO数据源的名字作为参数，以读模式打开它，并以文件中的每一行为参数调用关联的迭代器，最后自动关闭文件。

    I0.foreach("testfile") {|file| puts line }

还可以将整个文件的内容读取到一个字符串或者一个行数组中。

    # 读进字符串
    str = IO.read("testfile")
    str.length → 66
    str[0, 30] → "This is line one\nThis is line "
    # 读进数组
    arr = IO.readlines("testfile")
    arr.length → 4
    arr[0] → "This is line one\n"

不要忘了在不确定的世界里，I/O也是不确定的——大多数错误会引发异常，需要采取适当的行动从错误中恢复。
### 10.3.2 写文件
puts和print传递任意已存在的对象作为参数，ruby怎么处理呢？
除了少数例外，传递给puts和print的**任意对象**都会被对象的`to_s`转换成一个字符串。
如果由于某种原因，`to_s` 方法未能返回一个合法的字符串，就会创建一个含有对象类名和ID的字符串，类似于`#<ClassName:0x123456>`
**nil对象**会输出字符串nil
传递给puts的**数组**会一次将它的元素打印出来，就好象每个元素被分别传递给puts一样
想写入**二进制数据**而不想给ruby干扰，可以调用IO#pint，以包括待写入字节的字符串为参数。还可以使用底层的输入输出例程，详见后面514页的IO#sysread和IO#syswrite文档。
我们如何才能将二进制数据存储到字符串中呢?通常有三个方法：

- 字符串的字面量；
- 一个字节一个字节存入;
- 使用Array#pack。

    str1 = "\001\002\003"    →   "\001\002\003"
    str2 = ""                
    str2 << 1 << 2 << 3      →   "\001\002\003" 
    [ 1, 2, 3 ].pack("c*")   →   "\001\002\003"   # <kinder:note> ("c*")是什么意思？ 装包，后面27章内建类会把详情告诉你。

如果你怀念C++的iostream，可以使用`<<`操作符添加对象到IO输出流，就好象添加一个对象到数组一样。
方法`<<`使用`to_s`将参数转换成字符串，再按照它的方式传递。

    endl = "\n"
    STDOUT << 99 << " red balloons" << endl
    # produces:
    # 99 red balloons

因为其他类，例如String和Array也实现了相似的语法，所以使用`<<`编写代码来附加某些东西，不必关心是添加到数组、字符串还是文件。这种灵活性使得单元测试比较简单。后面365也的鸭子类型一章会更详细讨论这种思想。

**使用字符串I/O**
很多时候需要处理假定读写一个或多个文件的代码，但数据并不位于文件中：或许是SOAP服务产生的数据，或是从命令行传递来的参数，也可能是正在运行单元测试但不想改变真正的文件系统。
StringIO对象，行为很像其他I/O对象，但它们读写的是字符串，而不是文件。
如果你为读而打开一个StringIO对象，需要提供一个字符串给它。
同样，如果想向StringIO对象写入时，需要传递一个带填充的字符串。

    require 'stringio'
    ip = StringIO.new("now is\nthe time\nto learn\nRuby!")
    op = StringIO.new("", "w")
    ip.each_line do |line|
      op.puts line.reverse    # 将line.reverse放入op变量。
    end
    op.string → "\nsi won\n\nemit eht\n\nnrael ot\n!ybuR\n"

## 　　10.4　谈谈网络
ruby善于处理网络协议，无论是底层协议还是高层协议
ruby的**套接字库**提供了一组类，访问TCP UDP SOCK Unix域套接字，已经在体系结构上支持的任意其他套接字类型。详见后面763页。
库中还提供了辅助类，使得写服务器程序更容易。
如下面使用finger协议获取本地机器上用户“mysql”的信息。

    require 'socket'
    client = TCPSocket.open('127.0.0.1', 'finger')
    client.send("mysql\n", 0)     # 0 means standard packet
    puts client.readlines
    client.close
    # produces:
    # Login: mysql               Name: MySQL Server
    # Directory: /var/empty      Shell: /usr/bin/false
    # Never logged in.
    # No Mail.
    # No Plan.

第四版的例子
Here’s a simple program that gets information about our user website on a local web server using the HTTP OPTIONS request
这是一个简单的程序，使用 HTTP OPTIONS 请求获得关于本地web服务器我们的用户站点信息

    require 'socket'
    client = TCPSocket.open('127.0.0.1', 'www')
    client.send("OPTIONS /~dave/ HTTP/1.0\n\n", 0)      # 0 means standard packet 
    puts client.readlines
    client.close
    # produces:
    # HTTP/1.1 200 OK
    # Date: Mon, 27 May 2013 17:31:00 GMT
    # Server: Apache/2.2.22 (Unix) DAV/2 PHP/5.3.15 with Suhosin-Patch mod_ssl/2.2.22
    # OpenSSL/0.9.8r
    # Allow: GET,HEAD,POST,OPTIONS
    # Content-Length: 0
    # Connection: close
    # Content-Type: text/html


在较高的层次上，**lib/net库**提供了一组模块来处理应用层协议（目前支持FTP HTTP POP SMTP telnet），详细参见后面698页。
如下面的程序列出该主页显示的所有图片。

    require 'net/http'
    h = Net::HTTP.new('www.pragmaticprogrammer.com', 80)
    response = h.get('/index.html', nil)
    if response.message == "OK"
      puts response.body.scan(/<img src="(.*?)"/m).uniq
    end
    # produces:
    # images/title_main.gif
    # images/dot.gif
    # /images/Bookshelf_1.5_in_green.png
    # images/sk_all_small.jpg
    # images/new.jpg

这里例子还有很大的改进空间。特别是没有任何错误处理（如报告404错误），还需要能处理重定向。
还可以在更高层进行处理。通过装载**open-uri库**到程序中，方法Kernel.open立刻就可以识别文件名中的http://和ftp://等URL，还能自动处理重定向。

    require 'open-uri'
    open('http://www.pragmaticprogrammer.com') do |f|
      puts f.read.scan(/<img src="(.*?)"/m).uniq
    end
    # produces:
    # images/title_main.gif
    # images/dot.gif
    # /images/Bookshelf_1.5_in_green.png
    # images/sk_all_small.jpg
    # images/new.jpg

    # 第四版的例子：
    require 'open-uri'
    open('http://pragprog.com') do |f|
      puts f.read.scan(/<img alt=".*?" src="(.*?)"/m).uniq[0,3]
    end
    # produces:
    # http://pragprog.com/assets/logo-c5c7f9c2f950df63a71871ba2f6bb115.gif
    # http://pragprog.com/assets/drm-free80-9120ffac998173dc0ba7e5875d082f18.png
    # http://imagery.pragprog.com/products/353/jvrails2_xlargebeta.jpg?1368826914

详见后面235页18章关于在因特网上使用Ruby的更多信息。
## 11.5 Parsing HTML 解析HTML
Having read HTML from a website, you might want to parse information out of it. 
从一个站点读入HTML之后，你可能想剖析它的信息。
Often, simple regular expressions do the job. 
一般，简单的正则表达式可以干这个活。
In the example that follows, we’re using the %r{...} regular expression literal, because the match contains a forward slash character, and regular expressions are complex enough without having to add extra backslashes.
下面的例子中，我们使用正则表达式字面量%r{...}，因为模式包含一个前斜线字符，正则表达式足够复杂无需添加额外的反斜线。

    require 'open-uri'
    page = open('http://pragprog.com/titles/ruby3/programming-ruby-1-9').read
    if page =~ %r{<title>(.*?)</title>}m
      puts "Title is #{$1.inspect}"
    end
    # produces:
    # Title is "The Pragmatic Bookshelf | Programming Ruby 1.9"

But regular expressions won’t always work. 
但正则表达式并不总是能行。
For example, if someone had an extra space in the `<title>` tag, the match would have failed. 
比如，如有人有一个额外的空格在`<title>`标签，匹配就会失败。
For real-world use, you probably want to use a library that can parse HTML (and XML) properly. 
在真实运用里，你可能想使用一个能正确解析HTML和XML的库。
Although not part of Ruby, the Nokogiri library is very popular. 
虽然不是ruby的一部分，Nokogiri库却十分流行。
It’s a very rich library—we’ll only scratch the surface here. 
这是一个非常rich的库 -- 我们这里只用点皮毛。
Documentation is available inside the gem.
gem里面有它的文档。

    require 'open-uri'
    require 'nokogiri'
    doc = Nokogiri::HTML(open("http://pragprog.com/"))
    puts "Page title is " + doc.xpath("//title").inner_html
    # Output the first paragraph in the div with an id="copyright"
    # (nokogiri supports both xpath and css-like selectors)
    puts doc.css('div#copyright p')
    # Output the second hyperlink in the site-links div using xpath and css
    puts "\nSecond hyperlink is"
    puts doc.xpath('id("site-links")//a[2]')
    puts doc.css('#site-links a:nth-of-type(2)')
    # produces:
    # Page title is The Pragmatic Bookshelf
    <p>
        The <em>Pragmatic BookshelfTM</em> is an imprint of
            <a href="http://pragprog.com/">The Pragmatic Programmers, LLC</a>.
        <br>
        Copyright © 1999–2013 The Pragmatic Programmers, LLC.
        All Rights Reserved.
    </p>
    Second hyperlink is
    <a href="http://pragprog.com/about">About Us</a>
    <a href="http://pragprog.com/about">About Us</a>

Nokogiri can also update and create HTML and XML.
Nokogiri也可以更新和创建HTML和XML。

# 　第11章　纤程、线程和进程  
<kinder:note> ruby1.9出现fibers（纤程）
ruby有几种基本方式组织程序，可以“同时”运行程序的不同部分。
Fibers let you suspend execution of one part of your program and run some other part.
纤程让你暂停执行程序的一部分，运行其他部分。
使用多线程可以在程序内部把相互协作的任务分开。
使用多进程将任务分解到不同的程序。
##     12.1  纤程Fiber
Ruby 1.9 introduced fibers. 
Although the name suggests some kind of lightweight thread, Ruby’s fibers are really just a very simple coroutine mechanism. 
虽然名字暗示的一种轻量级线程，Ruby的纤维是真的只是一个非常简单的协同机制。
They let you write programs that look like you are using threads without incurring any of the complexity inherent in threading. 
他们让你写的程序，就像你使用线程，但不产生任何线程的固有的复杂性。
Let’s look at a simple example. 
让我们看个简单的例子。
We’d like to analyze a text file, counting the occurrence of each word. 
我们要分析一个文本文件，数数每个单词的出现次数。
We could do this (without using fibers) in a simple loop:
我们可以在一个简单的循环中完成任务，无需使用纤程：

    counts = Hash.new(0)
    File.foreach("testfile") do |line|
      line.scan(/\w+/) do |word|
        word = word.downcase
        counts[word] += 1
      end
    end
    counts.keys.sort.each {|k| print "#{k}:#{counts[k]} "}
    # produces:
    # and:1 is:3 line:3 on:1 one:1 so:1 this:3 three:1 two:1

However, this code is messy—it mixes word finding with word counting. 
不过，这个代码有些凌乱 -- 弄混了单词计数和找到的单词
We could fix this by writing a method that reads the file and yields each successive word. 
我们可以修复，通过写一个方法来读取文件并产生每个连续的词汇。
But fibers give us a simpler solution:
但纤程给了我们一个简单的解决方案：

    words = Fiber.new do                         # 产生一个纤程（同时赋值给变量words）来干这个块代码的事情。
      File.foreach("testfile") do |line|
        line.scan(/\w+/) do |word|
          Fiber.yield word.downcase              # 这个yield和block的yield含义不同。这个yield将流程掉转到调用纤程的地方。即下面的while那一行。
        end
      end
      nil                                       # 这是纤程的最后一个表达式，也是最后一个纤程的返回值。
    end
    counts = Hash.new(0)
    while word = words.resume                   # resume方法让上面的yield继续执行。
      counts[word] += 1
    end
    counts.keys.sort.each {|k| print "#{k}:#{counts[k]} "}
    # produces:
    # and:1 is:3 line:3 on:1 one:1 so:1 this:3 three:1 two:1

<kinder:note> 简单循环能做的事情，要纤程干什么？效率更高吗？高多少？
The constructor for the Fiber class takes a block and returns a fiber object. 
纤程类的构造函数执行block，并返回一个纤程对象。
For now, the code in the block is not executed.
现在，该块中的代码是不被执行的。

Subsequently, we can call resume on the fiber object. 
随后，我们能在纤程对象调用resume(重新开始，重开)
This causes the block to start execution. 
这导致block开始执行。
 The file is opened, and the scan method starts extracting individual words. 
文件已被打开，scan方法开始提取各个单词。
However, at this point, Fiber.yield is invoked. 
不过在这个时候，Fiber.yield被调用了。
This suspends execution of the block—the resume method that we called to run the block returns any value given to Fiber.yield.
这挂起block的执行 -- 我们调用来运行区块的resume(重开)方法返回任何指定给Fiber.yield的值。<kinder:note> 这个值应该就是word.downcase

Our main program enters the body of the loop and increments the count for the first word returned by the fiber. 
我们的主程序进入了循环的主体，为纤程所返回的第一个单词增加计数。
It then loops back up to the top of the while loop, which again calls words.resume while evaluating the condition. 
循环返回到最顶的while循环，当评估条件时再次调用word.resume
The resume call goes back into the block, continuing just after it left off (at the line after the Fiber.yield call).
resume调用返回到block里，在离开（在Fiber.yield调用之后的那行）之后就继续。

When the fiber runs out of words in the file, the foreach block exits, and the code in the fiber terminates. 
纤程提取完文件里的单词时，foreach区块退出，纤程里的代码终结。
Just as with a method, the return value of the fiber will be the value of the last expression evaluated (in this case the nil).[1] 
正如一个方法，纤程的返回值是最后一个表达式的值（在这种情况下，nil）。
The next time resume is called, it returns this value nil. 
下一次调用resume，它返回这个值nil。
You’ll get a FiberError if you attempt to call resume again after this.
如果你稍后尝试再次调用resume，你将得到一个FiberError。

[1].In fact, the nil is not strictly needed, as foreach will return nil when it terminates. The nil just makes it explicit.
事实上，nil严格来说并不需要，因为foreach将在结束时返回nil。nil只是为了让它更明确。

ibers are often used to generate values from infinite sequences on demand. 
Fibers通常用来按要求从无限序列中产生值。
Here’s a fiber that returns successive integers divisible by 2 and not divisible by 3:
这里是一个纤程，返回连续的整数，可被2整除，但不能被3整除。
<kinder:note> 这种写法真是太有意思了！还不用lambda。

    twos = Fiber.new do
      num = 2
      loop do
        Fiber.yield(num) unless num % 3 == 0
        num += 2
      end
    end
    10.times { print twos.resume, " " }
    # produces:
    # 2 4 8 10 14 16 20 22 26 28

Because fibers are just objects, you can pass them around, store them in variables, and so on. 
因为纤程只是对象，你可以四处将它传递，保存在变量里，等等。
Fibers can be resumed only in the thread that created them.
纤程只能在创建他们的线程中resume（重开）。

⇡New in 2.0⇣**惰性枚举**
Ruby 2.0 adds a new twist to this—you can now use lazy enumerators to gracefully handle infinite lists. 
Ruby 2.0增加一个手法 -- 你现在可以使用惰性枚举来优雅地处理无限列表。
These are described Lazy Enumerators in Ruby 2, on page 61.
详见ruby2惰性枚举的描述，在前面61页。

### Fibers, Coroutines, and Continuations 纤程，协程和延续
The basic fiber support in Ruby is limited—fibers can yield control only back to the code that resumed them. 
ruby里基本的纤程支持是有限的 -- 纤程可以产生的控制，只能返回到resumed（重开）它们的代码去。
However, Ruby comes with two standard libraries that extend this behavior. 
不过，ruby提供两个标准库进行扩展。
The fiber library (described in the library section on page 755) adds full coroutine support. 
fiber库（在后面755页的库那一章有详述）增加了完整的协程支持。
Once it is loaded, fibers gain a transfer method, allowing them to transfer control to arbitrary other fibers.
只要被导入，纤程就可获得transfer方法，允许他们转化控制到任意其他纤程去。

A related but more general mechanism is the continuation. 
一个相关但普通的机制是连续体。
A continuation is a way of recording the state of your running program (where it is, the current binding, and so on) and then resuming from that state at some point in the future. 
连续体是记录运行程序(在哪里，当前绑定什么，等等)的途径，然后从未来某点的状态resuming（重开）。
You can use continuations to implement coroutines (and other new control structures). 
你可以使用连续体来完成协程（和其他新的控制结构）。
Continuations have also been used to store the state of a running web application between requests—a continuation is created when the application sends a response to the browser; then, when the next request arrives from that browser, the continuation is invoked, and the application continues from where it left off. 
连续体也已经被用来存储运行的web应用的请求状态 -- 当应用发送一个应答给浏览器时，便创建了一个连续体；然后浏览器的下一个请求到达，调用该连续体，程序从它离开的地方继续运行。
You enable continuations in Ruby by requiring the continuation library, described in the library section on page 739.
在ruby你通过导入contiuation库激活延续，详情在后面739页的标准库一节。

## 　　11.1　多线程
**线程的优劣**
线程完全在进程内部，并在ruby解释器内实现。
因此ruby线程是彻底可移植的，不依赖于操作系统。
这是一种有效的轻量级方法，可以使代码达到并行化。
只需理解这些底层的实现问题并依次进行设计。

但同时也无法获得本地线程所带来的益处。比如
- 线程饿死（低优先级线程得不到机会运行）；
- 如果线程死锁了，整个进程可能会宕掉；
- 如果一个线程碰巧进行了一个需要长时间完成的操作系统调用，所有线程会被挂起知道解释器重新得到控制为止；
- 如果机器有多个处理器，则ruby线程利用不了这个事实

听起来挺吓人。实际上很多情况下使用线程的益处远远超出了可能会出现的任何潜在困难。
<kinder:note> 第四版的说明：ruby 1.9的改进
Often the simplest way to do two things at once is to use Ruby threads. 
经常同时做两件事的最简单的方法是使用Ruby线程。
Prior to Ruby 1.9, these were implemented as green threads—threads were switched within the interpreter. 
红宝石1.9之前，这些都由绿色的线程来实现 -- 就是切换在解释器的线程。
In Ruby 1.9, threading is now performed by the operating system. 
在Ruby 1.9，**线程由操作系统实现**。
This is an improvement, but not quite as big an improvement as you might want. 
这是一个进步，但和你的希望相比进步不太大
Although threads can now take advantage of multiple processors (and multiple cores in a single processor), there’s a major catch. 
尽管线程现在可以充分利用多个处理器（和多核的单处理器），但有一个主要的不利之处。
Many Ruby extension libraries are not thread safe (because they were written for the old threading model). 
许多 Ruby 扩展库不是线程安全的（因为他们是为旧的线程模型写的）。
So, Ruby compromises: it uses native operating system threads but operates only a single thread at a time. 
因此，Ruby妥协：它使用本地操作系统线程，但在一个时刻仅操作在一个线程。
You’ll never see two threads in the same application running Ruby code truly concurrently. 
你永远也看不到同一应用程序中的两个线程真正同时运行Ruby代码。
(You will, however, see threads busy doing, say, I/O while another thread executes Ruby code. 
（你会的，不过，看到线程忙着，比如，I/O；而另一个线程执行Ruby代码。
That’s part of the point.)
这是问题的一部分。）

### 11.1.1 创建ruby线程
#### 创建
下面这段代码创建一个单独的线程去下载一组网页。

    require 'net/http'
    pages = %w( www.rubycentral.com slashdot.org www.google.com )
    threads = []
    for page_to_fetch in pages    # 利用循环在下面分别建立三个线程。
      threads << Thread.new(page_to_fetch) do |url|
        h = Net::HTTP.new(url, 80)
        puts "Fetching: #{url}"
        resp = h.get('/', nil )
        puts "Got #{url}: #{resp.message}"
      end
    end
    threads.each {|thr| thr.join }
    # produces:
    # Fetching: www.rubycentral.com
    # Fetching: slashdot.org
    # Fetching: www.google.com
    # Got www.google.com: OK
    # Got www.rubycentral.com: OK
    # Got slashdot.org: OK

为什么不是简单在block里直接使用page_to_fetch变量的值呢？
因为线程共享的原因。3个线程会共享page_to_fetch变量。如果使用page_to_fetch变量的第一个线程还没有结束，它会突然开始使用新的值。很难发现这种类型的错误。

不过，在线程block里创建的局部变量对线程来说是真正的局部变量——每个线程会有这些变量的私有备份。在上面这个例子中，url变量会在每次线程创建时被设置，因而每个线程都有自己的e网页地址的备份。

下面是第四版的例子，输出是一样的：

    require 'net/http'
    pages = %w( www.rubycentral.org slashdot.org www.google.com )
    threads = pages.map do |page_to_fetch|     # 和第二版相比，这一行浓缩了上面几行
      Thread.new(page_to_fetch) do |url|
        http = Net::HTTP.new(url, 80)
        print "Fetching: #{url}\n"
        resp = http.get('/')
        print "Got #{url}: #{resp.message}\n"
      end
    end
    threads.each {|thr| thr.join }

#### 操作线程
ruby程序终止时，不管线程的状态如何，所有线程都被杀死。
调用线程的Thread#join方法来阻塞，等待特定线程的正常结束。
如果不想永远阻塞，可以给予join一个超时参数。
Thread#value方法是join的变种，返回线程执行的最后语句的值。
Thread#current可以得到当前线程。
Thread#list得到所有线程e列表，返回包含所有可运行或被停止的线程对象。
Thread#status和Thread#alive?确定特定线程的状态。
Thread#priority=调整线程的优先级。更高优先级的线程会在低优先级的线程前面运行。

#### 线程变量
线程通常可以访问在它创建时其作用范围内的任何变量。
线程block里面的局部变量是线程的局部变量，没有被共享。
但如果需要线程局部变量能被别的线程访问，Thread允许通过名字来创建和访问线程局部变量。可以简单地将线程对象看作一个散列表，使用[]=写入元素并使用[]把它们读出。

     count = 0
     threads = []
     10.times do |i|
       threads[i] = Thread.new do
         sleep(rand(0.1))  # 让线程等待一个随机长度的时间。
         Thread.current["mycount"] = count
         # 通过mycount，线程把count变量的当前值记录到线程局部变量中。<kinder:note> 这个变量和值构成了线程的一个元素。
         count += 1
       end
     end
     threads.each {|t| t.join; print t["mycount"], ", " }
     # 读取时，代码使用字符串mycount对线程对象进行索引。[1]
     puts "count = #{count}"
     # produces:
     # 4, 1, 0, 8, 7, 9, 5, 6, 3, 2, count = 10

[1] 这里存在一个竞态条件(race condition)。
竞态条件出现在当两段或多段代码（或硬件）都试图访问一些共享资源时，在这里结果会随着它们执行的次序而改变。在这个例子中，有可能一个线程将其mycount变量的值设置给count，但是在它有机会增加count之前，这个线程被调度了出去，而另一个线程重用了相同的count值。这个问题可以通过对共享资源的访问（如count变量）进行同步解决。
<kinder:note> 这个“增加count之前，这个线程被调度了出去”，怎么会呢？后面的“访问”是怎么"同步解决"的？

<kinder:note> 第四版的例子：

    count = 0
    threads = 10.times.map do |i|           # 只有这一句和上面的例子不同。
      Thread.new do
        sleep(rand(0.1))
        Thread.current[:mycount] = count
        count += 1
      end
    end
    threads.each {|t| t.join; print t[:mycount], ", " }
    puts "count = #{count}"
    # produces:
    # 7, 0, 6, 8, 4, 5, 1, 9, 2, 3, count = 10


### 11.1.2 线程和异常
如果线程引发了未处理的异常，会发生什么呢？这依赖与abort_on_exception标志（详见后面633页和636页）和解释器debug标志（详见后面178页）的设置。
如果abort_on_exception是false，debug标志没有启用（默认条件），未处理异常会简单杀死当前线程，其他线程继续运行。实际上，除非对引发这个异常的线程调用了join，根本不知道这个异常存在。
例子一：

     threads = []
     4.times do |number|                         # 新建4个线程
       threads << Thread.new(number) do |i|
         raise "Boom!" if i == 2     # 这里抛出异常
         print "#{i}\n"
       end
     end
     threads.each {|t| t.join }      # 这里使用join方法，因此下面输出异常信息。
     # produces:
     # 0
     # 1
     # 3
     # prog.rb:4: Boom! (RuntimeError)
     # from prog.rb:8:in `join'
     # from prog.rb:8
     # from prog.rb:8:in `each'
     # from prog.rb:8

例子二：

    threads = []
    4.times do |number|
      threads << Thread.new(number) do |i|
        raise "Boom!" if i == 2
        print "#{i}\n"
      end
    end
    threads.each do |t|
      begin                # 没有问题的线程在这里输出
        t.join
      rescue RuntimeError => e       # 异常的线程在这个输出
        puts "Failed: #{e.message}"
      end
    end
    # produces:
    # 0
    # 1
    # 3
    # Failed: Boom!

但是，设置abort_on_exception为true，或者使用-d选项去打开debug标志，未处理的异常会杀死所有正在运行的线程。一旦线程2退出，不会产生更多输出。
<kinder:note> 在ruby2,这个特性已经改变。

     Thread.abort_on_exception = true
     threads = []
     4.times do |number|
       threads << Thread.new(number) do |i|
         raise "Boom!" if i == 2
         print "#{i}\n"
       end
     end
     threads.each {|t| t.join }
     # produces:
     # 0
     # 1
     # prog.rb:5: Boom! (RuntimeError)
     # from prog.rb:4:in `initialize'
     # from prog.rb:4:in `new'
     # from prog.rb:4
     # from prog.rb:3:in `times'
     # from prog.rb:3

这段代码也说明了一个容易犯错的地方：循环里面，线程使用print而不是puts去输出数字。
因为幕后puts的工作被分成两部分：输出参数，然后输出回车换行符。在这两个动作之间，一个线程可能得到调用，因而输出会交织在一起。
使用已经包含回车换行符的字符串作为参数调用print，则规避了这个问题。

<kinder:note> 第四版的例子：

    threads = 4.times.map do |number|
      Thread.new(number) do |i|
        raise "Boom!" if i == 1
        print "#{i}\n"
      end
    end
    puts "Waiting"
    sleep 0.1
    puts "Done"
    # produces:
    # 0
    # 2
    # Waiting
    # 3
    # Done          #线程1的输出不见了。因为没有使用join方法。

You normally don’t sleep waiting for threads to terminate—you’d use join. 
一般你不用seep来等待线程的结束 -- 你应该使用join。
If you join to a thread that has raised an exception, then that exception will be raised in the thread that does the joining:
如果你join一个已经抛出异常的线程，异常在join的线程里抛出

    threads = 4.times.map do |number|
      Thread.new(number) do |i|
        raise "Boom!" if i == 1
        print "#{i}\n"
      end
    end
    puts "Waiting"
    threads.each do |t|
      begin
        t.join
      rescue RuntimeError => e
        puts "Failed: #{e.message}"
      end
    end
    puts "Done"
    # produces:
    # 0
    # Waiting
    # 2
    # 3
    # Failed: Boom!         这是线程1抛出了异常。多亏了join方法。
    # Done

However, set abort_on_exception to true or use -d to turn on the debug flag, and an unhandled exception kills the main thread, so the message Done never appears. 
不过，设置 abort_on_exception 为true，或者使用-d选项来打开调试标志，未处理异常会杀死主线程，所以Done不会出现。
(This is different from Ruby 1.8, where the exception killed all running threads.)
（这和ruby1.8不同，在1.8里异常会杀死所有运行线程）
<kinder:note> 这两行的表述不太一样：上行是“主线程”，下行是“所有运行线程”。下面的例子和上面第2版的例子区别在于：下面的异常显示`<main>`。不过这两个表述的效果应该是一样的吧？主线程一终结，其他线程也会跟着终结吧。不是吗？

    Thread.abort_on_exception = true
    threads = 4.times.map do |number|
      Thread.new(number) do |i|
        raise "Boom!" if i == 1
        print "#{i}\n"
      end
    end
    puts "Waiting"
    threads.each {|t| t.join }
    puts "Done"
    # produces:
    # 0
    # 2
    # prog.rb:4:in `block (2 levels) in <main>': Boom! (RuntimeError)


## 　　11.2　控制线程调度器
在设计良好的程序中，你通常只是让线程做它该做的事情。多线程程序中建立时间依赖性，通常被认为是糟糕的设计，因为这会导致代码复杂化同时阻碍线程调度器优化程序执行。
但有时需要显式的控制线程。
调用Thread#stop停止当前线程
调用Thread#run安排运行特定的线程。
调用Thread#pass把当前线程调度出去，允许运行别的线程。
Thread#join和Thread#value挂起调用她们的线程，直到指定的线程结束为止。
<kinder:note> 下面的内容是第四版补充的。
These last two are the only low-level thread control methods that the average program should use. 
最后两种是低水平线程控制方法，一般的程序会使用他们。
In fact, we now consider most of the other low-level thread control methods too dangerous to use correctly in programs we write.[3] 
事实上，我们现在考虑得最多的是其他低水平线程控制方法太危险了，在我们写程序时很难正确使用。
 Fortunately, Ruby has support for higher-level thread synchronization.  
幸运的是，ruby支持高水平的线程同步。
[3]. And, worse, some of these primitives are unsafe in use. 
更糟糕的是，这些原始的在使用中是不安全的。
Charles Nutter of JRuby fame has a blog post that illustrates one problem: http://blog.headius.com/2008/02/rubys-threadraise-threadkill-timeoutrb.html.
JRuby fame的Charles Nutter有一个博客展示了一个问题。
<kinder:note> 下面的例子在第四版被删除了。
例子：

    class Chaser
      attr_reader :count
      def initialize(name)
        @name = name
        @count = 0
      end
      def chase(other)
        while @count < 5
          while @count - other.count > 1
            Thread.pass
          end
          @count += 1
          print "#@name: #{count}\n"
        end
      end
    end
    c1 = Chaser.new("A")
    c2 = Chaser.new("B")
    threads = [               # 创建两个线程。并且先挂起线程
                Thread.new { Thread.stop; c1.chase(c2) },
                Thread.new { Thread.stop; c2.chase(c1) }
              ]
    start_index = rand(2)     # 随机决定一个线程先启动
    threads[start_index].run
    threads[1 - start_index].run
    threads.each {|t| t.join }
    # produces:
    # B:1    首先是B线程运行。
    # B:2     @count大于1,因此下面调度了第一线程
    # A:1     不过下面为什么会调度第二线程呢？毕竟这里2-2=0,不是大于1啊。中文版的结果在下面，更容易理解。
    # B:3
    # A:2
    # B:4
    # A:3
    # B:5
    # A:4
    # A:5
    # 中文2版的结果：<kinder:note>可惜这段代码在ruby2中运行不了:提示符总在闪烁，没有输出。哪个语法改变了？
    #  A: 1
    #  A: 2
    #  B: 1
    #  B: 2
    #  B: 3
    #  B: 4
    #  A: 3
    #  A: 4
    #  A: 5
    #  B: 5

但在实际的代码中使用这些原语(primitive)实现同步并不是一件容易的事情 -- 竞态条件总会趁机咬你一口。同时，处理共享数据时，竞态条件总是带来漫长且令人沮丧的调试阶段。
上面的例子包含了这样的错误：有可能在一个线程中count被增加了，但在count被输出之前，第二个线程得到调度并且输出了count，这个输出结果将会是乱序的。

## 　　12.4  互斥  这是第四版的内容
Let’s start by looking at a simple example of a race condition—multiple threads updating a shared variable:
让我们开始吧，看看一个简单的竞态条件的例子 -- 多线程更新一个共享变量。

    sum = 0
    threads = 10.times.map do
      Thread.new do
        100_000.times do
          new_value = sum + 1
          print "#{new_value}  " if new_value % 250_000 == 0
          sum = new_value
        end
      end
    end
    threads.each(&:join) # 注意这是新的写法。 旧的写法应该是`threads.each {|t| t.join}`；关于&:见前面5.4.2。
    puts "\nsum = #{sum}"
    
    # produces:
    # 250000 250000 250000 250000 250000 500000 500000
    # sum = 599999


We create 10 threads, and each increments the shared sum variable 100,000 times. 
我们创建了是个线程，每个线程增加共享的sum变量100,000次。
And yet, when the threads all finish, the final value in sum is considerably less than 1,000,000. 
不过，线程结束时，sum最后的值却明显少于1,000,000。
Clearly we have a race condition. 
很明显，我们有个竞态条件。
The reason is the print call that sits between the code that calculates the new value and the code that stores it back into sum. 
原因是print调用位于计算新值的代码和存储返回sum的代码之间。
In one thread, the updated value gets calculated—let’s say that the value of sum is 99,999, so `new_value` will be 100,000. 
在一个线程里，要更新的值得到了计算的值 -- 比如sum的值是99,999，所以新值应该是100,000.
Before storing the new value back into sum, we call print, and that causes another thread to be scheduled (because we’re waiting for the I/O to complete). 
在存储一个新值回sum之前，我们调用了print，导致其他线程被调度（因为我们正在等待I/O完成）。
So a second thread also fetches the value of 99,999 and increments it. 
所以第二个线程也取出了99,999的值，并增加。
It stores 100,000 into sum, then loops around again and stores 100,001, and 100,002, and so on. 
它将100,000存入sum，然后循环再来一次，存入100,001和100,002,如此往复。
Eventually the original thread continues running because it finished writing its message. 
最后原始线程继续运行，因为它完成写出信息。
It immediate stores it’s value of 100,000 into the sum, overwriting (and losing) all the values stored by the other thread(s). 
他立刻存储它100,000的值给sum，覆盖（并丢失）了所有其他线程存储的值。
We lost data.
我们丢失了数据。
<kinder:note> 这段论述在第二版表现为一个表格。看不懂的看参看表格的内容。

**Mutex类**
Fortunately, that’s easy to fix. 
幸运的是，这很好修复。
We use the built-in class Mutex to create synchronized regions —areas of code that only one thread may enter at a time. 
我们使用内建的Mutex来创建同步区域 -- 区域里的代码在一个时间只有一个线程可以进入。
Some grade schools coordinate students’ access to the bathrooms during class time using a system of bathroom passes. 
一些学校协调学生上课时间访问浴室，使用浴室中的通行系统。
Each room has two passes, one for girls and one for boys. 
每个房间有两个关口，一个给女孩，一个给男孩。
To visit the bathroom, you have to take the appropriate pass with you. 
要进入浴室，你只有通过适当的关口。
If someone else already has that pass, you have to cross your legs and wait for them to return. 
如果有人也已经通过，你只能等待他们出来。
The bathroom pass controls access to the critical resource—you have to own the pass to use the resource, and only one person can own it at a time.
浴室关口控制进出这一关键资源 -- 你只有得到通关来使用资源，并且一个时间只有一个人拥有这个权利。

A mutex is like that bathroom pass. 
mutex就像浴室的关口。
You create a mutex to control access to a resource and then lock it when you want to use that resource. 
你创建一个mutex来控制资源的访问，当你想使用资源的时候锁住它。
If no one else has it locked, your thread continues to run. 
如果没有其他人锁住，你的线程继续运作。
If someone else has already locked that particular mutex, your thread suspends (crossing its legs) until they unlock it. 
如果其他人已经锁住特定mutex，你的线程暂停，直到他们将它解锁。
 Here’s a version of our counting code that uses a mutex to ensure that only one thread updates the count at a time:
这是一个版本，计数代码使用一个mutex来确保在一个时间只有一个线程更新计数器。

    sum = 0
    mutex = Mutex.new
    threads = 10.times.map do
      Thread.new do
        100_000.times do
          mutex.lock           #### one at a time, please
          new_value = sum + 1     #
          print "#{new_value} " if new_value % 250_000 == 0
          sum = new_value         #
          mutex.unlock         ####
        end
      end
    end
    threads.each(&:join)   
    puts "\nsum = #{sum}"
    # produces:
    # 250000 500000 750000 1000000
    # sum = 1000000

**Mutex#synchronize**
This pattern is so common that the Mutex class provides Mutex#synchronize, which locks the mutex, runs the code in a block, and then unlocks the mutex. 
这个模式太普通了。Mutex类提供了Mutex#synchronize，锁住mutex，在block里运行，然后解开mutex。
This also ensures that the mutex will get unlocked even if an exception is thrown while it is locked.
这也确保mutex将得到解锁，即使在锁住的时候抛出意外。

    sum = 0
    mutex = Mutex.new
    threads = 10.times.map do
      Thread.new do
        100_000.times do
          mutex.synchronize do   ####
            new_value = sum + 1     #
            print "#{new_value}  " if new_value % 250_000 == 0
            sum = new_value         #
          end                    ####
        end
      end
    end
    threads.each(&:join)
    puts "\nsum = #{sum}"
    # produces:
    # 250000 500000 750000 1000000
    # sum = 1000000

**`Mutex#try_lock`**
Sometimes you want to claim a lock if a mutex is currently unlocked, but you don’t want to suspend the current thread if it isn’t. 
有时你要声明一个锁，如果mutex没有锁上，但你不想挂起当前线程 -- 如果它还没有挂起
The `Mutex#try_lock` method takes the lock if it can, but returns false if the lock is already taken. 
`Mutex#try_lock`方法获得锁，如果它能。但返回false，如果锁已经被拿到。
The following code illustrates a hypothetical currency converter. 
下面的代码演示一个假想的货币换算器。
The ExchangeRates class caches rates from an online feed, and a background thread updates that cache once an hour. 
ExchangeRates类从一个在线种子缓存汇率，一个后台线程每个小时更新一次缓存。
This update takes a minute or so. 
更新花费一分钟左右。
In the main thread, we interact with our user. 
在主线程里面，我们和用户交互。
However, rather than just go dead if we can’t claim the mutex that protects the rate object, we use `try_lock` and print a status message if the update is in process.
不过，不是死去 -- 如果我们不能声明mutex保护汇率对象时，我们使用`try_lock`并打印一个状态信息，如果更新进行中。

    rate_mutex = Mutex.new
    exchange_rates = ExchangeRates.new
    exchange_rates.update_from_online_feed
    Thread.new do
      loop do
        sleep 3600
        rate_mutex.synchronize do
          exchange_rates.update_from_online_feed
        end
      end
    end
    loop do
      print "Enter currency code and amount: "
      line = gets
      if rate_mutex.try_lock
        puts(exchange_rates.convert(line)) ensure rate_mutex.unlock
      else
        puts "Sorry, rates being updated. Try again in a minute"
      end
    end

**Mutex#sleep**
If you are holding the lock on a mutex and you want to temporarily unlock it, allowing others to use it, you can call Mutex#sleep. 
如果你保持锁定一个mutex，并且想临时性解开它，允许其他线程使用它，你可以调用Mutex#sleep。
We could use this to rewrite the previous example:
你可以使用这个来重写前面的例子。

    rate_mutex = Mutex.new
    exchange_rates = ExchangeRates.new
    exchange_rates.update_from_online_feed
    Thread.new do
      rate_mutex.lock
      loop do
        rate_mutex.sleep 3600
        exchange_rates.update_from_online_feed
      end
    end
    loop do
      print "Enter currency code and amount: "
      line = gets
      if rate_mutex.try_lock
        puts(exchange_rates.convert(line)) ensure rate_mutex.unlock
      else
        puts "Sorry, rates being updated. Try again in a minute"
      end
    end

### 队列和条件变量 Queues and Condition Variables
Most of the examples in this chapter use the Mutex class for synchronization. 
这一章的大多数例子使用Mutex类来同步。
However, Ruby comes with another library that is particularly useful when you need to synchronize work between producers and consumers. 
不过，ruby还有另一个库，在你需要在生产者和消费者之间同步工作时，特别有用。
The Queue class, located in the thread library, implements a thread-safe queuing mechanism. 
Queue类，位于线程库里面，完成一个线程安全的队列机制。
Multiple threads can add and remove objects from each queue, and each addition and removal is guaranteed to be atomic. 
多线程可以从每个队列中增加和删除对象，每个增加和移除都可保证是原子性的。
For an example, see the description of the thread library on page 813.
比如，看看后面813页线程库的描述。

A condition variable is a controlled way of communicating an event (or a condition) between two threads. 
条件变量是一个两个线程之间事件（或条件）的通讯的控制方法。
One thread can wait on the condition, and the other can signal it. 
一个线程可以等待条件，另一个发出这个信号。
The thread library extends threads with condition variables. 
线程库用条件变量扩展了线程。
Again, see the Monitor library for an example.
再次，比如，看看监视器库。

## 　　11.3　互斥  这是第二版的内容
这是最底层的阻止其他线程运行的方法，使用了全局的线程关键（thread-critical）条件。
当`Thread.critical = true`时，调度器不会调度现有线程去运行。但不会阻止创建和运行新线程。某些线程操作（如停止、杀死线程，在当前线程中睡眠和引发异常）会导致即使线程处于一个关键区域内也会被调度出去。
直接使用Thread.critical=不是很方便。我们强烈建议不要使用它，除非你是一个多线程编程（和喜欢长时间调试）的黑带高手。
ruby有很多变通的方法，比如下面的Monitor库。还有后面738页的Sync库、697页的`Mutex_m`库、743页的Queue类。
### 11.3.1 Monitor监视器
监视器用同步函数对包含一些资源的对象进行封装。
一个问题例子：

    class Counter
      attr_reader :count
      def initialize
        @count = 0
        super
      end
      def tick
        @count += 1
      end
    end
    c = Counter.new
    t1 = Thread.new { 10000.times { c.tick } }
    t2 = Thread.new { 10000.times { c.tick } }
    t1.join
    t2.join
    c.count → 11319

怎么不是20000呢？里面`@count += 1`是罪魁祸首。ruby解释器会分解为：

    val = fetch_current(@count)
    add 1 to val
    store val back into @count

如下表所示，尽管基本的load/add/store指令集被执行了5次，可是最终的count是3。因为线程1在中间中断了线程2的执行。当线程2恢复运行时，它把一个旧的值保存到@count中。
Table 11.1. Two threads in a race condition(竞态条件里的两个线程。)

    Thread  Executes. . .                  Result
    t1:     val = fetch_current(@count)    @count = 0
    t1:     add 1 to val                   0
    t1:     store val back into @count     @count = 1
    t2:     val = fetch_current(@count)    1
    t2:     add 1 to val                   1
    t2:     store val back into @count     @count = 2
    t1:     val = fetch_current(@count)    2
    t2:     val = fetch_current(@count)    2
    t1:     add 1 to val                   2
    t1:     store val back into @count     @count = 3
    t1:     val = fetch_current(@count)    3
    t1:     add 1 to val                   3
    t1:     store val back into @count     @count = 4
    t2:     add 1 to val                   4
    t2:     store val back into @count     @count = 3

使用监视器可以做出妥善安排，确保每次只有一个线程能够在tick方法中执行增加。

    require 'monitor'
    class Counter < Monitor   # 把计数器变成监视器的子类。
      attr_reader :count
      def initialize
        @count = 0
        super
      end
      def tick
        synchronize do       
        # synchronize方法继承自监视器，每次只有一个线程能够执行synchronize块中的代码。
          @count += 1
        end
      end
    end
    c = Counter.new
    t1 = Thread.new { 10000.times { c.tick } }
    t2 = Thread.new { 10000.times { c.tick } }
    t1.join; t2.join
    c.count → 20000   # 这就是我们想要的结果。

为了获得这些益处，没有必要让我们的类变成Monitor的子类，也可Mixin使用监视器的一个变体**MonitorMixin**

    require 'monitor'
    class Counter
      include MonitorMixin
      ...
    end

上面把同步放在需要同步的资源里面。当需要对类中所有对象的所有访问进行同步时，这是恰当的方式。
但如果在某些情况下才需要对对象的访问进行同步，或如果对一组对象进行同步，最好是使用一个**外部的监视器**。

    require 'monitor'
    class Counter
      attr_reader :count
      def initialize
        @count = 0
      end
      def tick
        @count += 1
      end
    end
    c = Counter.new
    lock = Monitor.new         # 嘿嘿，看这里，就是外部监视器了。
    t1 = Thread.new { 10000.times { lock.synchronize { c.tick } } }
    t2 = Thread.new { 10000.times { lock.synchronize { c.tick } } }
    t1.join; t2.join
    c.count → 20000

甚至**把特定对象放入监视器**。

    require 'monitor'
    class Counter
      # as before...
    end
    c = Counter.new
    c.extend(MonitorMixin)      # 看这里
    t1 = Thread.new { 10000.times { c.synchronize { c.tick } } }
    t2 = Thread.new { 10000.times { c.synchronize { c.tick } } }
    t1.join; t2.join
    c.count → 20000

但是，因Counter类在定义时不知道它是一个监视器，所有必须在外部执行同步。如果别的代码调用了tick但没有意识到需要同步，则我们又回到开始面临的境地了。

### 11.3.2 队列
当需要同步生产者和消费者之间的工作时，线程库中的Queue类实现了一个线程安全的队列机制。多个线程可以添加和删除队列中的对象，保证每次添加和删除是原子性的操作。
后面743页的线程库描述中有样例。
### 11.3.3 条件变量
监视器提供了一半我们需要的特性。但假如两个线程访问共享队列，一个要添加条目，一个要读取它。
就像下面的例子：

    require 'monitor'
    playlist = []
    playlist.extend(MonitorMixin) 
    # Player thread 播放器线程
    Thread.new do
      record = nil
      loop do
        playlist.synchronize do        # < < BUG！！！
          sleep 0.1 while playlist.empty?
            record = playlist.shift    # 逐步清空播放列表
          end
        play(record)                   # 播放歌曲
      end
    end
    # Customer request thread 客户请求线程
    Thread.new do
      loop do
        req = get_customer_request
        playlist.synchronize do
          playlist << req         # 添加歌曲到播放列表中。
        end
      end
    end

这段代码有一个问题。播放器线程获得对监视器的访问，客户线程永远无法进入它的同步块，永远无法把东西添加到播放列表。
因此，需要能够暂时放弃对关键区域的排他性使用，同时告诉别人我们正在等待资源。当资源变得可用时，我们需要能够抓住它并重新获得关键区域的锁，这些动作要在一个步骤里完成。这就是条件变量大显身手的地方。
条件变量是在一种两个线程之间交换事件（或条件）的受控方式。一个线程等待线程，而另一个发信号通知条件。
下面的例子中，编写存根[stub]方法，让它们使用条件变量去接受客户请求和播放歌曲。还添加了一个标志通知播放器关闭：一般情况下它会一直运行。

    require 'monitor'
    SONGS = [
              'Blue Suede Shoes',
              'Take Five',
              'Bye Bye Love',
              'Rock Around The Clock',
              'Ruby Tuesday'
            ]
    START_TIME = Time.now
    def timestamp
      (Time.now - START_TIME).to_i
    end
    # Wait for up to two minutes between customer requests
    # 等待最多2分钟在客户请求之间
    def get_customer_request
      sleep(120 * rand)
      song = SONGS.shift
      puts "#{timestamp}: Requesting #{song}" if song
      song
    end
    # Songs take between two and three minutes
    # 歌曲在两分钟到三分钟之间
    def play(song)
      puts "#{timestamp}: Playing #{song}"
      sleep(120 + 60*rand)
    end
    ok_to_shutdown = false
    # and here's our original code 下面是我们的原始代码
    playlist = []
    playlist.extend(MonitorMixin)
    plays_pending = playlist.new_cond    #待播放列表。这个new_cond方法是什么意思？
    # Customer request thread 客户请求线程
    customer = Thread.new do
      loop do
        req = get_customer_request
        break unless req           # 如果没有客户请求则跳出循环。
        playlist.synchronize do
          playlist << req
          plays_pending.signal     # 这个singal方法也是混杂类带来的吧？
        end
      end
    end
    # Player thread 播放器线程
    player = Thread.new do
      loop do
        song = nil
        playlist.synchronize do
          break if ok_to_shutdown && playlist.empty?       # 如果已经被关闭并且播放列表为空则跳出。
          plays_pending.wait_while { playlist.empty? }     # 待播放列表执行wait_while方法。这个方法也是混杂来的吗？
          song = playlist.shift
        end
        break unless song
        play(song)
      end
    end
    customer.join
    ok_to_shutdown = true
    player.join
    # produces:
    # 26: Requesting Blue Suede Shoes
    # 28: Playing Blue Suede Shoes
    # 72: Requesting Take Five
    # 188: Requesting Bye Bye Love
    # 214: Playing Take Five
    # 288: Requesting Rock Around The Clock
    # 299: Requesting Ruby Tuesday
    # 396: Playing Bye Bye Love
    # 563: Playing Rock Around The Clock
    # 708: Playing Ruby Tuesday

<kinder:note>这是怎么回事？没有什么存根方法啊？其他方法倒是好几个。

## 　　11.4　运行多个进程
有时也许需要把任务分成几个进程来处理，或者也许需要运行的不是用ruby编写的独立进程。
这不是一个问题：ruby有好几个方法去衍生和管理独立进程。
### 11.4.1 衍生新进程
最简单的方式：使用Kernel#system命令和反引号（``）方法运行一些命令然后等待它结束。
system在子程序中执行给定的命令，如果命令被找到并正确执行，返回true，否则返回false，子程序的退出码保存在全局变量$?中。

    system("tar xzf test.tgz")  # true
    result = `data` 
    result                      # " Wed May 3 16:56:19 CDT 2006\n"

system的问题是，这个命令和程序使用相同的输出流，这可能是我们不希望看到的。
而且很多情况下我们需要更多的控制，和子程序进行对话，发送数据给它，从它那儿得到数据。
**IO.popen**可以做到。
popen方法在子进程里运行命令，把子进程的标准输入和标准输出连接到RubyIO对象。不论子程序写入什么数据，ruby程序通过读取IO对象得到它。

    pig = IO.popen("/usr/local/bin/pig", "w+")
    pig.puts "ice cream after they go to bed."
    puts pig.gets
    # iceway eamcray afterway eythay ogay otay edbay

这个例子说明，当通过管道驱动子进程时，同时涉及到了表面上的简单性和现实世界的复杂性。
这段代码看起来非常简单：打开管道，写入一句话同时读回响应。
但我们发现pig程序并没有刷新它的输出。我们最初在pig.puts后面跟着pig.gets，但这回造成程序永久挂起。pig程序处理了输入，但响应永远不会写入到管道中。
我们不得不插入`pig.close_writer`代码行来解决这个问题：发送一个EOF到pig标准输入，这样输出随着pig的终止而被刷新。
<kinder:note> 这段话真是听不懂！怎么办？

popen还有一个值得注意的地方。如果被传递的命令是个减号（-），popen会folk一个新的ruby解释器。
这个解释器和原先的解释器在popen返回后都会继续运行。
原先的进程会接受到IO对象，而子进程得到nil。这个函数只能在支持fork(2)调用的操作系统上工作（因而不包括windows）
<kinder:note> 也是不懂。

    pipe = IO.popen("-", "w+")
    if  pipe 
      pipe.puts "Get a job!"
      STDERR.puts "Child says `#{pipe.gets.chomp}`"   # 为什么输出这一句？
    else
      STDERR.puts "Dad says `#(gets.chomp)`"          # 为什么输出这一句？
      puts "OK"
    end
    # 输出结果
    # Dad says 'Get a job!"
    # Child says 'OK'
    # ruby2的输出：
    # Dad says '#(gets.chomp)`
    # Child says 'OK'


除了popen方法，一些平台支持Kernel.fork Kernel.exec IO.pipe方法。
如果把！作为文件名的第一个字符(详见503页IO类的介绍)，许多符合文件命名惯例的IO方法和Kernel.open也会衍生子进程。
注意不能使用File.new创建管道，它只是用来创建文件。

### 11.4.2 独立子进程
有时候我们愿意把任务交给子进程，然后继续做我们的事情，晚些时候再查看子进程是否已经结束。
例如下面的外部排序：

    exec("sort testfile > output.txt") if fork.nil?
    # The sort is now running in a child process
    # carry on processing in the main program
    # ... dum di dum ...
    # then wait for the sort to finish
    Process.wait

Kernel.fork调用会在父进程中返回进程ID，在子进程中返回nil。这样子进程会执行Kernel.exec并运行sort。然后调用Process.wait等待sort结束（同时返回进程ID）

如果更愿意在子进程结束时收到通知，可以使用Kernel.trap(在后面534页描述)设置信号处理方法。

    trap("CLD") do          # 在SIGCLD上设置了trap，子进程终止时SIGCLD信号会被发给父进程。
      pid = Process.wait
      puts "Child pid #{pid}: terminated"
    end
    exec("sort testfile > output.txt") if fork.nil?
    # do other stuff...
    # produces:
    # Child pid 25816: terminated

关于使用和控制外部进程的更多信息，参见Kernel.open和IO.popen文档已经后面583页的Process模块一节。

### 11.4.3 block和子进程
IO.open与block相伴工作，很大程度上和File.open所做的一样，如果把命令传递给它，例如data，一个IO对象会作为参数传递给block。block结束时，IO对象自动关闭/

    IO.popen("date") {|f| puts "Date is #{f.gets}" }
    # produces:
    # Date is Thu Aug 26 22:36:55 CDT 2004

如果使用Kernel.fork关联block，block内代码会在ruby子进程中运行，父进程会在block后面继续运行。

    fork do
      puts "In child, pid = #$$"
      exit 99
    end
    pid = Process.wait
    puts "Child terminated, pid = #{pid}, status = #{$?.exitstatus}"
    # $?是全局变量，包含子进程结束时的信息。详见后面591页Process:Status。
    # produces:
    # In child, pid = 25823
    # Child terminated, pid = 25823, status = 99

# 　第12章　单元测试
**什么是单元测试**
单元测试专注于小块（单元）的代码，一般是单个方法或方法中的几行，这个其他的将整个系统视为一体的测试形式区别开来。
最后所有软件都是以层次而构架的：某一层次的代码依赖于下一层次代码的正确操作。如果下层代码结果包含了bug，那么所有上面的层次都会有潜在的影响。这是一个大问题。
如果对代码进行单元测试，可能发生两种情况：第一，当代码在头脑中依然鲜活，他就找出了bug。第二，因为单元测试只查看刚刚编写的代码，bug发生时只需查看少数代码行就可以发现，而不必在整个代码基础上考古了。
单元测试对于ruby这样的动态语言，似乎携手而来。ruby的灵活性使得编写测试非常简单，而测试让你能够更容易地验证你的代码。一旦渐入佳境，你会发现自己通常以这样一种步骤工作：先编写一些代码，再编写一两个测试，验证所有事情都完美正确，然后编写更多的代码。
**单元测试框架**
不过，随着项目中测试数量的增长，这种自由散漫的方式会使测试变得复杂而难以管理。多年以来，出现了许多单元测试框架来帮助组织测试过程。
Ruby comes with Ryan Davis’ MiniTest.[1]
ruby自带了RyanDavis编写的MiniTest框架。
[1].  In Ruby 1.8, this was Nathaniel Talbott’s Test::Unit framework. MiniTest is a rewrite of this.
在ruby1.8,预装的是Nathaniel Talbott的Test::Unit框架。MiniTest是它的重写。

MiniTest is largely compatible with Test::Unit but without a lot of bells and whistles (test- case runners, GUI support, and so on). 
MiniTest 大部分兼容Test::Unit，但没有大量的花俏装饰（测试用例运行器、GUI支持，等等）
However, because there are areas where it is different and because there are tens of thousands of tests out there that assume the Test::Unit API, Ryan has also added a compatibility layer to MiniTest. 
不过，因为存在困难的地方，而且因为已经存在成千上万的测试都预定使用Test::Unit的API，Ryan已经增加了一个兼容层给MiniTest。
For a little bit more information on the differences between the two, see MiniTest::Unit vs. Test::Unit, on page 177. 
关于两者的差别，在后面177页的"MiniTest::Unit vs. Test::Unit"有一些信息可以了解。
In this chapter, we’ll be using the Test::Unit wrapper, because it automatically runs tests for us. 
在这一章，我们使用Test::Unit包装器，因为它为我们自动运行测试。
But we’ll also be using some of the new assertions available in MiniTest.
但我们也使用一些MiniTest可用的新的断言。

MiniTest::Unit 还是 Test::Unit ？
MiniTest::Unit vs. Test::Unit
Folks have been using Test::Unit with Ruby for a good number of years now. However, the core team decided to replace the testing framework that comes as standard with Ruby with something a little leaner. Ryan Davis and Eric Hodel wrote MiniTest::Unit as a partial drop-in replacement for Test::Unit.
人们使用ruby的Test::Unit已经好几年了。不过，核心团队决定替换这个测试框架，作为ruby标配更精简些。Ryan Davis 和 Eric Hodel写了MiniTest::Unit作为部分插入替代Test::Unit。
Most of the assertions in MiniTest mirror those in Test::Unit::TestCase. The major differences are the absence of assert_not_raises and assert_not_throws and the renaming of all the negative assertions. In Test::Unit you’d say assert_not_nil(x) and assert_not(x); in MiniTest you’d use refute_nil(x) and refute(x).
MiniTest的大多数断言对应Test::Unit::TestCase的断言。最大不同是没有assert_not_raises和assert_not_throws，并重命名了所有的负向断言。在Test::Unit说assert_not_nil(x)和assert_not(x)；在MiniTest使用refute_nil(x)和refute(x)。
MiniTest also drops most of the little-used features of Test::Unit, including test cases, GUI runners, and some assertions.  
MiniTest也丢弃了大多数很少使用的特性，包括测试用例、GUI运行器，和一些断言。
And, probably most significantly, MiniTest does not automatically invoke the test cases when you execute a file that contains them.
而且，可能最有意义的是，MiniTest不会自动调用测试用例，当你执行一个包含它们的文件时。
So, you have three basic options with this style of unit testing:
所以，单元测试的类型有下面三个基本选项：
• require "minitest/unit", and use the MiniTest functionality.
require "minitest/unit", 使用MiniTest功能
• require "test/unit", and use MiniTest with the Test::Unit compatibility layer. This adds in the assertions in Additional Test::Unit assertions, on page 194, and enables the autorun functionality.
require "test/unit",带着Test::Unit层使用MiniTest。这在断言中增加了传统的Test::Unit断言（详情见后面194页），和自动功能。
• You can install the test-unit gem and get all the original Test::Unit functionality back, along with a bunch of new assertions.
还可以安装test-unit的gem，得回所有的原始功能，和一束新的断言。
## 　　12.1　Test::Unit框架
单元测试很琐碎，多年来，出现了许多单元测试框架来帮助组织测试过程。
ruby自带了一个预先安装，由Nathniel Talbott编写的Test::Unit框架
Test::Unit框架基本上将3个功能包装到一个整洁的包中。
 -  提供了一种表达单个测试的方式
 -  提供了一个框架来组织测试
 -  提供了灵活的方式来调用测试
### 12.1.1   断言 == 预期的结果
 无须编写一系列单独的if语句。
虽然存在许多不同风格的断言，但基本上遵循相同的模式。
每个断言都向你提供指定预想的结果或输出、以及传入实际输出的方式。
如果实际结果和预期不同，断言会输出一个漂亮的消息，并将此次记录为一次失败。
例如下面的代码：Figure 12.1. Roman numerals generation (with bugs)

    $ cat roman.rb
    class Roman
      MAX_ROMAN = 4999
      def initialize(value)
        if value <= 0 || value > MAX_ROMAN
          fail "Roman values must be > 0 and <= #{MAX_ROMAN}"
        end
        @value = value
      end
      FACTORS = [["m", 1000], ["cm", 900], ["d", 500], ["cd", 400],
                 ["c", 100],  ["xc", 90],  ["l",  50], ["xl", 40],
                 ["x", 10],   ["ix", 9],   ["v",   5], ["iv", 4],
                 ["i", 1]]
      def to_s
        value = @value
        roman = ""
        for code, factor in FACTORS
          count, value = value.divmod(factor)  # 这个divmod方法的参数是个数组。具体运算过程呢？得参见后面的资料。
          roman << code unless count.zero?      # bug在这一行：如果factor除得到的值大于0,则我们应该输入多个罗马数字，而现有代码值输出一个。
        end
        roman
      end
    end

下面是测试代码一：

    require 'roman'
    # ruby2改为 require_relative 'roman'
    require 'test/unit'
    class TestRoman < Test::Unit::TestCase
      def test_simple
        assert_equal("i", Roman.new(1).to_s)
        assert_equal("ix", Roman.new(9).to_s)
      end
    end
    # produces:
    # Loaded suite -
    # Started
    # .
    # Finished in 0.003655 seconds.
    # 1 tests, 2 assertions, 0 failures, 0 errors

下面是测试代码二：

    require 'roman'
    # ruby2改为 require_relative 'roman'
    require 'test/unit'
    class TestRoman < Test::Unit::TestCase
      def test_simple
        assert_equal("i", Roman.new(1).to_s)
        assert_equal("ii", Roman.new(2).to_s)
        assert_equal("iii", Roman.new(3).to_s)
        assert_equal("iv", Roman.new(4).to_s)
        assert_equal("ix", Roman.new(9).to_s)
      end
    end
    # produces:
    # Loaded suite -
    # Started
    # F
    # Finished in 0.021877 seconds.
    # 1) Failure:
    # <"ii"> expected but was
    # <"i">.
    # 1 tests, 2 assertions, 1 failures, 0 errors
    # test_simple(TestRoman) [prog.rb:6]:

修复原始代码的bug：

    roman << (code * count) 

简化测试代码：

    require 'roman'
    # ruby2改为 require_relative 'roman'
    require 'test/unit'
    class TestRoman < Test::Unit::TestCase
      NUMBERS = [
                [ 1, "i" ], [ 2, "ii" ], [ 3, "iii" ],
                [ 4, "iv"], [ 5, "v" ],  [ 9, "ix" ]
                ]
      #第四版改为散列表： NUMBERS = { 1 => "i", 2 => "ii", 3 => "iii", 4 => "iv", 5 => "v", 9 => "ix" }
      def test_simple
        NUMBERS.each do |arabic, roman|
          r = Roman.new(arabic)
          assert_equal(roman, r.to_s)
        end
      end
    end
    # produces:
    # Loaded suite -
    # Started
    # .
    # Finished in 0.004026 seconds.
    # 1 tests, 6 assertions, 0 failures, 0 errors

测试是否可以表示为罗马数字，如果不能则引发一个异常：
第二版的例子：

    require 'roman'
    # ruby2改为 require_relative 'roman'
    require 'test/unit'
    class TestRoman < Test::Unit::TestCase
      def test_range
        assert_raise(RuntimeError)  { Roman.new(0) }
        assert_nothing_raised()     { Roman.new(1) }
        assert_nothing_raised()     { Roman.new(499) }
        assert_raise(RuntimeError)  { Roman.new(5000) }
      end
    end
    # produces:
    # Loaded suite -
    # Started
    # .
    # Finished in 0.002898 seconds.
    # 1 tests, 4 assertions, 0 failures, 0 errors

第四版的例子：

    require_relative 'roman3'
    require 'test/unit'
    class TestRoman < Test::Unit::TestCase
      NUMBERS = { 1 => "i", 2 => "ii", 3 => "iii", 4 => "iv", 5 => "v", 9 => "ix" }
      def test_simple
        NUMBERS.each do |arabic, roman|
          r = Roman.new(arabic)
          assert_equal(roman, r.to_s)
        end
      end
      def test_range
        # no exception for these two...
        Roman.new(1)
        Roman.new(4999)
        # but an exception for these
        assert_raises(RuntimeError) { Roman.new(0) }
        assert_raises(RuntimeError) { Roman.new(5000) }
      end
    end
    # produces:
    # Run options:
    # # Running tests:
    # ..
    # Finished tests in 0.006736s, 296.9121 tests/s, 1187.6485 assertions/s.
    # 2 tests, 8 assertions, 0 failures, 0 errors, 0 skips
    # ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

**定制消息**
每个断言的最后一个参数就是一条消息，会在任何错误消息之前输出。
一般它是不需要的，因为Test::Unit的消息通常已经很适用了。测试`asser_not_nil`是一个例外，它的消息“<nil> expected to not be nil”帮不上忙，可以添加自己的一些注视。
(This code assumes the existence of some kind of User class.)
(这个代码假定一些User类的种类是存在的)<kinder:note>什么意思？
第二版的例子

    require 'test/unit'
    class TestsWhichFail < Test::Unit::TestCase
      def test_reading
        assert_not_nil(ARGF.read, "Read next line of input")
      end
    end
    # produces:
    # Loaded suite -
    # Started
    # F
    # Finished in 0.033581 seconds.
    # 1) Failure:
    # Read next line of input.    这就是上面定制的消息
    # <nil> expected to not be nil.
    # 1 tests, 1 assertions, 1 failures, 0 errors
    # test_reading(TestsWhichFail) [prog.rb:4]:

第四版的例子：

    require 'test/unit'
    class ATestThatFails < Test::Unit::TestCase
      def test_user_created
        user = User.find(1)
        refute_nil(user, "User with ID=1 should exist")
      end
    end
    # produces:
    # Run options:
    # # Running tests:
    # F
    # Finished tests in 0.007598s, 131.6136 tests/s, 131.6136 assertions/s.
    # 1) Failure:
    # test_user_created(ATestThatFails) [prog.rb:11]:
    # User with ID=1 should exist.     这就是上面定制的消息
    # Expected nil to not be nil.
    # 1 tests, 1 assertions, 1 failures, 0 errors, 0 skips
    # ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

Test:Unit断言的完整列表Figure 12.2. Test::Unit assertions

    assert(boolean, [ message ] )
        如果boolean为false或者nil，则失败。
    assert_nil(obj, [ message ] )
    assert_not_nil(obj, [ message ] )
        预期obj为（或不为）nil。
    assert_equal(expected, actual, [ message ] )
    assert_not_equal(expected, actual, [ message ] )
        使用==来判定actual和expected是否相等。
    assert_in_delta(expected_float, actual_float, delta, [ message ] )
        预期实际的浮点值处于预期值的delta（偏差）之内。
    assert_raise(Exception, . . . ) { block }
    assert_nothing_raised(Exception, . . . ) { block }
        预期block将会（或不会）引发参数列出的异常。
    assert_instance_of(klass, obj, [ message ] )
    assert_kind_of(klass, obj, [ message ] )
        预期obj是Klass的子类或者实例。
    assert_respond_to(obj, message, [ message ] )
        预期obj能响应message（一个符号）
    assert_match(regexp, string, [ message ] )
    assert_no_match(regexp, string, [ message ] )
        预期字符串匹配（或不匹配）正则表达式regexp
    assert_same(expected, actual, [ message ] )
    assert_not_same(expected, actual, [ message ] )
        预期expected.equal?(actual).
    assert_operator(obj1, operator, obj2, [ message ] )
        预期用obj2为参数调用obj1的operator， 且结果为true。
    assert_throws(expected_symbol, [ message ] ) { block }
        预期block抛出指定的符号。
    assert_send(send_array, [ message ] )
         将sent_array[1]中的消息发送给send_array[0]中的接收者，将send_array的其他部分作为参数，预期返回值为true。
    flunk(message="Flunked")
        永远失败

MiniTest断言的完整列表：

    assert | refute(boolean, ‹ message › )
        Fails if boolean is (is not) false or nil.
        如果boolean为false或者nil，则失败。
    assert_block { block }
        Expects the block to return true.
        预期block返回true。
    assert_ | refute_ empty(collection, ‹ message › )
        Expects empty? on collection to return true (false).
        预期收集的empty?方法返回true（或者false）
    assert_ | refute_ equal(expected, actual, ‹ message › )
        Expects actual to equal/not equal expected, using ==.
        使用==来判定actual和expected是否相等。
    assert_ | refute_in_delta(expected_float, actual_float, delta, ‹ message › )
        Expects that the actual floating-point value is (is not) within delta of the expected value.
        预期实际的浮点值处于预期值的delta（偏差）之内。
    assert_ | refute_ in_epsilon(expected_float, actual_float, epsilon=0.001, ‹ message › )
         Calculates a delta value as epsilon * min(expected, actual) and then calls the _in_delta test.
         计算偏差的值，epsilon乘以expectd和actual的最小值，然后调用`_in_delta`测试。
         <kinder:note> 应该不是这么翻译吧？
         ruby-docs.org对asser_in_epsilon作如此解释：
         For comparing Floats. Fails unless exp and act have a relative error less than epsilon.
         用于比较浮点数。将失败，除非exp和act相对误差小于epsilon.
    assert_ | refute_ includes(collection, obj, ‹ message › )
        Expects include?(obj) on collection to return true (false).
        预期收集的include?(obj)方法返回true（f或alse）
    assert_ | refute_ instance_of(klass, obj, message )
        Expects obj to be (not to be) a instance of klass.
        预期obj是（不是）Klass的实例。
    assert_ | refute_ kind_of(klass, obj, ‹ message › )
        Expects obj to be (not to be) a kind of klass.
        预期obj是（不是）Klass的子类。
    assert_ | refute_ match(regexp, string, ‹ message › )
        Expects string to (not) match regexp.
        预期字符串匹配（不匹配）正则表达式regexp。
    assert_ | refute_ nil(obj, ‹ message › )
        Expects obj to be (not) nil.
        预期obj为（不为）nil。
    assert_ | refute_ operator(obj1, operator, obj2, ‹ message › )
        Expects the result of sending the message operator to obj1 with parameter obj2 to be (not to be) true.
        预期用obj2为参数调用obj1的operator， 且结果为true。
    assert_raises(Exception, ...) { block }
        Expects the block to raise one of the listed exceptions.
        预期block将会（或不会）引发参数列出的异常。
    assert_ | refute_ respond_to(obj, message, ‹ message › )
        Expects obj to respond to (not respond to) message (a symbol).
        预期obj能(不能)响应message（一个符号）
    assert_ | refute_ same(expected, actual, ‹ message › )
        Expects expected.equal?(actual).
        预期expected.equal?(actual).
    assert_send(send_array, ‹ message › )
        Sends the message in send_array[1] to the receiver in send_array[0], passing the rest of send_array as arguments. Expects the return value to be true.
        将sent_array[1]中的消息发送给send_array[0]中的接收者，将send_array的其他部分作为参数，预期返回值为true。
    assert_throws(expected_symbol, ‹ message › ) { block }
        Expects the block to throw the given symbol.
        预期block抛出指定的符号。
    flunk(message="Epic Fail!")
        Always fails.
        永远失败
    skip(message)
        Indicates that a test is deliberately not run.
        指明测试故意不运行(跳过)。
    pass
        Always passes.
        总是通过。
    
MiniTest之外的其他Test::Unit断言：
Additional Test::Unit assertions

    assert_not_equal(expected, actual, ‹ message › )
        Expects actual not to equal expected, using ==. Like refute_equal.
        使用==来判定actual和expected不相等。和refute_equal一样。
    assert_not_match(regexp, string, ‹ message › )
        Expects string not to match regexp. Like refute_match.
        预期字符串不匹配正则表达式regexp。和refute_match一样。
    assert_not_nil(obj, ‹ message › )
        Expects obj not to be nil. Like refute_nil.
        预期obj不为nil。和refute_nil一样。
    assert_not_same(expected, actual, ‹ message › )
        Expects !expected.equal?(actual). Like refute_same.
        预期 !expected.equal?(actual).和refute_same一样。
    assert_nothing_raised(Exception, ...) { block }
        Expects the block not to raise one of the listed exceptions.
        预期block将不会引发参数列出的异常。
    assert_nothing_thrown(expected_symbol, ‹ message › ) { block }
        Expects the block not to throw the given symbol.
        预期block不会抛出指定的符号。
    assert_raise(Exception, ...) { block }
        Synonym for assert_raises.
        assert_raises的同义词


## 　　12.2　组织测试
单元测试中，首先包含Test::Unit的功能：`require 'test/unit'`
单元测试，可以很自然地被组织成更高层的形式，叫做测试用例（test case）;或者分解成较底层的形式，也就是测试方法本身。
测试用例通常包括和某个特定功能或特性相关的所有测试。

表示测试的类必须是Test:Unit:TestCase的子类。
含有断言的方法名必须以test开头。Test:Unit使用反射来查找要运行的测试，而只有以test开头的方法才符合条件。

测试用例所有测试方法都会设置一个特定的场景（scenario）。
每个测试方法考察场景的某些方面，最终，每个方法会总结得到自己的结果。
例如下面测试一个从数据库提取点唱机播放列表的类。

    require 'test/unit'
    # ruby2改为 require_relative 'roman'，下面涉及require的代码都是如此
    require 'playlist_builder'
    require 'dbi'   # 第四版没有这一行，该是内置了这个模块。
    class TestPlaylistBuilder < Test::Unit::TestCase
      def test_empty_playlist
        db = DBI.connect('DBI:mysql:playlists')    # 首先连接到数据库
        pb = PlaylistBuilder.new(db)               # 创建一个新的播放列表生成器
        assert_equal([], pb.playlist())
        db.disconnect                              # 断开测试和数据库。
      end
      def test_artist_playlist
        db = DBI.connect('DBI:mysql:playlists')
        pb = PlaylistBuilder.new(db)
        pb.include_artist("krauss")
        assert(pb.playlist.size > 0, "Playlist shouldn't be empty")
        # 上面一句在第四版改为：
        #  refute_empty(pb.playlist, "Playlist shouldn't be empty")
        pb.playlist.each do |entry|
          assert_match(/krauss/i, entry.artist)
        end
        db.disconnect
      end
      def test_title_playlist
        db = DBI.connect('DBI:mysql:playlists')
        pb = PlaylistBuilder.new(db)
        pb.include_title("midnight")
        assert(pb.playlist.size > 0, "Playlist shouldn't be empty")
        # 上面一句在第四版改为：
        #  refute_empty(pb.playlist, "Playlist shouldn't be empty")
        pb.playlist.each do |entry|
          assert_match(/midnight/i, entry.title)
        end
        db.disconnect
      end
      # ...
    end
    # produces:
    # Loaded suite -
    # Started
    # ...
    # Finished in 0.004809 seconds.

在单元测试中使用数据库的想法是很成问题的。因为单元测试假定是快速运行、上下文无关并且易于设定，但它说明了这一点。

可以把些通用代码提取到**setup**和**teardown**方法中。
在一个TestCase类中，一个叫做setup的方法在每个测试方法之前运行，teardown方法在每个测试方法结束之后运行。注意，不是对每个测试用例，而是对每个方法。
因此修改为：

    require 'test/unit'
    require 'playlist_builder'      # 同样这个require在第四版改为require_relative。
    require 'dbi'                    #同样这一行被删掉。
    class TestPlaylistBuilder < Test::Unit::TestCase
      def setup
        @db = DBI.connect('DBI:mysql:playlists')
        @pb = PlaylistBuilder.new(@db)
      end
      def teardown
        @db.disconnect
      end
      def test_empty_playlist
        assert_equal([], @pb.playlist())
      end
      def test_artist_playlist
        @pb.include_artist("krauss")
        assert(@pb.playlist.size > 0, "Playlist shouldn't be empty")
        # 上面一句在第四版改为：
        #  refute_empty(pb.playlist, "Playlist shouldn't be empty")
        @pb.playlist.each do |entry|
          assert_match(/krauss/i, entry.artist)
        end
      end
      def test_title_playlist
        @pb.include_title("midnight")
        assert(@pb.playlist.size > 0, "Playlist shouldn't be empty")
        # 上面一句在第四版改为：
        #  refute_empty(pb.playlist, "Playlist shouldn't be empty")
        @pb.playlist.each do |entry|
          assert_match(/midnight/i, entry.title)
        end
      end
      # ...
    end
    # produces:
    # Loaded suite -
    # Started
    # ...
    # Finished in 0.00691 seconds.
    # 3 tests, 23 assertions, 0 failures, 0 errors   第四版就是46assertions了。

Inside the teardown method, you can detect whether the preceding test succeeded with the passed? method.
在teadown方法里面，你可以用passed?方法检测前面的测试是否成功。

## 　　12.3　组织和运行测试
Test:Unit足够聪明，可以发现没有主程序，因此将所有的测试用例类集合起来依次运行；
还可以让它运行一个特定的测试方法。例如：

    $ ruby test_roman.rb --name test_range
    Loaded suite test_roman
    Started
    ..
    Finished in 0.039257 seconds.
    2 tests, 9 assertions, 0 failures, 0 errors

### 12.3.1 何处存放测试
你可能发现自己产生的测试代码几乎和产品代码一样多。
这些测试代码必须放在某个地方；但如果和产品代码放在一起，目录会很臃肿。

一般的方法是建立一个test目录。
但留下一个小问题：如何告诉ruby到哪里去找要测试的库文件？
补救：将路径放到测试文件的require语句中，例如`reuqire '../lib/roman'`然后从test子目录中运行测试。
无法补救： 1. 如果roman.rb本身需要库类中编写的其他文件。2. 也无法使用相同的测试了测试安装到目标系统上的类。

较好的解决方法是，从被测试库的父目录中运行测试。因为当前目录是在加载路径中，测试代码可以找到它： `$ ruby ../test/test_romn.rb` 
问题：如果你想要运行系统中其他地方的测试时。比如你所规划的构建过程要查找并执行名为`test_xxx`的文件来为应用中的所有软件运行测试。
补救：加载路径的魔法。在测试代码头部添加下面代码：

    $: .unshift File.join(File.dirname(__File__), "...", "lib")
    require ...

它首先得出测试文件运行所在的目录，然后构造被测试文件的路径。这个目录被加入加载路径（变量$:）的前部。
之后require代码将首先搜索到被测试的库。
<kinder:note> 还是天书。什么意思？特别是两个下划线
### 12.3.2 测试套件
一段时间之后，应用的测试用例集合可能有可观的增长，你可能会发现类聚的倾向。这样的话，你可以的这些测试用例一并组成测试套件，以组的形式运行它们。
在Test:Unit是很容易的。只需要创建一个要求加载test/unit的ruby文件，然后加载每个你希望成组的、包含测试用例的文件。
- 可以通过名字来运行单个测试
- 可以通过某个文件来运行其中的所有测试
- 可以将多个文件组成一个测试套件，作为运行测试的单元。
- 可以将多个测试套件组成另外的测试套件。
这让你可以在所掌控的任何粒度级别运行单元测试，只测试一个方法，或者测试整个应用。

命名约定：测试用例在以`tc_xxx`命名的文件中，测试套件在`ts_xxx`命名的文件中。

    $ cat ts_dbaccess.rb
    require 'test/unit'
    require 'tc_connect'
    require 'tc_query'
    require 'tc_update'
    require 'tc_delete'

如果运行这个文件，将会执行所要求加载的4个文件中的全部测试用例。

它可以更复杂。可以手工创建并填充TestSuit对象，虽然在事件中没有什么意义。
如果想要查找更多信息，详见`ri Test:Unit`
Test::Unit还带有许多时髦的GUI测试运行器，这里只介绍命令行。
## 13.4 RSpec and Shoulda
**其他类型的测试**
The built-in testing framework has a lot going for it. 
内建测试框架已经用了很久。
It is simple, and it is compatible in style with frameworks from other languages (such as JUnit for Java and NUnit for C#).
它简单，兼容其他语言的框架风格（比如java的Junit、C#的NUnit）。

However, there’s a growing movement in the Ruby community to use a different style of testing. 
不过，ruby社区有了使用其他类型的测试的发展趋势。
So-called behavior-driven development encourages people to write tests in terms of your expectations of the program’s behavior in a given set of circumstances. 
所谓行为驱动开发鼓励人们按照你希望的在指定一组环境下的程序行为来写测试。
In many ways, this is like testing according to the content of user stories, a common requirements-gathering technique in agile methodologies. 
在很多方法里，这像是根据用户故事的环境，普通的需求收集技术用敏捷方法进行测试。
With these testing frameworks, the focus is not on assertions. 
用这些测试框架，焦点不在断言。
Instead, you write expectations.
相反，你要写预期。

Although both RSpec and Shoulda allow this style of testing, they focus on different things.
虽然Rspec和Shoulda都允许这种类型的测试，但他们关注不同事情。
RSpec is very much concerned with driving the design side of things. 
RSpec更关心驱动事情的设计方面。
You can write and execute specs with RSpec well before you’ve written a line of application code. 
你可以用RSpec写下并执行规格，在你已经写下一行应用代码之前。
These specs, when run, will output the user stories that describe your application. 
这些规格运行时，将输出描述你的应用程序的用户故事。
Then, as you fill in the code, the specs mutate into tests that validate that your code meets your expectations.
然后，正如你完成的代码里，规格变异成测试，验证你的代码是否符合预期。

Shoulda, on the other hand, is really more focused on the testing side. 
在另一方面，Shoulda更专注于测试方面。
Whereas RSpec is a complete framework, Shoulda works inside a testing framework, Test::Unit or RSpec. 
和RSpec是一个完整的框架相反，Shoulda却在测试框架Test:Unit或者是Rspec里面运行。
You can even mix Shoulda tests with regular Test::Unit and RSpec test methods.
你甚至能用正常的Test::Unit和Rspec测试方法混合Shoulda测试。

Let’s start with a simple example of RSpec in action.
让我们从一个简单的RSpec实例开始。
### 13.4.1 开始网球比赛计分 Starting to Score Tennis Matches
The scoring system used in lawn tennis originated in the Middle Ages. 
评分系统用于草地网球起源于中世纪。
As players win successive points, their scores are shown as 15, 30, and 40. 
一旦球员赢得连续点，他们的得分是15，30，和40。
The next point is a win unless your opponent also has 40. 
第二点是一个胜利,除非你的对手也有40。
If you’re both tied at 40, then different rules apply—the first player with a clear two-point advantage is the winner.  [2]
如果你打到40平，然后采用不同的规则 -- 有一个清楚的两点优势的第一个球员是赢家。
We have to write a class that handles this scoring system. 
我们要写一个处理这类评分系统。
Let’s use RSpec specifications to drive the process. 
让我们使用RSpec规范驱动的过程。
We install RSpec with gem install rspec. 
使用`gem install rspec`安装RSpec
We’ll then create our first specification file:
然后我们将创建我们第一个规范文件：

[2].Some say the 0, 15, 30, 40 system is a corruption of the fact that scoring used to be done using the quarters of a clock face. 
一些人会说0 15 30 40系统是一种堕落，事实上评分已经用了四分之一钟面。
Us, we just think those medieval folks enjoyed a good joke.
我们只认为那是中世纪人喜欢的一个好笑话。
`unittesting/bdd/1/ts_spec.rb`

    describe "TennisScorer", "basic scoring" do
      it "should start with a score of 0-0"
      it "should be 15-0 if the server wins a point"
      it "should be 0-15 if the receiver wins a point"
      it "should be 15-15 after they both win a point"
      # ...
    end

This file contains nothing more than a description of an aspect of the tennis scoring class (that we haven’t yet written, by the way). 
这个文件没有包含更多的对网球计分类的样子的描述（其实我们还没写）。
It contains a description of the basic scoring system. 
它包含基本评分系统的描述。
 Inside the description are a set of four expectations (it "should start..." and so on). 
描述里面是四个预期的集合（就是"should start..."等等）
We can run this specification using the rspec command: [3]
我们可以使用rspec命令运行这个规范：
[3].  We’re running these examples with RSpec2. 
我们使用RSpec2运行这些例子。
This will probably be the default version by the time you read this, but I had to use gem install rspec --pre because it was prerelease when I was writing this chapter.
当你读到这里时，这可能将是默认版本但我已经使用`gem install rspec --pre`。因为它是之前的发行版，当我在写这一章时。

    $ rspec ts_spec.rb
    ****
    Pending:
      TennisScorer basic scoring should start with a score of 0-0
        # Not yet implemented
        # ./ts_spec.rb:2
      TennisScorer basic scoring should be 15-0 if the server wins a point
        # Not yet implemented
        # ./ts_spec.rb:3
      TennisScorer basic scoring should be 0-15 if the receiver wins a point
        # Not yet implemented
        # ./ts_spec.rb:4
      TennisScorer basic scoring should be 15-15 after they both win a point
        # Not yet implemented
        # ./ts_spec.rb:5
    Finished in 0.00039 seconds
    4 examples, 0 failures, 4 pending

That’s pretty cool. 
太酷了。
Executing the tests echoes our expectations back at us, telling us that each has yet to be implemented. 
运行这个测试返回我们的预期，告诉我们每个预期是否被完成。
Coding, like life, is full of these disappointments. 
编写代码，就像生活，充满了失望。
However, unlike life, fixing things is just a few keystrokes away. 
不过，也不像生活，只需敲打键盘就可完成。
Let’s start by meeting the first expectation—when a game starts, the score should be 0 to 0. 
让我们开始，看看第一个预期 - 当游戏开始，分数应该是0比0.
We’ll start by fleshing out the test:
我们开始编写测试：
`unittesting/bdd/2/ts_spec.rb`

    require_relative "tennis_scorer"
    describe TennisScorer, "basic scoring" do
      it "should start with a score of 0-0" do
        ts = TennisScorer.new
        ts.score.should == "0-0"
      end
      it "should be 15-0 if the server wins a point"
      it "should be 0-15 if the receiver wins a point"
      it "should be 15-15 after they both win a point"
    end

Note that we’ve assumed we have a class TennisScorer in a file called `tennis_scorer.rb`. 
注意我们假定我们在`tennis_scorer.rb`文件里有一个TennisScorer类。
Our first expectation now has a code block associated with it. 
我们的第一个预期现在有了相关的代码区块。
Inside that block, we create a TennisScorer and then use a funky RSpec syntax to validate that the score starts out at 0 to 0. 
在区块里面，我们创建了TennisScorer，然后使用特别的RSpec语法来验证分数开始时是0比0.
This partic- ular aspect of RSpec probably generates the most controversy—some people love it, others find it awkward. 
RSpec这个特别的方面可能产生最多的论战 --一些人喜欢，一些人觉得笨拙。
Either way, ts.score.should == "0-0" is basically the same as an assertion in Test::Unit.
不管怎么样，ts.score.should == "0-0"基本上和Test::Unit的断言相同。

We’ll beef up our TennisScorer class, but only enough to let it satisfy this assertion:
我们将补充TennisScorer类，但只要它满足这个断言就可以了。
`unittesting/bdd/2/tennis_scorer.rb `

    class TennisScorer
      def score
        "0-0"
      end
    end

We’ll run our spec again:
我们再次运行spec：

    $ rspec ts_spec.rb
    .***
    Pending:
      TennisScorer basic scoring should be 15-0 if the server wins a point
        # Not yet implemented
        # ./ts_spec.rb:9
      TennisScorer basic scoring should be 0-15 if the receiver wins a point
        # Not yet implemented
        # ./ts_spec.rb:10
      TennisScorer basic scoring should be 15-15 after they both win a point
        # Not yet implemented
        # ./ts_spec.rb:11
    Finished in 0.00054 seconds
    4 examples, 0 failures, 3 pending

Note that we now have three pending expectations; the first one has been satisfied.
注意我们现在有三个未完成的预期，第一个已经得到满足。
Let’s write the next expectation:
让我们写下第二个预期：
`unittesting/bdd/3/ts_spec.rb`

    require_relative "tennis_scorer"
    describe TennisScorer, "basic scoring" do
      it "should start with a score of 0-0" do
        ts = TennisScorer.new
        ts.score.should == "0-0"
      end
      it "should be 15-0 if the server wins a point" do
        ts = TennisScorer.new
        ts.give_point_to(:server)
        ts.score.should == "15-0"
      end
      it "should be 0-15 if the receiver wins a point"
      it "should be 15-15 after they both win a point"
    end

This won’t run, because our TennisScorer class doesn’t implement a `give_point_to` method. 
它不会运行。因为我们的TennisScorer类还没有完成`give_point_to`方法。
Let’s rectify that. 
修正它。
Our code isn’t finished, but it lets the test pass:
代码还没有完成，但可以通过测试了：
`unittesting/bdd/3/tennis_scorer.rb`

    class TennisScorer
      OPPOSITE_SIDE_OF_NET = { :server => :receiver, :receiver => :server }
      def initialize
        @score = { :server => 0, :receiver => 0 }
      end
      def score
        "#{@score[:server]*15}-#{@score[:receiver]*15}"   # 分数转换，并显示。
      end
      def give_point_to(player)
        other = OPPOSITE_SIDE_OF_NET[player]              # 调换对手？
        fail "Unknown player #{player}" unless other      # 
        @score[player] += 1                               # 加分。
      end
    end

Again, we’ll run the specification:
我们再次运行预期：

    $ rspec ts_spec.rb
    ..**
    Pending:
      TennisScorer basic scoring should be 0-15 if the receiver wins a point
        # Not yet implemented
        # ./ts_spec.rb:15
      TennisScorer basic scoring should be 15-15 after they both win a point
        # Not yet implemented
        # ./ts_spec.rb:16
    Finished in 0.00067 seconds
    4 examples, 0 failures, 2 pending

We’re now meeting two of the four initial expectations. 
我们现在看看四个初始预期中的两个。
But, before we move on, note there’s a bit of duplication in the specification: both our expectations create a new TennisScorer object. 
但，在这之前，注意在规范里有些相同的地方：我们的预期都创建了一个新的TennisScorer类。
 We can fix that by using a before stanza in the specification. 
我们可以在预期中使用一个前奏来修改。
This works a bit like the setup method in Test::Unit, allowing us to run code before expectations are executed. 
运作起来有点像Test::Unit的setup方法，允许我们在执行预期之前运行代码。
Let’s use this feature and, at the same time, build out the last two expectations:
我们用上这个特性，同时构建最后两个预期：
`unittesting/bdd/4/ts_spec.rb`

    require_relative "tennis_scorer"
    describe TennisScorer, "basic scoring" do
      before(:each) do
        @ts = TennisScorer.new
      end
      it "should start with a score of 0-0" do
        @ts.score.should == "0-0"
      end
      it "should be 15-0 if the server wins a point" do
        @ts.give_point_to(:server) @ts.score.should == "15-0"
      end
      it "should be 0-15 if the receiver wins a point" do
        @ts.give_point_to(:receiver) @ts.score.should == "0-15"
      end
      it "should be 15-15 after they both win a point" do
        @ts.give_point_to(:receiver)
        @ts.give_point_to(:server) @ts.score.should == "15-15"
      end
    end

Let’s run it:
运行它：

    $ rspec ts_spec.rb
    ....
    Finished in 0.00088 seconds
    4 examples, 0 failures

Finally, RSpec gives us an alternative way of setting up conditions for our tests. 
最后，RSpec给我们一个可选的方法，为我们的测试设置条件。
The let method creates what looks like a variable (it’s actually a dynamically defined method) whose value is given by evaluating a block. 
let方法创建一个看起来像变量，但其值通过block计算得到的东西（实际上是一个动态定义的方法）。
This lets us write the following:
这让我们写下：
`unittesting/bdd/5/ts_spec.rb`

    require_relative "tennis_scorer"
    describe TennisScorer, "basic scoring" do
      let(:ts) { TennisScorer.new}
      it "should start with a score of 0-0" do
        ts.score.should == "0-0"
      end
      it "should be 15-0 if the server wins a point" do
        ts.give_point_to(:server)
        ts.score.should == "15-0"
      end
      it "should be 0-15 if the receiver wins a point" do
        ts.give_point_to(:receiver)
        ts.score.should == "0-15"
      end
      it "should be 15-15 after they both win a point" do
        ts.give_point_to(:receiver)
        ts.give_point_to(:server)
        ts.score.should == "15-15"
      end
    end

We’re going to stop here, but I suggest that you might want to take this code and continue to develop it. 
我们要停下了。但我建议你应该保存代码并继续开发它。
Write expectations such as these:
就像这样，写下预期：

    it "should be 40-0 after the server wins three points"
    it "should be W-L after the server wins four points"
    it "should be L-W after the receiver wins four points"
    it "should be Deuce after each wins three points"
    it "should be A-server after each wins three points and the server gets one more"

RSpec has a lot more depth than just the description of expectations. 
RSpec有很多比上面描述的更深的预期。
In particular, you can use it with Cucumber, an entire language for describing and running complete user stories. 
特别地，你可以用Cucumber使用它，一个完整的语言来描述和运行完成用户故事。
 But that’s beyond the scope of this book.
但这超出了这本书的范围。

### 13.4.2 没人用Shoulda？ Anyone for Shoulda?
RSpec is testing with attitude. 
RSpec是有态度的测试。
On the other hand, Shoulda takes many of the ideas from RSpec and humbly offers them to you for integration into your regular unit tests. 
在另一方面，Shoulda从RSpec得到了很多理念，并谦恭地将他们提供整合给你的正常的单元测试。
For many developers, particularly those with existing Test::Unit tests, this is a good compromise. 
对于很多开发者来说，特别那些现有Test::Unit测试，这是一个很好的折衷。
You get much of the descriptive power of RSpec-style expectations without having to commit to the full framework.
你得到很多描述力的RSpec风格的预期，无需提交到全框架中。

Install Shoulda using gem install shoulda. 
使用`gem install shoulda`安装Shoulda。
Then, unlike RSpec, write a regular Test::Unit test case. 
然后，不像RSpec，写一个正常的Test::Unit测试用例。
Inside it, though, you can use the Shoulda mini-language to describe your tests.
在里面，你可以使用Shoulda迷你语言来描述你的测试。

Let’s recast our final RSpec tennis scoring tests using Shoulda:
让我们用Shoulda重做一次我们最后RSpec网球分数测试。
`unittesting/bdd/4/ts_shoulda.rb`

    require 'test/unit'
    require 'shoulda'
    require_relative 'tennis_scorer.rb'
    class TennisScorerTest < Test::Unit::TestCase
      def assert_score(target)
        assert_equal(target, @ts.score)
      end
      context "Tennis scores" do
        setup do
          @ts = TennisScorer.new
        end
        should "start with a score of 0-0" do
          assert_score("0-0")
        end
        should "be 15-0 if the server wins a point" do
          @ts.give_point_to(:server)
          assert_score("15-0")
        end
        should "be 0-15 if the receiver wins a point" do
          @ts.give_point_to(:receiver)
          assert_score("0-15")
        end
        should "be 15-15 after they both win a point" do
          @ts.give_point_to(:receiver)
          @ts.give_point_to(:server)
          assert_score("15-15")
        end
      end
    end

运行：

    $ ruby ts_shoulda.rb
    Run options:
    # Running tests:
    ....
    Finished tests in 0.008528s, 469.0432 tests/s, 469.0432 assertions/s.
    4 tests, 4 assertions, 0 failures, 0 errors, 0 skips
    ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

Behind the scenes, Shoulda is creating Test::Unit test methods for each should block in your tests. 
场景的背后，Shoulda为测试里的每个should区块创建Test::Unit测试方法。
This is why we can use regular Test::Unit assertions in Shoulda code. 
这就是为什么我们可以在Shoulda代码中使用正常的Test::Unit断言。
But Shoulda also works hard to maintain the right context for our tests. 
但Shoulda也努力为我们的测试保持正确的环境。
For example, we can nest contexts and their setup blocks, allowing us to have some initialization that’s common to all tests and some that’s common to just a subset. 
比如，我们能套入上下文和他们的设置区块，允许我们对于所有测试都有的和一些只是子集才有的，做一些初始化。
We can apply this to our tennis example. 
我们可以应用这个到我们的网球例子中。
We’ll write nested contexts and put setup blocks at each level. 
我们将写嵌套上下文，并将设置区块放在每个水平上。
When Shoulda executes our tests, it runs all the appropriate setup blocks for the should blocks.
当Shoulda执行我们的测试，它为should区块运行所有适合的设置区块。
`unittesting/bdd/4/ts_shoulda_1.rb`

    require 'test/unit'
    require 'shoulda'
    require_relative 'tennis_scorer.rb'
    class TennisScorerTest < Test::Unit::TestCase
      def assert_score(target)
        assert_equal(target, @ts.score)
      end
      context "Tennis scores" do
        setup do
          @ts = TennisScorer.new
        end
        should "start with a score of 0-0" do
          assert_score("0-0")
        end
        context "where the server wins a point" do
          setup do
            @ts.give_point_to(:server)
          end
          should "be 15-0" do
            assert_score("15-0")
          end
          context "and the oponent wins a point" do
            setup do
              @ts.give_point_to(:receiver)
            end
            should "be 15-15" do
              assert_score("15-15")
            end
          end
        end
        should "be 0-15 if the receiver wins a point" do
          @ts.give_point_to(:receiver)
          assert_score("0-15")
        end
      end
    end

Let’s run it:
运行：

    $ ruby ts_shoulda_1.rb
    Run options:
    # Running tests:
    ....
    Finished tests in 0.008962s, 446.3289 tests/s, 446.3289 assertions/s.
    4 tests, 4 assertions, 0 failures, 0 errors, 0 skips
    ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

Would we use these nested contexts for this tennis scoring example? 
我们可以使用这些嵌套上下文到这个网球评分例子吗？
We probably wouldn’t as it stands, because the linear form is easier to read. 
这一点我们可能不会，因为线性形式更易读。
But we use them all the time when we have tests where we want to run through a complex scenario that builds from test to test. 
但我们一直使用他们，当我们有测试,我们想运行测试，通过一个复杂的从测试构建的情景。
 This nesting lets us set up an environment, run some tests, then change the environment, run more tests, change it again, run even more tests, and so on. 
这个嵌套让我们设置一个环境，运行一些测试，然后改变环境，运行更多测试，再次改变它，运行更多测试，如此类推。
It ends up making tests far more compact and removes a lot of duplication.
它会使测试更紧凑，去除大量的重复。

# 　第13章　当遇到麻烦时
## 　　13.1　Ruby调试器
ruby自带一个调试器，集成到ruby的基本系统中。
可以通过在调用解释器时使用-r debug选项，连同ruby的其他选项以及脚本名称，来允许调试器。

    Ruby -r debug [调试选项] [程序文件] [程序参数]

调试器支持常用的功能，包括设置断点、步入或跳过方法调用以及显示调用栈和变量。
它还能列出某个对象或类中定义的实例方法，列出并控制ruby中单独的县城。
下面表13.1列出调试器中可用的所有命令。

    ---
    b [reak] [file|class:]line  在file（默认为当前文件）或class的给定行设置断点
    b [reak] [file|class:]name  在file或class的method中设置断点。 
    b [reak]                    显示断点和监视点
    wat [ch] expr               当表达式为真时中止
    del [ete] [nnn]             删除断点nnn（默认为全部）
    cat [ch] exception          当发生exception时异常停止运行
    cat [ch]                    列出当前捕获的异常
    tr [ace] (on|off) [all]     开关对当前线程或所有线程的执行跟踪
    ---
    disp [lay] expr             每当调试器获得控制时即显示表达式的值。
    disp [lay]                  显示当前display         
    undisp [lay] [nnn]          删除display（默认为当前所有）
    ---
    c [ont]                     继续执行
    s [tep] nnn=1               执行下面的nnn行，遇到方法则进入执行
    n [ext] nnn=1               执行下面的nnn行，遇到方法则跨国执行
    fin [ish]                   完成当前函数的执行
    q [uit]                     退出调试器
    ---
    w [here]                    显示当前的调用栈
    f [rame]                    与where同义
    l [ist] [start–end]         列出源代码的start行到end行
    up nnn=1                    在调用栈中上移nnn层
    down nnn=1                  在调用栈中下移nn层
    ---
    v [ar] g [lobal]            显示全局变量
    v [ar] l [ocal]             显示局部变量
    v [ar] i [stance] obj       显示obj的实例变量
    v [ar] c [onst] Name        显示给定类或者模块中的常量
    ---
    m [ethod] i [nstance] obj   显示obj的实例方法
    m [ethod] Name              显示给定类或者模块的实例方法
    ---
    th [read] l [ist]           列出所有线程
    th [read] [c[ur[rent]]]     显示当前线程的状态
    th [read] [c[ur[rent]]] nnn 使线程nnn成为当前线程，并停止它
    th [read] stop nnn          使线程nn成为当前线程，并停止它
    th [read] resume nnn        继续执行线程nnn
    th [read] [sw[itch]] nnn    切换线程上下文为nnn
    ---
    [p] expr                    在当前上下文中执行expr，expr时可能会包含变量赋值或者方法调用
    h[elp]                      显示命令概要
    empty                       重复上次执行的命令

如果你在安装ruby时启用了readline功能，就可以使用方向盘在命令的历史记录中来回选择，还可以行编辑命令来修正前面的输出。
下面是一个会话的例子：

    $ ruby -r debug t.rb
    Debug.rb
    Emacs support available.
    t.rb:1:def fact(n)
    (rdb:1) list 1-9   # list 1-9是用户输入，列出源代码1-9行
    [1, 10] in t.rb
     => 1 def fact(n)
        2   if n <= 0
        3     1
        4   else
        5     n * fact(n-1)
        6   end
        7 end
        8
        9 p fact(5)
    (rdb:1) b 2                   # b2是用户输入；回到第2行。
    Set breakpoint 1 at t.rb:2 
    (rdb:1) c                     # c 是用户输入；继续执行。
    breakpoint 1, fact at t.rb:2
    t.rb:2: if n <= 0
    (rdb:1) disp n                # disp n 是用户输入；干嘛？？
    1: n = 5
    (rdb:1) del 1                 # del 1 是用户输入；删除断点1.
    (rdb:1) watch n==1            # watch n==1 是用户输入；n === 1时终止。
    Set watchpoint 2
    (rdb:1) c                     # c 是用户输入；继续执行。
    watchpoint 2, fact at t.rb:fact
    t.rb:1:def fact(n)
    1: n = 1
    (rdb:1) where                 # where 是用户输入；显示当前调用栈。
    --> #1 t.rb:1:in `fact'
        #2 t.rb:5:in `fact'
        #3 t.rb:5:in `fact'
        #4 t.rb:5:in `fact'
        #5 t.rb:5:in `fact'
        #6 t.rb:9
    (rdb:1) del 2                  # del 2 是用户输入；删除断点2.
    (rdb:1) c                    # c 是用户输入；继续执行。
    120


## 　　13.2　交互式Ruby
irb，实际上是ruby的shell。使用它提供的环境，可以实时把玩ruby语言：

    irb [irb选项] [ruby脚本] [程序参数]

例子：

    % irb
    irb(main):001:0> a = 1 +
    irb(main):002:0* 2 * 3 /
    irb(main):003:0* 4 % 5
    => 2
    irb(main):004:0> 2+2
    => 4             
    irb(main):005:0> def test
    irb(main):006:1> puts "Hello, world!"
    irb(main):007:1> end
    => nil           
    irb(main):008:0> test
    Hello, world!
    => nil
    irb(main):009:0>

irb中可以创建子会话。
每个会话可以有自己的上下文。
例如，可以创建一个和原始会话有相同上下文的子会话，也可以在某个类或实例的上下文中创建子会话。

    Figure 13.1. Sample irb session
    % irb
    irb(main):001:0> irb
    irb#1(main):001:0> jobs
    #0->irb on main (#<Thread:0x401bd654>: stop)
    #1->irb#1 on main (#<Thread:0x401d5a28>: running)
    irb#1(main):002:0> fg 0
    #<IRB::Irb:@scanner=#<RubyLex:0x401ca7>,@signal_status=:IN_EVAL,
               @context=#<IRB::Context:0x401ca86c>>
    irb(main):002:0> class VolumeKnob
    irb(main):003:1> end
    => nil
    irb(main):004:0> irb VolumeKnob
      # In this same irb session,
      # we’ll create a new
      # subsession in the context
      # of class VolumeKnob.
    irb#2(VolumeKnob):001:0> def initialize
    irb#2(VolumeKnob):002:1> @vol=50
    irb#2(VolumeKnob):003:1> end
    => nil
    irb#2(VolumeKnob):004:0> def up
    irb#2(VolumeKnob):005:1> @vol += 10
    irb#2(VolumeKnob):006:1> end
    => nil
    irb#2(VolumeKnob):007:0> fg 0
      # We can use fg 0 to
      # switch back to the main
      # session, take at look at all
      # current jobs, and see what
      # instance methods
      # VolumeKnob defines.
    #<IRB::Irb:@scanner=#<RubyLex:0x401ca7>,@signal_status=:IN_EVAL,
               @context=#<IRB::Context:0x401ca86c>>
    irb(main):005:0> jobs
    #0->irb on main (#<Thread:0x401bd654>: running)
    #1->irb#1 on main (#<Thread:0x401d5a28>: stop)
    #2->irb#2 on VolumeKnob (#<Thread:0x401c400c>: stop)
    irb(main):006:0> VolumeKnob.instance_methods
    => ["up"]
    irb(main):007:0> v = VolumeKnob.new
     # Make a new VolumeKnob
     # object, and create a new
     # subsession with that
     # object as the context.
    #<VolumeKnob: @vol=50>
    irb(main):008:0> irb v
    irb#3(#<VolumeKnob:0x401e7d40>):001:0> up
    => 60
    irb#3(#<VolumeKnob:0x401e7d40>):002:0> up
    => 70
    irb#3(#<VolumeKnob:0x401e7d40>):003:0> up
    => 80
    irb#3(VolumeKnob):004:0> fg 0
     # Switch back to the main
     # session, kill the
     # subsessions, and exit.
    #<IRB::Irb:@scanner=#<RubyLex:0x401ca7>,@signal_status=:IN_EVAL,
               @context=#<IRB::Context:0x401ca86c>>
    irb(main):009:0> kill 1,2,3
    => [1, 2, 3]
    irb(main):010:0> jobs
    #0->irb on main (#<Thread:0x401bd654>: running)
    irb(main):011:0> exit

irb支持的所有命令，见后面185页开始的索引。
如果内建了GNU的readline功能，可以使用方向键或vi快捷键来编辑单个的输入行，返回到前面执行的命令来重新执行或编译它。
irb非常便于快速尝试想法，以知道它是否可行。

## 　　13.3　编辑器支持
ruby解释器被设计成一次读一个程序：你可以通过管道把整个程序作为标准输入传递给解释器。
我们可以利用这个优点在编辑器内运行ruby代码。
Emacs中，可以选择一段代码，使用Meta-I来执行，输出写入名为Shell Command Output的缓冲区内。
vi中，%!ruby会用代码运行的结果替换程序文本。`:w !ruby`会显示输出而不影响缓冲区。
ruby的源码misc/目录下的ruby-mode.el文件中包含了Emacs的ruby模式。也可以在网络上找到vim、jed和其他编辑器的语法高亮显示模块。
查看RubyFAQ（http://www.rubygarden.org/iowa/faqtotum）可以获得最新的信息和资源列表。
## 　　13.4　但是它不运作

1. 运行脚本时启用警告（-w命令行选项）
2. 如果碰巧忘记了参数列表中的“,” -- 特别是用于输出时 -- 会招致非常奇怪的错误信息。
3. 源代码最后一行的解析错误经常是由于某处遗失了end关键字造成的。有时会是很前面的地方。
3.    丑陋的消息 --syntax error, unexpected $end, expecting keyword_end(语法错误，未期待的$end, 等待关键字) --意味着你的代码中哪个地方有一个end被遗失了（消息里的$end意味着文件的结束，所以消息只是意味着：ruby在你的代码的结尾处暂停了，在它找到所有预期的end关键之前）。尝试使用-w选项，当发现end没有和if/while/class匹配使用时会发出警告。
  This ugly message—syntax error, unexpected $end, expecting keyword_end—means that you have an end missing somewhere in your code. (The $end in the message means end-of- file, so the message simply means that Ruby hit the end of your code before finding all the end keywords it was expecting.) Try running with -w, which will warn when it finds ends that aren’t aligned with their opening if/while/class.
4. 没有调用属性设置方法。在类定义中，setter=被解释为局部变量的赋值语句，而不是方法调用。self.setter=则表示方法调用。
例子：

    class Incorrcet
      attr_accessor :one :two
      def initialize
        one = 1          # 不正确的设置
        self.two = 2
      end
    end
    obj = Incorrcet.new
    obj.one             # nil
    obj.two             # 2

5. 对象看起来没有被正确设置，通常由于initialize方法或者实例变量名拼写错误造成。
6.  和ruby1.9一样，block的参数不再和局部变量处于一个作用域之下。这可能不兼容老代码。带-w选项运行会发现这些事项：
As of Ruby 1.9, block parameters are no longer in the same scope as local variables. This may be incompatibile with older code. Run with the -w flag to spot these issues:

    entry = "wibble"
    [1, 2, 3].each do |entry|
      # do something with entry
    end
    puts "Last entry = #{entry}"
    # produces:
    # prog.rb:2: warning: shadowing outer local variable - entry
    # Last entry = wibble

6. block的参数和局部变量处于相同的作用域中。<kinder:note> 这一条只适用于ruby1.8,从1.9开始已经为上一条所更正。
例子：

    c = "carbon"
    i = "iodine"
    elements = [ c, i ]
    elements.each_with_index do |element, i|
      # do thing
    end
    c   # "carbon"
    i   #  1

7. 优先级的问题。特别是当使用{}，而不是do～end时。
例子：

    def one(arg)
      if block_given?
        "block given to 'one' returns #{yield}"
      else
        arg
      end
    end
    def two
      if block_given?
        "block given to 'two' returns #{yield}"
      end
    end
    result1 = one two {       # 结果给了two方法，那one方法返回什么？
      "three"
    }
    result2 = one two do       # 结果给了one方法，那two方法返回什么？
      "three"
    end
    puts "With braces, result = #{result1}"
    puts "With do/end, result = #{result2}"
    # produces:
    # With braces, result = block given to 'two' returns three
    # With do/end, result = block given to 'one' returns three

8. 终端输出可能被缓存，于是无法立即看到输出信息。另外，如果同时向$stdout和$stderr输出信息，则输出顺序和你期望的可能不同。应该使用非缓冲I/0来处理调试用信息（设置sync=true）
9. 若数字来路不正规，则实际上可能是字符串。调用Intiger和map进行转换。
例子：

    while line = gets
      num1, num2 = line.split(/,/)
      # ...
    end

可以这样改写：

    while line = gets
      num1, num2 = line.split(/,/)
      num1 = Integer(num1)
      num2 = Integer(num2)
      # ...
    end

或者使用map来一次性转换所有的字符串

    while line = gets
      num1, num2 = line.split(/,/).map {|val| Integer(val) }
      # ...
    end

10. 无意的别名。
例子：

    arr = [1, 2]
    hash = { arr  => "value" }
    hash[arr]     → "value"
    arr[0] = 99   
    hash[arr]     →  nil
    hash.rehash   →  {[99, 2]=>"value"}
    hash[arr]     →  "value"

11. 确保使用对象的类是你预想的。可使用`puts my_obj.class`查看。
12. 如果方法调用结果和期望的不符，确保将参数放到小括号内部。
13. 确保方法参数列表的左括号紧跟在方法名后面，中间没有空格。
14. 使用irb和调试器
15. 使用Object#freeze。如果你怀疑某段未知的代码会将变量设置为一个虚妄值，则试着冻结该变量。

渐增式地开发应用程序，使得编写代码既容易又有趣。
写几行代码，运行，使用Test::Unit写一些测试。再写更多的代码...
动态类型语言的一个主要好处是你不必等到代码完善之后才运行它们。

## 　　13.5　然而它太慢了
解释性的高级语言没有低级语言的运行速度快。
通常慢的程序会有一两个性能瓶颈，浪费了执行时间。找到并改进这些瓶颈，将使得程序的效率立刻得到改善。难点在于如何找到他们。
关于其他的指示信息，查看索引中的Performance部分。
### 13.5.1 Benchmark
这个模块用来对代码段计时。详见后面657页。
例如我们可能想知道一个大的循环到底是使用循环内的局部变量速度快、还是使用外部已存的变量速度快：

    Figure 13.2. Comparing variable access costs using benchmark
    require 'benchmark'
    include Benchmark
    LOOP_COUNT = 1_000_000
    bm(12) do |test|
      test.report("normal:") do
        LOOP_COUNT.times do |x|
          y = x + 1
        end
      end
      test.report("predefine:") do
        x = y = 0
        LOOP_COUNT.times do |x|
          y = x + 1
        end
      end
    end
    produces:
                user      system    total        real
    normal:     3.110000  0.000000  3.110000 (   4.954929)
    predefine:  2.560000  0.000000  2.560000 (   3.009354)

使用benchmark需要很小心，因为垃圾回收常常会导致ruby程序运行速度变慢。
垃圾回首可能在程序运行的任何时候发生，因此可能会给你错误的结果：benchmark显示一段代码运行很慢，实际上是由于执行该段代码时垃圾回收恰好被出发造成的。
benchmark模块的bmbm方法会运行测试两次，一次预演，一次实际测量性能，力图将垃圾回收带来的影响降低到最低。
### 13.5.2 剖析器
Profiler，详见后面717页；可以告诉你程序中每个方法调用的次数以及ruby运行这些方法的平均时间和累计时间。
可以使用-r profile命令行选项。 也可以在代码中使用require语句。
例子：

    require 'profile'
    count = 0
    words = File.open("/usr/share/dict/words")
    while word = words.gets
      word = word.chomp!
      if word.length == 12
        count += 1
      end
    end
    puts "#{count} twelve-character words"

结果：

     20460 twelve-character words
     % cumulative self           self total
     time  seconds seconds calls    ms/call ms/call       name  
     7.76  12.01   12.01 234937     0.05    0.05          String#chomp!
     7.75  24.00   11.99 234938     0.05    0.05          IO#gets
     7.71  35.94   11.94 234937     0.05    0.05          String#length
     7.62  47.74   11.80 234937     0.05    0.05          Fixnum#==
     0.59  48.66   0.92  20460      0.04    0.04          Fixnum#+
     0.01  48.68   0.02 1           20.00   20.00        Profiler__.start_profile
     0.00  48.68   0.00 1           0.00    0.00          File#initialize
     0.00  48.68   0.00 1           0.00    0.00          Fixnum#to_s
     0.00  48.68   0.00 1           0.00    0.00          File#open
     0.00  48.68   0.00 1           0.00    0.00          Kernel.puts
     0.00  48.68   0.00 2           0.00    0.00          IO#write
     0.00  48.68   0.00 1           0.00    154800.00     #toplevel

分析：
首先注意上面显示的耗时，比不是用剖析器运行程序要慢得多。剖析器对性能影响很大，但影响是全局性的。因此获得的相对值仍然是有意义的。
上面这个程序明显花费了很多时间在循环上。高达235000次。
因此可以修改代码降低循环体的运行代价或者完全不用循环，可提高性能
改进代码：

    require 'profile'
    words = File.read("/usr/share/dict/words")
    count = words.scan(PATT= /^............\n/).size
    puts "#{count} twelve-character words"

运行结果：

     20460 twelve-character words
     % cumulative self           self     total
     time  seconds seconds calls  ms/call  ms/call  name
     96.67 0.29    0.29    1      290.00   290.00   String#scan
     6.67  0.31    0.02    1      20.00    20.00    Profiler__.start_profile
     0.00  0.31    0.00    1      0.00     0.00     Array#size
     0.00  0.31    0.00    1      0.00     0.00     Kernel.puts
     0.00  0.31    0.00    2      0.00     0.00     IO#write
     0.00  0.31    0.00    1      0.00     0.00     Fixnum#to_s
     0.00  0.31    0.00    1      0.00     300.00   #toplevel
     0.00  0.31    0.00    1      0.00     0.00     File#read

请记住，随后如果不使用剖析，检查一下代码 -- 有时候剖析器引起的速度降低可能会掩盖其他问题。
包括创建不必要的对象、执行不必要的工作，代码过于臃肿等。

### 13.5.3 Code Execution Coverage代码执行覆盖
Ruby 1.9.2 comes with low-level code coverage built in to the interpreter (see the Coverage module on page 740).
Ruby 1.9.2带来了一个内置于解释器中的低水平的代码覆盖器（见后面740页的Coverage模块）
It tracks which lines of code were executed in your code.
它跟踪着你代码中哪一行被执行。

People are starting to build libraries that wrap this low-level functionality with filters, HTML output, and the like. 
人们正在开始建立各种库，用过滤器、HTML输出等类似的东西包装这个低水平功能。
Two examples are Mark Bates’ CoverMe and Christoph Olszowka’s simplecov.
在Mark Bates的CoverMe和Christoph Olszowka的simplecov中有两个例子。

Both are installed as gems, and both come with comprehensive instructions on how to integrate them into your test environment.
两者都可用gems安装，都带来全面的说明以集成到你的测试环境中。
For our simple tennis scoring example, the summary, written as an HTML file, is fairly straightforward:
对于我们简单的网球计分的例子来说，总结，写成一个HTML文件，是相当简单的。

Click the name of a file, and you’ll get a display of which lines were executed:
单击一个文件名，你就会得到看到哪一行已被执行：


# 第2部分　Ruby与其环境
# 　第14章　Ruby和Ruby世界
## 　　14.1　命令行参数
In the beginning was the command line,“最初”始于命令行。
ruby命令行由3部分组成：选项，程序名，程序参数。

    ruby [option] [--] [programfile] [arguments]
    ruby [选项]   [--] [程序文件]    [命令行参数]

其中双连字符（--）和以连字符（-）开始的单词，都表示选项结束。
如果没有指定程序名称，或者名称为连字符（-），则从标准输入读入程序源代码。
### 14.1.1 命令行选项
下面的选项主要来自ruby2.0的man页。参考了本书的解释和其他解释。

OPTIONS  选项
     Ruby interpreter accepts following command-line options (switches).  They
     are quite similar to those of perl(1).
     Ruby 解释器接受下面命令行选项（开关）。这些选项和perl的很相似。

     --copyright    Prints the copyright notice.
                    显示版权提醒

     --version      Prints the version of Ruby interpreter.
                    显示ruby解释器的版本

     -0[octal]      (The digit “zero”.)  Specifies the input record separator
                    ($/) as an octal number. If no digit is given, the null
                    character is taken as the separator.  Other switches may
                    follow the digits.  -00 turns Ruby into paragraph mode.
                    -0777 makes Ruby read whole file at once as a single
                    string since there is no legal character with that value.
                    标志0（数字0）指定记录分隔字符（如果后面没有跟其他数字，则分隔字符是\0）。
                    以8进制数指定输入记录分隔符('$/')。
                    若不指定数字的话，分隔符是空字符(等同于$/="\0")。数字后面可以有其他的开关(switch)。
                    -00代表段落模式(等同于$/="")，
                    -0777(因为这个代码不代表任何文字)表示将文件的全部内容一次性读入(相当于$/=nil)。  

     -C directory
     -X directory   Causes Ruby to switch to the directory.
                    执行脚本之前，先移动到指定目录。

                    cd to directory, before executing your script		在执行脚本之前，转到目录

     -E external[:internal]
     --encoding external[:internal]
                    Specifies the default value(s) for external encodings and
                    internal encoding. Values should be separated with colon
                    (:).
                    为外部编码和内部编码指定默认值。值应该用冒号(:)分隔。

                    You can omit the one for internal encodings, then the
                    value (Encoding.default_internal) will be nil.
                    你可以省略内部编码的值，该值（Encoding.default_internal）默认为nil
                    <kinder:note> 本书第四版的表述：
                    Specifies the default character encoding for data read from and written to the outside world. 
                    为从外部世界读取数据和写入到外部世界指定默认的字符编码。
                    This can be used to set both the external encoding (the encoding to be assumed for file contents) and optionally the default internal encoding (the file contents are transcoded to this when read and transcoded from this when written). 
                    这可同时用于设置外部编码（文件内容的假定编码）和默认内部编码（读入时文件内容的编码转换成这个，写入时从这个编码转换）
                    The format of the encoding parameter is -E external, -E external:internal, or -E :internal. 
                    编码参数的格式是-E external，-E external:internal,或者-E:internal。
                    See Chapter 17, Character Encoding, on page 239 for details. 
                    详见第17章，字符编码，在239页
                    See also -U.
                    也见-U选项。


     --external-encoding=encoding
     --internal-encoding=encoding
                    Specify the default external or internal character encod‐
                    ing
                    指定的外部或内部字符编码。

     -F pattern     Specifies input field separator ($;).
                    指定输入字段分隔符（$;）。

                    输入字段分隔符作为split()的默认分隔符（影响-a选项）。

                    split() pattern for autosplit (-a)	
                    为-a分割模式

     -I directory   Used to tell Ruby where to load the library scripts.
                    Directory path will be added to the load-path variable
                    ($:).
                    指定(追加)加载文件的路径。指定的目录将被追加到Ruby的数组变量($:)中。

                    specify $LOAD_PATH directory (may be used more than once)			指定$LOAD_PATH目录（可指定多个）
                    
                    <kinder:note> 本书表述：
                   指定前插到$LOAD_PATH($:)的目录。
                   可以出现多个-I选项。每个-I选项后面可以有多个目录，它们在类UNIX系统中以冒号分隔，在DOS/WINDOWS系统中以分号分开。

     -K kcode       Specifies KANJI (Japanese) encoding. The default value for
                    script encodings (__ENCODING__) and external encodings
                    (Encoding.default_external) will be the specified one.
                    kcode can be one of
                    指定KANJI(日本)编码。脚本编码和外部编码的默认值将是该指定值。
                    kcode可能是下面之一：

                          e       EUC-JP
                          s       Windows-31J (CP932)
                          u       UTF-8
                          n       ASCII-8BIT (BINARY)

                    将来有可能会改变文字编码处理方式，届时该选项的内容也会有所变化。
                     <kinder:note> 本书补充：这个选项主要用在日语处理上。

     -S             Makes Ruby use the PATH environment variable to search for
                    script, unless its name begins with a slash.  This is used
                    to emulate #! on machines that don't support it, in the
                    following manner:
                      该选项表明，当脚本名不是以'/'开头的时候，要使用环境变量PATH的值搜索脚本。
                      若您的机器不支持#!的话，可以使用下列方法模拟#!的运行：

                          #! /usr/local/bin/ruby
                          # This line makes the next one a comment in Ruby \
                            exec /usr/local/bin/ruby -S $0 $*

                      #!/bin/sh
                      exec ruby -S -x $0 "$@"
                      #! ruby
                      因为第1行的关系，系统把脚本交给/bin/sh。/bin/sh执行第2行后启动Ruby解释器。
                      在-x选项的作用下，Ruby解释器把从'#!'到包含'ruby'的行的内容全部读入。
                      根据系统的不同，$0未必包含完整路径，因此有必要使用'-S'选项来告诉Ruby在必要时搜索脚本。

                      <kinder:note> 本书表述：
                      使用RUBYPAT或PATH环境变量查找程序文件。

     -T[level=1]    Turns on taint checks at the specified level (default 1).
                    打开执行水平的污点检查。（默认1）

                      执行不纯度测试。若给level指定了一个值之后，安全等级也会使用这个值。省略level时，其值为1。
                      对于CGI程序来说，将其指定为-T1比较合适。$SAFE的等级也将被设定。
                      <kinder:note> 本书的描述：
                      设置安全级别，启用tainting检查（见后面397页25章ruby安全，安全级别一节）

     -U             Sets the default value for internal encodings
                    (Encoding.default_internal) to UTF-8.
                    将内部编码的默认值(Encoding.default_internal)设置为UTF-8
                    <kinder:note> 第四版补充：
                    Sets the default internal encoding to UTF-8. See Chapter 17, Character Encoding, on page 239 for details. See also -E.
                    设置默认的内部编码为UFT-8。详见后面239页17章“字符编码”。也参见-E选项。

     -W[level=2]    Turns on verbose mode at the specified level without
                    printing the version message at the beginning. The level
                    can be;
                    打开指定水平的冗长模式，无需在开头显示版本信息。
                    冗长水平可以是：

                          0       Verbose mode is "silence". It sets the
                                  $VERBOSE to nil.
                                  “沉默”冗长模式 -- 将$VERBOSE设置为nil。

                          1       Verbose mode is "medium". It sets the
                                  $VERBOSE to false.
                                  "中度"冗长模式 -- 将$VERBOSE设置为false。

                          2 (default) Verbose mode is "verbose". It sets the
                                  $VERBOSE to true.  -W2 is same as -w
                                  “冗长”的冗长模式，为默认值 -- 将$VERBOSE设置为true。 -W2和-w一样。

                     <kinder:note> 本书补充：
                     使用W0,绝对不会给出任何警报（包括使用Kernel.warn发出的那些警告）

     -a             Turns on auto-split mode when used with -n or -p.  In
                    auto-split mode, Ruby executes

                          $F = $_.split

                    at beginning of each loop.
                    与'-n'或'-p'一起使用时，可以打开自动拆分模式(auto split mode)。自动拆分模式将在各个循环前执行以下动作：`$F = $_.split`

                    若没有同时指定'-n'或'-p'选项的话将不起作用。

     -c             Causes Ruby to check the syntax of the script and exit
                    without executing. If there are no syntax errors, Ruby
                    will print “Syntax OK” to the standard output.

                    只对脚本进行编译，而并不执行。编译后若没发现语法错误，则在标准输出显示“Syntax OK”。

     -d
     --debug        Turns on debug mode.  $DEBUG will be set to true.
                    以调试模式执行脚本。将$DEBUG设置成true。
                    <kinder:note> 本书的表述：
                    设置$DEBUG和$VERBOSE为true。可以被程序使用来打开额外的信息跟踪。

     -e command     Specifies script from command-line while telling Ruby not
                    to search the rest of the arguments for a script file
                    name.
                   在命令行中指定脚本,告诉ruby不用再从参数中搜索脚本文件名了。
                   
                   <kinder:note> 书中的表述：
                   将command作为一行ruby源代码来执行。
                   允许多个-e选项，这些command被视为同一程序中的多行代码。
                   如果使用-e时省略programfile参数，运行完这些-e命令后解释器会停止。
                   使用-e选项运行的程序可以使用区间和正则表达式在条件语句中的老式行为-- 整数区间与当前输入行号进行比较，而正则表达式对$_变量进行匹配。
                    
                   若多次使用-e选项时，系统会按照以下方式处理。
                   下列各表达式的意义相同。
                   ruby -e "5.times do |i|" -e "puts i" -e "end"

                   ruby -e "5.times do |i|
                     puts i
                   end"
                   ruby -e "5.times do |i|; puts i; end"

     -h
     --help         Prints a summary of the options.
                    显示选项的摘要

     -i extension   Specifies in-place-edit mode.  The extension, if speci‐
                    fied, is added to old file name to make a backup copy.
                    For example:
                    指明替换模式。如果指定了extension，它将被追加在原文件名的后面形成一个备份文件。

                          % echo matz > /tmp/junk
                          % cat /tmp/junk
                          matz
                          % ruby -p -i.bak -e '$_.upcase!' /tmp/junk
                          % cat /tmp/junk
                          MATZ
                          % cat /tmp/junk.bak
                          matz

                      对参数中指定的文件内容进行替换(in-place edit)。原始文件将被加上扩展名并保存下来。
                      若没有扩展名的话，将不会进行备份，而且只有替换后的文件会被保留下来。
                      <kinder:note> 本书的表述：
                      直接编辑ARGV文件。对于ARGV中的每个文件，写入到标准输出的任何内容都会保存为该文件的内容。如果提供了扩展名，会生成文件的一个备份拷贝。

     -l             (The lowercase letter “ell”.)  Enables automatic line-end‐
                    ing processing, which means to firstly set $\ to the value
                    of $/, and secondly chops every line read using chop!.
                    启用自动行尾处理功能。这意味着首先将$\设置为$/，然后使用chop!方法截断(chop)每一行。

                      进行行尾自动处理。
                      首先，将$\改为$/的值，在print输出时添加换行。
                      若使用了-n标志或-p标志的话，将对gets读入的各行末尾进行String#chop!处理。

     -n             Causes Ruby to assume the following loop around your
                    script, which makes it iterate over file name arguments
                    somewhat like sed -n or awk.

                          while gets
                            ...
                          end

                      若使用了该标志，则整个程序会像sed -n或awk一样，被`while gets; ... ;end`括起来运行。

     -p             Acts mostly same as -n switch, but print the value of
                    variable $_ at the each end of the loop.  For example:
                      与-n标志相仿，在各循环后输出变量$_的值。
                      例:

                          % echo matz | ruby -p -e '$_.tr! "a-z", "A-Z"'
                          MATZ

                     <kinder:note> 本书表述：
                     把程序放在`while gets; ...; print; end`循环中。

     -r library     Causes Ruby to load the library using require.  It is use‐
                    ful when using -n or -p.
                      执行脚本前，先对feature指定的库执行require操作。与'-n'选项、'-p'选项一起使用时特别奏效。

     -s             Enables some switch parsing for switches after script name
                    but before any file name arguments (or before a --).  Any
                    switches found there are removed from ARGV and set the
                    corresponding variable in the script.  For example:
                    对跟在脚本名之后但文件名参数之前（或双连线之前）的参数进行解析。
                    那里出现的任何开关都会从ARGV中删除，并设置脚本里的对应变量。例如：
`
                      对跟在脚本名后并且以'-'开头的参数进行解释，并将其值赋值给同名的全局变量。
                      遇到以'--'开头的参数就停止解释，并将该参数从ARGV中删除。
                      例:

                          #! /usr/local/bin/ruby -s
                          # prints "true" if invoked with `-xyz' switch.
                          print "true\n" if $xyz

                     <kinder:note> 本书表述和举例：
                     出现在程序文件之后，但在任何文件名参数或者--之前的命令行开关会从ARGV中删除，同时把它设置给用选项开关名字命名的全局变量中。下面这个例子中，它的效果就是把$opt变量设置为“electric”：
                     $ ruby -s prog -opt=electric ./mydata

                    On some systems $0 does not always contain the full path‐
                    name, so you need the -S switch to tell Ruby to search for
                    the script if necessary (to handle embedded spaces and
                    such).  A better construct than $* would be ${1+"$@"}, but
                    it does not work if the script is being interpreted by
                    csh(1).
                    一些系统的$0不总是包含完整的路径名，因此必要时（比如处理内嵌空格之类的任务），你需要-S开关来告诉ruby搜索脚本。
                    一个比`$*`更好的构造应是${1+"$@"} -- 但如果脚本用csh解释时这会失败。

     -v
     --verbose      Enables verbose mode without printing version message at
                    beginning and set the variable $VERBOSE to true.  Some
                    methods print extra messages if this variable is true.  If
                    this switch is given, and no other switches are present,
                    Ruby quits after printing its version.
                      启用冗长模式。
                      启动时显示版本信息，将内部变量$VERBOSE设为true。
                      当此变量为true时，一些方法在运行时会显示额外的信息。
                      若只设定'-v'选项，没有其他选项开关时，启动后会先显示版本信息，然后就结束运行(不会等待来自标准输入的脚本)。

     -w             Enables verbose mode without printing version message at
                    the beginning.  It sets the $VERBOSE variable to true.
                    冗长模式，但在开始时不显示版本信息。它将$VERBOSE变量设置为true。
                    <kinder:note> 本书补充：
                    与-v选项不一样，如果命令行中没有指定程序文件，它从标准输入中读取程序源码。建议使用-w选项来运行ruby程序。

     -x[directory]  Tells Ruby that the script is embedded in a message.
                    Leading garbage will be discarded until the first line
                    that starts with “#!” and contains the string, “ruby”.
                    Any meaningful switches on that line will be applied.  The
                    end of the script must be specified with either EOF, ^D
                    (control-D), ^Z (control-Z), or the reserved word __END__.
                    If the directory name is specified, Ruby will switch to
                    that directory before executing script.
                    告诉ruby:脚本被嵌在一个信息里。
                    主要垃圾将被丢失，直到第一行用“#!”开始，并包含“ruby”字符串。
                    该行任何有意义的开关将应用。
                    脚本的结尾必须用EOF,^D,^Z或者__END__明确指明。
                    如果指定了目录名，ruby将在执行脚本之前移动到那个目录。

                      从message中取出脚本并执行。读入脚本的范围是从'#!'开始，直到包含'ruby'的行为止。
                      用EOF(文件结束)，^D(controlD)，^Z(controlZ)或保留字_END_来指定脚本结束。
                      若指定了目录名的话，则在执行脚本前移动到该指定目录。

                     <kinder:note> 本书补充：
                     删除#!ruby行之前的文本，如果给出了directory，则将工作目录改为directory。

     -y
     --yydebug      DO NOT USE.
                    不要使用这个选项！

                    Turns on compiler debug mode.  Ruby will print a bunch of
                    internal state messages during compilation.  Only specify
                    this switch you are going to debug the Ruby interpreter.
                    打开编译调试模式。ruby将在编译过程中打印一堆内在状态信息。
                    只在调试ruby解释器时打开这个开关。

                      编译器调试模式。编译脚本时显示语法分析的过程。
                      该显示过程会很漫长，可能只对那些想调试编译器的人有用。

                     <kinder:note> 本书描述：
                     在语法分析器中启用yacc调试（太多的信息！）。

     --disable-FEATURE
     --enable-FEATURE
                    Disables (or enables) the specified FEATURE.
                    关闭（或开启）指定的特性。
                    --disable-gems
                    --enable-gems      Disables (or enables) RubyGems
                                       libraries.  By default, Ruby will load
                                       the latest version of each installed
                                       gem. The Gem constant is true if
                                       RubyGems is enabled, false if other‐
                                       wise.
                                       关闭（或开启）RubyGems库。
                                       默认ruby将导入每个已安装的gem的最新版本。
                                       如果开启了RubyGems，Gem常数为true；否则为false。
                                       <kinder:note> 本书第四版描述：
                                       Stops(Allow) Ruby from automatically loading RubyGems from require.
                                       停止（允许）ruby自动从require自动导入RubyGems。

                    --disable-rubyopt
                    --enable-rubyopt   Ignores (or considers) the RUBYOPT
                                       environment variable. By default, Ruby
                                       considers the variable.
                                       忽略（或使用）RUBYOPT环境变量。默认使用。
                                       <kinder:note> 本书第四版描述：
                                       Prevents Ruby from examining the RUBYOPT environment variable. You should probably set this in an environment you want to secure.
                                       阻止ruby检查RUBYOPT环境变量。你应该在一个你想要的安全环境中设置这个选项。

                    --disable-all
                    --enable-all       Disables (or enables) all features.
                                       关闭（或开启）所有特性。
                                       <kinder:note> 本书第四版描述：
                                       Disable (or enable) the rubygems and RUBYOPT options (see the following descriptions)
                                       关闭（或打开）rubygems和RUBYOPT选项（参见相关描述）

     --dump=target  DO NOT USE.
                    不再使用。

                    Prints the specified target.  target can be one of;

                          insns   disassembled instructions

                    Only specify this switch if you are going to debug the
                    Ruby interpreter.
                    打印指定目标。目标可以是“insns disassembled instructions”中的一个。只有你想调试Ruby解释器时，指定这个开关。

### 14.1.2 ARGV
程序文件后面出现的任何命令行参数在ruby程序中可用。保存在全局数组ARGV中。
比如：

    $ cat test.rb
    ARGV.each {|arg| p arg}
    $ ruby -w test.rb "Hello World" a1 1.6180
    "Hello World"
    "a1"
    "1.6180"

对于C程序员来说这里有一个经常出错的地方--ARGV[0]是程序的第一个参数而不是程序名称。程序名称位于全局变量$0之中。
还要注意ARGV中所有的值都是字符串。

如果程序试图从标准输入（或者使用特别文件ARGF，详见后面336页）中读取，ARGV中的**程序参数会被当作文件名称**，然后Ruyb会从这些文件中读取。 
如果程序把参数和文件名称混合在一起，那就确保从这些文件读取之前已清空了ARGV数组中的非文件名参数。

### 14.1.3 ARGF
It is common for a command line program to take a list of zero or more file names to process.
一个命令行程序,带着等待处理的零个或多个文件名的列表，是很常见的。
It will then read through these files in turn, doing whatever it does.
它会逐个读取这些文件，进行操作。

Ruby provides a convenience object, referenced by the name ARGF, that handles access to these files. 
Ruby提供了一个方便的对象，通过引用名称ARGF，处理这些文件的访问。
When your program starts, ARGF is initialized with a reference ARGV. 
当你的程序开始，ARGF被引用的ARGV初始化。
Because this is a reference, changes to make to ARGV (for example when you remove options as you process them) are seen by ARGF.
因为这是一个引用，ARGV看起来被ARGF所修改（例如，当您为处理它们而删除选项时）。

If you read from ARGF (for example by calling ARGF.gets) or from standard input (for example by calling plain gets), Ruby will open the file whose name is the first element of ARGV and perform the I/O on it. 
如果你从ARGF（例如通过调用ARGF.gets）或从标准输入（例如通过调用无格式的gets）读取，ruby将打开那些文件名是ARGV第一个元素的文件，并对其执行文件I/O。
If, as you continue to read, you reach the end of that file, Ruby closes it, shifts it out of the ARGV array, and then opens the next file in the list. 
如果你继续读下去，你到达文件结束，ruby关闭它，从ARGV数组移除，然后打开列表中下一个文件。
At some point, when you finishing reading from the last file, ARGV will return an end-of-file condition (so gets will return nil, for example). 
在某些时候，当你完成从最后文件的读取，ARGV将返回文件结束的状态（所以gets将返回nil，例如）。
If ARGV is initially empty, ARGF will read from standard input.
如果ARGV最初是空的，ARGF将从标准输入读取。

<kinder:note> 有些懵。下面来自第二版后面336页的解释。
$> (AVGF)
An object that provides access to the concatenation of the contents of all the files given as command-line arguments or $stdin (in the case where there are no arguments). 
一个可以访问作为命令行参数给出或者$stdin（当没有参数的时候）给出的所有文件的内容对象。

$< supports methods similar to a File object:
$< 支持的方法和File对象类似：
binmode, close, closed?, each, each_byte, each_line, eof, eof?, file, filename, fileno, getc, gets, lineno, lineno=, path, pos, pos=, read, readchar, readline, readlines, rewind, seek, skip, tell, to_a, to_i, to_io, to_s, along with the methods in Enumerable. 

The method file returns a File object for the file currently being read. 
file方法返回表示当前正在读取的文件的File对象。
This may change as $< reads through the files on the command line. 
返回的对象可能会改变，因为`$<`会依次读取命令行上给出的文件。
[r/o]
</kinder:note> 

You can get to the name of the file currently being read from using ARGF.filename, and you can get the current File object as ARGF.file. 
你可以使用ARGF.filename得到当前正被读入的文件名，你也可以将当前的File对象看作是ARGF.file。
ARGF keeps track of the total number of lines read in ARGF.lineno—if you need the line number in the current file, use ARGV.file.lineno. 
ARGF在变量ARGF.lineno跟踪读入的行数的总数 -- if你需要当前行在当前文件中的行号，使用ARGV.file.lineno。
Here’s a program that uses this information:
这是一个程序，使用此信息：

    while line = gets
      printf "%d: %10s[%d] %s", ARGF.lineno, ARGF.filename, ARGF.file.lineno, line
    end

If we run it, passing a couple of file names, it will copy the contents of those files.
如果我们运行它，传入一对文件名，它会复制这些文件的内容。

    $ ruby copy.rb testfile otherfile
    1: testfile[1] This is line one
    2: testfile[2] This is line two
    3: testfile[3] This is line three
    4: testfile[4] And so on...
    5: otherfile[1] ANOTHER LINE ONE
    6: otherfile[2] AND ANOTHER LINE TWO
    7: otherfile[3] AND FINALLY THE LAST LINE

### 14.1.4 In-place Editing 就地编辑
In-place editing is a hack inherited from Perl. 
就地编辑是从Perl黑过来的。
It allows you to alter the contents of files passed in on the command line, retaining a backup copy of the original contents. 
它允许你改变命令行中出现的文件的内容，保留原内容的备份副本。

 To turn on in-place editing, give Ruby the file extension to use for the backup file, either with the -i [ext] command line option, or by calling `ARGF.inplace_mode=ext` in your code. 
打开就地编辑，给Ruby文件扩展名作为备份文件，要么用-i[ext]命令行选项，或代码中通过调用`ARGF.inplace_mode=ext`。
Now, as your code reads through each file given on the command line, Ruby will rename the original file by appending the backup extension. 
现在，当你的代码读取在命令行给出的每个文件，ruby将通过附加备份扩展重命名原始文件。
It will then create a new file with the original name, and open it for writing on standard output. 
它将用原始文件新建一个新文件，并打开它，在标准输出写入内容。
This all means that if you code a program such as this:
这就意味着如果你的代码是这样一个项目：

    while line = gets
      puts line.chomp.reverse
    end

and you invoked it using
你可以这样调用它：

    $ ruby -i.bak reverse.rb testfile otherfile

You’d find that testfile and otherfile would now have reversed lines, and that the original files would be available in testfile.bak and otherfile.bak.
你会发现，现在testfile和otherfile已经按行反转，原来的文件会在testfile.bak和otherfile.bak。

For finer control over the I/O to these files, you can use the methods provided by ARGF.
为更好地控制I/O这些文件，你可以使用ARGF所提供的方法。
They’re rarely used, so rather than document them here, we’ll refer you to ri or the online documentation.
他们很少使用，所以不在这里介绍，建议您参考ri或在线文档。

## 　　14.2　程序终止
Kernel#exit方法会终止程序，返回一个状态值给操作系统。
但exit没有立即终止程序。Kernel#exit首先抛出可以捕获的SystemExit异常，然后执行若干清理动作，包括运行任何已注册的`at_exit`方法和对象的终止方法(finalizers)。详情参见后面521页的Kernel#exit。
## 　　14.3　环境变量
可以使用预定义的变量ENV访问操作系统环境变量。它相应与Hash相同的方法。[2]
[2] ENV实际上不是散列表，但如果需要，可以使用`ENV#to_hash`把它转换成Hash。

    ENV['SHELL']    → "/bin/sh"
    ENV['HOME']     → "/Users/dave"
    ENV['USER']     → "dave"
    ENV.keys.size   → 34
    ENV.keys[0, 7]  → ["MANPATH", "TERM_PROGRAM", "TERM", "SHELL",
                      "SAVEHIST", "HISTSIZE", "MAKEFLAGS"]

某些环境变量的值在ruby第一次运行时被读取，见下表14.1所示，这些变量会改变解释器的行为。
表14.1 Ruby使用的环境变量

    DLN_LIBRARY_PATH  动态装入模块的查找路径
    HOME              指向用户主目录。在文件名和目录名中展开～时使用它   
    LOGDIR            如果没有设置$HOME，它是用户主目录的fallback指针。只被Dir.chdir使用
    OPENSSL_CONF      指定OperSSL配置文件的位置
    RUBYLIB           ruby程序的附加查找路径（$SAFE必须为0）
    RUBYLIB_PREFIX   （只限于Windows）通过将前缀添加到RUBYLIB的每个组成部分，来改编(mangle)RUBYLIB查找路径。
    RUBYOPT           ruby的附加命令行选项；在解析完实际的命令行选项之后被检查（$SAFE必须为0）
    RUBYPATH          使用-S选项时Ruby程序的查找路径（默认为PATH）
    RUBYSHELL         在windows下创建执行进程时要用到的shell，如果没有设置，则会检查SHELL或COMSPEC环境变量。
    RUBY_TCL_DLL      覆盖TCL共享库或DLL的默认名称
    RUBY_TK_DLL       覆盖TK共享库或DLL的默认名称，使用它或者RUBY_TCL_DLL时都必须要设置这两个选项。


**虚拟机内存变量  ⇡New in 2.0⇣**
Other environment variables affect the memory allocated by the Ruby virtual machine for various tasks. [3]
其他环境变量通过ruby的虚拟机，影响内存分配，用于一些任务
[3]. This applies to MRI only.
这只适用于MRI(<kinder:note> Matz's Ruby Interpreter，就是Matz用c语言写的ruby语言解释器)。

Variable Name                          Description
变量名                                 描述
RUBY_THREAD_VM_STACK_SIZE              The VM stack size used at thread creation: 128KB (32 bit CPU) or 256KB (64 bit CPU).
                                       用于创建线程的虚拟机堆栈的大小
RUBY_THREAD_MACHINE_STACK_SIZE         The machine stack size used at thread creation: 512KB (32 bit CPU) or 1024KB (64 bit CPU).
                                       用于创建线程的机器堆栈的大小
RUBY_FIBER_VM_STACK_SIZE               VM stack size used at fiber creation: 64KB or 128KB.
                                       用于创建纤程的虚拟机堆栈的大小
RUBY_FIBER_MACHINE_STACK_SIZE          The machine stack size used at fiber creation: 256KB or 256KB.
                                       用于创建纤程的机器堆栈的大小

The current value of these variables can be read using `RubyVM::DEFAULT_PARAMS`.
这些变量的现值可通过使用`RubyVM::DEFAULT_PARAMS`来读取。

### 14.3.1 写入环境变量
ruby程序可能写入ENV对象，在大多数系统上这会改变相应环境变量的值。
当然这种变化仅限于做出这种改变的进程，以及随后被它创建的那些子进程。
例如：

    puts "In parent, term = #{ENV['TERM']}"
    fork do
      puts "Start of child 1, term = #{ENV['TERM']}"
      ENV['TERM'] = "ansi"
      fork do
        puts "Start of child 2, term = #{ENV['TERM']}"
      end
      Process.wait
      puts "End of child 1, term = #{ENV['TERM']}"
    end
    Process.wait
    puts "Back in parent, term = #{ENV['TERM']}"
    # produces:
    # In parent, term = xterm-color
    # Start of child 1, term = xterm-color
    # Start of child 2, term = ansi
    # End of child 1, term = ansi
    # Back in parent, term = xterm-color


## 　　14.4　从何处查找它的模块
使用require或者load把程序库模块装入到程序中。有些模块是ruby自带的，有些可能是从ruby应用归档（Ruby Application Archive）安装的，有些可能是自己开发的，ruby如何找到它们呢？
为特定机器编译ruby时，预定义了一组标准目录去保存ruby程序库：

    $ ruby -e 'puts $:'
    /usr/local/lib/ruby/site_ruby/2.0.0
    /usr/local/lib/ruby/site_ruby/2.0.0/i686-linux
    /usr/local/lib/ruby/site_ruby
    /usr/local/lib/ruby/vendor_ruby/2.0.0
    /usr/local/lib/ruby/vendor_ruby/2.0.0/i686-linux
    /usr/local/lib/ruby/vendor_ruby
    /usr/local/lib/ruby/2.0.0
    /usr/local/lib/ruby/2.0.0/i686-linux

`site_ruby`目录是为了保存已经添加的那些模块和扩展。
与体系结构相关的目录（i686-linux）保存特定于这种机器的可执行文件和其他东西。
所有这些目录会自动被包括在ruby的模块查找路径中。

有时这还不够。
可能你正忙于一个以ruby编写的大型项目上，已经编译了大量ruby代码的程序库，并希望组里每个人都可以访问这些代码。
可以有几种选择来实现它。

如果程序运行在安全级别0（参见后面397页开始的第25章）上，可以把环境变量RUBYLIB设置成一个包含一个或多个查找目录的列表。

如果程序没有setuid，可以使用命令行参数-I来做同样的事情。[3]
[3]目录之间的分隔符和平台相关，Windows上是分号（;），Unix上是冒号（:）

**ruby变量`$:`**
是一个目录数组，用来查找已装入的文件，被初始化为标准目录表，加上用RUBYLIB和-I选项所指定的所有附加目录。程序运行过程中随时可以将附加目录添加到这个数组中。
<kinder:note> 第四版补充：
Prior to Ruby 1.9, this used to be a common idiom:
ruby1.9之前，下面这行实在司空见惯：

    $: << File.dirname(__FILE__)
    require 'other_file'

This added the directory of the running file to the search path, so `other_file.rb` could be found there by the subsequent require. 
这将运行中的文件的目录添加到搜索目录，因此`other_file.rb`可以被后来的require语句找到。
Now we use `require_relative` instead.
现在我们使用的是`require_relative`。

    require_relative 'other_file'

后面215页17章描述的RubyGems，这是一个支持网络的包管理系统。

## 15.5 RubyGems Integration RubyGems集成
**RubyGems概述**
This section is based on the start of the chapter on RubyGems written by Chad Fowler for the second edition
of this book.
这一节基于第二版Chad Fowler写的RubyGems一章的开头部分。
<kinder:note> 所以下面的译文基本上来自第二版的17章。
RubyGems是一个库和程序的标准化打包以及安装框架。
它使得定位、安装、升级和卸载ruby包变得容易。

RubyGems出现之前，安装新的程序会涉及：搜索互联网、下载程序库包并试图安装它 -- 结果可能只是发现它的依赖性尚未满足。
如果程序库是用RubyGems打包的，那么，现在可以简单地让RubyGems去安装它（以及它e依赖包）。
每件事情RubyGems都为你完成了。

在RubyGems的世界里，开发人员把他们的程序和库包裹到一个gems文件中。
These files conform to a standardized format and typically are stored in reposi- tories on the Internet (but you can also create your own repositories if you want).
这些文件遵循标准化的格式，存储在互联网的仓库中（但你也可以创建你自己的仓库，如果你想的话）。
同时RubyGems系统提供命令行工具去操作这些gem文件。
It also provides integration into Ruby so that your programs can access gems as libraries.
它也提供了集成进入ruby，所以你的程序可以像库那样访问gems。

Prior to Ruby 1.9, it was your responsibility to install the RubyGems software on your computer. 
在Ruby 1.9之前，在电脑上安装RubyGems软件是你的责任。
Now, however, Ruby comes with RubyGems baked right in.
现在ruby已经帮你把RubyGems装好了！

### 15.5.1 Installing Gems on Your Machine  安装
Your latest project calls for a lot of XML generation. 
你最后的项目需要很多XML生成器。
You could just hard-code it, but you’ve heard about Jim Weirich’s Builder library, which constructs XML directly from Ruby code.
你可以只是努力打下代码，但你已经听过Jim Weirich的Builder库可以直接从Ruby代码中构建XML。

**gem query**
Let’s start by seeing whether Builder is available as a gem:
让我们开始吧，看看Builder是否已经打包成gem：

    $ gem query --details --remote --name-matches builder
    AntBuilder (0.4.3)
        Author: JRuby-extras
        Homepage: http://jruby-extras.rubyforge.org/
        AntBuilder: Use ant from JRuby. Only usable within JRuby
    builder (2.1.2)
        Author: Jim Weirich
        Homepage: http://onestepback.org
        Builders for MarkUp.

The --details option displays the descriptions of any gems it finds. 
--details选项显示它找到的gems的描述。
The --remote option searches the remote repository. 
--remote选项搜索远程仓库。
And the --name-matches option says to search the central gem repository for any gem whose name matches the regular expression /builder/. 
--name-matches选项搜索中心gem仓库中名字匹配正则表达式/builder/的gem。
(We could have used the short-form options -d, -r, and -n.)
(也可以使用短式选项-d，-r和-n)
The result shows a number of gems have builder in their name; the one we want is just plain builder.
结果显示了一些名字带有builder的gems；我们想要的只是builder。
**gem list**
The number after the name shows the latest version. 
名字之后的数字显示最新版本。
You can see a list of all available versions using the --all option. 
你可以使用--all选项查看可用版本清单。
We’ll also use the list command, as it lets us match on an exact name:
我们也使用list命令，因为它用精确的名字来匹配：

    $ gem list --details --remote --all builder
    *** REMOTE GEMS ***
    builder (2.1.2, 2.1.1, 2.0.0, 1.2.4, 1.2.3, 1.2.2, 1.2.1, 1.2.0, 1.1.0, 0.1.1)
        Author: Jim Weirich
        Homepage: http://onestepback.org
        Builders for MarkUp.

**gem install**
Because we want to install the most recent one, we don’t have to state an explicit version on the install command; the latest is downloaded by default:
因为我们想安装最新的版本，因此install安装命令无需明确版本数；默认下载最新版本。

    $ gem install builder
    Successfully installed builder-2.1.2
    1 gem installed
    Installing ri documentation for builder-2.1.2...
    Installing RDoc documentation for builder-2.1.2...

Several things happened here. 
这里发生了几件事情。
First, we see that the latest version of the Builder gem (2.1.2) has been installed. 
首先，我们看到Builder的最新版本gem已经安装完毕。
Next we see that RubyGems has determined that Jim has created docu- mentation for his gem, so it sets about extracting it using RDoc.
下面我们看到RubyGems已经确定Jim已经为他的gem创建了文档，所以着手使用RDoc解压。

If you’re running gem install on a Unix platform and you aren’t using rvm, you’ll need to prefix the command with sudo, because by default the local gems are installed into shared system directories.
如果你正运行gem，安装在一个Unix平台，你没有使用rvm，你需要在命令之前输入sudo，因为默认情况下本地gems被安装进共享系统目录中。

During installation, you can add the -t option to the install command, causing RubyGems to run the gem’s test suite (if one has been created). 
安装期间，你可以增加-t选项给安装命令，这会让RubyGems运行gem的测试套件（如果一个已经被创建）
If the tests fail, the installer will prompt you to either keep or discard the gem. 
如果测试失败，安装器会提示你是保留还是丢弃gem。
This is a good way to gain a little more confidence that the gem you’ve just downloaded works on your system the way the author intended.
这是一个好方法，可以获得多点信心：你下载的gem按照作者希望的方式运行起来。

Let’s see what gems we now have installed on our local box:
让我们看看我们在本地装了什么gems吧：

    $ gem list
    *** LOCAL GEMS ***
    builder (2.1.2)

### 15.5.2 Reading the Gem Documentation 阅读gem文档
**gem environment gemdir**
Being that this is your first time using Builder, you’re not exactly sure how to use it. 
因为这是你第一次使用Builder，你不太清楚怎么使用它。
Fortunately, RubyGems installed the documentation for Builder on your machine. 
幸运的是，RubyGems在你的机器中为Builder安装了文档。
We just have to find it.
我们只需要找到它。

As with most things in RubyGems, the documentation for each gem is stored in a central, protected, RubyGems-specific place. 
正如RubyGems的大多数东西，每个gem的文档被保存在一个集中的、受保护的、RubyGems明确指定的地方。
This will vary by system and by where you may explicitly choose to install your gems. 
这将因系统而异，也因你的明确指定安装目录而异。
The most reliable way to find the documents is to ask the gem command where your RubyGems main directory is located:
寻找文档最可靠的方法是问gem命令：RubyGems的主目录在哪里：

    $ gem environment gemdir
    /usr/local/lib/ruby/gems/1.9.3

RubyGems stores generated documentation beneath the doc/ subdirectory of this directory.
RubyGems把生成的文档存储在这个目录的doc/子目录下。

**gem server**
The easiest way to view gems’ RDoc documentation is to use RubyGems’ included gem server utility. 
查看gem的RDoc文档的最简单的方法，是使用RubyGems包含的的gem server工具。
To start gem server, simply type this:
为了启动gem server，只需要这样键入：

    $ gem server
    Server started at http://[::ffff:0.0.0.0]:8808
    Server started at http://0.0.0.0:8808

gem server启动一个web服务器，运行在启动它的电脑上。
默认情况下，它运行在端口8808上，从默认的RubyGems安装目录为那些gems以及它们的文档提供服务。
端口号和gem目录可以分别通过命令行的-p和-d去重新设置。

一旦你启动了gem server程序，如果运行在本地机器上，用浏览器浏览就可以访问那些已安装的gem文档。
在那里会看到一个列表，包含已安装的gems、它们的描述以及RDoc文档的链接。
Click the rdoc link for Builder—the result will look something like the following.
单击Builder的rdoc链接 -- 结果会出现一些看似下面的东西。

### 15.5.3 Using a Gem 使用一个gem
Once a gem is installed, you use require to load it into your program:[5]
安装好了一个gem，你可使用require将它导入你的程序中。
[5].  Prior to Ruby 1.9, before you could use a gem in your code, you first had to load a support library called rubygems. Ruby now integrates that support directly, so this step is no longer needed.
在ruby1.9之前的版本中，你在代码中使用gem之前，首先要导入一个叫rubygems的支持库。ruby现在直接集成了这个支持，所以这一步不用了。

    require 'builder'
    xml = Builder::XmlMarkup.new(target: STDOUT, indent: 2)
    xml.person(type: "programmer") do
      xml.name do
        xml.first "Dave"
      end
      xml.location "Texas"
      xml.preference("ruby")
    end
    # produces:
    #<person type="programmer">
    #  <name>
    #    <first>Dave</first>
    #  </name>
    #  <location>Texas</location>
    #  <preference>ruby</preference>
    #</person>

### 15.5.4 Gems and Versions  Gems和版本
Maybe you first started using Builder a few years ago. 
可能你首先使用几年前的Builder。
Back then the interface was a little bit different—with versions prior to Build 1.0, you could say this:
那时的界面有些不同--在Build1.0之前的版本，你可以这样说：

    xml = Builder::XmlMarkup.new(STDOUT, 2)
    xml.person do
      name("Dave Thomas")
    end

Note that the constructor takes positional parameters. 
注意构造器需要位置参数。
Also, in the do block, we can say just name(...), whereas the current Builder requires xml.name(...). 
同样，在do的block里面，我们可以说name(...)，然而当前构建器要求xml.name(..)。
We could go through our old code and update it all to work with the new-style Builder—that’s probably the best long- term solution. 
我们可以仔细检查我们的旧代码，并用新风格的Builder更新所有代码，让它运行起来。这可能是最好的长期解决方案。
But we can also let RubyGems handle the issue for us.
但我们也可以让RubyGems为我们处理事情。

When we asked for a listing of the Builder gems in the repository, we saw that multiple
versions were available: [6]
[6].  By the time this book reaches you, the list of available versions will likely have changed.

    $ gem list --details --remote --all builder
    *** REMOTE GEMS ***
    builder (2.1.2, 2.1.1, 2.0.0, 1.2.4, 1.2.3, 1.2.2, 1.2.1, 1.2.0, 1.1.0, 0.1.1)

When we installed Builder previously, we didn’t specify a version, so RubyGems automatically installed the latest. 
之前安装Builder时，我们没有指定版本，所以RubyGems自动安装了最新版本。
But we can also get it to install a specific version or a version meeting some given criteria. 
但也可安装一个指定的符合某些给定条件的版本。
Let’s install the most recent release of Builder with a version number less than 1:
让我们安装安装最近的版本号少于1的的Builder版本，

    $ gem install builder --version '< 1'
    Successfully installed builder-0.1.1
    1 gem installed
    Installing ri documentation for builder-0.1.1...
    Installing RDoc documentation for builder-0.1.1...

Have we just overwritten the 2.1.2 release of Builder that we’d previously installed?
我们是否覆盖了之前安装的2.1.2版本的Builder？
 Let’s find out by listing our locally installed gems:
我们列出所有本地安装的gem：

    $ gem list builder
    *** LOCAL GEMS ***
    builder (2.1.2, 0.1.1)

Now that we have both versions installed locally, how do we tell our legacy code to use the old one while still having our new code use the latest version? 
现在我们安装了两个版本，我们怎么告诉旧代码使用旧的Builder，同时让新代码使用新的Builder？
It turns out that require auto- matically loads the latest version of a gem, so the earlier code on page 219 will work fine. 
require自动导入gem最近的版本，所以219页（15.5.3 使用gem 一章）较早的代码会运行起来。
If we want to specify a version number when we load a gem, we have to do a little bit more work, making it explicit that we’re using RubyGems:
如果导入gem时我们想指定一个版本号，我们只需要做多点工作，使用RubyGems时更明确些：

    gem 'builder', '< 1.0'
    require 'builder'
    xml = Builder::XmlMarkup.new(STDOUT, 2)
    xml.person do
      name("Dave Thomas")
      location("Texas")
    end

The magic is the gem line, which says, “When looking for the Builder gem, consider only those versions less than 1.0.” 
魔法出现在gem行，那里说：“找到Builder gem，只考虑那些版本号小于1.0的”。
The subsequent require honors this, so the code loads the correct version of Builder and runs. 
后面的require也会跟着照办，所以代码导入gem的正确版本，并运行起来。
The "< 1.0" part of the gem line is a version predicate. 
gem行的"< 1.0"部分是版本指示。
The numbers that follow are of the form `major.minor.patch_level`. 
跟着的数字的形式是：主版本.次版本.补丁级别。
The various predicates that RubyGems supports are:
下面RubyGems支持的指示符：
Table 7—Version operators 版本操作符

    Operator   Description
    操作符     描述
    =          Exact version match. Major, minor, and patch level must be identical.
               精确版本匹配。主、次、补丁级别必须相同
    !=         Any version that is not the one specified.
               任何不是指定版本的版本
    >          Any version that is greater (even at the patch level) than the one specified.
               任何比指定版本高的版本（甚至在patch级别）
    <          Any version that is less than the one specified.
               任何比指定版本低的版本
    >=         Any version greater than or equal to the specified version.
               任何比指定版本高或相等的版本
    <=         Any version less than or equal to the specified version.
               任何比指定版本低或相等的版本
    ~>         “Boxed” version operator. Version must be greater than or equal to the specified version and less than the specified version after having its minor version number increased by 1. This is to avoid API incompatibilities between minor version releases.  
                “装箱式”版本操作符。版本必须高于或者等于指定版本，同时应该低于指定版本在次版本号加1后得到的结果。这是为了避免不同版次之间API的不兼容性。

You can specify multiple version predicates, so the following is valid:
你可以指定多个版本，下面的写法是有效的：

    gem 'builder', '> 0.1', '< 0.1.5'

Unfortunately, after all this work, there’s a problem. 
不幸的是，所有工作之后，还有一个问题。
Older versions of Builder don’t run under 1.9 anyway. 
Builder老的版本根本不会在ruby1.9工作。
You can still run this code in Ruby 1.8, but you’d have to update your code to use the new-style Builder if you want to use Ruby 1.9.
你还可以使用ruby1.8运行这个代码，但如果你想使用ruby1.9你只能更新你的代码以使用新风格的Builder。

### 15.5.5 Gems Can Be More Than Libraries Gems不只是库
As well as installing libraries that can be used inside your application code, RubyGems can also install utility programs that you can invoke from the command line. 
安装库可以在程序代码里面使用，RubyGems也可以安装从命令行调用的工具程序。
Often these utilities are wrappers around the libraries included in the gem. 
通常这些工具是在gem里的库文件的包装。
For example, Marcel Molina’s AWS:S3 gem is a library that gives you programmatic access to Amazon’s S3 storage facility. 
比如Marcel Molina的AWS:S3gem是一个库，让你程序访问亚马逊的S3存储设备
As well as the library itself, Marcel provided a command-line utility, s3sh, which lets you interact with your S3 assets. 
除了库的自身，Marcel提供了一个命令行工具，s3sh，让你和S3的特性交互。
When you install the gem, s3sh is automatically loaded into the same bin/ directory that holds the Ruby interpreter.
你安装了这个gem，s3sh就自动导入到存放ruby解释器的同样的bin/目录。

There’s a small problem with these installed utilities. 
这些安装工具有一个小问题。
Although gems supports versioning of libraries, it does not version command-line utilities. 
虽然gems支持库版本，但没有登记命令行的工具的版本。
With these, it’s “last one in wins.”
这是最后一个的胜利。

## 15.6 The Rake Build Tool  Rake编译工具
### 概述
As well as the Builder gem, Jim Weirich wrote an incredibly useful utility program called Rake. 
除了Builder gem，Jim Weirich写了一个非常有用的工具程序，Rake。
Prior to Ruby 1.9, you had to install Rake as a separate gem, but it is now included in the base Ruby installation.
Ruby1.9之前，你需要安装Rake的gem，现在已经包含在ruby的基本安装包中了。

Rake was initially implemented as a Ruby version of Make, the common build utility.
Rake最初是作为ruby版本的Make的实现，Make是一个普通编译工具。
However, calling Rake a build utility is to miss its true power. 
不过，把Rake叫做编译工具实在屈才。
Really, Rake is an automation tool—it’s a way of putting all those tasks that you perform in a project into one neat and tidy place.
其实，Rake是一个自动化工具 -- 它是一种方法，将项目要执行的所有任务放入一个简洁干净的地方。

Let’s start with a trivial example. 
让我们从一个小例子开始吧。
As you edit files, you often accumulate backup files in your working directories. 
编辑文件时，常常在你的工作目录堆积起很多备份文件。
On Unix systems, these files often have the same name as the original files, but with a tilde character appended. 
在Unix系统，这些文件通常名称和原始文件相同，但后缀一个～符号。
On Windows boxes, the files often have a .bak extension.
在Win系统，文件使用.bak扩展名。

**任务**
We could write a trivial Ruby program that deletes these files. 
我们可以写一个小的ruby程序来删除这些文件。
For a Unix box, it might look something like this:
对于Unix系统，大概是这样：

    require 'fileutils'
    files = Dir['*~']
    FileUtils::rm files, verbose: true

The FileUtils module defines methods for manipulating files and directories (see the description in the library section on page 757). 
FileUtils模块定义了一组方法来操作文件和目录（详见后面757页库的描述一节）
Our code uses its rm method. 
我们的代码使用它的rm方法。
We use the Dir class to return a list of filenames matching the given pattern and pass that list to rm.
我们使用Dir类返回一个文件名列表（这些文件名匹配指定的模式），然后列表传给rm。

Let’s package this code as a Rake task—a chunk of code that Rake can execute for us.
让我们将代码打包成Rake任务 -- 就是Rake能为我们执行的代码块。

By default, Rake searches the current directory (and its parents) for a file called Rakefile. 
默认，Rake在当前目录（和子目录）搜索Rakefile文件。
This file contains definitions for the tasks that Rake can run.
这个文件包含Rake可以运行的任务的定义。

So, put the following code into a file called Rakefile:
所以，将下面的代码放入Rakefile文件：

    desc "Remove files whose names end with a tilde"
    task :delete_unix_backups do
      files = Dir['*~']
      rm(files, verbose: true) unless files.empty?
    end

Although it doesn’t have an .rb extension, this is actually just a file of Ruby code. 
虽然没有.rb扩展，但它实际上只有ruby代码。
Rake defines an environment containing methods such as desc and task and then executes the Rakefile.
Rake定义了一个环境，包含一些方法，比如desc、task，然后执行Rakefile。

The desc method provides a single line of documentation for the task that follows it. 
desc方法提供了单行文档，介绍下面的任务。
The task method defines a Rake task that can be executed from the command line. 
task方法定义可以从命令行执行的Rake任务。
The parameter is the name of the task (a symbol), and the block that follows is the code to be executed. 
参数是任务的名字（一个符号），随后的block是执行的代码。
Here we can just use rm—all the methods in FileUtils are automatically available inside Rake files.
这里我们可以只是使用rm -- 所有FileUtils的方法在Rake文件中都是自动可用的。

We can invoke this task from the command line:
我们可以从命令行调用task：

    $ rake delete_unix_backups
    (in /Users/dave/BS2/titles/ruby4/Book/code/rake)
    rm entry~

The first line shows us the name of the directory where Rake found the Rakefile (remember that this might be in a directory above our current working directory). 
第一行显示Rake发现Rakefile的目录名称（记住这可能在一个我们当前工作目录之上的目录）
The next line is the output of the rm method, in this case showing it deleted the single file entry~.
第二行是rm方法的输出，这个例子显示它删除了一个文件emtry～。

OK, now let’s write a second task in the same Rakefile. 
好，现在我们在那个Rakefile里写下第二个任务。
This one deletes Windows backup files.
这个任务删除Windows备份文件。

    desc "Remove files with a .bak extension"
    task :delete_windows_backups do
      files = Dir['*.bak']
      rm(files, verbose: true) unless files.empty?
    end

**组合任务**
We can run this with `rake delete_windows_backups`.
我们可以用`rake delete_windows_backups`运行这段代码。
But let’s say that our application could be used on both platforms, and we wanted to let our users delete backup files on either. 
但我们希望程序可以运行在两种平台上，无论那种都可以删除备份文件。
We could write a combined task, but Rake gives us a better way—it lets us compose tasks. 
我们可以写一个联合任务，但Rake给我们一个更好的方法 -- 组合任务。
Here, for example, is a new task:
这里，比如，是一个新的任务：

    desc "Remove Unix and Windows backup files"
    task :delete_backups => [ :delete_unix_backups, :delete_windows_backups ] do
    puts "All backups deleted"
    end

The task’s name is `delete_backups`, and it depends on two other tasks. 
任务的名字是`delete_backups`，依赖其他两个任务。
This isn’t some special Rake syntax: we’re simply passing the task method a Ruby hash containing a single entry whose key is the task name and whose value is the list of antecedent tasks. 
这不是Rake的特定语法：我们只是将一个包含一个条目(键为任务名称，值为之前的任务)的ruby散列表传递给task方法。
This causes Rake to execute the two platform-specific tasks before executing the `delete_backups` task:
这导致Rake先执行两个指定平台的任务，然后执行`delete_backups`任务。

    $ rake delete_backups
    rm entry~
    rm index.bak list.bak
    All backups deleted

**完整脚本**
Our current Rakefile contains some duplication between the Unix and Windows deletion tasks. 
我们现在的Rakefile包含一些在Unix和Windows之间的删除任务的副本。
As it is just Ruby code, we can simply define a Ruby method to eliminate this:
因为它是纯Ruby代码，我们可以只定义一个Ruby方法来消除它：

    def delete(pattern)
      files = Dir[pattern]
      rm(files, verbose: true) unless files.empty?
    end
    desc "Remove files whose names end with a tilde"
    task :delete_unix_backups do
      delete "*~"
    end
    desc "Remove files with a .bak extension"
    task :delete_windows_backups do
      delete "*.bak"
    end
    desc "Remove Unix and Windows backup files"
    task :delete_backups => [ :delete_unix_backups, :delete_windows_backups ] do
      puts "All backups deleted"
    end

If a Rake task is named default, it will be executed if you invoke Rake with no parameters.
如果Rake任务采用默认命名（Rakefile），如果你不带参数调用Rake，它可被执行。
You can find the tasks implemented by a Rakefile (or, more accurately, the tasks for which there is a description) using this:
你会发现可以使用这个来让Rakefile（或者，更准确说，带有描述的任务）完成任务：

    $ rake -T
    (in /Users/dave/BS2/titles/ruby4/Book/code/rake)
    rake delete_backups # Remove Unix and Windows backup files
    rake delete_unix_backups # Remove files whose names end with a tilde
    rake delete_windows_backups # Remove files with a .bak extension

**更多能力**
This section only touches on the full power of Rake. 
这一节只触及Rake全部能力的一部分。
It can handle dependencies between files (for example, rebuilding an executable file if one of the source files has changed), it knows about running tests and generating documentation, and it can even package gems for you. 
它还可以处理文件之间的依赖（比如，重新构建一个可执行文件，其中一个源文件已经改变），它知道关于运行测试、生成文档，它还能打包成gem。
Martin Fowler has written a good overview of Rake if you’re interested in digging deeper.  [7]
Martin Fowler已经写了一个很好的预览，如果你对更深的知识有兴趣。
You might also want to investigate Sake,[8] a tool that makes Rake tasks available no matter what directory you’re in, or Thor[9], a tool that makes it easy to write Ruby command-line tools.
你也可能想研究Sake，一个无论你在哪个目录都让Rake任务可以运行的工具。或者Thor，一个让你很容易就写出ruby命令行工具的工具。
[7].  http://martinfowler.com/articles/rake.html
[8].  http://errtheblog.com/posts/60-sake-bomb
[9].  http://github.com/wycats/thor

## 　　14.5　编译环境
为特定的体系结构编译ruby时，所有用来编译它的相关设置（包括用来编译ruby的机器的体系结构，编译器选项和源代码目录等等）都被写入到库文件rbconfig.rb中的Config模块。
ruby安装之后，任何ruby程序可以使用这个模块得到编译ruby的细节。
require 'rbconfig'
include Config
CONFIG["host"]              # "powercp-apple-darwin7.7.0"
CONFIG["libdir"]            # "/users/dave/ruby1.8/lib"
扩展库可以使用这个配置文件在给定的体系结构上正确地编译和链接。详见后面275页开始的21章和779页开始的mkmf。

#   16 Namespace,SourceFile, and Distribution 命名空间、源文件和发行版
**增长的烦恼**
As your programs grow (and they all seem to grow over time), you’ll find that you’ll need to start organizing your code—simply putting everything into a single huge file becomes unworkable (and makes it hard to reuse chunks of code in other projects). 
随着你的程序增长（他们都似乎随着时间而增长），你会发现你需要开始整理你的代码 -- 仅仅把一切都放在一个巨大的文件变得不可行（很难使得它在其他项目中的代码块中重用）。
So, we need to find a way to split our project into multiple files and then to knit those files together as our program runs.
因此，我们需要找到一个方法来分割我们的项目为多个文件，然后组织那些文件，为我们的程序运行。

There are two major aspects to this organization. 
有两种主要的方面需要组织。
The first is internal to your code:
首先是代码内部：
how do you prevent different things with the same name from clashing?
怎么避免让不同的东西同时拥有相同的名字。
The second area is related: 
其次是区域相关：
how do you conveniently organize the source files in your project?
你怎么在项目中方便地组织你的源代码？

## 16.1 Namespaces  命名空间
We’ve already encountered a way that Ruby helps you manage the names of things in your programs.
我们已经遇到了一个Ruby帮助你管理程序中的事物的名称的方式。 
If you define methods or constants in a class, Ruby ensures that their names can be used only in the context of that class (or its objects, in the case of instance methods):
如果你在一个类定义方法或常数，ruby确保他们的名字只能在该类的上下文（或它的对象，在实例方法的情况下)：

    class Triangle
      SIDES = 3
      def area
        # ..
      end
    end
    class Square
      SIDES = 4
      def initialize(side_length)
        @side_length = side_length
      end
      def area
      @side_length * @side_length
      end
    end
    puts "A triangle has #{Triangle::SIDES} sides"
    sq = Square.new(3)
    puts "Area of square = #{sq.area}"
    # produces:
    # A triangle has 3 sides
    # Area of square = 9

Both classes define a constant called SIDES and an instance method area, but these things don’t get confused. 
两类都定义了一个叫做SIDES的常数，和一个叫area的实例方法，但这些事情不会混淆。
You access the instance method via objects created from the class, and you access the constant by prefixing it with the name of the class followed by a double colon.
你可以通过一个来自该类的实例来访问实例方法；你可以通过`类名::常量`的方式访问常数。

 The double colon (::) is Ruby’s namespace resolution operator. 
双冒号是ruby的命名空间的解析运算符。
The thing to the left must be  a class or module, and the thing to the right is a constant defined in that class or module.[1]
左边一定是一个类或模块，右边是类或模块里定义的一个常数。
[1].The thing to the right of the :: can also be a class or module method, but this use is falling out of favor —using a period makes it clearer that it’s just a regular old method call.
右面也可能是一个类或模块，但这种用法已经失宠 -- 使用一段时间使它清楚地表明，它只是一个普通的老的方法调用。

So, putting code inside a module or class is a good way of separating it from other code.
所以，将代码放进一个模块或类是一个将它和其他代码隔离开来的好方法。
Ruby’s Math module is a good example—it defines constants such as Math::PI and Math::E and methods such as Math.sin and Math.cos. 
ruby的数学模块是一个好例子 -- 它定义了类似Math::PI和Math::E的常数和Math.sin和Math.cos之类的方法。
You can access these constants and methods via the Math module object:
你可以通过数学模块对象来访问这些常数和方法:

    Math::E # => 2.718281828459045
    Math.sin(Math::PI/6.0) # => 0.49999999999999994

(Modules have another significant use—they implement Ruby’s mixin functionality, which we discussed Section 5.3, Mixins, on page 75.)
（模块有另一种重要的用法 -- 他们完成了ruby的混入功能，详见前面5.3节Mixins）

Ruby has an interesting little secret. 
ruby有一个有趣的小秘密。
The names of classes and modules are themselves just constants[2]. 
类和模块的名字本身就是常数。
[2].Remember that we said that most everything in Ruby is an object. 
记住我们说过ruby里面一切都是对象。
Well, classes and modules are, too.  
当然，类和模块也是。
The name that you use for a class, such as String, is really just a Ruby constant containing the object representing that class.
你使用的类（比如String）的名字，真的是一个ruby常数，它包含表示该类的对象。

And that means that if you define classes or modules inside other classes and modules, the names of those inner classes are just contants that follow the same namespacing rules as other constants:
那意味着如果你在其他类和模块里面定义一个类和模块，内部类的名字只会是常数，和其他常数一样遵循同样的命名空间规则。

    module Formatters
      class Html
        # ...
      end
      class Pdf
        # ...
      end
    end
    html_writer = Formatters::Html.new

You can nest classes and modules inside other classes and modules to any depth you want (although it’s rare to see them more than three deep).
你可以在类和模块里面嵌套任何深度的类和模块（虽然多于三层就已经很少见了）。
So, now we know that we can use classes and modules to partition the names used by our programs. 
所以，现在我们知道我们可以使用类和模块来区分我们程序使用的名字了。
The second question to answer is, what do we do with the source code?
第二个问题是，我们用源代码干什么？

## 16.2 Organizing Your Source 组织源代码
**Java的精髓**
This section covers two related issues: how do we split our source code into separate files, and where in the file system do we put those files?
这一节设计两个相关的事项：我们怎么将源代码分割到独立的文件中去？我们应该将那些文件放在文件系统的哪个位置？

Some languages, such as Java, make this easy. 
一些语言，比如Java，这不是问题。
They dictate that each outer-level class should be in its own file and that file should be named according to the name of the class. 
它们指明每个外部级别的类应在它自己的文件中，该文件应根据该类名而命名。
Other languages, such as Ruby, have no rules relating source files and their content. 
其他语言，比如Ruby，没有关于源文件和内容的规则。
In Ruby, you’re free to organize your code as you like.
在Ruby，你可按自己的意愿来组织代码。

But, in the real world, you’ll find that some kind of consistency really helps. 
不过，在真是世界，你将发现一些惯性做法真是有效。
It will make it easier for you to navigate your own projects, and it will also help when you read (or incor- porate) other people’s code.
它让你更容易地导航你的项目，当你读其他人的代码或者和他人合作代码时这也非常有用。

So, the Ruby community is gradually adopting a kind of de facto standard. 
所以，ruby社区逐步采用了一些事实上的标准。
In many ways, it follows the spirit of the Java model, but without some of the inconveniences suffered by our Java brethren. 
在很多方法上，它吸取了Java模块的精髓，但无需遵守Java同胞必须忍受的不便。
Let’s start with the basics.
让我们从基本开始。

### 16.2.1 Small Programs 一个小程序
**测试的便利**
Small, self-contained scripts can be in a single file. 
短小的、自我包含的脚本可以是单个文件。
However, if you do this, you won’t easily be able to write automated tests for your program, because the test code won’t be able to load the file containing your source without the program itself running. 
不过，如果你这样做，你不能轻易地为你的程序写出自动测试，因为没有程序自身的运行，测试代码不会导入包含你的资源的文件。
So, if you want to write a small program that also has automated tests, split that program into a trivial driver that provides the external interface (the command-line part of the code) and one or more files containing the rest. 
所以，如果你想写有自动测试的小程序，将程序分割成一个小小的驱动（提供外部界面，即代码的命令行部分）和包含程序剩余部分的一个或多个文件。
Your tests can then exercise these separate files without actually running the main body of your program.
你的测试就能运行这些独立的文件，无需真正运行程序主体。

**单行脚本**
Let’s try this for real. 
让我们尝试将这实现。
Here’s a simple program that finds anagrams in a dictionary. 
这是一个小程序，用于查找字典里的变形词汇。
Feed it one or more words, and it gives you the anagrams of each. 
读入一个或多个词语，它将给你挑出变形词来。
Here’s an example:
这是一个例子：

    $ ruby anagram.rb teaching code
    Anagrams of teaching: cheating, teaching
    Anagrams of code: code, coed

If we were typing in this program for casual use, we might just enter it into a single file (perhaps anagram.rb). 
如果我们只是临时使用而写这个程序，我们可能只需要把它放进一个文件即可。
It would look something like this:[3]
看起来像这样：
3.
You might be wondering about the line word.unpack("c*").sort.pack("c*"). 
你可能会`对word.unpack("c*").sart.patk("c*")`这一行感到奇怪。
This uses the function unpack to break a string into an array of characters, which are then sorted and packed back into a string.
这使用了unpack函数将字符串变成字符数列，然后进行排序，再返回变成一个字符串。

packaging/anagram.rb

    #!/usr/bin/env ruby
    require 'optparse'
    dictionary = "/usr/share/dict/words"
    OptionParser.new do |opts|      # <kinder:note>这个"选项解析"类以后再查。
      opts.banner = "Usage: anagram [ options ] word..."
      opts.on("-d", "--dict path", String, "Path to dictionary") do |dict|
        dictionary = dict
      end
      opts.on("-h", "--help", "Show this message") do
        puts opts
        exit
      end
      begin
        ARGV << "-h" if ARGV.empty?
        opts.parse!(ARGV)
      rescue OptionParser::ParseError => e
        STDERR.puts e.message, "\n", opts
        exit(-1)
      end
    end
    # convert "wombat" into "abmotw". All anagrams share a signature
    def signature_of(word)    # 词汇变形
      word.unpack("c*").sort.pack("c*")   # 首先对字节进行解包，返回定数，然后对定数进行排序，再将数组重新装包为字节。
    end
    signatures = Hash.new
    File.foreach(dictionary) do |line|    # 将字典每个词汇都进行变形，并生成一个hash表。
      word = line.chomp
      signature = signature_of(word)
      (signatures[signature] ||= []) << word
    end
    ARGV.each do |word|                   # 将参数词汇匹配字典后输出。
      signature = signature_of(word)      # 对参数进行预处理。
      if signatures[signature]            # 如果该参数在hash中有对应的值，则返回下面这一句。
        puts "Anagrams of #{word}: #{signatures[signature].join(', ')}"
      else
        puts "No anagrams of #{word} in #{dictionary}"
      end
    end

Then someone asks us for a copy, and we start to feel embarrassed. 
有人想要一个程序的副本，我们会觉得困窘。
It has no tests, and it isn’t particularly well packaged.
还没测试，也没适当打包。

**分解思路**
Looking at the code, there are clearly three sections. 
看看代码，有三个章节
The first twenty-five or so lines do option parsing, the next ten or so lines read and convert the dictionary, and the last few lines look up each command-line argument and report the result. 
前25行左右是选项解析。接着10来行读入和转换字段，最后几行查找每个命令行参数并报告结果。
Let’s split our file into four parts:
我们可以将文件分割为四部分：

•  An option parser； 一个选项解析器。
•  A class to hold the lookup table for anagrams；一个类处理变形词汇的查找表。
•  A class that looks up words given on the command line；一个类查找命令行上给出的词汇。
•  A trivial command-line interface；一个命令行界面。

The first three of these are effectively library files, used by the fourth.
前三个是有效的库文件，被第四个所使用。

Where do we put all these files? 
我们要把这些文件放在哪里？
The answer is driven by some strong Ruby conventions, first seen in Minero Aoki’s setup.rb and later enshrined in the RubyGems system. 
答案是根据一些强势的ruby惯例。前者见Minero Aoki的setup.rb，后者保存在RubyGems系统。
We’ll create a directory for our project containing (for now) three subdirectories:
我们将为我们的项目创建一个目录，包含三个子目录。

    anagram/        <- top-level
             bin/   <- command-line interface goes here
             lib/   <- three library files go here
             test/  <- test files go here

Now let’s look at the library files. 
现在让我们d看库文件。
We know we’re going to be defining (at least) three classes.
我们知道我们将定义三个类。

Right now, these classes will be used only inside our command-line program, but it’s conceivable that other people might want to include one or more of our libraries in their own code. 
现在，这些类将只用于命令行程序里面，但其他人可能想在他们的代码中包含我们这一个或多个库。
This means that we should be polite and not pollute the top-level Ruby namespace with the names of all our classes and so on. 
这意味着我们应该礼貌些，不用我们的类名去污染顶级的ruby命名空间，等等。
We’ll create just one top-level module, Anagram, and then place all our classes inside this module. 
我们将创建一个顶级的模块Anagram，然后将我们所有类放入里面。
This means that the full name of (say) our options-parsing class will be Anagram::Options.
这意味着我们的选项解析类的全称是Anagram::Options。

This choice informs our decision on where to put the corresponding source files. 
这个选择告诉我们决定在哪里放置相应的源文件。
Because class Options is inside the module Anagram, it makes sense to put the corresponding file, options.rb, inside a directory named anagram/ in the lib/ directory. 
因为Options类在模块Anagram里面，应明智地将对应文件options.rb放进lib/anagram文件夹。
This helps people who read your code in the future; when they see a name like A::B::C, they know to look for c.rb in the b/ directory in the a/ directory of your library. 
这将有助于人们读懂你的代码。当他们看到一个A::B::C的名字，他们知道能在你的lib/a/b目录寻找c.rb文件。
So, we can now flesh out our directory structure with some files:
所以，我们现在可以将文件放入我们的目录框架了：

    anagram/
            bin/
                anagram <-命令行接口
            lib/
                anagram/
                        finder.rb
                        options.rb
                        runner.rb
            test/
                  ... various test files

**选项解析器和测试**
Let’s start with the option parser. 
开始整理选项解析器。
Its job is to take an array of command-line options and return to us the path to the dictionary file and the list of words to look up as anagrams. 
它的指责是获得命令行选项的数列，然后返回一个字典文件的路径和我们要查找的单词列表。
The source, in lib/anagram/options.rb, looks like this: 
源代码在/lib/anagram/options.rb，看起来类似这样：
Notice how we define the Options class inside a top-level Anagram module.
注意我们怎么在顶级的Anagram模块里面定义Options类。

packaging/anagram/lib/anagram/options.rb

    require 'optparse'
    module Anagram
      class Options
        DEFAULT_DICTIONARY = "/usr/share/dict/words"
        attr_reader :dictionary, :words_to_find
        def initialize(argv)                 # <kinder:note> 初始化方法
          @dictionary = DEFAULT_DICTIONARY   # 找到字典
          parse(argv)                        # 调用下面的parse方法
          @words_to_find = argv              # 将结果赋值给@word_to_find
        end
        private
        def parse(argv)
          OptionParser.new do |opts|          # <kinder:note> 创建一个选项解析对象。
            opts.banner = "Usage: anagram [ options ] word..."
            opts.on("-d", "--dict path", String, "Path to dictionary") do |dict|   # 解析选项-d等
              @dictionary = dict
            end
            opts.on("-h", "--help", "Show this message") do                        # 解析选项-h等
              puts opts
              exit
            end
            begin
              argv = ["-h"] if argv.empty?             # 如果没有解析参数则默认-h
              opts.parse!(argv)
            rescue OptionParser::ParseError => e       # 错误处理
              STDERR.puts e.message, "\n", opts
              exit(-1)
            end
          end
        end
      end
    end

**测试**
Let’s write some unit tests. 
写些单元测试吧。
This should be fairly easy, because options.rb is self-contained— the only dependency is to the standard Ruby OptionParser. 
这当然早了些，因为options.rb是自我包含的 -- 唯一依赖是ruby的标准选项解析器。
We’ll use the Test::Unit framework, extended with the Shoulda gem.[4] 
我们使用Test::Unit框架，并用Shoulda gem来扩展。
We’ll put the source of this test in the file `test/test_options.rb`:
我们将这个测试资源放在文件`test/test_options.rb`中。
[4].  We talk about Shoulda in the Unit Testing chapter on page 186.
之前的186业的13.4我们已经说过这个Shoulda了。

packaging/anagram/test/test_options.rb

    require 'test/unit'
    require 'shoulda'
    require_relative '../lib/anagram/options'
    class TestOptions < Test::Unit::TestCase
      context "specifying no dictionary" do
        should "return default" do
          opts = Anagram::Options.new(["someword"])
          assert_equal Anagram::Options::DEFAULT_DICTIONARY, opts.dictionary
        end
      end
      context "specifying a dictionary" do
        should "return it" do
          opts = Anagram::Options.new(["-d", "mydict", "someword"])
          assert_equal "mydict", opts.dictionary
        end
      end
      context "specifying words and no dictionary" do
        should "return the words" do
          opts = Anagram::Options.new(["word1", "word2"])
          assert_equal ["word1", "word2"], opts.words_to_find
        end
      end
      context "specifying words and a dictionary" do
        should "return the words" do
          opts = Anagram::Options.new(["-d", "mydict", "word1", "word2"])
          assert_equal ["word1", "word2"], opts.words_to_find
        end
      end
    end

The line to note in this file is as follows:
这个文件中下面这一行需要注意：

    require_relative '../lib/anagram/options'

This is where we load the source of the Options class we just wrote. 
这是我们导入刚些的Options类的资源。
We use `require_relative`, as it always loads from a path relative to the directory of the file that invokes it.
我们使用`require_relative`，因为它总是从调用文件的目录的相对路径来导入。

    $ ruby test/test_options.rb
    Run options:
    # Running tests:
    ....
    Finished tests in 0.010588s, 377.7862 tests/s, 377.7862 assertions/s.
    4 tests, 4 assertions, 0 failures, 0 errors, 0 skips
    ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

**查找器和测试**
The finder code (in lib/anagram/finder.rb) is modified slightly from the original version. 
查找器代码（在lib/anagram/finder.rb）修改不多。
To make it easier to test, we’ll have the default constructor take a list of words, rather than a filename. 
为了便于测试，我们让默认构造器处理一个单词列表，而不是一个文件名。
We’ll then provide an additional factory method, `from_file`, that takes a filename and constructs a new Finder from that file’s contents:
我们接着提供一个额外的"工厂"方法`from_file`,处理文件名并从文件的内容中构造一个新的查找器。

packaging/anagram/lib/anagram/finder.rb

    module Anagram
      class Finder
        def self.from_file(file_name)      # 这可是一个类方法。
          new(File.readlines(file_name))   # 这一行以文件的每一行为参数。
        end
        def initialize(dictionary_words)   # 这个类的初始化是对字典进行预处理，并存入一个hash表中。
          @signatures = Hash.new
          dictionary_words.each do |line|
            word = line.chomp
            signature = Finder.signature_of(word)
            (@signatures[signature] ||= []) << word
          end
        end
        def lookup(word)                    # 返回参数词语在hash表中对应的值。
          signature = Finder.signature_of(word)
          @signatures[signature]
        end
        def self.signature_of(word)         # 对参数进行预处理。
          word.unpack("c*").sort.pack("c*")
        end
      end
    end

Again, we embed the Finder class inside the top-level Anagram module. 
再次，我们将Finder类嵌入Anagram模块的顶级。
And, again, this code is self-contained, allowing us to write some simple unit tests:
当然，这个代码也是自我包含的，允许我们写一个简单的单元测试：

packaging/anagram/test/test_finder.rb

    require 'test/unit'
    require 'shoulda'
    require_relative '../lib/anagram/finder'
    class TestFinder < Test::Unit::TestCase
      context "signature" do
        { "cat" => "act", "act" => "act", "wombat" => "abmotw" }.each do |word, signature|
          should "be #{signature} for #{word}" do
            assert_equal signature, Anagram::Finder.signature_of(word)
          end
        end
      end
      context "lookup" do
        setup do
          @finder = Anagram::Finder.new(["cat", "wombat"])
        end
        should "return word if word given" do
          assert_equal ["cat"], @finder.lookup("cat")
        end
        should "return word if anagram given" do
          assert_equal ["cat"], @finder.lookup("act")
          assert_equal ["cat"], @finder.lookup("tca")
        end
        should "return nil if no word matches anagram" do
          assert_nil @finder.lookup("wibble")
        end
      end
    end

These go in test/test_finder.rb:

    $ ruby test/test_finder.rb
    Run options:
    # Running tests:
    ......
    Finished tests in 0.009453s, 634.7191 tests/s, 740.5057 assertions/s.
    6 tests, 7 assertions, 0 failures, 0 errors, 0 skips
    ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

**接口和运行器**
We now have all the support code in place. 
我们已经完全支持了代码。
We just need to run it. 
只需要运行它即可。
We’ll make the command- line interface—the thing the end user actually executes—really thin. 
我们要做一个小巧的命令行接口 -- 最后用户要执行的东西。
It’s in the bin/ directory in a file called anagram (no .rb extension, because that would be unusual in a command). [5]
这个文件名为anagram，放在bin/目录（不要.rb扩展，因为这在命令中不常见）
5.
If you’re on Windows, you might want to wrap the invocation of this in a .cmd file.
如果是Windows，你需要用一个.cmd文件包装起来。

packaging/anagram/bin/anagram

    #! /usr/local/rubybook/bin/ruby
    require 'anagram/runner'
    runner = Anagram::Runner.new(ARGV)
    runner.run

The code that this script invokes (lib/anagram/runner.rb) knits our other libraries together:
这个脚本调用的代码将我们的其他库结合在了一起：

packaging/anagram/lib/anagram/runner.rb

    require_relative 'finder'
    require_relative 'options'
    module Anagram
      class Runner
        def initialize(argv)
          @options = Options.new(argv)  # 将选项传入options，将解析结果传给@option。
        end
        def run
          finder = Finder.from_file(@options.dictionary)   # 以字典为参数构造一个finder
          @options.words_to_find.each do |word|            # 对用户输入参数进行查找
            anagrams = finder.lookup(word)
            if anagrams
              puts "Anagrams of #{word}: #{anagrams.join(', ')}"
            else
              puts "No anagrams of #{word} in #{@options.dictionary}"
            end
          end
        end
      end
    end

In this case, the two libraries finder and options are in the same directory as the runner, so `require_relative` finds them perfectly.
在这种情况下，finder和options两类和runner类在同一个目录，所以`require_relative`可以轻易找到它们。
Now that all our files are in place, we can run our program from the command line:
现在我们的所有文件已经就位，我们可以从命令行启动我们的程序了。

    $ ruby -I lib bin/anagram teaching code
    Anagrams of teaching: cheating, teaching
    Anagrams of code: code, coed

There’s nothing like a cheating coed teaching code.
这真是一个绝妙的例子！

## 16.3 Distributing an Installing Your Code 分发代码
**分发标准架构**
Now that we have our code a little tidier, it would be nice to be able to distribute it to others. 
为了让代码更整洁些，更好的做法是将它分发给其他人。
 We could just zip or tar it up and send them our files, but then they’d have to run the code the way we do, remembering to add the correct -I lib options and so on. 
我们可以只是用zip或者tar压缩了再发给其他人，但他们只能按照我们的方法运行代码，要记得增加-I lib选项等等。
They’d also have some problems if they wanted to reuse one of our library files—it would be sitting in some random directory on their hard drive, not in a standard location used by Ruby. 
如果他们想重用我们的库文件，也会有很多麻烦 -- 代码放在他们硬盘上一些无序的目录中，而不是使用ruby的标准地方。
Instead, we’re looking for a way to take our little application and install it in a standard way.
所以，我们寻找一种方法来处理我们的小应用，并用标准的方式安装它。

Now, Ruby already has a standard installation structure on your computer. 
现在你的电脑上，ruby已经有了一个标准的安装架构
When Ruby is installed, it puts its commands (ruby, ri, irb, and so on) into a directory of binary files. 
ruby安装时，它将命令（ruby ri irb等等）放在一个二进制文件目录中。
It puts its libraries into another directory tree and documentation somewhere else. 
将库放进另一个目录树，文档也放在一些地方。
So, one option would be to write an installation script that you distribute with your code that copies components of your application to the appropriate directories on the system that’s installing it.
所以，一个选项是，写一个安装脚本，和你的代码一起发布，将应用程序复制到系统上适当的安装目录上。
### 16.3.1 Being a Good Packaging Citizen  成为一个好打包手
So, I’ve ignored some stuff that you’d want to do before distributing your code to the world.  
所以，我们已经忽略了一些要做的事情，以便将代码分享给世界。
Your distributed directory tree really should have a README file, outlining what it does and probably containing a copyright statement; an INSTALL file, giving installation instructions; and a LICENSE file, giving the license it is distributed under.
你的分发目录树应该有个README文件，简述它的功能，还可能包含一个版权文件；INSTALL文件，给出安装说明；LICENSE文件，指出这些代码在什么许可证下分发。

You’ll probably want to distribute some documentation, too. 
你可能也想分发一些文档。
This would go in a directory called doc/, parallel with the bin and lib directories.
这就应该创建一个doc目录，和bin、lib目录在同一层次。

You might also want to distribute native C-language extensions with your library. 
也可能想和你的库一起分发原生的C语言扩展。
These extensions would go into your project’s ext/ directory.
这些扩展应该放在项目的ext目录。

### 16.3.2 Using RubyGems 使用RubyGems
The RubyGems package management system (which is also just called Gems) has become the standard for distributing and managing Ruby code packages. 
RubyGems包管理系统（也只将Gems），已经变成一个标准来分发和管理Ruby代码包。
As of Ruby 1.9, it comes bundled with Ruby itself.[6]
到了Ruby1.9, 它被绑定在Ruby里面。
6.
Prior to RubyGems, folks often distibuted a tool called setup.rb with their libraries. 
在RubyGems之前，人们通常分发库里一个叫setup.rb的工具
This would install the library into the standard Ruby directory structure on a user’s machine.
这将安装库到用户机器的标准ruby目录构造中。

RubyGems is also a great way to package your own code. 
RubyGems也是一个很好的方式来打包自己的代码。
If you want to make your code available to the world, RubyGems is the way to go. 
如果你想向世界分享你的代码，RubyGems是一个方法。
Even if you’re just sending code to a few friends or within your company, RubyGems gives you dependency and installation management—one day you’ll be grateful for that. 
即使你只是想将代码发送给你公司内的几个好友，RubyGems帮你进行依赖性和安装的管理 -- 总有一天你将感到很感激。

 RubyGems needs to know information about your project that isn’t contained in the directory structure. 
 RubyGems需要知道关于你项目的信息，没有包括在目录结构里面。
Instead, you have to write a short RubyGems specification: a GemSpec. 
相反，你只能写一个简单的RubyGems说明书：一个GemSpec。
Create this in a separate file named project-name.gemspec in the top-level directory of your application (in our case, the file is anagram.gemspec):
创建一个独立的叫做"程序名.gemspec"文件，放在程序的顶级目录下（在我的例子中是anagram.gemspec）:

packaging/anagram/anagram.gemspec

    Gem::Specification.new do |s|
      s.name = "anagram"
      s.summary = "Find anagrams of words supplied on the command line"
      s.description = File.read(File.join(File.dirname(__FILE__), 'README'))
      s.requirements = [ 'An installed dictionary (most Unix systems have one)' ]
      s.version = "0.0.1"
      s.author = "Dave Thomas"
      s.email = "dave@pragprog.com"
      s.homepage = "http://pragdave.pragprog.com"
      s.platform = Gem::Platform::RUBY
      s.required_ruby_version = '>=1.9'
      s.files = Dir['**/**']
      s.executables = [ 'anagram' ]
      s.test_files = Dir["test/test*.rb"]
      s.has_rdoc = false
    end

The first line of the spec gives our gem a name. 
说明书第一行是gem的名字。
This is important—it will be used as part of the package name, and it will appear as the name of the gem when installed. 
这是很重要的 -- 它将会用作包名的一部分，而且它将在安装时作为gem名字出现。
Although it can be mixed case, we find that confusing, so do our poor brains a favor and use lowercase for gem names.
虽然它可被修改，但如果发现混淆，我们可以使用小写命名。

The version string is significant, because RubyGems will use it both for package naming and for dependency management. 
版本号是重要的，因为RubyGems将使用它用于包的命名和依赖性管理。
Stick to the x.y.z format.  [7]
格式是x.y.z。
[7].  And read http://www.rubygems.org/read/chapter/7 for information on what the numbers mean.
关于数字的含义信息参见http://www.rubygems.org/read/chapter/7。

The platform field tells RubyGems that (in this case) our gem is pure Ruby code. 
平台字段告诉RubyGems这个例子的gem是纯ruby代码。
It’s also possible to package (for example) Windows .exe files inside a gem, in which case you’d use Gem::Platform::Win32.
也可能将Windows的exe文件打包在gem里面，那就该写成Gem::Platform::Win32。


The next line is also important (and oft-forgotten by package developers). 
下一行也是重要的（可经常被开发者所忽略）。
Because we use `require_relative`, our gem will run only with Ruby 1.9 and newer.
因为我们使用`require_relative`，我们的gem将只能运行在ruby1.9以上的版本上。

We then tell RubyGems which files to include when creating the gem package. 
然后我们告诉RubyGems创建gem包时应该包含哪些文件。
Here we’ve been lazy and included everything. 
这里我们懒懒地包含所有文件。
You can be more specific.
你可以更详细些的。

The s.executables line tells RubyGems to install the anagram command-line script when the gem gets installed on a user’s machine.
s.executables行告诉RubyGems安装anagram命令行脚本，当gem在用户的机器安装时。

To save space, we haven’t added RDoc documentation comments to our source files (RDoc is described in Chapter 19, Documenting Ruby, on page 263). 
为了保存空间，我们不添加RDoc文档来注释我们的源代码（RDoc在后面263页的十九章ruby文档中）
The last line of the spec tells RubyGems not to try to extract documentation when the gem is installed.
最后一行告诉RubyGems，gem安装后不要解压文档。

Obviously I’ve skipped a lot of details here. 
明显的，我们这里跳过很多细节。
A full description of GemSpecs is available online [8], along with other documents on RubyGems.[9]
说明书的完整描述可在线获得，和RubyGems其他文档在一起。

[8].  http://www.rubygems.org/read/book/4
[9].  http://www.rubygems.org/

### 16.3.3 Packaging Your RubyGem 打包你的RubyGems
Once the gem specification is complete, you’ll want to create the packaged .gem file for dis- tribution. 
一旦完成gem说明书，你将要创建一个打包的.gem文件来分发。
This is as easy as navigating to the top level of your project and typing this:
这太容易了，打开你项目的顶级目录，然后键入：

    $ gem build anagram.gemspec
    WARNING: no rubyforge_project specified
      Successfully built RubyGem
      Name: anagram
      Version: 0.0.1
      File: anagram-0.0.1.gem

You’ll find you now have a file called anagram-0.0.1.gem.
你将发现你有了一个叫anagram-0.0.1.gem的文件。

    $ ls *gem
    anagram-0.0.1.gem

You can install it:
你就可以安装它了：

    $ sudo gem install pkg/anagram-0.0.1.gem
    Successfully installed anagram-0.0.1
    1 gem installed

And check to see that it is there:
检查一下它是否安装：

    $ gem list anagram -d
    *** LOCAL GEMS ***
    anagram (0.0.1)
      Author: Dave Thomas
      Homepage: http://pragdave.pragprog.com
      Installed at: /usr/local/lib/ruby/gems/1.9.0
      Find anagrams of words supplied on the command line

Now you can send your .gem file to friends and colleagues or share it from a server. 
现在你可以从一个服务器中发送你的gem文件给你的朋友和同事了。
Or, you could go one better and share it from a RubyGems server.
或者，你可以从一个RubyGems服务器中分享它，那就更好了。

If you have RubyGems installed on your local box, you can share them over the network to others. 
如果你本地安装了RubyGems，你可以通过网络来分享。
Simply run this:
只需要运行：

    $ gem server
    Server started at http://[::ffff:0.0.0.0]:8808
    Server started at http://0.0.0.0:8808

This starts a server (by default on port 8808, but the --port option overrides that). 
这开启了一个服务器（默认端口8808,但--port选项可以改写）
Other people can connect to your server to list and retrieve RubyGems:
其他人可以连接到你的服务器,可显示和得到RubyGems：

    $ gem list --remote --source http://dave.local:8808
    *** REMOTE GEMS ***
    anagram (0.0.1)
    builder (2.1.2, 0.1.1)
    ..

This is particularly useful in a corporate environment.
在合作环境下这是特别有用的。
You can speed up the serving of gems by creating a static index—see the help for gem `generate_index` for details.
通过创建一个静态索引，你可以加速gems的服务速度 -- 详见gem `generate_index`的帮助信息

### Serving Public RubyGems  公共RubyGems服务
RubyGems.org (http://rubygems.org) has become the main repository for public Ruby libraries and projects. 
RubyGems.org (http://rubygems.org)已经变成一个公开Ruby库和程序的主仓库。
And, if you create a RubyGems.org account, you can push your .gem file to their public servers.
如果你创建了一个RubyGems.org帐户，你可以到他们的服务器上公开gem文件。

    $ gem push anagram-0.0.1.gem
    Enter your RubyGems.org credentials.
    Email: dave@pragprog.com
    Password: Pushing gem to RubyGems.org...
    Successfully registered gem: anagram (0.0.1)

And, at that point, any Ruby user in the world can do this:
这时世界上的任何ruby用户都可以这样：

    $ gem search -r anagram
    *** REMOTE GEMS ***
    anagram (0.0.1)

and, even better, can do this:
这样就更好了：

    $ gem install anagram

### Adding Even More Automation 增加更多的自动化

The Jeweler library [10] can create a new project skeleton that follows the layout guidelines in this chapter. 
**Jeweler库**能够像本章描述的布局指导那样创建一个新项目框架。
It also provides a set of Rake tasks that will help create and manage your project as a gem.
它也提供了一组Rake任务，帮助创建和管理你的项目作为gem。
[10].  http://github.com/technicalpickles/jeweler

If you’re a Rails user, you’ll have come across bundler, a utility that manages the gems used by your application. 
如果你是一个Rails用户，你应该知道**bundler**，应用程序用来管理gems一个工具。
Bundler is more general than this: it can be used to manage the gems used by any piece of Ruby code.
Bundler更普遍：它能用一个ruby代码片段管理所用的gems。

Some folks like the extra features of these utilities, while others prefer the leaner “roll-your- own” approach. 
一些人喜欢这些工具的额外特征，而另一些更喜欢自己动手。
Whatever route you take, taking the time to package your applications and libraries will pay you back many times over.
不管你采用什么方法，花点时间打包你的应用和包将回馈更多时间给你。

### See You on GitHub 到GitHub再见
Finally, if you’re developing a Ruby application or library that you’ll be sharing, you’ll 11 probably want to store it on GitHub. 
最后，如果你在开发一个希望和人共享的ruby应用或者库，你可能想将它存放在Github上面。
Although it started as a public Git repository, GitHub is now a community in its own right. 
虽然它开始作为一个公共的Git仓库，GitHub现在是一个社区，拥有自己的权利。
It’s a home away from home for many in the Ruby community.
这个地方远离了ruby社区的许多地方。
[11].  http://github.com

#   17 Character Encoding 字符编码
**必要性情景**
Prior to Ruby 1.9, Ruby programs were basically written using the ASCII character encoding.
ruby1.9之前，ruby程序一般基于ASCII字符编码来来写。
You could always override this with the -K command-line option, but this led to inconsistencies when manipulating strings and doing file I/O.
你可以用-K命令行选项来重写这个，但这在处理字符串和文件I/O时将带来矛盾。

Ruby 1.9 changed all this. 
ruby 1.9 改变了这一切。
Ruby now supports the idea of character encodings. 
Ruby现在支持字符编码的理念。
And, what’s more, these encodings can be applied relatively independently to your program source files, to objects in your running programs, and to the interpretation of I/O streams.
而且，这些编码能对你的程序源代码、在你程序运行中的对象、I/O流的解释，保持相对独立性。

Before delving into the details, let’s spend a few minutes thinking about why we need to separate the encodings of source files, variables, and I/O streams. 
钻研细节之前，让我们花几分钟想想为什么我们要把源文件、变量和I/O流的编码独立出来
Let’s imagine Yui is a developer in Japan who wants to code in her native language. 
试着想像Yui是一个日本开发者，她想用本国语言编码。
Her editor lets her write code using Shift JIS (SJIS), a Japanese character encoding, so she writes her variable names using katakana and kanji characters. 
她的编辑器让她使用Shift JIS -- 一种日本字符写代码，所以她使用katakana和kanji字符写变量名。
But, by default, Ruby assumes that source files are written in ASCII, and the SJIS characters would not be recognized as such. 
但默认的是，ruby假设源文件用ASCII写成，SJIS字符不能被这样识别。
However, by setting the encoding to be used when compiling the source file, Ruby can now parse her program.
不过，通过在编译源文件时设置使用编码，Ruby可以解析她的程序了。

She converts her program into a gem, and users around the world try it. 
她把程序转换成一个gem，全世界的用户都想试一试。
Dan, in the United States, doesn’t read Japanese, so the content of her source files makes no sense to him. 
Dan，住在美国，不能读日文，所以她的源文件的内容对他没有意义。
 However, because the source files carry their encoding around with them, there’s no problem; his Ruby happily compiles her code. 
不过，因为源文件带着它们的编码，这没有问题，他的ruby轻松编译出她的代码。
But Dan wants to test her code against a file that contains regular old ASCII characters. 
但Dan想用她的代码测试一个文件，文件里包含正常的老ASCII字符。
That’s no problem, because the file encoding is determined by Dan’s locale, not by the encoding of the Ruby source. 
也没问题，因为文件编码是Dan的locale决定的，而不是ruby源的编码决定的。
Similarly, Sophie in Paris uses the same gem, but her data is encoded in ISO-8859-1 (which is basically ASCII plus a useful subset of accented European characters in character positions above 127). 
相似的，巴黎的Sophie使用相同的gem，但她的数据用ISO-8859-1编码（这个编码基于ASII，在127字符位之上增加了一些有用的欧洲重音字符子集）。
Again, no problem.
这也没有问题。

Back in Japan, Yui has a new feature to add to her library. 
回到日本，Yui在她的库里增加了一个新特性。
Users want to create short PDF summaries of the data she reads, but the PDF-writing library she’s using supports only ISO- 8859-1 characters. 
用户想创建所读入数据的简短PDF摘要，但她所使用的PDF-writing库只支持ISO-8859-1字符。
So, regardless of the encoding of the source code of her program and the files she reads, she needs to be able to create 8859-1 strings at runtime. 
所以，不管她的程序源文件和读入文件的编码是什么，她需要在运行时创建8859-1字符串。
Again, we need to be able to decouple the encoding of individual objects from the encoding of everything else.
再次，我们需要能力，去从任何其他编码解藕个别对象的编码。

If this sounds complex, well...it is. 
如果这听起来复杂了些，对，就是。
But the good news is that the Ruby team spent a long time thinking up ways to make it all relatively easy to use when you’re writing code. 
但好消息是ruby足花了长时间想到办法，让这在你写下代码时变得比较简单易用，
In this section, we’ll look at how to work with the various encodings, and I’ll try to list some conventions that will make your code work in the brave new multinational world.
在这一章，我们将看看怎么和各种编码一起工作，我将尝试列出一些惯例，让你的代码在勇敢的新的跨国世界里工作良好。

## 17.1 Encoding 编码
At the heart of the Ruby encoding system is the new Encoding class. [1]
在ruby编码系统的中心是新的Encoding类。
[1].
For a nice, easy read on encodings, charcter sets, and Unicode, you could take a look at Joel Spolsky’s 2003 article on the Web at http://www.joelonsoftware.com/articles/Unicode.html.
为了编码、字符设置和Unicode的好看易读，你可以看看Joel Spolsky的2003作品，在http://www.joelonsoftware.com/articles/Unicode.html
 --------------------------------------------------- 
http://www.joelonsoftware.com/articles/Unicode.html

Joel on Software
乔尔在软件
The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)
绝对绝对最低 每一个软件开发人员,积极必须知道关于Unicode和字符集(没有借口!)
by Joel Spolsky
由Joel Spolsky
Wednesday, October 08, 2003
周三,08年10月,2003年

Ever wonder about that mysterious Content-Type tag? You know, the one you're supposed to put in HTML and you never quite know what it should be?
有没有想过那个神秘的**内容类型**标签呢? 你知道,应该在HTML中,你却不知道应该是什么?

Did you ever get an email from your friends in Bulgaria with the subject line "???? ?????? ??? ????"?
你有没有得到一个电子邮件从你的朋友在保加利亚,标题栏”? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?


I've been dismayed to discover just how many software developers aren't really completely up to speed on the mysterious world of character sets, encodings, Unicode, all that stuff. 
我惊愕地发现许多软件开发人员如何并不完全取决于速度字符集的神秘世界,编码,Unicode,所有的东西。
A couple of years ago, a beta tester for FogBUGZ was wondering whether it could handle incoming email in Japanese. 
几年前,一个beta测试人员 FogBugz 不知道它是否可以处理从日本传入的电子邮件。
Japanese? They have email in Japanese? I had no idea. 
日语吗? 他们有电子邮件在日本吗? 我不知道。
When I looked closely at the commercial ActiveX control we were using to parse MIME email messages, we discovered it was doing exactly the wrong thing with character sets, so we actually had to write heroic code to undo the wrong conversion it had done and redo it correctly. 
当我仔细观察商业ActiveX控件使用MIME解析电子邮件消息,我们发现它用字符集做错的事情,所以我们不得不写英雄代码撤销错误的转换做了和重做它正确。
When I looked into another commercial library, it, too, had a completely broken character code implementation. 
当我看着另一个商业库,也完全破碎的字符代码实现。
I corresponded with the developer of that package and he sort of thought they "couldn't do anything about it." 
我和包的开发人员沟通,他认为他们”不能做这件事。 “
Like many programmers, he just wished it would all blow over somehow.
就像许多程序员,他只是希望它都会烟消云散。


But it won't. 
但它不会。 
When I discovered that the popular web development tool PHP has almost complete ignorance of character encoding issues, blithely using 8 bits for characters, making it darn near impossible to develop good international web applications, I thought, enough is enough.
当我发现PHP几乎已经流行的web开发工具 字符编码问题一无所知 ,轻率地使用8位字符,这该死的几乎不可能培养良好的国际web应用程序,我想, 够了够了 。


So I have an announcement to make: if you are a programmer working in 2003 and you don't know the basics of characters, character sets, encodings, and Unicode, and I catch you, I'm going to punish you by making you peel onions for 6 months in a submarine. 
所以我要宣布一件事:如果你是一个程序员的工作在2003年和你不知道基本的字符,字符,编码,和Unicode,我 抓 你,我要惩罚你,让你剥洋葱在潜艇6个月。 
I swear I will.
我发誓我会的。


And one more thing:
还有一件事:


IT'S NOT THAT HARD.
这不是那么难。


In this article I'll fill you in on exactly what every working programmer should know. 
在本文中,我将详细告诉你什么 每一个程序员的工作 应该知道。 
All that stuff about "plain text = ascii = characters are 8 bits" is not only wrong, it's hopelessly wrong, and if you're still programming that way, you're not much better than a medical doctor who doesn't believe in germs. 
所有素材”纯文本= 8位ascii =字符”不仅是错了,错得一塌糊涂,如果你还是编程,你和不相信细菌医生差不多。
Please do not write another line of code until you finish reading this article.
请不要写一行代码,直到你读完这篇文章。


Before I get started, I should warn you that if you are one of those rare people who knows about internationalization, you are going to find my entire discussion a little bit oversimplified. 
在我开始之前,我应该提醒你,如果你是一个少有的人知道国际化,你将会发现我的整个讨论有点过于简单化。
I'm really just trying to set a minimum bar here so that everyone can understand what's going on and can write code that has a hope of working with text in any language other than the subset of English that doesn't include words with accents. 
我真的只是想设定一个最低酒吧在这里,这样每个人都可以了解到发生了什么,可以写代码,有一个 希望 与其他任何一种语言的文本比子集不包括单词的英语口音。 
And I should warn you that character handling is only a tiny portion of what it takes to create software that works internationally, but I can only write about one thing at a time so today it's character sets.
和我应该提醒你,字符处理中只有一小部分是需要创建国际软件工程,但我一次只能写一件事所以今天字符集。


#### A Historical Perspective 历史的角度来看

The easiest way to understand this stuff is to go chronologically.
最简单的方式了解这个东西是时间顺序。

You probably think I'm going to talk about very old character sets like EBCDIC here. Well, I won't. EBCDIC is not relevant to your life. We don't have to go that far back in time.
你可能认为我要谈论这里的很老的字符集喜欢EBCDIC。 好吧,我不会的。 EBCDIC不是与你的生活有关。 我们没有去,久远的时间。


Back in the semi-olden days, when Unix was being invented and K&R were writing The C Programming Language, everything was very simple. 
回到semi-olden时代,当Unix被发明和K&R写作 C编程语言 ,一切都很简单. 
EBCDIC was on its way out. 
EBCDIC摆脱. 
The only characters that mattered were good old unaccented English letters, and we had a code for them called ASCII which was able to represent every character using a number between 32 and 127. 
唯一重要的人物是好老无重音的英文字母,为他们和我们有一个代码 美国信息交换标准代码 这是能够代表每一个字符都使用32和127之间的数字. 
Space was 32, the letter "A" was 65, etc. 
空间是32,字母“A”是65年,等。 
This could conveniently be stored in 7 bits. 
这可以方便地存储在7位.
Most computers in those days were using 8-bit bytes, so not only could you store every possible ASCII character, but you had a whole bit to spare, which, if you were wicked, you could use for your own devious purposes: the dim bulbs at WordStar actually turned on the high bit to indicate the last letter in a word, condemning WordStar to English text only. 
大多数计算机在那些日子里使用8位字节,所以不仅可以存储每一个可能的ASCII字符,但你有一个整体有些多余,,如果你是邪恶的,你可以使用自己的狡猾的用途:昏暗的灯泡在WordStar实际上打开了高比特来表示一个单词的最后一个字母,谴责WordStar英语文本. 
Codes below 32 were called unprintable and were used for cussing. 
代码下面32被称为 猥亵的 用于谩骂. 
Just kidding. 
只是在开玩笑. 
They were used for control characters, like 7 which made your computer beep and 12 which caused the current page of paper to go flying out of the printer and a new one to be fed in.
他们被用于控制字符,比如7使你的电脑beep和12导致当前页纸去飞出的打印机和一个新的美联储。


And all was good, assuming you were an English speaker.
都很好,假设你是一个会说英语的人来。


Because bytes have room for up to eight bits, lots of people got to thinking, "gosh, we can use the codes 128-255 for our own purposes." 
八个比特因为字节的空间,许多人开始想,“天哪,我们可以使用代码128 - 255用于自己的目的. 
The trouble was, lots of people had this idea at the same time, and they had their own ideas of what should go where in the space from 128 to 255. 
问题是, 很多 人这种想法的同时,他们有自己的想法的应该在从128年到255年的空间. 
The IBM-PC had something that came to be known as the OEM character set which provided some accented characters for European languages and a bunch of line drawing characters...horizontal bars, vertical bars, horizontal bars with little dingle-dangles dangling off the right side, etc., and you could use these line drawing characters to make spiffy boxes and lines on the screen, which you can still see running on the 8088 computer at your dry cleaners'.  
IBM-PC有东西被称为OEM字符集提供一些欧洲语言和重音字符 一群素描人物 … 单杠、垂直酒吧、单杠下悬挂着一些小小的dingle-dangles右边,等,,您可以使用这些素描人物的框线在屏幕上,你仍能看到8088计算机上运行你的干洗店. 
In fact  as soon as people started buying PCs outside of America all kinds of different OEM character sets were dreamed up, which all used the top 128 characters for their own purposes. 
事实上 当人们开始购买个人电脑以外的美国各种OEM字符集是梦想,所有前128个字符用于自己的目的. 
For example on some PCs the character code 130 would display as é, but on computers sold in Israel it was the Hebrew letter Gimel (ג), so when Americans would send their résumés to Israel they would arrive as rגsumגs. 
例如在一些电脑上130字符代码将显示e,但电脑在以色列的希伯来字母Gimel(ג),所以当美国人将résumés简历发送到以色列,他们将到达 rגsumגs. 
In many cases, such as Russian, there were lots of different ideas of what to do with the upper-128 characters, so you couldn't even reliably interchange Russian documents.
在许多情况下,如俄罗斯,有很多不同的想法如何处理上- 128字符,所以你甚至不能可靠地交换俄罗斯文档。


Eventually this OEM free-for-all got codified in the ANSI standard. 
最终这OEM混战编纂的ANSI标准. 
In the ANSI standard, everybody agreed on what to do below 128, which was pretty much the same as ASCII, but there were lots of different ways to handle the characters from 128 and on up, depending on where you lived. 
ANSI标准,每个人都同意做什么低于128,差不多是ASCII,但有很多不同的方式来处理字符从128年起,这取决于你住在哪里. 
These different systems were called code pages. 
这些不同的系统被称为 代码页 . 
So for example in Israel DOS used a code page called 862, while Greek users used 737. 
比如在以色列DOS使用代码页叫862,而希腊的用户使用737. 
They were the same below 128 but different from 128 up, where all the funny letters resided. 
他们低于128的相同,但是不同于128以上,那是所有有趣的字母居住. 
The national versions of MS-DOS had dozens of these code pages, handling everything from English to Icelandic and they even had a few "multilingual" code pages that could do Esperanto and Galician on the same computer! Wow! But getting, say, Hebrew and Greek on the same computer was a complete impossibility unless you wrote your own custom program that displayed everything using bitmapped graphics, because Hebrew and Greek required different code pages with different interpretations of the high numbers.
全国的ms-dos版本有几十个这些代码页,处理从英语到冰岛,他们甚至有一些“语言”世界语和加利西亚语的代码页 在同一台计算机上! 哇! 但,希伯来和希腊在同一台计算机上完全是不可能的,除非你写自己的自定义程序,使用位图图形的显示一切,因为希伯来和希腊需要大量的不同代码页有不同的解释。


Meanwhile, in Asia, even more crazy things were going on to take into account the fact that Asian alphabets have thousands of letters, which were never going to fit into 8 bits. 
与此同时,在亚洲,更疯狂的事情要考虑到这样一个事实:亚洲字母成千上万的字母,这是永远不会适合8位. 
This was usually solved by the messy system called DBCS, the "double byte character set" in which some letters were stored in one byte and others took two. 
这是通常由混乱的系统称为DBCS,解决“双字节字符集” 一些字母被存储在一个字节和其他两个. 
It was easy to move forward in a string, but dang near impossible to move backwards. 
很容易前进的一个字符串,但是dang near几乎不可能后退. 
Programmers were encouraged not to use s++ and s-- to move backwards and forwards, but instead to call functions such as Windows' AnsiNext and AnsiPrev which knew how to deal with the whole mess.
鼓励程序员不使用s++和s--,向前和向后移动,而是调用功能,如Windows的AnsiNext和AnsiPrev知道如何处理整个混乱。


But still, most people just pretended that a byte was a character and a character was 8 bits and as long as you never moved a string from one computer to another, or spoke more than one language, it would sort of always work. 
但是,大多数人只是假装一个字节是一个字符,字符是8位,只要你从来没有一个字符串从一台计算机转移到另一个,或说不止一种语言,它将总是奏效. 
But of course, as soon as the Internet happened, it became quite commonplace to move strings from one computer to another, and the whole mess came tumbling down. 
当然,一旦网络发生了,它变得相当普遍将字符串从一台计算机移动到另一个,和整个混乱轰然倒塌. 
Luckily, Unicode had been invented.
幸运的是,Unicode被发明了。


#### Unicode 统一字符


Unicode was a brave effort to create a single character set that included every reasonable writing system on the planet and some make-believe ones like Klingon, too. 
Unicode是一个勇敢的努力创建一个字符集,包括地球上每一个合理的书写系统和一些虚伪的克林贡语,. 
Some people are under the misconception that Unicode is simply a 16-bit code where each character takes 16 bits and therefore there are 65,536 possible characters. 
有些人误解,Unicode只是下一个16位代码,其中每个字符占用16位,因此可能有65536字符. 
This is not, actually, correct. 
实际上,这不是正确的. 
It is the single most common myth about Unicode, so if you thought that, don't feel bad.
这是最常见的误区Unicode,所以如果你认为,不要难过。


In fact, Unicode has a different way of thinking about characters, and you have to understand the Unicode way of thinking of things or nothing will make sense.
事实上,Unicode的思考字符的方式不同,你必须理解Unicode的思维方式或任何有意义的东西。


Until now, we've assumed that a letter maps to some bits which you can store on disk or in memory:
直到现在,我们假定一个字母映射到一些可以存储在磁盘或内存:


A -> 0100 0001


In Unicode, a letter maps to something called a code point which is still just a theoretical concept. How that code point is represented in memory or on disk is a whole nuther story.
在Unicode,字母映射到一个 代码点 这还只是一个理论概念。 代码点的表示方式在内存或磁盘上是一个整体nuther的故事。


In Unicode, the letter A is a platonic ideal. It's just floating in heaven:
在Unicode,字母A是一个柏拉图式的理想。 这只是漂浮在天堂:


A
一个


This platonic A is different than B, and different from a, but the same as A and A and A. 
这种柏拉图式的 一个 是不同于 B ,不同于a,但一样 A（<kinder:note> 粗体）和 A（<kinder:note> 斜体） 和A（正体）。
The idea that A in a Times New Roman font is the same character as the A in a Helvetica font, but different from "a" in lower case, does not seem very controversial, but in some languages just figuring out what a letter is can cause controversy. 
A在Times New Roman字体等同于Helvetica字体的A,但是 不同于小写的“a”,似乎不非常有争议,但在一些语言搞明白一个字母 是 会引起争议. 
Is the German letter ß a real letter or just a fancy way of writing ss?
德国字母ß是真正的字母或只是ss一个漂亮的写作方式吗? 
 If a letter's shape changes at the end of the word, is that a different letter? Hebrew says yes, Arabic says no. 
如果一个字母的形状变化的词,这是一个不同的字母吗? 希伯来语说,是的,阿拉伯语说不. 
Anyway, the smart people at the Unicode consortium have been figuring this out for the last decade or so, accompanied by a great deal of highly political debate, and you don't have to worry about it. 
无论如何,在过去的十年左右的时间，在Unicode协会的聪明人已经解决问题了,伴随着大量的高度政治辩论,你不必担心. 
They've figured it all out already.
他们已经想出来了。


Every platonic letter in every alphabet is assigned a magic number by the Unicode consortium which is written like this: U+0639. 
每一个柏拉图式的字母在字母表由Unicode协会分配一个神奇的数字，写成: U+0639。 
 This magic number is called a code point. 
这个神奇的数字被称为 代码点 . 
The U+ means "Unicode" and the numbers are hexadecimal. 
U+意味着“Unicode”和十六进制数字. 
U+0639 is the Arabic letter Ain. 
U+0639 是阿拉伯语字母Ain. 
The English letter A would be U+0041. 
英语字母A是 U+0041 . 
You can find them all using the charmap utility on Windows 2000/XP or visiting the Unicode web site.
你可以在Windows 2000 / XP或访问 Unicode的网站找到他们所有，使用 charmap 实用程序 。


There is no real limit on the number of letters that Unicode can define and in fact they have gone beyond 65,536 so not every unicode letter can really be squeezed into two bytes, but that was a myth anyway.
没有真正的字母数量限制，Unicode可以定义,事实上他们已经超越65536，不是每个Unicode字母真的可以挤进两个字节,但无论如何,这是一个神话。


OK, so say we have a string:
好吧,说我们有一个字符串:


Hello
你好


which, in Unicode, corresponds to these five code points:
Unicode代码点对应于这五个:


U+0048 U+0065 U+006C U+006C U+006F.


Just a bunch of code points. Numbers, really. We haven't yet said anything about how to store this in memory or represent it in an email message.
只是一群代码点。 数字,真的。 我们还没有说任何关于如何存储在内存或在电子邮件消息代表它。


#### Encodings 编码


That's where encodings come in.
这就是 编码 进来。


The earliest idea for Unicode encoding, which led to the myth about the two bytes, was, hey, let's just store those numbers in two bytes each. So Hello becomes
Unicode编码最早的想法,导致两个字节的神话,,嘿,我们就将这些数据存储在两个字节。 所以Hello就变成：


00 48 00 65 00 6C 00 6C 00 6F


Right? Not so fast! Couldn't it also be:
对吗? 不要这么快! 不也就是:


48 00 65 00 6C 00 6C 00 6F 00 ?


Well, technically, yes, I do believe it could, and, in fact, early implementors wanted to be able to store their Unicode code points in high-endian or low-endian mode, whichever their particular CPU was fastest at, and lo, it was evening and it was morning and there were already two ways to store Unicode. 
好,从技术上说,是的,我相信它可以,事实上,早期的实现者希望能够存储Unicode代码点在high-endian或low-endian模式,无论他们的特定的CPU是最快的,瞧,这是晚上,这是早晨,已经有 两个 的方式来存储Unicode. 
So the people were forced to come up with the bizarre convention of storing a FE FF at the beginning of every Unicode string; this is called a Unicode Byte Order Mark and if you are swapping your high and low bytes it will look like a FF FE and the person reading your string will know that they have to swap every other byte. 
所以人们不得不拿出奇怪的约定储存FE FF在每个Unicode字符串的开始;这就是所谓的一个 Unicode字节顺序标记 如果你交换你的高和低字节,它将看起来像个FF FE和阅读你的字符串将会知道他们必须交换其他字节. 
Phew. 
唷. 
Not every Unicode string in the wild has a byte order mark at the beginning.
不是每个Unicode字符串在野外有一个字节顺序标记开始。


For a while it seemed like that might be good enough, but programmers were complaining. 
一段时间似乎会是个不错的选择,但程序员抱怨. 
"Look at all those zeros!" they said, since they were Americans and they were looking at English text which rarely used code points above U+00FF. 
“看看所有这些零! “他们说,因为他们是美国人,他们在看英语文本,很少使用U+00FF以上面的代码点. 
Also they were liberal hippies in California who wanted to conserve (sneer). 
他们也想自由嬉皮士在加州 保存(冷笑) . 
If they were Texans they wouldn't have minded guzzling twice the number of bytes. 
如果德克萨斯人他们也不会在乎狂饮的字节数的两倍. 
But those Californian wimps couldn't bear the idea of doubling the amount of storage it took for strings, and anyway, there were already all these doggone documents out there using various ANSI and DBCS character sets and who's going to convert them all? Moi? 
但这些加州wimps受不了为字符串存储的数量翻倍的想法了,不管怎样,已经有所有这些该死的文档使用各种ANSI和DBCS字符集和谁来转换? 莫伊吗?
For this reason alone most people decided to ignore Unicode for several years and in the meantime things got worse.
因为这个原因就大多数人决定忽略Unicode好几年,在此期间事情变得更糟。


Thus was invented the brilliant concept of UTF-8. UTF-8 was another system for storing your string of Unicode code points, those magic U+ numbers, in memory using 8 bit bytes. In UTF-8, every code point from 0-127 is stored in a single byte. Only code points 128 and above are stored using 2, 3, in fact, up to 6 bytes.
因此是 发明了 utf-8的概念。 utf-8是另一个系统来存储你的字符串的Unicode代码点,这些魔法U+数字,在内存中使用8位字节。 在utf-8中,每一个代码点从0-127存储 在一个字节 。 只有代码点128及以上存储使用2、3中,事实上,6字节。


#### How UTF-8 works   UTF-8怎么工作？


This has the neat side effect that English text looks exactly the same in UTF-8 as it did in ASCII, so Americans don't even notice anything wrong. 
这看起来整洁的副作用,英语文本 完全相同的在ASCII utf - 8一样, 所以美国人甚至不通知错了什么. 
Only the rest of the world has to jump through hoops. 
只有世界其他地区的百依百顺. 
Specifically, Hello, which was U+0048 U+0065 U+006C U+006C U+006F, will be stored as 48 65 6C 6C 6F, which, behold! is the same as it was stored in ASCII, and ANSI, and every OEM character set on the planet. 
具体地说, 你好 ,这是U+0048 U+0065 U+006C U+006C U+006F,将存储为48 65 6 c 6 c 6 f,,看哪! 就像是存储在ASCII,ANSI,地球上每一个OEM字符集. 
Now, if you are so bold as to use accented letters or Greek letters or Klingon letters, you'll have to use several bytes to store a single code point, but the Americans will never notice. 
现在,如果你是如此大胆,用重音字母或者克林贡人希腊字母或字母,你将不得不使用几个字节来存储一个代码点,但是美国人不会注意到. 
(UTF-8 also has the nice property that ignorant old string-processing code that wants to use a single 0 byte as the null-terminator will not truncate strings).
(utf-8的属性还不错,忽视旧字符串处理的代码,这些代码想要使用一个0字节作为null-terminator，不会截断字符串)。


So far I've told you three ways of encoding Unicode. 
到目前为止,我已经告诉过你 三个 Unicode编码的方法. 
The traditional store-it-in-two-byte methods are called UCS-2 (because it has two bytes) or UTF-16 (because it has 16 bits), and you still have to figure out if it's high-endian UCS-2 or low-endian UCS-2. 
传统两节储存方法被称为ucs-2(因为它有两个字节)或utf-16(因为它有16位),您仍然需要找出是high-endian ucs-2或low-endian ucs-2. 
And there's the popular new UTF-8 standard which has the nice property of also working respectably if you have the happy coincidence of English text and braindead programs that are completely unaware that there is anything other than ASCII.
还有流行的新utf-8 标准 也有很好的属性,工作体面地，如果你有快乐巧合的英语文本和死脑筋程序完全没有意识到有什么其他非ASCII。


There are actually a bunch of other ways of encoding Unicode. 
实际上有一些其他Unicode编码的方法. 
There's something called UTF-7, which is a lot like UTF-8 but guarantees that the high bit will always be zero, so that if you have to pass Unicode through some kind of draconian police-state email system that thinks 7 bits are quite enough, thank you it can still squeeze through unscathed. 
所谓utf-7,这是一个很多像utf-8,但保证高一些永远是零,因此,如果你必须通过Unicode通过某种严厉的警察国家的电子邮件系统,认为7位，足够了,谢谢你 它仍然可以挤过毫发无损. 
There's UCS-4, which stores each code point in 4 bytes, which has the nice property that every single code point can be stored in the same number of bytes, but, golly, even the Texans wouldn't be so bold as to waste that much memory.
ucs-4,4个字节存储每个代码点,不错的属性,每一个代码点可以存储在相同数量的字节,但是,吐痰,甚至是德克萨斯人不会这么大胆的浪费那多少内存。


And in fact now that you're thinking of things in terms of platonic ideal letters which are represented by Unicode code points, those unicode code points can be encoded in any old-school encoding scheme, too! 
事实上,既然你想事情按照柏拉图式的理想字母所代表通过Unicode代码点,那些Unicode代码点可以编码在任何传统的编码方案! 
For example, you could encode the Unicode string for Hello (U+0048 U+0065 U+006C U+006C U+006F) in ASCII, or the old OEM Greek Encoding, or the Hebrew ANSI Encoding, or any of several hundred encodings that have been invented so far, with one catch: some of the letters might not show up! 
例如,您可以将Unicode编码字符串你好(U+0048 U+0065 U+006c U+006c U+006f)在ASCII,或旧的OEM希腊编码,或希伯来ANSI编码,或任何的几百个到目前为止发明了编码, 有一个陷阱: 一些字母可能不会显示! 
If there's no equivalent for the Unicode code point you're trying to represent in the encoding you're trying to represent it in, you usually get a little question mark: ? or, if you're really good, a box. 
如果没有等价的Unicode代码点你想代表在编码你想代表,你通常得到一个小问号:? 或者,如果你真的好,一个箱子. 
Which did you get?
你是哪一个?
 -> �


There are hundreds of traditional encodings which can only store some code points correctly and change all the other code points into question marks. 
有成百上千的传统编码只能存储一些正确代码点,将所有其他代码点变成问号. 
Some popular encodings of English text are Windows-1252 (the Windows 9x standard for Western European languages) and ISO-8859-1, aka Latin-1 (also useful for any Western European language). 
一些流行的英语文本编码Windows-1252(Windows 9 x标准的西方欧洲语言) iso-8859-1 ,又名latin-1(也适用于任何西欧语言). 
But try to store Russian or Hebrew letters in these encodings and you get a bunch of question marks. 
但试图将俄罗斯或希伯来字母存储在这些编码,你会得到一堆问号. 
UTF 7, 8, 16, and 32 all have the nice property of being able to store any code point correctly.
UTF 7、8、16和32都有很好的属性,能够正确存储任何代码点。


#### The Single Most Important Fact About Encodings 关于编码的一个最重要的事实


If you completely forget everything I just explained, please remember one extremely important fact. 
如果你完全忘记一切我刚才的解释说,请记住一个极其重要的事实. 
It does not make sense to have a string without knowing what encoding it uses. 
是没有意义的,不知道它使用什么编码字符串 . 
You can no longer stick your head in the sand and pretend that "plain" text is ASCII.
你不能再把你的头埋在沙子里,假装“平原”ASCII文本。


There Ain't No Such Thing As Plain Text.
不是没有所谓的纯文本。


If you have a string, in memory, in a file, or in an email message, you have to know what encoding it is in or you cannot interpret it or display it to users correctly.
如果你有一个字符串,在内存中,在一个文件中,或在电子邮件消息,你必须知道什么是编码在或你不能解释它正确地显示给用户。


Almost every stupid "my website looks like gibberish" or "she can't read my emails when I use accents" problem comes down to one naive programmer who didn't understand the simple fact that if you don't tell me whether a particular string is encoded using UTF-8 or ASCII or ISO 8859-1 (Latin 1) or Windows 1252 (Western European), you simply cannot display it correctly or even figure out where it ends. 
几乎每一个愚蠢的“我的网站看起来像胡言乱语”或“她不能读我的邮件,当我用口音”问题归结为一个天真的程序员不明白一个简单的事实,如果你不告诉我是否一个特定的字符串是使用utf - 8编码或ASCII或ISO 8859 - 1(拉丁1)或Windows 1252(西欧),你不能正确显示它,甚至找出它结束. 
There are over a hundred encodings and above code point 127, all bets are off.
有超过一百个编码在代码点127以上,满盘皆输。


How do we preserve this information about what encoding a string uses? Well, there are standard ways to do this. 
我们如何保护这些信息字符串使用什么编码呢? 好,有标准的方法可以做到这一点. 
For an email message, you are expected to have a string in the header of the form
对于电子邮件,您预计将有一个字符串的头形式


    Content-Type: text/plain; charset="UTF-8"
    内容类型:文本/平原;charset =“utf - 8”


For a web page, the original idea was that the web server would return a similar Content-Type http header along with the web page itself -- not in the HTML itself, but as one of the response headers that are sent before the HTML page. 
为一个web页面,最初的想法是,web服务器将返回一个相似 内容类型 http报头用web页面本身 -- 不是在HTML本身,但作为一个响应头之前发送HTML页面。


This causes problems. 
这将导致问题. 
Suppose you have a big web server with lots of sites and hundreds of pages contributed by lots of people in lots of different languages and all using whatever encoding their copy of Microsoft FrontPage saw fit to generate. 
假设您有一个大的有很多网站和数百页的web服务器提供的很多人在很多不同的语言和他们使用什么编码复制生成的网页制作认为合适. 
The web server itself wouldn't really know what encoding each file was written in, so it couldn't send the Content-Type header.
web服务器本身不会真的 知道 每个文件的编码是什么写的,所以不能发送content - type报头。


It would be convenient if you could put the Content-Type of the HTML file right in the HTML file itself, using some kind of special tag. 
方便的如果你能把内容类型的HTML文件的HTML文件本身,使用某种特殊的标记. 
Of course this drove purists crazy...  how can you read the HTML file until you know what encoding it's in?! 
当然这开车纯粹主义者疯狂…… 你怎么能 读 HTML文件,直到你知道编码的吗? ! 
Luckily, almost every encoding in common use does the same thing with characters between 32 and 127, so you can always get this far on the HTML page without starting to use funny letters:
幸运的是,几乎所有常用的编码字符32至127是同样的事情,所以你可以在HTML页面总是这么远没有开始使用有趣的字母:


    <html>
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">


But that meta tag really has to be the very first thing in the `<head>` section because as soon as the web browser sees this tag it's going to stop parsing the page and start over after reinterpreting the whole page using the encoding you specified.
但meta标签真的必须在`<head>`部分的开头,因为一旦web浏览器看到这个标签就会停止解析后的页面并重新开始使用指定的编码方式呈现整个页面。


What do web browsers do if they don't find any Content-Type, either in the http headers or the meta tag? 
web浏览器会怎么做,如果他们没有找到任何内容类型,在http头或meta标签吗? 
Internet Explorer actually does something quite interesting: it tries to guess, based on the frequency in which various bytes appear in typical text in typical encodings of various languages, what language and encoding was used. 
Internet Explorer确实相当有趣的东西:它试图猜测,基于各种字节的频率出现在各种语言的典型文本在典型的编码,使用什么语言和编码. 
Because the various old 8 bit code pages tended to put their national letters in different ranges between 128 and 255, and because every human language has a different characteristic histogram of letter usage, this actually has a chance of working. 
因为各种旧8位代码页倾向于把国家字母在不同的范围在128年至255年之间,由于每个人类语言都有不同的特征直方图字母用法,这实际上有一个工作的机会. 
It's truly weird, but it does seem to work often enough that naïve web-page writers who never knew they needed a Content-Type header look at their page in a web browser and it looks ok, until one day, they write something that doesn't exactly conform to the letter-frequency-distribution of their native language, and Internet Explorer decides it's Korean and displays it thusly, proving, I think, the point that Postel's Law about being "conservative in what you emit and liberal in what you accept" is quite frankly not a good engineering principle. 
确实很奇怪,但它似乎经常工作,天真的网页作者从来不知道他们需要一个内容类型头看看他们的页面在一个web浏览器和它 看起来好 ,直到有一天,他们写点东西,并不完全符合letter-frequency-distribution他们的母语,和ie决定朝鲜并显示它因而,证明,我认为,这一点Postel法则对你发出“保守和自由在你接受“坦白说不是一个好的工程原则. 
Anyway, what does the poor reader of this website, which was written in Bulgarian but appears to be Korean (and not even cohesive Korean), do? 
不管怎样,有什么可怜的本网站的读者,这是写在保加利亚但似乎韩国(甚至有凝聚力的韩国人),做什么?
He uses the View | Encoding menu and tries a bunch of different encodings (there are at least a dozen for Eastern European languages) until the picture comes in clearer. 
他使用视图|编码菜单和一群不同编码(至少有一打东欧语言),直到有更清晰的照片. 
If he knew to do that, which most people don't.
如果他知道,大多数人不。


For the latest version of CityDesk, the web site management software published by my company, we decided to do everything internally in UCS-2 (two byte) Unicode, which is what Visual Basic, COM, and Windows NT/2000/XP use as their native string type. 
 CityDesk 的最新版本，网站发布管理软件 我的公司 ,我们决定尽在ucs-2 Unicode(两个字节)内部,这正是Visual Basic,COM,Windows NT / 2000 / XP使用原生字符串类型. 
In C++ code we just declare strings as wchar_t ("wide char") instead of char and use the wcs functions instead of the str functions (for example wcscat and wcslen instead of strcat and strlen). 
在我们刚刚宣布字符串作为c++代码 wchar_t (“宽字符”),而不是 char 并使用 WCS 函数,而不是 STR 函数(例如 wcscat 和 wcslen 而不是 接成长串 和 strlen ). 
To create a literal UCS-2 string in C code you just put an L before it as so: L"Hello".
C代码创建一个字符串字面ucs-2字符串,你只把L放在前面，如此: L“你好” 。


When CityDesk publishes the web page, it converts it to UTF-8 encoding, which has been well supported by web browsers for many years. 
CityDesk发布网页时,它将其转换为utf - 8编码,这已经被web浏览器也支持了许多年. 
That's the way all 29 language versions of Joel on Software are encoded and I have not yet heard a single person who has had any trouble viewing them.
这是所有的方式 29个语言版本 的 乔尔在软件 编码,我还没有听到一个人有任何麻烦查看他们的人。


This article is getting rather long, and I can't possibly cover everything there is to know about character encodings and Unicode, but I hope that if you've read this far, you know enough to go back to programming, using antibiotics instead of leeches and spells, a task to which I will leave you now.
这篇文章很长,我不可能涵盖一切知道字符编码和Unicode,但我希望,如果你读过这一步,你知道再编程,使用抗生素,而不是水蛭和法术,一个任务,我将离开你了。


    Have you been wondering about Distributed Version Control? It has been a huge productivity boon for us, so I wrote Hg Init, a Mercurial tutorial—check it out! 
    你想知道关于分布式版本控制? 这是一个巨大的生产力 有利于我们,所以我写了Hg Init, Mercurial教程 —出来! 


Next:
下一个:

Craftsmanship
工艺

Want to know more?
想知道更多吗?

You’re reading Joel on Software, stuffed with years and years of completely raving mad articles about software development, managing software teams, designing user interfaces, running successful software companies, and rubber duckies.
你正在阅读 乔尔在软件 ,塞 年复一年的完全疯文章软件开发,管理 软件团队,设计用户界面,运行成功的软件公司, 和橡胶鸭子。

About the author.
关于作者。

I’m Joel Spolsky, co-founder of Fog Creek Software, a New York company that proves that you can treat programmers well and still be highly profitable. Programmers get private offices, free lunch, and work 40 hours a week. Customers only pay for software if they’re delighted. We make Trello, easy web-based collaboration software, FogBugz, an enlightened bug tracking and software development tool, and Kiln, a distributed source control system that will blow your socks off. I’m also the co-founder and CEO of Stack Exchange. More about me.
我 Joel Spolsky , 的创始人之一 Fog Creek软件 , 一个 纽约 公司证明 你可以善待程序员,仍然非常有利可图。 程序员获得私人办公室,免费的午餐,工作40 小时一个星期。 客户只支付软件如果他们很高兴。 我们让Trello, 简单的基于网络的协作软件 FogBugz,开明的 缺陷跟踪 和软件开发工具,和窑,分布式 源控制 系统,会打击你的袜子。 我也的联合创始人兼首席执行官 栈交流 。 更多关于我。
© 2000-2013 Joel Spolsky
joel
joelonsoftware.com
 --------------------------------------------------- 

Objects of class Encoding each represent a different character encoding. 
Encoding类的每个对象代表一种不同的字符编码。
The Encoding.list method returns a list of the built-in encodings, and the Encoding.aliases method returns a hash where the keys are aliases and the values are the corresponding base encoding. 
Encoding.list方法返回内建编码的列表，Encoding.aliases方法返回一个键为别名值为相应基础编码的散列表。
We can use these two methods to build a table of known encoding names:
我们可以使用这两种方法来构建一个已知编码名称表：
`encoding/list_encodings.rb`

    encodings = Encoding 
                  .list 
                  .each.with_object({}) do |enc, full_list|
                      full_list[enc.name] = [enc.name]
                  end
    Encoding.aliases.each do |alias_name, base_name|
      fail "#{base_name} #{alias_name}" unless encodings[base_name]
      encodings[base_name] << alias_name
    end
    puts(encodings 
           .values 
           .sort_by {|base_name, *| base_name.downcase} 
           .map do |base_name, *rest|
             if rest.empty?
               base_name
             else
              "#{base_name} (#{rest.join(', ')})"
            end
          end)

Table 8, Encodings and their aliases, on page 241 shows the output, wrapped into columns.
输出在表8·编码和别名，后面241页。
However, that’s not the full story. 
不过，这并不是全部。
Encodings in Ruby can be dynamically loaded—Ruby actually comes with more encodings than those shown in the output from this code.
ruby中的编码可以被动态导入 -- ruby实际上能处理更多的编码，即使编码没有在表8里面出现。
Strings, regular expressions, symbols, I/O streams, and program source files are all associated with one of these encoding objects.
字符串、正则表达式、符号、I/O流和程序源文件，全部和他们的编码对象有联系。
Encodings commonly used in Ruby programs include ASCII (7-bit characters), ASCII-8BIT, [2] UTF-8, and Shift JIS.
通常用在ruby程序的编码包括ASCII(7位字符）ASCII-8BIT，UTF-8,Shift JIS
[2].There isn’t actually a character encoding called ASCII-8BIT. It’s a Ruby fantasy but a useful one. We’ll talk about it shortly.
实际上没有什么叫做ASCII-8BIT的字符编码。只是ruby空想中的有用的一种，我们将简单谈谈它。

## 17.2 Source Files 源文件
First and foremost, there’s a simple rule: if you only ever use 7-bit ASCII characters in your source, then the source file encoding is irrelevant. 
首先，也是最重要的，是一个简单的规则：如果你只曾经在源代码使用过7位的ASCII字符，则无关源文件编码。
So, the simplest way to write Ruby source files that just work everywhere is to stick to boring old ASCII.
所以，写出到处都能运行的ruby源文件最简单的方法是坚持烦人的老式ASCII。

Table 8—Encodings and their aliases

    ASCII-8BIT (BINARY)              Big5                                     Big5-HKSCS (Big5-HKSCS:2008)
    Big5-UAO                         CP50220                                  CP50221
    CP51932                          CP850 (IBM850)                           CP852
    CP855                            CP949                                    CP950
    CP951                            Emacs-Mule                               EUC-JP (eucJP)
    EUC-JP-2004 (EUC-JISX0213)       EUC-KR (eucKR)                           EUC-TW (eucTW)
    eucJP-ms (euc-jp-ms)             GB12345                                  GB18030
    GB1988                           GB2312 (EUC-CN, eucCN)                   GBK (CP936)
    IBM437 (CP437)                   IBM737 (CP737)                           IBM775 (CP775)
    IBM852                           IBM855                                   IBM857 (CP857)
    IBM860 (CP860)                   IBM861 (CP861)                           IBM862 (CP862)
    IBM863 (CP863)                   IBM864 (CP864)                           IBM865 (CP865)
    IBM866 (CP866)                   IBM869 (CP869)                           ISO-2022-JP (ISO2022-JP)
    ISO-2022-JP-2 (ISO2022-JP2)      ISO-2022-JP-KDDI                         ISO-8859-1 (ISO8859-1)
    ISO-8859-10 (ISO8859-10)         ISO-8859-11 (ISO8859-11)                 ISO-8859-13 (ISO8859-13)
    ISO-8859-14 (ISO8859-14)         ISO-8859-15 (ISO8859-15)                 ISO-8859-16 (ISO8859-16)
    ISO-8859-2 (ISO8859-2)           ISO-8859-3 (ISO8859-3)                   ISO-8859-4 (ISO8859-4)
    ISO-8859-5 (ISO8859-5)           ISO-8859-6 (ISO8859-6)                   ISO-8859-7 (ISO8859-7)
    ISO-8859-8 (ISO8859-8)           ISO-8859-9 (ISO8859-9)                   KOI8-R (CP878)
    KOI8-U                           macCentEuro                              macCroatian
    macCyrillic                      macGreek                                 macIceland
    MacJapanese (MacJapan)           macRoman                                 macRomania
    macThai                          macTurkish                               macUkraine
    Shift_JIS                        SJIS-DoCoMo                              SJIS-KDDI
    SJIS-SoftBank                    stateless-ISO-2022-JP                    stateless-ISO-2022-JP-KDDI
    TIS-620                          US-ASCII (ASCII, ANSI_X3.4-1968, 646)    UTF-16
    UTF-16BE (UCS-2BE)               UTF-16LE                                 UTF-32
    UTF-32BE (UCS-4BE)               UTF-32LE (UCS-4LE)                       UTF-7 (CP65000)
    UTF-8 (CP65001)                  UTF8-DoCoMo                              UTF8-KDDI
    UTF8-MAC (UTF-8-MAC, UTF-8-HFS)  UTF8-SoftBank                            Windows-1250 (CP1250)
    Windows-1251 (CP1251)            Windows-1252 (CP1252)                    Windows-1253 (CP1253)
    Windows-1254 (CP1254)            Windows-1255 (CP1255)                    Windows-1256 (CP1256)
    Windows-1257 (CP1257)            Windows-1258 (CP1258)                    Windows-31J (CP932, csWindows31J, SJIS, PCK)
    Windows-874 (CP874)


**编码注释行**
However, once a source file contains a byte whose top bit is set, you’ve just left the comfortable world of ASCII and entered the wild and wacky nightmare of character encodings. 
不过，一旦源文件包含设置了一个最高位的字节，你只能离开舒服的ASCII世界，进入野蛮又古怪充满噩梦的字符编码。
Here’s how it works.
这是它的工作过程。

If your source files are not written using 7-bit ASCII, you probably want to tell Ruby about it. 
如果你的源文件没有使用7位ASCII，你可能想告诉ruby一些情况。
Because the encoding is an attribute of the source file, and not anything to do with the environment where the file is used, Ruby has a way of setting the encoding on a file-by-file basis using a new magic comment. 
因为编码是源文件的属性，无关文件使用的环境，ruby有一个方法来设置编码，在每个文件的头上使用一个新的魔幻注释。
If the first line of a file [3] is a comment (or the second line if the first line is a #! shebang line), Ruby scans it looking for the string coding:. 
如果文件的第一行是一个注释（或者第二行，如果第一行是#!行），ruby将扫描查找字符串`coding:`。
[3].Or a string passed to eval。
或者传一个字符串给eval。
If it finds it, Ruby then skips any spaces and looks for the (case-insensitive) name of an encoding. 
如果它发现了，ruby就会跳过空格查找编码名（不区分大小写）。
Thus, to specify that a source file is in UTF-8 encoding, you can write this:
因此，指定一个源文件位UTF-8编码，你可以这样写：

    # coding: utf-8

As Ruby is just scanning for coding:, you could also write the following.
因为ruby只是查找`coding:`，你也可以这样写。


    # encoding: ascii

Emacs users might like the fact that this also works:
Emacs用户可能喜欢下面这种：

    # -*- encoding: shift_jis -*-

(Your favorite editor may also support some kind of flag comment to set a file’s encoding.)
（你最喜欢的编辑器可能也支持一些类型的标记注释来设置文件的编码）
If there’s a shebang line, the encoding comment must be the second line of the file:
如果有#!行，编码注释必须在文件的第二行：

    #!/usr/local/rubybook/bin/ruby
    # encoding: utf-8

Additionally, Ruby detects any files that start with a UTF-8 byte order mark (BOM). 
另外，ruby探测文件是否有用UTF-8字节的顺序标记（BOM）。
If Ruby sees the byte sequence \xEF\xBB\xBF at the start of a source file, it assumes that file is UTF-8 encoded.
如果ruby看到字节序列\xEF\xBB\xBF在源文件的开头，就会假定那个文件是UFT-8编码。

The special constant __ENCODING__ returns the encoding of the current source file.
特别常数 __ENCODING__返回当前源文件编码。

### ruby 1.9 vs. ruby2.0
⇡New in 2.0⇣
In Ruby 1.9, the default source file encoding is US-ASCII. 
在 Ruby 1.9, 默认源文件编码是US-ASCII。
If your source files contain any characters with byte value greater than 127, you’ll need to tell Ruby the encoding of the file, or Ruby will report an error, probably saying something like “invalid multibyte char.” 
如果你的源文件包含任何字节值大于127的字符，你需要告诉Ruby文件的编码，或ruby将报告一个错误，可能会说诸如“无效多字节字符”的话。
Here’s an example where we typed some UTF-8 characters into a Ruby program:
这是一个例子，这个程序里面包含了一些UFT-8字符:

    π = 3.14159
    puts "π = #{π}"

With Ruby 1.9, you’ll get an error unless you add the encoding: utf-8 comment at the top.
用Ruby 1.9, 你将得到一个错误，除非你在顶部添加了`encoding: utf-8`注释。
In Ruby 2.0, however, the default source file encoding is UTF-8, and the previous program will run as it stands.
在 Ruby 2.0,不管怎样，默认的源文件编码是UTF-8，之前的程序将如常运行。
We can verify that Ruby correctly interprets π as a single character.
我们可以验证ruby是否将π解释为一个字符：

    # encoding: utf-8
    PI = "π"
    puts "The size of a string containing π is #{PI.size}"
    # produces:
    # The size of a string containing π is 1

Now, let’s get perverse. 
现在，我们任性些。
The two-byte sequence \xcf\x80 represents π in UTF-8 but is not a valid byte sequence in the SJIS encoding. 
两位的\xcf\x80在UTF-8代表π, 但在SJIS编码里它是无效的字节序列。
Let’s see what happens if we tell Ruby that this same source file is SJIS encoded. 
让我们看看如果我们告诉ruby这和刚才相同的源文件是SJIS编码的。
(Remember, when we do this, we’re not changing the actual bytes in the string—we’re just telling Ruby to interpret them with a different set of encoding rules.)
（记住，这样做的时候，我们不改变字符串的实际字节 -- 我们只是告诉ruby用一个不同的编码规则集来解释它）

    # encoding: sjis
    PI = "π"
    puts "The size of a string containing π is #{PI.size}"
    # produces:
    # puts "The size of a string containing π is #{PI.size}"
    #          ^
    # prog.rb:2: invalid multibyte char (Windows-31J)
    # prog.rb:3: syntax error, unexpected tCONSTANT, expecting end-of-input

This time, Ruby complains because the file contains byte sequences that are illegal in the given encoding. 
这一次，ruby抱怨了，因为文件包含的字节序列在指定的编码中是非法的。
And, to make matters even more confusing, the parser swallowed up the double quote after the π character, presumably while trying to build a valid SJIS character.
而且，让事情更糟的是，解析器吞掉了π之后的双引号，大概为了尝试构建一个有效的SJIS字符吧。
This led to the second error message, because the word The is now interpreted as program text.
这导致了第二个错误信息，因为单词The现在被解释为程序文本了。

### Source Elements That Have Encodings 有编码的源元素
String literals are always encoded using the encoding of the source file that contains them, regardless of the content of the string:
字符串字面量总是采用包含它们的源文件的编码，和字符串的内容无关：

    # encoding: utf-8
    def show_encoding(str)
      puts "'#{str}' (size #{str.size}) is #{str.encoding.name}"
    end
    show_encoding "cat" # latin 'c', 'a', 't'
    show_encoding "∂og" # greek delta, latin 'o', 'g'
    # produces:
    # 'cat' (size 3) is UTF-8
    # '∂og' (size 3) is UTF-8

Symbols and regular expression literals that contain only 7-bit characters are encoded using US-ASCII. 
只包含7位字节的符号和正则表达式字面量，只使用US-ASCII编码。
Otherwise, they will have the encoding of the file that contains them.
其他的，他们将有包含他们的文件的编码。

    # encoding: utf-8
    def show_encoding(str)
      puts "#{str.inspect} is #{str.encoding.name}"
    end
    show_encoding :cat
    show_encoding :∂og
    show_encoding /cat/
    show_encoding /∂og/
    # produces:
    # :cat is US-ASCII
    # :∂og is UTF-8
    # /cat/ is US-ASCII
    # /∂og/ is UTF-8

You can create arbitrary Unicode characters in strings and regular expressions using the \u escape. 
你可以在字符串和正则表达式中用\u逃脱符创建任意Unicode字符。
This has two forms: \uxxxx lets you encode a character using four hex digits, and the delimited form \u{x...  x...  x...} lets you specify a variable number of characters, each with a variable number of hex digits:
这有两种形式：\uxxxx让你编码一个字符使用四个十六进制数据，\u{x...  x...  x...}定界符让你指定一个字符的变化数，每个带有十六进制的变化数。

    # encoding: utf-8
    "Greek pi: \u03c0" # => "Greek pi: π"
    "Greek pi: \u{3c0}" # => "Greek pi: π"
    "Greek \u{70 69 3a 20 3c0}" # => "Greek pi: π"

Literals containing a \u sequence will always be encoded UTF-8, regardless of the source file encoding.
包含一个\u序列的字面量将总是UTF-8编码，和源文件编码无关。

The String#bytes method is a convenient way to inspect the bytes in a string object. 
String#bytes方法是一个方便的途径去检查字符串对象的字节。
Notice that in the following code, the 16-bit codepoint is converted to a two-byte UTF-8 encoding:
注意在下面的代码中，16位代码点被转化为两字节的UTF-8编码：

    # encoding: utf-8
    "pi: \u03c0".bytes # => [112, 105, 58, 32, 207, 128]

### Eight-Bit Clean Encodings 八位干净编码
Ruby supports a virtual encoding called ASCII-8BIT. 
Ruby支持一个叫ASCII-8BIT的虚拟编码。
Despite the ASCII in the name, this is really intended to be used on data streams that contain binary data (which is why it has an alias of BINARY}). 
尽管名中有ASCII，这是真打算用在包含二进制数据的数据流上（这就是为什么他有一个BINARY的别名）。
However, you can also use this as an encoding for source files. 
不管怎样，你也可以将它当作一个源文件编码来使用。
If you do, Ruby interprets all characters with codes below 128 as regular ASCII and all other characters as valid constituents of variable names. 
如你愿意，Ruby将所有128码以下的字符解释正常的ASCII，将所有其他的字符解释为变量名的正常构成。
This is basically a neat hack, because it allows you to compile a file written in an encoding you don’t know—the characters with the high-order bit set will be assumed to be printable.
这基本上是一个简洁的黑客方法（hack），因为允许你编译一个用未知编码写成的文件 -- 带有高阶位设置的字符将被假定为可打印的。

    # encoding: ascii-8bit
    π = 3.14159
    puts "π = #{π}"
    puts "Size of 'π' = #{'π'.size}"
    # produces:
    # π = 3.14159
    # Size of 'π' = 2

The last line of output illustrates why ASCII-8BIT is a dangerous encoding for source files.
输出的最后一行说明为什么ASCII-8BIT是源文件的危险编码。
Because it doesn’t know to use UTF-8 encoding, the π character looks to Ruby like two separate characters.
因为它不知道使用UTF-8编码，π字符对Ruby来说看起来像两个独立字符。

### Source Encoding Is Per-File  每个文件是源编码
Clearly, a large application will be built from many source files. 
相当清楚的，一个大的应用程序将由许多源文件构建。
Some of these files may come from other people (possibly as libraries or gems). 
这些文件中的一些可能来自他其他人（可能是一个库或gems）
In these cases, you may not have control over the encoding used in a file.
在这种情况下，你可能没有控制每个文件的编码。

Ruby supports this by allowing different encodings in the files that make up a project. 
允许不同文件采用不同编码，Ruby支持这个功能从而组成一个项目。
Each file starts with the default encoding of US-ASCII. 
每个文件用默认的US-ASCII编码开始。
The file’s encoding may then be set with either a coding: comment or a UTF-8 BOM.
文件的编码可能被设置为`coding:`注释或者一个UTF-8字节顺序标记（BOM Byte Order Mark）

Here’s a file called iso-8859-1.rb. 
这是一个叫ISO-8859-1.rb的文件。
Notice the explicit encoding.
注意明确编码。
encoding/iso-8859-1.rb

    # -*- encoding: iso-8859-1 -*-
    STRING_ISO = "ol\351" # \x6f \x6c \xe9

And here’s its UTF-8 counterpart:
下面是它的UTF-8副本：
encoding/utf.rb

    # file: utf.rb, encoding: utf-8
    STRING_U = "∂og" # \xe2\x88\x82\x6f\x67

Now let’s require both of these files into a third file. 
现在让我们要求这些文件都进入第三个文件
Just for the heck of it, let’s declare the third file to have SJIS encoding:
只为更好玩些，让我们的第三个文件使用SJIS编码：

    # encoding: sjis
    require_relative 'iso-8859-1'
    require_relative 'utf'
    def show_encoding(str)
      puts "'#{str.bytes.to_a}' (#{str.size} chars, #{str.bytesize} bytes) " + "has encoding #{str.encoding.name}"
    end
    show_encoding(STRING_ISO)
    show_encoding(STRING_U)
    show_encoding("cat")
    # produces:
    # '[111, 108, 233]' (3 chars, 3 bytes) has encoding ISO-8859-1
    # '[226, 136, 130, 111, 103]' (3 chars, 5 bytes) has encoding UTF-8
    # '[99, 97, 116]' (3 chars, 3 bytes) has encoding Windows-31J

Each file has an independent encoding, and string literals in each retain their own encoding, even when used in a different file. 
每个文件都有一个独立的编码，里面的字符串字面量包含它们自己的字符，甚至使用在不同的文件时。
All the encoding directive does is tell Ruby how to interpret the characters in the file and what encoding to use on literal strings and regular expressions.
所有的编码指示都告诉ruby怎么去解释文中的字符，以及在字面量字符串和正则表达式中使用什么编码。
Ruby will never change the actual bytes in a source file when reading them in.
读入时ruby将绝不改变源文件里的实际字节。

## 17.3 Transcoding 转码
**String#encode**
As we’ve already seen, strings, symbols, and regular expressions are now labeled with their encoding. 
正如我们已经看到，字符串、符号、正则表达式现在嵌入了他们的编码。
You can convert a string from one encoding to another using the String#encode method. 
你可以使用String#encode方法将字符串从一种编码转换成另一种编码。
For example, we can convert the word olé from UTF-8 to ISO-8859-1:
比如，我们能将词语olé从UTF-8转换成ISO-8859-1:

    # encoding: utf-8
    ole_in_utf = "olé"
    ole_in_utf.encoding               # => #<Encoding:UTF-8>    
    ole_in_utf.bytes.to_a             # => [111, 108, 195, 169]
    ole_in_8859 = ole_in_utf.encode("iso-8859-1")
    ole_in_8859.encoding              # => #<Encoding:ISO-8859-1>
    ole_in_8859.bytes.to_a            # => [111, 108, 233]

You have to be careful when using encode—if the target encoding doesn’t contain characters that appear in your source string, Ruby will throw an exception. 
使用encode时你应该小心些 -- 如果目标编码没有包含你的源字符的字符，Ruby将会抛出一个异常。
For example, the π character is available in UTF-8 but not in ISO-8859-1:
比如，字符π在UTF-8是可用的，但在ISO-8859-1中是不存在的。

    # encoding: utf-8
    pi = "pi = π"
    pi.encode("iso-8859-1")
    # produces:
    # from prog.rb:3:in `<main>'
    # prog.rb:3:in `encode': U+03C0 from UTF-8 to ISO-8859-1
    # (Encoding::UndefinedConversionError)

You can, however, override this behavior, for example supplying a placeholder character to use when no direct translation is possible. 
不管怎样，你可以重写这个行为，比如提供一个占位符字符，在没有直接的译文可以提供时使用。
(See the description of String#encode in the reference section on page 675 for more details.)
详看后面675页参考部分String#encode的描述。

    # encoding: utf-8
    pi = "pi = π"
    puts pi.encode("iso-8859-1", :undef => :replace, :replace => "??")
    # produces:
    # pi = ??

**`String#force_encoding`**
Sometimes you’ll have a string containing binary data and you want that data to be inter- preted as if it had a particular encoding. 
有时你将有一个包含二进制数据的字符串，而你想将那个数据解释出来，就好象它有特定的编码。
You can’t use the encode method for this, because you don’t want to change the byte contents of the string—you’re just changing the encoding associated with those bytes. 
这种情况你不能使用encode方法，因为你不想改变字符串的字节内容 -- 你只能改变那些字节关联的编码。
Use the `String#force_encoding` method to do this:
可以使用`String#force_encoding`方法：

    # encoding: ascii-8bit
    str = "\xc3\xa9"
    # e-acute in UTF-8
    str.encoding           # => #<Encoding:ASCII-8BIT>
    str.force_encoding("utf-8")
    str.bytes.to_a        # => [195, 169]
    str.encoding          # => #<Encoding:UTF-8>

**两种方法之间转换**
Finally, you can use encode (with two parameters) to convert between two encodings if your source string is ASCII-8BIT. 
最后，你可以使用encode（带两个参数）在两种方法之间转换，如果你的源字符串是ASCII-8BIT。
This might happen if, for example, you’re reading data in binary mode from a file and choose not to encode it at the time you read it. 
这是可能的，如果，比如，你正在二进制模式下从一个文件中读入数据，并选择在你读入的时候不进行编码。
Here we fake that out by creating an ASCII-8BIT string that contains an ISO-8859-1 sequence (our old friend olé). 
这里我们假设，通过创建一个ASCII-8BIT字符串包含一个ISO-8859-1序列（老朋友olé）

We then convert the string to UTF-8. 
然后我们将字符串转换为UTF-8。
To do this, we have to tell encode the actual encoding of the bytes by passing it a second parameter:
要成功，我们必须通过传给一个次要参数告诉encode字节的实际编码。

    # encoding: ascii-8bit
    original = "ol\xe9"
    # e-acute in ISO-8859-1
    original.bytes.to_a          # => [111, 108, 233]
    original.encoding            # => #<Encoding:ASCII-8BIT>
    new = original.encode("utf-8", "iso-8859-1")
    new.bytes.to_a               # => [111, 108, 195, 169]
    new.encoding                 # => #<Encoding:UTF-8>

If you’re writing programs that will support multiple encodings, you probably want to read Section 17.5, Default External Encoding, on page 248—it will greatly simplify your life.
如果你正写着支持多编码的程序，你可能想读读后面248页17.5 默认外部编码 一章 -- 它能简化你的生活。

## 17.4 Input and Output 输入和输出
**外边编码**
Playing around with encodings within a program is all very well, but in most code we’ll want to read data from and write data to external files. 
在程序里玩弄编码是很好玩的，但在大部分代码里我们要从外部文件中读入并写入外部文件里。
And, often, that data will be in a particular encoding.
而且，数据经常有特定的编码。

Ruby’s I/O objects support both encoding and transcoding of data. 
Ruby的 I/O 对象支持数据的编码和转码。
What does this mean?
这意味着什么呢？

Every I/O object has an associated external encoding. 
每个I/O对象都有一个关联的外部编码。
This is the encoding of the data being read from or written to the outside world. 
这是数据被从外部世界读入或者写入外部数据的编码。
Through a piece of magic I’ll describe later on page 248, all Ruby programs run with the concept of a default external encoding. 
通过一段后面248页描述的幻数，所有的ruby程序用默认外部编码的概念进行运作。
<kinder:note> 在哪里？
This is the external encoding that will be used by I/O objects unless you override it when you create the object (for example, by opening a file).
这外部编码将被I/O对象使用，除非你在创建新对象时重写它（比如，通过打开文件）。

**内部编码**
Now, your program may want to operate internally in a different encoding. 
现在，你的程序可能想在内部用一个不同的编码操作。
For example, some of my files may be encoded with ISO-8859-1, but we want our Ruby program to work internally using UTF-8. 
比如，我的一些文件可能用ISO-8859-1编码，但我们想ruby程序运作时使用UTF-8。
Ruby I/O objects manage this by having an optional associated internal encoding. 
Ruby I/O 对象通过一个可选的内部编码管理这个。
If set, then input will be transcoded from the external to the internal encodings on read operations, and output will be transcoded from internal to external encoding on write operations.
如果设置了，则输入在读入操作时将被从外部编码转化为内部编码，而输出在写入操作时将被从内部编码转化为外部编码。

**`IO#external_encoding`**
Let’s start with the simple cases. 
让我们从简单的情况开始。
On our OS X box, the default external encoding is UTF-8.
在我们的OS X系统，默认外部编码是UTF-8。
If we don’t override it, all our file I/O will therefore also be in UTF-8. 
如果我们不改变它，我们所有文件I/O将也是用UTF-8.
We can query the external encoding of an I/O object using the `IO#external_encoding` method:
我们可以使用`IO#external_encoding`方法查询一个I/O对象的外部编码。

    f = File.open("/etc/passwd")
    puts "File encoding is #{f.external_encoding}"
    line = f.gets
    puts "Data encoding is #{line.encoding}"
    # produces:
    # File encoding is UTF-8
    # Data encoding is UTF-8

Notice that the data is tagged with a UTF-8 encoding even though it (presumably) contains just 7-bit ASCII characters. 
注意数据带有UTF-8编码，即使它只包含7位ASCII字符。
Only literals in your Ruby source files have the “change encoding if they contain 8-bit data” rule.
在你的ruby源文件中只有字面量有“如果他们包含8位数据则改变编码”的规则。
<kinder:note> 什么意思？

**强制读入和写入的编码**
You can force the external encoding associated with an I/O object when you open it—simply add the name of the encoding, preceded by a colon, to the mode string. 
当你打开I/O对象时，你可以强制它相联的外部编码 -- 它只会增加编码的名字，前置一个冒号，到模式字符串中。
Note that this in no way changes the data that’s read; it simply tags it with the encoding you specify:
注意这没有改变它读入的数据，它只是用你指定的编码给它标签一下而已。

    f = File.open("/etc/passwd", "r:ascii")
    puts "File encoding is #{f.external_encoding}"
    line = f.gets
    puts "Data encoding is #{line.encoding}"
    # produces:
    # File encoding is US-ASCII
    # Data encoding is US-ASCII

You can force Ruby to transcode—change the encoding—of data it reads and writes by putting two encoding names in the mode string, again with a colon before each. 
你可以强制ruby转码 -- 改变读入和写入的数据的编码 -- 通过放两个编码名称在模式字符串中，同样的这两个都需要前置冒号。
For example, the file iso-8859-1.txt contains the word olé in ISO-8859-1 encoding, so the e-acute (é) character is encoded by the single byte \xe9. 
比如，文件iso-8859-1.txt包含用ISO-8859-1编码的单词olé，所以e-acute (é)字符被编码为单个字节\xe9。
I can view this file’s contents in hex using the od command- line tool. 
我可以用od命令行工具看到十六进制下面这个文件的内容。
(Windows users can use the d command in debug to do the same.)
（Windows用户可以在degug中使用d命令来看）

    0000000 6f 6c e9 0a 
    0000004

If we try to read it with our default external encoding of UTF-8, we’ll encounter a problem:
如果我们尝试用默认的外部编码UTF-8读入，我们会遇到一个问题：

    f = File.open("iso-8859-1.txt")
    puts f.external_encoding.name
    line = f.gets
    puts line.encoding
    puts line
    # produces:
    # UTF-8
    # UTF-8
    # ol?

The problem is that the binary sequence for the e-acute isn’t the same in ISO-8859-1 and UTF-8. 
问题是二进制序列e-acute在ISO-8859-1和UTF-8是不同的。
Ruby just assumed the file contained UTF-8 characters, tagging the string it read accordingly.
ruby只是假设文件包含UTF-8字符，因此标记读入的字符串。
We can tell the program that the file contains ISO-8859-1:
我们可以告诉程序该文件包含ISO-8859-1：

    f = File.open("iso-8859-1.txt", "r:iso-8859-1")
    puts f.external_encoding.name
    line = f.gets
    puts line.encoding
    puts line
    # produces:
    # ISO-8859-1
    # ISO-8859-1
    # ol?

This doesn’t help us much. 
这不能帮到我们很多。
The string is now tagged with the correct encoding, but our operating system is still expecting UTF-8 output.
字符串现在用正确的编码标记了，但我们的操作系统仍然期待这UTF-8输出。
The solution is to map the ISO-8859-1 to UTF-8 on input:
解决方法是在输出时将ISO-8859映射到UTF-8：

    f = File.open("iso-8859-1.txt", "r:iso-8859-1:utf-8")
    puts f.external_encoding.name
    line = f.gets
    puts line.encoding
    puts line
    # produces:
    # ISO-8859-1
    # UTF-8
    # olé

If you specify two encoding names when opening an I/O object, the first is the external encoding, and the second is the internal encoding. 
如果你在打开一个I/O对象时指定两个编码名字，第一个将是外部编码，第二个是内部编码。
Data is transcoded from the former to the latter on reading and the opposite way on writing.
数据在读入时从前者转换为后者，写入时则相反。

### Binary Files 二进制文件
In the old days, we Unix users used to make little snide comments about the way that Windows users had to open binary files using a special binary mode. 
以前，我们的Unix用户常常制造小注释讽刺 Windows用户只能用特定的二进制模式打开二进制文件
Well, now the Windows folks can get their own back. 
好吧，现在Windows用户可以反过来说我们了。
If you want to open a file containing binary data in Ruby, you must now specify the binary flag, which will automatically select the 8-bit clean ASCII-8BIT encoding. 
如果你想用ruby打开一个包含二进制的文件，你必须指定二进制标志，这将自动选择八位干净ASCII-8BIT编码。
To make things explicit, you can use “binary” as an alias for the encoding:
为了更明确些，你可以使用“binary”作为编码的别名：

    f = File.open("iso-8859-1.txt", "rb")
    puts "Implicit encoding is #{f.external_encoding.name}"
    f = File.open("iso-8859-1.txt", "rb:binary")
    puts "Explicit encoding is #{f.external_encoding.name}"
    line = f.gets
    puts "String encoding is #{line.encoding.name}"
    # produces:
    # Implicit encoding is ASCII-8BIT
    # Explicit encoding is ASCII-8BIT
    # String encoding is ASCII-8BIT

## 17.5 Default External Encoding  默认外部编码
If you look at the text files on your computer, the chances are that they’ll all use the same encoding. 
如果你在电脑里寻找文本文件，得看他们是否全部使用相同的编码。
In the United States, that’ll probably be UTF-8 or ASCII. 
在美国，可能是UTF-8或者ASCII。
In Europe, it might be UTF-8 or ISO-8859-x. 
在欧洲，可能是UTF-8或者ISO-8859-x。
If you use a Windows box, you may be using a different set of encodings (use the console chcp command to find your current code page). 
如果你使用Windows系统，你可能使用不同的编码集（使用控制台的chcp命令可找到当前的代码页）。
But whatever encoding you use, the chances are good that you’ll stick with it for the majority of your work.
但无论你使用什么编码，运气很好，你可以坚持它完成大多数工作。

On Unix-like boxes, you’ll probably find you have the LANG environment variable set. 
在Unix类系统，你可能找到你的LANG环境编码设置。
On one of our OS X boxes, it has the value`en_US.UTF-8` 
在OS X系统，它的值是`en_US.UTF-8`。

This says that we’re using the English language in the U.S. 
这说明我们使用美国英语。
territory and the default code set is UTF-8. 
区域和默认码集是UTF-8。
On startup, Ruby looks for this environment variable and, if present, sets the default external encoding from the code set component. 
启动时，ruby寻找这个环境变量，如果存在，将从码集组件中设置默认外部编码。
Thus, on this box, Ruby 1.9 programs run with a default external encoding of UTF-8. 
因而，在这个系统，Ruby 1.9 程序运行时用的是默认UTF-8外部编码。
If instead we were in Japan and the LANG variable were set to `ja_JP.sjis`, the encoding would be set to Shift JIS. 
如果我们是在日本，LANG环境变量将设置为`ja_JP.sjis`，编码被设置为Shift JIS。
We can look at the default external encoding by querying the Encoding class. 
我们可以通过查找Encoding类来发现默认的外部编码。
While we’re at it, we’ll experiment with different values in the LANG environment variable:
进入后，我们将用LANG环境变量的不同值做下实验：

    $ echo $LANG
    en_US.UTF-8
    $ ruby -e 'p Encoding.default_external.name'
    "UTF-8"
    $ LANG=ja_JP.sjis ruby -e 'p Encoding.default_external.name'
    "Shift_JIS"
    $ LANG= ruby -e 'p Encoding.default_external.name'
    "US-ASCII"

The encoding set from the environment does not affect the encoding Ruby uses for source files—it affects only the encoding of data read and written by your programs.
环境的编码集不会影响Ruby用于源文件的编码 -- 它只影响程序里面数据读入和写入的编码。
Finally, you can use the -E command-line option (or the long-form --encoding) to set the default external encoding of your I/O objects, as shown in the following commands.
最后，你可以使用-E命令行选项（长形式是--encoding）来设置你I/O对象的默认外部编码，正如下面命令所显示的：

    $ ruby -E utf-8 -e 'p Encoding.default_external.name'
    "UTF-8"
    $ ruby -E sjis -e 'p Encoding.default_external.name'
    "Shift_JIS"
    $ ruby -E sjis:iso-8859-1 -e 'p Encoding.default_internal.name'
    "ISO-8859-1"

## 17.6 Encoding Compatible  编码兼容
Before Ruby performs operations involving strings or regular expressions, it first has to check that the operation makes sense. 
在ruby执行包含字符串或正则表达式的操作之前，它首先秩序检查操作的意义。
For example, it is valid to perform an equality test between two strings with different encodings, but it is not valid to append one to the other.
比如，在两个采用不同编码的字符串进行相等测试是有意义的，但将一个追加在另一个的后面则是无效的。
The basic steps in this checking are as follows:
这个检查的基本步骤如下：

1.  If the two objects have the same encoding, the operation is valid.
    如果两个对象有一样的编码，操作有效。
2.  If the two objects each contain only 7-bit characters, the operation is permitted regardless of the encodings.
    如果两个对象都只包含七位字符，则不管什么编码，操作都被许可。
3.  If the encodings in the two objects are compatible (which we’ll discuss next), the opera- tion is permitted.
    如果两个对象里编码是兼容的（下文会讨论），操作是允许的。
4.  Otherwise, an exception is raised.
    其他情况将抛出例外。

Let’s say you have a set of text files containing markup. 
假设你有一组包含标记的文本文件。
In some of the files, authors used the sequence &hellip; to represent an ellipsis. 
在一些文件里，作者使用序列 &hellip; 来表示省略号。
In other files, which have UTF-8 encoding, authors used an actual ellipsis character (\u2026). 
在其他UTF-8的文件，作者使用一个真正的省略号字符（\u2026）。
We want to convert both forms to three periods.
我们要将这两种形式转换第三种句点。

We can start off with a simplistic solution:
我们可以用一个简单的解决方案开始：

    # encoding: utf-8
    while line = gets
      result = line.gsub(/&hellip;/, "...")
                   .gsub(/\u2026/, "...") # unicode ellipsis
      puts result
    end

In my environment, the content of files is by default assumed to be UTF-8. 
在我们的环境中，文件内容默认UTF-8编码。
Feed our code ASCII files and UTF-encoded files, and it works just fine. 
将ASCII文件和UTF编码文件读入代码中，代码运行地不错。
But what happens when we feed it a file that contains ISO-8859-1 characters?
但我们要是读入一个包含ISO-8859-1字符的文件，又怎么样呢？

    dots.rb:4:in `gsub': broken UTF-8 string (ArgumentError)

Ruby tried to interpret the input text, which is ISO-8859-1 encoded, as UTF-8. 
Ruby尝试解释输入ISO-8859-1编码文本，作为UTF-8。
Because the byte sequences in the file aren’t valid UTF, it failed.
因为文件的字节流不是有效的UTF，它失败了。

There are three solutions to this problem. 
有三种解决方法。
The first is to say that it makes no sense to feed files with both ISO-8859 and UTF-8 encoding to the same program without somehow differentiating them. 
第一种是同一个程序不能理解同时用ISO-8859和UTF-8编码、但不知什么原因而没有区分它们的输入文件。
That’s perfectly true. 
那真是完美。
This approach means we’ll need some command-line options, liberal use of `force_encoding`, and probably some kind of code to delegate the pattern matching to different sets of patterns depending on the encoding of each file.
这种解决意味着我们将需要一些命令行选项，自由使用`force_encoding`，可能一些种类的代码代表模式匹配不同模式集，依赖每个文件的编码。

A second hack is to simply treat both the data and the program as ASCII-8BIT and perform all the comparisons based on the underlying bytes. 
第二种方法是简单地将数据和程序当作ASCII-8BIT，并基于下面的字节执行所有的比较。
This isn’t particularly reliable, but it might work in some circumstances.
这不出特别有效，但可能在一些情境下有效。

The third solution is to choose a master encoding and to transcode strings into it before doing the matches. 
第三种解决方法是选择一个主编码，在匹配之前将字符串转码为该主编码。
Ruby provides built-in support for this with the `default_internal` encoding mechanism.
Ruby提供了内建支持，用`default_internal`编码机制。

## 17.7 Default Internal Encoding 默认内部编码
By default, Ruby performs no automatic transcoding when reading and writing data.
Ruby默认在读入和写入数据时不会进行自动转码。
However, two command-line options allow you to change this.
不过，两个命令行参数允许你改变这一点。
We’ve already seen the -E option, which sets the default encoding applied to the content of external files. 
我们已经看过-E选项，可以将默认编码设置设置为外部文件编码。
When you say -E xxx, the default external encoding is set to xxx. 
当你说-E xxx,默认外部编码就设定为xxx。
However, -E takes a second option. 
不过，-E选项还有第二个选项。
In the same way that you can give File#open both external and internal encodings, you can also set a default internal encoding using the option -E external:internal.
同样，你可以将外部和内部编码给File#open方法，你也可以用`-E external:internal`设置内部编码。

Thus, if all your files are written with ISO-8859-1 encoding but you want your program to have to deal with their content as if it were UTF-8, you can use this:
因此，如果所有文件都是用ISO-8859-1编码，但你想程序处理时当作UTF-8编码，你可以使用这个：

    $ ruby -E iso-8859-1:utf-8

You can specify just an internal encoding by omitting the external option but leaving the colon:
你可以只指定一个内部编码，忽略外部编码，但记得需要冒号：

    $ ruby -E :utf-8

Indeed, because UTF-8 is probably the best of the available transcoding targets, Ruby has the -U command-line option, which sets the internal encoding to UTF-8.
确实，因为UTF-8可能是最好用的转码目标，Ruby有-U命令行选项，将内部编码设置为UTF-8。
You can query the default internal encoding in your code with the Encoding.default_internal method. 
你可以用`Encoding.default_internal`方法在你的代码中查询默认内部编码。
This returns nil if no default internal encoding has been set. 
如果没有设置内部编码，将返回nil。
 One last note before we leave this section: if you compare two strings with different encodings, Ruby does not normalize them. 
这一节的最后：如果你比较两个不同编码的字符串，ruby不会将它们规范化。
Thus, "é" tagged with a UTF-8 encoding will not compare equal to "é" tagged with ISO-8859-1, because the underlying bytes are different.
因此，使用UTF-8编码的不能和使用ISO-8859-1的进行比较，因为潜在的字节是不同的。

## 17.8 Fun with Unicode 使用Unicode的乐趣
As Daniel Berger pointed out [4], we can now do fun things with method and variable names:
正如aniel Berger所指出的，我们现在可以玩弄方法和变量名了。

    # encoding: utf-8
    def ∑(*args)
      args.inject(:+)
    end
    puts ∑ 1, 3, 5, 9
    # produces:
    # 18

Of course, this way can lead to some pretty obscure and hard-to-use code.
当然，这个方法会导致相当晦涩和难用的代码。
(For example, is the summation character in the previous code a real summation, \u2211, or a Greek sigma, \u03a3?) Just because we can do something doesn’t mean we necessarily should...
（比如，上例中代码的合计字符用一个真的合计，\u2211，或者是一个希腊字母\u03a3?,只是因为我们可以做些什么，但不意味着我们需要这么做……）

[4]. http://www.oreillynet.com/ruby/blog/2007/10/fun_with_unicode_1.html
Fun with Unicode

Wednesday October 31, 2007 6:55PM
by Daniel Berger in Technical 

Did you know you can do this with Ruby out of the box?
# A real lambda
λ { puts ‘Hello’ }.call => ‘Hello’

# Sigma - sum of all elements
∑(1,2,3) => 6

# Square root
√ 49 => 7.0

How difficult was this to implement? Keep reading!

    # Be sure to run with the "-Ku" flag!
    module Kernel
       alias λ proc
    
       def ∑(*args)
          sum = 0
          args.each{ |e| sum += e }
          sum
       end
    
       def √(root)
          Math.sqrt(root)
       end
    end

Pretty tricky, eh?

Just remember the “-Ku”. :) 


# 　第15章　交互式Ruby Shell
<kinder:note> 这一章在第四版为18章。
## 　　15.1　命令行

    irb [irb-option] [ruby_script] [program arguments]

表格15.1 irb命令行选项

    --back-trace-limit n       显示最顶部和尾部的n项回溯信息，默认值为16
    --context-mode n           :CONTEXT_MODE is describd later on page 259.
    -d                         设置#DEBUG为true（和ruby -d一样）         
    -E enc                     等同于ruby -E选项
    -f                         禁止读取～/.irbrc
    -h, --help                 显示使用信息。        
    -I directories             指定$LOAD_PATH目录
    --inf-ruby-mode            设置irb以Emacs的inf-ruby-mod模式运行，更改提示符并废止readline。
    --inspect                  使用Object#inspect来格式化输出（默认方式，除数学模式外）
    --noinspect                不使用inspect进行输出
    --irb_debug n              将内部调试级别设置为n（只对irb的开发有用）
    -m                         数学模式（支持分数和矩阵）
    --noprompt                 不显示提示符
    --prompt prompt-mode       切换提示符。预定义的模式包括null, default, classic, simple, xmp, inf-ruby
    --prompt-mode prompt-mode  同 -prompt
    -r module                  同ruby -r
    --readline                 使用Readline扩展模块
    --noreadline               不使用Readline扩展模块
    --sample-book-mode         使用简单提示符
    --simple-prompt            使用简单提示符
    --single-irb               Nested irb sessions will all share the same context.
    --tracer                   显示命令执行的跟踪
    -U                         等同于ruby -U选项。
    -v, --version               输出irb的版本号

通常你在运行irb时并不指定任何选项，但如果你希望运行一个脚本并实时查看每一步记录，可以指定ruby脚本的名称，以及该脚本的选项。

**提示符**
开始执行之后，irb显示一个提示符（下面的例子显示当前的绑定、行号、缩进级别）并等待输入。
irb包括一个ruby解析器，因此它知道语句尚未结束，这是提示符会变成一个星号。
可以通过键入exit或quit，或者通过输入文件结束符（如果没有设置`IGNORE_EOF`模式）来退出irb。

    % irb
    irb(main):001:0>  1 + 2
    => 3              
    irb(main):002:0>  3 +
    irb(main):003:0*  4
    => 7              
    irb(main):004:0>  quit
    %

**工作区**
在irb会话中，你所做的工作在irb工作区（workspace）中累积起来。
你设置的变量、定义的方法和创建的类，都被记忆下来并可以被后续使用。

    irb(main):001:0> def fib_up_to(n)
    irb(main):002:1>   f1, f2 = 1, 1
    irb(main):003:1>   while f1 <= n
    irb(main):004:2>     puts f1
    irb(main):005:2>     f1, f2 = f2, f1+f2
    irb(main):006:2>   end
    irb(main):007:1> end
    => nil
    irb(main):008:0> fib_up_to(4)
    1
    1
    2
    3
    => nil

注意第七行后面返回nil，是定义方法和运行方法的结果。这个方法输出Fibonacci数列，然后返回nil。

**用irb体验刚编写的代码**
可能你想追踪一个bug，或者只是想把玩一下。
如果你将程序加载到irb中，就可以创建它定义的类别的实例，并调佣其方法。

    $ cat code/fib_up_to.rb
    def fib_up_to(max)
      i1, i2 = 1, 1
      while i1 <= max
        yield i1
        i1, i2 = i2, i1+i2
      end
    end
    $ irb
    ruby 2.0 > load 'code/irb/fibonacci_sequence.rb'
    => True
    ruby 2.0 > fibonacci_sequence.first(10)
    => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]

注意这个实例中，使用load而不是require，将文件包含到我们的会话中。
load允许我们多次加载同一个文件。这样如果我们发现了一个bug，可以编辑文件，重新加载到irb会话中来。
### 15.1.1 Tab补齐
Tab补齐是以一个扩展库来实现的，即irb/completion。
当调用irb时，可以从命令行加载它`$ irb -r irb/completion`
还可以在irb运行时加载补齐库：

    irb(main):001:0> require 'irb/completion'
    => true

如果你总是使用tab补齐，最便捷的方式可能是将require命令放在.irbrc文件中。

加载之后，你在irb提示符后键入表达式，在词的中间键入Tab键，会显示一个选择
这在输入方法名等内建名称时相当有用。
如果你在irb中定义了一个类，当你想要调用它的方法时，tab补齐也有效。

### 15.1.2 子会话
irb支持多个、并发的会话。键入irb会创建一个子会话
当前会话只有一个：其他的在激活之前处于休眠状态。
键入jobs会列出所有会话，fg会激活一个特定的休眠会话。
### 15.1.3 子会话的绑定
创建子会话时指定了一个对象，它会成为绑定self的值。
没有指明接收者的方法会被该对象执行。
这是体验对象的一种便捷方式。

    ruby 2.0 > self
      => main
    ruby 2.0 > irb "wombat"
    ruby 2.0 > self
      => "wombat"
    ruby 2.0 > upcase
      => "WOMBAT"
    ruby 2.0 > size
      => 6
    ruby 2.0 > gsub(/[aeiou]/, '*')
      => "w*mb*t"
    ruby 2.0 > irb_exit
      => #<IRB::Irb: @context=#<IRB::Context:0x000001009dc4d8>, ...
    ruby 2.0 > self
      => main
    ruby 2.0 > upcase
    NameError: undefined local variable or method `upcase' for main:Object
        from (irb):4
        from /Users/dave/.rvm/rubies/ruby 2.0/bin/irb:17:in `<main>'

## 　　15.2　配置
### 15.2.1 初始化文件
irb运行时，会加载初始化文件：~/.irbrc .irbrc irb.rc $irbrc
初始化文件中，可以运行任意ruby代码。还可以设置配置项的值。
具体配置变量见后面15.2.4节 -- 初始化文件中使用的值是符号。使用这些符号来设置散列表IRB.conf中的值。例如：

    IRB.conf[:PROMPT_MODE] = :SIMPLE

配置irb一个有趣的技法是，基于上下文动态地改变配置。
可以将`IRB.conf[:IRB_RC]`设置为一个Proc对象。在irb上下文有所变动时，调用这个Proc
例如：

    IRB.conf[:IRB_RC] = lambda do |conf|
      leader = " " * conf.irb_name.length    # <kinder:note> 定义空白长度
      conf.prompt_i = "#{conf.irb_name} --> "
      conf.prompt_s = leader + ' \-" '
      conf.prompt_c = leader + ' \-+ '
      conf.return_format
      = leader + " ==> %s\n\n"
      puts "Welcome!"
    end

使用该.irbrc文件的会话，看起来如下：

    $ irb
    Welcome!
    irb --> 1 + 2
        ==> 3
    irb --> 2 +
        \-+ 6
        ==> 8

### 15.2.2 扩展irb
因为你在irb中键入的内容被当作ruby代码来解释，可以通过定义新的顶层方法来扩展irb。
例如你可能希望能在irb查询某个类或者方法的参考文档。可以在.irbrc文件中添加下面的ri方法：

    def ri (*name)
      system(%{ri #{names.map {|name| name.to_s}.join{" "}})
    end

下一次启动irb时，就能使用这个方法得到参考文档
第四版的例子：
For example, you may want to time how long certain things take. 
比如，你可能想看完成某项工作的时间。
You can use the measure method in the Benchmark library to do this, but it’s more convenient to wrap this in a helper method.
你可以使用Benchmark库的measure方法来完成，但在一个辅助方法中包装它会更方便。
Add the following to your .irbrc file:
将下面的代码添加到.irbrc文件中。

    def time(&block)
      require 'benchmark'
      result = nil
      timing = Benchmark.measure do
        result = block.()
      end
      puts "It took: #{timing}"
      result
    end

The next time you start irb, you’ll be able to use this method to get timings:
下次启动irb，你将能使用这个方法来计时。

    ruby 2.0 > time { 1_000_000.times { "cat".upcase } }
    It took: 0.320000 0.000000 0.320000 ( 0.323104)
    => 1000000

### 15.2.3 交互式配置
直接在提示符后面键入配置即可：

    ruby 2.0 > 1 +
    ruby 2.0 > 2
    => 3
    ruby 2.0 > conf.prompt_mode = :SIMPLE
    => :SIMPLE
    >> 1 +
    ?> 2
    => 3

### 15.2.4 irb的配置选项
下面的描述中，
`:XXX`的标记表示初始化文件中IRB.conf散列表内所使用的键。
`xxx`表示可以在交互中设置的值。
`[x]`表示该选项的默认值。

    AUTO_INDENT / auto_indent_mode   [true] 

如果为真，irb将会在你输入嵌套结构时进行缩进。
<kinder:note> 第二版这一选项默认为false。

    :BACK_TRACE_LIMIT / back_trace_limit   [16] 

显示回溯的起始和结束n行。

    :CONTEXT_MODE  [3] 

对新工作区使用的绑定：
0 - 顶层的Proc
1 - 绑定于一个加载的、匿名文件中
2 - 每个线程绑定于一个加载的文件
3 - 绑定于一个顶层的函数

    :DEBUG_LEVEL / debug_level    [0]

将内部的调试级别设置为n。
只有当你调试irb的词法分析器(lexer)时才有用。

    :IGNORE_EOF / ignore_eof     [false]

指定当输入接收到文件结尾时irb的行为。如果为真，它会被忽略；否则，irb将退出。

    :IGNORE_SIGINT / ignore_sigint   [true] 

如果为假，则^C (Ctrl+c)将会退出irb。
如果为真，则输入中途按下^C (Ctrl+c)将会取消输入并放回顶层；执行时，^C (Ctrl+c)会取消当前操作。

    :INSPECT_MODE / inspect_mode    [nil]

指定如何显示值：
true，使用inspect
false，使用`to_s`
nil，在非数学模式下使用inspect，数学模式下使用`to_s`

    :IRB_RC   [nil] 

可以被设置为一个Proc对象，当一个irb会话或子会话开始时被调用。

    last_value       [...]

第二版表示为`conf.last_value`
irb输出的最后一个值。

    :LOAD_MODULES / load_modules     [[]]

通过-r命令行选项加载模块的列表。

    :MATH_MODE / math_mode      [false]

如果为真，irb运行所加载的mathn库（2版详见692页，4版768页），且不使用inspect来显示值。

    prompt_c  [依赖配置]

连接语句的提示符（例如，在if之后立即显示）。

    prompt_i  [依赖配置]

标准、顶层提示符。

    :PROMPT_MODE / prompt_mode    [:DEFAULT]

提示符的显示风格。

    prompt_s  [依赖配置]

连续字符串的提示符。

    :PROMPT

参见195页的配置提示符。2版4版261页。

    :RC / rc  [true]

如果为false，不加载初始化文件

    return_format  [依赖配置]

显示交互中输入表达式结果的格式。

    :SAVE_HISTORY / save_history    [nil]

The number of commands to save between irb sessions.
irb会话中保存命令的数量。

    :SINGLE_IRB    [nil]

如果为true，嵌套的irb会话会共享相同的绑定；
否则根据`:CONTEXT_MODE`的值创建一个新的绑定。

    thread   [当前进程]

当前执行Thread对象的只读引用。

    :USE_LOADER / use_loader    [false]

指定是否使用irb自己的文件读取方法来进行load/require。
Specifies whether irb’s own file reader method is used with load/require.

    :USE_READLINE / use_readline  [依赖配置]

如果存在，irb使用readline库(参见后面2版723页4版795页)；
除非给选项被设置为false，此时readline永远不会使用；
如果为nil，readline不会在inf-ruby-mod中使用。

    :USE_TRACER / use_tracer    [false] 

如果为true，跟踪语句的执行。

    :VERBOSE / verbose     [true]

理论上，该选项为true时会打开附加的跟踪；但实践中没有输出什么额外的跟踪结果。

## 　　15.3　命令

    eixt; quit; irb_exit; irb_quit

退出irb会话或者子会话。如果使用了cb更改了绑定，则从绑定模式退出

    conf; context; irb_context

显示当前配置。
通过调用conf方法可修改配置。
例如，要将默认的提示符设置为服从性的含义。可以使用：

    irb(main):001:0> conf.prompt_i = "Yes, Master? "
    => "Yes, Master? "
    Yes, Master? 1 + 2


    cb; irb_change_bingding <obj>

创建并进入一个新的绑定，它有自己的局部变量范围。如果提供了obj，将作为新绑定中的shelf

    irb <obj>

开始一个irb子会话。如果提供了obj，会被用作self。

    jobs; irb_jobs

列出irb的子会话。

    fg n; irb_fg n

切换到指定的irb子会话。
n可以是：irb的子会话号；线程ID，irb对象，当子会话开始时的self对象。

    kill n; irb_kill n

杀死一个irb子会话。n的可能值和fg描述的一样。
### 15.3.1 配置提示符
提示符的集合保存在提示符散列表IRB.conf[:PROMPT]中。
如果要建立一个名为`MY_PROMPT`新的提示符：

    IRB.conf[:PROMPT][:MY_PROMPT] = {    # name of prompt mode
      :PROMPT_I => '-->',                # normal prompt
      :PROMPT_S => '--"',                # prompt for continuing strings
      :PROMPT_C => '--+',                # prompt for continuing statement
      :RETURN => " ==>%s\n"              # format to return value
    }

定义完，必须通知irb来使用它：`irb --prompt my-promt`
或者将它作为默认的提示符：`IRB.conf[:PROMPR_MOD] = :MY_PROMPT`

`PROMPT_T` `PROMPT_S` `PROMPT_C`指定了每个提示符字符串的格式。
在格式化字符串中，特定的%序列会被展开：
%N  当前命令
%m  主对象（self）`to_s`的结果
%M  主对象（self）inspect的结果
%l  分隔符类型。在多行的字符串中，%l显示用来开始字符串的分隔符类型，这样你知道如何结束它。分隔符是 " ' / ] ` 中的一个。
%ni  缩进级别。可选数字n用来作为printf的宽度规格。例如printf("%nd")
%nn  当前的行号（n用作缩进级别）
%%   字面的百分号。
例如：默认的提示符模式定义如下：

    IRB.conf[:PROMPT][:DEFAULT] = {
      :PROMPT_I => "%N(%m):%03n:%i> ",
      :PROMPT_S => "%N(%m):%03n:%i%l ",
      :PROMPT_C => "%N(%m):%03n:%i* ",
      :RETURN   => "=> %s\n"
    }


### 15.3.2  Saving Your Session History 保存会话历史
If you have readline support in irb (that is, you can hit the up arrow key and irb recalls the previous command you entered), then you can also configure irb to remember the commands you enter between sessions. 
如果你的irb支持realine支持（就是，你按了向上键，irb将显示你之前键入的命令），你也可以配置irb记住会话里面你所输入的命令的数量。
Simply add the following to your .irbrc file:
只需将下列语句添加到你的.irbrc文件中。

    IRB.conf[:SAVE_HISTORY] = 50 # save last 50 commands

## 　　15.4　限制  <kinder:note> 这一章已经在第四版被删除
因为irb的工作方式，和标准的ruby解释器稍有不同。问题在于**局部变量的判定**。

ruby解释器的表现：
通常ruby查看赋值语句来判定某个名称是否为一个变量-- 如果一个名字没有被赋值过，则假定该名字是一个方法的调用:

    eval "var = 0"
    var
    # produces:
    # prog.rb:2: undefined local variable or method `var'
    # for main:Object (NameError)

irb的表现：

    irb(main):001:0> eval "var = 0"
    0
    irb(main):002:0> var
    0

如果将irb的代码放在begin/end对中，irb的表现就会和解释器的一致

    irb(main):001:0> begin
    irb(main):002:1*
    eval "var = 0"
    irb(main):003:1> var
    irb(main):004:1> end
    NameError: undefined local variable or method `var'
    (irb):3:in `irb_binding'

## 　　15.5　rtags与xmp   <kinder:note> 这一章已经在第四版被删除
### rtags
rtags是一个用来创建Emacs或vi所使用的TAGS文件的工具。

    rtags [-vi][files]

默认的，rtag创建一个使用Emacs所使用TASS（参见etags.e1）。
-vi选项生成适用vi使用的TASS文件。
rtags的安装方式和irb相同（也就是，需要把irb安装到库路径中，创建一个由irb/rtag.rb到bin/rtags的链接）
### xmp
irb的xmp是一个示例(example)打印程序，在运行时现实每个表达式的值。很想我们为格式化本书示例所编写的脚本。
在irb归档中也有另一个独立的xmp。
使用如下：

    require 'irb/xmp'
    xmp <<END
    artist = "Doc Severinsen"
    artist.upcase
    END
    # produces:
    # artist = "Doc Severinsen"
    #    ==> "Doc Severinsen"
    # artist.upcase
    #    ==> "DOC SEVERINSEN"

或者xmp可以作为一个对象实例。以这种方式使用，xmp对象维护调用之间的上下文。

    require 'irb/xmp'
    x = XMP.new
    x.puts 'artist = "Louis Prima"'
    x.puts 'artist.upcase'
    # produces:
    # artist = "Louis Prima"
    #    ==> "Louis Prima"
    # artist.upcase
    #    ==> "LOUIS PRIMA"

可以用任何形式明确地提供一个绑定，否则xmp使用调用者的环境。

    xmp code_string, abinding
    XMP.new(abinding)

注意xmp不支持多线程。

# 　第16章　文档化Ruby
RDoc的功能
从1.8开始，Ruby内建了RDoc工具，可以提取并格式化嵌套在ruyb源代码文件中的文档。
该工具被用来为ruby内建的类和模块生成文档。
不断增长的库和扩展也使用这种方式来写文档。
<kinder:note> 第四版注释：
RDoc isn’t the only Ruby documentation tool. Those who like a more formal, tag-based scheme might want to look at Yard at http://yardoc.org.

RDoc也不只是ruby文档工具。那些喜欢更正式、基于标签的设计的人可能想看看Yard。
RDoc做两件事：
第一，它分析ruby和c源文件，以及其他格式如Markdown等文档，以寻找需要文档化的信息。
第二，它把得到的这些信息转化为某种方便阅读的格式。

RDoc可以生成两种格式的输出：HTML和ri。

在浏览器窗口以HTML格式输出的RDoc。
RDoc解析源代码以提取主要元素（类、模块、方法、属性等等）。 即使源代码没有任何内部文档，RDoc仍旧从中提取出信息：
在侧边是：文件、父类、类、方法列表。
在主板是：名称、属性、方法等等。
通过在文件中的元素前添加注释快，可以为该元素添加额外的文档。
不太明显的一点，RDoc会检测出注释中超链接的可能性。这是RDoc的关键特性。

RDoc也可以生成能被ri命令行工具识别的文档。

    $ ri Counter
    ---------------------------------------- Class: Counter
          Implements a simple accumulator, whose value is
          accessed via the attribute counter. Calling the
          method Counter#inc increments this value.
    -------------------------------------------------------
    Class methods:
          new
    Instance methods:
          inc
    Attributes:
          counter
    ----------------------------------------------------------------- Counter#inc
          inc()
    -----------------------------------------------------------------------------
          increment the current value of the count

ruby发行版中内建的类和模块（以及某些库）都是用这种方式来建立文档的。
<kinder:note> 第四版注释：如果你使用rvm，你需要运行`rvm docs generate`。

    $ ri Proc
    Proc < Object
    (from ruby core)
    ------------------------------------------------------------------------------
    Proc objects are blocks of code that have been bound to a set of local
    variables. Once bound, the code may be called in different contexts and still
    access those variables.
      def gen_times(factor)
        return Proc.new {|n| n*factor }
      end
      times3 = gen_times(3)
      times5 = gen_times(5)
      times3.call(12) #=> 36
      times5.call(5) #=> 25
      times3.call(times5.call(4)) #=> 60
    ------------------------------------------------------------------------------
    Class methods:
      new
    Instance methods:
        ===, [], arity, binding, call, curry, hash, inspect, lambda?, parameters,
        source_location, to_proc, to_s, yield ==
    
**页面列表**
⇡New in 2.0⇣
Many projects include README files, files containing usage notes, Changelogs, and so on.
许多项目包含了README文件，包含用法注意、更改日记等等。
RDoc automatically finds and formats these. It calls the result a page. You access the list of available pages from ri using the name of the project and a colon:
RDoc自动找到这些文件并进行格式化。它调出一个结果页面。你可以使用ri加后缀冒号的项目名称，来查看可用页面列表：

    $ ri ruby:
    Pages in ruby core
    
    ChangeLog
    NEWS
    README
    README.EXT
    : :

To read a particular page, add its name after the colon:
要读取一个特定的页面，在冒号之后添加名字即可。

    $ ri ruby:NEWS
    NEWS for Ruby 2.0.0

## 　　16.1　向Ruby代码中添加RDoc
通过在元素前添加注释快，可以为该元素添加额外的文档。
注释块可以很自然地书写：或者在连续的注释行前加#，或者把注释放到`=begin rdoc... =end`块中。
在文档注释中，段落中的行有相同的左边距，缩进超过此空白部分的文本被逐字格式化。
`_word_ *word* +word+`将分别以斜体、粗体、印刷体来显示其中的词。
如果想处理多个词或者含有非词字符的文本，可以用`<em>multiple words</em><b>more words</b><tt>yet more words</tt>`。
反斜线加入到内嵌的标记前将使得标记不被解释。
如果RDoc发现注释行以#--开头，则停止处理注释。这可以用来区分外部注释和内部注释，或者禁止将注释关联到方法、类或者模块上。#++开头的行重新打开文档处理功能。
例如：

    # Extract the age and calculate the
    # date of birth.
    #--
    # FIXME: fails if the birthday falls on February 29th, or if the person
    # was born before epoch and the installed Ruby doesn't support negative time_t
    #++
    # The DOB is returned as a Time object.
    #--
    # But should probably change to use Date.

### 16.1.1 超链接
以下划线或减号作前缀的类名、源代码文件以及任何方法名都会自动把注释文本转化成指向它们描述的链接。
以http:,mailto:,ftp:和www:开始的网络链接也能被识别。引用外部图像文件的HTTP URL将被转换成内嵌的`<IMG ...>`标记。
以link:开头的链接被认为是引用本地文件，且其路径是当对于当前操作路径的相对路径。
超链接也是label[url]形式，在这种情况下，label是被显示的文本，而url是被链接的目标。如果label含有多个词，可以放在花括号中：`{two words}[url]`。
### 16.1.2 列表
列表是缩进的段落，且带有：
- 一个 * 或者 - （用于无序列表）；
- 后跟着一个点的数字（用于编号列表）；
- 后跟着一个点的大写或小写字母（用于字母列表）。
注意一个列表项中后续的行要缩进和第一行对齐。

带有标签的列表（描述列表）使用放括号将标记括起，或者在标记后加两个冒号。

如果主体文本的开头和标记在同一行，则开头的位置决定主体文本剩余部分的缩进量。
主体文本也可从标记的下一行开始，并从标记的开头缩进。这常用在标记比较长的情况。例如：

    # <tt>--output</tt> <i>name [, name]</i>::
    #     specify the name of one or more output files. If multiple
    #     files are present, the first is used as the index.
    #
    #  <tt>--quiet:</tt>:: do not output the names, sizes, byte counts,
    #                      index areas, or bit ratios of units as
    #                      they are processed.

### 16.1.3 标题和水平线
以等号开头。等号个数多，标题的级别越高。
三个或更多的连字符表示水平线。
### 16.1.4 文档修饰符
方法的参数列表将被提出来和方法的描述一块显示。
如果一个方法调用yield，那么传递给yield的参数也将被显示出来。
例如：

    def fred
      # ...
      yield line, address

将产生文档：
fred() {|line, address| ... }
当方法定义在同一行时，使用含有:yield:的注释，可以改变这种默认行为：
例如：

    def fred # :yields: index, position
      # ...
      yield line, address

将获得如下文档：
fred() {|index, position| ... }

这里的`:yield:`就是一个文档修饰符的例子。
它们紧跟在所修饰的文档元素后面，并与文档元素在同一行上。
#### :nodoc:[all]
不要在文档中包含这个元素。
对于类和模块，直接处于其中的方法、别名、常量和属性也不会出现在文档中。
但默认在其中定义的模块或者类仍将被文档化。可以使用all关闭这个默认行为。
下面的例子，只有SM::Input被文档化。

    module SM #:nodoc:
      class Input
      end
    end
    module Markup #:nodoc: all
      class Output
      end
    end

#### :doc:
强制文档化方法或者属性，否则将不被文档化。
如果你想把一种特殊的私用方法放到文档中的话，这会很有用。
#### :notnew:
仅适用于initialize实例方法。
通常RDoc认为一个类的#initialize方法的文档和参数实际上对应的是new方法，并构造一个new方法。
这个修饰符将阻止RDoc这么做。
注意#initialize是被保护的方法，所以你不会看到它的文档，除非使用-a命令行选项。
#### :call-seq:lines...
当生成文档时，持续到下一空白注释行的文本被认为是对调用序列（略过对方法参数列表的解析）的解释。
即使某一行以#开头也被认为是空白行。对此指令而言，开头的冒号可以省略。
<kinder:note> 调用序列？？？
#### :include:filename
添加指定文件的内容到此处。
RDoc将从-include命令行选项列出的目录列表中搜索文件。
默认在当前目录搜索。
文件的内容将移动到和这个修饰符的`:`具有相同的缩进。
#### :title:text
设置文档的标题。
等价于--title命令行参数（命令行参数会覆盖源代码中任意的:title:修饰符）
#### :main:name
等价于--main命令行参数，设置此文档的初始显示页面。
#### :stopdoc: /:startdoc:
停止和开始添加新文档元素到当前容器。
例如：类中含有一些你不想为止添加文档的常量，那么可以把:stopdoc:放到第一个常量前，把:startdoc:放到最后一个常量前。
如果直到容器结束都没有:startdoc:，那么整个类或者模块都不被文档化！  
#### :enddoc
在当前词汇级别，不再为后面的任何东西做文档。

完整例子见后面19.4

## 　　16.2　向C扩展中添加RDoc
<kinder:note> 读了这一章才发现ruby真是优雅！哈哈。c代码太烦人了。
RDoc也能理解很多用C为ruby写扩展的惯例。
**`Init_Classname`的方法**
大多数C扩展有一个`Init_Classname`的方法。RDoc认为这是类的定义--`init_function`之前的任何C注释都被当作该类的文档。
`Init_function`通常用来关联C函数和Ruby方法名。比如，Cipher扩展可能会定义一个名为salt=的ruby方法，该方法通过调用以下函数来由C函数`salt_set`实现的。

    rb_define_method(cCipher, "salt=", salt_set, 1);

RDoc会解析此调用，添加salt=方法到类文档中，然后搜索函数`salt_set`的C源代码。如果该函数前面有注释，那么RDoc会用该注释作为salt=方法的文档。
<kinder:note> 不懂！
除了在函数的注释中写普通文档之外，这种基本模式不需要任何其他额外负担即可工作。
**Ruby方法的调用序列和call-seq**
然而RDoc不能识别相应的Ruby方法的调用序列。在这个例子中，RDoc仅会显示一个名为arg1的参数。你可以通过在函数注释中使用call-seq指令解决这个问题。call-seq后面的行（直到空行）被用来文档化方法的调用序列。

    /*
     * call-seq:
     * cipher.salt = number
     * cipher.salt = "string"
     *
     * Sets the salt of this cipher to either a binary +number+ or
     * bits in +string+.
     */
    static VALUE
    salt_set(cipher, salt)
    ...

如果方法返回一个有意义的值，则应当用call-seq中的字符`->`后面的串来注释。

    /*
     * call-seq:
     * cipher.keylen    -> Fixnum or nil
     */

**Document-class:和Document-method:**
尽管在为简单的e扩展寻找类和方法注释时RDoc能以启发式的方式工作良好，但对较复杂的扩展实现它却不能总是做到运行正确。这时你可以使用Document-class:和Document-method:指令来指明一个C注释分别和给点的类或者方法想关联。这两个修饰符以被注释的ruby类或方法的名字作为参数。

    /*
     * Document-method: reset
     *
     * Clear the current buffer and prepare to add new
     * cipher text. Any accumulated output cipher text
     * is also cleared.
     */

**不同C源文件中的C函数**
最后，我们也可在`Init_xxx`函数中将ruby方法与处于不同C源文件中的C函数相关联。
但必须通过rb_define_method方法调用添加注释来指明包含函数定义的文件。
下面的例子告诉RDoc到名为md5.c的文件中去找与md5方法相对应的函数（以及相关文档）。

    rb_define_method(cCipher, "md5", gem_md5, -1); /* in md5.c */

## 　　16.3　运行RDoc

    $ rdoc [options] [filenames ...]

最新选项列表可以看`$ rdoc --help`

在生成任何输出之前，将先对文件进行解析，并收集它们所含有的信息。这样就可以处理所有文件之间的交叉索引。
如果文件是一个目录，那么会遍历其含有的所有文件。如果没有提供文件名，那么会处理当前目录及其子目录的所有ruby文件。
典型用法是为ruby源代码包生成文档。

`$ rdoc`
这个命令会为当前目录及其子目录内所有的ruby源文件和C源文件生成HTML文档。这些文档会被存储在doc/子目录下的文档树中。

RDoc使用文件后缀名来确定如何处理每个文件。
名字以rb和rbw结尾的文件被认为是ruby源文件。以c结尾的文件被当作C文件。
其他文件被认为只含有标记（有或者没有#开头的注释标记）
如果目录名被传给RDoc，那么只递归扫描其中的C和Ruby源文件。
假若想包含像README这样的非源码文件到文档分析流程中，需要在命令行中显式给出文件名。
**.document**
写ruby库时，常常会有一部分源代码文件实现了公共接口，但大多数文件仅为内部使用，可以在项目目录下创建一个.document文件，RDoc仅处理该文件列出的文件。
该文件的每一行可以是文件名、目录名或者是一个通配符。
**:include: README**
有些项目通常在顶层的README文件中查找文档。以RDoc格式编写此文件，并用:include:指令包含它到主类中是一种很方便的做法。

### 16.3.1 为ri创建文档
RDoc可以创建能被ri命令显示的文档。
当你运行ri时，默认情况下它会到3个地方搜索文档：
1. system文档目录：其中含有ruby发布版自带的文档，它们是在安装ruby时创建的。
2. site目录：其中含有本地添加的系统范围内的文档。
3. 用户的目录：存储在每个用户自己的主目录中。
你可以使用RDoc的-op选项后用ri的--oc-dir选项覆盖默认目录位置。

你可以在这样找到这3个目录：

    $ ri --list-doc-dirs
    /Users/dave/.rvm/rubies/ruby-2.0.0-p0/share/ri/2.0.0/system
    /Users/dave/.rvm/rubies/ruby-2.0.0-p0/share/ri/2.0.0/site
    /Users/dave/.rdoc

为了添加文档到ri，需要告诉RDoc使用哪个输出目录。
自己用的话，用ri选项最方便了：`$ rdoc --ri file1.rb file2.rb`
想安装到系统范围：`$ rdoc --ri-site file1.rb file2.rb`

--ri-system选项通常仅用来为ruby内建类和标准库安装文档。可以从Ruby源代码发行版中重新创建这些文档：

    $ cd ruby source base/lib
    $ rdoc --ri-system

##     19.4 Ruby source file documented with RDoc

    # This module encapsulates functionality related to the
    # generation of Fibonacci sequences.
    #--
    # Copyright (c) 2004 Dave Thomas, The Pragmatic Programmers, LLC.
    # Licensed under the same terms as Ruby. No warranty is provided.
    module Fibonacci
      # Calculate the first _count_ Fibonacci numbers, starting with 1,1.
      #
      # :call-seq:
      # Fibonacci.sequence(count) -> array
      # Fibonacci.sequence(count) {|val| ... } -> nil
      #
      # If a block is given, supply successive values to the block and
      # return +nil+, otherwise return all values as an array.
      def Fibonacci.sequence(count, &block)
        result, block = setup_optional_block(block)
        generate do |val|
          break if count <= 0
          count -= 1
          block[val]
        end
        result
      end
      # Calculate the Fibonacci numbers up to and including _max_.
      #
      # :call-seq:
      #
      Fibonacci.upto(max)
      -> array
      #
      Fibonacci.upto(max) {|val| ... }
      -> nil
      #
      # If a block is given, supply successive values to the
      # block and return +nil+, otherwise return all values as an array.
      def Fibonacci.upto(max, &block)
        result, block = setup_optional_block(block)
        generate do |val|
          break if val > max
          block[val]
        end
        result
      end
      private
      # Yield a sequence of Fibonacci numbers to a block.
      def Fibonacci.generate
        f1, f2 = 1, 1
        loop do
          yield f1
          f1, f2 = f2, f1+f2
        end
      end
      # If a block parameter is given, use it, otherwise accumulate into an
      # array. Return the result value and the block to use.
      def Fibonacci.setup_optional_block(block)
        if block.nil?
          [ result = [], lambda {|val| result << val } ]
        else
          [ nil, block ]
        end
      end
    end

##     19.5 C source file documented with RDoc

    #include "ruby.h"
    #include "cdjukebox.h"
    static VALUE cCDPlayer;
    static void cd_free(void *p) { ... }
    static VALUE cd_alloc(VALUE klass) { ... }
    static void progress(CDJukebox *rec, int percent) { ... }
    /* call-seq:
     * CDPlayer.new(unit) -> new_cd_player
     *
     * Assign the newly created CDPlayer to a particular unit
     */
    static VALUE cd_initialize(VALUE self, VALUE unit) {
      int unit_id;
      CDJukebox *jb;
      Data_Get_Struct(self, CDJukebox, jb);
      unit_id = NUM2INT(unit);
      assign_jukebox(jb, unit_id);
      return self;
    }
    /* call-seq:
     * player.seek(int_disc, int_track) -> nil
     * player.seek(int_disc, int_track) {|percent| } -> nil
     *
     * Seek to a given part of the track, invoking the block
     * with the percent complete as we go.
     */
    static VALUE cd_seek(VALUE self, VALUE disc, VALUE track) {
      CDJukebox *jb;
      Data_Get_Struct(self, CDJukebox, jb);
      jukebox_seek(jb, NUM2INT(disc), NUM2INT(track), progress);
      return Qnil;
    }
    /* call-seq:
     * player.seek_time -> Float
     *
     * Return the average seek time for this unit (in seconds)
     */
    static VALUE
    cd_seek_time(VALUE self)
    {
      double tm;
      CDJukebox *jb;
      Data_Get_Struct(self, CDJukebox, jb);
      tm = get_avg_seek_time(jb);
      return rb_float_new(tm);
    }
    /* Interface to the Spinzalot[http://spinzalot.cd]
     * CD Player library.
     */
    void Init_CDPlayer() {
      cCDPlayer = rb_define_class("CDPlayer", rb_cObject);
      rb_define_alloc_func(cCDPlayer, cd_alloc);
      rb_define_method(cCDPlayer, "initialize", cd_initialize, 1);
      rb_define_method(cCDPlayer, "seek", cd_seek, 2);
      rb_define_method(cCDPlayer, "seek_time", cd_seek_time, 0);
    }

## 　　16.4　显示程序用法信息
<kinder:note> 这一节在第四版已被删去。
大多数命令行程序用某种工具来显示它们的正确用法：如果收到不合法的参数，会报告一个简短的错误信息，后跟着实际选项的概要。
如果你使用RDoc，可能已经在主程序开始处的RDoc注释中描述了如何使用程序。你可以用RDoc::usage直接从注释命令中将这些信息提取出来显示，而不用在程序某个地方用puts重复这些信息。
可以传递一些字符串参数给RDoc::usage。
如果有参数，则它只从注释块中提取以参数命名的小节（该小节以和参数相同的字符串做标题，忽略大小写）。
如果没有字符串参数，那么RDoc::usage将显示整个文档。
RDoc::usage在显示完用法信息后会立即终止程序。
如果RDoc::usage的第一个参数是一个整数，将作为程序的返回码（否则会返回0错误码）。
如果你不想在显示用法信息后退出程序，调用`RDoc::usage_no_exit`。

Figure 16.7. Sample program using RDoc::usage 范例程序

    # == Synopsis
    #
    # Display the current date and time, optionally honoring
    # a format string.
    # 
    # == Usage
    # 
    #     ruby showtime.rb [ -h | --help ] [ -f | --fmt fmtstring ]
    # 
    # fmtstring::
    #   A +strftime+ format string controlling the
    #   display of the date and time. If omitted,
    #   use <em>"%Y-%M-%d %H:%m"</em>
    # 
    # == Author
    # Dave Thomas, The Pragmatic Programmers, LLC
    # 
    # == Copyright
    # Copyright (c) 2004 The Pragmatic Programmers.
    # Licensed under the same terms as Ruby.
    
    require 'optparse'
    require 'rdoc/usage'
    
    fmt = "%Y-%M-%d %H:%m"
    opts = OptionParser.new
    opts.on("-h", "--help") { RDoc::usage }
    opts.on("-f", "--fmt FMTSTRING") {|str| fmt = str }
    opts.parse(ARGV) rescue RDoc::usage('usage')
    puts Time.now.strftime(fmt)


RDoc:usage使用RI环境变量，该变量可以设置显示宽度和输出风格。

# 　第17章　用RubyGems进行包的管理
<kinder:note> 这一章在第四版中被删除，并入前面的`ruby和ruby世界一章。
详见15.5 15.6两节。
## 　　17.1　安装RubyGems
## 　　17.2　安装程序Gems
## 　　17.3　安装和使用Gem库
## 　　17.4　创建自己的Gems
# 　第18章　Ruby与Web
ruby对Internet并不陌生。你不仅可以用ruby编写SMTP服务器，FTP守护进程或者Web服务器，还可以用ruby做一些更一般性的工作，例如用CGI编程或者替代PHP。
## 　　18.1　编写CGI脚本
一个简单的CGI脚本：

    #!/usr/bin/ruby
    print "Content-type: text/html\r\n\r\n"
    print "<html><body>Hello World! It's #{Time.now}</body></html>\r\n"

将这个脚本放到CGI目录中，加上执行权限，你就可以通过浏览器来访问它。（如果你的Web服务器并不自动添加头信息，你需要自己添加响应头信息。）

    #!/usr/bin/ruby
    print "HTTP/1.0 200 OK\r\n"
    print "Content-type: text/html\r\n\r\n"
    print "<html><body>Hello World! It's #{Time.now}</body></html>\r\n"

这种编程方式太底层了。需要编写自己的请求解析、会话管理、cookie操作、输出转义等等。幸运的是，有其他方式可以使它们更简单。
### 18.1.1 使用cgi.rb 
类CGI提供了编写CGI脚本的支持。使用它，你可以操作表单、cookie和环境；维护有状态的会话等等。
它是一个相当大的类。这里只快速浏览一下功能。
### 18.1.2 引用
**CGI.escape**
处理URL和HTML编码时，一定小心引用某些特定的字符。
如斜杠是路径名的一部分，URL查询部分的任何/必须要进行转义（转为%2F），使用它时再转回/。
空格和&字符也是特殊字符。
处理这种转化，CGI提供了CGI.escape和CGI.unescape两个例程（routine）：

    require 'cgi'
    puts CGI.escape("Nicholas Payton/Trumpet & Flugel Horn")
    # produces:
    # Nicholas+Payton%2FTrumpet+%26+Flugel+Horn

**CGI.escapeHTML**
更常见的是，你可能想转义HTML特殊字符：

    require 'cgi'
    puts CGI.escapeHTML("a < 100 && b > 200")
    # produces:
    # a &lt; 100 &amp;&amp; b &gt; 200

**CGI.escapeElement**
更妙的是，你可以决定只对字符串中某个特定的HTML元素进行转义。

    require 'cgi'
    puts CGI.escapeElement('<hr><a href="/mp3">Click Here</a><br>','A')
    # produces:
    # <hr>&lt;a href=&quot;/mp3&quot;&gt;Click Here&lt;/a&gt;<br>

这里只有A元素被转义了；其他元素保持原样。
**un-版本**
这些方法都有一个un-版本恢复原来的字符串。

    require 'cgi'
    puts CGI.unescapeHTML("a &lt; 100 &amp;&amp; b &gt; 200")
    # produces:
    # a < 100 && b > 200

### 18.1.3查询参数
**HTML请求**
从浏览器到你应用的HTTP请求中可能包括参数，或者作为URL的一部分，或者将数据嵌入到请求体中。
因为在一个请求中相同名字的值可能会返回多次，因此处理这些参数是很复杂的。
例如：假定我们要编写一个人们为何喜欢Ruby的调查，表单如下：

    <html>
      <head>
        <title>Test Form</title>
      </head>
      <body>
        <p>
          I like Ruby because:
        </p>
        <form action="cgi-bin/survey.rb">
          <p>
            <input type="checkbox" name="reason" value="flexible" />
            It's flexible
          </p>
          <p>
            <input type="checkbox" name="reason" value="transparent" />
            It's transparent
          </p>
          <p>
            <input type="checkbox" name="reason" value="perlish" />
            It's like Perl
          </p>
          <p>
            <input type="checkbox" name="reason" value="fun" />
            It's fun
          </p>
          <p>
            Your name: <input type="text" name="name"/>
          </p>
          <input type="submit"/>
        </form>
      </body>
    </html>

当某人填写这个表单时，可能选择多种喜爱Ruby的原因。
CGI类提供了几种方式来访问表单数据。
首先，可以把CGI对象看作一个散列表，通过字段名索引并返回字段的值。

    require 'cgi'
    cgi = CGI.new
    cgi['name'] # => "Dave Thomas"
    cgi['reason'] # => "flexible"

但这对reason字段，只能看到多个值中的一个。可以通过使用CGI#params方法要求查看它们。params返回的值类似一个散列表，保存有请求的参数。
可以读写这个散列表（写操作可以让你修改与这个请求关联的数据）。注意，散列表中的每个值都是一个数组。

    cgi = CGI.new
    cgi.params           #  =>  {"name"=>["Dave Thomas"], "reason"=>["flexible",
                         #  ..  "transparent", "fun"]}
    cgi.params['name']   #  =>  ["Dave Thomas"]
    cgi.params['reason'] #  =>  ["flexible", "transparent", "fun"]

你可以使用`CGI#has_key?`来判断请求中是否包括某个特定参数。

    require 'cgi'
    cgi = CGI.new
    cgi.has_key?('name') # => true
    cgi.has_key?('age') # => false

#### 生成HTML
CGI包括大量的方法用来创建HTML。每个元素一个方法。
要启用这些方法，必须调用CGI.new创建一个CGI对象，传入需要的HTML标准级别。
在下面的例子中，我们使用html4。（<kinder:note> 第二版是html3）
为了让元素嵌套更容易写，这些方法将代码block作为其内容。
这些代码block应该返回一个String，作为该元素的内容。

    require 'cgi'
    cgi = CGI.new("html4") # add HTML generation methods
    cgi.out do
      cgi.html do
        cgi.head { cgi.title { "This Is a Test"} } +
        cgi.body do
          cgi.form do
            cgi.hr +
            cgi.h1 { "A Form: " } +
            cgi.textarea("get_text") +
            cgi.br +
            cgi.submit
          end
        end
      end
    end

虽然有趣，但这个生成HTML的方法还是相当费力的，并且可能在实践中也不多使用。
多数人倾向直接书写HTML，使用模板系统，或者使用应用框架，如rails（<kinder:note> 第二版为lowa）

### 模板系统 <kinder:note> 本节在第四版为20.3
模板系统可让你将应用的表示和逻辑分隔开来。好像所有用ruby编写Web应用的人都在同时编写模板系统：
<kinder:note> 第二版：RubyGarden的wiki列出了许多。 http://www.rubygarden.org/ruby?"HtmlTemplates
<kinder:note> 第四版：Vidar Hokstad在2008年列出了19种： http://www.hokstad.com/mini-reviews-of-19-ruby-template-engines.html

Also, remember to look at Builder if you need to generate XHTML or XML.
需要产生XHTML或者XML时也要记得Builder。

#### RDoc模板  <kinder:note> 第四版删除
RDoc文档系统含有一个非常简单的e模板系统，用来将它的XML文档产生HTML输出。
但这个模板系统并不使用传统的HTML或者XML标记，--因为它有意被用来产生许多不同格式的输出 --因此有RDoc模板标记的文件，可能不容易用传统的HTML编辑工具来编辑。

    require 'rdoc/template'
    HTML = %{Hello, %name%.
    <p>
    The reasons you gave were:
    <ul>
    START:reasons
        <li>%reason_name% (%rank%)
    END:reasons
    </ul>
    }
    data = {
      'name' => 'Dave Thomas',
      'reasons' => [
        { 'reason_name' => 'flexible', 'rank' => '87' },
        { 'reason_name' => 'transparent', 'rank' => '76' },
        { 'reason_name' => 'fun', 'rank' => '94' },
      ]
    }
    t = TemplatePage.new(HTML)
    t.write_html_on(STDOUT, data)
    # produces:
    # Hello, Dave Thomas.
    # <p>
    # The reasons you gave were:
    # <ul>
    #   <li>flexible (87)
    #   <li>transparent (76)
    #   <li>fun (94)
    # </ul>

向构造函数(TempaltePage.new)传入一个包含了要应用的模板的字符串(HTML)。然后将一个包含名字和值的散列表传入`write_html_on`方法(`t.write_html_on(STDOUT, data)`)。
如果模板包含%xxxx%序列，则查找散列表，而对应名字的xxx值就会被替换进去。
如果模板包含START:yyy，对应yyy的散列值被认为是一个散列数组，
在START:yyy和END:yyy之间的模板行重复应用于数组的每个元素。

模板还支持条件：如果散列表中有zzz的key，则IF:zzz和ENDIF:zzz之间的行会被包含到输出中。

#### Amrita    <kinder:note> 第四版删除
www.brain-tokyo.jp/research/amrita/rdocs/
Amrita是生成HTML文档的库，其模板本身也是有效的HTML。
这使得Amrita对现有HTML编辑器非常有好。还意味着Amrita模板也可以作为独立的HTML页面正常显示。

Amrita使用HTML元素的id标记来判断是否要替换。
如果对应给定名字的值是nil或false，HTML元素不会包含到输出结果中。
如果值是一个数组，它迭代对应的HTML元素

    equire 'amrita/template'
    include Amrita
    HTML = %{<p id="greeting" />
    <p>The reasons you gave were:</p>
    <ul>
      <li id="reasons"><span id="reason_name"></span>,
                        <span id="rank"></span>
    </ul>
    }
    data = {
      :greeting => 'Hello, Dave Thomas', :reasons => [
        { :reason_name => 'flexible', :rank => '87' },
        { :reason_name => 'transparent', :rank => '76' },
        { :reason_name => 'fun', :rank => '94' },
      ]
    }
    t = TemplateText.new(HTML)
    t.prettyprint = true
    t.expand(STDOUT, data)
    # produces:
    # <p>Hello, Dave Thomas</p>
    # <p>The reasons you gave were:</p>
    # <ul>
    #   <li>flexible, 87 </li>
    #   <li>transparent, 76 </li>
    #   <li>fun, 94 </li>
    # </ul>

##### erb/eruby
有很多包可以将ruby语句嵌入到其他形式的文档中，特别是HTML，通常这被成为eRuby。
eRuby存在很多不同的实现，包括erb和eruby。
eruby可以用gem安装，erb是纯ruby编写的，包含在标准发布中。
在HTML嵌入ruby是非常强大的概念--它基本上提供了同ASP JSP PHP对等的工具，但是具有ruby的全部能力。
###### 使用erb
erb通常被作为一个过滤器。
输入文本中的文本除了以下情况外，其他不会被更改。
表达式                   描述

    <% ruby code %>          执行分隔符之间的Ruby代码
    <%= ruby expresion %>    对ruby表达式求值，并用表达式的值替换序列
    <%# ruby code %>         忽略分隔符之间的ruby代码（对测试有用）
    % line of ruby code      由百分号开头的文本行被认为只包含ruby代码

调用erb：

    erb [options][document]

没有document参数，erubg将从标准输入中读取。
erb的选项如下：

    选项            描述
    -d              设置 $DEBUG 为真
    -E ext[:int]    Sets the default external/internal encodings设置默认外部/内部编码
    -K kcode        指定其他的编码系统。这选项在第二版出现。第四版被上面的-E替代
    -n              显示生成的Ruby脚本 (带行号)
    -r library      加载指定的库
    -P              不对以%开头的行进行erb处理
    -S level        设置安全级别
    -T mode         设置修剪模式(trim mode)
    -U              Sets default encoding to UTF-8 设置默认编码为UTF-8
    -v              打开细节信息模式
    -x              Displays resulting Ruby script显示生成的Ruby脚本。
                    <kinder:note> 第二版翻译为：显示结果的Ruby脚本。

一个例子：

    $ cat web/f1.erb
    % 99.downto(96) do |number|
      <%= number %> bottles of beer...
    % end
    $ erb f1.erb
    99 bottles of beer...
    98 bottles of beer...
    97 bottles of beer...
    96 bottles of beer...

erb是通过将输入改写为一个ruby脚本并执行该脚本来工作的。可以使用-n或者-x选项来查看生成的ruby脚本。

    $ erb -x f1.erb
    #coding:ASCII-8BIT
    _erbout = ''; 99.downto(96) do |number|
    _erbout.concat(( number ).to_s); _erbout.concat " bottles of beer...\n"
    ; end
    _erbout.force_encoding(__ENCODING__)

注意erb是如何构造字符串`_erbout`的，它包括来自模板的静态字符串，以及表达式的执行结果（本例中是a的值）。

###### 在代码中嵌入erb
So far we’ve shown erb running as a command-line filter. 
到现在我们已经显示了作为命令行过滤器运行的erb。
However, the most common use is to use it as a library in your own code. 
不过，最常见的用法是作为一个代码里面的库。
(This is what Rails does with its .erb templates.)
（这就是Rails的.erb模板做的东西）

    require 'erb'
    SOURCE =
    %{<% for number in min..max %>
      The number is <%= number %>
    <% end %>
    }
    erb = ERB.new(SOURCE)
    min = 4
    max = 6
    puts erb.result(binding)
    # produces:
    # The number is 4
    #
    # The number is 5
    #
    # The number is 6

Notice how we can use local variables within the erb template. 
注意我们在erb模板中怎么使用局部变量。
This works because we pass the current binding to the result method. 
它能工作，是因为我们将当前的binding传给了result方法。
<kinder:note> 这个binding是proc参数吗？
erb can use this binding to make it look as if the template is being evaluated in the context of the calling code.
erb可以使用这个binding让它看起来模板在被调用代码的环境里被赋值。
<kinder:note> ？？？

erb comes with excellent documentation: use ri to read it. 
erb还附带着优秀的文档：使用ri来读取。
One thing that Rails users should know is that in the standard version of erb, you can’t use the -%> trick to suppress blank lines. 
一件Rails用户知道的事是在标准版本的erb，你不能使用 -%> 来抑制空白行。
(In the previous example, that’s why we have the extra blank lines in the output.) 
（在之前的例子中，这就是为什么输出有额外的空行）
Take a look at the description of trim modes in the documentation of ERB.new for alternatives.
看看可选的ERB.new文档中修建模式的描述。

##### haml      <kinder:note> 第四版新增
Haml is a library that generates HTML documents from a template. 
Haml是一个从模板产生HTML文档的库。见http://haml-lang.com/
Unlike many other templating systems, Haml uses indentation to indicate nesting (yup, just like Python). 
不像其他模板系统，Haml使用缩进来指明嵌套（对，像Python）
For example, you can represent a <ul> in Haml using this:
比如，你可以这样来表示一个<ul>：

    %ul
      %li item one
      %li item two

Install Haml using this:
这样安装：

    $ gem install haml

The Haml input syntax is rich and powerful, and the example that follows touches on only a subset of the features. 
Haml输出的语法丰富有力，下面的例子只涉及一部分特性。
Lines starting with % get converted to HTML tags, nested in the output according to their indentation in the input. 
用%开始的行被转化为HTML标签，输出的嵌套按照输入中的缩进程度。
An equals sign means “substitute in the value of the Ruby code that follows.” 
等号意味着“替换为后面ruby代码的值”。
A minus sign executes Ruby code but doesn’t substitute the value in—our example uses that to look over the reasons when constructing the table.
减号执行Ruby代码，但不替换为该值-- 例子中当构建表格时，使用减号个来遍历reasons。

There are many ways of getting values passed in to the template. 
有很多方法可以得到传入模板中的数值。
In this example, we chose to pass in a hash as the second parameter to render. 
在这个例子中，我们选择传入一个散列表作为第二个参数来渲染。
This results in local variables getting set as the template is expanded, one variable for each key in the hash:
这导致当模板被扩展时，局部变量被设置，一个变量设置为散列表中的每个键。
例子：

    require 'haml'
    engine = Haml::Engine.new(%{
    %body
      #welcome-box
        %p= greeting
      %p
        As of
        = Time.now
        the reasons you gave were:
      %table
        %tr
          %th Reason
          %th Rank
        - for reason in reasons
          %tr
            %td= reason[:reason_name]
            %td= reason[:rank]
    })
    data = {
      greeting: 'Hello, Dave Thomas',
      reasons: [
        { reason_name: 'flexible', rank: '87' },
        { reason_name: 'transparent', rank: '76' },
        { reason_name: 'fun', rank: '94' },
      ]
    }
    puts engine.render(nil, data)

produces:
产生：

    <body>
      <div id='welcome-box'>
        <p>Hello, Dave Thomas</p>
      </div>
      <p>
        As of
        2013-05-27 12:31:30 -0500
        the reasons you gave were:
      </p>
      <table>
        <tr>
          <th>Reason</th>
          <th>Rank</th>
        </tr>
        <tr>
          <td>flexible</td>
          <td>87</td>
        </tr>
        <tr>
          <td>transparent</td>
          <td>76</td>
        </tr>
        <tr>
          <td>fun</td>
          <td>94</td>
        </tr>
      </table>
    </body>


### 18.1.4 在Apache中安装eruby <kinder:note> 第四版删除
如果你想在有一定访问量的Web站点中使用类似erb的页面生成技术，你可能要转换到使用eruby，它有较好的性能。
然后你可以配置Apache Web服务器自动使用eRuby来解析内嵌Ruby文档。和PHP的方式一样。
你可以用rhtml作为后缀创建内嵌Ruby的文件，然后配置Web服务器对这些文档运行eruby程序来产生想要的HTML输出。

为了在Apache Web服务器中使用eruby，需要执行下面步骤：
- 将eruby的二进制文件拷贝到cgi-bin目录中。
- 在http.conf中添加下面两行：

    AddType application/x-httpd-eruby .rhtml
    Action application/x-httpd-eruby /cgi-bin/eruby

- 如果需要，你还可以添加和替换DirectoryIndex指令，使其包括index.rhtml。
  这让你可以使用ruby来为没有index.html的目录建立目录列表。
  例如，下面的指令将内嵌Ruby脚本的rhtml，当目录中没有index.html或index.shtml时，作为候补。

    DirectoryIndex index.html index.shtml index.rhtml

当然，你也可以提供一个站点级别的Ruby脚本。

    DirectoryIndex index.html index.shtml /cgi-bin/index.rb

## 　　18.2　Cookies
Cookie是让web应用得以在用户机器上保存状态的一种方式。虽然让某些人皱眉头，cookie仍然是记忆会话信息的一种便捷（也是不可靠）的方式。
RubyCGI类为你处理加载和保存cookie。
你可以用CGI#cookies方法来访问与当前请求想关联的cookie
你可以通过CGI#out的cookie参数设置为单个cookie或cookie数组的引用，将cookie返回浏览器。
web/cookies.rb

    #!/usr/bin/ruby
    require 'cgi'
    COOKIE_NAME = 'chocolate chip'
    cgi = CGI.new
    values = cgi.cookies[COOKIE_NAME]
    if values.empty?
      msg = "It looks as if you haven't visited recently"
    else
      msg = "You last visited #{values[0]}"
    end
    cookie = CGI::Cookie.new(COOKIE_NAME, Time.now.to_s)
    cookie.expires = Time.now + 30*24*3600 # 30 days
    cgi.out("cookie" => cookie ) { msg }

### 18.2.1 会话
会话是一种持久化的特定web浏览器和请求之间的信息。
会话是由CGI::Session处理的。
它使用cookies但提供了一种更高层次的抽象。
使用cookies，会话模拟了一种类似散列表的行为，让你可以关联value和key。

与cookies不同，session将大部分数据保存在服务器，使用浏览器驻留的cookie简单地作为服务器端数据的唯一标识。
还可以选择会话的存储技术：保存在一般文件中，在Pstore(见后面719页的描述)中，内存中，甚至自己定义的存储中。

会话在使用之后应关闭，这可以确保它们的数据被写入到存储中。
当你最终完成一个会话之后，应该删除它。
web/session.rb

    require 'cgi'
    require 'cgi/session'
    cgi = CGI.new("html4")
    sess = CGI::Session.new(cgi, "session_key" => "rubyweb",
                                      "prefix" => "web-session.")
    if sess['lastaccess']
      msg = "<p>You were last here #{sess['lastaccess']}.</p>"
    else
      msg = "<p>Looks like you haven't been here for a while</p>"
    end
    count = (sess["accesscount"] || 0).to_i
    count += 1
    msg << "<p>Number of visits: #{count}</p>"
    sess["accesscount"] = count
    sess["lastaccess"] = Time.now.to_s
    sess.close
    cgi.out {
      cgi.html {
        cgi.body {
          msg
        }
      }
    }

上面代码使用了会话的默认存储机制：将持久化数据保存到默认的临时目录中（参见Dir.tmpdir）。文件名均以web-sesion.开头，同时以会话ID的散列值结尾。
更多信息见ri CGI:Session。

## 　　18.3　提升性能 <kinder:note> 第四版删除
与大部分的CGI程序一样，默认的配置是每访问cig-bin的一个页面，就启动一个新的ruby程序拷贝。这对机器的利用而言是很昂贵的。而且对Web访问者来说慢得极其痛苦。

Apache服务器通过支持可加载模块来解决这个问题。
一般来说，这些模块是动态加载的，并成为Web服务器运行进程的一部分--你不必一次又一次地衍生解释器进程来响应请求：Web服务器便是解释器。
因此我们有赖于`mod_ruby`，它是Apache的一个模块，将一个完整的ruby解释器链接到Apache服务器本身。
在安装和配置好之后，你可以运行ruby脚本，运行得比没有使用`mod_ruby`更快。你还可以利用它提供额外的功能（例如与Apache请求处理的紧密集成）。

不过，在请求之间解释器始终保存在内存中，它可能处理多个应用的请求。这些应用的库可能会产生冲突，你无法假定来自浏览器会话的请求序列都是由同一个解释器处理的——Apache使用内部的算法来分配处理程序进程。
使用FastCGI协议可以解决部分问题。这是一个有趣的hack，不只对ruby，对所有CGI类型的程序都适用。
它使用一个代理程序，通常作为Apache的一个模块。
请求到达时，这个代理会将它们转发到一个特定的、始终运行的进程，它像普通的CGI脚本那样进行响应。结果会返回给代理，然后发送会浏览器。
FsatCGI和运行`mod_ruby`有同样的优势，解释器总是在后台运行。对如何将请求分配被解释器，它还给了你更多控制。
你可以在http://www.fastcgi.com找到更多信息。
## 　　18.4　Web服务器的选择
ruby 1.8和之后的版本都捆绑了WEBrick，一个灵活的、纯ruby的HTTP服务器工具。
基本上，它是一个基于插件的框架。让你可以编写服务器来处理HTTP请求及响应。

下面是一个基本的HTTP服务器，负责文档和目录的索引。
web/webrick1.rb

    #!/usr/bin/ruby
    require 'webrick'
    include WEBrick
    s = HTTPServer.new(Port: 2000,DocumentRoot: File.join(Dir.pwd, "/html"))
    trap("INT") { s.shutdown }
    s.start

HTTPServer构造函数在端口2000上创建了一个新的Web服务器。代码设置文档目录为当前目录下的html子目录。然后在服务器开始运行之前调用Kernel.trap，使其在遇到中断信号时，可以完整地关闭。

WEBrick不仅限于支持这种静态内容的服务。你可以像Java servlet容器那样使用它。
web/webrick2.rb

    #!/usr/bin/ruby
    require 'webrick'
    include WEBrick
    s = HTTPServer.new(Port: 2000)
    class HelloServlet < HTTPServlet::AbstractServlet
    def do_GET(req, res)
      res['Content-Type'] = "text/html"
      res.body = %{
        <html><body>
          <p>Hello. You're calling from a #{req['User-Agent']}</p>
          <p>I see parameters: #{req.query.keys.join(', ')}</p>
        </body></html>}
      end
    end
    s.mount("/hello", HelloServlet)
    trap("INT"){ s.shutdown }
    s.start

这个代码架设了地址为/hello的servlet。请求到达时，`do_Get`方法被调用。
它使用响应对象来现实用户的agent信息，以及请求中的参数。

##     20.6 Frameworks 框架 <kinder:note> 第四版新增
In reality, almost no one uses CGI to write web-based Ruby applications any more. 
现实中，几乎没人还会使用CGI来写基于web的Ruby应用程序。
Most of the real action these days is with frameworks. 
大部分情况会使用框架。
Frameworks abstract away all this low-level detail and also help you structure your code into something that is both easy to write and (probably more importantly) easy to maintain.
框架抽象出所有低水平细节，也能帮你构建易于书写和维护的代码。

At the time of writing, Ruby on Rails 3 is the leading web framework for Ruby. 
写这本书时，RoR3是最重要的ruby web框架。
It has an incredibly active community and a vast set of plug-ins, so the chances are good you’ll find a lot of preexisting code to help you kick-start your application. 
它有一个非常活跃的社区和非常大量的插件，所以运气不错，你会发现很多已存代码能够帮你创建应用。
Other alternatives include Camping, Padrino, Sinatra, and Ramaze4. 
其他可选方案还有Camping, Padrino, Sinatra, and Ramaze4. 
By the time you read this, the list will have grown.
等你读到这里时，这个清单该会增长了。

And, if you fancy writing your own framework, consider making it independent of the underlying web server by building it on top of Rack5.
如果你喜欢创建你自己的框架，可以考虑让它构建在Rack5的上面，独立于底层的web服务器。<kinder:note> 是这么翻译吗？

## 　　18.5　SOAP及Web Services  <kinder:note>第四版删除。
SOAP以前代表Simple Object Access Protocol（简单对象访问协议）。当人们无法忍受这种反讽，这种字母所写的解释被丢弃了，SOAP就只是个名字了。
ruby也提供了SOAP的一种实现。可以让你编写使用Web服务的服务器和客户端。
这些应用可以从本地或跨网络远程访问。
SOAP应用也不知道网络另一端使用何种语言实现，因此，SOAP是将ruby应用和其他语言编写的应用进行互联的一种便捷方式。

SOAP基本上一种列集(marshaling)机制，使用XML在网络的两个节点间发送数据。
它基本上被用来实现分布进程间的远程方法调用（RPC,Remote Procedure Call）。
SOAP服务器发布一个或多个接口。这些接口是由数据类型以及使用这些类型的方法所定义的。
然后SOAP客户端创建本地的代理，通过SOAP协议连接到服务器的接口。
对代理中方法的调用，会被传递到服务器对应的接口上。
服务器上方法产生的返回值通过代理传递回客户端。
### 一个例子：计算收益
最开始，它提供一个单独的方法，compound，给定本金、收益率、每年收益复利的次数和年数，算出复利收益。
为了达到管理的目的，我们跟踪这个方法调用了多少次，并通过访问方法让外界可以得到这个计数。
注意这个类就是一般的Ruby代码--它并不知道自己运行于SOAP环境中。

    class InterestCalculator
    attr_reader :call_count
      def initialize
        @call_count = 0
      end
      def compound(principal, rate, freq, years)
        @call_count += 1
        principal*(1.0 + rate/freq)**(freq*years)
      end
    end

#### SOAP服务器
现在我们让对象可以通过SOAP服务器来访问，这将让客户端程序能够通过网络调用对象的方法。
我们在这里使用独立的服务器，在测试时非常方便，因为我们可以从命令行启动它。
还可以将ruby SOAP服务作为CGI脚本或在`mod_ruby`之下运行。

    require 'soap/rpc/standaloneServer'
    require 'interestcalc'
    NS = 'http://pragprog.com/InterestCalc'
    class Server2 < SOAP::RPC::StandaloneServer
      def on_init
        calc = InterestCalculator.new
        add_method(calc, 'compound', 'principal', 'rate', 'freq', 'years')
        add_method(calc, 'call_count')
      end
    end
    svr = Server2.new('Calc', NS, '0.0.0.0', 12321)
    trap('INT') { svr.shutdown }
    svr.start

这段代码定义了一个类，实现了一个独立的SOAP服务器。
初始化时，这个类创建一个InterestCalculator对象。
然后使用`add_method`将这个类实现的两种方法compound和`call_count`加入到服务器中。<kinder:note> compound是个方法，可`call_count`是个变量啊。
最后，代码创建了服务器类的一个实例并运行。
构造函数的参数是应用的名字、默认的命名空间、接口使用的地址以及端口号。
#### SOAP客户端
客户端为服务器上的InterestCalculator服务创建一个本地代理，加入它想要使用的方法，然后调用它们。

    require 'soap/rpc/driver'
    proxy = SOAP::RPC::Driver.new("http://localhost:12321",
                                  "http://pragprog.com/InterestCalc")
    proxy.add_method('compound', 'principal', 'rate', 'freq', 'years')
    proxy.add_method('call_count')
    puts "Call count: #{proxy.call_count}"
    puts "5 years, compound annually: #{proxy.compound(100, 0.06, 1, 5)}"
    puts "5 years, compound monthly: #{proxy.compound(100, 0.06, 12, 5)}"
    puts "Call count: #{proxy.call_count}"

#### 测试SOAP
要测试，可以在一个终端端口运行服务器。

    % ruby server.rb
    I, [2004-07-26T10:55:51.629451 #12327] INFO -- Calc: Start of Calc.
    I, [2004-07-26T10:55:51.633755 #12327] INFO -- Calc: WEBrick 1.3.1
    I, [2004-07-26T10:55:51.635146 #12327] INFO -- Calc: ruby 1.8.2 (2004-07-26) [powerpc-darwin]
    I, [2004-07-26T10:55:51.639347 #12327] INFO -- Calc: WEBrick::HTTPServer#start: pid=12327 port=12321

在另一个窗口中运行客户端。

    % ruby client.rb
    Call count: 0
    5 years, compound annually: 133.82255776
    5 years, compound monthly: 134.885015254931
    Call count: 2
    % ruby client.rb
    Call count: 2
    5 years, compound annually: 133.82255776
    5 years, compound monthly: 134.885015254931
    Call count: 4

注意当我们第二次运行客户端时，调用次数从2开始。服务器创建了单独一个InterestCalculator对象来服务器进入的请求，且这个对象为每个请求所重用。

### 18.5.1 SOAP和Google
SOAP的真正好处是，可以和其他web服务交互。
下面的示例可以向Google的WebAPI发送查询。
#### 开发者密钥
http://www.google.com/apis
步骤2：创建一个Google帐号。
填写email地址，提供一个口令，Google会将一个开发者密钥发送给你。
将密钥保存在主目录的`.google_key`文件中。
#### 查看Google API方法doGoogleSearce文档
key            开发者密钥
q              查询字符串
start          结果起始的索引
maxResults     每次查询返回的最大结果个数
filter         如果开启，压缩结果，这样类似的页面或同一领域的页面只显示一次
restrict       限制搜索为Google Web索引的一个子集
safeSearch     如果开启，从结果中删除可能的成人内容
lr             限制搜索指定语言集合的文档
ie             忽略（输入编码）
oe             忽略y（输出编码）

#### 构造SOAP代理：
下面的示例向Google搜索单词pragmatic，打印返回的第一项：

    require 'soap/rpc/driver'
    require 'cgi'
    endpoint = 'http://api.google.com/search/beta2'
    namespace = 'urn:GoogleSearch'
    soap = SOAP::RPC::Driver.new(endpoint, namespace)
    soap.add_method('doGoogleSearch', 'key', 'q', 'start',
                    'maxResults', 'filter', 'restrict',
                    'safeSearch', 'lr', 'ie', 'oe')
    query = 'pragmatic'
    key = File.read(File.join(ENV['HOME'], ".google_key")).chomp
    result = soap.doGoogleSearch(key, query, 0, 1, false, nil,
                                false, nil, nil, nil)
    printf "Estimated number of results is %d.\n",
    result.estimatedTotalResultsCount
    printf "Your query took %6f seconds.\n", result.searchTime
    first = result.resultElements[0]
    puts first.title
    puts first.URL
    puts CGI.unescapeHTML(first.snippet)

输出：

    Estimated number of results is 550000.
    Your query took 0.123762 seconds.
    The <b>Pragmatic</b> Programmers, LLC
    http://www.pragmaticprogrammer.com/
    Home of Andrew Hunt and David Thomas's best-selling book 'The
    <b>Pragmatic</b> Programmer'<br> and The '<b>Pragmatic</b> Starter Kit
    (tm)' series. <b>...</b> The <b>Pragmatic</b> Bookshelf TM. <b>...</b>

#### 动态发现服务器上对象的接口
这是使用WSDL（Web Service Description Language）来完成的。
WSDL文件是一个XML文档，描述了一个web服务接口的类型、方法以及访问的机制。
SOAP客户端可以读取WSDL文件来自动创建访问服务器的接口。


Google在http://api.google.com/GoogleSearch.wsdl 发布了其接口的WSDL描述上。
可以修改上面的搜索应用来读取这个WSDL，消除了显式添加doGoogleSearch方法的需要：

    require 'cgi'
    WSDL_URL = "http://api.google.com/GoogleSearch.wsdl"
    soap = SOAP::WSDLDriverFactory.new(WSDL_URL).createDriver
    query = 'pragmatic'
    key = File.read(File.join(ENV['HOME'], ".google_key")).chomp
    result = soap.doGoogleSearch(key, query, 0, 1, false,
                                  nil, false, nil, nil, nil)
    printf "Estimated number of results is %d.\n",
            result.estimatedTotalResultsCount
    printf "Your query took %6f seconds.\n", result.searchTime
    first = result.resultElements[0]
    puts first.title
    puts first.URL
    puts CGI.unescapeHTML(first.snippet)

#### 使用Iab库
最后，我们可以使用Ian Macdonald的Google库（可以从RAA得到）。
它将Web服务API封装到一个漂亮的接口后面（原因无外是它消除了所有额外的参数）。
这个库还有方法来构造Google查询的数据范围和其他限制，并提供了Google缓存和拼写检查功能的接口。

    require 'google'
    require 'cgi'
    key = File.read(File.join(ENV['HOME'], ".google_key")).chomp
    google = Google::Search.new(key)
    result = google.search('pragmatic')
    printf "Estimated number of results is %d.\n",
            result.estimatedTotalResultsCount
    printf "Your query took %6f seconds.\n", result.searchTime
    first = result.resultElements[0]
    puts first.title
    puts first.url
    puts CGI.unescapeHTML(first.snippet)

## 　　18.6　更多信息  <kinder:note> 第四版删除
ruby的web编程是一个很大的课题。
要深入研究，你可能需要查看“The Ruby Way”（Ful01）的第9章。你可以在那里找到网络和Web编程的更多示例。
查看“The Ruby Developer's Guide”(FJN02)的第六章，可以在其中找到关于组织CGI应用的优秀示例，以及Iowa的一些示例代码。

如果SOAP让你感到复杂，可以考察使用XML-PRC，在后面757业有简略的描述。

web开发框架在网络上有很多。最热门的两个是：

    Rails（http://www.rubyonrails.org）
    CGIKit（http://www.spice-of-life.net/cgikit/index_en.html）

# 　第19章　Ruby Tk
**组合模型**
ruby应用程序归档（Application Archive）含有几个提供图形用户界面的扩展，包括对Fox，GTK及其他一些部件库（widget）的支持。
Tk扩展被集成到了ruby主发行版中，既可以运行在Unix上，也可以运行在Windows系统上。
要使用，需要在系统上安装Tk。Tk是一个很大的系统，而且有专门的书籍介绍它，所以这里介绍如何从ruby中访问Tk的特性。
你可能需要一本参考书以更有效地使用Tk和Ruby。我们使用的绑定（binding）和Perl绑定非常相近，所以你可能想搞到一本Learning Perl/Tk[Wal99]或者Perl/Tk Pocket Reference[Lid98]。
TK以一种组合模型（composition model）工作
--也就是说，你开始先创建一个容器（例如一个TKFrame或TkBoot），然后在其中创建部件（widget，GUI组件的另一种说法），例如按钮或者标签（label）。
当你准备启动GUI时，调用Tk.mainloop。最后Tk引擎会获得程序的控制权，显示各个部件并根据GUI时间调用相应的代码。

译注：截止至本书出版时，ruby 1.8.5 win版本的One-Click Installer安装之后，Tk可能无法正常运行。运行require "tk"可能会报告找不到DLL或其他错误信息。这似乎是此版本的一个bug，解决此问题的方法之一是安装ActiveTcl（www.activestate.com）
## 　　19.1　简单的Tk应用程序
在ruby中一个简单的Tk应用程序看起来如下所示：

    require 'tk'                      # 装载Tk扩展模块
    root = TkRoot.new { title "Ex1"}  # 创建一个根窗框
    TkLabel.new(root) do              # 创建一个TkLable作为子部件。
      text 'Hello, World!"
      pack('padx' => 15, 'pady' => 15, 'side' => 'left')  # 组装（pack）好根窗框。
    end
    Tk.mainloop  # 进入GUI主事件循环。

更简单的代码：

    require 'tk'
    TkLabel.new { text 'Hello, World!' ; pack }
    Tk.mainloop

Tk程序也不过如此而已！再来一本本章开头推荐的Perl/Tk专著，你就可以立即构建你所需要的高级GUI了。
## 　　19.2　部件
**创建部件很容易**
使用Tk文档中给出的部件的名字，并在其前面加‘Tk’即可。
如TkLabel TkButton TkEntry等。
像创建任何其他对象一样，使用new方法可以创建部件实例。
如果不为给定的部件指定一个父部件，那么父部件默认为根窗框。
通常我们需要指定父部件，以及其他一些选项--颜色、大小等等。
当程序运行的时候，我们也需要通过设定回调函数和共享数据从部件中取回信息。
### 19.2.1 设置部件选项
如果你看一下Tk参考手册，你会注意到部件的选项列表通常带一个连字符。
在Perl/Tk中，选项被传递给部件的一个Hash中。
也可以使用代码block来传递选项：在block中选项的名字被用作方法名，选项的参数作为方法的参数。
部件以父部件作为第一个参数，后跟可选选项hash或者可选的选项block。
第一种形式：

    TkLabel.new(parent_widget) do
      text 'Hello, World!'
      pack('padx' => 5,
            'pady' => 5,
            'side' => 'left')
    end

使用这种block形式时有一点需要注意：变量的作用域并不是你所想的那样。
block实际不是在调用者上下文而是在部件对象上下文中被处理的。
**这意味着不能在block中访问调用者的实例变量**，但可以访问外围作用域中的局部变量和全局变量。
第二种形式：

    TkLabel.new(parent_widget, 'text' => 'Hello, World!').pack(...)

距离的单位默认为像素，但可以使用不同的后缀来表示不同的单位：c（厘米），i（英寸），m（毫米）， p（像素）。

### 19.2.2 获取部件数据
使用回调函数和绑定变量，我们可以从部件中获取信息。
**回调函数**
回调函数很容易设置。command选项以Proc对象为参数，但回调函数被触发时，该对象将被调用。

    require 'tk'
    TkButton.new do
      text "EXIT"
      command { exit }
      pack('side'=>'left', 'padx'=>10, 'pady'=>10)
    end
    Tk.mainloop

在这里我们将与方法想关联的block作为传入的proc，但我们也可以使用Kernel.lambda来显式生成一个Proc对象。
**变量绑定**
我们还可以使用TkVariable代理，将某个Ruby变量绑定到Tk部件的值。
这样使得每当部件的值发生变量时，Ruby变量也会自动被更新。而当变量发生变化时，部件也会改变以反映新的值。

    require 'tk'
    packing = { 'padx'=>5, 'pady'=>5, 'side' => 'left' }
    checked = TkVariable.new   # 创建一个Tk变量的引用。
    def checked.status         # 根据checkbox是否选中，checked.status将返回0或1  
      value == "1" ? "Yes" : "No"
    end
    status = TkLabel.new do
      text checked.status
      pack(packing)
    end
    TkCheckButton.new do     # 多选框
      variable checked
      pack(packing)
    end
    TkButton.new do          # 按钮
      text "Show status"
      command { status.text(checked.status) }
      pack(packing)
    end
    Tk.mainloop

相同的机制也可应用到任意支持变量引用的Tk部件中，例如单按钮和文本域。

### 19.2.3 动态地设置/获取选项
**动态设置**
除了在创建部件时可以设置选项外，还可以在运行时重新配置部件。每个部件都支持configure方法，它和new一样，以一个Hash对象或者代码block作为参数。
例子：点击按钮时改变标签文本。

    require 'tk'
    root = TkRoot.new { title "Ex3" }
    top = TkFrame.new(root) { relief 'raised'; border 5 }
    lbl = TkLabel.new(top) do
      justify 'center'
      text
      'Hello, World!'
      pack('padx'=>5, 'pady'=>5, 'side' => 'top')
    end
    TkButton.new(top) do
      text "Ok"
      command { exit }
      pack('side'=>'left', 'padx'=>10, 'pady'=>10)
    end
    TkButton.new(top) do
      text "Cancel"
      command { lbl.configure('text'=>"Goodbye, Cruel World!") }  # 标签文本在这里改变。
      pack('side'=>'right', 'padx'=>10, 'pady'=>10)
    end
    top.pack('fill'=>'both', 'side' =>'top')
    Tk.mainloop

**动态获取**
也可以使用cget来查询部件的具体选项。

    require 'tk'
    b = TkButton.new do
      text
      "OK"
      justify "left"
      border 5
    end
    b.cget('text') →     "OK"   
    b.cget('justify') →  "left"
    b.cget('border') →   5


### 19.2.4 示例应用程序：pig latin生成器

    require 'tk'
    class PigBox                     # 转换词汇。
      def pig(word)
        leading_cap = word =~ /^[A-Z]/
        word.downcase!
        res = case word
          when /^[aeiouy]/
            word+"way"
          when /^([^aeiouy]+)(.*)/
            $2+$1+"ay"
          else
            word
        end
        leading_cap ? res.capitalize : res   # 首字大写
      end
      def show_pig                   # 调用方法然后显示结果
        @text.value = @text.value.split.collect{|w| pig(w)}.join(" ")
      end
      def initialize                 # 初始化
        ph = { 'padx' => 10, 'pady' => 10 }
        # common options
        root = TkRoot.new { title "Pig" }                      # 根窗框
        top = TkFrame.new(root) { background "white" }         # 框架
        TkLabel.new(top) {text 'Enter Text:' ; pack(ph) }      # 标签
        @text = TkVariable.new                                 # 绑定变量
        TkEntry.new(top, 'textvariable' => @text).pack(ph)     # 条目
        pig_b = TkButton.new(top) { text 'Pig It'; pack ph}    # pig按钮
        pig_b.command { show_pig }                             # 回调函数
        exit_b = TkButton.new(top) {text 'Exit'; pack ph}      # exit按钮
        exit_b.command { exit }                                # 回调退出
        top.pack('fill'=>'both', 'side' =>'top')               # 这个干嘛？
      end
    end
    PigBox.new
    Tk.mainloop

**布局管理（Geometry Management）**
部件方法pack是一个非常重要的方法调用 -- 不用它，你就见不到任何部件。
pack命令告诉布局管理器根据我们指定的条件来布局部件。

布局管理器能识别3个命令：
pack -- 灵活的，基于限制的位置
place -- 绝对位置
grid -- 表格（行/列）位置

## 　　19.3　绑定事件
我们的部件暴露在真实的世界中：点击、鼠标滑过，tab键遍历。
可以使用部件的bind方法创建一个从特定部件事件到代码block的绑定。
例如：显示图像的按钮部件。

    require 'tk'
    image1 = TkPhotoImage.new { file "img1.gif" }
    image2 = TkPhotoImage.new { file "img2.gif" }
    b = TkButton.new(@root) do
      image image1
      command { exit }
      pack
    end
    b.bind("Enter") { b.configure('image'=>image2) }   # 鼠标进入按钮时改变图像。
    b.bind("Leave") { b.configure('image'=>image1) }   # 鼠标离开按钮时改变图像。
    Tk.mainloop

在bind函数的参数中，事件的名字可以被短线分割为几个字串的组成部分，顺序为修饰符-修饰符-类型-细节（modifier-modifier-type-detail）
Tk参考中列出了修饰符，包括Button1,Control，Alt，Shift等等。
类型是事件的名字（使用X11中的命名传统），包括ButtonPress，KeyPress和Expose。
细节是1到5的按钮号，也可以是键盘输入的keysym。
例如按下control键并释放鼠标的button1时，触发的绑定可以记为：`Control-Button1-ButtonRelease`或者`Control-ButtonRelease`
事件本身可以含有一些域（field），如事件发生的事件、x和y的位置等。
bind可以使用event field code将这些信息传递给回调函数。使用方式类似printf规范。
例如：

    canvas.bind("Moniton", lambda {|x, y| do_motion(x, y)}, "%x %y")

## 　　19.4　画布
Tk提供了一个canvas部件，使用它可以绘制并生成PostScirpt输出。
例子：绘制直线的代码Figure 19.1. Drawing on a Tk Canvas

    require 'tk'
    class Draw
      def do_press(x, y)    # 按下
        @start_x = x
        @start_y = y
        @current_line = TkcLine.new(@canvas, x, y, x, y)
      end
      def do_motion(x, y)    # 移动
        if @current_line
          @current_line.coords @start_x, @start_y, x, y
        end
      end
      def do_release(x, y)   # 释放
        if @current_line
          @current_line.coords @start_x, @start_y, x, y
          @current_line.fill 'black'
          @current_line = nil
        end
      end
      def initialize(parent)   # 初始化
        @canvas = TkCanvas.new(parent)
        @canvas.pack
        @start_x = @start_y = 0
        @canvas.bind("1", lambda {|e| do_press(e.x, e.y)})
        @canvas.bind("B1-Motion",
                      lambda {|x, y| do_motion(x, y)}, "%x %y")
        @canvas.bind("ButtonRelease-1",
                      lambda {|x, y| do_release(x, y)},
                      "%x %y")
      end
    end
    root = TkRoot.new { title 'Canvas' }
    Draw.new(root)
    Tk.mainloop

## 　　19.5　滚动
TkCanvas, TkListbox, TkText都可以被设置成为使用滚动条。
滚动条和部件之间的通信是双向的。移动滚动条意味着部件视图将改变；而当通过其他方式改变部件视图时，滚动条也会相应地移动以反映新的位置。
例子：使用可滚动的文本列表。

    list_w = TkListbox.new(frame) do
      selectmode 'single'
      pack 'side' => 'left'
    end
    list_w.bind("ButtonRelease-1") do
      busy do
        filename = list_w.get(*list_w.curselection)
        tmp_img = TkPhotoImage.new { file filename }
        scale = tmp_img.height / 100
        scale = 1 if scale < 1
        image_w.copy(tmp_img, 'subsample' => [scale, scale])
        image_w.pack
      end
    end
    scroll_bar = TkScrollbar.new(frame) do
      command {|*args| list_w.yview *args }   # 这个回调函数将会调用列表部件的yview方法，该方法会改变列表y方向上可见部分的值。
      pack
      'side' => 'left', 'fill' => 'y'
    end
    list_w.yscrollcommand {|first,last| scroll_bar.set(first,last) }  # 建立逆向关联：当列表需要滚动时，使用set函数设置滚动条的适当范围。

### 19.5.1 完整示例：一个简单的GIF图像查看器
你曾见过创建了“忙光标”而忘记重置它的应用程序吗？
在ruby中有一个优雅的技巧可以避免此事情的发生。使用busy方法！

这个例子也演示了TkListbox的一些基本操作--向列表中添加元素，为鼠标按钮释放事件[3]添加回调函数，以及查询当前的选择。
[3] 因为只有当鼠标释放时才算作选中部件，所以你需要按钮释放事件而不是按下事件。

迄今为止，我们使用TkPhotoImage来直接显示图像，但你也可缩放、二次抽样或仅显示部分图像。这里我们使用二次抽样来缩小图像以便查看。

    require 'tk'
    class GifViewer
      def initialize(filelist)          # 初始化，调用预览方法
        setup_viewer(filelist)
      end
      def run                           # 运行
        Tk.mainloop
      end
      def setup_viewer(filelist)        # 预览
        @root = TkRoot.new {title 'Scroll List'}
        frame = TkFrame.new(@root)      ## 框架 
        image_w = TkPhotoImage.new      ## 图片
        TkLabel.new(frame) do           ## 图片标签
          image image_w
          pack 'side'=>'right'
        end
        list_w = TkListbox.new(frame) do        ## 列表箱
          selectmode 'single'
          pack 'side' => 'left'
        end
        list_w.bind("ButtonRelease-1") do       ## 列表绑定点击动作
          busy do
            filename = list_w.get(*list_w.curselection)
            tmp_img = TkPhotoImage.new { file filename }
            scale = tmp_img.height / 100
            scale = 1 if scale < 1
            image_w.copy(tmp_img, 'subsample' => [scale, scale])
            image_w.pack
          end
        end
        filelist.each do |name|
          list_w.insert('end', name) # Insert each file name into the list 在列表中插入每个文件名
        end
        scroll_bar = TkScrollbar.new(frame) do        ## 滚动条
          command {|*args| list_w.yview *args }
          pack
          'side' => 'left', 'fill' => 'y'
        end
        list_w.yscrollcommand {|first,last| scroll_bar.set(first,last) }
        frame.pack
      end
      # Run a block with a 'wait' cursor
      def busy                     # 忙碌处理
        @root.cursor "watch" # Set a watch cursor
        yield
      ensure
        @root.cursor "" # Back to original
      end
    end
    viewer = GifViewer.new(Dir["screenshots/gifs/*.gif"])
    viewer.run

## 　　19.6　从Perl/Tk文档转译
就是这么一回事，现在你可以独立了。
很大程度上，你可以很容易地将Perl/Tk文档转译为ruby文档。
但也有几个异常，某些方法没有实现，也可能某些额外的功能没有文档。
在ruby/tk书籍面世之前，最好在邮件列表中询问或阅读源代码。

但通常很容易看出端倪来。
记住选项可能以散列表的方式或者代码block的风格出现，并且代码block的作用域是在使用它的TkWidget内而不是在类的实例内。
### 19.6.1 对象创建
在Perl/Tk世界中，父部件负责创建子部件；
在ruby中，父部件被作为第一个参数传递给子部件的构造函数。

    Perl/Tk:  $widget = $parent->Widget( [ option => value ] )
    Ruby:     widget = TkWidget.new(parent, option-hash)
              widget = TkWidget.new(parent) { code block }

有时你可能不需要保存新建部件的返回值，如果需要，它就在那儿。
不要忘了布局部件（或者使用其他的几何位置函数），否则它将不会被显示出来。
### 19.6.2 选项
记住代码block的作用域是不同的。

    Perl/Tk: -background => color
    Ruby:    'background' => color
             { background color }

### 19.6.3 变量引用
使用TkVariable将一个ruby变量和一个部件的属性值关联起来。
然后可以使用TkVariable中的值访问方法（value和value=）来直接更改部件的内容。

    Perl/Tk: -textvariable => \$variable 
             -textvariable => varRef
    Ruby:    ref = TkVariable.new
             'textvariable' => ref
             { textvariable ref }

# 　第20章　Ruby和微软Windows系统
ruby运行在不同的环境中。ruby来自以Unix为中心的人，但这些年它也已经在Windows世界开发了许多有用的特性。
## 　　20.1　得到Ruby for Windows <kinder:note> 第四版删除了
## 　　20.2　在Windows下运行Ruby
你将发现有两个版本的ruby解释器在ruby安装器发行版中。

ruby用于命令行提示（DOS shell），这和Unix版本中的ruby可执行程序是一样的。
对于读写标准输入和输出的程序来说，是挺不错的。

但这也意味着，任何时候运行ruby，你都会得到一个DOS shell，即使你不需要它——Windows也会创建新的命令行提示窗口，并当ruby运行时显示它。
某些时候可能不是恰当的行为。比如，如果双击了使用图形界面接口的ruby脚本，或者以后台任务方式，或者从其他程序内部运行ruby脚本的时候。

在这些情况下，你可能希望使用rubyw。它和ruby一样，只是不会提供标准输入、标准输出或标准错误，并且运行时也不会启动DOS shell。

<kinder:note> 第二版：
安装程序会默认设置文件关联，让.rb后缀的文件自动使用rubyw。这样双击ruby脚本，它们只会运行程序而不会同时提示DOS shell。
<kinder:note> 第四版：
You can set up file associations using the assoc and ftype commands so that Ruby will auto- matically run Ruby when you double-click the name of a Ruby script:
你可以使用assoc和ftype命令来关联文件，这样双击ruby脚本时将会自动运行ruby。

    C:\> assoc .rb=RubyScript
    C:\> ftype RubyScript="C:\ruby1.9\bin\ruby.exe" %1 %*

You may have to run the command prompt with elevated privileges to make this work.
你可能必须用适当的特权运行命令提示符，才能让它运行起来。
To do this, right-click it in the Start menu, and select Run As Administrator.
在“开始”菜单右击，选择“作为管理员运行”即可。

If you don’t want to have to type the .rb, you can add Ruby scripts to your PATHEXT:
如果你不想输入.rb，你可以增加ruby脚本到你的PATHEXT:

    C:\> set PATHEXT=.rb;%PATHEXT%

## 　　20.3　Win32API
如果你计划要编写ruby程序，需要直接使用一些Windows32API函数，或者需要使用其他DLL中的某些入口函数（entry point），可以使用Win32API库。

作为一个例子，这里的代码来自于一个更大的Windows应用，我们的预约实施系统使用这个应用来下载并打印发票和收据。
web应用生成PDF文件，运行在Windows上的ruby脚本会把它下载到本地文件中。
脚本使用Windows中的shell命令print来打印这个文件。

    arg   = "ids=#{resp.intl_orders.join(",")}"
    fname = "/temp/invoices.pdf"
    site = Net::HTTP.new(HOST, PORT)
    site.use_ssl = true
    http_resp, = site.get2("/ship/receipt?" + arg,
                           'Authorization' => 'Basic ' +
                           ["name:passwd"].pack('m').strip )
    File.open(fname, "wb") {|f| f.puts(http_resp.body) }
    shell = Win32API.new("shell32","ShellExecute",
                           ['L','P','P','P','P','L'], 'L' )
    shell.Call(0, "print", fname, 0,0, SW_SHOWNORMAL)

这里创建了一个Win32API对象，它表示对特定DLL入口函数的调用，这是由函数名称、含有该函数的DLL名称以及函数原型特征（参数类型和返回类型）来指定的。
在前面的例子中，shell变量包装了shell32DLL中的ShellExecute这个Windows函数。
<kinder:note> 第二版：
它接受6个参数（1个数字，4个字符串指针和1个数字）并返回1个数字（这些参数类型将在755页描述）。我们也可以调用这个返回的对象去打印下载的文件。
<kinder:note> 第四版：
The second parameter is an array of characters describing the types of the parameters the method takes:
第二个参数是一个字符序列，描绘方法的参数类型：
 n and l represent numbers, i represent integers, p represents pointers to data stored in a string, and v represents a void type (used for export parameters only). 
n和l代表数字，i代表整数，p代表指向存储在字符串中的数据的指针，v代表一个有效类型（只用于导出参数）
These strings are case insensitive. 
这些字符串是不区分大小写的。
So, our method takes a number, four string pointers, and a number. 
所以，我们的方法有1个数字，4个字符串指针和1个数字。
The last parameter says that the method returns a number. 
最后一个参数说方法会返回一个数字。
The resulting object is a proxy to the underlying ShellExecute function and can be used to make the call to print the file that we downloaded.
返回的对象是一个潜在ShellExecute函数的代理，用于调用下载文件的打印。

DLL函数的许多参数是某种形式的二进制结构。Win32API通过使用Ruby的String对象来回传递这些二进制数据。
必要的话你需要对这些字符串打包和拆包（第二版：参见755页的例子）。

## 　　20.4　Windows 自动化
**WIN32OLE扩展**
如果对摆弄这些底层的WindowsAPI不感兴趣，也许你对Windows自动化有兴趣-- Masaki Suketa编写的一个称为WIN32OLE的ruby扩展，使得可以把ruby当作Windows自动化的一个客户程序来使用。WIN32OLE是标准ruby发行版的一部分。
windows自动化允许自动化控制器（即客户端程序）对自动化服务器发出命令和查询，自动化服务器可能是微软ExcelWordPowerpoint等等。
若要执行自动化服务器中的方法，可以通过从win32ole对象中调用相同名称的方法来实现。比如创建一个新的WIN32OLE客户程序，运行全新的IE拷贝，并命令它访问其主页。

    win32/gohome.rb
    require 'win32ole'
    ie = WIN32OLE.new('InternetExplorer.Application')
    ie.visible = true
    ie.gohome

也可以让它浏览特定的网页。

    win32/navigate.rb
    require 'win32ole'
    ie = WIN32OLE.new('InternetExplorer.Application')
    ie.visible = true
    ie.navigate("http://www.pragprog.com")

那些WIN32OLE不知道的方法（比如visible，gohome或navigate）会被传递到WIN32OLE#invoke方法，会将正确的命令发送给服务器
### 20.4.1 得到和设置属性
<kinder:note> 第四版的表述：
An automation server’s properties are automatically set up as attributes of the WIN32OLE object. 
自动服务器的属性被自动设置为WIN32OLE对象的属性。
This means you can set a property by assigning to an object attribute. 
这意味着你可以通过给对象属性赋值来设置属性。
For example, to get and then set the Height property of Explorer, you could write this:
例如，要得到和设置IE的高度属性，你可以这样写：
`win32/get_set_height.rb`

    require 'win32ole'
    ie = WIN32OLE.new('InternetExplorer.Application')
    ie.visible = true
    puts "Height = #{ie.Height}"
    ie.Height = 30

The following example uses the automation interface built into the OpenOffice suite to create a spreadsheet and populate some cells:
下面例子使用了OpenOffice套件内建的自动接口来创建一个表格并创建了一些单元格：
[1] See `http://udk.openoffice.org/common/man/tutorial/office_automation.html` for links to resources on automating OpenOffice.
`win32/open_office.rb`

    require 'win32ole'
    class OOSpreadsheet
      def initialize
        mgr = WIN32OLE.new('com.sun.star.ServiceManager')
        desktop = mgr.createInstance("com.sun.star.frame.Desktop")
        @doc = desktop.LoadComponentFromUrl("private:factory/scalc", "_blank", 0, [])
        @sheet = @doc.sheets[0]
      end
      def get_cell(row, col)
        @sheet.getCellByPosition(col, row, 0)
      end
      # tl: top_left 左上, br: bottom_right 右下
      def get_cell_range(tl_row, tl_col, br_row, br_col)
        @sheet.getCellRangeByPosition(tl_row, tl_col, br_row, br_col, 0)
      end
    end
    spreadsheet = OOSpreadsheet.new
    cell = spreadsheet.get_cell(1, 0)
    cell.Value = 1234   # <kinder:note> 这个值为什么在A2格？
    cells = spreadsheet.get_cell_range(1, 2, 5, 3)
    cols = cells.Columns.count
    rows = cells.Rows.count
    cols.times do |col_no|
      rows.times do |row_no|
        cell = cells.getCellByPosition(col_no, row_no)
        cell.Value = (col_no + 1)*(row_no+1)  # <kinder:note> 结果出现在B3:F4
      end
    end

<kinder:note> 第二版的表述：
使用普通的ruby散列表表示法可以从服务器中设置和取得属性。
比如为了在Excel图表中设置Rotation属性，可以这样写：

    excel = WIN32OLE.new("excel.application")
    excelchart = excel.Charts.Add()
    ...
    excelchart['Rotation'] = 45
    puts excelchart['Rotation']

OLE对象的参数作为WIN32OLE对象的属性会被自动设置。
这意味着可以通过对一个对象属性进行赋值来设置参数。

    excelchart.rotation = 45
    r = excelchart.rotation

下面的例子是修改后的示例文件excel.rb。
它先启动Excel，创建一个图表，然后在屏幕上旋转它：

     require 'win32ole'
     # -4100 is the value for the Excel constant xl3DColumn.
     ChartTypeVal = -4100;
     excel = WIN32OLE.new("excel.application")
     # Create and rotate the chart
     excel['Visible'] = TRUE
     excel.Workbooks.Add()
     excel.Range("a1")['Value'] = 3
     excel.Range("a2")['Value'] = 2
     excel.Range("a3")['Value'] = 1
     excel.Range("a1:a3").Select()
     excelchart = excel.Charts.Add()
     excelchart['Type'] = ChartTypeVal
     30.step(180, 5) do |rot|
       excelchart.rotation = rot
       sleep(0.1)
     end
     excel.ActiveWorkbook.Close(0)
     excel.Quit()

### 20.4.2 命名参数
其他自动化客户语言如Visual Basic有命名参数这个概念。
假设一个Visual Basic函数，它有如下标签：

    Song(artist, title, length):   rem Visual Basic

与顺序指定所有3个参数相反，可以使用命名参数来调用它：

    Song title := 'Get It On':   rem Visual Basic

这等同于调用Song(nil, 'Get It On', nil)。
在ruby中，可以通过传递带有命名参数的散列表来使用这个特性。

    Song.new('title' => 'Get It On')

### 20.4.3 for each
VB有‘for each’语句，对服务器中项（item）的收集（collection）进行迭代，WIN32OLE对象有each方法（接受一个代码块）去完成同样的事情：
win32/win32each.rb

    require 'win32ole'
    excel = WIN32OLE.new("excel.application")
    excel.Workbooks.Add
    excel.Range("a1").Value = 10
    excel.Range("a2").Value = 20
    excel.Range("a3").Value = "=a1+a2"
    excel.Range("a1:a3").each do |cell|
      p cell.Value
    end

### 20.4.4 事件
以ruby编写的自动化客户程序可以注册自己去接收其他程序的事件。这是使用`WIN32OLE_EVENT`类实现的。
这个例子（基于Win32OLE0.1.1发布的代码）演示了使用事件槽（event sink）记录用户使用IE浏览过的URLs：
`win32/record_navigation.rb`

    require 'win32ole'
    urls_visited = []
    running = true
      def default_handler(event, *args)
      case event
      when "BeforeNavigate"
        puts "Now Navigating to #{args[0]}..."
      end
    end
    ie = WIN32OLE.new('InternetExplorer.Application')
    ie.visible = TRUE
    ie.gohome
    ev = WIN32OLE_EVENT.new(ie, 'DWebBrowserEvents')
    ev.on_event {|*args| default_handler(*args)}
    ev.on_event("NavigateComplete") {|url| urls_visited << url }
    ev.on_event("Quit") do |*args|
      puts "IE has quit"
      puts "You Navigated to the following URLs: "
      urls_visited.each_with_index do |url, i|
        puts "(#{i+1}) #{url}"
      end
      running = false
    end
    # hang around processing messages
    WIN32OLE_EVENT.message_loop while running

### 20.4.5 优化
与大多数高级语言一样，在代码中可以非常容易掺杂进那些慢得让人无法忍受的代码，但只要稍加考虑，就会很容易解决它们。
使用WIN32OLE，需要当心那些不必要的动态查找（lookup）。

只要有可能，最好把WIN32OLE赋值给变量，然后使用它来引用其元素，而不是创建一长链的“.”表达式。
比如不要写：
可以通过把表达式前面部分保存到临时变量中，以去掉这些共同的子表达式，再从这个变量那儿进行调用。

    worksheet = workbook.Worksheets(1)
    worksheet.Range("A1").value = 1
    worksheet.Range("A2").value = 2
    worksheet.Range("A3").value = 4
    worksheet.Range("A4").value = 8

也可以为特定Windows类型库创建ruby存根（stub）。
这些存根把OLE对象包装到ruby类中。其中OLE对象中的每个入口函数都在该类中有一种对应的方法。在内部，存根方法使用入口函数的编号而不是它的名称，这加快了访问速度。

给出类型库的名称，使用olegen.rb脚本可以生成这个封装类。
脚本见：http://svn.ruby-lang.org/repos/ruby/trunk/ext/win32ole/sample/olegen.rb

    C:\> ruby olegen.rb 'Microsoft TAPI 3.0 Type Library' >tapi.rb

类型库的外部方法和事件会作为ruby方法写入到指定的文件中。
你可以把它包含在程序中，并直接调用这些方法。
<kinder:note> 下面被第四版删除：

    require 'benchmark'
    include Benchmark
    bmbm(10) do |test|                   # bmbm？
      test.report("Dynamic") do          # 动态的
        nm = WIN32OLE.new('NetMeeting.App.1')
        10000.times { nm.Version }
      end
      test.report("Via proxy") do        # 代理的
        nm = NetMeeting_App_1.new
        10000.times { nm.Version }
      end
    end
    # produces:
    # Rehearsal ---------------------------------------------
    # Dynamic   0.600000 0.200000 0.800000 ( 1.623000)
    # Via proxy 0.361000 0.140000 0.501000 ( 0.961000)
    # ------------------------------------ total: 1.301000sec
    # 
    #             user      system   total       real      
    # Dynamic     0.471000  0.110000 0.581000 (  1.522000)
    # Via proxy   0.470000  0.130000 0.600000 (  0.952000)

这个代理版本比执行动态查找的代码快出40%左右。

### 20.4.6 更多帮助
 
如果需要ruby访问WindowsNT 2000或XP的话，你可以看一下Daniel Berger的Win32Utils项目（http://rubyforge.org/projects/win32utils/）。
在那里会找到访问Windows剪贴板、事件日志、调度器等的模块。

另外Fiddle库（将在后面756页简单介绍。第二版名为DL库，后669页）允许Ruby程序调用动态装入的共享库（对象）中的方法。
在Windows上，这意味着ruby代码可以装入和调用WindowsDLL中的入口函数。
<kinder:note> 第二版表述：
比如，下面的代码取自标准Ruby发行版中的DL源码，它在Windows机器上弹出消息框，同时判断用户点击了哪个按钮：

    require 'dl'
    User32 = DL.dlopen("user32")
    MB_OKCANCEL = 1
    message_box = User32['MessageBoxA', 'ILSSI']
    r, rs = message_box.call(0, 'OK?', 'Please Confirm', MB_OKCANCEL)
    case r
    when 1
      print("OK!\n")
    when 2
      print("Cancel!\n")
    end
这段代码打开User32DLL，然后创建了`message_box`这个ruby对象，该对象包装了MessageBoxA的入口函数。第二个参数ILSSI声明这个方法会返回一个证书，同时接受一个Long，两个字符串和一个整数，作为它的参数。

<kinder:note> 第四版表述：
比如，下面的代码在Windows机器上弹出消息框，同时判断用户点击了哪个按钮：
win32/dl.rb

    require 'fiddle'
    user32 = DL.dlopen("user32.dll")
    msgbox = Fiddle::Function.new(user32['MessageBoxA'],
                                  [TYPE_LONG, TYPE_VOIDP, TYPE_VOIDP, TYPE_INT],
                                  TYPE_INT)
    MB_OKCANCEL = 1
    msgbox.call(0, "OK?", "Please Confirm", MB_OKCANCEL)

This code wraps User32 DLL, creating a Ruby method that is a proxy to the underlying MessageBoxA method. 
这段代码包装了User32 DLL，创建了一个ruby方法，用来代理背后的MessageBoxA方法。
It also specifies the return and parameter types so that Ruby can cor- rectly marshal them between its objects and the underlying operating system types.
它也指定了返回值和参数类型，方便ruby在它的对象和背后的操作系统类型之间正确地汇集它们。

这个包装（wrapper）对象被用来调用DLL中的消息框入口函数。
返回值是用户交互的结果（在本例中，它是用户按下按钮的标识符），以及传入参数的一个数组（我们忽略了它）。

# 　第21章　扩展Ruby 
<kinder:note> 第四版删除，但作为资料附录在网上，为2010年11月第一版。下面的内容以本书2版为基础，再参考本书4版网上的附录。
## 和底层系统打交道
用ruby编写代码来扩展ruby新的特性很简单。
但偶尔也需要和底层系统打交道。如果你用C编写的底层代码扩展Ruby，更有无限可能。
This chapter is about interfacing between Ruby and external libraries written in C.  
这一章是关于ruby和用C语言写的外部库之间的接口
Its audience is that rare group of people who write the interfaces that the rest of us use.  
受众是少数写接口的人。
Thanks to their work over the life of Ruby, there are interfaces to just about every low-level library that exists.
感谢他们的为ruby的声明而工作，很多接口是存在于低级库。

And, if such an interface doesn’t yet exist, there are options you should explore before reaching for a C compiler.  
而且，如果这样一个接口还没，有些选项你要探索，在得到C编译器之前。
You may be able to use the DL library to link dynamically to your external library.  
你可能有能力使用DL库来动态地连接到你的外部库。
You may be able to switch to (say) JRuby or IronRuby, and use their tight integration with the Java and .NET runtimes.  
你可能有能力转换到JRuby或IronRuby，并使用它们和Java和.NET运行时的紧密集成。
Or, you may be able to access the functionality you need via (say) a socket interface.  
或者，你可能有能力通过套接字接口来访问功能。
But, rarely, you may have to write a Ruby extension.
不过，很少时候，你可能只好写一个Ruby扩展。

用C扩展Ruby很简单。
例如，假定我们要我Sunset Diner的Grill定制一个支持Internet的点唱机。它可以从硬盘播放MP3音频文件，或者从CD唱机播放音乐CD。
我们希望能从Ruby程序控制点唱机硬件，硬件供应商为我们提供了C的头文件和要使用的二进制库；我们的工作是构造一个Ruby对象来调用适当的C函数。
本章的大部分信息是从ruby发布所包含的README.EXT文件中选取的。
如果你计划编写一个Ruby扩展，那么你可能需要参考该文件来获取更多的细节和最近的更新。

## 　　21.1　你的第一个扩展
**编写扩展代码**
这个扩展只是为了测试一个过程，并没有做什么无法单纯用Ruby来完成的事情。
我们要编写的扩展与下面的ruby类有相同的功能。

    class MyTest
      def initialize
        @arr = Array.new
      end
      def add(obj)
        @arr.push(obj)
      end
    end

换言之，我们要用C编写一个扩展，和上面的Ruby类做到插入兼容（plug-compatible）。
等价的C代码大概是：

    #include "ruby.h"    // 首先，需要包含头文件ruby.h获得所需的ruby定义
    static int id_push;   // 本书4版这里改为static ID id_push

    static VALUE t_init(VALUE self)
    {
      VALUE arr;
      arr = rb_ary_new();
      rb_iv_set(self, "@arr", arr);
      /*
      我们要做的第一件事是创建一个ruby数组，并设置让实例变量@arr来指向它。
      如果你编写的ruby代码引用一个不存在的实例变量，则会创建它，然后我们得到一个指针。
      */
      return self;
      /*
      警告：每个从Ruby调用的C函数必须返回一个VALUE，即使它只是Qnil；否则结果很可能是core dump（或GPF，General Protection Fault，一般性保护错误）
      */
    }
    /*
    虽说它没有参数，但其实有一个参数。
    除了所有ruby参数之外，每个方法会被传入一个初始的VALUE参数，其中包括该方法的接收者（receiver，等同于Ruby代码中的self）
    */

    static VALUE t_add(VALUE self, VALUE obj)
    {
      VALUE arr;
      arr = rb_iv_get(self, "@arr");
      rb_funcall(arr, id_push, 1, obj);
      return arr;
    }
    /*
    最后这个方法从当前对象得到实例变量@arr，并调用Array#push将传入的参数值存入数组。
    当以这种方式访问实例变量时，前缀@是必须的--否则变量虽可创建但无法从Ruby内引用。
    */

    VALUE cTest;
    void Init_my_test() {
    /*
    每个扩展都定义一个名为Init_name的C全局函数。
    这个函数在解释器第一次加载（或者静态链接）名为name的扩展时被调用。
    它被用来初始化扩展，并加入到Ruby环境中。（至于ruby如何知道扩展的名称是name，我们稍后再涉及。）
    本例中，我们定义了一个新的类MyTest，是Object（由外部符号rc_cObject表示；其他参见ruby.h）的子类。
    */
      cTest = rb_define_class("MyTest", rb_cObject);
      rb_define_method(cTest, "initialize", t_init, 0);
      rb_define_method(cTest, "add", t_add, 1);
      /*
      上面两行将add和initailize设置为MyTest的两个实例方法。
      调用rb_define_method会在Ruby方法名和实现它的C函数间建立一个绑定。
      如果ruby代码调用对象实例的add方法，解释器会调用C函数t_add，并传入一个参数。
      类似的，当调用该类的new方法时，ruby会构造一个基本的对象，然后调用initialize。这里定义了要调用C函数t_init，而没有（ruby类型的）参数。
      */      
      id_push = rb_intern("push");
    }

尽管C带来了额外和笨重的语法，你还是在使用Ruby来编写程序 -- 可以调用任何你知道和喜爱的方法来操作对象，得到的好处是在需要时能够手工编写紧凑且快速的e代码。

### 21.1.1 构建我们的扩展
 1. 在C源文件`my_test.c`的同一目录下，创建一个名为exconf.rb的文件：

    require 'mkmf'
    create_makefile("mytest")

 2. 运行extconf.rb，这会生成一个Makefile：

    $ ruby extconf.rb
    creating Makefile

 3. 使用make构建扩展。这是在Mac OS X系统中所产生的结果：

    % make
    gcc -fno-common -g -O2 -pipe -fno-common -I.
    -I/usr/lib/ruby/1.9/powerpc-darwin7.4.0
    -I/usr/lib/ruby/1.9/powerpc-darwin7.4.0 -I.
    -c my_test.c
    cc -dynamic -bundle -undefined suppress -flat_namespace
    -L'/usr/lib' -o my_test.bundle my_test.o -ldl -lobjc

构建这个扩展的所有结果，会被组装成一个共享库（一个.so、.dll或.bundle，在OS X上）

### 21.1.2 运行我们的扩展
我们可以简单地通过在运行时动态require来使用它（适用于大部分系统）。我们可以将它放到一个测试中，来验证它如我们预期地那样工作。

    require 'my_test'
    require 'test/unit'
    class TestTest < Test::Unit::TestCase
      def test_test
        t = MyTest.new
        assert_equal(Object, MyTest.superclass)
        assert_equal(MyTest, t.class)
        t.add(1)
        t.add(2)
        assert_equal([1,2], t.instance_eval("@arr"))
      end
    end
    # produces:
    # Finished in 0.002589 seconds.
    # 1 tests, 3 assertions, 0 failures, 0 errors

扩展可以正常工作，我们可以通过运行make install将它全部安装（install it globally）。

## 　　21.2　C中的Ruby对象
在操作ruby对象之前，我们需要找出如何从C表示和访问ruby的数据对象。
**ruyb如何在C中实现面向对象**
在ruby中一切皆对象，所有变量都是对象的引用。
大部分ruby对象，被表示为一个C指针，它指向了包括对象数据和其他实现细节的一块内存区域。
在C代码中，所有这些引用都是VALUE类型的变量，因此当你传递Ruby对象时，所传递的是VALUE。

例外的是，出于性能的原因，ruby将Fixnum、Symbol、true、false和nil实现为所谓的立即值（immediate value）。它们的值也保存在VALUE类型的变量中，但它们不是指针；相反它们的值直接保存在变量中。
因此某些时候VALUE是指针，而某些时候是直接值。

解释器如何实现这一魔法呢？
它依赖于这样的一个事实，所有指向某个内存区域的指针，都是4或8字节边界对齐的。
这意味着我们可以确保指针的低两位总是0.
当它想要储存一个立即值时，会安排至少将其中一位设置为1,其余的解释器代码可以将指针和直接值区别开来。
虽然这听起来非常诡谲，但实际上很容易在实践中使用，主要是因为解释器有很多宏和方法，来简化这个类型系统的处理。

这是ruyb如何在C中实现面向对象的代码：
Ruby对象是内存中分配的一个结构，包括了实例变量的表和有关这个类的信息。
类本身是另一个对象（也是内存中分配的结构），包括类的实例方法表。
ruby是在此基础上建立的。

<kinder:note> 嘿嘿，还是不懂。
### 21.2.1 操作直接对象 
Fixnum的值是一个31位的数字（或者在更广泛的CPU体系结构中可能是63位）。
它将原来的数字左移一位，并设置LSB（least significant bit，最低有效位，bit0）位1。
当VALUE被当作一个指针指向某个具体的ruby结构时，总能够保证LSB的值是0.其他直接值的LSB也为0。
因此，一个简单的位测试可以告诉你它是否是一个Fixnum。`FIXNUM_P`的宏包装了这个测试。类似的测试可以让你检查其他的直接值：

    FIXNUM_P(value) → 如果value是 Fixnum， 则非0
    SYMBOL_P(value) → 如果value是 Symbol， 则非0
    NIL_P(value)    → 如果value是 il， 则非0
    RTEST(value)    → 如果value是 nil 或 false， 则非0

下面的表格列出了若干有用的数字以及其他标准数据类型的转换宏。
Table 21.1. C/Ruby 数据类型转换函数和宏
C数据类型转换为 Ruby对象:

    INT2NUM(int)           → Fixnum 或 Bignum
    INT2FIX(int)           → Fixnum (速度较快)
    LONG2NUM(long          → Fixnum 或 Bignum
    LONG2FIX(int)          → Fixnum (速度较快)
    LL2NUM(long long)      → Fixnum or Bignum (如果本地
                           系统支持long long类型)
    ULL2NUM(long long)     → Fixnum or Bignum (如果本地
                           系统支持long long类型)
    CHR2FIX(char)          → Fixnum
    rb_str_new2(char *)    → String
    rb_float_new(double)   → Float

Ruby对象转换为C数据类型:


    int             NUM2INT(Numeric)               (包括类型检查)
    int             FIX2INT(Fixnum)                (速度较快)
    unsigned int    NUM2UINT(Numeric)              (包括类型检查)
    unsigned int    FIX2UINT(Fixnum)               (包括类型检查)
    long            NUM2LONG(Numeric)              (包括类型检查)
    long            FIX2LONG(Fixnum)               (速度较快)
    unsigned long   NUM2ULONG(Numeric)             (包括类型检查)
    char            NUM2CHR(Numeric or String)     (包括类型检查)
    double          NUM2DBL(Numeric)
                    关于字符串的部分请参见正文

其他的直接值（true false nil）在C中被分别表示为Qtrue Qfalse Qnil的常量。
你可以直接测试VALUE变量，或者使用转换宏（由它进行适当的转型）。

### 21.2.2 操作字符串
在C中，我们使用nul结尾的字符串。不过ruby字符串更一般化，可能包括若干内嵌的null。
因此，操作ruby字符串最安全的方式是，按照解释器所做的那样，同时使用指针和长度。实际上，Ruby的String对象是RString结构的一个引用，而RString结构包括指针和长度成员。你可以用RSTRING宏来访问这个结构。

    VALUE str;
    RSTRING(str)->len → ruby字符串的长度
    RSTRING(str)->ptr → 字符串的存储指针

然而，生活远比这复杂。
当你需要一个字符串值的时候，与其直接使用VALUE对象，还不如调用StringValue，并以原来的值作为参数。它会返回一个对象，你可以对其使用RSTRING宏，或如果它无法从原来的值得到一个字符串时，抛出异常。
这是Ruby1.8的duck typing[2]提案的一部分，在后面294页和365页有更详细的描述。
[2] 译注： 动态类型的术语，有两个含义：一是ruby避开了类型系统，二是说来自Dave Thomas的隐喻：如果某物走起来像鸭子，叫起来也像鸭子，那么就可以认为它是一只鸭子。
StringValue方法检查其操作数是否一个String，如果不是，则它尝试调用对象的`to_str`，如果调用失败则抛出一个TypeError异常。

因此，如果想编写迭代String对象中所有字符的代码，可以这样编写：

    static VALUE iterate_over(VALUE original_str) {
      int i;
      char *p
      VALUE str = StringValue(original_str);
      p = RSTRING(str)->ptr;
      // may be null
      for (i = 0; i < RSTRING(str)->len; i++, p++) {
      // process *p
      }
      return str;
    }

如果你想跳过长度信息，而只访问底层的字符串指针，你可以使用便捷方法StringValuePtr，它得到字符串的引用，然后返回指向其内容的C指针。

如果你想使用字符串来访问或控制某些外部资源，那么你可能希望钩入（hook）ruby的tainting机制中。
在本例中，你可以使用SafeStringValue方法，它像StringValue一样工作，但如果它的参数是tainted（不可信的）同时安全级别大于0的，则抛出一个异常。
<kinder:note> 不懂啊！

Pre-1.9 String Access
1.9 之前的字符串访问
Prior to Ruby 1.8.6, you’d access RSTRING fields directly to get the length and string data pointer. 
在1.8.6之前，你要直接访问RSTRING字段来得到长度和字符串数据指针。
So, how do you write an extension that works with either technique? 
所以，你怎么写一个扩展，和其中一个技巧一起工作？
Perhaps like this:
可能像这样：
#if !defined(RSTRING_LEN)
#  define RSTRING_LEN(x) (RSTRING(x)->len)
#  define RSTRING_PTR(x) (RSTRING(x)->ptr)
#endif

### 21.2.3 操作其他对象
当VALUE不是直接对象时，它们指向定义了Ruby对象结构的指针--你不能让VALUE指向任意内存区域。
基本内建类的结构在ruby.h中定义，命名为RClassname，例如RArray RBignum RClass RData RFile RFloat RHash RObject RRegexp RString RStruct。

有多种方式可以检查某个特定的VALUE是何种类型的结构。
宏TYPE(obj)会返回一个常量，表示给定对象的C类型：`T_OBJECT T_STRING`等。
内建类的常量在ruby.h中定义。
注意这里说的type是实现中的细节--和对象的类不同。

如果你想确保VALUE指针指向一个特定的结构，你可以使用宏`Check_Type`,如果value不是预期的type（`T_STRING T_FLOAT`这样的常量），则会抛出一个TypeError异常。

    Check_Type(VALUE value, int type)

Having said all this, you need to be careful about building too much dependence on checking types into your extension code.  
所有这些说过的，你需要消息构建太多的依赖来检查你的扩展代码的类型。
We have more to say about extensions and the Ruby type system on page 27.
我们有太多关于扩展和ruby类型系统的话要说，参见后面2版21.5节4版扩展附录27页。

再次，注意我们所说的type是表示某个特定内建类型的C结构。
对象的类是完全不同的另一种怪兽：内建类的class对象保存在名为`rb_cClassname`的C全局变量中（例如，`rb_cObject`），模块的命名为`rb_mModulename`。
直接更改这些C结构中的数据是不可取的，不过，你可以查看，但不要触动它们。
相反，你通常使用提供的C函数来操作Ruby数据（我们稍后将有更多讨论）。


然而，你可能有兴趣深入到这些结构中来得到数据。
要解引用（dereference）这些C结构的成员，你必须将一般化的VALUE转型为适当的结构类型。
ruby.h包含了许多宏为你执行适当的转型，让你可以很容易地对结构成员解引用。
<kinder:note> 2版的描述
这些宏的名称为RCLASSNAME，例如RSTRING或RARRAY。
我们已经在处理字符串时看到RSTRING的使用。你可以对数组使用相同的方式：

    VALUE arr;
    RSTRING(arr)->len  → ruby数组的长度
    RSTRING(arr)->capa → ruby数组的容量
    RSTRING(arr)->ptr  → 数组的存储指针

对散列表RHASH、文件RFILE等也有类似的访问方法。
话虽如此，但你也需要小心，在扩展代码中不要过于依赖对类型的检查。
我们将在后面294页更多讨论扩展以及Ruby的类型系统。

<kinder:note> 4版附录的描述
These macros are named RCLASSNAME (which returns the whole structure) and `RCLASSNAME_xxx` , which let you access the specific fields in the structure.  
这些宏命名为RCLASSNAME（返回整个构造）和`RCLASSNAME_xxx`，让你访问构造里指定的字段。
For example, RSTRING(obj) will return a reference to the RString structure pointed to by obj; `RSTRING_PTR`(obj) and `RSTRING_LEN`(obj) return the contents and length.
比如，RSTRING(obj)将返回一个obj指向的RString构造的引用；`RSTRING_PTR`(obj)和`RSTRING_LEN`(obj)返回内容和长度。
There are similar accessors for hashes (RHASH, files (RFILE), and so on.  
hash file也有类似的访问方法(RHASH和RFILE)，其他的也是。
The full list is shown in Figure 2.3, on the following page.
完整的列表在下一页的表格2.3中出现。

Figure 2.3: Object Accessor Macros   图表2.3 对象访问宏

    RClass c;          
    RCLASS_M_TBL(c)     Pointer to table of methods
    RCLASS_SUPER(c)     Pointer to superclass
    ---
    RModule m;
    RMODULE_IV_TBL(m)
    RMODULE_M_TBL(m)    Same as classes
    RMODULE_SUPER(m)
    ---
    RFloat v;
    RFLOAT_VALUE(v)     The value as a native float
    ---
    RString str;
    RSTRING_LEN(str)    Length of the string
    RSTRING_PTR(str)    Pointer to start of string data
    RSTRING_END(str)    Pointer to end of string data
    ---
    RArray a;
    RARRAY_LEN(a)      Number of elements in the array
    RARRAY_PTR(a)      Pointer to start of array data (treat as being read-only)
    ---
    RHash h;
    RHASH_TBL(h)       Pointer to the hash data (see st.c
    RHASH_ITER_LEV(h)  If nonzero, hash is being traversed by an iterator
    RHASH_IFNONE(h)    Default value for hash (may be a proc object)
    RHASH_SIZE(h)      Number of entries in hash
    RHASH_EMPTY_P(h)   True if RHASH_SIZE(h) is zero


### 21.2.4 全局变量
多数时候，由你的扩展实现类，而ruby代码使用这些类。
你在ruby和C代码中共享的数据，会整洁地包装到类的对象中。
它应当如此。

不过，有时候你希望实现全局变量，在C扩展和Ruyb代码中都可以访问。

最简单的方法是，让变量作为一个VALUE（也就是说，一个ruby对象）。
然后你可以将C变量的地址绑定到一个ruby变量的名字。
在这种情况下，$前缀是可选的。但它可以帮助你澄清这是一个全局变量。
并且请记住：让栈中的变量作为ruby的全局变量，不会（长期）有效。

    static VALUE hardware_list;
    static VALUE Init_SysInfo() {
      rb_define_class(....);
      hardware_list = rb_ary_new();
      rb_define_variable("$hardware", &hardware_list);
      ...
      rb_ary_push(hardware_list, rb_str_new2("DVD"));
      rb_ary_push(hardware_list, rb_str_new2("CDPlayer1"));
      rb_ary_push(hardware_list, rb_str_new2("CDPlayer2"));
    }

Ruby端可以用$hardware来访问C变量`hardware_list`：

    $hardware  -> ["DVD", "CDPlayer1", "CDPlayer2"]

不过，有时生活会更复杂。
也许你要定义的全局变量，它的值在访问时必须通过计算才能得到。
你可以通过定义hooked和虚拟变量来完成。
hooked变量是一个真实的变量，当访问到对应的ruby变量时，由一个具名的（named）函数初始化。
虚拟变量也有些类似，但并没有真正的存储：它们的值来自于对hook函数的求值。
更多细节请参见后面308页开始的API章节。

如果你从C创建一个Ruby对象，把它保存在一个C全局变量中，而不将它暴露给Ruby，你至少要将它告知垃圾收集器，以免因疏忽而忘记回收。

    static VALUE obj;
    // ...
    obj = rb_ary_new();
    rb_global_variable(obj);

##     2.3 The Threading Model 线程模型  2010.11月版
### 内部实现线程
Previous Ruby interpreters implemented threading internally.  
之前的ruby解释器在内部实现线程。
These green threads relied on the interpreter periodically switching between Ruby-level threads.  
这些绿色线程依赖解释器在ruby级别的线程中进行周期性的转换。
Even if your computer had eight cores, your Ruby program would run on only one of them at a time.  
即使你的计算机有八核，你的ruby程序也只会在一个时间运行一个。
And, if you called a long-running external function, your whole program would hang.  
而且，如果你调用一个长时间运行的外部函数，你的整个程序将会被挂起。
DNS name resolution was a notorious culprit.
DNS域名解析就是一个名称狼藉的代表。

### 操作系统线程   **1.9**
Ruby 1.9 now uses operating system threads.  
ruby 1.9现在使用操作系统线程了。
This allows your multithreaded Ruby programs to do more in parallel than was possible earlier.  
这允许你的多线程ruby程序在并行上比早前做得更多。
However, before you run cheering into the streets, I have to tell you a catch.  
不过，在你裸奔（^.^）庆祝之前，我告诉你一个问题。
Although the core interpreter is thread-safe, extension libraries probably aren’t.  
虽然核心解释器是线程安全的，将扩展库可能不会。
And problems that arise when you run non-thread-safe code multithreaded are incredibly hard to diagnose, and they have a habit of being extremely damaging to data.  
问题就会出现，当你多线程地运行非线程安全的代码，无法可靠地诊断，并且对数据造成极端的伤害。
So, Matz made a decision: the Ruby VM can run in multiple threads, but it will execute Ruby code in only one of those threads at a time.
所以，Matz做了一个决定：Ruby VM可以在多线程中运行，但它在一个时间只会在一个线程里执行代码。

This means that you probably won’t be writing your next high-volume telephone exchange microcode in Ruby.  
这意味着，你可能不会在ruby中写下一个高音电话交换微码。
But it still brings benefits.  
但这仍然有益。
Whereas previously the DNS lookup would stall all your code, in Ruby 1.9 it will run in an operating system thread.  
不管前面的DNS查找在何处停止了你的所有代码，在ruby 1.9，它会在操作系统线程里面运行。
If your program has other Ruby-level threads waiting to execute, they can run while the looking is executing.  
如果你的程序有另一个ruby级别的线程等待执行，它们可以在执行查找时运行起来。
Another example is the multiplication of very large Bignum values.  
另一个例子是非常大的Bignum值的乘法。
Whereas in the old interpreter the multiplication would hog the CPU and no other threads would run, Ruby 1.9 schedules such multiplications in one operating system thread and allows other Ruby-level threads to operate in true parallel.
考虑到在旧的解释器中，乘法会占用CPU，其他线程不能运行，ruby 1.9将这样的程序调度到一个操作系统线程中，运行其他ruby级别线程进行并行操作。

When you write your own Ruby extensions, you need to make sure they play well in this new world.  
当你写下你的ruby扩展时，你需要确保它们在新世界中仍然运行良好。
In particular, if they are about to undertake some long-running external operation, you need to make sure that other Ruby threads are allowed to run in parallel.
特别是，如果它们将要承担一些长时间运行的外部操作，你需要确保其他ruby线程可以并行运行。

### GVL和rb_thread_blocking_region  虚拟机巨锁和线程阻塞区域
Ruby controls which threads can run using the GVL, or Giant VM Lock.  
ruby使用GVL或者Giant VM Lock来控制线程运行。
The thread that’s currently executing Ruby-level code will have claimed the GVL, and no other thread will be able to claim it (and hence execute Ruby code) until the lock is relinquished.  
线程中那些正在执行的ruby级的代码将声明GVL，没有其他线程可以声明它（并因此执行ruby代码），直到该锁被放弃。
Your extension code normally doesn’t worry about this—Ruby handles it for you.  
你的扩展代码通常不用担心这个--ruby为你处理好了。
But if your extension is about to make (say) a long-running I/O request, it will need to temporarily relinquish the GVL until that request completes.  
但如果你的线程要进行（比如）一个长时运行的I/O请求，它将需要临时放弃GVL，直到请求完成。
To do this, call the method `rb_thread_blocking_region` (which we’ll abbreviate to `rb_tbr` in the description that follows—in your code you have to spell out the full name).  
要这样做，调用方法`rb_thread_blocking_region`（我们在下面的描述中缩写为`rb_tbr`，而在代码中你必须写出全名）。
This method takes the address of a C function and a pointer to a parameter to pass to that function.  
这个方法将C函数的地址和一个指针作为参数传给该函数。
It also takes a second function/parameter pair, which we’ll describe shortly.
它也带有第二个函数/参数对，我们将简短描述一下。

Internally, `rb_tbr` releases the GVL and then calls the function you specify, passing it the parameter you gave in the call.  
在内部，`rb_tbr`释放GVL，返回调用你指定的函数，将你在调用中给定的参数传给它。
When the function terminates, `rb_tbr` then reacquires the GVL before returning back to you.  
当函数终结时，`rb_tbr`然后在结果返回给你之前，重新获得GVL。
If it were written in Ruby, an incomplete implementation might look like this:
如果它是用ruby写的，不完整的实现看起来就像这样：

    def rb_thread_blocking_region(param, unblock_function, unblock_flag)
      release_lock(GVL)
      begin
        yield(param)
      ensure
        acquire_lock(GVL)
      end
    end
    rb_thread_blocking_region(task_data, ...) do |data|
      # some long-running external call
    end

Before we look at the C-level implementation, we need to discuss the second function/parameter pair that you pass to `rb_thread_blocking_region` .  
在我们观察C级别实现之前，我们需要讨论你传给`rb_thread_blocking_region`的第二个函数/参数对。
These represent an unblocking function, or ubf.  
这些表现了一个未阻塞函数，或者简称ubf。
There are times that Ruby needs to terminate the execution of code that’s being run in a separate thread.  
有很多次，ruby需要终结代码在独立线程里的执行。
For example, a thread may call your extension library to start some long-running operation, such as a file copy.  
比如，一个线程可能调用扩展库来开始一些长时运行的操作，比如复制文件。
Your code uses `rb_tbr` to allow the rest of the interpreter to run during this process.  
你的代码使用`rb_tbr`来在处理期间允许解释器的休息间隔来运行。
But maybe one of those other threads calls exit to shut down the interpreter.
但可能那些线程中的一个其他线程调用了exit来关闭解释器。
Ruby needs to coordinate this shutdown with the work that’s taking place in your thread.  
Ruby需要通过在你的线程中进行替换来调整这个shutdown。
It does this by calling the unblocking function that you pass to `rb_tbr` .  
通过调用传给`rb_tbr`的非阻塞函数，它做到这一点。
This function is responsible for terminating whatever activity was initiated by `rb_tbr` .
这个函数负责终结任何`rb_tbr`初始化的活动。

Let’s look at some C code that uses this feature.  
让我们看看使用这个特性的C代码。
This example is taken from bignum.c in the main interpreter, but it applies to code that is in an extension, too.
这个例子从主解释器的bignum.c文件取得，但它也适用于在扩展里的代码。

First, the code defines a structure that is used to pass parameters to the function that executes in parallel.  
首先，代码定义了一个结构，用于传递参数到并行执行的函数
In this example, the same structure is also passed to the unblocking function:
在这个例子中，相同的结构也被传到非阻塞函数。

    struct big_mul_struct {
      VALUE x, y, z, stop;
    };

Here’s the body of the method that is called to multiply two bignums.  
这是方法的主体，被调用来进行两个bignum的相乘。
I’ve cut out some of the boring stuff in the middle.
我已经在中间删除了一些烦人的东西。

    static VALUE
    rb_big_mul0(VALUE x, VALUE y)
    {
      struct big_mul_struct bms;
      volatile VALUE z;
      /* ... */
      bms.x = x;
      bms.y = y;
      bms.stop = Qfalse;
      if (RBIGNUM_LEN(x) + RBIGNUM_LEN(y) > 10000) {
        z = rb_thread_blocking_region(bigmul1, &bms, rb_big_stop, &bms.stop);
      }
      else {
        z = bigmul1(&bms);
      }
      return z;
    }

The important code for us is at the end of the method.  
对我们来说重要的代码在方法的结尾。
If the numbers being multiplied are big, it calls `rb_thread_blocking_region` , passing in the function to run ( bigmul1 ), the parameter to pass to it ( bms ), and the unblocking function and parameter ( `rb_big_stop` and bms ).  
如果正在相乘的数字是大的，它调用`rb_thread_blocking_region`，传入函数来运行（bigmul1），参数传入其中（bms），以及非阻塞函数和参数（`rb_big_stop`）。
If instead the numbers are below the threshold, it calls bigmul1 directly.
如果数字在极限以下，它直接调用bigmul1.

Now let’s look at the unblocking function, `rb_big_stop` :
现在我们看看非阻塞函数`rb_big_stop`：

    static void
    rb_big_stop(void *ptr)
    {
      VALUE *stop = (VALUE*)ptr;
      *stop = Qtrue;
    }

If called, it simply sets the location referenced by its parameter to Qtrue .
如果调用，它只将参数指向的位置设置为Qtrue。
And how does this stop the calculation prematurely? 
那这个怎么过早结束计算呢？
Let’s look at bigmul1 (again, omitting some gory details):
让我们看看bigmul1（再次省略一些血淋淋的细节）：

    static VALUE
    bigmul1(void *ptr)
    {
      struct big_mul_struct *bms = (struct big_mul_struct*)ptr;
      long i, j;
      VALUE x = bms->x, y = bms->y, z = bms->z;
      /* ... */
      for (i = 0; i < RBIGNUM_LEN(x); i++) {
        if (bms->stop) return Qnil;
        /*
         * do the next digit...
         */
      }
      return z;
    }

So, if the unblocking function is called, it sets the stop member of the structure to Qtrue .  
所以，如果非阻塞函数被调用，它将结构的stop数设置为Qtrue。
Then in the loop that’s doing the multiplication and that is running in a separate thread, it notices that the flag has been set and exits early, returning nil .
然后在相乘的、运行在一个独立线程的循环中，它注意到那个flag已经被设置，并早早退出，返回nil。

### Threads, Processes, and I/O  线程、进程和IO
If the function you pass to `rb_tbr` executes I/O or synchronizes with an external process, you’re left with a difficult decision when it comes time to write the unblocking function.  
如果你传给`rb_tbr`的函数执行IO或和外在进程进行同步，当它即将写入非阻塞函数时，你会遇到一个困难的决定。
Interrupting I/O is tricky and is most likely system-dependent.  
中断I/0是有技巧的，并且非常依赖系统。
Luckily for you, Ruby provides a sledgehammer to crack that particular nut.  
幸运的是，ruby通过了一个“锤子”来砸烂那个特殊的“坚果”。
If you pass `RUBY_UBF_IO` or `RUBY_UBF_PROCESS` as the third parameter (and NULL as the fourth), Ruby will use a default ubf function that simply kills the thread performing the processing.  
如果传递`RUBY_UBF_IO`或`RUBY_UBF_PROCESS`作为第三个参数（NULL是第四个），ruby将使用默认的ubf函数，只是杀死正在执行过程的线程。
Here’s the code from the interpreter method that reads from a file descriptor:
这是解释器方法的代码，从一个文件描述符读取：

    static int
    rb_read_internal(int fd, void *buf, size_t count)
    {
      struct io_internal_struct iis;
      iis.fd = fd;
      iis.buf = buf;
      iis.capa = count;
      return rb_thread_blocking_region(internal_read_func, &iis,
        RUBY_UBF_IO, 0);
    }

You’ll need to decide whether you should use these built-in ubfs in your own extension.  
你将需要决定是否在你的扩展中使用这些内建的非阻塞函数。
For example, if updating a database table, you’ll probably want to perform a more controlled shutdown than simply terminating the controlling thread.
比如，如果正在更新一个数据库表，你可能要进行一个更多控制的关闭，而不只是终结控制中的线程。

## 　　21.3　Jukebox扩展
我们已经覆盖了大部分的基本内容，现在回到我们的点唱机示例--连接ruby和c代码，并且在两个世界中共享数据和行为。
### 21.3.1 包装C结构
供应商的头文件：

    typedef struct _cdjb {
      int statusf;
      int request;
      void *data;
      char pending;
      int unit_id;
      void *stats;
    } CDJukebox;
    // Allocate a new CDJukebox structure
    // 分配一个新的CDJukebox架构
    CDJukebox *new_jukebox(void);
    // Assign the Jukebox to a player
    // 将Jukebox赋值给播放器
    void assign_jukebox(CDJukebox *jb, int unit_id);
    // Deallocate when done (and take offline)
    // 完成后解除分配(并断线)
    void free_jukebox(CDJukebox *jb);
    // Seek to a disc, track and notify progress
    // 查找一个唱盘、轨道并提示进度
    void jukebox_seek(CDJukebox *jb,
                      int disc,
                      int track,
                      void (*done)(CDJukebox *jb, int percent));
    // ... others...
    // ...其他代码..
    // Report a statistic
    // 报告统计
    double get_avg_seek_time(CDJukebox *jb);

这是供应商提供的全部操作。虽然他们可能不承认，代码使用面向对象的方式编写的。
我们并不知道CDJukeBox接口所有成员的含义，但这不碍事--我们可以将它看作是不透明的一大堆数据。
供应商的代码知道如何操作它；我们只需要将这些数据携带进去。

任何时候，你想要如Ruby对象那样来处理一个c结构，你需要将它包装成一个特殊的ruby内部类，称为DATA（类型为`T_DATA`）。
有两个宏完成这一包装，且其中一个宏会再次返回你的结构。

### 21.3.2 API：C数据类型的包装
**包装**

    VALUE Data_Wrap_Struct ( VALUE class, void (*mark)(),
                             void (*free)(), void *ptr )

包装给定的C数据类型ptr，注册两个垃圾收集例程（参见下面的描述），并返回一个指向实际ruby的对象的VALUE指针。返回对象的c类型是`T_DATA`，且它的ruby类是class。

    VALUE Data_Make_Struct( VALUE class, c-type, void (*mark)(),
                            void (*free)(), c-type * )

分配指定类型的结构体系并清零，然后继续`Data_Wrap_Struct`的工作，c-type是你要包装的c数据类型的名字，而不是类型的变量。

           Data_Get_Struct( VALUE obj,c-type,c-type * )

返回原本的指针。这个宏是对宏`DATA_PTR(obj)`的类型安全的包装，它会对指针进行评估。

`Data_Wrap_Struct`创建的对象是普通的ruby对象，唯一不同的是它有额外的、无法从ruby中访问的c数据类型。
从下图21.1中看到，c数据类型和对象所包含的实例变量是分开的。

                    +------CDPlayer--------------+
                    |                   +------+ |
    jukebox1---->   |     @unit:1       |  C   | |
                    |                   |struct| |
                    |                   +------+ |
                    +----------------------------+ 
    
                    +------CDPlayer--------------+
                    |                   +------+ |
    jukebox1---->   |     @unit:2       |  C   | |
                    |                   |struct| |
                    |                   +------+ |
                    +----------------------------+ 

但由于它是独立的，当垃圾收集器**回收这个对象**时，该怎样清除它呢？
如果你必须释放某些资源（关闭文件、清除锁或其他IPC机制等等），又该如何呢？
Ruby使用标记和清扫（mark and sweep）的垃圾回收方式。
在标记阶段，ruby查找指向内存区域的指针。它标记这些区域为“使用中”（因为有东西指向它们）。
如果这些区域本身包括更多的指针，这些指针所指向的内存也会被标记，以此类推。
在标记的最后阶段，所有被引用的内存已经被标记了，而所有孤立的区域则不会有标记。
当清扫阶段开始时，释放那些没有被标记的内存。

为了参与到ruby标记后清扫的垃圾回收过程，你必须定义一个例程来释放你的结构。或者还需要一个例程来完成从你的结构到其他结构的引用标记。
两个例程都接收void指针，它指向你的结构。
mark例程在垃圾收集器处于标记阶段时被调用。如果你的结构引用了其他的ruby对象，那么你的标记函数需要用`rb_gc_mark(value)`来标识出这些对象。
如果结构没有引用其他的ruby对象，你可以简单地以0作为函数的指针。
当对象需要清除时，垃圾收集器将调用free例程来释放它。
如果你自己分配了某些内存（例如，使用`Data_Make_Struct`），你需要传入一个释放函数--即便它就是标准C库中的free例程。对你分配的复杂结构，你的释放函数可能需要遍历这个结构来释放所有分配的内存。

让我们看看**CD播放器的接口**。
供应商的库将信息以及各种函数保存在一个CDJukebox结构中。这个结构表示点唱机的状态，因此是将之包装成ruby类的一个好的候选。
我们通过调用库中的CDPlayerNew方法来创建该结构的一个新实例，然后将这个创建的结构包装到一个新的CDPlayer Ruby对象中：

    CDJukebox *jukebox;
    VALUE obj;
    // Vendor library creates the Jukebox
    // 容器库创建Jukebox
    jukebox = new_jukebox();
    // then we wrap it inside a Ruby CDPlayer object
    // 然后我们将它包装进一个Riby CDPlayer对象里面
    obj = Data_Wrap_Struct(klass, 0, cd_free, jukebox);
    // 神秘的klass参数，我们稍后讨论。

在代码执行后，obj应该保存了一个新分配的CDPlayer Ruby对象（包装了新建的CDJukebox C结构）的引用。

当然，要**编译这段代码**，我们还需要多做些工作。
必须定义CDPlayer的类，并将它的引用保存在cCDPlayer变量中
还必须定义用来释放对象的函数`cdplayer_free`。只需调用供应商库中的清除方法即可：

    static void cd_free(void *p) {
      free_jukebox(p);
    }

不过，代码片段还不足成事。需要以某种方式将所有这些东西打包集成到解释器中。
为此，我们还需要查看解释器使用的某些约定。

### 21.3.3 对象创建
Ruby 1.8完善了对象的创建和初始化。虽然旧有方式也可工作，但使用分配函数的新方式，要整洁得多（而且将来也不大会被废弃）。
假如你要在ruby程序中创建一个CDPlayer类的对象：`cd = CDPlayer.new`
在幕后，解释器调用CDPlayer类方法的new。因为CDPlayer没有定义new，所以ruby查看它的父类，Class类。
实现Class类中的new相当简单：它为新的对象分配内存，然后调用对象的initialize方法来初始化内存。
因此，如果我们的CDPlayer扩展要成为ruby的好公民，它就应该能在这种框架下工作。
这意味着，我们需要实现一个分配函数以及一个初始化方法。

#### 1.8版本之前的对象分配
在ruby 1.8之前，如果你想要在对象中分配额外的空间，要么你将代码放到initialize方法中，要么你必须为你的类定义一个new方法。
Guy Decoux建议使用下面的混合方法，来做到1.6和1.8扩展间最大的兼容。

    static VALUE cd_alloc(VALUE klass) {
      // same as before
    }
    static VALUE cd_new(int argc, VALUE *argv, VALUE klass) {
      VALUE obj = rb_funcall2(klass, rb_intern("allocate"), 0, 0);
      rb_obj_call_init(obj, argc, argv);
      return obj;
    }
    void init_CDPlayer() {
      // ...
      #if HAVE_RB_DEFINE_ALLOC_FUNC
        // 1.8 allocation
        rb_define_alloc_func(cCDPlayer, cd_alloc);
      #else
        // define manual allocation function for 1.6
        rb_define_singleton_method(cCDPlayer, "allocate",
                                    cd_alloc, 0);
      #endif
      rb_define_singleton_method(cCDPlayer, "new", cd_new, -1);
      // ...
    }

如果你要编写的代码必须运行ruby最新和较老的版本上，那么你需要使用与此类似的方法。
不过你可能还需要处理克隆和复制，并靠略当你的对象被列集时会如何。

### 21.3.4 分配函数
分配函数负责创建对象使用的内存。
如果你所实现的对象，并不需要除ruby实例变量之外的数据，那么无需编写一个分配函数--ruby默认的分配器就可以满足了。
但如果你的类包装了一个C结构，你需要在分配函数中为这个结构分配空间。
分配函数将要分配对象的类（class）作为参数。
在我们的示例中，它十有八九是cCDPlayer，但我们直接使用给出的参数，因为这意味着作为klass的子类我们也可以正确地工作。

    static VALUE cd_alloc(VALUE klass) {
      CDJukebox *jukebox;   //<kinder:note> 记得吗？这段代码在21.3.2出现过
      VALUE obj;
      // Vendor library creates the Jukebox
      // 容器库创建Jukebox
      jukebox = new_jukebox();
      // then we wrap it inside a Ruby CDPlayer object
      // 然后我们将它包装进一个Riby CDPlayer对象里面
      obj = Data_Wrap_Struct(klass, 0, cd_free, jukebox);
      // 神秘的klass参数，我们稍后讨论。
      return obj;
    }

你还需要在类的初始化代码中注册你的分配函数:

    void Init_CDPlayer() {
      cCDPlayer = rb_define_class("CDPlayer", rb_cObject);
      rb_define_alloc_func(cCDPlayer, cd_alloc);
      // ...
    }

大部分对象可能也需要定义一个初始化函数。
分配函数创建一个空的、未初始化的对象，而我们需要填入具体的值。
以CD播放器为例，调用构造函数可能指定与该对象所关联的播放器单元的个数。

    static VALUE cd_initialize(VALUE self, VALUE unit) {
      int unit_id;
      CDJukebox *jb;
      Data_Get_Struct(self, CDJukebox, jb);
      unit_id = NUM2INT(unit);
      assign_jukebox(jb, unit_id);
      return self;
    }

这种多步创建协议的原因是：让解释器能够处理必须以“后门方式”创建对象的情况。
一个例子是，当对象要从列集的(marshaled)形式中反序列化时。此时，解释器需要创建一个空的对象（通过调用分配器），但是它不会调用初始化函数（因为它不知道要使用的参数）
另一个常见的情况是，当对象被复制或克隆时。

这里潜伏了一个更深入的问题。因为用户可能选择绕过构造函数，你需要确保分配代码使返回的对象处于有效状态。它可能并没有包括曾经由#initialize设置的全部信息，但至少应该是可用的。

### 21.3.5 克隆对象
所有ruby对象都可以使用dup或clone方法来拷贝。
这两个方法是类似的：两者都会通过调用分配函数产生调用类的一个新实例。然后它们从原来的对象中拷贝实例变量。
clone会拷贝得更深入些，它会拷贝原来对象的单体类（singleton class，如果它有的话）和标志（例如指示对象被冻结的标志）。
你可以认为dup是内容的拷贝，而clone是整个对象的拷贝。

不过，ruby解释器并不知道如何处理你编写的c扩展中对象的内部状态。
例如，如果你的对象包装了一个c结构，其中包括一个打开的文件描述符，这取决于实现的语义，这个描述符是否应简单地拷贝到新对象中，或者是否应该打开一个新的文件描述符。

为了处理它，解释器将拷贝对象内部状态的职责委托给你自己的代码。
在拷贝对象的实例变量之后，解释器调用新对象的`initialize_copy`方法，传入原对象的引用。
这取决于你在该方法中实现有意义的语义。

对于CDPlayer类来说，对克隆问题采取十分简单的方法：我们简单地从原对象中拷贝CDJukebox结构。
这是本例一段短小奇怪的代码。
要测试我们确实可以克隆原对象，代码检查原对象：1,具有`T_DATA`的TYPE（意味着它是一个非核心的对象），并且2,具有和我们相同的释放函数。
这是一种相对性能较好的方式，来验证原对象和我们自己的对象是兼容的（只要你没有在多个类间共享相同的释放函数）。
另一个方式，稍稍慢些，是使用`rb_obj_is_kind_of`并对类进行直接的测试。

    static VALUE cd_init_copy(VALUE copy, VALUE orig) {
      CDJukebox *orig_jb;
      CDJukebox *copy_jb;
      if (copy == orig)
        return copy;
      // we can initialize the copy from other CDPlayers
      // or their subclasses only
      // 我们只能初始化从另一个CDPlayers或者它们的子类复制而来的拷贝
      if (TYPE(orig) != T_DATA ||
        RDATA(orig)->dfree != (RUBY_DATA_FUNC)cd_free) {
        rb_raise(rb_eTypeError, "wrong argument type");
        }
      // copy all the fields from the original
      // object's CDJukebox structure to the
      // new object
      // 从原始对象的CDJukebox结构复制所有的字段到新对象
      Data_Get_Struct(orig, CDJukebox, orig_jb);
      Data_Get_Struct(copy, CDJukebox, copy_jb);
      MEMCPY(copy_jb, orig_jb, CDJukebox, 1);
      return copy;
    }

拷贝方法无需分配一个被包装的结构来接收原对象的CDJukebox结构；`cd_alloc`方法已经为我们分配了。
注意，使用基于类的类型检查是正确的：我们需要原对象含有一个包装的CDJukebox结构，并且只有从类CDPlayer派生的对象才有该结构。

### 21.3.6 集成到一起
CDPlayer类的所有代码：

    #include "ruby.h"
    #include "cdjukebox.h"
    static VALUE cCDPlayer;
    
    // 释放CDJukebox容器的辅助函数
    // Helper function to free a vendor CDJukebox
    static void cd_free(void *p) {
      free_jukebox(p);
    }
    
    // 分配新的CDPlayer对象，包装了CDJukebox结构的容器
    // Allocate a new CDPlayer object, wrapping
    // the vendor's CDJukebox structure
    static VALUE cd_alloc(VALUE klass) {
      CDJukebox *jukebox;
      VALUE obj;
      // Vendor library creates the Jukebox
      jukebox = new_jukebox();
      // then we wrap it inside a Ruby CDPlayer object
      obj = Data_Wrap_Struct(klass, 0, cd_free, jukebox);
      return obj;
    }
    
    // 将新建的CDPlayer赋值给特定的单元
    // Assign the newly created CDPLayer to a
    // particular unit
    static VALUE cd_initialize(VALUE self, VALUE unit) {
      int unit_id;
      CDJukebox *jb;
      Data_Get_Struct(self, CDJukebox, jb);
      unit_id = NUM2INT(unit);
      assign_jukebox(jb, unit_id);
      return self;
    }
    
    // 复制跨越状态（被clone和dup使用）。对于jukeboxes，我们实际上创建了一个新的容器对象，并从老的那个设置它的单元数
    // Copy across state (used by clone and dup). For jukeboxes, we
    // actually create a new vendor object and set its unit number from
    // the old
    static VALUE cd_init_copy(VALUE copy, VALUE orig) {
      CDJukebox *orig_jb;
      CDJukebox *copy_jb;
      if (copy == orig)
        return copy;
      // we can initialize the copy from other CDPlayers or their
      // subclasses only
      if (TYPE(orig) != T_DATA ||
          RDATA(orig)->dfree != (RUBY_DATA_FUNC)cd_free) {
        rb_raise(rb_eTypeError, "wrong argument type");
      }
      // copy all the fields from the original object's CDJukebox
      // structure to the new object
      Data_Get_Struct(orig, CDJukebox, orig_jb);
      Data_Get_Struct(copy, CDJukebox, copy_jb);
      MEMCPY(copy_jb, orig_jb, CDJukebox, 1);
      return copy;
    }
    
    // progress回调产生完成比例的调用
    // The progress callback yields to the caller the percent complete
    static void progress(CDJukebox *rec, int percent) {
      if (rb_block_given_p()) {
        if (percent > 100) percent = 100;
        if (percent < 0) percent = 0;
        rb_yield(INT2FIX(percent));
      }
    }
    
    // 寻找指定的音轨部分，调用progress回调，当我们进行时。
    // Seek to a given part of the track, invoking the progress callback
    // as we go
    static VALUE
    cd_seek(VALUE self, VALUE disc, VALUE track) {
      CDJukebox *jb;
      Data_Get_Struct(self, CDJukebox, jb);
      jukebox_seek(jb,
                    NUM2INT(disc),
                    NUM2INT(track),
                    progress);
      return Qnil;
    }
    
    // 返回该单元的平均寻找时间
    // Return the average seek time for this unit
    static VALUE
    cd_seek_time(VALUE self)
    {
      double tm;
      CDJukebox *jb;
      Data_Get_Struct(self, CDJukebox, jb);
      tm = get_avg_seek_time(jb);
      return rb_float_new(tm);
    }
    
    // 返回这个播放器的单元数
    // Return this player's unit number
    static VALUE
    cd_unit(VALUE self) {
      CDJukebox *jb;
      Data_Get_Struct(self, CDJukebox, jb);
      return INT2NUM(jb->unit_id);;
    }
    
    void Init_CDPlayer() {
      cCDPlayer = rb_define_class("CDPlayer", rb_cObject);
      rb_define_alloc_func(cCDPlayer, cd_alloc);
      rb_define_method(cCDPlayer, "initialize", cd_initialize, 1);
      rb_define_method(cCDPlayer, "initialize_copy", cd_init_copy, 1);
      rb_define_method(cCDPlayer, "seek", cd_seek, 2);
      rb_define_method(cCDPlayer, "seek_time", cd_seek_time, 0);
      rb_define_method(cCDPlayer, "unit", cd_unit, 0);
    }

现在，我们可以用一种美好的、面向对象的方式，从ruby中控制点唱机：

    require 'CDPlayer'
    p = CDPlayer.new(13)
    puts "Unit is #{p.unit}"
    p.seek(3, 16) {|x| puts "#{x}% done" }
    puts "Avg. time was #{p.seek_time} seconds"
    p1 = p.dup
    puts "Cloned unit = #{p1.unit}"
    # produces:
    # Unit is 13
    # 26% done
    # 79% done
    # 100% done
    # Avg. time was 1.2 seconds
    # Cloned unit = 13

这个实例演示了迄今我们所讨论的大部分内容，但还有一个附加的功能。
供应商库提供了一个回调例程--一个函数指针，当硬件播放碟片时会频繁调用。
我们在此已经设置停当，运行作为seek参数传入的一个代码block。
在progress函数中，我们查看在当前上下文中是否有一个迭代器，如果有，以当前完成的百分比为参数运行它。

## 　　21.4　内存分配
有时你可能需要在扩展中分配内存，但不用于对象的存储-- 也许你已经得到了bloom滤波器（bloom filter）一个巨大的位图（bitmap）、一幅图像或者ruby并不直接使用的许多的数据结构。
为了让垃圾收集器正确工作，你应该使用下面的内存分配例程。

这些例程比标准的malloc稍稍多做了些工作。
例如，如果`ALLOC_N`判断它无法分配得到所需数量的内存，将会调用垃圾收集器来尝试收回一些空间。
如果无法分配或者或许数量的内存不可获得，它将引发一个NoMemError异常。

### 21.4.1 API：内存分配

    type * ALLOC_N(c-type, n)

分配n个c-type对象，其中c-type是c类型的字面名称，而非该类型的变量。

    type * ALLOC(c-type)

分配一个c-type，并且将结果转型为该类型的指针。

    REALLOC_N(var, c-type, n)

重新分配n个c-type，并将结果复制给指针var，它指向类型为c-type的变量。

    type * ALLOCA_N(c-type, n)

在栈上分配c-type的n个对象-- 这部分内存会在调用`ALLOCA_N`的函数返回时自动释放。

## 　　21.5　Ruby的类型系统
在ruby中，我们很少依赖于一个对象的类型或class，而更多地关注于它的能力，这被称为duck typing。我们将在第365页的23章中详细讨论它。
如果你查看解释器的代码，你会发现许多例证。
<kinder:note> 2版原文：
例如，下面的代码实现了kernel.exec方法：

    VALUE
    rb_f_exec(argc, argv)
        int argc;
        VALUE *argv;
    {
        VALUE prog = 0;
        VALUE tmp;
        if (argc == 0) {
            rb_raise(rb_eArgError, "wrong number of arguments");
        }
        tmp = rb_check_array_type(argv[0]);
        if (!NIL_P(tmp)) {
            if (RARRAY(tmp)->len != 2) {
                rb_raise(rb_eArgError, "wrong first argument");
            }
            prog = RARRAY(tmp)->ptr[0];
            SafeStringValue(prog);
            argv[0] = RARRAY(tmp)->ptr[1];
        }
        if (argc == 1 && prog == 0) {
            VALUE cmd = argv[0];
            SafeStringValue(cmd);
            rb_proc_exec(RSTRING(cmd)->ptr);
        }
        else {
            proc_exec_n(argc, argv, prog);
        }
        rb_sys_fail(RSTRING(argv[0])->ptr);
        return Qnil;                       /* dummy */
    }

该方法的第一个参数是一个字符串或者一个含有两个字符串的数组。

<kinder:note> 4版附录：
For example, the String class implements the method %.  
比如，String类实现了%方法。
This treats the string object as a format specifier (just like the C sprintf function).  
这将字符串对象当作一个格式指示符（很像C的sprintf函数）。
The % method can take a single argument (if the string contains just one substitution) or an array of values (if the format string contains multiple substitutions).
%方法可以带单个参数（如果字符串包含一个替代）或值的数组（如果格式字符串包含多个替代）。

    ruby-1.9.2-p0 > "You bought %d x %s" % [ 3, "widgets"]
    => "You bought 3 x widgets"
    ruby-1.9.2-p0 > "The total is %0.2f" % 5.678
    => "The total is 5.68"

Here’s the code in string.c that implements the String#% method:
下面是string.c里的代码，实现了String#%方法：

    static VALUE
    rb_str_format_m(VALUE str, VALUE arg)
    {
      VALUE tmp = rb_check_array_type(arg);
      if (!NIL_P(tmp)) {
        return rb_str_format(RARRAY_LEN(tmp), RARRAY_PTR(tmp), str);
      }
      return rb_str_format(1, &arg, str);
    }

The first parameter to this method is the self object—the format string.  
这个方法的第一个参数是self对象--格式字符。
The arg argument is either an array or a single object.  
arg参数可以是一个数组，或是单个对象。

然而，代码并不显式地检查参数的类型。
相反，它先对传入的参数调用`rb_check_array_type`（代码在array.c）：

    VALUE
    rb_check_array_type(ary)
        VALUE ary;
    {
        return rb_check_convert_type(ary, T_ARRAY, "Array", "to_ary");
    }

让我们跟踪到object.c的`rb_check_convert_type`：
<kinder:note>这是2版原文：

    VALUE
    rb_check_convert_type(val, type, tname, method)
        VALUE val;
        int type;
        const char *tname, *method;
    {
        VALUE v;
        /* always convert T_DATA */
        if (TYPE(val) == type && type != T_DATA) return val;
        v = convert_type(val, tname, method, Qfalse);
        if (NIL_P(v)) return Qnil;
        if (TYPE(v) != type) {
            rb_raise(rb_eTypeError, "%s#%s should return %s",
                      rb_obj_classname(val), method, tname);
        }
        return v;
    }

<kinder:note> 这是4版附录：

    VALUE
    rb_check_convert_type(VALUE val, int type, const char *tname,const char *method)
    {
      VALUE v;
      /* always convert T_DATA */
      if (TYPE(val) == type && type != T_DATA) return val;
        v = convert_type(val, tname, method, Qfalse);
        if (NIL_P(v)) return Qnil;
          if (TYPE(v) != type) {
            char *cname = rb_obj_classname(val);
            rb_raise(rb_eTypeError, "can't convert %s to %s (%s#%s gives %s)",
            cname, tname, cname, method, rb_obj_classname(v));
          }
          return v;
    }

我们将面临这样的处境。
如果对象是正确的类型（本例中为`T_ARRAY`），那么返回原本的对象。
否则我们使用`convert_type method`调用原对象，询问它是否可以将自己表现为一个数组（我们调用它的`to_ary`方法）。
如果可以，我们很高兴并继续。
代码所表述的意思是：我并不需要一个Array，我只是需要一个能够表现为数组的对象！
这意味着kernel.exec可以接收任何实现了`to_ary`方法的参数。
我们从后面371页(鸭子类型)开始会详细讨论这些转换协议（但是从Ruby的角度）。

作为一个扩展的编写者，这对你意味着什么呢？有两个含义。
其一，尝试避免检查传递给你的参数类型。
相反看看是否有类似`rb_check_xxx_type`的方法帮你将参数转换到你需要的类型。
如果没有，查找现有的某个可以帮助你进行转换的函数（例如`rb_Array`、`rb_Float`、`rb_Intger` ）。
其二，如果你要编写一个扩展，其中实现的某些对象可以有意义地用作一个Ruby字符串或数组，考虑实现`to_str`或`to_ary`方法，允许扩展所实现的对象被用于字符串或数组的上下文中。

## 　　21.6　创建一个扩展
在编写完扩展的源代码后，我们需要编译它来为Ruby所用。
我们或者将它实现为一个可以在运行时动态加载的共享库，或者静态地连接到ruby的主解释器中。
基本的步骤是相同的：
 1. 在指定的目录中创建c源文件；
 2. 在lib子目录中创建所有ruby的支持文件（可选）；
 3. 创建extconf.rb。
 4. 运行extconf.rb来为目录的c文件创建Makefile。
 5. 运行make；
 6. 运行make install。

### 21.6.1 通过extconf.rb创建Makefile
下图21.2演示了构建扩展的总体流程。

                    +-----------------+       +-----------+ 
                    |    extconf.rb   |  <... |    mkmf   |
                    +-----------------+       +-----------+ 
                    +-----------------+
                    | ruby extconf.rb |
                    +-----------------+
                            | 产生
                    +-----------------+
                    |    Makefile     |
                    +-----------------+
                            |
     +-------+      +-----------------+       +-----------+ 
     |  *.c  | ...> |        make     |  <... | libraries |
     +-------+      +-----------------+       +-----------+ 
                            | 产生
                    +-----------------+
                    |    Test.so      |
                    +-----------------+

整个过程的关键是，你作为开发者所创建的extconf.rb程序。
在extconf.rb中，你编写一个简单的程序来判断在用户系统中有哪些特性可用，以及这些特性位于何处。
执行这个rb文件会建立一个定制的Makefile，它是根据你的应用和编译时所用的系统来剪裁的。

最简单的extconf.rb可能只有两行，对许多扩展来说已经足够：

    require 'mkmf'
    creat_makefile("Test")

第一行引入了mkmf库模块（见后面779页的描述）。它包含了所有我们要使用的命令。
第二行为‘Test’扩展创建一个Makefile。Test将会从当前目录中的c源文件构建。
当你的代码被加载时，ruby调用它的`Init_Test`方法。

例如我们在只有一个源文件(main.c)的目录中运行该rb程序，结果为：
在linux机器上：

    gcc -fPIC -I/usr/local/lib/ruby/1.8/i686-linux -g -O2
      -c main.c -o main.o
    gcc -shared -o Test.so main.o -lc

编译的结果是Test.so，可以通过require在运行时动态地链接到ruby中。

在Mac OS X中，命令有所不同，但结果相同：都创建了一个共享库（Mac上称为bundle）:

    gcc -fno-common -g -O2 -pipe -fno-common \
        -I/usr/lib/ruby/1.8/powerpc-darwin \
        -I/usr/lib/ruby/1.8/powerpc-darwin -c main.c
    cc -dynamic -bundle -undefined suppress -flat_namespace \
       -L'/usr/lib' -o Test.bundle main.o -ldl -lobjc


虽然这个基本的extconf.rb程序对许多简单的扩展都适用，但如果你的扩展需要默认编译环境所没有的某些头文件或者库，或者你根据某些库或函数的存在与否进行条件编译，你还需要更多工作。

**`dir_config`**
一个常见的需求是指定查找头文件和库的非标准目录。
首先，extconf.rb应该包含一个或多个`dir_config`命令。这指定了一个目录集合的标记。
然后，运行extconf.rb时，告诉mkmf在当前系统中对应的物理目录在什么地方。

如果extconf.rb包括`dir_config(name)`的代码行，你可以用命令行选项给出对应目录的位置。
`--with-name-include=directory`将directory/include添加到编译器的选项中。
`--with-name-lib=directory`将directory/lib添加到链接器的选项中。
如果（而且很常见）你的头文件和库文件的目录分别是某个目录下的include和lib子目录，你可以使用简洁的方式。
`--with-name-dir=directory`将directory/include和directory/lib添加到编译器和链接器的选项中

和你在运行extconf.rb时使用--with选项一样，也可以使用为你的机器构建ruby时所使用的--with选项。这意味着，你可以发现并使用ruby本身使用库的位置。

具体来说，CD播放器需要使用供应商的CDJukebox库和头文件。
你的extconf.rb包括：

    require 'mkmf'
    dir_config('cdjukebox')
    # .. more stuff
    create_makefile("CDPlayer")

然后你可能像下面这样运行extconf.rb:

    $ ruby extconf.rb --with-cdjukebox-dir=/usr/local/cdjb

产生的Makefile会认为/usr/local/cdjb/lib含有库文件，而/usr/local/cdjb/include含有头文件。

**`have_library`**
`dir_config`命令添加用于搜索库和头文件的位置列表。但它不会将这些库链接到你的应用。
`have_library`查找某个具名库的指定入口点。如果它找到这个入口点，便将这个库添加到链接扩展所摔死的库的列表中。
下面是我们链接CD播放器的extconf.rb内容：

    require 'mkmf'
    dir_config("cdjukebox")
    have_library("cdjukebox", "new_jukebox")
    create_makefile("CDPlayer")

**`find_library`**
`find_library`与之类似，允许你指定一个目录列表来搜索库。
某个特定库的位置可能会因主机系统的不同而不同。
例如，X Window系统在这一点是闻名的，它在不同的系统上位于不同的目录中。
`find_library`命令会搜索所提供的目录列表，查找正确的路径。
这和`have_library`不同，`have_library`只能使用配置信息进行搜索。
例如要创建X Window的JPEG库的Makefile，extconf.rb可能包括：

    require 'mkmf'
    if have_library("jpeg","jpeg_mem_init") and
        find_library("X11", "XOpenDisplay",
                      "/usr/X11/lib",     # list of directories
                      "/usr/X11R6/lib",   # to check
                      "/usr/openwin/lib") # for library
    then
        create_makefile("XThing")
    else
        puts "No X/JPEG support available"
    end

我们已经为这个程序添加了一些附加的功能。所有的mkmf命令在失败时返回false。
这意味着我们可以编写一个extconf.rb，它只有当万事具备时，才会生成Makefile。
标准的Ruby发布就是这样做的，它只尝试编译你的系统所支持的那些扩展。

**`have_header`**
你可能还希望扩展的代码能够根据目标使用环境的不同，来配置其特性。
例如，我们的CD点唱机可以使用高性能的MP3解码器，如果用户最终已有安装的话，我们可以通过查找它的头文件来检验。

    require 'mkmf'
    dir_config('cdjukebox')
    have_library('cdjb', 'CDPlayerNew')
    have_header('hp_mp3.h')
    create_makefile("CDJukeBox")

`defined`
我们还可以检查目标环境中所有库是否支持某个特性的函数。
例如，setpriority调用可能是有用的，但并非在所有系统上都存在。可以通过下面代码检验：

    #if defined(HAVE_HP_MP3_H)
    # include <hp_mp3.h>
    #endif
    #if defined(HAVE_SETPRIORITY)
      err = setpriority(PRIOR_PROCESS, 0, -10)
    #endif

**全局变量$CFLAGS和$LFLAGS**
如果你有特殊的需要，而这些mkmf的命令无法满足时，你的程序可以直接向全局变量$CFLAGS和$LFLAGS添加选项，这些选项会被分别传入到编译器和链接器。

**mkmf.log**
有时，你创建的extconf.rb好像无法工作。
你提供给它库名，它却断定不存在这样的库。你调整了又调整，mkmf还是无法找到你需要的库。
如果你可以找出幕后发生的确切状况就好了。
你可以！
每次运行extconf.rb脚本时，mkmf会产生一个日志文件，包括了它完成的详细步骤。
如果你查看mkmf.log，会发现程序曾试图查找你所请求库的步骤。
有时候，尝试手工地运行这些步骤，会帮助你解决问题。

**安装目标**
Makefile会包括一个install目标。
它会将你的共享库对象正确地拷贝到你（或用户）的本地文件系统中。
目标与你运行extconf.rb时使用的ruby解释器的安装位置有关。
如果你的系统中安装了多个ruby解释器，扩展会被安装到那个运行extconf.rb的ruby解释器的目录中。
**lib/子目录**
除了安装共享库之外，extconf.rb还会查看是否存在lib/子目录。
如果有它会将这些ruby文件随着共享库一同安装。
如果你将编写扩展的工作分成两部分，包括底层的C代码和高层的Ruby代码时，这是很有用的。

### 21.6.2 静态链接
如果你的系统不支持动态链接，或者如果有一个扩展模块希望静态链接到ruby本身中，编辑ruby发布中的ext/Setup将扩展的目录列表添加到该文件中。
在扩展的目录中，创建一个名为MAINFEST的文件，其中包括扩展的所有文件（源文件、extconf.rb、lib/等等）。
然后重新构建ruby。
Setup中列出的扩展将会被静态地链接到ruby可执行程序中。

如果你想禁止所有的动态链接，并静态地链接所有的扩展，编辑ext/Setup加入下面的选项`option nodynamic`

### 21.6.3 一个捷径SWIG
如果你想扩展一个现有的用C或者C++编写的库，可以调查一下SWIG(www.swig.org)。
SWIG是一个接口生成器：使用库的定义（通常从头文件获得），并自动生成从其他语言访问这个库的粘合代码。
SWIG支持Ruby，意味着它可以生成将外部库包装到ruby类的c源文件。

## 　　21.7　内嵌Ruby解释器
除了通过添加C代码来扩展ruby外，你还可以把问题反过来，并把ruby嵌入到你的应用中。 
<kinder:note> 2版原文：
你有两种方式这样做。

一是通过调用`ruby_run`让解释器得到控制权。
但解释器永远不会从`ruby_run`调用中返回：

    #include "ruby.h"
    int main(void) {
      /* ... our own application stuff ... */
      ruby_init();
      ruby_init_loadpath();
      ruby_script("embedded");
      rb_load_file("start.rb");
      ruby_run();
      exit(0);
    }

为了初始化ruby解释器，你可以调用`ruby_init()`。但在某些平台上，你需要在此之前进行一些特殊的步骤：

    #if defined(NT)
      NtInitialize(&argc, &argv);
    #endif
    #if defined(__MACOS__) && defined(__MWERKS__)
      argc = ccommand(&argv);
    #endif

查看ruby发布的main.c，看看你的平台需要哪些特殊的宏定义或设置。
你需要ruby的头文件和库文件来编译这些潜入的代码。
比如Mac OS X，将ruby1.8 安装到一个私有目录中，所以Makefile：

    WHERE=/Users/dave/ruby1.8/lib/ruby/1.8/powerpc-darwin/
    CFLAGS=-I$(WHERE) -g
    LDFLAGS=-L$(WHERE) -lruby -ldl -lobjc
    embed: embed.o
            $(CC) -o embed embed.o $(LDFLAGS)

第二种潜入ruby的方式是，允许ruby代码和你的C代码交互：C代码调用ruby代码，接着ruby代码做出响应。
和寻常一样初始化解释器，然后不再进入解释器的主循环，调用ruby代码中的特定方法。
当这些方法返回时，C代码取回控制权。
不过，如果ruby代码引发了一个异常而没有被捕捉，那么c程序会退出。
为了克服这一点，需要像解释器那样保护所有可能导致异常的调用。
`rb_protesct`方法可以包装对另一个C函数的调用；后者应该调用我们的Ruby方法。
然而，`rb_protect`包装的方法被定义为只能接受一个参数；要传入多个参数将牵涉到某些丑陋的C转型。

示例：一个简单的类实现了一个方法返回1到max的和。

    class Summer
      def sum(max)
        raise "Invalid maximum #{max}" if max < 0
        (max*max + max)/2
      end
    end

让我们编写一个C程序以让它多次调用这个类的实例。
创建它的实例，需要得到类对象（通过查找一个顶层的常量，其名字也是类的名字）
然后可以让ruby创建这类的实例--实际上`rb_class_new_instance`等同于Class.new（开头两个为0的参数是变量数和指向变量本身的空指针）。
一旦得到这个对象，就可以使用`rb_funcall`调用它的sum方法。

    #include "ruby.h"
    static int id_sum;
    int Values[] = { 5, 10, 15, -1, 20, 0 };
    static VALUE wrap_sum(VALUE args) {
      VALUE *values = (VALUE *)args;
      VALUE summer = values[0];
      VALUE max = values[1];
      return rb_funcall(summer, id_sum, 1, max);
    }
    static VALUE protected_sum(VALUE summer, VALUE max) {
      int error;
      VALUE args[2];
      VALUE result;
      args[0] = summer;
      args[1] = max;
      result = rb_protect(wrap_sum, (VALUE)args, &error);
      return error ? Qnil : result;
    }
    int main(void) {
      int value;
      int *next = Values;
      ruby_init();
      ruby_init_loadpath();
      ruby_script("embedded");
      rb_require("sum.rb");
      // get an instance of Summer
      VALUE summer = rb_class_new_instance(0, 0,
                        rb_const_get(rb_cObject, rb_intern("Summer")));
      id_sum = rb_intern("sum");
      while (value = *next++) {
        VALUE result = protected_sum(summer, INT2NUM(value));
        if (NIL_P(result))
          printf("Sum to %d doesn't compute!\n", value);
        else
          printf("Sum to %d is %d\n", value, NUM2INT(result));
      }
      ruby_finalize();
      exit(0);
    }


<kinder:note> 4版附录：
As of RUby 1.9, you can no longer call `ruby_run` to invoke loaded code.  
到了ruby 1.9， 你可以不用调用`ruby_run`来调用已装载的代码。
Instead, you can call it either via the C API or by evaluating strings.
相反，你既可通过C API来调用它，还可以用求值字符串。

Let’s start with the Ruby program we want to embed. 
让我们从一个要嵌入的ruby程序开始。
Here’s a simple Ruby class that implements a method to return the sum of the numbers from 1 to max:
这是一个简单的ruby类，实现一个方法，返回数字1到max的和。

    # Download ext_ruby/embed/sum.rb
    class Summer
      def sum(max)
        raise "Invalid maximum #{max}" if max < 0
        (max*max + max)/2
      end
    end

Let’s see how to invoke this from a C program.
让我们看看怎么从C程序中调用这个方法。
First we’ll interact by evaluating strings of Ruby code:
首先，我们通过ruby代码的求值字符串进行交互

    # ext_ruby/embed/embed.c
    #include "ruby.h"
    int main(int argc, char **argv) {
      VALUE result;
      ruby_sysinit(&argc, &argv);
      RUBY_INIT_STACK;
      ruby_init();
      ruby_init_loadpath();
      rb_require("sum");         // or sum.rb
      rb_eval_string("$summer = Summer.new");
      rb_eval_string("$result = $summer.sum(10)");
      result = rb_gv_get("result");
      printf("Result = %d\n", NUM2INT(result));
      return ruby_cleanup(0);
    }

To initialize the Ruby interpreter, you need to call `ruby_sysinit()` to pick up command-line arguments used by Ruby, `RUBY_INIT_STACK` to set up the Ruby stack, and `ruby_init` to initialize the interpreter itself.  
要初始化Ruby解释器，你需要调用`ruby_sysinit()`来重新获得ruby使用的命令行参数，调用`RUBY_INIT_STACK`来设置ruby栈，调用`ruby_init`来初始化解释器自身。
The call to `ruby_init_loadpath` adds any directories to be searched for libraries (for example if your RUBYLIB environment variable is set).
`ruby_init_loadpath`的调用添加了任何目录来搜索库（比如，如果设置了你的RUBYLIB环境变量）。

Once this prelude is out of the way, we can start using our external Ruby file.  
一旦这个序幕拉开，我们就可以开始使用我们的外部ruby文件了。
We load it into the interpreter using `rb_require` and then evaluate two lines of code using `rb_eval_string`.  
我们将它导入解释器，使用`rb_require`，然后使用`rb_eval_string`求解代码的两行。
Notice that we assign the results of these two lines to global variables.  
注意我们将这两行的结果赋值给全局变量。
We could also have used instance variables, but globals are easier to manipulate at the top level.  
我们也可使用实例变量，但全局变量更易于在顶部进行计算。
We could not have used local variables: they don’t persist across calls to eval.
我们不能使用局部变量：它们不能跨越调用eval。

Once our sum has been calculated, we need to get it back into our C code.  
一旦我们的总量被计算，我们需要将它回到我们的C代码。
The call to `rb_gv_get` gets the value of a global variable but returns it as a Ruby object.  
`rb_gv_get`调用得到全局变量的值，但以一个ruby对象返回它。
We convert it to a native integer via NUM2INT before printing the result (which is 55).
我们将它转换为一个原生整数，通过NUM2INT，在打印结果之前（就是55）。

In order to compile this code, you need the Ruby include and library files accessible.  
为了编译这个代码，你需要ruby包含文件和库文件都可访问。
When writing this book on my system I have the Ruby 1.9 interpreter installed under rvm, so my Makefile looks like the following.  
当我在系统上写下这本书是，我在rvm下安装了ruby 1.9，所以我的Makefile是这样的。
(Note that Ruby 1.9 changes the location of the ruby.h file.)
（注意ruby 1.9改变了ruby.h文件的位置。）

    # ext_ruby/embed/Makefile
    LIB=/usr/local/rubybook/lib
    INC=/usr/local/rubybook/include/ruby-1.9.0/ruby
    CFLAGS=-I$(INC) -g
    LDFLAGS=-L$(LIB) -lruby -ldl -lobjc
    embed: embed.o
           $(CC) -o embed embed.o $(LDFLAGS)

This kind of hands-off manipulation of Ruby programs from within C code is easy, but it has two major drawbacks.  
从C代码里面的ruby程序的这种非手工的计算是很简单的，但它有两个大的缺点。
First, it’s indirect—we have to keep storing things in globals and extracting the values from these globals out to use them.  
首先，它是间接的--我们只能将存储的东西放在全局变量，并从中解压出来以使用。
Second, we’re not doing any real error checking, which will definitely bite us later.
其次，我们不是做真正的错误检查，这会让我们稍后吃点苦头。

So, the second way to interact with Ruby code is to use the C API.  
所以，第二个和ruby代码交互的方法是使用C API。
This gives us much finergrained control and also lets us handle errors.  
这让我们更有条理地控制，也可处理错误。
You do this by initializing the interpreter as normal.  
你可通过正常初始化解释器来使用。
Then, rather than evaluating strings, you instead invoke specific methods in your Ruby code.  
然后，你在你的ruby代码中调用特定方法，而不是字符串求值。
When these methods return, your C code gets control back.
当这些方法返回时，你的C代码重新得到了控制。

There’s a wrinkle, though.  
虽然有点波折。
If the Ruby code raises an exception and it isn’t caught, your C program will terminate.  
如果ruby代码抛出了一个异常，并且没被捕获，你的C程序将会终结 。
To overcome this, you need to do what the interpreter does and protect all calls that could raise an exception.  
要克服这点，你需要做些解释器做的事情，保护所有会抛出异常的调用。
This can get messy.  
这会变得凌乱。
The `rb_protect` method call wraps the call to another C function.  
`rb_protect`方法调用包装另一个C函数的调用。
That second function should invoke our Ruby method.  
那第二个函数能调用我们的ruby方法。
However, the method wrapped by `rb_protect` is defined to take just a single parameter.  
不过，`rb_protect`包装的方法被定义为只带一个参数。
Passing more involves some ugly C casting.
传递更多引发一些丑陋的C部件。

Let’s look at an example. 
让我们一个例子。
Let’s write a C program that calls an instance of this class multiple times.
写一个C程序，多次调用这个类的一个实例。
To create the instance, we’ll get the class object (by looking for a top-level constant whose name is the name of our class).  
要创建这个实例，我们将获得类对象（通过寻找一个名为类名的顶级常数）。
We’ll then ask Ruby to create an instance of that class— `rb_class_new_instance` is actually a call to Class.new.  
我们将然后请求ruby来创建该类的一个实例--`rb_class_new_instance`实际上是Class.new的调用。
(The two initial 0 parameters are the argument count and a dummy pointer to the arguments themselves.) 
（这两个初始值为0的参数是参数count和一个指向参数自身的虚拟指针。）
Once we have that object, we can invoke its sum method using `rb_funcall`.
一旦我们有了那个对象，我们可以使用`rb_funcall`调用它的sum方法。

    # ext_ruby/embed2/embed2.c
    #include "ruby.h"
    static int id_sum;
    int Values[] = { 5, 10, 15, -1, 20, 0 };
    static VALUE wrap_sum(VALUE args) {
      VALUE *values = (VALUE *)args;
      VALUE summer = values[0];
      VALUE max = values[1];
      return rb_funcall(summer, id_sum, 1, max);
    }
    static VALUE protected_sum(VALUE summer, VALUE max) {
      int error;
      VALUE args[2];
      VALUE result;
      args[0] = summer;
      args[1] = max;
      result = rb_protect(wrap_sum, (VALUE)args, &error);
      return error ? Qnil : result;
    }
    int main(int argc, char **argv) {
      int value;
      int *next = Values;
      int error;
      ruby_sysinit(&argc, &argv);
      RUBY_INIT_STACK;
      ruby_init();
      ruby_init_loadpath();
      ruby_script("demo_embedder"); /* sets name in error messages */
    
      rb_protect((VALUE (*)(VALUE))rb_require, (VALUE)"sum", &error);
    
      // get an instance of Summer
      VALUE summer = rb_class_new_instance(0, 0,
      rb_const_get(rb_cObject, rb_intern("Summer")));
      id_sum = rb_intern("sum");
      while (value = *next++) {
        VALUE result = protected_sum(summer, INT2NUM(value));
        if (NIL_P(result))
          printf("Sum to %d doesn't compute!\n", value);
        else
          printf("Sum to %d is %d\n", value, NUM2INT(result));
      }
      return ruby_cleanup(0);
    }

The ugly part of this code is the `protected_sum` method.  
这个代码的丑陋部分是`protected_sum`方法。
We want to use `rb_funcall` to call the sum method in our Summer object, but `rb_funcall` takes four parameters.  
我们想在Summer对象使用`rb_funcall`来调用sum方法，但`rb_funcall`带了四个参数。
The only way to handle exceptions raised in Ruby code from the C API is to wrap the call to Ruby code using the `rb_protect` method.  
处理ruby代码里从C API抛出的异常的唯一办法，是使用`rb_protect`方法将ruby代码的调用包装起来。
But `rb_protect` wraps only those methods that have the following signature:
但`rb_protect`只会包装有下面签字的方法：

    VALUE *method(VALUE arg)

To work around this, `protected_sum` creates a two-element array containing the parameters it wants to pass to `rb_funcall` and then uses a C cast to fake out that this array is a single VALUE argument.  
要绕开这些，`protected_sum`创建了一个两元素的数组，包含它要传给`rb_funcal`的参数，然后使用一个C铸件来装饰：这个数组是一个单VALUE参数。
The first parameter to `rb_protect` is the name of a proxy method, `wrap_sum`, that unbundles these arguments and the calls `rb_funcall`.  
`rb_protect`的第一个参数是一个代理方法的名称，`wrap_sum`，对这些参数进行分类，并调用`rb_funcall`。
If you do a lot of this kind of work, it would be worthwhile writing a simple wrapper library to simplify this kind of coding.
如果你做了很多这种工作，你将会觉得值得如此付出，来写一个简单的包装库来简化这类编码。

最后：ruby解释器并非为潜入到其他语言而编写。
最大的问题可能是它在全局变量中维护其状态，因此它不是线程安全的。
你可以潜入ruby--每个进程只有一个解释器。

在C++程序中嵌入ruby的一个很好的资源位于http://metaeditor.sourceforge.net/embed/。
这个页面还包括其他潜入ruby示例的链接。

### 21.7.1 API：嵌入RubyAPI
`void ruby_init()` 设置并初始化解释器。这个函数应该在任何相关ruby的函数之前被调用。
`void ruby_init_loadpath()` 初始化$，加在路径变量；如果代码需要加在库模块，则有必要设置它。
`void ruby_options(int argc, char **argv)` 为解释器提供命令行选项。
`void ruby_script(char *name)` 将ruby脚本的名字($0)设置为name。
`void ruby_load_file(char *file)` 将指定的文件加载到解释器中。
`void ruby_run()`  运行解释器。
`void ruby_finalize()` 关闭解释器。

## 　　21.8　将Ruby连接到其他语言（4版附录改为其他环境）
可以用任何语言来编写扩展，只要能将两个语言用c连接起来。
几乎任何事都是可能发生的，包括ruby和c++，ruby和java等的笨拙的联姻。

There’s a bigger story here, though.  
不过，这里有一个更大的故事。
In the past, there was effectively only one Ruby implementation.  
在过去，实际上只有一个ruby实现。
But at the time of writing, we now have a number of alternative implementations.  
但在写的时候，我们现在有了几个可选的实现。
As well as Matz’s original Ruby interpreter (commonly called MRI), there’s JRuby,[2] MacRuby,[3] IronRuby,[4] and Rubinius[5]  (with other implementations waiting in the wings and not yet released).
除了Matz的原始ruby解释（一般称为MRI），还有JRuby，MacRuby， IronRuby和Rubinus（还有其他实现正在开发还没发布）。
[2]. http://jruby.codehaus.org/
[3]. http://macruby.org/
[4]. http://www.ironruby.net/
[5]. http://rubini.us/

So, if you’re looking to integrate Ruby code and Java code, then you should probably consider JRuby.  
因此，如果你在继承ruby代码和Java代码，你可以考虑JRuby。
It allows you to bridge pretty much seamlessly between the two languages.  
它允许你无缝桥接两种语言。
It runs Ruby on Rails and provides adapters so that you can (for example) use existing entity beans as Rails model objects.
它运行ruby on rails，并提供适配器，因此你可（比如）使用已存的beans作为Rails模型对象。

If you want to integrate Ruby into a Microsoft environment, IronRuby gives you an implementation targeted at the DLR, while Ruby.NET targets the CLR.  
如果你想将ruby继承到微软的环境，IronRuby给你一个实现，针对DLR，而Ruby.NET针对CLR。
Similarly, MacRuby would be a natural fit if you want to intregrate with the Cocoa environment on OS X;
类似的，MacRuby可能是一个自然的选择，如果你想OS X里的Cocoa环境集成。

Rubinius is interesting—it uses the original Matz Ruby parser but contains a totally different VM implementation.  
Rubinius是有趣的--它使用原始的Matz ruby解析器，但包含了一个完全不同的虚拟机实现。
Its goal it to have code run so fast that it is possible to write the majority of Ruby’s libraries in Ruby itself (rather than having, for example, the String class written in C, as it is in MRI).  
它的目标是让代码运行的更快，以便用ruby自身写出大多数的ruby库（而不是拥有，比如String类用C来写，正如它在MRI里面）。
Right now, it looks like they might be able to achieve this, which will be a major win for portability and extensibility.
现在，它看起来像是能够达到目标，那将是兼容性和可扩展性的重大胜利。

However, be careful.  
不过，得小心。
Ruby does not really have an official specification, so these implementations may exhibit differing behaviors when dealing with edge conditions.  
ruby没有官方规格，所以这些实现可能表现不同，当我们面对极端条件时。
Also, currently only MRI and MacRuby implement Ruby 1.9.
现在也只有MRI和MacRuby实现了Ruby 1.9.

下面这一段在4版被删除：
你可能完成同样的事而无须诉诸C代码。
例如可以使用中间件，例如SOAP（见前面249页18.5节）或COM（见前面269页Windows自动化），将ruby连接到其他语言。

## 　　21.9　Ruby C语言API
### 概览
有一些C级别的函数，可能发现在编写扩展时它们非常有用。
某些函数需要一个ID，你可以使用`rb_intern`得到某个字符串对应的ID，并使用`rb_id2name`从ID重建这个字符串的名字。

因为大部分C函数在ruby中有对等的方法，并且已经在书中的其他地方详细描述了。这里对她们的描述比较简略。
下面的列表是不完整的。实在因太多而无法全部记录在这里。
如果你需要的函数无法在这里找到，请查看ruby.h或intern.h寻找类似的候选。
而且，在每个源文件的底部或接近底部，是一组描述了从ruby方法到c函数之间绑定的方法定义。
你也可以直接调用c函数，或查找包装了所需调用的函数。

下面的列表，基于READMEEXT中的列表，显示了解释器中的主要源文件。
ruby语言核心

    class.c, error.c, `eval*.c`, gc.c, object.c, parse.y, variable.c

实用函数

    dln.c, regex.c, st.c, util.c
    <kinder:note> 下面是2010年版：
    dln.c , `reg*.c` , st.c , util.c

ruby解释器

    dmyext.c, inits.c, keywords main.c, ruby.c, version.c
    <kinder:note> 下面是2010年版：
    blockinlining.c , compile.c , debug.c , dmy*.c , inits.c , iseq.c , keywords , main.c , ruby.c , version.c , vm*.c

编码和字符集
<kinder:note> 2010年版才加入

    `enc/*`, encording, transcode.c

基础库

    array.c, bignum.c, compar.c, dir.c, enum.c, file.c, hash.c, io.c,
    marshal.c, math.c, numeric.c, pack.c, prec.c, process.c,
    random.c, range.c, re.c, signal.c, sprintf.c, string.c, struct.c,
    time.c
    <kinder:note> 下面是2010年版：
    array.c , bignum.c , compar.c , cont.c , dir.c , enum.c , enumerator.c , file.c , hash.c , io.c , marshal.c , math.c , numeric.c , pack.c , prec.c , process.c , random.c , range.c , re.c , signal.c , sprintf.c , string.c , struct.c , thread*.c , time.c

### 21.9.1  API：定义类
`VALUE rb_define_class( char *name, VALUE superclass )`
用给定的name和superclass定义一个顶层的类（对Object类使用`rb_cObject`）。

`VALUE rb_define_module( char *name )`
用给定的name定义一个新的顶层模块。

`VALUE rb_define_class_under( VALUE under, char *name, VALUE superclass )`
在under类或模块之下定义一个嵌套类。

`VALUE rb_define_module_under( VALUE under, char *name )`
在under类或模块之下定义一个嵌套模块。

`void rb_include_module( VALUE parent, VALUE module )`
将指定的module模块包含到parent类或模块中。

`void rb_extend_object( VALUE obj, VALUE module )`
用module模块扩展obj。

`VALUE rb_require( const char *name )`
等同于require name。返回Qtrue或Qfalse。

### 21.9.2  API：定义结构
`VALUE rb_struct_define( char *name, char *attribute..., NULL )`
用给定的属性定义一个新的结构。

`VALUE rb_struct_new( VALUE sClass, VALUE args..., NULL )`
用给定的属性值创建一个sClass的实例。

`VALUE rb_struct_aref( VALUE struct, VALUE idx )`
返回由idx索引或命名的元素。

`VALUE rb_struct_aset( VALUE struct, VALUE idx, VALUE val )`
设置由idx索引或命名的属性值为val。

### 21.9.3  API：定义方法
在下面的某些方法定义中，参数argc指定ruby方法接受参数的个数。
它可能有下面的值：
<kinder:note> 2版

     argc      函数原型
     0..17     VALUE func(VALUE self, VALUE arg...)   
               使用这么多的实际参数来调用c函数。
     -1        VALUE func(int argc, VALUE *argv, VALUE self)  
               提供给c函数的可变个数参数是以c数组形式传入的。
     -2        VALUE func(VALUE self, VALUE args)
               提供给c函数的可变个数参数是以ruby数组形式传入的。

<kinder:note> 4版附录：
If the value is not negative, it specifies the number of arguments the method takes.  
如果value非负数，它指定了方法所带参数的数目。
If negative, it indicates that the method takes optional arguments.  
如果是负数，它表明方法带有可选参数。
In this case, the absolute value of argc minus one is the number of required arguments 
在这个情况下，argc减一后的绝对值是必要参数。
(so -1 means all arguments are optional, -2 means one mandatory argument followed by optional arguments, and so on).
（所以，-1意味着所有参数都是可选的，-2意味着一个必要参数、其他为可选参数，以此类推）。

在一个接收可变个数参数的函数中，你可以使用C函数`rb_scan_args`来解决问题。

    void rb_define_method( VALUE classmod, char *name,
                           VALUE(*func)(), int argc )

用给定的name在classmod类或者模块中定义一个实例方法，由c函数func实现并接收argc个参数。

    void rb_define_alloc_func( VALUE classmod, VALUE(*func)() )

为classmod标识分配器。

    void rb_define_module_function( VALUE module, char *name,
                                    VALUE(*func)(), int argc) )

用给定的name在module模块中定义一个方法，由c函数func实现并接收argc个参数。

    void rb_define_global_function( char *name, VALUE(*func)(),
                                    int argc )

用给定的name定义一个全局函数（Kernel的私有方法），由C函数func实现并接收argc个参数。

    void rb_define_singleton_method( VALUE classmod, char *name,
                                      VALUE(*func)(), int argc )

用给定的name在类classmod中定义一个单体方法，由C函数func实现并接收argc个参数。

    int rb_scan_args( int argcount, VALUE *argv, char *fmt, ... )

扫描参数列表，并赋值给类似scanf中的变量：fmt是一个字符串，包括0、1或两个数字和后面的标志字符。
第一个数字指明了必需参数的个数。
第二个是可选参数的个数。
`*`意味着将剩余的参数装入到一个ruby数组中。
`&`意味着会传入一个相关联的block，并赋值给制定的参数。如果没有给出代码block，赋值为Qnil。
在fmt之后，给出的若干的VALUE指针（和scanf一样），对应要赋值的参数。

    VALUE name, one, two, rest;
    rb_scan_args(argc, argv, "12", &name, &one, &two);
    rb_scan_args(argc, argv, "1*", &name, &rest);

    void rb_undef_method( VALUE classmod, const char *name )

在给定的classmod类或者模块中，取消给定方法name的定义。

    void rb_define_alias( VALUE classmod, const char *newname,
                          const char *oldname )

为classmod类或模块中的oldname定义一个别名。

### 21.9.4  API：定义变量和常量

    void rb_define_const( VALUE classmod, char *name, VALUE value )

使用给定的name和value定义classmod类或模块中的常量。

    void rb_define_global_const( char *name, VALUE value )

使用给定的name和value定义一个全局常量。

    void rb_define_variable( const char *name, VALUE *object )

将C中创建的object地址以name为符号暴露给ruby命名空间。
从ruby看来，这是一个全局变量，因此name应该以$开头。
切记要尊重ruby允许的变量名规则，违规命名的变量将无法从ruby中访问。

    void rb_define_class_variable( VALUE class, const char *name,
                                   VALUE val )

在指定的class中定义个类变量name（必须以@@为前缀），初始化值为value。

    void rb_define_virtual_variable( const char *name,
                                     VALUE(*getter)(),
                                     void(*setter)() )
将一个虚拟变量以$name暴露到ruby命名空间。
这个变量没有实际的存储；尝试得到或设置这个值，将调用原型如下的指定函数：

    VALUE getter(ID id, VALUE *data,
                 struct global_entry *entry);
    void setter(VALUE value, ID id, VALUE *data,
                struct global_entry *entry);

你可能不需要使用entry参数，并可以安全地在函数声明中忽略它。

    void rb_define_hooked_variable( const char *name,
                                    VALUE *variable,
                                    VALUE(*getter)(),
                                    void(*setter)() )

定义当读写variable时调用的函数。参见前面的`rb_define_virtual_variable`。

    void rb_define_readonly_variable( const char *name,
                                      VALUE *value )

和`rb_define_readonly_variable`类似，但在ruby中是只读的。

    void rb_define_attr( VALUE variable, const char *name, int read,
                         int write )

使用指定的name为指定的variable创建访问方法。
如果read非0,创建一个读取方法；如果write非0,创建一个写入方法。

    void rb_global_variable( VALUE *obj )

将指定的地址注册给垃圾收集器。

### 21.9.5  API：调用方法

    VALUE rb_create_new_instance( (int argc, VALUE *argv, VALUE klass) )
    VALUE rb_class_new_instance( (int argc, VALUE *argv, VALUE klass) )  # 4版附录

返回klass类的一个新实例。argv是argc个参数的数组。

    VALUE rb_funcall( VALUE recv, ID id, int argc, ... )

调用recv对象中由id指定的方法，argc是参数的个数，后面是实际的参数（可能没有参数）。

    VALUE rb_funcall2( VALUE recv, ID id, int argc, VALUE *args )

调用recv对象中由id指定的方法，argc是参数的个数，参数本身保存在c数组args中。

    VALUE rb_funcall3( VALUE recv, ID id, int argc, VALUE *args )

和`rb_funcall2`一样，但不会调用私有的方法。

    VALUE rb_apply( VALUE recv, ID name, int argc, VALUE args )
    VALUE rb_apply(VALUE recv, ID name, VALUE args)   # 4版附录

调用recv对象中由id指定的方法，argc是参数的个数，而参数本身保存在ruby数组的args中。
<kinder:note> 4版附录
Invokes the method given by id in the object recv with the arguments given in the Ruby Arrayargs.
调用对象recv中id指定的方法，带上在Ruby Arrayargs里面指定的参数。

    ID rb_intern( char *name )

返回指定name对应的ID。如果名字不存在，会为它创建一个符号表项(symbol table entry)。

    char * rb_id2name( ID id )

返回指定id的名字。

    VALUE rb_call_super( int argc, VALUE *args )

调用与当前方法同名的超类中的方法。

### 21.9.6  API：异常

    void rb_raise( VALUE exception, const char *fmt, ... )

引发一个exception异常。指定的字符串fmt和余下参数的解释方式与print相同。

    void rb_fatal( const char *fmt, ... )

引发一个Fatal异常，并终止进程。不会调用rescue的block，但ensure block会被调用。
指定的字符串fmt和余下参数的解释方式与print相同。

    void rb_bug( const char *fmt, ... )

立刻终止进程--不会调用任何形式的处理函数。
指定的字符串fmt和余下参数的解释方式与print相同。
你应该只有遇到致命bug才调用这个函数。

    void rb_sys_fail( const char *msg )

使用指定的msg，引发一个特定于平台的异常，对应最后得知的系统错误。

    VALUE rb_rescue( VALUE (*body)(), VALUE args, VALUE(*rescue)(),
                     VALUE rargs )

用给定的args执行body。
如果引发了SandardError异常，则用给定的rargs执行rescue。

    VALUE rb_ensure( VALUE(*body)(), VALUE args, VALUE(*ensure)(),
                     VALUE eargs )

用给定的args执行body。
不管是否引发了异常，在body完成之后，均使用给定的eargs执行ensure。

    VALUE rb_protect( VALUE (*body)(), VALUE args, int *result )
    VALUE rb_protect( VALUE (*body)(), VALUE args, int *state )  # 这是4版附录

用给定的args执行body。
如果期间引发了任何异常，在resualt中返回非0的值。
**1.9**
The value in state corresponds to the various `TAG_xxx` macros.  
state的值对应着不同的`TAG_xxx`宏。
In Ruby 1.9, these are defined in `eval_intern.h` (although there’s a strong argument for moving them to ruby.h, as `eval_intern.h` is not accessible to extension writers).
在ruby 1.9,这些被定义在`eval_intern.h`（虽然很多争论希望将它们移到ruby.h，因为`eval_intern.h`对编写扩展的程序员不可访问）。

    void rb_notimplement( )

引发一个notImpError异常，指示外围的函数没有完成，或者在该平台无法得到。

    void rb_exit( int status )

用指定的status退出ruby。引发一个SystemExit异常，并调用注册的退出函数和完成函数。

    void rb_warn( const char *fmt, ... )

无条件地向标准错误输出发出一个警告信息。
指定的字符串fmt和余下参数的解释方式与printf相同。

    void rb_warning( const char *fmt, ... )

有条件地向标准错误输出发出一个警告消息，如果调用ruby时使用了-w选项。
指定的字符串fmt和余下参数的解释方式与printf相同。

### 21.9.7  API：迭代器

    void rb_iter_break( )

中断外围的迭代器block。

    VALUE rb_each( VALUE obj )

调用指定obj对象的each方法。

    VALUE rb_yield( VALUE arg )

将执行转移到当前上下文的迭代器block，将arg作为参数传入。
多个值可以作为一个数组来传入。

    int rb_block_given_p( )

如果yield可以执行当前上下文的block，则返回true。也就是说，如果当前方法传入一个代码block并可以被调用。

    VALUE rb_iterate( VALUE (*method)(), VALUE args,
                      VALUE (*block)(), VALUE arg2 )

使用参数args和block调用method。
该方法中的yield将使用传给它的参数和第二个参数arg2调用block。

    VALUE rb_catch( const char *tag, VALUE (*proc)(), VALUE value )

等同于ruby的catch。

    void rb_throw( const char *tag , VALUE value )

等同于ruby的throw。

### 21.9.8  API：访问变量

    VALUE rb_iv_get( VALUE obj, char *name )

返回指定对象obj中的实例变量name（必须以@为前缀）。

    VALUE rb_ivar_get( VALUE obj, ID name )
    VALUE rb_ivar_get( VALUE obj, ID id)    # 4版附录

返回指定对象obj中的实例变量name。
<kinder:note> 4版附录：
Returns the instance variable with ID id from the given obj
返回指定对象obj中的实例变量ID id。

    VALUE rb_iv_set( VALUE obj, char *name, VALUE value )

返回指定对象obj中的实例变量name（必须以@为前缀）的值设置为value。返回value。

    VALUE rb_ivar_set( VALUE obj, ID name, VALUE value )
    VALUE rb_ivar_set( VALUE obj, ID id, VALUE value )  #4版附录

将指定对象obj中的实例变量name的值设置为value。返回value。
<kinder:note> 4版附录：
Sets the value of the instance variable with ID id in the given obj to value.
将指定对象obj中的带ID id实例变量的值设置为value。返回value。

 
    VALUE rb_gv_set( const char *name, VALUE value )

将全局变量name（前缀$是可选的）设置为value。返回value。

    VALUE rb_gv_get( const char *name )

返回全局变量name（前缀$是可选的）。

    void rb_cvar_set( VALUE class, ID name, VALUE val )
    void rb_cvar_set( VALUE class, ID id, VALUE val, int unused ) # 4版附录

将指定class中的类变量name设置为value。
<kinder:note> 4版附录：
Sets the class variable with ID id in the given class to value.
将指定class中的ID为id类变量设置为value。

    VALUE rb_cvar_get( VALUE class, ID name )
    VALUE rb_cvar_get( VALUE class, ID id)   # <kinder:note>4版附录

返回指定class中的类变量name。
<kinder:note> 4版附录：
Returns the class variable with ID id from the given class.
返回指定class中的ID id类变量。

    int rb_cvar_defined( VALUE class, ID name )
    int rb_cvar_defined( VALUE class, ID id)

如果class中定义了类变量name，则返回Qtrue；否则返回Qfalse。
<kinder:note> 4版附录：
Returns Qtrue if the class variable with ID id has been defined for class; otherwise, returns Qfalse.
如果class中定义了ID id类变量，则返回Qtrue；否则返回Qfalse。

    void rb_cv_set( VALUE class, const char *name, VALUE val )

将指定class中的类变量name（必须以@@为前缀）设置为value。

    VALUE rb_cv_get( VALUE class, const char *name )

返回指定class中的类变量name（必须以@@为前缀）。

### 21.9.9  API：对象状态

    OBJ_TAINT( VALUE obj )

将给定对象obj标记为tainted。

    int OBJ_TAINTED( VALUE obj )

如果给定的obj是tainted，则返回一个非0值。

    OBJ_FREEZE( VALUE obj )

将给定对象obj标记为被冻结。

    int OBJ_FROZEN( VALUE obj )

如果给定的obj被冻结，返回非0值。

    SafeStringValue( VALUE str )

如果当前的安全级别大于0,并且str是tainted（不可信的），则引发SecurityError异常。
如果str不是`T_STRING`或`$SAFE>=4`，则引发TypeError异常。

    int rb_safe_level( )

返回当前的安全级别。

    void rb_secure( int level )

如果level小于等于当前的安全级别，引发SecurityError异常。

    void rb_set_safe_level( int newlevel )

将当前的安全级别设置为newlevel。

### 21.9.10 API：常用的方法

    VALUE rb_ary_new( )

返回默认大小的新Array。

    VALUE rb_ary_new2( long length )

返回一个长度为length的新Array。

    VALUE rb_ary_new3( long length, ... )

返回一个长度为length的新Array，并用余下的参数填充它。

    VALUE rb_ary_new4( long length, VALUE *values )

返回一个长度为length的新Array，并用C数组的值填充它。

    void rb_ary_store( VALUE self, long index, VALUE value )

将value保存到数组self的index元素中。

    VALUE rb_ary_push( VALUE self, VALUE value )

将value压入看数组self的底部。返回value。

    VALUE rb_ary_pop( VALUE self )

从数组self中删除并返回最后一个元素。

    VALUE rb_ary_shift( VALUE self )

从数组self中删除并返回第一个元素。

    VALUE rb_ary_unshift( VALUE self, VALUE value )

将value压入到数组self的前部。返回value。

    VALUE rb_ary_entry( VALUE self, long index )

返回数组self中第index个元素。

    int rb_respond_to( VALUE self, ID method )

如果self可以响应method，则返回非0值。

    VALUE rb_thread_create( VALUE (*func)(), void *data )

在一个新线程中运行func，将data作为参数传入。

    VALUE rb_hash_new( )

返回一个新的空的Hash。

    VALUE rb_hash_aref( VALUE self, VALUE key )

返回self中与key对应的元素。

    VALUE rb_hash_aset( VALUE self, VALUE key, VALUE value )

设置self中key对应的值。返回value。

    VALUE rb_obj_is_instance_of( VALUE obj, VALUE klass )

如果obj是klass的一个实例，则返回Qtrue。

    VALUE rb_obj_is_kind_of( VALUE obj, VALUE klass )

如果klass是obj的类，或者klass是obj的一个超类，返回Qtrue。

    VALUE rb_str_new( const char *src, long length )

返回一个新的String，用src中length个字符初始化。

    VALUE rb_str_new2( const char *src )

返回一个新的String，用一个null结尾的C字符串src初始化。

    VALUE rb_str_dup( VALUE str )

返回一个从str复制的新String对象。

    VALUE rb_str_cat( VALUE self, const char *src, long length )

将字符串src中length个字符串连到字符串self。返回self。

    VALUE rb_str_concat( VALUE self, VALUE other )

将other串联到字符串self。返回self。

    VALUE rb_str_split( VALUE self, const char *delim )

返回self被delim分隔后得到的一个String对象的数组。
##     2.11  MKMF 参考
详见后面附录B。

# 第3部分　Ruby的核心
# 　第22章　Ruby语言
本章是对ruby语言从头到脚的一个介绍。
大部分内容是语言本身的意义--基本上忽略了内建类和模块（这些内容将在后面的参考资料上详细介绍。2版423页，4版417页）。
有时ruby用库实现的某些特性，对于大多数语言来说可能属于其基本语法。本章也包含了这样的方法，如果必要【第二版：并在页边空白用“库”标出】。
本章的内容看着很面熟，你可以把本章看成是ruby语言核心的完备参考。
## 　　22.1　源代码编排 <kinder:note> 在第四版被拆成两节。
## 　　22.1　源文件编码
Ruby 1.9 programs are by default written in 7-bit ASCII, also called US-ASCII. 
ruby 1.9默认采用7位ASCII，也就所谓US-ASCII。
If a code set other than 7-bit ASCII is to be used, place a comment containing coding: followed by the name of an encoding on the first line of each source file containing non-ASCII characters.
如果使用7位ASCII之外的代码集，要将一个包含`coding: 编码名`的注释放在每个源文件的第一行。
The coding: comment can be on the second line of the file if the first line is a shebang comment. 
`coding:`注释可以在文件第二行，如果第一行是一个`#!`注释。
Ruby skips characters in the comment before the word coding:. 
Ruby跳过注释里`coding:`之前的字符。

Ruby 2 assumes the source is written in UTF-8. 
Ruby 2假设源码是用UTF-8写的。
This assumption can be overridden using the same style coding: comment.
这个假设可以被改写，使用同样风格的`coding:`注释。

    # coding: utf-8
    UTF-8 source...

    # -*- encoding: iso-8859-1 -*-
    ISO-8859-1 source...

    #!/usr/bin/ruby
    # fileencoding: us-ascii
    ASCII source...

## 　　22.2　源代码编排
**基于行**
ruby是基于行的语言。
ruby的表达式和语句都以行尾结束。
除非解析器能够确定语句是不完整的--比如行最后一个符号是操作符或者逗号。
分号可以区分一行中的多个表达式。
也可以在行尾加一个反斜线表示延续到下一行。
注释以#开始，到物理行结束为止。语法分析时注释将被忽略。

ruby会忽略以==begin开头和==end开头的行之间的物理行，可以被用来注释一段代码或者在源文件中嵌入文档。

ruby一次性读入整个程序。所以可以用管道将程序传递给ruby解释器的标准输入流。

    echo 'puts "Hello, World"' | ruby

在源代码的任意位置，如果ruby遇到只有`__END__`且前后没有空格的行，ruby将认为该行是程序的结束。后面的行都不会被当作程序代码。
不过使用全局的IO对象DATA，可以将这些行读入到运行的程序中。详见后面337页（2版315页）的变量和常量一节。

## 22.2.1 BEGIN 和 END Block
ruyb的每个源代码都可以声明，当自己被装载时要执行的代码block（BEGIN block）和程序结束行结束后要执行的block（END block）。
一个程序可以包含多个BEGIN和ENDblock。
BEGIN block的执行顺序和它的出现顺序相同。
END block的执行顺序则和它的出现顺序相反。

### 22.2.2 常规分隔输入
除了常用的引用机制外，还可以用其他形式来表示字符串字面量、字符串和符号的数组、正则表达式和shell命令，这就是常规分隔语法。
所有这些字面量以一个百分号开始，后跟一个指明字面量类型的字符。
下表概述了这些字符：实际的字面量在后面的章节中有相应的描述。

    Type类型                  Meaning含义            Example举例
    %q                       单引号字符串       %q{\a and #{1+2} 是字面}
    %Q, %                    双引号字符串       %Q{\a and #{1+2} 被扩展}
    %w, %W                   字符串数组         %w[ one two three ]
    %i, %I (new in ⇡2.0⇣)    符号数组           %i[ one two three ]
    %r                       正则表达式模式     %r{cat|dog}
    %s(2版也没出现)          符号               %s!a symbol!
    %x                       Shell命令          %x(df -h)

Unlike their lowercase counterparts, %I, %Q, and %W will preform interpolation:
和他们的小字母同伴不同，%I %Q %W将对参数进行扩展修改：

    %i{ one digit#{1+1} three } # => [:one, :"digit\#{1+1}", :three]
    %I{ one digit#{1+1} three } # => [:one, :digit2, :three]
    %q{ one digit#{1+1} three } # => " one digit\#{1+1} three "
    %Q{ one digit#{1+1} three } # => " one digit2 three "
    %w{ one digit#{1+1} three } # => ["one", "digit\#{1+1}", "three"]
    %W{ one digit#{1+1} three } # => ["one", "digit2", "three"]

类型字符后面的是分隔字符，分隔字符可以是任意非字母或非多字节的字符。
如果分隔符是`( [ { <`其中之一，那么从它到对应闭合分隔符之间的字符，属于字面量所有，同时嵌套的分隔符对也考虑在内。
对于其他的分隔符形式，在分隔下一次出现之前的所有字符，属字面量所有。

    %q/this is a string/
    %q-string-
    %q(a (nested) string)

分隔字符可以跨越多行：行结束符以及后续行开始处的空格，都被包含到字符串中：

    meth = %q{def fred(a)
                a.each {|i| puts i }
              end}

## 　　22.2　基本类型
ruby的基本类型包括数字、字符串、数组、散列表、区间、符号和正则表达式。
### 22.2.1 整数和浮点数
**整数**
Ruby的整数是Fixnum类或者Bignum类的对象。
Fixnum对象可以容纳比本机字(native machine word)少一位的整数。
当一个Fixnum超过这个范围时，将会自动转换成Bignum对象。
Bignum对象的表示范围仅受可以内存大小的限制。
如果Bignum对象的操作结果可以用Fixnum表示，结果将以Fixnum类型返回。

整数由一个可选的符号标记、一个可选的进制提示符（0表示八进制，0d表示十进制，0x代表十六进制，0b代表二进制）和一个相应进制的字符串组成。
数字串中的下划线字符将被忽略。

    123456                   => 123456 # Fixnum                       
    0d123456                 => 123456 # Fixnum
    123_456                  => 123456 # Fixnum - 下划线被忽略
    -543                     => -543 # Fixnum - 负数
    0xaabb                   => 43707 # Fixnum - 十六进制
    0377                     => 255 # Fixnum - 八进制
    0o377                    => 255 # Fixnum - 八进制
    -0b10_1010               => -42 # Fixnum - 二进制 (负数的)
    123_456_789_123_456_789  => 123456789123456789 # Bignum

<kinder:note> 下面这一段在第四版被修改后移动到下面“字符串”一节。
因为这2版和4版的表述不同，故抄录如下:
你可以在一个ASCII字符前加一个问号来获得其对应的整数值。
Ctrl组合键字符可以由`?\C-x`和`?\cx`(Ctrl+x的组合键是x&0x9f)来产生。
Meta字符（x | 0x80）可以由`?\M-x`来生成。
Meta和Ctrl的组合键可以由`?\M-\C-x`生成。
使用??\\序列你能得到反斜线字符的整数值。

    ?a         => 97  # ASCII character
    ?\n        => 10  # code for a newline (0x0a)
    ?\C-a      => 1   # control a = ?A & 0x9f = 0x01
    ?\M-a      => 225 # meta sets bit 7
    ?\M-\C-a   => 129 # meta and control a
    ?\C-?      => 127 # delete character

**小数**
一个带有小数点和（或）带有指数的数字字面量被认为是Float对象。
Float对象和本机上的double数据类型大小一样。
小数点后必须跟一个数字，因为像`1.e3`这样的串将试图调用Fixnum类的e3方法。
小数点前至少要有一个数字。

     12.34      # => 12.34
     -0.1234e2  # => -12.34
     1234e-2    # => 12.34

#### 有理数和复数 Rational and Complex Numbers
Classes that support rational numbers (ratios of integers) and complex numbers are built into the Ruby interpreter. 
支持有理数（整数比）和复数的类被内建到ruby解释器里面。
However, Ruby provides no language-level support for these numeric types—there are no rational or complex literals, for example. 
不过，ruby没有对这些数字类型提供语言级的支持。比如，没有相应的字面量。
See the descriptions of Complex on page 451 and Rational on page 656 for more information.
描述详见451页复数和656页的有理数。

### 字符串
ruby提供了多种机制来生成字面量字符串。每种机制都产生String类对象。
不同机制的区别在于如何区分分隔字符串，以及字面量内容会进行哪些替换。
Literal strings are encoded using the source encoding of the file that contains them.
字面量字符串使用包含它们的文件的源编码方式进行编码。

单引号引起来的字符串字面量（例如`'stuff'`和`%q/stuff/`）执行的替换最少。
两者都会将`\\`序列转换为单个反斜线，单引号形式还会将`\'`转换为单引号。
所有其他的反斜线都不会进行替换。

双引号字符串（例如`"stuff"``%Q/stuff/``%/stuff/`）还执行额外的替换。
详见下表 （双引号字符串中允许的替换）：

    \#{code}       Value of code 代码的值   
    \nnn           Octal nnn         八进制nnn
    \x             x               
    \C-x           Control-x       
    \M-x           Meta-x          
    \M-\C-x        Meta-control-x  
    \a             Bell/alert (0x07)   警告铃声
    \b             Backspace (0x08)    回退
    \cx            Control-x         
    \e             Escape (0x1b)       逃脱
    \f             Formfeed (0x0c)     进纸
    \n             Newline (0x0a)      新行
    \r             Return (0x0d)       返回
    \s             Space (0x20)        空格
    \t             Tab (0x09)
    \uxxxx         Unicode character   Unicode字符
    \u{xx xx xx}   Unicode characters  多个Unicode字符
    \v             Vertical tab (0x0b)
    \xnn           Hex nn              十六进制nn

例子：

    a = 123
    "\123mile"                      # => Smile
    "Greek pi: \u03c0"              # => Greek pi: π
    "Greek \u{70 69 3a 20 3c0}"     # => Greek pi: π
    "Say \"Hello\""                 # => Say "Hello"
    %Q!"I said 'nuts'\!," I said!   # => "I said 'nuts'!," I said
    %Q{Try #{a + 1}, not #{a - 1}}  # => Try 124, not 122
    %<Try #{a + 1}, not #{a - 1}>   # => Try 124, not 122
    "Try #{a + 1}, not #{a - 1}"    # => Try 124, not 122
    %{ #{ a = 1; b = 2; a + b } }   # => 3

Last, and probably least (in terms of usage), you can get the string corresponding to an ASCII character by preceding that character with a question mark.
最后，你可以得到字符串相应的ASCII字符，通过前缀问号字符：

    ?a         "a"       ASCII 字符
    ?\n        "\n"      换行(0x0a)
    ?\C-a      "\u0001"  control a (0x65 & 0x9f) == 0x01
    ?\M-a      "\xE1"    meta sets bit 7
    ?\M-\C-a   "\x81"    meta and control a
    ?\C-?      "\u007F"  delete character

<kinder:note> 注意和“整数”一节中第二版的表述做比较。

字符串可以跨行，在这种情况下串中包含换行符。
有可以使用here document来表示很长的字符串字面量。
每当ruby遇到`<<identifier`或者`<<quoted string`时，将用后续的逻辑输入行来生成字符串字面量，知道遇到以`identifier`或者`quoted string`开头的行时才结束。
也可以在`<<`字符紧跟一个减号，让终止符可以从左侧页空白缩进。
如果终止符是由引号括起来的字符串，那么该引号对应的替换规则将被应用到here document，否则使用双引号替换规则。

    print <<HERE
    Double quoted \
    here document.
    It is #{Time.now}
    HERE
    
    print <<-'THERE'
        This is single quoted.
        The above used #{Time.now}
        THERE

    # produces:
    # Double quoted here document.
    # It is 2013-05-27 12:31:31 -0500
    #     This is single quoted.
    #     The above used #{Time.now}

输入中相连的单引号字符串和双引号字符串被连接成一个String对象。

    'Con' "cat" 'en' "ate" # => "Concatenate"

<kinder:note> 下面两行在4版被删除：
字符串被保存在8位字节[1]序列中，每个字节可以含有256个8位值中的任意一个，包括null和换行符。上面表22.2中的替换序列可以让我们方便且可移植地将不可打印字符插入到字符串中。
[1] 为了在日本使用，jcode库支持对EUC SJIS或者UTF-8编码的字符串进行操作。不妥底层的字符串仍作为字节序列被访问。

当字符串字面量用于赋值语句或者作为参数时，一个新的String对象将被创建。

    3.times do
      print 'hello'.object_id, " "
    end
    # 产生：
    70214897722200 70214897722080 70214897721960

后面666页(2版660)开始有String类的详细文档。

### 22.2.2 区间
除了用在条件表达式中，``和``还能构成Range对象。
两个点的形式是闭合区间；三个点的形式是半开闭区间。
详见后面650页（2版597页）对Range的描述。
如果想得到Range的其他用法，参考后面320页（2版342页条件表达式的描述。

### 22.2.3 数组
数组类的字面量是在方括号间由逗号分隔的一连串对象引用组成的。
尾部的逗号将被忽略。
数组也可以用简写形式`%w`和`%W`来构成。
小写字母形式将空格隔开的token提取为连续的数组元素。在单个字符串内不执行行替换。
大写字母形式虽然也把单词列表转换成数组，但对每个词执行和双引号字符串一样的替换规则。
词之间的空格可以用反斜线转移。

    arr = %w( fred wilma barney betty great\ gazoo )
    arr # => ["fred", "wilma", "barney", "betty", "great gazoo"]
    arr = %w( Hey!\tIt is now -#{Time.now}- )
    arr # => ["Hey!\tIt", "is", "now", "-#{Time.now}-"]
    arr = %W( Hey!\tIt is now -#{Time.now}- )
    arr # => ["Hey!  It", "is", "now", "-2013-05-27 12:31:31 -0500-"]

### 22.2.4 散列表
A literal Ruby Hash is created by placing a list of key/value pairs between braces. Keys and values can be separated by the sequence `=>`.  [1]
Hash字面量可以由花括号中的键/值对列表构成，键值对用序列`=>`分隔[1]。
[1]. As of Ruby 1.9, a comma may no longer be used to separate keys and values in hash literals. A comma still appears between each key/value pair.
[1]. 到ruby 1.9为止，hash字面量的键和值可不再用逗号分隔。逗号仍然出现在每个键值对的中间。

    colors = { "red" => 0xf00, "green" => 0x0f0, "blue" => 0x00f }

If the keys are symbols, you can use this alternative notation:
如果键是符号，可以使用这种可选的符号：

    colors = { red: 0xf00, green: 0x0f0, blue: 0x00f }

The keys and/or values in a particular hash need not have the same type.
一个hash里的键和（或）值不要去属于相同类型。

**对散列表键的要求**
散列表键必须能够相应hash消息并返回一个散列码（hash code），且某个键对应的散列码不能改变。
散列表中使用的键也必须能用`eql?`来比较。如果`eql?`在比较两个键时返回真，那么这两个键必定具有相同的散列码。
这意味着某些类（例如数组和散列表）不适于做键，因为它们的hash值可能随内容而发生变化。

如果你保存了键对象的一个外部引用，并使用该引用修改了对象，那么这也修改了它的散列码，进而基于该键的查询将无效。
You can force the hash to be reindexed by calling its rehash method.
你可调用rehash方法强制hash重新索引。

    arr = [1, 2, 3]
    hash = { arr => 'value' }
    hash[arr] # => "value"
    arr[1] = 99
    hash      # => {[1, 99, 3]=>"value"}
    hash[arr] # => nil
    hash.rehash
    hash[arr] # => "value"

因为字符串是最常用的键，且字符串内容会经常变化，所以ruby会对字符串进行特别处理。
如果你使用String对象作为hash键，则hash将在内部复制该字符串，并使该拷贝作为键。
此拷贝被冻结，对原字符串的任意改变都不会影响hash。

如果你实现了自定义的类，并用该类的对象实例作为hash键，那么你需要确保：
a，一旦对象被创建，它的散列码不再改变。
或者b，每当键的散列码发生变化时都调用Hash#rehash方法重新对散列表进行索引。

### 22.2.5 符号
ruby 符号是一个对应字符串（通常是一个名字）的标识符。
你可以通过在名字前加一个冒号来构造该名字的符号，也可以在任意字符串字面量前加一个冒号来创建该字符串的符号。
在双引号字符串中会发生替换。
不管程序如何使用名字，一个具体的名字或字符串总是产生同样的符号。
You can also use the %s delimited notation to create a symbol.
你也可以使用%s分隔符来创建一个符号。

    :Object
    :my_variable
    :"Ruby rules"
    a = "cat"
    :'catsup' # => :catsup
    :"#{a}sup" # => :catsup
    :'#{a}sup' # => :"\#{a}sup"

其他语言称这个过程为interning，而称符号为原子。

### 22.2.6 正则表达式
⇡New in 2.0⇣
Ruby 1.9 uses the Oniguruma regular expression engine. Ruby 2.0 uses an extension of this engine called Onigmo. We show these extensions with the Ruby 2.0 flag.
Ruby 1.9 使用Oniguruma正则表达式引擎。ruby 2.0使用这个引擎的扩展Onigmo。我们用ruby 2.0 表现这个引擎。
See Chapter 7, Regular Expressions, on page 93 for a detailed description of regular expressions.
前面93页的第7章“正则表达式”，有详细的描述。

正则表达式的字面量是Regexp类型的对象。
可以通过调用Regexp.new构造函数显式创建正则表达式，也可以用字面量形式/pattern/和%r{pattern}隐式创建。
%r构造是常规分隔输入的一种形式（详见前面2版303页4版298页）

    /pattern/
    /pattern/options
    %r{pattern}
    %r{pattern}options
    Regexp.new( ’pattern’ ‹ , options › )  
    #注意第二版是 Regexp.new('pattern'[, option])

options is one or more of i (case insensitive), o (substitute once), m (.matches newline), and x (allow spaces and comments). 
选项是一个或多个的i（大小写无关）o（只替换一次）m（.匹配新行）x（允许空格和注释）。
You can additionally override the default encoding of the pattern with n (no encoding-ASCII), e (EUC), s (Shift_JIS), or u (UTF-8).
你可以另外改写模式的默认编码，使用n（无编码-ASCII），e（EUC），s（Shist_JIS），或者u（UTF-8）。

#### 正则表达式选项<kinder:note> 这一节4版被压缩为上面几句了，但这里的表达显然更清晰。
正则表达式可以包含一个或多个选项来修改模式和字符串的匹配方式。
如果你使用字面量来创建Regexp对象，那么一个或者多个字符可以作为选项紧跟在结束符后面。
如果你使用Regexp.new，那么这些选项是作为构造函数中第二个参数的若干常量。
i
大小写无关。模式匹配将忽略模式和字符串中字符的大小写。
通过设置`$=`来使匹配大小写无关的方式已经过时了。
o
替换一次。正则表达式的任意#...替换仅在一次求解它的时候执行替换；否则，替换在每次字面量生成Regexp对象时执行。
m
跨行模式。通常“.”匹配换行符之外的任意字符。使用/m选项，“.”将匹配任意字符。
x
扩展模式。复杂的正则表达式可读性较差。x选项允许你向模式中插入空格、换行符和注释，以提高它的可读性。

还有另外一组选项可以设置正则表达式的语言编码。
如果没有这些选项，那么将使用解释起的默认编码（可以用-K或者$KCODE设置）：
n 没有编码（ASCII）；e EUC；s SJIS；u UTF-8

#### 正则表达式模式
⇡New in 2.0⇣ 
(This section contains minor differences from previous versions of this book. Ruby 1.9 uses the Oniguruma regular expression engine.) [2]
(这一节包含了和本书之前版本的细微差别。ruby 1.9 使用Oniguruma正则表达式引擎)
[2]. Some of the information here is based on http://www.geocities.jp/kosako3/oniguruma/doc/RE.txt.
这里的一些信息基于http://www.geocities.jp/kosako3/oniguruma/doc/RE.txt.

⇡New in 2.0⇣ 
An asterisk at the end of an entry in the following list means that the match is extended beyond ASCII characters if Unicode option is set.
下面列出的每条的尾部的星号，意思是，如果设置了Unicode选项，匹配被扩展到ASCII字符之外。

characters
All except . | ( ) [ \ ^ { + $ * and ? match themselves. 
除了. | ( ) [ \ ^ { + $ * ?之外的其他字符，匹配自身。
To match one of these characters, precede it with a backslash.
要匹配这些字符，可前缀一个反斜线。

\a \cx \e \f \r \t \unnnn \v \xnn \nnn \C-\M-x \C-x \M-x
Match the character derived according to Table 11, Substitutions in double-quoted strings, on page 300.
根据前面300页“基本类型”中双引号字符替换表,匹配字符。

^, $ 
Match the beginning/end of a line.
匹配行头和行尾。

\A, \z, \Z
Match the beginning/end of the string. \Z ignores trailing \n.
匹配字符串的开头或结尾。\Z忽略尾部的\n。

\d, \h 
Match any decimal digit or hexadecimal digit ([0-9a-fA-F]).  *
匹配任何十进制数字或十六进制数字（[0-9a-fA-F]）。

\s 
Matches any whitespace character: tab, newline, vertical tab, formfeed, return, and space.  *
匹配任何空白符：tab符，换行符，垂直tab符，进纸符，返回符，空白符。

\w 
Matches any word character: alphanumerics and underscores.  *
匹配任何单词字符：字母和下划线。

\D, \H, \S, \W
The negated forms of \d, \h, \s, and \w, matching characters that are not digits, hexadecimal digits, whitespace, or word characters.  *
\d, \h, \s, \w的否定形式，匹配非数字、非十六进制数字、空白、单词字符。

\b, \B 
Match word/nonword boundaries.
匹配单词或非单词边界。

\G 
The position where a previous repetitive search completed.
之前重复性搜索完成的位置。
<kinder:note> 2版补充：
锚点\G用在全局匹配方法String#gusb、String#gsub!、String#index和String#scan中。
在重复匹配中，它代表字符串内迭代中最后一个匹配结束的位置。
开始时\G指向字符串开始的位置（或者String#index第二个参数引用的字符）。

    "a01b23c45 d56".scan(/[a-z]\d+/)    → ["a01", "b23", "c45", "d56"]
    "a01b23c45 d56".scan(/\G[a-z]\d+/)  → ["a01", "b23", "c45"]
    "a01b23c45 d56".scan(/\A[a-z]\d+/)  → ["a01"]

<kinder:note> ？？

\K 
Discards the portion of the match to the left of the \K.
丢弃匹配\K的左边的一部分。
<kinder:note> ？？

\R 
⇡New in 2.0⇣
A generic end-of-line sequence.  *
一个一般的行尾序列。

\X 
⇡New in 2.0⇣
A Unicode grapheme.  *
一个Unicode字形。

\p{property}, \P{property}, \p{!property}
⇡New in 2.0⇣
Match a character that is in/not in the given property (see Table 4, Unicode character properties, on page 114).
匹配在或不在指定属性的字符。(参见前面114页表格4,Unicode字符属性)

. (period，句点)
Appearing outside brackets, matches any character except a newline. (With the /m option, it matches newline, too).
出现在方括号外面，匹配换行符以外的任意字符（如果指定了/m选项，它也可以匹配换行符）。

[characters]
Matches a single character from the specified set. See Character Classes, on page 98.
从指定字符集中匹配单个字符。见前面98页的字符类。

re* 
Matches zero or more occurrences of re.
匹配0个或多个re。

re+ 
Matches one or more occurrences of re.
匹配1个或多个re。

re{m,n} 
Matches at least m and at most n occurrences of re.
匹配最少m个、最多n个re。

re{m,} 
Matches at least m occurrences of re.
匹配最少m个re。

re{,n} 
Matches at most n occurrences of re.
匹配最多n个re。

re{m} 
Matches exactly m occurrences of re.
匹配刚好m个re。

re? 
Matches zero or one occurrence of re.
匹配0个或1个re。
The ?, *, +, and {m,n} modifiers are greedy by default. Append a question mark to make them minimal, and append a plus sign to make them possessive (that is, they are greedy and will not backtrack).
默认情况下，? * + {m,n}修饰符都是最长匹配的。在后面加上一个问号使得他们执行最短匹配；在后面追加一个加号使得他们私有（就是最长匹配又不回溯）。

re1 | re2
Matches either re1 or re2.
匹配re1或者re2.
<kinder:note> 2版补充：|的优先级很低。

(...) 
Parentheses group regular expressions and introduce extensions.
圆括号将正则表达式进行分组并引入扩展。

#{...} 
Substitutes expression in the pattern, as with strings. By default, the substitution is performed each time a regular expression literal is evaluated. With the /o option, it is performed just the first time.
替换模式中的表达式，就像字符串那样。默认情况下，每次求解正则表达式时都执行该替换。如果设置了/o选项，则仅在第一求解时替换。

\1, \2, ... \n
Match the value matched by the nth grouped subexpression.
替换第n组子表达式的值。
<kinder:note> 这第一个Match是笔误吧，应是substitute吧？

(?# comment)
Inserts a comment into the pattern.
插入注释到模式中。
<kinder:note> 2版补充：当模式匹配时，其中的内容将被忽略。

(?:re) 
Makes re into a group without generating backreferences.
使re成为组，但不产生向后引用。
<kinder:note> 下面是2版补充：
当想对结构进行分组，但又不想为该组产生$1或者任何其他特殊变量时很有用。
下面例子中的两个模式都能匹配用冒号或者空格分隔年月日的日期。
第一种形式存储分隔字符在$2和$4中；而第二个模式根本不在外部变量中存储这些分隔符。

    date = "12/25/01"
    date =~ %r{(\d+)(/|:)(\d+)(/|:)(\d+)}
    [$1,$2,$3,$4,$5] → ["12", "/", "25", "/", "01"]
    date =~ %r{(\d+)(?:/|:)(\d+)(?:/|:)(\d+)}
    [$1,$2,$3] → ["12", "25", "01"]

(?=re), (?!re)
Matches if re is/is not at this point but does not consume it.
re在或不在该点时匹配，但不消耗匹配。
<kinder:note> 2版补充：
(?=re)
也被称为零宽度正向查看。
这可以让你向前寻找一个匹配的上下文而不影响$&。

    str = "red, white, and blue"
    str.scan(/[a-z]+(?=,)/) → ["red", "white"]

(?!re)零宽度正向查看
例如/hot(?!dog)(\w+)/与含有字符dog且后不跟dog的词向匹配，并将词的结尾部分保存到$1中。

`(?<=re), (?<!re)`
Matches if re is/is not before this point but does not consume it.
如果re在或没有在该点之前，则匹配；但不消耗它。

(?>re)
Matches re but inhibits subsequent backtracking.
匹配re，但抑制后面的回溯。
<kinder:note> 2版补充：
在当前锚点的一个正则表达式中嵌套一个独立的正则表达式。
被其耗用的字符，就不会被上层的正则表达式访问到。
因此这个结构可以抑制回溯，从而提高性能。
例如模式`/a.*b.*a/`在匹配含有一个a后跟多个b但不以a结尾的字符串时，需要指数级时间复杂度。
不过有时候这可以通过使用嵌套的正则表达式`/a(?>,*b).*a/`来避免。
在这种形式中，嵌套的表达式就耗用掉所有的输入字符直到最后一个可能的b。
当检查尾部a匹配失败时，就没有必要回退，并且模式匹配将迅速以失败告终。
（当匹配不应当直接查到最后一个b时，这个模式和原来的模式有不同的语义）

    require 'benchmark'
    include Benchmark
    str = "a" + ("b" * 5000)
    bm(8) do |test|
      test.report("Normal:") { str =~ /a.*b.*a/ }
      test.report("Nested:") { str =~ /a(?>.*b).*a/ }
    end
    # produces:
    #          user       system    total      real
    # Normal:  1.090000   0.000000  1.090000 ( 1.245818)
    # Nested:  0.000000   0.000000  0.000000 ( 0.001033)

<kinder:note> ??

(?adimux), (?-imx)
Turn on/off the corresponding a, d, i, m, u, or x option. If used inside a group, the effect is limited to that group.
打开或关闭对应的a d i m u x选项。如果用在组中，则只影响该组。

(?adimux:re), (?-imx:re)
⇡New in 2.0⇣
Turn on/off the i, m, or x option for re.
为re打开/关闭i m x选项。

\n, \k'n', and \k<n>th
The n captured subpattern.
第n个捕获的子模式。

(?<name>...) or (?'name'...)
Name the string captured by the group.
命名分组捕获的字符串。

\k<name> or \k'name'
The contents of the named group.
命名分组的内容。

\k<name>+/-n or \k'name'+/-n
The contents of the named group at the given relative nesting level.
命名分组在某个指定相对嵌套级别上的内容。

\g<name> or \g<number>
Invokes the named or numbered group.
调用命名分组或编号分组

## 　　22.3　名字
Ruby名字用来引用常量、变量、方法、类和模块。
名字中的第一个字符帮助ruby区分它的用法。

某些名字，如下表所示，是**保留字**，不能将它们用作名字。

    __ENCODING__ __FILE__ __LINE__ BEGIN END alias and begin
    break case class def defined? do else elsif end
    ensure false for if in module next nil not
    or redo rescue retry return self super then true
    undef unless until when while yield 

后面4版323页2版345页开始的章节里有方法名的详细描述。
**名字字符**
In these descriptions, uppercase letter means A through Z, and digit means 0 through 9. 
在下面的描述中，大写字母指A到Z；数字指0到9；小写字母指a到z，以及下划线（_）。
Low- ercase letter means the characters a through z, as well as the underscore (_). 
In addition, any non-7-bit characters that are valid in the current encoding are considered to be lowercase.[3]
另外，在当前编码里有效的任何非7位字符都被视为小写字母。
[3].Such names will not be usable from other source files with different encoding.
这样的名字对其他使用不同编码的源文件而言是没有用处的。

一个**名字**是一个大写字母、小写字母或者下划线，后跟任意个命名用字符：大写字母、小写字母、下划线或数字的任意组合。

**局部变量名**：小写字母和命名用字符。通常使用下划线来书写含有多个词的名字。但解释器并不强制要求：`fred anObject _x three_two_one`

**实例变量名**：以@开始，后跟一个名字（用小写字母是不错的做法）。如`@name @_ @size`

**类变量名**：以@@开始，后跟一个名字。如`@@name @@_ @@Size`

**常量名**：以一个大些字母开始，后跟多个命名用字符。
类名字和模块名字都是常量，所以遵守常量的命名传统。
习惯上，常量对象引用一般由大写字母和下划线组成，而类和模块名字是MixedCase。

    module Math
      ALMOST_PI = 22.0/7.0
    end
    class BigBlog
    end

**全局变量**，以及一些特殊的系统变量，由美元符（$）后跟命名用字符组成。
此外，Ruby还定义了一组由两个字母组成的全局变量名，其中第二个字符是一个标点符号。
从2版333页4版311页“预定义变量”节开始有这些预定义变量的详细列表。
最后，全局变量名也可以由$-后跟一个字符或者下划线组成。
后面的这些变量通常用来反映命令行选项的相应设置（详见后面2版335页的表格4版313页执行环境变量）：`$params $PROGRAM $! $_ $-a $-k`

### 22.3.1 变量/方法二义性
在表达式中，ruby看到像a这样的名字时，它需要判断a是个局部变量引用还是对没有参数的方法a的调用。
ruby使用一种启发式的方法来判断这种情况。
当ruby解析源代码文件时，会记录所有已经被赋值的符号。它认为这些符号是变量。
以后遇到一个既可以是变量又可以是方法调用的符号时，ruby会检查是否已经对该符号进行了赋值。
如果是，那么把该符号当作变量，否则当作方法调用。
下面是描述这种情况的一个人为设计的例子，由Clemens Hintze提供。

    def a
      puts "Function 'a' called"
      99
    end
    for i in 1..2
      if i == 2
        puts "i==2, a=#{a}"  # 第一个puts
      else
        a = 1
        puts "i==1, a=#{a}"  # 第二个puts
      end
    end
    # produces:
    # i==1, a=1
    # Function 'a' called
    # i==2, a=99

当解析的时候，ruby看到第一个puts语句使用了a，并且由于还没有遇到对a的任何赋值语句，所以把它当作方法调用。但是解析第二个puts语句时，由于ruby遇到了对a的一个赋值语句，所以把它当作变量。
<kinder:note> 真是很奇怪，首先执行第二个puts的时候，不是看到a的赋值了吗？怎么到了第一个puts就翻脸不认人了！是我的理解那里出错了吗？还有输出中的这个`Function 'a' called`是在哪一行什么时候激发的？

注意赋值语句不一定被执行--只要ruby看过它了就可以。下面的程序不会导致错误：
a = 1 if false; a  #=> nil 

## 　　22.4　变量和常量
ruby的变量和常量含有对象的引用。

变量本身没有内在的类型。变量的类型仅仅由变量引用的对象所能响应的消息决定。[4]
[4]. 当我们说变量没有类型的时候，是指任意一个变量都能在不同时候引用不同类型的对象。
ruby常量也是对对象的引用。常量在它第一次被赋值的时候创建（通常在类或模块中定义）。和不灵活的语言不同，Ruby允许你改变常量的值，尽管这会导致警告。

    MY_CONST = 1
    puts "First MY_CONST = #{MY_CONST}"
    MY_CONST = 2
    # 产生一个警告但仍然将 MY_CONST 设置为 2。
    puts "Then MY_CONST = #{MY_CONST}"
    # produces:
    # prog.rb:4: warning: already initialized constant MY_CONST
    # prog.rb:1: warning: previous definition of MY_CONST was here
    # First MY_CONST = 1
    # Then MY_CONST = 2

注意尽管应该不改变常量的值，但可以改变它所引用的对象的内部状态。
Note that although constants should not be changed, you can alter the internal states of the objects they reference (you can freeze objects to prevent this). 
(你可以通过冻结对象来预防这一点)。
This is because assignment potentially aliases objects, creating two references to the same object.
这是因为赋值潜在地为对象定义别名，创建两个引用到同一个对象。

    MY_CONST = "Tim"
    MY_CONST[0] = "J"  # 通过对象改变字符串的引用
    print MY_CONST   # => "Jim"

### 22.4.1 常量和变量的作用域
在类或者模块内的任意位置都可以直接访问此类或模块中定义的**常量**。
在类或者模块外，可以通过域作用符::前面加上一个返回适当类或模块对象的表达式来访问。
不属于任何类或者模块的常量，可以直接访问或者使用不带前缀的域作用符来访问。
常量可以在方法体外定义。通过在常量名之前使用类或模块名和域作用符，还可以将常量从外面添加到已存的类或模块中。

    OUTER_CONST = 99
    class Const
      def get_const
        CONST
      end
      CONST = OUTER_CONST + 1
    end
    Const.new.get_const # => 100
    Const::CONST # => 100
    ::OUTER_CONST # => 99
    Const::NEW_CONST = 123

**全局变量**是贯穿整个程序的变量。
每次对某个特定全局名字的引用总返回一个对象。引用一个未被初始化的全局变量将会返回nil。

**类变量**是贯穿类或者模块体的变量。它必须在使用之前初始化。
一个类变量被类的所有实例所共享，且只在类中可以使用。

    class Song
      @@count = 0
      def initialize
        @@count += 1
      end
      def Song.get_count
        @@count
      end
    end

类变量属于包含该变量的最内层的类或者模块。
在顶层使用的类变量在Object内中定义，这种类变量类似于全局变量。
在singleton方法中定义的类变量属于顶层类（尽管这种使用方式已经过时了，如果你用这种方式，会产生警告）。
在Ruby 1.9中，类变量被认为是所定义类的私有变量，即使看起来有些漏洞，就像下例所展示的：
 In Ruby 1.9, class variables are supposed to be private to the defining class, although as the following example shows, there seems to be some leakage.

    class Holder # => prog.rb:13: warning: class variable access from toplevel
      @@var = 99
      def Holder.var=(val)
        @@var = val
      end
      def var
        @@var
      end
    end
    @@var = "top level variable"
    a = Holder.new
    a.var # => "top level variable"  # 注意2版这一行的结果是：99
    Holder.var = 123
    a.var # => 123

类变量被定义该变量的类的所有子类所共有。

    class Top
      @@A = "top A"
      @@B = "top B"
      def dump
        puts values
      end
      def values
        "#{self.class.name}: @@A = #@@A, @@B = #@@B"
      end
    end
    class MiddleOne < Top
      @@B = "One B"
      @@C = "One C"
      def values
        super + ", C = #@@C"
      end
    end
    class MiddleTwo < Top
      @@B = "Two B"
      @@C = "Two C"
      def values
        super + ", C = #@@C"
      end
    end
    class BottomOne < MiddleOne; end
    class BottomTwo < MiddleTwo; end
    Top.new.dump
    MiddleOne.new.dump
    MiddleTwo.new.dump
    BottomOne.new.dump
    BottomTwo.new.dump
    # produces:
    # Top: @@A = top A, @@B = Two B    
    # <kinder:note> 因为@@B是顶层的类变量，所以@@B以后面子类的赋值为准？因此这里不等于"top B"。这真是没有想到！
    # MiddleOne: @@A = top A, @@B = Two B, C = One C 
    # MiddleTwo: @@A = top A, @@B = Two B, C = Two C
    # BottomOne: @@A = top A, @@B = Two B, C = One C
    # BottomTwo: @@A = top A, @@B = Two B, C = Two C

I recommend against using class variables for these reasons.
我认为不要因为这些理由使用类变量。

**实例变量**可以被类内的所有实例方法使用。
引用一个未初始化的实例变量会返回nil。
类的每个实例都有一组独特的实例变量。
<kinder:note> 下面一句4版删除：
类方法中不能使用实例变量（尽管类和模块中也可以有实例变量。参考后面2版388页）

**局部变量**的独特之处在于它们的作用域是静态确定的，然而却是动态创建的。
局部变量是在程序执行时为其第一次赋值的时候动态创建的。
然而，局部变量的作用域却是静态确定的，其作用域是最内层的block、方法定义、类定义、模块定义或者顶层程序。
引用一个在作用域内但未创建的局部变量会产生NameError异常。
如果同名的局部变量不在同一个作用域内，那么它们是不同的变量。

方法参数是局部于其方法的变量。

blck参数在执行block时被赋值。

<kinder:note> 这一段采用4版的表述：
If a local variable is first assigned in a block, it is local to the block.
如果局部变量是在block内第一次被赋值的，那么它是该block的局部变量。
If a block uses a variable that is previously defined in the scope containing the block’s definition, then the block will share that variable with the scope. 
如果block使用的变量是在前面包含block定义的作用域内定义的，那么block将在该作用域内共享该变量。
There are two exceptions to this. 
不过还是有两个例外。
Block parameters are always local to the block. 
block参数总是局限于那个block。
In addition, variables listed after a semicolon at the end of the block parameter list are also always local to the block.
另外，block参数尾部用分号列出的变量也总是局限于那个block。

    a = 1
    b = 2
    c = 3
    some_method { |b; c| a = b + 1; c = a + 1; d = c + 1 }

In this previous example, the variable a inside the block is shared with the surrounding scope. 
在上面这个例子中，block内的变量a是和周围的作用域共享的。
The variables b and c are not shared, because they are listed in the block’s parameter list, and the variable d is not shared because it occurs only inside the block.
而变量b和c没有共享，因为它们在block参数列表列出；而变量d没有被共享是因为它只出现在block里面。

block可以使用在它创建时已经存在的局部变量。这形成绑定的一部分。
注意，尽管此时变量的帮顶是固定的，但在执行的时候，block可以方法这些变量的当前值。
即使原本外围的作用域被销毁了，绑定依然会保持这些变量。

while，until和for循环体和循环体外的代码属于同一作用域：前面已经存在的局部变量可以在循环中使用，而且新建的任意局部变量也可以在循环体后继续使用。

### 22.4.2  预定义变量
标记
在以下的描述中，符号（r/o）表示变量是只读的，如果程序试图修改只读变量将会出现错误。而且，你可能不想在执行程序的半途中改变true的意思。
带有[thread]标记的变量是局部于线程的变量。

名字
许多全局变量看起来有点怪：例如`$_, $!, $&`等等。
这是有历史原因的：这类变量大多数来自Perl。
如果你觉得很难记住这些标点，可以看看2版671页4版749页名为Enlish的库文件，该库文件为常用的全局变量提供了更具描述性的名字

在下面的变量和常量表中，列出了变量名字，所引用的对象类型一些描述。

异常信息

`$!`  `$ERROR_INFO`         异常    [thread]
传递给raise的异常对象。

`$@`  `$ERROR_POSITION`      数组    [thread]
最后一个异常产生时的调用栈。详见2版518页的Kernel#calller。

模式匹配变量
这些变量（除了`$=`）在模式匹配失败后被设置为nil。

`$&`  `$MATCH`       字符串  [r/o,thread]
匹配的字符串（匹配成功之后）。
此变量局部于当前作用域。

`$+`  `$LAST_PAREN_MATCH`       字符串   
成功模式匹配产生的最高序号的组的内容。例如，在"cat" =~ /(c|a)(t|z)/中，`$+`为”t“。这个变量局部于当前作用域。

``$```  `$PREMATCH`     字符串   [r/o,thread] 
匹配字符串之前的串。
这个变量局部于当前作用域。

`$'`  `$POSTMATCH`       字符串   [r/o,thread] 
匹配字符串之后的串。
这个变量局部于当前作用域。

`$=`  `$IGNORECASE`       Object   
过时的用法。如果设置为除了nil或false之外的任意值，所有的模式匹配将会大小写无关，字符串比较将忽略大小写，而且字符串的hash值也会忽略大小写。
<kinder:note> 4版补充：
变量$=已经在ruby1.9被删除。

`$1`到`$9`   字符串    [r/o,thread]
模式匹配中连续匹配的组的内容。
这些变量局部于当前作用域。

`$~`  `$LAST_MATCH_INFO`       MatchData    [thread]
一个封装成功匹配结果的对象。
变量``$& $` $' $1 .. $9``都是从`$~`中派生的。
对`$~`的赋值会改变这些派生变量的值。
这个变量局部于当前作用域。

输入/输出变量
`$/`  `RS``$INPUT_RECORD_SEPARATOR`  字符串
输入记录分隔符（默认为换行符）。
像Kernel#gets这样的例程用该值来区分记录边界。如果设置为nil，gets将读入整个文件。

`$-0`    字符串
上面`$/`的同义词。

`$\`  `$ORS``$OUTPUT_RECORD_SEPARATOR`  字符串
附加到方法调用（例如Kernel#pring和IO#write）的输出结果的字符串。
默认值是nil。

`$,`  `$OFS``$OUTPUT_RECORD_SEPARATOR`  字符串
像Kernel#print，Array#join这样的方法的参数输出时的分隔字符串。
默认值是nil，不添加任何文本。

`$.`  `$NR`  Fixnum
从当前输入文件中读入的最后一行的行号。

`$;`  `$FS``$FIELD_SEPARATOR`  字符串
String#split使用的默认分隔模式。
也可以在命令行用-F选项设置。

`$<`  `$DEFAULT_INPUT`  ARGF.class    [r/o]
见前面213页“AFGF”一节。
<kinder:note> 4版的描述。
<kinder:note> 2版的描述如下：
`$<`    Object    [r/o]
一个可以访问作为命令行参数给出或者`$stdin`（当没有参数的时候）给出的所有文件的内容对象。
它支持的方法和File对象类似：binmod, closed?, each, each_bytes, each_line, eof, eof?, file, filename, fileno, getc, gets, lineno, lineno=, path, pos, pos=, read, readchar, readline, readlines, rewind, seek, skip, tell, to_a, to_i, to_io, to_s以及Enumerable中的方法。
file方法返回表示当前正在读的文件的File对象。返回的对象可能会改变，因为`$<`会依次读取命令行给出的文件。

`$>`  `$DEFAULT_OUTPUT`  IO
Kernel#print和Kernel#printf的输出目标。
默认值是`$stdout`

`$_`   `LAST_READ_LINE` 字符串    [thread]
Kernel#gets或Kernel#readline读入的最后一行。
在Kernel模块中很多字符串相关的函数默认情况下都是对`$_`操作。
这个变量局部于当前作用域。

`$defout`    IO
和`$>`同义，已经弃用。使用`$stdout`替代。
<kinder:note> 4版补充：这个变量在ruby 1.9被删。

`$deferr`    IO
和`$STDERR`同义。已被弃用。使用`$stderr`替代。
<kinder:note> 4版补充：这个变量在ruby 1.9被删。

`$-F`    字符串
和`$;`同义。

`$stderr`    IO
当前标准错误输出。

`$stdin`    IO
当前标准输入。

`$stdout`    IO
当前标准输出。
<kinder:note> 下面一句4版删除：
对$stdout赋值的用法已经过时，使用$stdout.reopen替代。

执行环境变量
`$0`    字符串
被执行的ruby程序的名字。
通常是程序的文件名。
在一些操作系统中，对此变量赋值会改变ps(1)命令报告的进程名字。

`$*`    数组    [r/o]
一个包含调用程序时给出的命令行选项的字符串数组。
被ruby解释器使用的选项已经被删除。

`$"`  `$LOADED_FEATURES`  数组    [r/o]
一个包含reuire装载的文件名或模块名的数组。

`$$`  `$PID``$PROCESS_ID`  Fixnum    [r/o]
被执行程序的进程号。

`$?`  `$CHILD_STATUS`    Process:Status    [r/o,thread]
最后一个终止的子进程的退出状态。

`$:`    数组    [r/o]
一个字符串数组。
laod和require方法在每个字符串指定的目录中搜索ruby脚本和二进制扩展。
初始值为-I命令行选项传入的参数，后跟安装时定义的标准库的路径、当前路径(".")。
As of Ruby 1.9.2, the current directory is no longer added to $:. 
到了ruby 1.9.2,当前目录不再被添加到`$:`。
在程序中可以重新设置此变量的值以调整默认搜索路径；通常，程序使用`$: << dir`以将dir添加到路径中。

`$-a`    Object    [r/o]
如果命令行中给出了-a选项，则为真。
<kinder:note> -a选项是自动拆分模式。
自动拆分模式将在各个循环前执行`$F = $_.split`

`__callee__`    符号
The name of the lexically enclosing method.
词法上封闭方法的名字。

`$-d`    Object
$DEBUG的同义词。

`$DEBUG`    Object
如果命令行给出-d选项，则为真。

`__ENCODING__`   字符串    [r/o]
The encoding of the current source file.
当前源文件的编码。

`__FILE__`    字符串    [r/o]
当前源文件的名字。

`$F`    数组
如果使用-a命令行选项，则此数组表示分隔的输入行。

`$FILENAME`    字符串    [r/o]
如果输入文件的名字。等价于``$<.filename``

`$-i`    字符串
如果启动了in-place编辑模式（可能使用了-i命令行选项），则`$-i`保存了用来保存备份文件的扩展。
如果设置一个值给`$-i`，则将启用in-place编辑模式。详见前面2版178页”14.1命令行参数“。

`$-I`    数组    [r/o]
与`$:`同义。

`$-K`    字符串
设置字符串和正则表达式的多字节编码系统。
等价于-K命令行参数。详见前面2版178页”14.1命令行参数“。

`$-l`    Object    [r/o]
如果命令行给出了-l选项（启动lined-den处），则为真。详见前面2版178页”14.1命令行参数“。

`__LINE__`    字符串    [r/o]
源代码文件中当前行的行号。

`$LOAD_PATH`    数组    [ro]
与`$:`同义。

`$LOADED_FEATURES`    数组    [ro] → Array
Synonym for `$"`.
与`$"`同义。

`__method__`    符号
The name of the lexically enclosing method.
词汇上封闭方法的名字。

`$PROGRAM_NAME`    字符串
Alias for `$0`.
`$0`的别名。

`$-p`    Object    [ro]
如果命令行中有-p选项（该选项将程序置于一个隐含的while gets~end循环中），则为真。
详见前面2版178页”14.1命令行参数“。

`$SAFE`    Fixnum    thread
当前安全级别（详见2版398页）
不能用赋值语句来减少该变量的值。

`$VERBOSE`    Object
如果命令行中给出了-v，--version，-W或者-w选项则为真。
如果没有这些选项，或者有-w1,则为假。
如果有-W0选项则为nil。
将此选项设置为真将使得解释器和一些库例程输出更多额外信息。
设置为nil将禁止所有警告。（包括Kernel.warn的输出，4版改为“包括Object#warn的输出”）。

`$-v`    Object
与$VERBOSE同义。

`$-w`    Object
与$VERBOSE同义。

$-W    Object
Return the value set by the -W command-line option.
返回-W命令行选项设置的值。

标准对象
ARGF    Object
Provides access to a list of files. Used by command line processing. See ARGF, on page 213.
提供访问文件列表。命令行处理使用。见前面4版”ARGF“
<kinder:note> 2版表述：
与`$<`同义。

ARGV    数组
与`$*`同义。

ENV    Object
一个类似于hash的包含程序环境变量的对象。
类Object.ENV的实例实现了Hash的所有方法。
该对象可以用来查询和设置环境变量的值。例如`ENV["PATH"]`和`ENV["term"] = "ansi"`

false    FalseClass    [ro]
类FalseClass的Singleton实例。

nil    NilClass    [ro]
类NilClass的Singleton实例。
表示未初始化的实例变量和全局变量的值。

self    Object    [ro]
当前方法的接收者（对象）

true    TrueClass    [ro]
类TrueClass的Singleton实例。

### 22.4.3 全局变量
Ruby解释器定义的全局变量：

`DATA`    IO
如果主程序文件含有`__END__`指令，那么常量DATA将会被初始化为源代码中`__END__`的行。

`FALSE`    FalseClass
和false同义。

`NIL`    NilClass
有nil同义。

`RUBY_COPYRIGHT`    字符串
The interpreter copyright.
解释器的版权。

`RUBY_DESCRIPTION`    字符串
Version number and architecture of the interpreter.
解释器架构的版本号。

`RUBY_ENGINE`    字符串
The name of the Ruby interpreter. Returns "ruby" for Matz’s version. Other interpreters include macruby, ironruby, jruby, and rubinius.
ruby解释器的名字。
Matz的版本返回ruby。
其他解释器包括macruby ironruby,jruby,rubinius。

`RUBY_PATCHLEVEL`    字符串
The patch level of the interpreter.
解释器的补丁级别。

`RUBY_PLATFORM`    字符串
运行程序的平台标志符。
这个字符串和GNU configure工具用的平台标志符有相同的形式（并不完全一致）。

`RUBY_RELEASE_DATE`    字符串
版本发布的日期。

`RUBY_REVISION`    字符串
The revision of the interpreter.
解释器的修订号。

`RUBY_VERSION`    字符串
解释器的版本号。

`STDERR`    IO
程序实际的标准错误流。初始值为`$stderr`

`STDIN`    IO
程序实际的标准输入流。初始值为`$stdin`

`STDOUT`    IO
程序实际的标准输出流。初始值为`$stdout`

`SCRIPT_LINES_`    散列表
如果常量`SCRIPT_LINES_`被定义，并引用一个Hash，那么ruby会保存它解析的每个文件的内容为Hash的一项。键是文件的名字而值是一个字符串数组。
详见后面2版528页Kernel.require的实例。

`TOPLEVEL_BINDING`    Binding
一个Binding对象表示在ruby顶层上的绑定--程序被初始化执行的层次。

`TRUE`    TrueClass
与true同义。
常量`__FILE__`和常量`$0`常常被合用，以使得仅当文件直接由用户执行时才运行文件中的代码。
例如库程序员经常需要在库中加入一些测试代码，且当库代码被直接运行时才运行这些测试代码，而库被装载入其他程序时则不运行测试代码。

    # Library code
    # ...
    if __FILE__ == $0
      # tests ...
    end

## 　　22.5　表达式
**表达式中的术语**可以是下面任意一个：

 - 字面量
ruby字面量可以是数字、字符串、数组、散列表、区间、符号和正则表达式。详见前面2版319页22.2“基本类型”。

 - Shell命令
shell命令是封装在反引号之间字符串或以%x开头的常规分隔字符串（详见前面“常规分隔输入”一节）。
字符串的值是在宿主操作系统的标准shell上运行字符串表示的命令标准输入。
执行后也会将命令的退出状态保存在$?变量中。

    filter = "*.c"
    files = `ls #{filter}`
    files = %x{ls #{filter}}

 - 符号产生器 <kinder:note> 这一个在4版中删去。
符号对象是通过在操作符、字符串、变量、常量、方法、类或模块名字前加一个冒号生成的。
对应不同名字的符号对象是唯一的。但它并不指向名字的具体实例。所以不管上下文是什么，符号例如:fred都是同一个。符号和其他高级语言的原子概念很相似。

 - 变量引用或常量引用
变量通过使用其名字来引用它。
根据作用域的不同（见前面22.4.1“变量和常量的作用域”），常量可以通过使用名字来引用，也可以使用包含此常量的类或者模块名字加域操作符(::)来引用。

 - 方法调用
见后面22.7“调用方法”有方法调用的各式各样方式的描述。

### 22.5.1 操作符表达式
表达式可以用操作符来组合。如下表。
“方法”栏有`✓`标记的是由方法来实现的，可以被改写。

方法   操作符                     描述
✓      [ ] [ ]=                   引用元素、设置元素
✓       **                        求幂
✓      ! ~ + -                    非、求补、一元加或一元减（最后两个方法的方法名为`+@``-@`）
✓      * / %                      乘除和求模
✓      + -                        加减
✓      >> <<                      右移和左移
✓      &                          与（对整数是一位一位地操作）
✓      ^ |                        异或和或（对整数是一位一位地操作）
✓      <= < > >=                  比较操作符
✓      <=> == === != =~ !~        等于和模式匹配操作符（`!=``!~`可能不是作为方法定义的）
       &&                         逻辑与
       ||                         逻辑或
       .. ...                     区间（包含边界和不包含边界）
       ?:                         三元操作符if～then～else
       = %= /= -= += |= &= >>=    赋值运算符。
       <<= *= &&= ||= **= ^=
       defined?                   检查符号是否被定义。<kinder:note> 4版删除。
       not                        逻辑非
       or and                     逻辑比较
       if unless while until      表达式修饰符
       begin/end                  Block表达式

### 22.5.2 关于赋值的更多内容
赋值操作符将一个或者多个rvalue（r表示右，因为右值倾向于出现在赋值语句的右边）赋给一个或者多个lvalue（左值）。赋值的意义依赖于每个单独的左值。

    a = /regexp/
    b, c, d = 1, "cat", [3, 4, 5]

如果左值是一个对象属性，那么接收对象中对应的属性设置函数将被调用，并以右值作为参数。

    class A
      attr_writer :value
    end
    obj = A.new;
    obj.value = "hello" # 等同于obj.value = ("hello")

如果左值是数组元素引用，ruby将调用接收对象的元素赋值操作符（[]=），并以方括号的下标和右值为参数：

    元素引用                       实际方法调用
    var[] = "one"                  var.[ ]=("one")
    var[1] = "two"                 var.[ ]=(1, "two")
    var["a", /^cat/ ] = "three"    var.[ ]=("a", /^cat/, "three")

赋值表达式本身的值是它的右值。即使是对返回不同值的属性方法赋值，也是如此。

#### 并行赋值
赋值表达式可以有一个或者多个左值，也可以有一个或者多个右值。

  1. If any rvalue is prefixed with an asterisk and implements `to_a`, the rvalue is replaced with the elements returned by `to_a`, with each element forming its own rvalue.
如果任何一个右值前面有一个星号，且实现了`to_a`，那么该右值将被`to_a`返回的元素取代，每个元素形成一个独立的右值。

 2. If the assignment contains one lvalue and multiple rvalues, the rvalues are converted to an array and assigned to that lvalue.
如果赋值语句包含一个左值和多个右值，右值被转化为一个数组并赋值那个左值。

 3. If the assignment contains multiple lvalues and one rvalue, the rvalue is expanded if possible into an array of rvalues as described in (1).
如果赋值语句含有多个左值和一个右值，右值如果可能将扩展为右值的一个数组，就像（1）所描述的那样。
<kinder:note> 这个规则该是拼写错误吧？

 4. Successive rvalues are assigned to the lvalues. This assignment effectively happens in parallel so that (for example) a,b=b,a swaps the values in a and b.
连续的右值赋值给左值。这种赋值其实是并行进行的，所以（例如）a,b=b,a将交换a和b的值。

 5. If there are more lvalues than rvalues, the excess will have nil assigned to them.
如果有左值个数多于右值个数，超出的部分被赋值为nil。

 6. If there are more rvalues than lvalues, the excess will be ignored.
如果左值个数少于右值个数，超出的部分将被忽略。

 7. At most one lvalue can be prefixed by an asterisk. This lvalue will end up being an array and will contain as many rvalues as possible. If there are lvalues to the right of the starred lvalue, these will be assigned from the trailing rvalues, and whatever rvalues are left will be assigned to the splat lvalue.
大多数情况，一个左值可被前缀以星号。这个左值将结束为一个数组，并将包含尽量多的右值。如果还有左值在缀星左值的右边，将被赋值为尾部的右值，无论剩下多少右值，将被赋值给那个左值。

 8. If an lvalue contains a parenthesized list, the list is treated as a nested assignment statement, and then it is assigned from the corresponding rvalue as described by these rules.
如果一个左值包含括号引用起来的列表，则此列表被当作嵌套赋值语句，而且应用这些规则来根据相应的右值进行赋值。

See Parallel Assignment, on page 130 for examples of parallel assignment. The value of a parallel assignment is its array of rvalues.
详见前面"并行赋值"一节的例子。
并行赋值的值是其右值的数组。

###22.5.3 Block表达式

    begin
      body
    end

表达式可以成组地放入begin和end之间。
Block表达式的值是最后一个表达式的值。
Block表达式在异常处理中也起作用，后面22.13“异常”一节会有讨论。

### 22.5.4 布尔表达式
ruby预定义了全局的false和nil。
在布尔表达式上下文中，这两个都被当作假。所有其他值都被当作真。
当你需要使用显式真值时，可以使用true常量。
#### 与、或、非
and和&&操作符先求解它们的第一个操作数，如果为假，返回第一个操作数的值；否则返回第二个操作数的值。

or和||操作符符先求解它们的第一个操作数，如果为真，返回第一个操作数的值；否则返回第二个操作数的值。

not和!操作符符先求解它们的操作数的值，如果为真，返回假，如果为假，返回真。
<kinder:note> 4版删除2版的这一句：
由于历史的原因，字符串、正则表达式或者range不能作为not或者!的参数。

这些操作符的单词形式比相应的符号形式优先级低。详见前面的22.4。

#### defined?
defined?操作符的参数可以是任意表达式，如果这个参数未定义，则defined?返回nil。否则，将返回参数的一个描述。详见前面7.4 条件执行的例子。

#### 比较操作符
ruby的语法定义了比较操作符：`==, ===, <=>, <, <=, >, >=, =~`

所有这些操作符都是由方法来实现的。
习惯上，ruby语言也使用标准方法eql?和equal?（参见前面表7.1）
尽管这些操作符的意义很直观，但其比较语义是由实现它们的类来决定的。
从后面2版423页开始的库文档阐述了内置类的比较语义。

依据`<=>`，模块Comparable为实现操作符`==, <, <=, >, >=`和方法between?提供了支持。
操作符===被用在case表达式中，详见后面22.5.7case表达式。

==和=～都有相反的形式!=和!~。在语法分析中，ruby会对它们进行转换：`a != b`映射为`!(a = b)`，而`a !~ b`映射为`!(a =~ b)。
没有和!=和!~相对应的方法。

#### 布尔表达式中的Range

    if expr1 .. expr2
    while expr1 ... expr2

在布尔表达式中使用的range具有双态触发器(flip-flop)的行为。
它有两种状态：开和关，而且初始状态是关。

1. For the three-dot form of a range, if the flip-flop is unset and expr1 is true, the flip-flop becomes set and the the flip-flop returns true.
对于三点形式的区间，如果双态触发器关闭，expr1为真，双态触发器会变成开，返回真。

2. If the flip-flop is set, it will return true. However, if expr2 is not true, the flip-flop becomes unset.
如果双态触发器为开，会返回真。不过，如果expr2不为真，双态触发器会变成关。
<kinder:note> 这和2版的表述不同：
每调用一次range变迁一次状态。

3. If the flip-flop is unset, it returns false.
如果双态触发器关闭，将返回假值。

The first step differs for the two-dot form of a range. If the flip-flop is unset and expr1 is true, then Ruby only sets the flip-flop if expr2 is not also true.
区间的两点形式第一步是不同的。
如果双态触发器关闭，并且expr1为真，如果expr2也不为真，ruby会开启双态触发器。

下面的代码说明了这些差别：

    a = (11..20).collect {|i| (i%4 == 0)..(i%3 == 0) ? i : nil} 
    a # => [nil, 12, nil, nil, nil, 16, 17, 18, nil, 20]
    a = (11..20).collect {|i| (i%4 == 0)...(i%3 == 0) ? i : nil}
    a # => [nil, 12, 13, 14, 15, 16, 17, 18, nil, 20]
      # 这是一个三点形式的区间。开始关，1）1=11时，不能被4整除，所以为关（返回nil）。
                                        2）12时，可被4和3整除，开（返回i）。
                                        3）13，不能被4整除，也不能被3整除，那就应该关啊。怎么回事啊！

<kinder:note> 好吧。这个触发器是什么东东？一点头绪都没有。网上的大牛说那是电学里的JK触发器。
http://lilydjwg.is-programmer.com/2012/3/24/flip-flop-in-ruby-jk-latch.32635.html

uby 中 flip-flop 表达式的真谛：JK 触发器

依云 posted @ 大约 1 年前 in 编程 with tags ruby 数字电路 , 1711 阅读

本文来自依云's Blog，转载请注明。

今天看 Matz 的《Ruby编程指南》，遇到一个被称为「flip-flop」的奇特表达式：

    在一个由条件式或循环所构成的上下文中，一个 flip-flop 由两个通过..操作符相连的布尔表达式构成。除非其左侧表达式为 true，否则一个 flip-flop 表达式就是 false，而且在左侧表达式为 true 之前，它的值都会是 false。一旦该表达式为 true ，那么它就会“flips”到一个持久的 true 状态。它会保持该状态，而且对其后续的求值也返回 true，直到其右侧表达式成为 true 为止。如果其右侧表达式为 true 了，那么该 flip-flop 就会“flops”回一个持久的false状态，对其后续的求值也返回false，直到其左侧表达式再次成为 true 为止。
    ...
    Flip-flop 是一个非常晦涩的 Ruby 特性，因此最好不要在你的代码中使用它。但是它们并不是 Ruby 所独有的，Ruby 从 Perl 那里继承了这个特性，而 Perl 则从 Unix 的文本处理工具 sed 和 awk 那里继承了这个特性（注4）。Flip-flop 的初衷是在一个开始模式和一个结束模式之间匹配一个文本文件的行，而且这仍然是使用它们的有效方式。下面的这个简单的 Ruby 程序展示了一个 flip-flop，它逐行地从一个文本文件中读取内容，打印出含有“TODO”的行。它会不断地打印文本行，直到读入一个空行为止：

    1    ARGF.each do |line|  # For each line of standard in or of named files         
    2      print line if line=~/TODO/..line=~/^$/ # Print lines when flip-flop is true
    3    end

作者还说"很难正式地描述一个 flip-flop 的精确行为"。但我不这么认为。

我想到了学习数字电路时遇到的各种触发器，于是乎，反复读了几次以上描述确定了 flip-flop 的行为到底如何后，列出了它的真值表，其中 A、B 为点两边的表达式的值（输入），Q 为其内部状态，Qn 就是 Qnext。
1   A   B   Q   Qn
2   0   0   0   0
3   0   0   1   1
4   0   1   0   0
5   0   1   1   0
6   1   0   0   1
7   1   0   1   1
8   1   1   0   1
9   1   1   1   0

然后和那些触发器的真值表对照，赫然发现它就是JK 触发器——
1   J   K   Q   Qn
2   0   0   0   0
3   0   0   1   1
4   0   1   X   0
5   1   0   X   1
6   1   1   0   1
7   1   1   1   0
看来 Matz 没学过数字电路 ;-)
PS: flip-flop 在电子电路中就是「触发器」的意思。。。

#### 布尔表达式中的正则表达式
ruby 1.8之前，布尔表达式中的单个正则表达式将会和变量`$_`的当前值进行匹配。
现在只有在命令行-e参数中出现的条件中才支持这种行为。

    $ ruby -ne 'print if /one/' testfile
    This is line one

在通常的代码中，对隐含操作符和`$_`的使用已经慢慢废止了，所以最好使用匹配变量的显式匹配。
<kinder:note> 2版还有：
如果需要匹配`$_`，则使用

    if ~/re/ ...
    # 或者 if $_ =~ /re/ ...

### 22.5.5 if和unless表达式

    if boolean-expression ‹ then ›
      body
    ‹ elsif boolean-expression ‹ then ›
      body ›*
    ‹ else
      body ›
    end

    unless boolean-expression ‹ then ›
      body
    ‹ else
      body ›
    end

关键字then将代码体和条件分隔开来。
如果代码体和条件不再一行，则不需要。
无论哪个代码体被执行，if或者unless表达式的值是最后一个被执行的表达式的值。
[4] Prior to Ruby 1.9, you could use a colon instead of then. This is no longer supported.
ruby 1.9之前，可以用冒号来替代then。这个特性不再支持了。

#### if和unless修饰符

    expression if boolean-expression
    expression unless boolean-expression

仅当布尔表达式为真(对if)或者假(对unless)时，才求解表达式

### 22.5.6 三元运算符 ternary operator

    boolean-expression ? expr1 : expr2

如果布尔表达式为真，则返回expr1，否则返回expr2。

### 22.5.7 case表达式
ruby有两种形式的case语句。
第一种会求解一系列条件的值，并执行一个为真的条件对应的代码。

    case
    when ‹ boolean-expression ›+ ‹ then ›
      body
    when ‹ boolean-expression ›+ ‹ then ›
      body
      ...
    ‹ else
      body ›
    end

第二种在case关键后面有一个目标表达式。它从第一个（左上）comparison开始，通过执行`comparison === target`寻找一个匹配。

    case target
    when ‹ comparison ›+ ‹ then ›
      body
    when ‹ comparison ›+ ‹ then ›
      body
      ...
    ‹ else
      body ›
    end

比较目标可以是跟在星号后的一个数组引用，在这种情况下，在执行测试之前，数组会扩展成其元素。
当比较返回真时，停止搜索，并执行与该比较目标相关联的代码体（不需要break）。
然后case返回执行的最后一个表达式的值。
如果没有comparison匹配：如果有else从句，则执行else代码，否则返回nil。

then关键字分隔when比较目标和它的代码体，如果代码体从新行开始，则不需要then。
As an optimization in Matz’s Ruby 1.9 and later, comparisons between literal strings and between numbers do not use ===.
从ruby 1.9开始，字面量字符串之间的比较、数字之间的比较不使用`===`。
<kinder:note> 使用eql?吗？

### 22.5.8 循环 loops
只要布尔表达式为真，则一直执行循环体
只要布尔表达式为假，则一直执行循环体

上面两种形式，do将布尔表达式和循环体分隔开，如果循环体在陵一行上，可以省略它们。
for循环的执行很像下面的each循环，除了在for循环体中定义的局部变量在循环体外仍旧可以使用，而在迭代block中定义变量在循环体外无效。

loop，迭代执行与之相关的block，不是一个语言结构--它是Kernel模块中定义的一个方法。

    loop do
      print "Input: "
      break unless line = gets
      process(line)
    end

#### while和until修饰符

    expression while boolean-expression
    expression until boolean-expression

如果表达式不是begin/end block，则只有布尔表达式为真（对while）或假（对until）就一直执行表达式。
如果表达式是begin/end block，则block至少会被执行一次。

#### break redo next retry <kinder:note> retry在4版删除
[5]. The retry keyword is no longer permitted in a loop context.
retry关键字不再允许放在循环环境中。

break redo next会改变while until for或者迭代器控制的循环正常执行流程。
break终止直接封装它的循环--控制会转到block后面的语句。
redo从头重新执行循环，但并不重新求解条件表达式或取迭代器的下一个元素。
next关键字跳到循环体的末尾，相当于开始下一次迭代。

break和next可以有一个或多个可选的参数。
如果break和next在block中，则给定的参数作为yield的值返回。
如果用在while until和for循环中，传递给break的值将作为本语句的值返回，而传给next的值将被忽略。
如果根本没有调用break，或者调用了它但没有参数值，则循环返回nil。

    match = for line in ARGF.readlines
              next if line =~ /^#/
              break line if line =~ /ruby/
            end

<kinder:note> 2版还有一个例子：

    match = while line = gets
              next if line =~ /^#/
              break line if line =~ /ruby/
            end

## 　　22.6　方法定义
**方法定义的形式**

    def defname ‹ ( ‹ , arg ›* )
      body
    end
    ›

    defname ← methodname | expr.methodname

<kinder:note> 下面是2版的表述,相对而言上面4版的更简洁：

    def defname [ ( [ arg [ =val ], ... ] [ ,
      body
    end

    defname ← methodname
              constant.methodname
              (expr).methodname

defname既是方法的名字，也是其所处的合法的上下文的名字。

methodname既可以是重定义的操作符（详见前面表22.4）,也可以是名字。
如果methodname是个名字，那么它应当以一个小写字母（或者下划线）开头，后面可以跟大写或小写字母、下划线和数字。
methodname还可以以问号(?)、感叹号(!)和等于号(=)结尾。
问号和感叹号仅仅是名字的一部分；等于号也是名字的一部分，但也表明该方法可以用作左值（参见前面3.1.2 可写属性）。

在类和模块定义外，由普通方法名定义的方法将作为私有方法加入到类Object中，因此无须指定显式的接收者家可以在任意上下文中调用它。

使用expr.methodname形式作为方法名，将创建一个与表达式引用的对象相关联的方法：该方法只能通过以表达式引用的对象作为接收者来调用。
这种定义风格将创建单个对象的方法或单例(singleton)方法。
You’ll find it most often inside class or module definitions, where the expr is either self or the name of the class/module. This effectively creates a class or module method (as opposed to an instance method).
你会发现它最常出现在类或模块定义的内部，expr是自身或类/模块的名字。这有效创建一个类或模块方法（相对于实例方法）。

    class MyClass
      def MyClass.method # definition 定义
      end
    end
    
    MyClass.method # call 调用
    
    obj = Object.new # definition 定义
    def obj.method 
    end 
    obj.method # call 调用

    def (1.class).fred  # receiver may be an expression 接收者可以是一个表达式
    end 
    Fixnum.fred # call 调用

方法定义可能不包含类或模块定义。
它们可以含有嵌套的实例或者单例方法定义。
当执行外部方法时，内部的方法被定义。
在被嵌套方法的上下文中，内部方法不是一个闭包--它是自包含的。
<kinder:note>真是匪夷所思，虽然不懂得什么叫做“自包含”

    def toggle
      def toggle
        "subsequent times"
      end
      "first time"
    end
    toggle  # => "first time"       这就是"执行外部方法时，内部的方法被定义"
    toggle  # => "subsequent times" 所以这里就开始执行内部方法
    toggle  # => "subsequent times"

方法体的行为如同是一个begin/end的block，其中可能包括异常处理的语句（rescue else ensure）

### 22.6.1 方法参数
New in 2.0⇣
A method definition may have zero or more regular arguments, zero or more keyword arguments, a optional splat argument, an optional double splat argument, and an optional block argument. 
方法定义可以含有零或多个普通参数，零或多个关键字参数，一个可选的splat参数，一个可选的双splat参数，和一个可选的block参数。
参数之间用逗号分隔，而且参数列表可以用括号括起来。

**普通参数**
普通参数是一个局部变量，后可跟一个等于号和作为默认值的表达式。
表达式在方法被调用的时候被求解。表达式是从左到右求解的。
表达式可以引用参数列表中它前面已定义的参数（parameter，形参）。

    def options(a=99, b=a+1)
      [ a, b ]
    end
    options        # => [99, 100]
    options(1)     # => [1, 2]
    options(2, 4)  # => [2, 4]

As with parallel assignment, one of the arguments may start with an asterisk. 
和并行赋值一样，其中有一个参数可能用星号开始。
If the method call specifies any parameters in excess of the regular argument count, all these extra parameters will be collected into this newly created array.
如果方法调用指定了任何超过普通参数个数的形参，所有这些额外的形参将被收集到这个新创建的数组。

    def varargs(a, *b)
      [ a, b ]
    end
    varargs(1) # => [1, []]
    varargs(1, 2) # => [1, [2]]
    varargs(1, 2, 3) # => [1, [2, 3]]

This argument need not be the last in the argument list. See the description of parallel assignment to see how values are assigned to this parameter.
这个参数不需要在参数列表的最后位置。
参见前面并行赋值的描述，看看数值怎么赋给这个参数。

    def splat(first, *middle, last)
      [ first, middle, last ]
    end
    splat(1, 2) # => [1, [], 2]
    splat(1, 2, 3) # => [1, [2], 3]
    splat(1, 2, 3, 4) # => [1, [2, 3], 4]

如果数组参数跟在带有默认值的参数后面，那么参数将优先被用来改写默认值。剩下的参数将会用来形成数组。

    def mixed(a, b=99, *c)
      [ a, b, c]
    end
    mixed(1)          # =>  [1, 99, []]
    mixed(1, 2)       # =>  [1, 2, []]
    mixed(1, 2, 3)    # =>  [1, 2, [3]]
    mixed(1, 2, 3, 4) # =>  [1, 2, [3, 4]]

#### 关键字参数 Keyword Arguments
⇡New in 2.0⇣
Ruby 2 methods may declare keyword arguments using the syntax `name: default_value` for each. 
Ruby 2的方法可声明关键字参数，使用语法`名字: 默认值`。
These arguments must follow any regular arguments in the list.
这些参数必须在列表中跟在任何普通参数后面。

    def header(name, level: 1, upper: false)
      name = name.upcase if upper
      "<h#{level}>#{name}</h#{level}>"
    end
    header("Introduction") # => "<h1>Introduction</h1>"
    header("Getting started", level:2) # => "<h2>Getting started</h2>"
    header("Conclusion", upper: true) # => "<h1>CONCLUSION</h1>"

If you call a method that has keyword arguments and do not provide corresponding values in the method call’s parameter list, the default values will be used. 
如果你调用一个有关键字参数的方法，但方法调用的参数列表中不提供相应的值，将使用用默认值。
If you pass keyword parameters that are not defined as arguments, an error will be raised unless you also define a double splat argument, `**arg`. 
如果你传递的关键字参数被没有定义为参数，将抛出一个错误，除非你也定义了一个双plate参数`**arg`。
The double splat argument will be set up as a hash containing any uncollected keyword parameters passed to the method.
双plat参数将被设置为一个hash，包含任何传递给方法的未收集的关键字变量。

    def header(name, level: 1, upper: false, **attrs)
      name = name.upcase if upper
      attr_string = attrs.map {|k,v| %{#{k}="#{v}"}}.join(' ')
      "<h#{level} #{attr_string}>#{name}</h#{level}>"
    end
    header("TOC", class: "nav", level:2, id: 123)

<kinder:note> 不懂。

#### block参数
可选的block参数必须在列表的最后。
不管方法何时被调用，ruby检查关联的block。
如果存在block，它会被转化为一个Proc类的对象，并赋值给block参数。
如果不存在block，参数会被设置为nil。

    def example(&block)
      puts block.inspect
    end
    example
    example { "a block" }
    # produces:
    # nil
    # #<Proc:0x007fb2230004d8@prog.rb:6>

#### 撤销一个方法 Undefining a Method
The keyword undef allows you to undefine a method.
关键字undef允许你撤销一个方法。

    undef name | symbol ...

An undefined method still exists; it is simply marked as being undefined. 
一个被撤销的方法仍然存在，只是被标记为被撤销。
If you undefine a method in a child class and then call that method on an instance of that child class, Ruby will immediately raise a NoMethodError—it will not look for the method in the child’s parents.
如果你在一个子类中撤销了一个方法，然后在那个子类的实例调用那个方法，ruby会马上抛出一个NoMethodError--它将不会在父类中查找该方法。

## 　　22.7　调用方法
**一般形式**

    ‹ receiver. ›name‹ parameters › ‹ {block} ›
    ‹ receiver:: ›name‹ parameters › ‹ {block} ›

    parameters ← ( ‹ param ›* ‹ , hashlist › ‹ *array › ‹ &a_proc › )

    block ← { blockbody } or do blockbody end

**参数**
The parentheses around the parameters may be omitted if it is otherwise unambiguous.
参数周围的括号可被忽略，如果没有其他的误会。

Initial parameters are assigned to the actual arguments of the method. 
开头的形参将被赋值给方法的实际参数。
Following these parameters may be a list of key => value or key: value pairs. 
这些形参后面可以有一个key => value或者key: value对.
These pairs are collected into a single new Hash object and passed as a single parameter.
这些对将被收集到一个新的Hash对象，并作为一个形参传入方法。

**缀星参数**
Any parameter may be a prefixed with an asterisk. 
无论哪个形参都可能前缀星号。
If a starred parameter supports the `to_a` method, that method is called, and the resulting array is expanded inline to provide parameters to the method call. 
如果缀星的形参支持`to_a`方法，该方法被调用，结果的数组被行内扩展，以提供参数到方法调用中。
If a starred argument does not support `to_a`, it is simply passed through unaltered.
如果缀星的参数不支持`to_a`方法，它将只被原封不动地传过去。

    def regular(a, b, *c)
      "a=#{a}, b=#{b}, c=#{c}"
    end
    regular 1, 2, 3, 4                        # => a=1, b=2, c=[3, 4]
    regular(1, 2, 3, 4)                       # => a=1, b=2, c=[3, 4]
    regular(1, *[2, 3, 4])                    # => a=1, b=2, c=[3, 4]
    regular(1, *[2, 3], 4)                    # => a=1, b=2, c=[3, 4]
    regular(1, *[2, 3], *4)                   # => a=1, b=2, c=[3, 4]
    regular(*[], 1, *[], *[2, 3], *[], 4)     # => a=1, b=2, c=[3, 4]

**双splat参数**
⇡New in 2.0⇣
Any parameter may be prefixed with two asterisks (a double splat). 
无论哪个参数都可能前缀双星（双splat）。
Such parameters are treated as hashes, and their key-value pairs are added as additional parameters to the method call.
这样的参数被当作散列表,它们的键值对被添加，作为方法调用的额外参数。

    def regular(a, b)
      "a=#{a}, b=#{b}"
    end
    regular(99, a: 1, b: 2)             # => a=99, b={:a=>1, :b=>2}
    others = { c: 3, d: 4 }             
    regular(99, a: 1, b: 2, **others)   # => a=99, b={:a=>1, :b=>2, :c=>3,
                                        # .. :d=>4}
    regular(99, **others, a: 1, b: 2)   # => a=99, b={:c=>3, :d=>4, :a=>1,
                                        # .. :b=>2}
    rest = { e: 5 }
    regular(99, **others, a: 1, b: 2)          # => a=99, b={:c=>3, :d=>4, :a=>1,
                                               # .. :b=>2}
    regular(99, **others, a: 1, b: 2, **rest)  # => a=99, b={:c=>3, :d=>4, :a=>1,
                                               # .. :b=>2, :e=>5}

**关键字参数**
When a method defined with keyword arguments is called, Ruby matches the keys in the passed hash with each argument, assigning values when it finds a match.
当一个方法用关键字参数定义，它被调用时，ruby用每个参数匹配传入的hash的键，一旦找到匹配就进行赋值。

    def keywords(a, b: 2, c: 3)
      "a=#{a}, b=#{b}, c=#{c}"
    end
    keywords(99)        # => a=99, b=2, c=3  
    keywords(99, c:98)  # => a=99, b=2, c=98
    
    args = { b: 22, c: 33}
    keywords(99, **args)               # => "a=99, b=22, c=33"
    keywords(99, **args, b: 'override') # => "a=99, b=override, c=33"

If the passed hash contains any keys not defined as arguments, Ruby raises a runtime error unlesss the method also declares a double splat argument. 
如果传入hash包含没有被定义为参数的键，ruby会抛出一个运行时错误，除非该方法也声明了一个双splat参数。
In that case, the double splat receives the excess key-value pairs from the passed hash.
在那种情况下，双splat从传入的hash中接收过量的键值对。

    def keywords1(a, b: 2, c: 3)
      "a=#{a}, b=#{b}, c=#{c}"
    end
    keywords1(99, d: 22, e: 33)
    # produces:
    # prog.rb:5:in `<main>': unknown keywords: d, e (ArgumentError)

    def keywords2(a, b: 2, c: 3, **rest)
      "a=#{a}, b=#{b}, c=#{c}, rest=#{rest}"
    end
    keywords2(99, d: 22, e: 33) # => a=99, b=2, c=3, rest={:d=>22, :e=>33}

**block参数**
block可以关联一个方法调用，该调用可以使用字面量形式的block（它必须和方法调用的最后一行在同一行上），也可以关联一个参数，该参数包含对带&符号的Proc或Method对象的引用。

    def some_method
      yield
    end
    some_method { }
    some_method do
    end

    a_proc = lambda { 99 }
    some_method(&a_proc)

Ruby arranges for the value of `Object#block_given?` to reflect the availability of a block associ- ated with the call, regardless of the presence of a block argument. 
不管block参数存在与否，ruby使用`Object#block_given?`的值来判断是否存在与本调用相关联的block。
A block argument will be set to nil if no block is specified on the call to a method.
如果方法的调用上没有指明block，该block参数将被设置为nil。

    def other_method(&block)
      puts "block_given = #{block_given?}, block = #{block.inspect}"
    end
    other_method { }
    other_method
    # produces:
    # block_given = true, block = #<Proc:0x007fafc305c3d0@prog.rb:4>
    # block_given = false, block = nil

**接收者**
可以通过将方法的名字传递给接收者来调用一个方法。
如果没有指明接收者，则使用self。
接收者首先在它自己的类中查看是否有方法定义，然后依次在它的父类中查找。
被包含的模块的实例方法看起来像是包含它们的类的匿名超类。
 If the method is not found, Ruby invokes the method `method_missing` in the receiver. 
如果没有找到方法，ruby调用接收者的`method_missing`方法。
The default behavior defined in `Object#method_missing` is to report an error and terminate the program.
`Object#method_missing`定义的默认行为是报告错误并终止程序。

当显式指明方法调用的接收者时，可以使用句点（.）或两个冒号（:）把它和方法名分隔开。
这两种形式唯一区别仅在方法名以大写字母开始时才会出现。
在这种情况下，ruby会认为receiver::Thing方法调用的是试图访问接收者中的称为Thing的常量，除非方法调用带有一个包含在括号中的参数列表。
Using :: to indicate a method call is mildly deprecated.
稍微不太赞成用::来表示方法调用。

    Foo.Bar()  # method call     
    Foo.Bar    # method call
    Foo::Bar() # method call
    Foo::Bar   # constant access

**方法的返回值**
方法的返回值是执行的最后一个表达式的值。
The method in the following example returns the value of the if statement it contains, and that if statement returns the value of one of its branches.
下例中的方法返回其包含的if语句的值，而if语句返回其中一个分支的值。

    def odd_or_even(val)
      if val.odd?
        "odd"
      else
        "even"
      end
    end
    odd_or_even(26) # => "even"
    odd_or_even(27) # => "odd"

return表达式会立即退出方法。

    return ‹ expr ›*

如果不带参数调用return，则return的返回值为nil；如果带一个参数，则返回该参数的值，如果参数多于一个，则返回一个包含所有参数值的数组。

### 22.7.1 super

    super ‹ ( ‹ , param ›* ‹ , *array › ) › ‹ block ›

在方法体内，调用super就像调用原方法一样，不过是在含有原方法的对象的超类中搜索方法体。
如果没有参数（且未加括号）传递给super，则原方法的参数将作为super的参数，否则，super的参数将被传递。

### 22.7.2 操作符方法

    expr operator
    operator expr
    expr1 operator expr2

如果操作符表达式中的操作符是一个可重新定义的方法（参见前面的ruby操作符（优先级从高到低）)，ruby将像如下表达式那样执行操作符表达式。

    (expr1).operator() or
    (expr1).operator(expr2)

### 22.7.3 属性赋值

    receiver.attrname = rvalue

当receiver.attrname作为左值出现时，ruby将调用接收者中名为attrname=的方法，并以右值作为其唯一参数。
这种赋值语句的返回值总是rvalue的值--attrname的返回值将被丢弃。
如果你想访问返回值（多半情况下不是rvalue的值），那么向方法发送一个显式消息。

    class Demo
      attr_reader :attr
      def attr=(val)
        @attr = val
        "return value"   # 真没想到。这类似于返回一个“你设置成功”的消息。
      end
    end
    d = Demo.new
    # In all these cases, @attr is set to 99
    # 在如下情形中，@ttr都被设置为99
    d.attr = 99         # => 99
    d.attr=(99)         # => 99
    d.send(:attr=, 99)  # => "return value"
    d.attr              # => 99

### 22.7.4 元素引用操作符

    receiver[ ‹ expr ›+ ]
    receiver[ ‹ expr ›+ ] = rvalue

当用作右值时，元素引用调用接收者的[]方法，并以方括号中的表达式作为参数传递。
当用作左值时，元素引用将调用接收者的[]=方法，并以方括号中的表达式和跟在其后被赋值的rvalue作为参数传递。

## 　　22.8　别名

    alias new_name old_name

创建一个引用已有的方法、操作符、全局变量或正则表达式向后引用（``$& $` $' $+``）的新名字。
局部变量、实例变量、类变量和常量不能有别名。
alias的参数可以是名字或符号。

     class Fixnum
       alias plus +
     end
     1.plus(3) # => 4
     alias $prematch $`
     "string" =~ /i/ # => 3
     $prematch # => "str"
     alias :cmd :`
     cmd "date" # => "Mon May 27 12:31:34 CDT 2013\n"

当为方法起别名时，新的名字将指向原方法体的一个**拷贝**。即使后来方法被重新定义了，别名仍旧会调用原来的方法实现代码。
<kinder:note> 注意这是拷贝，而不是指向。

    def meth
      "original method"
    end
    alias original meth
    def meth
      "new and improved"
    end
    meth # => "new and improved"
    original # => "original method"

## 　　22.9　类定义
**形式**

    class ‹ scope:: › classname ‹ < superexpr ›
      body
    end
    class << obj
      body
    end

ruby的类定义通过执行类代码体创建或者扩展类Class的对象。
在第一种形式中，一个命名类将被创建或者被扩展。生成的Class对象将被赋给名为classname的常量（参见下面的作用域规则）。这个名字应该以一个大写字母开头。
第二种形式中，一个匿名（单例）类会和指定的对象相关联。
如果superexp存在，那么它应当是一个以Class对象为结果的表达式，而且它也将是被定义的类的超类。
如果省略了superepr，则默认为类Object。

**作用域规则**
在方法体内，随着各种定义代码的读入，大多数ruby表达式将被执行。然而：
  1. 方法定义将在类的对象的一个表中注册该方法。
  2. 嵌套的类和模块定义将被存储在类的常量中，而不是在全局常量中。在定义嵌套的类和模块的类外可以通过使用“::”修饰其名字来访问它。

    module NameSpace
      class Example     # <kinder:note> 这就是一个嵌套类
        CONST = 123
      end
    end
    obj = NameSpace::Example.new
    a = NameSpace::Example::CONST

  3. 方法Module#include将把命名的模块添作被定义类的匿名超类。

**域作用符**
使用域作用符（::）可以为类定义中的classname前置一个已存的类或模块名。
这种语法会将新的定义插入到前面已定义的模块和类的名字空间中，但不是在这些外部类的作用域中解释此定义。
前面带有域作用符的classname将使其类或模块处于顶层作用域中。
<kinder:note> 真是不懂。

在下面的例子中，类C被插入到模块A的作用域，但并不在A的上下文中进行解释。
结果，对CONST的引用被解释成该名字对应的顶层常量而不是A的常量。
而且我们必须使用单例方法的全名，因为在A::C的上下文中，C本身不是一个已知的常量。

    CONST = "outer"
    module A
      CONST = "inner"   # This is A::CONST
    end
    module A
      class B    # <kinder:note> 这也是一个嵌套类
        def B.get_const
          CONST
        end
      end
    end
    A::B.get_const # => "inner"
    class A::C               
    #<kinder:note> 将C插入看A模块中，但并不在A模块中解释。
      def (A::C).get_const
        CONST
        #<kinder:note> 所以这个方法不会返回A模块`CONST = “inner”`
      end
    end
    A::C.get_const # => "outer"

值得我们强调的是类定义是**可执行的代码**。
在类定义中使用的许多指令（例如attr和include）只不过是类Module的私有实例方法（参见后面2版554页4版579页的文档）

从后面2版379页开始的24章“类与对象”，4版357页24章”元编程“，描述了Class对象是如何与环境的其他部分进行交互细节的。

### 22.9.1 从类中创建对象

    obj = classexpr.new ‹ ( ‹ , args ›* ) ›

类Class定义的实例方法Class#new将创建接收者（在这个语法例子中是classexpr）对应的类的对象。
这是通过调用classexpr.allocate来完成的。
你可以重载此方法，但是你的实现必须返回正确的类的对象。
然后它调用新创建的对象的initialize，并将传递给new的参数传递给initialize。

如果类定义中重载了类方法new，并且new没有调用super，那么将无法创建该类的对象，并且调用new将返回nil。

和其他方法一样，initailize应当调用super，以保证父类被适当的初始化。
如果父类是Object，则不需要这么做，因为Object类不做任何实例相关的初始化。

### 22.9.2 类属性声明
类属性声明不是ruby语法的一部分。
它们不过是定义在类Module中的方法，该方法会自动创建访问类属性的方法。

    class name
      attr attribute ‹ , writable ›
      attr_reader ‹ attribute ›+
      attr_writer ‹ attribute ›+
      attr_accessor ‹ attribute ›+
    end

<kinder:note> 尽管如此，它太实用了！

## 　　22.10　模块定义
**形式**

    module name
      body
    end

模块基本上是一个不能实例化的类。
和类一样，在定义过程中模块体将被执行，生成的Module对象都存储在一个常量中。
模块中可以含有类方法和实例方法，也可以定义常量和类变量。
和类一样，通过使用Module对象作为接收者调用模块类方法（有时叫做模块方法），通过使用域作用符（::）来访问常量。
在模块定义中的名字可以以封装它的类或者模块做前缀。

    CONST = "outer"
    module Mod
      CONST = 1
      def Mod.method1 # module method 模块方法
        CONST + 1
      end
    end
    module Mod::Inner        
    # <kinder:note> 和类作用域一样，
    # 这个Inner模块使得所调用的CONST值不在Mod模块上下文中。
      def (Mod::Inner).method2
        CONST + " scope"
      end
    end
    Mod::CONST # => 1
    Mod.method1 # => 2
    Mod::Inner::method2 # => "outer scope"

### 22.10.1 Mixins 混入模块

    class|module name
      include expr
    end

使用include方法可以将一个模块包含到另一个模式或者类的定义中。
含有include的模块或类定义可以访问它所包含模块的常量、类变量和实例方法。

如果一个模块被包括到一个类定义中，那么模块的常量、类变量和实例方法实际上被绑定到该类的一个匿名（且不可访问）超类中。<kinder:note> 注意什么叫匿名不可访问
类的对象会响应发送给模块实例方法的消息。
如果调用未在类中定义的方法，那么在传递此方法给任何父类之前会先传递给该类包括的模块。
模块可以定义一个initialize方法，当创建包括模块的类的对象时，如果满足下面条件之一，该方法可被调用：
a，类没有定义它自己的initialize方法。
b，类的initialize方法调用了super。

模块也可在顶层被包含。在这种情况下，顶层可以访问模块的常量、类变量和实例方法。

**模块函数**
尽管include在提供mixin功能时很有用，也可以把模块的常量、类变量和实例方法带入到另一个命名空间中。
然而，实例方法定义的功能不能通过模块方法来实现。

    module Math
      def sin(x)
        #
      end
    end
    include Math # The only way to access Math.sin  访问Math.sin的唯一途径
    sin(1)

方法`Module#module_function`通过拷贝一个或多个模块实例方法的定义来创建相应的模块方法来解决这个问题。

    module Math
      def sin(x)
        #
      end
      module_function :sin   # <kinder:note> 这是关键。
    end
    Math.sin(1)   # <kinder:note> 比较上例，这里可以访问了！
    include Math
    sin(1)

实例方法和模块方法是两个不同的方法：方法定义被`module_function`拷贝出来而不是建立别名。

## 　　22.11　访问控制

    private ‹ symbol ›*
    protected ‹ symbol ›*
    public ‹ symbol ›*

ruby模块和类的常量和方法定义了3种保护级别。
  - Public。任意访问。
  - Protected。仅可被类或者子类的对象访问。
  - Private。仅可以使用函数形式访问（也就是说以隐含的self作为接收者）。
因此似有方法仅能在本类中和同一个对象的直接后代中被访问。参见前面3.3”访问控制“的讨论。

每个函数有两种使用方式。
1. 如果没有参数，那么这三个函数为随后定义的方法设置默认的访问控制。
2. 如果有参数，那么为参数中给出的方法或常量设置访问控制。

方法被调用时执行访问控制。

## 　　22.12　Blocks，Closures和Proc对象
**Block的形式**
代码block是包括在花括号或do～end对中的一组语句和表达式。
Block可以以包括在垂直条中的参数列表开始。
它只能紧随在方法调用后才出现。
Block的开始部分（花括号或do）必须和方法调用处于同一逻辑行中。

    invocation do | a1, a2, ... |
    end
    invocation { | a1, a2, ... |
    }

花括号具有高优先级，而do的优先级较低。
如果方法调用有不被括在括号内的参数，那么花括号形式的block将会绑定到最后一个参数，而不是整个调用上。<kinder:note> 这句话好难理解。
do形式会绑定到调用上。

在被调用方法的方法体内，可以使用yield关键字调用代码block。
传递给yield的参数将赋值给block参数。
如果yield将多个参数传递给只能接受一个参数的block，将会产生一个警告。
yield的返回值是block中执行的最后一条语句的值或者传递给在block中执行的next语句的值。

**闭包(closure)**
block是闭包（closure）。它能记住其被定义时的上下文，并在被调用时使用该上下文。
上下文中包含self的值、常量、类变量、局部变量和任意被截获的block。

    class BlockExample
      CONST = 0
      @@a = 3
      def return_closure
        a = 1
        @a = 2
        lambda { [ CONST, a, @a, @@a, yield ] }
      end
      def change_values
        @a += 1
        @@a += 1
      end
    end
    eg = BlockExample.new
    block = eg.return_closure { "original" }
    block.call # => [0, 1, 2, 3, "original"]
    eg.change_values
    block.call # => [0, 1, 3, 4, "original"]  <kinder:note> 这里改变啦。

Here, the `return_closure` method returns a lambda that encapsulates access to the local variable a, instance variable @a, class variable @@a, and constant CONST. 
在这里，`return_closure`方法返回一个lambda，形成访问本地变量a、实例变量@a、类变量@@a和常数CONST。
We call the block outside the scope of the object that contains these values, but they are still available via the closure.
我们在包含这些值的对象的作用域之外调用这个block，但它们透过闭包仍然有效。

If we then call the object to change some values, the values accessed via the closure also change.
如果我们稍后调用对象去改变一些值，通过闭包访问的值也会改变。

### 22.12.1 Block Arguments Block参数
Block argument lists are very similar to method argument lists:
Block参数列表类似于方法参数列表：

  - You can specify default values.
    你可以制定默认值。
  - You can specify splat (starred) arguments.
    你可以指定长条参数（缀星）。
  - The last argument can be prefixed with an ampersand, in which case it will collect any block passed when the original block is called.
    最后一个参数可以用&前缀，当原始block被调用时，它将选择任意传递的block。
  - Block-local variables are declared by placing them after a semicolon in the argument list.
    声明Block内变量，可将它们在参数列表中放在分号之后。

These changes make it possible to use `Module#define_method` to create methods based on blocks that have similar capabilities to methods created using def.
这些改变让它可能使用来创建基于block的方法，拥有和用def创建的方法相似的能力。

### 22.12.2 Proc Object 进程对象
Ruby’s blocks are chunks of code attached to a method. 
Ruby的block适合方法相关联的一堆代码。
Blocks are not objects, but they can be converted into objects of class Proc.
Block不是对象，但它们能被转换成类Proc的对象。 
There are four ways of converting a block into a Proc object.
有4种方法将block转换成Proc对象。

1. 通过传递block给一个方法，该方法的最后一个参数前有一个地址符&。该参数会接受block作为Proc对象。

    def meth1(p1, p2, &block)
      puts block.inspect
    end
    meth1(1,2) { "a block" }
    meth1(3,4)
    # produces:
    # #<Proc:0x007f97cb12c400@prog.rb:4>
    # nil

2. 通过调用Proc.new，再将它和block关联。[6]
[6] There’s also a built-in Object#proc method. In Ruby 1.8, this was equivalent to lambda. In Ruby 1.9 and later, it is the same as Proc.new. Don’t use proc in new code.
也有一个内建的Object#proc方法。在ruby1.8,它等同lambda。在ruby1.9以后，它等同Proc.new。新代码中不要使用proc。

    block = Proc.new { "a block" }
    block
    # => #<Proc:0x007fd4a4064638@prog.rb:1>

3. 通过调用Object#lambda（2版是Kernel#lambda）关联block到方法调用

    block = lambda { "a block" }
    block
    # => #<Proc:0x007f9d4c12c5c8@prog.rb:1 (lambda)>

4. Using the -> syntax.使用 -> 语法

    lam = ->(p1, p2) { p1 + p2 }
    lam.call(4, 3) # => 7

Note that there cannot be a space between -> and the opening parenthesis.
注意->和左圆括号之间不能有空格。

前两种风格的Proc对象在使用时是相同的。
我们称这些对象为raw procs。
后两种风格，由lambda和 -> 生成，为Proc对象添加了一些额外的功能，我们下面很快就能看到。
我们称这种对象为lambda。

Here’s the big thing to remember: raw procs are basically designed to work as the bodies of control structures such as loops. 
这里有个大事要记住：raw procs基本的设计意图是作为诸如循环的控制结构的主体。
Lambdas are intended to act like methods. 
Lambdas则倾向于类似方法。
So, lambdas are stricter when checking the parameters passed to them, and a return in a lambda exits much as it would from a method.
所以，当检查传给它们的参数时lambda更严格，而离开lambda的返回更像是从方法退出。

### 22.12.3 Calling a Proc 调用一个Proc
You call a proc by invoking its methods call, yield, or []. 
通过调用方法调用、yield或者[]，你可调用一个proc。
The three forms are identical. 
这三种形式都是一样的。
Each takes arguments that are passed to the proc, just as if it were a regular method. 
每种都将参数传给proc，好像普通的方法一样。
If the proc is a lambda, Ruby will check that the number of supplied arguments match the expected parameters. 
如果proc是一个lambda，ruby将检查提供的参数数目是否匹配预期参数。
You can also invoke a proc using the syntax name.(args...). 
你也可使用`name.(args...)`语法来调用proc。
This is mapped internally into name.call(args...).
这会被内部映射到`name.call(args...)`。

### 22.12.4 Procs, break, and next
Within both raw procs and lambdas, executing next causes the block to exit back to the caller of the block. 
在raw procs和lambda内，执行next语句将退回到block的调用者。
The return value is the value (or values) passed to next, or nil if no values are passed.
返回值是传递给next的值，如果没有传递则返回nil

    def ten_times
      10.times do |i|
        if yield(i)         # 这里等待yield返回true。
          puts "Caller likes #{i}"
        end
      end
    end
    ten_times do |number|
      next(true) if number ==7   # 这里这样写true if number == 7不更好？
    end
    # produces:
    # Caller likes 7

Within a raw proc, a break terminates the method that invoked the block. 
在raw proc里面，bread将终结调用block的方法。
The return value of the method is any parameters passed to the break.
方法的返回值是传递给break的参数。

### 22.12.2 Return和Block
A return from inside a raw block that’s still in scope acts as a return from that scope. 
处于作用域内来自raw block内部的return和该作用域的return作用一样。
block内原上下文不再有效的return会引发异常（因为上下文不同会引发LocalJumpError或ThreadError异常）。
下面的例子演示了第一种情况：

    def meth1
      (1..10).each do |val|     
        return val            # returns from meth1
      end
    end
    meth1 # => 1

下面的例子展示了由于block的上下文不存在而导致返回失败。

    def meth2(&b)
      b
    end
    res = meth2 { return }
    res.call
    # produces:
    # from prog.rb:6:in `call'
    # from prog.rb:6:in `<main>'
    # prog.rb:5:in `block in <main>': unexpected return (LocalJumpError)

下面例子中返回操作失败是由于block是在一个线程中创建的，而在另一个线程中被调用。

    def meth3
      yield
    end
    t = Thread.new do
      meth3 { return }
    end
    t.join
    # produces:
    # from prog.rb:2:in `meth3'
    # from prog.rb:6:in `block in <main>'
    # prog.rb:6:in `block (2 levels) in <main>': unexpected return (LocalJumpError)

如果使用Proc.new创建raw proc，也是这样。 
This is also true if you create the raw proc using Proc.new.

    def meth4
      p = Proc.new { return 99 }
      p.call
      puts "Never get here"
      #<kinder:note> 看清楚，这一句不会输出。和上面第一个例子一样的。
    end
    meth4 # => 99

lambda的表现更像一个自立的方法主体：return只是从block返回到block的调用者。
A lambda behaves more like a free-standing method body: a return simply returns from the block to the caller of the block:

    def meth5
      p = lambda { return 99 }
      res = p.call
      "The block returned #{res}"    #<kinder:note> 这一句会输出。
    end
    meth5
    # => "The block returned 99"

因此，如果你使用`Module#define_method`，你可能想传递一个用lambda而不是Proc.new创建的proc给该方法，因为前者的return会取得希望的效果，而后者会产生LocalJumpError。

## 　　22.13　异常
ruby异常是类Eception或其子类的对象（内建异常的完整列表见前面8.1的标准异常层级表。
### 22.13.1 引发异常

    raise
    raise string
    raise thing ‹ , string ‹ , stack trace › ›

第一种形式重新引发$!中的存储异常，如果$!是nil，则引发一个新的RuntimeError。
第二种形式创建一个新的RuntimeError异常，并设置其消息为给定的字符串。
第三种形式通过在第一个参数上调用exception方法创建一个异常对象，然后设置异常消息和backtrace(回溯追踪，2版译为调用栈)为第二个和第三个参数。

Exception类和其对象含有一个称为exception的因子（factor，2版译为工厂）方法，所以异常类的名字和实例可以用作raise的第一个参数。

异常发生时，ruby和将异常对象的引用存储在全局变量$!中。

### 22.13.2 处理异常
在如下地方可以处理异常：
  - 在begin～end的block作用域内。

    begin
      code...
      code...
    ‹ rescue ‹ , parm ›* ‹ , => var › ‹ , then ›
      error handling code... ›*
    ‹ else
      no exception code... ›
    ‹ ensure
      always executed code... ›
    end

  - 在方法体内。

    def method name and args
      code...
      code...
    ‹ rescue ‹ , parm ›* ‹ , => var › ‹ , then ›
      error handling code... ›*
    ‹ else
      no exception code... ›
    ‹ ensure
      always executed code... ›
    end

  - 一个可执行语句的后面。

    statement ‹ rescue statement ›*

一个block或方法可以有多个rescue语句，每个语句可以指定0个或多个异常参数。
不带参数的rescue语句被当作它带有一个StandardError参数。这意味这一些底层的异常无法被不带参数的resuce类捕获。
如果你想捕获任何异常，使用`rescue Exception => e`

当发生异常时，ruby向上扫描调用栈，直至找到该异常外层的begin~end块、方法体或带rescure修饰符的语句。
对block中的每个rescue语句，ruby依次比较当前被引发的异常和rescue的每个参数；每个参数被`parameter === $1`测试。
如果引发的异常和rescue的一个参数匹配，则ruby执行rescue的代码体，并停止查找。
如果匹配的rescue语句以 => 和一个变量名结束，那么该变量将被设置为$!。

尽管rescue语句的参数通常是异常类的名字，但实际上它们可以是返回适当类的任意表达式（包括方法调用）。

如果没有rescue语句和发生的异常匹配，ruby将向上一层栈中搜索匹配异常的高一级的begin~end块。
如果一个异常被传递到住线程的顶层还没被捕获，那么程序将输出一个消息并终止运行。

如果else语句存在，且code没有引发异常，那么其代码将被执行。
当执行else语句时发生的异常不会被和else在同一个block中的rescue语句捕获。

如果ensure语句存在，当block退出时它的代码总会被执行（即使存在未被捕获的异常处理）。
在rescue语句中，不带参数的raise将重新引发$!异常。

**rescue语句修饰符**
一条语句可以含有一个可选的rescue修饰符，该修饰符后跟另一条语句（还可以跟另一个rescue修饰符，等等）。
如果rescue修饰符不含异常参数，则rescue将捕获StandardError及其子类。

如果异常在rescue修饰符的左边发生，那么左边的语句将被放弃，而且整行的值为右边语句的值。

    values = [ "1", "2.3", /pattern/ ]
    result = values.map {|v| Integer(v) rescue Float(v) rescue String(v) }
    result # => [1, 2.3, "(?-mix:pattern)"]

**对Block进行Retry**
retry语句可以用在rescue语句中，以从头开始运行begin~end块。

## 　　22.14　Catch 和 Throw
方法Object.catch将执行与之相关联的block。

    catch ( object ) do
      code...
    end

方法Object.throw将中断语句的正常执行。

    throw( object ‹ , obj › )

等throw执行时，ruby在调用栈中向上搜索知道直到匹配对象的第一个catch块。
If it is found, the search stops, and execution resumes past the end of the
catch’s block. 
如果找到，则搜索结束，并从被catch块后面继续执行。
如果throw的第二个参数存在，那么它的值将作为catch的值返回。
当搜索对应的catch时，ruby检查它遇到的任何block表达式的ensure语句。

如果没有匹配throw的catch块，ruby将会在throw的位置下引发一个NameError异常。

# 　第23章　Duck Typing 鸭子类型
**类型安全**
ruby中没有声明变量和方法的类型--一切都是某种对象。

一些人喜欢这种灵活性。
一些人对不受限制地使用所有这些变量会感到紧张不安。

其实，缺乏静态类型对编写可靠的应用来说并不是一个问题。

现实情况是，大多数主流语言中，静态类型系统在程序安全方面没有真正起到太大的作用。
举例来说，Java的类型系统可靠，就无需实现ClassCastException异常。因为Java中存在运行时的类型非确定性（与C++ C#和别的语言一样）。
静态typing有助于代码优化，并通过工具提示帮助那些集成开发环境做得更聪明些。

另一方面，动态类型的变量实际上在很多方面提高了你的生产能力。
你也会发现对类型混乱感到惶恐是毫无根据的。

部分原因是：如果你出于某种目的使用一个变量，当你接下来再次使用它时，几乎总可能是因为相同的原因而使用。所谓可能发生的混乱根本就不会发生。

在这之上，经验丰富的ruby编程者往往倾向于采用某种编程风格。
他们编写了很多简短的方法，并一边编写一边测试。
简短的方法意味着大多数变量的作用范围是受限制的，这样程序因类型出错的情况就少些。
同时测试会帮助尽早发现那些愚蠢的错误：输入错误以及类型错误，使它们没有机会在代码中扩散开来。

结论是类型安全中的安全常常是一种错觉。

## 　　23.1　类不是类型
类型究竟是什么？
即使在Java中，类并不总是类型--有时候类型是类的子集，并且有时候对象实现了多个类型。
在ruby中，类从来不是类型。
相反，对象类型更多是根据对象能够做什么决定的。它被称为duck typing。

**测试中的鸭子类型**
下面我们编写一个方法，把客户名字写入到一个已打开文件的后面。

    class Customer
      def initialize(first_name, last_name)
        @first_name = first_name
        @last_name = last_name
      end
      def append_name_to_file(file)
        file << @first_name << " " << @last_name
      end
    end

下面写一个单元测试。创建一个文件，然后重新打开它，读取其内容并验证是否写入了正确的字符串。等一切结束后还把文件删除。

    require 'test/unit'
    require_relative 'addcust'
    class TestAddCustomer < Test::Unit::TestCase
      def test_add
        c = Customer.new("Ima", "Customer")
        f = File.open("tmpfile", "w") do |f|
          c.append_name_to_file(f)
        end
        f = File.open("tmpfile") do |f|
          assert_equal("Ima Customer", f.gets)
        end
      ensure
        File.delete("tmpfile") if File.exist?("tmpfile")
      end
    end
    # produces:
    # Run options:
    # # Running tests:
    # .
    # Finished tests in 0.007193s, 139.0241 tests/s, 139.0241 assertions/s.
    # 1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
    # ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

然而可以依赖鸭子类型。需要某种言行有如文件的东西，我们把它传递给要测试的方法。
在这种情况下，意味着我们需要这么一个对象，它通过附加一些特性来响应`<<`方法。
什么东西合适呢？普通的String怎么样？

    require 'test/unit'
    require_relative 'addcust'
    class TestAddCustomer < Test::Unit::TestCase
      def test_add
        c = Customer.new("Ima", "Customer")
        f = ""
        c.append_name_to_file(f)
        assert_equal("Ima Customer", f)
      end
    end
    # produces:
    # Run options:
    # # Running tests:
    # .
    # Finished tests in 0.006737s, 148.4340 tests/s, 148.4340 assertions/s.
    # 1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
    # ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

被测试的方法认为它正写入到文件中，但它只是添加一个字符串。

没有必要非得用字符串，用数组也不错：

    require 'test/unit'
    require_relative 'addcust'
    class TestAddCustomer < Test::Unit::TestCase
      def test_add
        c = Customer.new("Ima", "Customer")
        f = []
        c.append_name_to_file(f)
        assert_equal(["Ima", " ", "Customer"], f)
      end
    end
    # produces:
    # Run options:
    # # Running tests:
    # .
    # Finished tests in 0.006641s, 150.5797 tests/s, 150.5797 assertions/s.
    # 1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
    # ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

<kinder:note> 真是让人拍案叫絕！
实际上，如果想检查插入的单个对象是否正确，用数组可能会更方便。
因此，鸭子类型适合用来测试，但是用在程序体内会怎么样呢？同样，它也使得编写灵活的程序代码变得容易。
**程序代码中的鸭子类型**
Dave的经历。系统提供了一种逗号分隔值（comma-separated value, CSV）的下载功能。但它出问题了。一番测试后，发现问题出在得到数据查询的结果并生成CSV下载的函数中：

    def csv_from_row(op, row)
      res = ""
      until row.empty?
        entry = row.shift.to_s
        if /[,"]/ =~ entry
          entry = entry.gsub(/"/, '""')
          res << '"' << entry << '"'
        else
          res << entry
        end
        res << "," unless row.empty?
      end
      op << res << CRLF
    end
    result = ""
    query.each_row {|row| csv_from_row(result, row)}
    http.write result

处理中等规模的数据集时，这段代码表现得不错。但输入到达一定大小时，性能突然间马上慢下来了。垃圾回收！

解决办法简单而令人惊讶有效：

    def csv_from_row(op, row)
      # 和前面的一样
    end
    result = []
    query.each_row {|row| cvs_from_row(result, row)}
    http.write result.join

方法本身没有改变：它不关心参数究竟是什么类型，继续把它产生的数据添加到它的参数中。
在方法返回了结果后，我们把所有那些单个行连接到一个大的字符串中。这个改变把运行时间从3分钟以上减少到只需几秒钟。

## 　　23.2　像鸭子那样编码
如果想使用duck typing哲学来编写程序，只需要记住一件事情：对象的类型是根据它能够做什么而不是根据它的类型决定的。
(In fact, older versions of Ruby had a method Object#type that returned the class of an object.)
(事实上，老版本的ruby有一个Object#type方法，返回对象的类型)
<kinder:note> 2版的表述：
（实际上，正是由于此，ruby 1.8目前不赞成使用Object#type方法而使用Object#class方法：这个方法返回接收者的类，因为type这个名字会让人误解。）

在实践中这有什么意义？在某种层面上，它意味着测试对象的类通常没有什么价值。
比如，你可能编写函数去把歌曲信息添加到一个字符串中。如果用C#或Java的经验，你倾向于写成：

    def append_song(result, song)
      # test we're given the right parameters
      unless result.kind_of?(String)
        fail TypeError.new("String expected")
      end
      unless song.kind_of?(Song)
        fail TypeError.new("Song expected")
      end
      result << song.title << " (" << song.artist << ")"
    end
    result = ""
    append_song(result, song)

鸭子类型哲学则编写出非常简洁的代码。

    def append_song(result, song)
      result << song.title << " (" << song.artist << ")"
    end
    result = ""
    append_song(result, song)

无需检查参数类型，如果它们支持`<<`（result）或title和artist（song），一切都运行良好。
如果不支持，方法会抛出一个异常，就如同你检查其类型时会发生的那样。
但是取消这个检查的话，方法变得非常灵活：可以向其传入数组、字符串、文件或任何别的使用`<<`来添加的对象。

有时你想在使用这种自由的编程风格之余，对参数进行检查。
在沿着这条路走下去之前，确保你真正从中受益--需要编写和维护很多额外的代码。

    def append_song(result, song)
      # test we're given the right parameters
      unless result.respond_to?(:<<)
        fail TypeError.new("'result' needs `<<' capability")
      end
      unless song.respond_to?(:artist) && song.respond_to?(:title)
        fail TypeError.new("'song' needs 'artist' and 'title'")
      end
      result << song.title << " (" << song.artist << ")"
    end
    result = ""
    append_song(result, song)

如果因为检查了参数是所需的类，你会被鸭子类型抛弃吗？不会。[1]
[1]总之这鸭子类型并不会检查你是否是其中的一员。<kinder:note> 这是个幽默。
但你会考虑是根据对象的能力而不是它的类来做这个检查。

## 　　23.3　标准协议和强制转换
尽管技术上不属于ruby语言的一部分，但解释器和标准库会使用各种各样的协议来处理其他语言在使用类型时遇到的一些问题。

一些对象会有多种自然表示。
比如，你可能编写一个类来表示罗马数字。
这个类并不一定是Integer的子类。因为其对象是数字的表示，自己未必就是数字。
同时它们真的有点类似integer的特点。
无论何时当ruby预期见到整数时，如果能够使用我们罗马数字类的对象，就太好了。

为此，ruby提供了转换协议（conversion protocols）--对象可以选择把自己转换成另一个类的对象。
ruby有三种标准的方式来实现它。

第一种方式。
诸如`to_s`和`to_i`分别把它们的接收者转换成字符串或整数。
这些转换方式不是非常严格的：比如，如果对象有某种得体的字符串表示，可能会有`to_s`方法。为了返回数字的字符串表示（比如VII），我们的Roman类可能会实现`to_s`方法。

第二种方式。
使用名字如`to_str`和`to_int`的方法。
它们是严格的转换函数：只有当对象能够很自然地用在字符串或整数能够使用的任何地方，才应该实现它。

比如，罗马数字的对象可以清楚地表示一个整数，因此应该实现`to_int`方法。
但是涉及字符串的严格转换时，我们得好好想一想。
罗马数字显然可以用字符串来表示，但这些数字是字符串吗？我们能在任何使用字符串的地方使用这些数字吗？可能不。
从逻辑上讲，它们是数字的表示。
你可以把它们表示成字符串，但它们和字符串并非plug-compatible(插入兼容)。
因为这个原因，罗马数字不应实现`to_str`。
总结一下：使用`to_s`，罗马数字可以转换成字符串，但本质上不是字符串，因此没有实现`to_str`。

为了看看这实际上是如何工作的，我们考察一下打开的文件。
File.new的第一个参数可能是已有的文件描述符或是要打开的文件名。
当然，ruby不是只看第一个参数还检查类型是否是Fixnum或String；相反，它给被传递进来的对象一个机会，让这个对象以数字或字符串来表示自己。

    class File
      def self.new(file, *args)
        if file.respond_to?(:to_int)
          IO.new(file.to_int, *args)
        else
          name = file.to_str
          # call operating system to open file 'name'
          # 调用操作系统来打开文件name
        end
      end
    end

少数几个严格的转换函数被**内建到标准库**中。

`to_ary`  -- Array
This is used when interpreter needs a parameter to a method to be an array and when expanding parameters and assignments containing the `*xyz` syntax.
用在当解释器需要方法的参数是个数组，和当扩展参数和赋值包含`*xyz`语法时。
<kinder:note> 2版（ruby1.8）的`to_ary`函数等同于4版（ruby2.0）的`to_s`函数！

    class OneTwo
      def to_ary
        [ 1, 2 ]
      end
    end
    ot = OneTwo.new
    puts ot
    # produces:
    # 1
    # 2

`to_a`  -- Array
This is used when interpreter needs to convert an object into an array for parameter passing or multiple assignment.
用在当解释器需要把对象转换成数组以传递参数或进行多个赋值时。
<kinder:note> 这个函数在2版中是`to_ary`函数。

    class OneTwo
      def to_a
        [ 1, 2 ]
      end
    end
    ot = OneTwo.new
    a, b = *ot
    puts "a = #{a}, b = #{b}"
    printf("%d -- %d\n", *ot)
    # produces:
    # a = 1, b = 2
    # 1 -- 2

`to_enum`  -- Enumerator
This converts an object (presumably a collection) to an enumerator. 
它将一个对象(大概是一个收集)转换成一个enumerator。
It’s never called internally by the interpreter.
它从不被解释器内部调用。

`to_hash` -- Hash
用在当解释器期待看到散列表时（唯一已知的用法是Hash#replace的第二个参数）。

`to_int`  -- Integer
用在当解释器启动看到整数值时（如文件描述符或Object#Integer的参数）。

`to_io`  -- IO
用在当解释器期待IO对象时（比如IO#reopen或IO.select的参数）

`to_open` -- IO
Called (if defined) on the first parameter to IO.open.
如果定义了该函数，在IO.open的第一个参数上调用。

`to_path`  -- String
Called by the interpreter when it is looking for a filename (for example, by File#open).
当寻找一个文件名（比如File#open）时，由解释器调用。

`to_proc`  -- Proc
用在转换一个方法调用中的前缀有&符号的对象。

    class OneTwo
      def to_proc
        proc { "one-two" }
      end
    end
    def silly
      yield
    end
    ot = OneTwo.new
    silly(&ot) # => "one-two"

`to_regexp`  -- Regexp
Invoked by `Regexp#try_convert` to convert its argument to a regular expression.
`Regexp#try_convert`调用它来将参数转换为一个正则表达式。

`to_str`  -- String
普遍用在任何解释器寻找String值的地方。

    class OneTwo
      def to_str
        "one-two"
      end
    end
    ot = OneTwo.new
    puts("count: " + ot)
    File.open(ot) rescue puts $!.message
    # produces:
    # count: one-two
    # No such file or directory - one-two

`to_sym`  -- Symbol
Expresses the receiver as a symbol. This is used by the interpreter when compiling instruction sequences, but it’s probably not useful in user code.
表示接收者是符号。用于解释器编译指示序列，但在用户代码中可能是没用的。
2版的表述：表示接收者是符号。解释器没有使用它进行转换并且可能在用户代码中是无用的。

最后要说明的是：诸如Integer和Fixnum的类实现了`to_int`方法，String类实现了`to_str`方法。这样可以多态地调用这些严格的转换函数。

    # it doesn't matter if obj is a Fixnum or a
    # Roman number, the conversion still succeeds
    # 如果obj是一个Fixnum或Roman数组，那么没有关系，转换会成功的。
    num = obj.to_int

The **`Symbol.to_proc`** Trick(窍门)
Ruby implements the `to_proc` for objects of class symbol.
Ruby为符号类的对象实现了`to_proc`。
Say you want to convert an array of strings to uppercase.
比如你想将一个字符串数组换成大写的。
You could write this:
你可以这样写：

    names = %w{ant bee cat}
    result = names.map {|name| name.upcase}

That’s fairly concise, right? 
这相当简明，对不对？
Return a new array where each element is the corresponding element in the original, converted to uppercase. 
返回一个心的数组，每个元素对应原来的元素，并转换成了大写。
But you can instead write this:
但你也可以这样写：

    names = %w{ant bee cat}
    result = names.map(&:upcase)

Now that’s concise: apply the upcase method to each element of names.
现在那也简明：对每个元素名施加upcase方法。
So, how does it work? 
那这是怎么运行的？
It relies on Ruby’s type coercions. 
它依赖ruby的类型强制。

Let’s start at the top.
让我们从顶部开始。

When you say names.map(&xxx), you’re telling Ruby to pass the Proc object in xxx to the map method as a block. 
当你说name.map(&xxx)，你告诉ruby传递xxx里的Proc对象作为一个block给map方法。
If xxx isn’t already a Proc object, Ruby tries to coerce it into one by sending it a `to_proc` message.
如果xxx不是一个Proc对象，ruby会尝试通过发送`to_proc`信息，强制它成为一个Proc对象。

Now :upcase isn’t a Proc object—it’s a symbol. 
现在:upcase不是一个Proc对象，它是一个符号。
So when Ruby sees names.map(&:upcase), the first thing it does is try to convert the symbol :upcase into a Proc by calling `to_proc`. 
所以当ruby看到names.map(&:upcase)时，它做的第一件事情是调用`to_proc`，尝试转换符号:upcase成为一个Proc。
And, by an incredible coincidence, Ruby implements just such a method. 
因为难以置信的巧合，ruby刚好实现了这个方法。
If it was written in Ruby, it would look something like this:
如果用ruby来写，看起来如此：

    def to_proc
      proc { |obj, *args| obj.send(self, *args) }
    end

This method creates a Proc, which, when called on an object, sends that object the symbol itself. 
这个方法创建了一个Proc，当它被一个对象调用时，就将自身symbol发送给那个对象。
So, when names.map(&:upcase) starts to iterate over the strings in names, it’ll call the block, passing in the first name and invoking its upcase method.
所以，当 names.map(&:upcase)开始在names字面量字符串时，它将调用block，传入第一个名字并调用upcase方法。
<kinder:note> 似懂非懂。

It’s an incredibly elegant use of coercion and of closures. 
这是一个难以置信的强制和闭包的优雅使用。
However, it comes at a price. 
不过，这是要付出代价的。
The use of dynamic method invocations mean that the version of our code that uses &:upcase is about half as fast as the more explicitly coded block. 
动态方法调用的使用意味着我们使用&:upcase的代码版本的速度只有明确代码块的一半。
This doesn’t worry me personally unless I happen to be in a performance-critical section of my code.
不过我个人并不担心，除非我发现我的代码性能临界了。

### 23.3.1 数字强制转换numeric coercion
当写“1+2”时，ruby知道在对象1（Fixnum）上调用+，把Fixnum 2作为参数传递给它。
但当写“1+2.3”时，同样的+方法接受Float参数。
它如何知道该做点什么呢？
(尤其详细检查参数的类型违背了鸭子类型的精神)

答案在ruby中基于coerce方法的强制协议。
coercion的基本操作很简单。
它接受两个数字，返回包含两个元素的数组，分别是两个数字的表示（参数在前，后面跟着接收者）。
coerce方法保证两个对象会有相同的类，因此可以对它们进行加减乘除比较或任何别的什么操作。 

     1.coerce(2)          # => [2, 1]
     1.coerce(2.3)        # => [2.3, 1.0]
     (4.5).coerce(2.3)    # => [2.3, 4.5]
     (4.5).coerce(2)      # => [2.0, 4.5]

技巧在于接收者调用其参数的coerce方法来生成数组。
这种技术被称为两次分发。
它允许方法根据它类并且还有参数的类来改变自身的行为。
在这个例子中，我们让参数决定到底应该对哪个类的对象进行相加（或乘，除等等）。

假设正在编写新的类来进行算数计算。
为了使用强制转换，需要实现coerce方法。
它接受一些其他类型的数字作为参数，并返回一个数组，其中包含同一类的两个对象，她们的值与其参数及其自身相等。

对于罗马数字类来说，每个罗马数字对象了内部把它的实际值以Fixnum方法保存在实例变量@value中。
coerce方法检查参数的类是否也是Integer。
如果是，返回参数和这个内部值。
如果不是，则优先把两者都转让成浮点数。

    class Roman
      def initialize(value)
        @value = value
      end
      def coerce(other)
        if Integer === other
          [ other, @value ]
        else
          [ Float(other), Float(@value) ]
        end
      end
      # .. other Roman stuff
    end
     iv = Roman.new(4)
     xi = Roman.new(11)
     3 * iv
     1.2 * xi
    # => 12
    # => 13.2

当然以此种方法实现的Roman类还不知道如何相加。
因为Roman类没有plus方法。
现在实现如下：

    class Roman
      MAX_ROMAN = 4999
      attr_reader :value
      protected :value
      def initialize(value)
        if value <= 0 || value > MAX_ROMAN
          fail "Roman values must be > 0 and <= #{MAX_ROMAN}"
        end
        @value = value
      end
      def coerce(other)
        if Integer === other
          [ other, @value ]
        else
          [ Float(other), Float(@value) ]
        end
      end
      def +(other)
        if Roman === other
          other = other.value
        end
        if Fixnum === other && (other + @value) < MAX_ROMAN
          Roman.new(@value + other)
        else
          x, y = other.coerce(@value)
          x + y
        end
      end
      FACTORS = [["m", 1000], ["cm", 900], ["d", 500], ["cd", 400],
                 ["c",  100], ["xc",  90], ["l",  50], ["xl",  40],
                 ["x",   10], ["ix",  9], ["v",    5], ["iv" ,  4],
                 ["i",    1]]
      def to_s
        value = @value
        roman = ""
        for code, factor in FACTORS
          count, value = value.divmod(factor)
          roman << (code * count)
        end
        roman
      end
    end
    iv = Roman.new(4)
    xi = Roman.new(11)
    iv + 3        # => vii 
    iv + 3 + 4    # => xi
    iv + 3.14159  # => 7.14159
    xi + 4900     # => mmmmcmxi
    xi + 4990     # => 5001

最后应当小心使用coerce--尝试总是强制转换到更通用的类型，否则可能最终造成强制转换循环：A试图强制转换到B，而B试图强制转换回A。

## 　　23.4　该做的做，该说的说
鸭子类型会引起争论。
但根本上讲鸭子类型不是一组规则，它只是一种编程风格。
当设计程序时，请在偏执和灵活中寻求平衡。
如果觉得需要限制对象的类型，问一下自己为什么要限制。
如果期待String却得到Array时，试着确定在哪里出错了。
有时候这个差异是特别地重要。尽管往往不重要。

# 　第24章　类与对象  这一章在4版中改为“metaprogramming（元编程）”
**基本模型**
似乎有太多的概念：类、对象、class对象、实例方法、类方法、单例类和虚拟类。
然而，ruby只有一个底层的类和对象结构。
基本模型是如此简单：
一个ruby对象有三个部分：一组标志，一些实例变量，以及相关联的类。
ruby类是Class的一个对象，包括一个对象所具备的所有内容、外加方法列表和一个超类的引用（超类本身是另一个类）。
ruby中的所有方法调用必须指派一个接收者（默认为self，即当前对象）。
ruby通过在接收者的类中查找方法列表，来找到要调用的方法。
如果在其中没有找到，则在其包含的模块中查找，然后是父类，父类中包含的模块，继而是父类的父类，凡此以往。
如果方法最终没有在接收者类或者其任何祖先中找到，ruby调用最初接收者的`method_missing`方法。

## 　　24.1　类和对象是如何交互的
所有类/对象的交互，都是使用上面给出的简单模型解释的：对象引用类，而类引用零个或多个超类。不过，实现细节可能有些诡谲。
我们已经找到了最简单的方式，可视化地将ruby实现的实际结构描绘出来。
后面我们查看类与对象的所有可能组合。
注意，它们并非如UML的类图：我们所演示的是内存中的结构以及它们之间的指针。

### 24.1.1 你的基本的日常的对象
首先让我们查看一个从简单类创建的对象。下图24.1演示了由变量lucille引用的一个对象Guitar，以及类的超类Object。
注意，对象的类引用klass是如何指向class对象的，并且super指针如何指向父类。

    class Guitar
      def play()
        ...
      end
      ...
    end
    lucille = Guitar.new

                    +--------+
                 +--| Guitar |----+
                 |  +--------+    |
                 |    flags:...   |
     lucille +-->|    iv_tbl: +   |
                 |    klass: +----|----+          +--------+     
                 +---------------+     |          | Class  |     
                                       |       +--| Object |----+
                    +--------+         |       |  +--------+    |
                    | Class  |         |       |    flags:...   |
                 +--| Guitar |----+    |       |    super:  +   |
                 |  +--------+    |<---+       |    iv_tbl: +   |
                 |    flags:...   |            |    klass:  +   |
                 |    super:  +---|----------> |    method:     |
                 |    iv_tbl: +   |            |     -clone     |
                 |    klass:  +   |            |     -display   |
                 |    method:     |            |     -dup       |
                 |     -play      |            +----------------+ 
                 +----------------+           

图24.1 一个基本对象，以及它的类和超类

### 24.1.2 什么是Meta？
上图24.1中Class对象的klass成员没有指向任何有意义的东西。
现在我们具有所需的全部信息来找出它应该指向什么。
当你调用lucille.play()时，ruby沿着lucille的klass指针找到要查找实例方法的class对象。

当你调用类方法--例如Guitar.string(...)--时会发生什么呢？
接收者是class对象的Guitar本身。
因此为了一致性，我们需要把这些方法放到其他类中，并由Guitar的klass指针所引用。
这个新类将包括Guitar的所有类方法。
虽然术语还未确定，我们将它称为metaclass。
我们把Guitar的metaclass记为Guitar‘。但这还不是全部。
因为Guitar是Object的子类，它的metaclass Guitar‘则是Object的metaclass（Object’）的子类。

当ruby执行Guitar.strings()时，它沿用与之前一样的过程：找到接收者Guitar类：沿着klass引用得到Guitar‘类，然后找到方法。


    class Guitar
      def Guitar.strings()
        return 6
      end
      def play()
        ...
      end
      ...
    end
    lucille = Guitar.new

                    +--------+
                 +--| Guitar |----+
                 |  +--------+    |
                 |    flags:...   |
     lucille +-->|    iv_tbl: +   |
                 |    klass: +----|----+       
                 +---------------+     |       
                                       |       
                    +--------+         |          +--------+     
                    | Class  |         |          | Class  |     
                 +--| Guitar |----+    |       +--| Object |----+
                 |  +--------+    |<---+       |  +--------+    |
                 |    flags:...   |            |    flags:...   |
                 |    super:  +---|----------> |    super:  +   |
                 |    iv_tbl: +   |            |    iv_tbl: +   |
                 |    klass:  +---|-----+      |    klass:  +   |
                 |    method:     |     |      |    method:     |
                 |     -play      |     |      |     -clone     |
                 +----------------+     |      |     -display   |
                                        |      |     -dup       |
                                        |      +----------------+ 
                    +---------+         |          +---------+     
                    |  Class  |         |          |  Class  |     
                 +--| Guitar' |----+    |       +--| Object' |----+
                 |  +---------+    |<---+       |  +---------+    |
                 |    flags:  V    |            |    flags:  V    |
                 |    super:  +----|----------> |    super:  +    |
                 |    iv_tbl: +    |            |    iv_tbl: +    |
                 |    klass:  +    |            |    klass:  +    |
                 |    method:      |            |    method:      |
                 |     -strings    |            +-----------------+
                 +-----------------+            
                                                
图24.2 添加Guitar的metaclass

最后注意Guitar’类的标志中有一个V。
这些由ruby自动创建的类，被内在标记为虚拟类(virtual class)。
虚拟类在ruby内被不同地对待。
最明显的不同是对外界来说它们实际上是不可见的：它们永远不会出现在像Module#ancesstors或`ObjectSpace.each_object`等方法返回的对象列表中，而你也无法使用new来创建其实例。

**Metaclass和Singleton（单例）类**
在本书（2版）审校期间，对metaclass术语的使用引起了很多的讨论。
因为ruby的metaclass和类似Smalltalk语言中的不同。
最后，Matz做出了下面的抉择：

你可以称之为metaclass，但是和Smalltalk不同，它并非是一个关于类的类；它是一个类的singleton类。
  - ruby中的每个对象都有自己的属性（方法、常量等等），在其他语言中被保存在类中，就如同每个对象都有其自己的类。
  - 为了处理每个对象的属性，ruby为每个对象提供了一个好像类的东西，某些时候被称为singleton类。
  - 在当前的实现中，singleton类是具有特别标志的类，与对象和它们的类不同。如果语言的实现者愿意，可以把它们作为虚拟类。
  - 类的singleton类的行为如果Smalltalk的metaclass。

### 24.1.3 特定于Object的类
ruby允许你创建一个和特定对象绑定的类。
下面的示例，创建两个String对象，然后将一个匿名类关联到其中一个对象，覆写对象基类中的一个方法并添加一个新的。

    a = "hello"
    b = a.dup
    class <<a
      def to_s
        "The value is '#{self}'"
      end
      def two_times
        self + self
      end
    end
    a.to_s       →  "The value is 'hello'" 
    a.two_times  →  "hellohello"
    b.to_s       →  "hello"

这个示例使用`class <<obj`定义，基本的意思是“为对象obj构建一个新类”。
也可以将它改写为：

    a = "Hello"
    b = a.dup
    def a.to_s
      "The value is '#{self}'"
    end
    def a.two_times
      self + self
    end
    a.to_s       →  "The value is 'hello'" 
    a.two_times  →  "hellohello"
    b.to_s       →  "hello"

两者的效果是相同的：向对象a中添加一个类。
有关ruby的实现，这给了我们强烈的提示：创建虚拟类并插入作为a的直接类。
a的原有类String，作为虚拟类的超类。下面图4.3演示了之前和之后的状况。

     a = 'Hello'

                    +--------+
                 +--| String |----+
                 |  +--------+    |
                 |    flags:...   |
     a  +------->|    iv_tbl: +   |
                 |    klass: +----|----+          +--------+     
                 +---------------+     |          | Class  |     
                                       |       +--| Object |----+
                    +--------+         |       |  +--------+    |
                    | Class  |         |       |    flags:...   |
                 +--| String |----+    |       |    super:  +   |
                 |  +--------+    |<---+       |    iv_tbl: +   |
                 |    flags:...   |            |    klass:  +   |
                 |    super:  +---|----------> |    method:     |
                 |    iv_tbl: +   |            |     -clone     |
                 |    klass:  +   |            |     -display   |
                 |    method:     |            |     -dup       |
                 |     -to_s      |            +----------------+ 
                 |     ...        |  
                 +----------------+           
    --------------------------------------------------------------------------
      Class <<a
        def to_s
          "The value is '#{self}'"
        end
        def two_times
          self + self
        end
      end

                +--------+
             +--| String |----+
             |  +--------+    |
             |    flags:...   |
     a  +--->|    iv_tbl: +   |
             |    klass: +----|---+      
             +---------------+    |      
                                  |   
                +--------+        |      +--------+           +--------+      
                | Virtual|        |      | Class  |           | Class  |     
             +--|        |----+   |   +--| String |----+   +--| Object |----+
             |  +--------+    |<--+   |  +--------+    |   |  +--------+    |
             |    flags:  V   |       |    flags:...   |   |    flags:...   |
             |    super:  +---|-----> |    super:  +---|-->|    super:  +   |
             |    iv_tbl: +   |       |    iv_tbl: +   |   |    iv_tbl: +   |
             |    klass:  +   |       |    klass:  +   |   |    klass:  +   |
             |    method:     |       |    method:     |   |    method:     |
             |     -to_s      |       |     -to_s      |   |     -clone     |
             |     -two_times |       |     -...       |   |     -display   |
             +----------------+       |     -...       |   |     -dup       |
                                      +----------------+   +----------------+ 

图24.3 向对象中添加一个虚拟类

记住ruby中的类是永不关闭的：你可以随时洞开一个类并添加新的方法。
这对虚拟类也适用。
如果对象的klass引用已经指向了一个虚拟类，则并不会创建一个新的虚拟类。
这意味着，前面示例中定义的第一个方法创建了一个虚拟类，而第二个为其添加了一个方法。

Object#extend方法将其参数中的方法添加到调用该方法的接收者中，因此，如果需要的话，它也创建一个虚拟类。
`Obj.extend(Mod)`基本和下面的等价：

    class <<obj
      include Mod
    end

### 24.1.4 Mixin模块
当类包含一个模块时，模块的实例方法就变为类的实例方法。就好像模块变成类的超类。
这就是它工作的方式。
当包括一个模块时，ruby创建了一个指向该模块的匿名代理类，并将这个代理插入到实施包含的类中作为其直接超类。
代理类包含有指向模块实例变量和实例方法的引用。
这很重要：同一个模块可能被包含到不同的类中，并出现在许多不同的继承链中。
不过，感谢代理类，它指向唯一的底层模块：改变模块中的某个方法的定义，它会改变所有包含该模块的类，无论过去或未来。

下图24.4演示了类和所包含的mixin模块之间的关系。
如果包含了多个模块时，它们依次插入到继承链中。

                 +--------+
              +--| Guitar |---+
              |  +--------+   |
              |    flags: ... |
    lucille+->|    iv_tbl: +  |
              |    klass:  +--|--+      
              +---------------+  |      
                                 |   
                +--------+       |      +--------+             +--------+    
                | Class  |       |      | Proxy  |             | Class  |   
             +--| Guitar |---+   |   +--|        |--+       +--| Object |--+
             |  +--------+   |<--+   |  +--------+  |       |  +--------+  |
             |    flags:...  |       |    flags:... |       |    flags:... |
             |    super:  +--|-----> |    super:  +-|------>|    super:  + |
             |    iv_tbl: +  |       |    iv_tbl: +-|----+  |    iv_tbl: + |
             |    klass:  +  |       |    klass:  + |    |  |    klass:  + |
             |    method:    |       |    method: --|--+ |  |    method:   |
             |     -play     |       |              |  | |  |     -clone   |
             |               |       |     -...     |  | |  |     -display |
             +---------------+       |     -...     |  | |  |     -dup     |
                                     +--------------+  | |  +--------------+ 
                                        +--------+     | |
                                        | Module |     | |
                                     +--| Enum.. |---+ | |
                                     |  +--------+   | | |
                                     |    flags:...  | | |
                                     |    super:  +  | | |
                                     |    iv_tbl: +<-|-|-+
                                     |    klass:  +<-|-+
                                     |    method:    |
                                     |     -collect  |
                                     |     -detect   |
                                     +---------------+ 

图24.4 被包含的模块以及它的代理类

如果模块本身包含了其他模块，代理类的链会加入到包含该模块的所有类中，每个直接或间接包含的模块都对应有一个代理。

### 21.1.5 扩展对象
和使用`class <<obj`为对象定义一个匿名类一样，可以使用Object#extend将一个模块混合到对象中。例如：

    module Humor
      def tickle
        "hee, hee!"
      end
    end
    a = "Grouchy"
    a.extend Humor
    a.tickle  # "hee, hee!"

这是使用extend一个有趣的技巧。
如果你在一个类定义中使用它，模块的方法会变为类方法。
这是因为调用extend和self.extend是等价的，因此方法被添加到self中，而在类定义中则是添加到类本身：

    module Humor
      def tickle
        "hee, hee!"
      end
    end
    class Grouchy
      include Humor
      extend Humor
    end
    Grouchy.tickle      → "hee, hee!" 
    a = Grouchy.new       
    a.tickle            → "hee, hee!"

## 　　24.2　类和模块的定义
在C++或Java的语言中，类定义是在编译期间处理的：编译器创建符号表，计算出需要分配多少存储空间，构造分发表(dispatch table)，以及我们无需过多考虑的所有其他隐秘事情。
ruby则不同，在ruby中，**类和模块的定义是可执行的代码**。
虽然是在编译期间进行解析，但当遇到定义时，类和模块是在运行时创建的。（这对方法定义也是成立的。）
这可以让你可以比传统语言更动态地构架你的程序。
你可以在类要被定义时，而非每次使用类的对象时，做出决定。
下例中的类，当它要被定义时，决定要创建哪个版本的解密例程。

    module Tracing
      # ...
    end
    class MediaPlayer
      include Tracing if $DEBUG
      if ::EXPORT_VERSION
        def decrypt(stream)
          raise "Decryption not available"
        end
      else
        def decrypt(stream)
          # ...
        end
      end
    end

<kinder:note> 用时才定义，不可思议。

如果类定义是可执行的代码，这意味着它是在某个对象的上下文中执行的：self必定指向了某个东西。让我们把他找出来：

    class Test
      puts "Class of self = #{self.class}"
      puts "Name of self = #{self.name}"
    end
    # Class of self = Class
    # Name of self = Test

这意味着类定义在执行时就是以这个类作为当前对象。
回到前面metaclass的章节，我们可以看到这意味着metaclass及其超类中的方法，当执行方法定义时是可用的。让我们来看一看。

    class Test
      def Test.say_hello
        puts "Hello from #{name}"
      end
      say_hello
    end
    # Hello from Test

在这个示例，我们定义了一个类方法，`Test.say_hello`，并且在类定义的代码体中调用它。
在`say_hello`内部，我们调用name，Module类的一个实例方法。
因为Module是Class的祖先类，因此在类定义中调用其实例方法，无需明确指定接收者。

### 24.2.1 类实例变量
如果类定义是**在某个对象的上下文中执行**，这意味着这个类可能具有实例变量。

    class Test
      @cls_var = 123
      def Test.inc
        @cls_var += 1
      end
    end
    Test.inc  →  124 
    Test.inc  →  125

如果类有它们自己的实例变量，我们可以使用`attr_reader`等方法去访问它们吗？
可以。但我们必须在正确的地方运行这些方法。
对一般的实例变量来说，属性访问方法是在类一级定义的。
但对类实例变量来说，我们**必须在metaclass中定义访问函数**。

    class Test
      @cls_var = 123
      class <<self
        attr_reader :cls_var
      end
    end
    Test.cls_var  # 123

这把我们导向一个有趣的结论。
许多我们在定义类或模块时使用的指令，例如`alias_method, attr, public`，都是Module类中的方法。
这创建了某些隐秘的可能性--可以通过编写ruby代码来**扩展类或模块定义的功能**。
让我们看几个示例。

第一个示例，向模块和类添加基本的文档化功能。
这可以让我们将一个字符串关联到所编写的模块和类，当程序运行时可以得到这个字符串。
我们选择一个简单的语法：

    class Example
      doc "This is a sample documentation string"  # 这个doc是个方法，在下面定义
      #  ... 类的其余部分
    end

我们要让doc方法在任何模块或类中都可使用，所以我们需要让它作为Module的一个实例方法：

    class Module
      @@docs = {}
      # 类定义期间调用 
      # <kinder:note> 没有看到哪行代码调用这个doc？在最后两行的puts语句。
      def doc(str)
        @@docs[self.name] = self.name + ":\n" + str.gsub(^\s+/, '')
        #<kinder:note> 输出为：类名（换行），字符串
      end
      # 调用以获得文档
      def Module::doc(aClass)
        # 如果我们要传递一个类或模块，转换为字符串
        # （类的`<=`，比较是否同一类或同一子类）
        aClass = aClass.name if aClass.class <= Module
        @@docs(aClass) || "No documentation for #{aClass}"
        # <kinder:note> @@docs(aClass) 能够返回什么东西呢？只是class的名字而已。
      end
    end

    class Example
      doc "This is a sample documentation string"
      # 类的其他部分
    end

    module Another
      doc <<-edoc
        And this is a documentation string
        in a module
      edoc
      # 模块的其他部分
    end

    puts Module::doc(Example)
    puts Module::doc("Another")
    # 输出：
    # Example
    # This is a sample documentation string
    # Another:
    # And this is a documentation string
    # in a module

<kinder:note> 不懂，Example和Another里面的doc是什么意思？

第二个示例。基于Tadayoshi Funaba的data模块（后面665页描述）的性能增强。
假如我们有一个类表示某种底层的数量（本例中是日期）。
这个类可能有许多属性，以多种不同方式表示底层的日期：Julian天数(阳历)、字符串、[年月日]三元组等等。
每个值都表示相同的日期，并且可能设计相当复杂的计算推导。
这样我们希望当第一次访问某个属性时，只一次计算它的值。

手工的方式是为每个访问方法添加一个测试。

    class ExampleDate
      def initialize(day_number)
        @day_number = day_number
      end
      def as_day_number
        @day_number
      end
      def as_string
        unless @string
          # complex calculation
          @string = result
        end
        @string
      end
      def as_YMD
        unless @ymd
          # another calculation
          @ymd = [ y, m, d ]
        end
        @ymd
      end
      # ...
    end

这是一个笨重的方法--让我们看看能否高出一些更性感的方法。
我们的目标是一个指令，它表明某个特定的方法体只应该被调用一次。
第一次调用返回的值应该被缓存起来。
此后，调用同一方法应该返回缓存的值，无需再次重入方法体。
这和Eiffel的例程修饰语once类似。我们希望用下面的方式编写代码：

    class ExampleDate
      def as_day_number
        @day_number
      end
      def as_string
        # complex calculation
      end
      def as_YMD
        # another calculation
        [ y, m, d ]
      end
      once :as_string, :as_YMD
    end

通过编写once作为ExampleDate的一个类方法，我们可以使用它作为一个指令，但是内部看起来应该如何呢？
对每个方法，它创建原有代码的一个别名，然后用相同的名字创建一个新方法。
下面是Tadayoshi Funaba的代码，稍稍重新做了格式化。

    def once(*ids) # :nodoc:
      for id in ids
        module_eval <<-"end;"
          alias_method :__#{id.to_i}__, :#{id.to_s}
          private :__#{id.to_i}__
          def #{id.to_s}(*args, &block)
            (@__#{id.to_i}__ ||= [__#{id.to_i}__(*args, &block)])[0]
          end
        end;
      end
    end

这段代码使用`module_eval`在调用它的模块（或者以本例来说，调用它的类）的上下文中执行一段代码。
原来的方法被重命名为`__nnn__`，其中nnn部分是方法名符号ID的一个整数表示。
代码使用相同的名字来缓冲实例变量，然后用原来的名字定义了一个方法。
如果缓存的实例变量有值，则返回这个值；否则调用原来的方法，缓存并返回它的返回值。

理解了这段代码，你才真正迈向精通ruby的道路。
<kinder:note> 好吧，我只是懂条毛！

不过，我们可以更进一步。查看date模块，你会看到once的代码稍有不同。

    class Date
      class <<self
        def once(*ids)
          # ...
        end
      end
      # ...
    end

这里有趣的事情是内联类的定义，`class <<self`。
它基于self对象定义一个类，并且self恰巧是Date的class对象。
结果呢？内联类定义中的每个方法，都自动成为Date的类方法。

once特性有很强的适用性--它应该对所有类都可以工作。
如果你将once提取出来并作为Module类的私有实例方法，那么所有的ruby类都可以使用它。
（当然你可以这样做，因为Module类是开放的，你可以自由地向其中添加方法。）

### 24.2.2 类名是常量
前面提到过当你调用一个类方法时，所要做的是向Class对象本身发送一个消息。
当你调用例如String.new("gumby")的方法时，向String的class对象发送消息new。
但是ruby如何处理它呢？
总之，消息的接收者应该是一个对象引用，隐含着某处必定有一个名为String的常量，持有String对象的引用。[2]
[2]它是一个常量，不是一个变量，因为String是由大写字母开头的。
而且实际上，这就是实际所发生的动作。
所有的内建类，以及你所定义的类，都有一个对应的全局变量，它的名字和你的类名相同。
这很直接且微妙。
微妙的地方在于，在系统中有两个名为String的东西。
一个是指向String类的常量（Class类的一个对象），另一个是（类）对象本身。

类名为常量的事实，意味着你可以把类和其他ruby对象一样来对待：可以拷贝它们，将它们作为参数传入方法，或者在表达式中使用它们。

    def factory(klass, *args)
      klass.new(*args)
    end
    factory(String, "Hello") → "Hello"
    factory(Dir, ".")  → #<Dir:0x1c90e4>
    
    flag = true 
    (flag ? Array : Hash)[1, 2, 3, 4] → [1, 2, 3, 4]
    flag = false 
    (flag ? Array : Hash)[1, 2, 3, 4] → {1=>2, 3=>4}

    # <kinder:note> 太有意思了！

还有另一个侧面：如果一个无名的类被赋值给一个常量，ruby将常量作为类名。

    var = Class.new
    var.name → ""
    Wibble = var
    var.name → "Wibble"

## 　　24.3　顶层的执行环境
本书宣称ruby中所有事物都是对象，不过，我们一次又一次使用一样看起来与此相悖的东西--ruby顶层的执行环境。

    puts "Hello,World"

看起来不是一个对象。
但深入探究，字面上的"Hello, World"产生一个ruby的String对象，所以它是一个对象。
直接调用puts方法实际等同于self.puts，那么何为self？

    self.class #=> Object

在顶层，我们在某个预定义的对象上下文中执行代码。
当我们定义方法时，我们实际创建了Object类的一个（私有）实例方法。
这十分微妙：因为它们在Object类中，这些方法在任何地方都可以获得。
而且因为我们在Object的上下文中，能够以函数的形式使用Object（包括从Kernel中的Mixin的方法）。
这解释了为什么我们可以在顶层（实际上在ruby的任何地方）调用Kernel中的方法，例如puts；这些方法是每个对象的一部分。

顶层的实例变量也属于这个顶层对象。

## 　　24.4　继承与可见性
关于类继承最后一个诡谲的地方，十分含糊。
在一个类定义中，你可以修改祖先类中方法的可见性。例如下面：

    class Base
      def aMethod
        puts "Got here"
      end
      private :aMethod
    end
    
    class Derived1 < Base
      public :aMethod
    end
    
    class Derived2 < Base
    end

在这示例中，我们可以调用Derived1类实例中的eMethod，但不能通过Base或Derived2的实例来调用它。
那么ruby如何辗转让一个方法有两个不同的可见性呢？它使诈。
如果一个子类改变了父类中某个方法的可见性，ruby实际上在子类中插入一个隐藏的代理方法，使用super调用原有的方法。
然后将这个代理的可见性设置为你所需要的。因此下面的代码：

    class Derived1 < Base
      public :aMethod
    end

等同于：

    class Derived1 < Base
      def aMethd(*args)
        super
      end
      public :aMethod
    end

super调用可以访问父类中的方法，而不管其可见性，所以重写方法可以让子类覆写父类中的可见性规则。

## 　　24.5　冻结对象
有时你费尽力气才让你的对象完全正确，如果允许其他人可以改变它，你会受到惩罚。
也许你需要通过某个第三方的对象，在你的两个类之间传递某种不知类型的对象，而你希望确保它在到达时是未经改动的。
也许你希望使用一个对象作为散列表的key，并确保当它被用作key时没有人能修改它。
也许有什么东西破坏了你的一个对象，而你想让ruby在改变发生时立即抛出一个异常。

ruby提供了一种非常简单的机制来帮助实现上述需求。
任何对象都可以通过调用Object#freeze被冻结。
一个被冻结的对象是不能修改的：你不能改变它的实例变量（无论直接或间接），你不能为其关联单例方法，而且，如果它是类或模块，你不能添加、删除或更改它的方法。
一旦被冻结，对象将始终保持冻结状态：没有Object#thaw方法可用。
你可以使用`Object#frozen?`来判断对象是否被冻结。

当你拷贝一个被冻结的对象时，
如果调用对象的clone方法，整个对象的状态（包括是否冻结）都会被拷贝到新对象中。
而dup通常只拷贝对象的内容--新拷贝不会继承冻结的状态。

    str1 = "hello"
    str1.freeze       →    "hello"  
    str1.frozen?      →    true
    str2 = str1.clone      
    str2.frozen?      →    true
    str3 = str1.dup        
    str3.frozen?       →   false

虽然冻结对象最初看起来是个好主意，不过在你遇到实际需求之前，最后不要这样。
冻结是在纸面上看起来十分必要，而在实践中所用不多的想法之一。

# 第24章  metaprogramming（元编程）
**缘由**
The Jacquard loom, invented more than 200 years ago, was the first device controlled using punched cards—rows of holes in each card were used to control the pattern woven into the cloth. 
Jacquard织布机，发明于200年前，是第一个用卡带控制的设备，每张卡带上都布满了小孔，用于控制衣服上的织物样式。
But imagine if instead of churning out fabric, the loom could punch more cards, and those cards could be fed back into the mechanism. 
但请设想一下，如果不是编制织物，织布机可以打上更多的卡片，那些卡片可以被反馈给机制。
The machine could be used to create new programming that it could then execute. 
这个机器能用于创建新的可以执行的程序。
And that would be metaprogramming—writing code that writes code.
那就是元编程--写一个能写代码的代码。

Programming is all about building layers of abstractions. 
编程全是关于构建抽象层。
As you solve problems, you’re building bridges from the unrelenting and mechanical world of silicon to the more ambiguous and fluid world we inhabit. 
你解决问题的时候，你构建一座桥，从冷酷、呆板的世界到我们习惯的更模糊和流动的世界。
Some programming languages—such as C—are close to the machine. 
有些编程语言--比如C--和机器的关系很紧密。
The distance from C code to the application domain can be large.
从c代码到应用的领域的距离却很巨大。

Other languages—Ruby, perhaps—provide higher-level abstractions and hence let you start coding closer to the target domain. 
其他语言--可能如ruby--提供了更高级的抽象，因此你可更接近目标领域而开始编程。
For this reason, most people consider a higher-level language to be a better starting place for application development (although they’ll argue about the choice of language).
因为这个原因，大部分人认为更高级的语言是应用开发更好的起点（虽然他们将争论语言的选择）。

But when you metaprogram, you are no longer limited to the set of abstractions built in to your programming language. 
但当你编程，你不再局限于内建于编程语言的抽象集。
Instead, you create new abstractions that are integrated into the host language. 
相反，你创建新的抽象，整合到主语言中。
In effect, you’re creating a new, domain-specific programming language —one that lets you express the concepts you need to solve your particular problem.
实际上，你正在创建一个新的、指定领域的语言--让你表达需要解决的特定的问题的概念。

Ruby makes metaprogramming easy. 
ruby让元编程变得容易。
As a result, most advanced Ruby programmers will use metaprogramming techniques to simplify their code. 
结果是，大部分高级的ruby编程人员将使用元编程技巧去简化他们的代码。
This chapter shows how they do it. 
这一章展示他们的做法。
It isn’t intended to be an exhaustive survey of metaprogramming techniques. 
不是有意进行元编程技巧的详细介绍。
Instead, we’ll look at the underlying Ruby principles that make metaprogramming possible. 
相反，我们将查找让元编程得以可能的根本的ruby原则。
From there you’ll be able to invent your own metaprogramming idioms.
从那里，你将能创造你自己的元编程用语。

## 24.1 Object and classes 对象和类
**对象结构和ruby类**
Classes and objects are obviously central to Ruby, but at first sight they can be a little confusing. 
类和对象明显是ruby的核心，但你开始看时会有些困惑。
It seems like there are a lot of concepts: classes, objects, class objects, instance methods, class methods, singleton classes, and virtual classes. 
似乎有太多的概念：类、对象、class对象、实例方法、类方法、单例类和虚拟类。
In reality, however, Ruby has just a single underlying class and object structure.
然而实际上，ruby只有一个底层的类和对象结构。

A Ruby object has three components: a set of flags, some instance variables, and an associated class. 
一个ruby对象有三个部分：一组标志，一些实例变量，以及相关联的类。
A Ruby class is itself an object of class Class. 
ruby类本身是Class类的一个对象。
It contains all the things an object has plus a set of method definitions and a reference to a superclass (which is itself another class). 
它包括一个的对象所有的全部东西，和一组方法定义，一个超类的引用（超类本身是另一个类）。
<kinder:note> 就是说ruby类=（一组标志+一些实例变量+相关联的类）+ 一组方法定义+ 一个超类引用
<kinder:note> 这个所谓相关联的类就是指虚拟类吧。
 And, basically, that’s it. 
基本上，就是这样。
From here, you could work out the details of metaprogramming for yourself. 
从这里开始，你可以自己制造元编程的细节。
But, as always, the devil lurks in the details, so let’s dig a little deeper.
不过和往常一样，魔鬼隐藏在细节里面，所以我们要学得更深些。

### 24.1.1 self and Method Calling  【self和方法调用】
Ruby has the concept of the current object. 
ruby有当前对象的概念。
This current object is referenced by the built-in, read-only variable self. 
这个当前对象给内建的只读的变量self所引用。
self has two significant roles in a running Ruby program.
在一个运行的ruby程序中，self有两个有意义的作用。

First, self controls how Ruby finds instance variables. 
首先，self控制ruby如何寻找实例变量。
We already said that every object carries around a set of instance variables. 
我们已经说过每个对象都装载着一组实例变量。
When you access an instance variable, Ruby looks for it in the object referenced by self.
当你访问一个实例变量，ruby在被self关联的对象里寻找它。

Second, self plays a vital role in method calling. 
其次，self在方法调用中扮演至关重要的角色。
In Ruby, each method call is made on some object. 
在 Ruby，每个方法调用都在一些对象上实施。
This object is called the receiver of the call. 
这个对象被称为调用的接收者。
When you make a call such as items.size, the object referenced by the variable items is the receiver and size is the method to invoke.
当你调用如items.size，被变量items所引用的对象是接收者，size是所调用的方法。

If you make a method call such as puts "hi", there’s no explicit receiver. 
如果你实施了一个方法调用，比如`puts "hi"`，看起来没有明显的接收者。
In this case, Ruby uses the current object, self, as the receiver. 
在这个情况，ruby使用当前对象self作为接收者。
It goes to self’s class and looks up the method (in this case, puts). 
它寻找self的类，寻找方法（在这个例子是puts）。
If it can’t find the method in the class, it looks in the class’s superclass and then in that class’s superclass, stopping when it runs out of superclasses (which will happen after it has looked in BasicObject).  1
如果它不能在类中找到这个方法，它在类的超类中寻找，然后在那个超类的超类，直到最后的超类（即BasicObject）中都没有找到，它就停下来了。
[1] If it can’t find the method in the object’s class hierarchy, Ruby looks for a method called `method_missing` on the original receiver, starting back at the class of self and then looking up the superclass chain.
如果不能在对象的类别层级中找到这个方法，ruby会在原来的接受者里面找到一个叫做`method_mission`的方法，开始返回到self类，然后查找超类链。

When you make a method call with an explicit receiver (for example, invoking items.size), the process is surprisingly similar. 
当你用一个明确的接收者（比如调用`items.size`）进行一个方法调用，过程十分相似。
The only change—but it’s a vitally important one—is the fact that self is changed for the duration of the call. 
唯一的改变--但是最重要的一个--是：事实上，self在调用期间被改变了。
Before starting the method lookup process, Ruby sets self to the receiver (the object referenced by items in this case). 
在开始方法查找过程之前，ruby将self设置为接收者（在此例中为items所引用的对象）。
Then, after the call returns, Ruby restores the value that self had before the call.
然后，在调用返回后，ruby恢复self在调用之前的值。

Let’s see how this works in practice. Here’s a simple program:
让我们看看实践中这是如何工作的。这是个简单的程序：

    class Test
      def one
        @var = 99
        two
      end
      def two
        puts @var
      end
    end
    t = Test.new
    t.one
    # produces:
    # 99

The call to Test.new on the second-to-last line creates a new object of class Test, assigning that object to the variable t. 
倒数第二行`Test.new`的调用创建了一个新的Test类对象，并将这个对象赋给变量t。
Then, on the next line, we call the method t.one. 
然后，下一行，我们调用t.one方法。
To execute this call, Ruby sets self to t and then looks in t’s class for the method one. 
要执行这个调用，Ruby将self设置为t，然后查找t的类里方法one。
Ruby finds the method defined on line 2 and calls it.
Ruby在定义的第二行找到了这个方法，并调用。

Inside the method, we set the instance variable @var to 99. 
在方法里，我们将实例变量@var设置为99。
This instance variable will be associated with the current object. 
这个实例变量将被联系到当前对象。
What is that object?
那个对象是什么？
Well, the call to t.one set self to t, so within the one method, self will be that particular instance of class Test.
好吧，t.one的调用将self设置为t，因此在one方法里面，self将是Test类的特定的实例。

On the next line, one calls two. 
在接下来的两行，one调用two。
Because there’s no explicit receiver, self is not changed. 
因为没有显式的接收者，self没有改变。
When Ruby looks for the method two, it looks in Test, the class of t.
ruby查找方法two时，它在Test，t的类里看到了。

The method two references an instance variable @var. 
方法two引用一个实例变量@var。
Again, Ruby looks for this variable in the current object and finds the same variable that was set by the method one.
又一次，ruby在当前对象查找这个变量，然后找到方法one设置的同一个变量。

The call to puts at the end of two works the same way. 
最后两行对puts的调用也是方式相同。
Again, because there’s no explicit receiver, self will be unchanged. 
再次，因为没有显式的接收者，self会保持不变。
Ruby looks for the puts method in the class of the current object but can’t find it. 
Ruby在当前对象的类中查找puts方法，但无法找到。
It then looks in Test’s superclass, class Object. 
然后它在Test的超类Object类中查找。
Again, it doesn’t find puts. 
再次，它没有找到。
However, Object mixes in the module Kernel. 
不过，Object混入了Kernel模块。
We’ll talk more about this later; for now we can say that mixed-in modules act as if they were superclasses. 
我们后面会谈得详细些；现在我们可以说混入的模块运作起来就像是超类一般。
The Kernel module does define puts, so the method is found and executed.
Kernel模块定义了puts，这样就找到了方法，并执行起来。

After two and one return, Ruby resets self to the value it had before the original call to t.one.
two和one返回之后，Ruby重新将self设置为最初t.one调用之前的值。

This explanation may seem labored, but understanding it is vital to mastering metaprogram- ming in Ruby.
这个解释看起来很吃力，但理解它是掌握ruby元编程的命门。

### 24.1.2 self and Class Definitions 【self和类定义】
We’ve seen that calling a method with an explicit receiver changes self. 
我们已经看过带一个显式的接收者调用一个方法改变self。
Perhaps surprisingly, self is also changed by a class definition. 
可能更令人惊奇的是，self也可以通过一个类定义来改变。
This is a consequence of the fact that class definitions are actually executable code in Ruby—if we can execute code, we need to have a current object. 
这是一个事实的结果：ruby中类定义实际上是可执行代码--如果我们能执行代码，我们需要一个当前对象。
A simple test shows what this object is:
一个简单的test展示什么是一个对象：

    class Test
      puts "In the definition of class Test"
      puts "self = #{self}"
      puts "Class of self = #{self.class}"
    end
    # produces:
    # In the definition of class Test
    # self = Test
    # Class of self = Class

Inside a class definition, self is set to the class object of the class being defined. 
在类定义内部，self被设置为被定义类的类对象。
This means that instance variables set in a class definition will be available to class methods (because self will be the same when the variables are defined and when the methods execute):
这意味着**在类定义设置的实例变量对类方法来说是可用的**（因为当变量定义和方法执行时self是一样的）

    class Test
      @var = 99
      def self.value_of_var
        @var
      end
    end
    Test.value_of_var # => 99

The fact that self is set to the class during a class definition turns out to be a dramatically elegant decision, but to see why, we’ll first need to have a look at singletons.
事实上，self在类定义期间被设置为类，可谓是一个动态优雅的决定，但要看看为什么，我们将首先需要看看单例。

## 24.2 Singletons 单例
**单例方法**
Ruby lets you define methods that are specific to a particular object. 
ruby可让你定义指定到特定对象的方法。
These are called singleton methods. 
这就是单例方法。
Let’s start with a simple string object:
让我们从一个简单的字符串对象开始：

    animal = "cat"
    puts animal.upcase
    # produces:
    # CAT

This results in the following object structure.
这导致了下面的对象结构。

                 +----------------+
                 |  value: "cat"  |
     animal  +-->|                |
                 |    class: +----|----+       
                 +---------------+     |       
                    +--------+         |           +--------+     
                    | Class  |<--------+           | Class  |     
                 +--| String |----+             +--| Object |----+
                 |  +--------+    |             |  +--------+    |
                 |    super:  +---|---------->  |    super:      |
                 |    class:  +   |             |    class:      |
                 |    method:     |             |    method:     |
                 |     -downcase()|             |     -clone()   |
                 |     -upcase()  |             |     -dup()     |
                 |     -...       |             |     -...       |
                 +----------------+             +----------------+

The animal variable points to an object containing (among other things) the value of the string ("cat") and a pointer to the object’s class, String.
animal变量指向一个对象，其中包含字符串的值（“cat”）和一个指向对象的类别String的指针。

When we call animal.upcase, Ruby goes to the object referenced by the animal variable and then looks up the method upcase in the class object referenced from the animal object. 
当我们调用animal.upcase时，ruby找到被animal变量引用的对象，并在从animal对象引用的类对象中查找upcase方法。
Our animal is a string and so has the methods of class String available.
我们的animal是一个字符串，所以拥有String类变量的方法。

Now let’s make it more interesting. 
现在让我们把它变得更有趣。
We’ll define a singleton method on the string referenced by animal:
我们将定义一个单例方法在animal引用的字符串上：

    animal = "cat"
    def animal.speak
      puts "The #{self} says miaow"
    end
    animal.speak
    puts animal.upcase
    # produces:
    # The cat says miaow
    # CAT

We’ve already seen how the call to animal.speak works when we looked at how methods are invoked. 
当我们看到方法如何被调用时，我们已经看到对animal.speak调用怎么运行。
Ruby sets self to the string object "cat" referenced by animal and then looks for a method speak in that object’s class. 
Ruby将self设置为animal所引用的字符串对象cat，然后在那个对象的类中查找方法speak。
Surprisingly, it finds it. 
惊讶的是它找到了。

It’s initially surprising because the class of "cat" is String, and String doesn’t have a speak method. 
令人惊奇的原因是cat的类是String，但String并没有speak方法。
So, does Ruby have some kind of special-case magic for these methods that are defined on individual objects?
那么，ruby是否拥有一种特定的魔术用于这些在个体对象上定义的方法？

Thankfully, the answer is “no.” 
很高兴答案是没有。
Ruby’s object model is remarkably consistent. 
ruby的对象模型非常一致。
When we defined the singleton method for the "cat" object, Ruby created a new anonymous class and defined the speak method in that class. 
当我们为“cat”对象定义单例方法时，ruby创建了一个新的匿名类，并在该类中定义了speak方法。
This anonymous class is sometimes called a singleton class and other times an eigenclass. 
这个匿名类有时被称为一个单例类，有时叫eigenclass(本征类).
I prefer the former, because it ties in to the idea of singleton methods.
我更喜欢前者，因为它紧密联系着单例方法的理念。

Ruby makes this singleton class the class of the "cat" object and makes String (which was the original class of "cat") the superclass of the singleton class. 
ruby让这个单例归类到cat对象的类中，让String（即cat的原始类）变成单例类的超类。
The picture looks like this:
示意图如下：

                 +----------------+
                 |  value: "cat"  |
     animal  +-->|                |
                 |    class: +----|----+       
                 +---------------+     |       
                     +--------+        |
                     | class  |<-------+
                 +---| anon   |---+
                 |   +--------+   |
                 |      super  +--|----+
                 |    class       |    |       
                 |     method     |    |
                 |     -speak()   |    |
                 +---------------+     |       
                    +--------+         |      +--------+     
                    | class  |<--------+      | class  |     
                 +--| String |---+         +--| Object |--+
                 |  +--------+   |         |  +--------+  |
                 |    super:  +--|-------> |    super:    |
                 |    class:  +  |         |    class:    |
                 |    method:    |         |    method:   |
                 |   -downcase() |         |    -clone()  |
                 |   -upcase()   |         |    -dup()    |
                 |   -...        |         |    -...      |
                 +---------------+         +--------------+

Now let’s follow the call to animal.speak. 
现在让我们顺着animal.speak的调用下去。
Ruby goes to the object referenced by animal and then looks in its class for the method speak. 
ruby到了animal引用的对象，然后在它的类中寻找speak方法。
The class of the animal object is the newly created singleton class, and it contains the method we need.
animal对象的类是个新建的单例，包含了我们需要的方法。

What happens if we instead call animal.upcase? 
如果我们调用animal.upcase时，会发生什么呢？
The processing starts the same way: Ruby looks for the method upcase in the singleton class but fails to find it there. 
开始的处理是一样的：ruby在单例中查找upcase方法，但是失败了。
It then follows the normal processing rules and starts looking up the chain of superclasses. 
然后它沿着正常的处理规则，并开始查找超类链。
The superclass of the singleton is String, and Ruby finds the upcase method there. 
单例的超类是String，ruby在这里找到了upcase方法。
Notice that there is no special-case processing here—Ruby method calls always work the same way.
注意这里没有特定情境处理--ruby方法调用总是用同样的方式来工作。

### 24.2.1 Singletons and Classes 【单例和类】
Earlier, we said that inside a class definition, self is set to the class object being defined. 
早前我们说过在类定义内部，self被设置为被定义的类对象。
It turns out that this is the basis for one of the more elegant aspects of Ruby’s object model.
结果是：这是ruby对象模型更优雅方面的基础。

Recall that we can define class methods in Ruby using either of the forms def self.xxx or def ClassName.xxx:
回想我们在ruby中能用`def self.xxx`或`def ClassName.xxx`的形式定义类方法：

    class Dave
      def self.class_method_one
        puts "Class method one"
      end
      def Dave.class_method_two
        puts "Class method two"
      end
    end
    Dave.class_method_one
    Dave.class_method_two
    # produces:
    # Class method one
    # Class method two

Now we know why the two forms are identical: inside the class definition, self is set to Dave.
现在我们知道为什么两种形式是同样的：在类定义的内部，self被设置为Dave。

But now that we’ve looked at singleton methods, we also know that, in reality, there is no such thing as class methods in Ruby. 
但现在我们已经看过单例方法，我们也知道，事实上在ruby没有这样的类方法。
Both of the previous definitions define singleton methods on the class object. 
前面的两种定义在类对象中定义了单例方法。
As with all other singleton methods, we can then call them via the object (in this case, the class Dave).
和其他单例方法一样，我们可以通过对象（在这个例子中是Dave类）调用它们。

Before we created the two singleton methods in class Dave, the class pointer in the class object pointed to class Class. 
在我们在Dave类创建两个单例方法之前，类对象里面的类指针指向Class类。
(That’s a confusing sentence. Another way of saying it is “Dave is a class, so the class of Dave is class Class,” but that’s pretty confusing, too.) 
（这是个歧义句子。另一种说法是“Dave是一个类，因此Dave类是Class类”，但这也会有歧义）
The situation looks like this:
这情境就像这样：

                    +--------+                  +--------+     
     animal  +-->   | class  |                  | class  |     
                 +--|  Dave  |----+          +--| Object |----+
                 |  +--------+    |          |  +--------+    |
                 |    super:  +---|--------> |    super:      |
                 |    class:  +---|-+        |    class:      |
                 |    method:     | |        |    method:     |
                 |                | |        |     -clone()   |
                 |                | |        |     -dup()     |
                 |                | |        |     -...       |
                 +----------------+ |        +----------------+
                    +--------+      |           +--------+     
                    | class  |<-----+           | class  |     
                 +--|  Class |----+          +--| Mbdule |----+
                 |  +--------+    |          |  +--------+    |
                 |    super:  +---|--------> |    super:      |
                 |    class:      |          |    class:      |
                 |    method:     |          |    method:     |
                 |     -new()     |          |     -clone()   |
                 |                |          |     -dup()     |
                 |     -...       |          |     -...       |
                 +----------------+          +----------------+

The object diagram for class Dave after the methods are defined looks like this:
Dave类在方法定义之后的对象图是这样的：

                +--------+              +--------+     
     animal+--> | class  |              | class  |     
            +---|  Dave  |----+      +--| Object |----+
            |   +--------+    |      |  +--------+    |
            |     super:  +---|----> |    super:      |
            |     class:  +---|-+    |    class:      |
            |     method:     | |    |    method:     |
            |                 | |    |     -clone()   |
            |                 | |    |     -dup()     |
            |                 | |    |     -...       |
            +-----------------+ |    +----------------+
               +--------+       |       +--------+            +--------+     
               | class  |<------+       | class  |            | class  |     
            +--|  anon  |-------+    +--|  Class |----+    +--| Module |----+
            |  +--------+       |    |  +--------+    |    |  +--------+    |
            |    super:  +------|--> |    super:  +---|--> |    super:      |
            |    class:         |    |    class:      |    |    class:      |
            |    method:        |    |    method:     |    |    method:     |
            |-class_method_one()|    |     -new()     |    |     -clone()   |
            |-class_method_two()|    |                |    |     -dup()     |
            |     -...          |    |     -...       |    |     -...       |
            +-------------------+    +----------------+    +----------------+

Do you see how the singleton class is created, just as it was for the animal example? 
你看到单例类是怎么被创建的吗？只是为animal这一例而创建吗？
The class is inserted as the class of Dave, and the original class of Dave is made this new class’s parent.
这个类被插入作为Dave类，原始的Dave类为这个新类的父类。<kinder:note> 这个怎么理解啊？

We can now tie together the two uses of self, the current object. 
我们现在能将两个当前对象self的使用绑在一起。
We talked about how instance variables are looked up in self, and we talked about how singleton methods defined on self become class methods. 
我们谈论实例变量如何在self中被找到，我们也谈了self定义的单例方法怎么变成类方法。
Let’s use these facts to access instance variables for class objects:
让我们使用这些事实来访问类对象的实例变量：

    class Test
      @var = 99
      def self.var
        @var
      end
      def self.var=(value)
        @var = value
      end
    end
    puts "Original value = #{Test.var}"
    Test.var = "cat"
    puts "New value = #{Test.var}"
    # produces:
    # Original value = 99
    # New value = cat

Newcomers to Ruby commonly make the mistake of setting instance variables inline in the class definition (as we did with @var in the previous code) and then attempting to access these variables from instance methods. 
ruby的新手通常在设置类定义内嵌实例变量时出错（就像上例我们对@var的操作一样），然后尝试从实例方法访问这些变量。
As the code illustrates, this won’t work, because instance variables defined in the class body are associated with the class object, not with instances of the class.
正如代码所演示的，这不能运行，因为在类主体中定义的实例变量被联系到类对象，而不是类的实例。

### 24.2.2 Another Way to Access the Singleton Class【访问单例类的其他方法】
We’ve seen how you can create methods in an object’s singleton class by adding the object reference to the method definition using something like def animal.speak.
我们已经看到你是如何使用一些例如`def animal.speak`的方法，通过添加引用到方法定义的对象，来创建单例类的方法。
You can do the same using Ruby’s `class << an_object` notation:
你也可使用ruby的`class << an_object`标记。

    animal = "dog"
    class << animal
       def speak
        puts "The #{self} says WOOF!"
      end
    end
    animal.speak
    # produces:
    # The dog says WOOF!

Inside this kind of class definition, self is set to the singleton class for the given object (animal in this case). 
在这种类定义的内部，self被设置为指定对象（在这个例子中是animal）的单例类。
Because class definitions return the value of the last statement executed in the class body, we can use this fact to get the singleton class object:
因为类定义返回类主体最后一个执行语句的值，我们可用这个事实来获得单例类对象：

    animal = "dog"
    def animal.speak
      puts "The #{self} says WOOF!"
    end
    singleton = class << animal
      def lie
        puts "The #{self} lies down"
      end
      self # << return singleton class object 返回单例类对象
    end
    animal.speak
    animal.lie
    puts "Singleton class object is #{singleton}"
    puts "It defines methods #{singleton.instance_methods - 'cat'.methods}" 
    # <kinder:note> 注意上面一句的输出！你想象得到吗？
    # produces:
    # The dog says WOOF!
    # The dog lies down
    # Singleton class object is #<Class:#<String:0x007fa6910471f0>>
    It defines methods [:speak, :lie]

Note the notation that Ruby uses to denote a singleton class: `#<Class:#<String:...>>`.
注意ruby用来表示单例类的标记：`#<Class:#<String:...>>`

Ruby goes to some trouble to stop you from using singleton classes outside the context of their original object. 
ruby遇到麻烦会阻止你在原始类上下文的外边使用单例类：
For example, you can’t create a new instance of a singleton class:
比如，你不能创建一个新的单例类的实例：

    singleton = class << "cat"; self; end
    singleton.new
    # produces:
    # from prog.rb:2:in `<main>'
    prog.rb:2:in `new': can't create instance of singleton class (TypeError)

Let’s tie together what we know about instance variables, self, and singleton classes. 
让我们将我们关于实例变量、self和单例类的知识放在一起。
We wrote class-level accessor methods on page 363 to let us get and set the value of an instance variable defined in a class object. 
我们在363页写了类级的访问方法（即上一节class Test的例子），我们可以得到和访问定义在类对象的实例变量的值。
But Ruby already has `attr_accessor`, which defines getter and setter methods. 
但ruby已经有了`attr_accessor`，来定义getter和setter方法。
Normally, though, these are defined as instance methods and hence will access values stored in instances of a class. 
虽然通常这些已经定义为实例方法，并因此将访问存储在类的实例的值。
To make them work with class-level instance variables, we have to invoke `attr_accessor` in the singleton class:
要让他们和类级实例变量一起运行，我们只能在单例类中调用`attr_accessor`：
<kinder:note> 下面的例子结果和上一节的一模一样。但写法更简单：

    class Test
      @var = 99
      class << self
        attr_accessor :var
      end
    end
    puts "Original value = #{Test.var}"
    Test.var = "cat"
    puts "New value = #{Test.var}"
    # produces:
    # Original value = 99
    # New value = cat

## 24.3 Inheritace and Visibility 继承与可见性
<kinder:note> 这一节的内容和2版24.4“继承与可见性”的内容几乎一样。变动的只是第一句：
There’s a wrinkle to when it comes to method definition and class inheritance, but it’s fairly obscure.

## 24.4 Modules and Mixin 模块和混入
**include模块**
You know that when you include a module into a Ruby class, the instance methods in that module become available as instance methods of the class.
你知道，当include一个模块进一个ruby类时，模块的实例方法变成可用的类的实例方法。

    module Logger
      def log(msg)
        STDERR.puts Time.now.strftime("%H:%M:%S: ") + "#{self} (#{msg})"
      end
    end
    class Song
      include Logger
    end
    s = Song.new
    s.log("created")
    # produces:
    # 12:31:37: #<Song:0x007f952b0478c0> (created)

Ruby implements include very simply: the module that you include is effectively added as a superclass of the class being defined. 
ruby对include的实现很简单：你include的模块实际被添加作为被定义类的超类。
It’s as if the module is the parent of the class that it is mixed in to. 
这就好像模块是所混入类的父类。
And that would be the end of the description except for one small wrinkle.
除了一个小波折，这可是描述的终点了。

Because the module is injected into the chain of superclasses, it must itself hold a link to the original parent class. 
因为module被注入超类链，它必须自身保持一个到原始父类的链接。
If it didn’t, there’d be no way of traversing the superclass chain to look up methods. 
如果不这样，就没有办法通过父类链来寻找方法了。
However, you can mix the same module into many different classes, and those classes could potentially have totally different superclass chains. 
不过，你可以混入同一个模块到不同的类中，这些类可潜在的拥有完全不同的超类链。
If there were just one module object that we mixed in to all these classes, there’d be no way of keeping track of the different superclasses for each.
如果只有一个模块对象混入所有这些类，就无法保持跟踪每个不同的超类链。

To get around this, Ruby uses a clever trick. 
为了绕开这点，ruby使用了一个聪明的窍门。
When you include a module in class Example, Ruby constructs a new class object, makes it the superclass of Example, and then sets the superclass of the new class to be the original superclass of Example. 
当你在Example类引入一个模块时，ruby构造了一个新的类对象，让它成为Example的父类，然后设置新类的父类成为Example的原始父类。
It then references the module’s methods from this new class object in such a way that when you look a method up in this class, it actually looks it up in the module:
然后用一种方法从这个新类对象引用模块方法--当你在这个类找到一个方法，它实际上实际上在模块里找到：

               +--------+                                 +--------+     
               | class  |                                 | class  |<----+
            +--| Object |--+                           +--| Object |--+  |
            |  +--------+  |                           |  +--------+  |  |
            |    super:    |                           |    super:    |  |
            |    class:  +-|-+                         |    class:    |  |
            |    method:   | |                         |    method:   |  |
            |    -clone()  | |                         |     -clone() |  |
            |    -dup()    | |                         |     -dup()   |  |
            |    -...      | |                         |     -...     |  |
            +--------------+ |                         +--------------+  |
               +--------+    |       +--------+          +--------+      | 
               | class  |<---|+      | Module |          | class  |<---+ |
            +--|  anon1 |--+ ||   +--| Logger |--+    +--|  anon2 |--+ | |
            |  +--------+  | ||   |  +--------+  |    |  +--------+  | | |
            |    super:  +-|-+|   |    super:    |    |    super: +--|-|-+
            |    class:    |  |   |    class:    |    |    class:    | |
            |    method: --|--|-->|    method:   |<---|    method:   | |
            |              |  |   |     -log()   |    |              | |
            |     -...     |  |   |     -...     |    |              | |
            +--------------+  |   +--------------+    +--------------+ |
               +--------+     |                          +--------+    |  
               | class  |     |                          | class  |    |   
            +--|  Album |--+  |                       +--| Song   |--+ |
            |  +--------+  |  |                       |  +--------+  | |
            |    super:  +-|--+                       |    super: ---|-+
            |    class:    |                          |    class:    |
            |    method:   |                          |    method:   |
            |     -...     |                          |   -...       |
            +--------------+                          +--------------+

A nice side effect of this arrangement is that if you change a module after including it in a class, those changes are reflected in the class (and the class’s objects). 
这个安排的一个正面作用是如果你在类里引入之后改变了模块，那些改变会被反映在类中（和那些类对象中）。
In this way, modules behave just like classes.
按这个方式，模块的表现很像类。

    module Mod
      def greeting
        "Hello"
      end
    end
    class Example
      include Mod
    end
    ex = Example.new
    puts "Before change, greeting is #{ex.greeting}"
    module Mod
      def greeting
        "Hi"
      end
    end
    puts "After change, greeting is #{ex.greeting}"
    # produces:
    # Before change, greeting is Hello
    # After change, greeting is Hi

If a module itself includes other modules, a chain of proxy classes will be added to any class that includes that module, one proxy for each module that is directly or indirectly included.
如果一个模块自包含其他模块，一个代理类的链将被添加到那个包含该模块的类中，每个直接或间接的模块都有一个代理。
Finally, Ruby will include a module only once in an inheritance chain—including a module that is already included by one of your superclasses has no effect.
最后，ruby将只在继承链对每个模块包含一次--包含一个已经被超类包含的模块不会影响。

####  prepend 前置
⇡New in 2.0⇣
Ruby 2 introduced the prepend method. 
Ruby 2引入了prepend方法。
Logically, this behaves just like include, but the methods in the prepended module take precedence over those in the host class. 
逻辑上，这个表现很像include，但前置过的模块的方法比主类中的方法有更高的优先级。
Ruby pulls off this magic by inserting a dummy class in place of the original host class[2] and then inserting the prepended module between the two.
Ruby通过插入一个虚构类来替代原始主类，然后在两者之间插入预置模块。
[2]. Actually, it inserts the dummy class above the original class, and then moves the methods from the original to the copy.
实际上，它在原始类之上插入了一个虚构类，然后加方法从原始类移动到拷贝中。

If a method inside a prepended module has the same name as one in the original class, it will be invoked instead of the original. 
如果原始类本身有一个和预置模块同名的方法，则预置模块内的方法将比原类的方法更先被调用。
The prepended method can then call the original using super.
预置方法可以使用super调用原类。
<kinder:note> 优先级颠倒了过来。如果模块是父类，则应调用原类中的方法。这一法则在这里被颠覆了。

    module VanityPuts
      def puts(*args)
        args.each do |arg|
          super("Dave says: #{arg}")
        end
      end
    end
    class Object
      prepend VanityPuts
    end
    puts "Hello and", "goodbye"
    # produces:
    # Dave says: Hello and
    # Dave says: goodbye

However, there is a problem with this—the change we just made to class Object is global.
不过，这里有个问题--如果我们改变的类Object是全局的。
We’ll see how to fix that shortly when we look at refinements.
当看到提炼，我们将看看怎么简短修复那个不足。
<kinder:note> 下面有个小节是refinement。

#### extend 扩展
The include method effectively adds a module as a superclass of self. 
include方法有效添加一个模块作为self的超类。
It is used inside a class definition to make the instance methods in the module available to instances of the class.
这用于在类定义内部，让模块的实例方法为类实例所用。

However, it is sometimes useful to add the instance methods to a particular object. 
不过，有时将实例方法添加到特定对象也很有用。
You do this using Object#extend. 
你可以用Object#extend来做。
Here’s an example:
这是个例子：

    module Humor
      def tickle
        "#{self} says hee, hee!"
      end
    end
    obj = "Grouchy"
    obj.extend Humor
    obj.tickle # => "Grouchy says hee, hee!"

Stop for a second to think about how this might be implemented.
停一秒下来想想这是怎么实现的。

When Ruby executes obj.tickle in this code example, it does the usual trick of looking in the class of obj for a method called tickle. 
当ruby在这个代码例子里执行obj.tickle时，它使用平常的窍门在obj类中寻找tickle方法。
For extend to work, it has to add the instance methods in the Humor module into the superclass chain for the class of obj. 
extend要工作，它只有添加Humor模块里的实例方法到obj类的超类链。
So, just as with singleton method definitions, Ruby creates a singleton class for obj and then includes the module Humor in that class. 
所以，正像单例方法定义那样，ruby为obj创建了一个单例类，然后在那个类中包含了Humor模块。
In fact, just to prove that this is all that happens, here’s the C implementation of extend in the current Ruby 1.9 interpreter:
事实上，为了证明这个真实性，这是当前Ruby 1.9解释器中extend的C实现。

    void rb_extend_object(VALUE obj, VALUE module) {
      rb_include_module(rb_singleton_class(obj), module);
    }

There is an interesting trick with extend. 
这是extend一个有趣的窍门。
If you use it within a class definition, the module’s methods become class methods. 
如果你在类定义里面使用它，模块的方法变成了类方法。
This is because calling extend is equivalent to self.extend, so the methods are added to self, which in a class definition is the class itself.
这是因为调用extend等同于self.extend，所以方法被添加到self，在类定义中是类本身。

Here’s an example of adding a module’s methods at the class level:
这是一个例子，添加一个模块方法在类层。

    module Humor
      def tickle
        "#{self} says hee, hee!"
      end
    end
    class Grouchy
      extend Humor
    end
    Grouchy.tickle # => "Grouchy says hee, hee!"

Later on page 375, we’ll see how to use extend to add macro-style methods to a class.
在稍后的375页“类方法和模块”一节中，我们将看到如何使用extend来添加一个宏风格（<kinder:note> 译为“宏体”岂不更好？）的方法到类中。

#### Refinements 提炼
⇡New in 2.0⇣
We previously looked at applying a change to a builtin class by defining the altered version of a method in a module, and then prepending that module in the class. 
我们之前看到通过模块中定义一个改动的版本实施一些改变到内建类中，然后前置类中的那个模块。
When we subsequently call the method on instances of the class, it finds the version in the module first.
当我们后来在类的实例调用方法时，它首先发现了模块中的版本。

This technique is time-honored—frameworks such as Ruby on Rails rely on it. 
这个技巧算是历史悠久了--ruby on rails框架就依赖它。
But it comes with a price—any changes we make like this are global. 
但它是有代价的--任何类似的改变都是全局性的。
They apply not just to the code we wrote for our application, but also to the code in all the libraries and gems we use, too. 
它们的实施不仅仅针对我们为应用所写的代码，也实施到我们使用的所有库和gems的代码。
It is possible that a change that made our code easier to write breaks someone else’s library code that we rely on.[3]
有可能，我们轻易写出的代码的一个变动会破坏我们依赖的别人的库代码。
[3] This is clearly a problem in theory. 
理论上这是一个问题。
Does it happen in practice? Actually, surprisingly little. 
实践中这会发生吗？事实上，令人吃惊的少。
But you can never be sure that things will quite work as you expect. 
但你决不能相信事情会像你期待的那样顺利。
Even if you don’t override these classes, it is possible you’re using two separate libraries whose patches to third-party classes clash.
即使你不覆写这些类 ，可能你使用的两个独立库的补丁就会和第三方类发生冲突。

Ruby 2.0 is experimenting with a new way of dealing with this problem. 
Ruby 2.0正尝试一个新的方法来解决这个问题。
The technique is called refinements.
这个技术被称为提炼。

Now, before going any further, here is the mandatory warning. 
现在，在进一步之前，这是一些强制性警告。
Refinements are not yet completely worked out. 
提炼这个功能还没有全部完成。
In fact, a fair amount of refinement functionality was removed just a few weeks before Ruby 2.0 was released. 
事实上，相当多的提炼功能在ruby2释放版本之前被移除了。
So what we’re documenting here may well become outdated as new releases of Ruby change the spec. 
我们这里描述的所谓提炼可能变得过时，当ruby的新版本改变了spec。
If you are writing code that uses refine- ments, you’ll want to keep track of these changes.
如果你正写这使用提炼的代码，你需要关注这些改变。

A refinement is a way of packaging a set of changes to one or more classes. 
提炼是一个方法来包装一组一个或多个类的变动。
These refinements are defined within a module.
这些提炼被定义在模块中。

If a Ruby source file then elects to use this module of refinements, the change will apply to the source in that module past the point where the refinement is used. 
如果一个ruby源文件选择使用这个提炼的模块，改变将会应用到模块里的源，穿过使用提炼的那点。
However code outside this file is not affected.
不管怎样这个文件外面的代码是不受影响的。

Let’s make this concrete. 
我们具体一点。
Here’s our vanity version of puts rewritten using refinements.
这是我们通过使用提炼写出的puts的虚拟版本。

    module VanityPuts
      refine Object do
        private
        def puts(*args)
          args.each do |arg|
            Kernel::puts("Dave says: #{arg}")
          end
        end
      end
    end
    using VanityPuts
    puts "Hello", "world"
    # produces:
    # prog.rb:2: warning: Refinements are experimental, and the behavior may change in future versions of Ruby!
    # Dave says: Hello
    # Dave says: world

The refinement is contained in the module VanityPuts. 
提炼被放在VanityPuts模块中。
The refine block takes a class and a block. 
提炼block是一个类和一个block。
Within the block are the methods that you would like to update in that class. 
在block内部是类中你要升级的方法。
At this point, no change is made—you have defined a method, but haven’t yet told Ruby to use it.
在这点上，没有改变什么--你已经定义了一个方法，但ruby还没有用它。

That’s what the using clause does. 
那是using语句要做的事情。
You give it a module containing one or more refinements, and it marks the refined objects to say “for the rest of this source file, when you make a call to an instance of Object, first check to see if the method can be found in the refinement. 
你给它一个模块，包含一个或多个提炼，它标记提炼的对象说：“这个源文件的其他部分，当你调用一个对象实例时，首先检查方法能否在提炼中找到”
If so, invoke it, otherwise invoke the original.
如果是，调用它，否则调用原始的那个方法。

Let’s step it up a notch. 
让我们更进一步。
We’ll define three source files. 
我们将定义三个源文件。
Here’s one that contains a refinement definition:
这是一个包含提炼的定义：

    # metaprogramming/ref1/vanity_refinement.rb
    module VanityPuts
      refine Object do
        private
        def puts(*args)
          args.each do |arg|
            Kernel::puts("Dave says: #{arg}")
          end
        end
      end
    end

And here’s a file that uses this refinement.
这是一个使用提炼的文件。

    # metaprogramming/ref1/file_using_refinement.rb
    using VanityPuts
    puts "I'm in #{File::basename(__FILE__)}"
    def shout(msg)
      puts(msg.upcase)
    end

Finally, let’s run them from a third file:
最后，从第三个文件运行他们：

    require_relative 'vanity_refinement'
    puts "About to require file using refinement"
    require_relative 'file_using_refinement'
    puts "Back from require"
    shout("finished")
    # produces:
    # prog.rb:2: warning: Refinements are experimental, and the behavior may change in future versions of Ruby!
    # About to require file using refinement
    # Dave says: I'm in file_using_refinement.rb
    # Back from require
    # Dave says: FINISHED

Notice how the puts calls in the main program are unadorned, but the calls in the file that uses the refinement has the vanity prefix.
注意主程序中的puts调用是怎么被卸去的，但文件里使用提炼的调用有一个vanity前缀。

#### Refinements—use and scoping 【提炼-使用和作用域】
You can define refinements in any module. 
你可以在任何模块中定义提炼。
A refinement may only refer to a class (not a module).
提炼可能只指向类（不是模块）。

The using call that activates a refinement module can only occur at the top-level scope or in a string that is evaluated. 
using调用激活一个提炼模块，仅发生在顶级作用域或所赋值的字符串中。
using may not be called inside a class or module definition.[4]
using在类或模块定义的内部可能不被调用
[4].  This is the area where we’re likely to see changes in the future.
这是未来我们想改变的地方。

The basic scoping rule is simple. 
基本作用域规则很简单。
A refinement is activated in a source file by calling using.
提炼只在调用using的源文件中激活。
For the rest of that source file, the methods that are defined in that refinement are active.
对于源文件的剩余部分，在提炼中定义的方法是激活的。

#### Designing with Refinements 【用提炼设计】
Refinements are too new for the community to have come to any kind of consensus on the best way to use them. 
对社区来说提炼太新颖了，因此没有什么最佳使用的指南。
However, it seems likey that there are at least two basic use cases.
不过，看起来至少有两种基本的情况。

The first is the case where a developer wants to make changes to a third party class for their own use. 
第一种情况是开发者想改变他们所使用的第三方类。
For example, a tool such as Rake, which issues a lot of calls to run external programs using the system method might want to modify the built-in version of system so that it logs errors differently. 
比如，诸如Rake的工具，会使用系统方法发出很多调用来运行外部程序，可能想修改系统的内建版本，以便以不同的方式记录错误。
However, it does not want that logging to apply to other calls to system that are not part of Rake. 
不过，但它不想记录应用到非Rake部分的其他系统调用。
In this case, the code will use the refinement locally within its own source files. 
在这个情况下，代码将在自身的源文件本地使用提炼。
It will be an implementation detail, hidden from users of the code.
这将是一个执行细节，其中隐藏了用户的代码。

The second use case is where a library writer offers the refinement as part of their external interface. 
第二种使用情况是，在库程序员提供了提炼作为他们外在界面的一部分。
For example, the Rails Active Support code defines methods such as hours, minutes, and ago on numbers, allowing you to write 3.days.ago. 
比如，Rails Active Support代码定义了诸如hours, minutes,ago等方法在数字上，允许你写3.days.ago。
Right now, those changes to numbers are global. 
现在，数字的那些改变成了全局性的。
But, using refinements, the Rails team could code the new methods, but not add them in to any system classes.
但使用提炼，Rails小组可以写出新的方法，不会将它们添加到任何系统类中。 
Instead, their API would document how to add them for yourself into just those source files that uses them. 
相反，他们的API会写着怎么为你自身添加它们到使用它们的那些源文件中。
They might tell you to to write using Rails::Extensions::Durations in any source file that needs to use them.
他们可能告诉你写`using Rails::Extension::Durations`在需要使用它们的源文件中。

Obviously there are many more use cases. 
明显还有许多用例。
And the two we’ve mentioned are not mutually exclusive—the Rails framework, for example, is likely to want to use these duration-related methods itself, as well as making them available via a documented refinement. 
这两个我们提到的用例并不是互斥的--比如Rails框架，就喜欢自身使用这些“期间关联”的方法，同时通过一个documented的提炼让它们可用。
So this is an interesting time to work with Ruby—as a community we’ll be discussing how best to use refinements for many years.
因此，这是一个有趣的时间去用ruby--作为社区,在许多年里我们将讨论怎么使用提炼的最佳方式。

## 24.5 Metaprogramming Class-level Macros 【元编程类级宏】
**一步一步重写`attr_accessor`方法**
If you’ve used Ruby for any time at all, you’re likely to have used `attr_accessor`, the method that defines reader and writer methods for instance variables:
如果你已经使用过ruby， 你应该使用过`attr_accessor`，为一个实例变量定义一个读入和写入的方法：

    class Song
      attr_accessor :duration
    end

If you’ve written a Ruby on Rails application, you’ve probably used `has_many`:
如果你写过Ruby On Rails应用，你应该使用过`has_many`：

    class Album < ActiveRecord::Base
      has_many :tracks
    end

These are both examples of class-level methods that generate code behind the scenes. 
两个在场景之后产生代码的类级方法都有例子。
Because of the way they expand into something bigger, folks sometimes call these kinds of methods macros.
因为它们扩展进一些更多的方法，folks有时调用这些种类的方法宏。

Let’s create a trivial example and then build it up into something realistic. 
让我们创建一个微小的例子，然后构建进一些现实的东西。
We’ll start by implementing a simple method that adds logging capabilities to instances of a class. 
我们将开始，通过实现一个简单的方法，即增加类实例的记录能力。
We previously did this using a module—this time we’ll do it using a class-level method. 
我们之前用一个模块来做--这一回我们将使用一个类级方法来做。
Here’s the first iteration:
这是第一个迭代：

    class Example
      def self.add_logging
        def log(msg)
          STDERR.puts Time.now.strftime("%H:%M:%S: ") + "#{self} (#{msg})"
        end
      end
      add_logging
    end
    ex = Example.new
    ex.log("hello")
    # produces:
    # 12:31:38: #<Example:0x007fc14310fa20> (hello)

Clearly, this is a silly piece of code. 
很明显，这是一段愚蠢的代码。
But bear with me—it’ll get better. 
但我受得了--可以更好写。
And we can still learn some stuff from it. 
我们仍可从中学到一些东西。
First, notice that `add_logging` is a class method—it is defined in the class object’s singleton class. 
首先，注意`add_logging`是一个类方法--定义在类对象的单例方法。
That means we can call it later in the class definition without an explicit receiver, because self is set to the class object inside a class definition.
那意味着我们能稍后在在类定义里面调用它，无需明显的接收者，因为self被设置为类定义的类对象。

Then, notice that the `add_logging` method contains a nested method definition. 
然后，注意`add_logging`方法包含一个嵌入的方法定义。
This inner definition will get executed only when we call the `add_logging` method. 
这个内部定义将只在我们调用`add_logging`方法时执行。
The result is that log will be defined as an instance method of class Example.
结果是log将被定义为Example类的一个实例方法。

Let’s take one more step. 
下一步，
We can define the `add_logging` method in one class and then use it in a subclass. 
我们可在一个类中定义`add_logging`，然后在子类中使用它。
This works because the singleton class hierarchy parallels the regular class hierarchy. 
因为单例类层级和正常的类层级是并行的，所以这可以运行。
As a result, class methods in a parent class are also available in the child class, as the following example shows.
作为结果，父类中的类方法在子类中也可用，正如随后的例子所显示的。

    class Logger
      def self.add_logging
        def log(msg)
          STDERR.puts Time.now.strftime("%H:%M:%S: ") + "#{self} (#{msg})"
        end
      end
    end
    class Example < Logger
      add_logging
    end
    ex = Example.new
    ex.log("hello")
    # produces:
    # 12:31:38: #<Example:0x007fcc5c0473d0> (hello)

Think back to the two examples at the start of this section. 
回想这一节的两个例子。
Both work this way. 
都是以这样的方式工作。
`attr_accessor` is an instance method defined in class Module and so is available in all module and class definitions. 
`attr_accessor`是一个实例方法，定义在类模块中，因此在所有模块和类定义中都是可用的。
`has_many` is a class method defined in the Base class within the Rails ActiveRecord module and so is available to all classes that subclass ActiveRecord::Base.
`has_many`是一个类方法，定义在Rails的ActiveRecord模块Base类中，因此对所有ActiveRecord::Base的子类都是可用的。

This example is still not particularly compelling; it would still be easier to add the log method directly as an instance method of our Logger class. 
这个例子仍不算太强制;直接添加log方法作为Logger类的实例方法，还是很容易。
But what happens if we want to construct a different version of the log method for each class that uses it? 
但如果我们想为每个使用log方法的类构造一个不同的版本的log方法，会发生什么呢？
For example, let’s add the capability to add a short class-specific identifying string to the start of each log message. 
比如，让我们将增加一个能力：添加一个短的指定类识别字符串到每个log消息的开始
We want to be able to say something like this:
我们想能够这样说：

    class Song < Logger
      add_logging "Song"
    end
    class Album < Logger
      add_logging "CD"
    end

To do this, let’s define the log method on the fly. 
要做这个，让我们赶快定义log方法。
We can no longer use a straightforward def...end-style definition. 
我们不再使用一个直接的`def~end`风格的定义。
Instead, we’ll use one of the cornerstones of metaprogramming, `define_method`. 
相反，我们使用元编程其中一个基础`define_method`。
This takes the name of a method and a block, defining a method with the given name and with the block as the method body. 
这需要一个方法名和一个block，定义一个方法，用指定名字和block作为方法主体来定义一个方法。
Any arguments in the block definition become parameters to the method being defined.
block定义的任意实参变成传给所定义方法的形参。

    class Logger
      def self.add_logging(id_string)
        define_method(:log) do |msg|
          now = Time.now.strftime("%H:%M:%S")
          STDERR.puts "#{now}-#{id_string}: #{self} (#{msg})"
        end
      end
    end
    class Song < Logger
      add_logging "Tune"
    end
    class Album < Logger
      add_logging "CD"
    end
    song = Song.new
    song.log("rock on")
    # produces:
    # 12:31:38-Tune: #<Song:0x007f9afb90e1b8> (rock on)

There’s an important subtlety in this code. 
这段代码有一个重要的微妙。
The body of the log method contains this line:
log方法的主体包含这么一行：

    STDERR.puts "#{now}-#{id_string}: #{self} (#{msg})"

The value now is a local variable, and msg is the parameter to the block. 
now的值是个局部变量，smg是block的形参。
But `id_string` is the parameter to the enclosing `add_logging` method. 
但`id_string`是个封装的`add_logging`方法的形参。
It’s accessible inside the block because block definitions create closures, allowing the context in which the block is defined to be carried forward and used when the block is used. 
在block内部是可用的，因为**block定义创建了一个闭包**，当block被使用时允许被定义block里面的上下文可被向前运载和使用。
In this case, we’re taking a value from a class- level method and using it in an instance method we’re defining.
在这个例子中，我们从一个类级的方法中得到一个值，并在一个我们定义的实例方法里面使用它。 
This is a common pattern when creating these kinds of class-level macros.
当我们创建这种类型的类级宏时，这是一般的模型。

As well as passing parameters from the class method into the body of the method being defined, we can also use the parameter to determine the name of the method or methods to create. 
和通过从类方法传递形参到所定义方法的主体一样，我们也使用形参来决定要创建的方法的名字。
Here’s an example that creates a new kind of `attr_accessor` that logs all assignments to a given instance variable:
这是一个例子，创建了一个新种类的`attr_accessor`方法，记录所有的作业给一个指定的实例变量。

    class AttrLogger
      def self.attr_logger(name)
        attr_reader name
        define_method("#{name}=") do |val|
          puts "Assigning #{val.inspect} to #{name}"
          instance_variable_set("@#{name}", val)
        end
      end
    end
    class Example < AttrLogger
      attr_logger :value
    end
    ex = Example.new
    ex.value = 123
    puts "Value is #{ex.value}"
    ex.value = "cat"
    puts "Value is now #{ex.value}"
    # produces:
    # Assigning 123 to value
    # Value is 123
    # Assigning "cat" to value
    # Value is now cat

Again, we use the fact that the block defining the method body is a closure, accessing the name of the attribute in the log message string. 
再一次，我们使用了这个事实，定义在方法主体的block是个闭包，能够访问log信息字符串里的属性的名称。
Notice we also make use of the fact that `attr_reader` is simply a class method—we can call it inside our class method to define the reader method for our attribute. 
注意我们也使用了一个事实：`attr_reader`只是一个类方法--我们可在类方法内部调用它去为属性定义reader方法。
Note another common bit of metaprogramming—we use `instance_variable_set` to set the value of an instance variable (duh). 
注意另一个元编程的普通点--我们使用`instance_variable_set`来设置实例变量的值（duh）。
There’s a corresponding `_get` method that fetches the value of a named instance variable.
还有一个对应的`_get`方法，取出已命名的实例变量值的值。

#### Class Methods and Modules 【类方法和模块】
You can define class methods in one class and then use them in subclasses of that class. 
你可以在一个类中定义类方法然后在该类的子类中使用它们。
But it is often inappropriate to use subclassing, either because we already have to subclass some other class or because our design aesthetic rebels against making Song a subclass of Logger.
但使用子类经常不太合适，或者因为已经有了其他的父类，或者因为我们的设计美学不允许让Song成为Logger的子类。

In these cases, you can use a module to hold your metaprogramming implementation. 
在这些情况下，你可以使用模块来实现元编程。
As we’ve seen, using extend inside a class definition will add the methods in a module as class methods to the class being defined:
正如我们见过的，在类定义内部使用extend扩展将在模块中的方法增添为在所定义类中的类方法，

    module AttrLogger
      def attr_logger(name)
        attr_reader name
        define_method("#{name}=") do |val|
          puts "Assigning #{val.inspect} to #{name}"
          instance_variable_set("@#{name}", val)
        end
      end
    end
    class Example
      extend AttrLogger
      attr_logger :value
    end
    ex = Example.new
    ex.value = 123
    puts "Value is #{ex.value}"
    ex.value = "cat"
    puts "Value is now #{ex.value}"
    # produces:
    # Assigning 123 to value
    # Value is 123
    # Assigning "cat" to value
    # Value is now cat

Things get a little trickier if you want to add both class methods and instance methods into the class being defined. 
如果你想增加类方法和实例方法到所定义类中，只需要一点小窍门。
Here’s one technique, used extensively in the implementation of Rails. 
这里是一个技巧，广泛地运用在Rails的实现中。
It makes use of a Ruby hook method, included, which is called automatically by Ruby when you include a module into a class. 
它利用了ruby的hook钩子方法，included，当你include一个模块进入类时被ruby自动调用。
It is passed the class object of the class being defined.
它被传递到所定义类的类对象中。

    module GeneralLogger
      # Instance method to be added to any class that includes us
      # 实例方法，被添加到任何include我们的类中。
      def log(msg)
        puts Time.now.strftime("%H:%M: ") + msg
      end
      # module containing class methods to be added
      # 包含被添加的类方法的模块
      module ClassMethods
        def attr_logger(name)
          attr_reader name
          define_method("#{name}=") do |val|
            log "Assigning #{val.inspect} to #{name}"
            instance_variable_set("@#{name}", val)    # <kinder:note> 这个函数怎么说？
          end
        end
      end
      # extend host class with class methods when we're included
      # 当我们include之后，用类方法扩展主类
      def self.included(host_class)
        host_class.extend(ClassMethods)
      end
    end
    class Exampleoutdated
      include GeneralLogger
      attr_logger :value
    end
    ex = Example.new   # <kinder:note>应该是ex = Exampleoutdated.new吧？
    ex.log("New example created")
    ex.value = 123
    puts "Value is #{ex.value}"
    ex.value = "cat"
    puts "Value is #{ex.value}"
    # produces:
    # 12:31: New example created
    # 12:31: Assigning 123 to value
    # Value is 123
    # 12:31: Assigning "cat" to value
    # Value is cat

Notice how the included callback is used to extend the host class with the methods defined in the inner module ClassMethods.
注意被包含的回调如何被用于用在ClassMethods模块内所定义方法去扩展主类。

Now, as an exercise, try executing the previous example in your head. 
现在，作为一个练习，尝试在头脑里面执行前面的例子。
For each line of code, work out the value of self.
想想每一行代码self的值。
Master this, and you’ve pretty much mastered this style of metaprogramming in Ruby.
掌握了这个，你将相当精通ruby这种风格的元编程了。

## 24.6 Two Other Forms of Class Definition 类定义的另外两种形式
Just in case you thought we’d exhausted the ways of defining Ruby classes, let’s look at two other options.
在这个例子中你想我们已经穷尽了ruby类的定义方法，让我看看另外两种选择吧。

### 24.6.1 Subclassing Expressions 【子类表达式】
**正常的类定义语法**
The first form is really nothing new—it’s simply a generalization of the regular class definition syntax. 
第一种形式没什么新鲜--就只是一个正常的类定义语法：
You know that you can write this:
你知道这样写：

    class Parent
      ...
    end
    class Child < Parent
      ...
    end

What you might not know is that the thing to the right of the < needn’t be just a class name; it can be any expression that returns a class object. 
你可能不知道 < 的右边不仅仅是一个类名，还可以是任何返回类名的表达是。
In this code example, we have the constant Parent. 
在这个代码例子中，我们使用常量Parent。
A constant is a simple form of expression, and in this case the constant Parent holds the class object of the first class we defined.
常量是表达式的简单形式，在这例子中，常量Parent保存着我们定义的第一个类的类对象。

**Struct类**
Ruby comes with a class called Struct, which allows you to define classes that contain just data attributes. 
ruby自带一个Struct类，这个类允许你定义只包含日期属性的类。
For example, you could write this:
比如，你可以这样写：

    Person = Struct.new(:name, :address, :likes)
    dave = Person.new('Dave', 'TX')
    dave.likes = "Programming Languages"
    puts dave
    # produces:
    # #<struct Person name="Dave", address="TX", likes="Programming Languages">

The return value from Struct.new(...) is a class object. 
从Struct.new(...)返回的值是一个类对象。
By assigning it to the constant Person, we can thereafter use Person as if it were any other class.
将常量Person赋值给它之后，我们能像使用其他类那样使用Person。

But say we wanted to change the `to_s` method of our structure.
但假如我们想改变我们的构造的`to_s`方法。
We could do it by opening up the class and writing the following method.
我们能通过打开类并写入下面的方法来做：

    Person = Struct.new(:name, :address, :likes)
    class Person
      def to_s
        "#{self.name} lives in #{self.address} and likes #{self.likes}"
      end
    end

However, we can do this more elegantly (although at the cost of an additional class object) by writing this:
不过，这样写的话，我们能更优雅地做到（尽管要付出另一个类对象的代价）：

    class Person < Struct.new(:name, :address, :likes)
      def to_s
        "#{self.name} lives in #{self.address} and likes #{self.likes}"
      end
    end
    dave = Person.new('Dave', 'Texas')
    dave.likes = "Programming Languages"
    puts dave
    # produces:
    # Dave lives in Texas and likes Programming Languages

### 24.6.2 Creating Singleton Classes【创建单例类】
Let’s look at some Ruby code:
我们看看一下ruby代码：

    class Example
    end
    ex = Example.new

When we call Example.new, we’re invoking the method new on the class object Example. 
当我们调用Example.new时，我们是在类对象Example上调用new方法。
This is a regular method call—Ruby looks for the method new in the class of the object (and the class of Example is Class) and invokes it. 
这是正常的调用--ruby在类的对象（Example是个Class）中寻找方法，并调用该方法。
So we can also invoke Class#new directly:
所以我们也可以直接调用`Class#new`：

    some_class = Class.new
    puts some_class.class
    # produces:
    # Class

If you pass Class.new a block, that block is used as the body of the class:
如果你传一个block给Class.new，那个block被当作类的主体来使用：

    some_class = Class.new do
      def self.class_method
        puts "In class method"
      end
      def instance_method
        puts "In instance method"
      end
    end
    some_class.class_method
    obj = some_class.new
    obj.instance_method
    # produces:
    # In class method
    # In instance method

By default, these classes will be direct descendents of Object. 
默认情况下，这些类将是Object直接派生的。
You can give them a different parent by passing the parent’s class as a parameter:
你可以通过以父类作为参数传递，给它们一个不同的父类。

    some_class = Class.new(String) do
      def vowel_movement
        tr 'aeiou', '*'
      end
    end
    obj = some_class.new("now is the time")
    puts obj.vowel_movement
    # produces:
    # n*w *s th* t*m*

We can use these dynamically constructed classes to extend Ruby in interesting ways. 
我们可以通过有趣的方法使用这些动态构造类来扩展ruby。
For example, here’s a simple reimplementation of the Ruby Struct class:
比如，这是一个Ruby构造类的再实现：

    def MyStruct(*keys)
      Class.new do
        attr_accessor *keys
        def initialize(hash)
          hash.each do |key, value|
            instance_variable_set("@#{key}", value)
          end
        end
      end
    end
    Person = MyStruct :name, :address, :likes
    dave = Person.new(name: "dave", address: "TX", likes: "Stilton")
    chad = Person.new(name: "chad", likes: "Jazz")
    chad.address = "CO"
    puts "Dave's name is #{dave.name}"
    puts "Chad lives in #{chad.address}"
    # produces:
    # Dave's name is dave
    # Chad lives in CO

### How Classes Get Their Names 【Class如何取得他们的名字】
You may have noticed that the classes created by Class.new have no name. 
你可能已经留意到用Class.new创建的类没有名字。
However, if you assign the class object for a class with no name to a constant, Ruby automatically names the class after the constant:
不过，如果你赋一个类对象给一个类，却不指定一个常量作为名字，ruby将在收到常量后自动命名。

    some_class = Class.new
    obj = some_class.new
    puts "Initial name is #{some_class.name}"
    SomeClass = some_class
    puts "Then the name is #{some_class.name}"
    puts "also works via the object: #{obj.class.name}"
    # produces:
    # Initial name is
    # Then the name is SomeClass
    # also works via the object: SomeClass

## 24.7 `instance_eval` and `class_eval` 
**重设self**
The methods `Object#instance_eval`, `Module#class_eval`, and `Module#module_eval` let you set self to be some arbitrary object, evaluate the code in a block with, and then reset self:
`Object#instance_eval`, `Module#class_eval`, 和`Module#module_eval`方法让你将self设置为任意对象，在block中计算代码，然后重设self。

    "cat".instance_eval do
      puts "Upper case = #{upcase}"
      puts "Length is #{self.length}"
    end
    # produces:
    # Upper case = CAT
    # Length is 3

Both forms also take a string, but this is considered a little dangerous.
这个形式对字符串也有效，但这有些危险。

First, it is slow—calling eval effectively compiles the code in the string before executing it.
首先是慢--调用eval要有效编译字符串的代码，然后才执行。
But, even worse, eval can be dangerous. 
不过更糟的是，eval还会危险。
If there’s any chance that external data—stuff that comes from outside your application—can wind up inside the parameter to eval, then you have a security hole, because that external data may end up containing arbitrary code that your application will blindly execute.
如果内部数据有任何改变--这种事来自应用程序之外--可以结束内部参数到eval，然后你就会出现一个安全漏洞，因为外部数据可能结束，包含任意代码，你的应用程序会盲目执行。
That said, here’s an example using a string parameter:
那就是说，这是一个使用字符串参数的例子：

    "cat".instance_eval('puts "Upper=#{upcase}, length=#{self.length}"')
    # produces:
    # Upper=CAT, length=3

`class_eval` and `instance_eval` both set self for the duration of the block. 
`class_eval` and `instance_eval` 都会在block期间设置self。
However, they differ in the way they set up the environment for method definition. 
不过它们为方法定义设置环境的方式是不同的。
`class_eval` sets things up as if you were in the body of a class definition, so method definitions will define instance methods:
`class_eval`的设置好像你在类定义里面，因此方法定义将定义实例方法：

    class MyClass
    end
    MyClass.class_eval do
      def instance_method
        puts "In an instance method"
      end
    end
    obj = MyClass.new
    obj.instance_method
    # produces:
    # In an instance method

In contrast, calling `instance_eval` on a class acts as if you were working inside the singleton class of self. 
相反，在一个类调用`instance_eval`就好象在self的单例类中运行。
Therefore, any methods you define will become class methods.
因此，你定义的任何方法都变成类方法。

    class MyClass
    end
    MyClass.instance_eval do
      def class_method
        puts "In a class method"
      end
    end
    MyClass.class_method
    # produces:
    # In a class method

It might be helpful to remember that, when defining methods, `class_eval` and `instance_eval` have precisely the wrong names: `class_eval` defines instance methods, and `instance_eval` defines class methods. 
当定义方法时，`class_eval`和`instance_eval`都名不副实：`class_eval`定义的是实例方法，而`instance_eval`定义的是类方法。记住这点十分有用。
Go figure.
想想看吧。

Ruby has variants of these methods. 
Ruby有这些方法的变量。
`Object#instance_exec`, `Module#class_exec`, and `Module#module_exec` behave identically to their `_eval` counterparts but take only a block (that is, they do not take a string). 
`Object#instance_exec`, `Module#class_exec`, 和`Module#module_exec` 的表现对应这他们的`_eval`副本，但只带一个block（就是说它们没有带一个字符串）。
Any arguments given to the methods are passed in as block parameters.
任何指定给方法的实参都被传递进block作为形参。

This is an important feature. 
这是一个重要的特性。
Previously it was impossible to pass an instance variable into a block given to one of the `_eval` methods—because self is changed by the call, these variables go out of scope. 
之前不可能传递一个实例变量进指定一个`_eval`方法的block--因为self被调用所改变，这些变量超出了作用域。
With the `_exec` form, you can now pass them in:
用`_exec`形式，你现在可以传递进来：

    @animal = "cat"
    "dog".instance_exec(@animal) do |other|
      puts "#{other} and #{self}"
    end
    # produces:
    # cat and dog

### 24.7.2 `instance_eval` and Constants 【`instance_eval`和常量】
Ruby 1.9 changed the way Ruby looks up constants when executing a block using `instance_eval` and `class_eval`. 
Ruby 1.9 改变了使用`instance_eval`和`class_eval`执行block时寻找常量的方式。
Ruby 1.9.2 then reverted the change. 
Ruby 1.9.2恢复了原状。
In Ruby 1.8 and Ruby 1.9.2, constants are looked up in the lexical scope in which they were referenced. 
在 Ruby 1.8和ruby1.9.2中，常量在一个引用的词汇作用域中寻找。
In Ruby 1.9.0, they are looked up in the scope in which `instance_eval` is called. 
在 Ruby 1.9.0, 常量在调用`instance_eval`的作用域中查找。
This (artificial) example shows the behavior at the time I last built this book—it may well have changed again by the time you run it....
这个（人为）的例子显示了我最后写这本书的时候的行为--当你再次运行时，它可能又被改变了……

    module One
      CONST = "Defined in One"
      def self.eval_block(&block)
        instance_eval(&block)
      end
    end
    module Two
      CONST = "Defined in Two"
      def self.call_eval_block
        One.eval_block do
          CONST
        end
      end
    end
    Two.call_eval_block
    # => "Defined in Two"

In Ruby 1.9.0, this same code would evaluate to "Defined in One".
在 Ruby 1.9.0， 这段代码的结果是“Defined in One”。
<kinder:note> 在ruby 2.0，结果也是“Defined in Two”。

###24.7.3 `instance_eval` and Domain-Specific Languages 【`instance_eval`和特定领域语言】
It turns out that `instance_eval` has a pivotal role to play in a certain type of domain-specific language (DSL). 
这决定了，`instance_eval`在特定类型的领域特定语言中有扮演重要角色。
For example, we might be writing a simple DSL for turtle graphics.[5] 
比如，我们可以为"海龟绘图"写一个简单的DSL。
To draw a set of three 5x5 squares, we might write the following:[6]
要绘制一组三个5x5的方块，我们可以这样写：
5.  
In turtle graphics systems, you imagine you have a turtle you can command to move forward n squares, turn left, and turn right. 
在海龟绘图系统，你假设自己控制一只海龟，你可以命令它向前移动几个方块，左转，右转。
You can also make the turtle raise and lower a pen. 
你也可以让海龟提高或降低笔。
If the pen is lowered, a line will be drawn tracing the turtle’s subsequent movements. 
如果笔被放下，会随着海龟接下来的运动画一条线。
Very few of these turtles exist in the wild, so we tend to simulate them inside computers.
这些龟很少会野外生存，所以我们倾向于在电脑上模拟它们。
6.
Yes, the forward(4) is correct in this code. 
对，在这个代码中forward(4)是正确的。
The initial point is always drawn.
初始点总是先画。

     3.times do
       forward(8)
       pen_down
       4.times do
         forward(4)
         left
       end
       pen_up
     end

Clearly, `pen_down`, forward, left, and `pen_up` can be implemented as Ruby methods. 
很清楚，`pen_down`, forward, left, 和`pen_up`都可以作为ruby方法来实现。
However, to call them without a receiver like this, either we have to be within a class that defines them (or is a child of such a class) or we have to make the methods global. 
不过，要像这样无需接受者来调用它们，或者我们必须在一个类中定义它们（或者是这个类的子类），或者我们必须使用全局方法。
`instance_eval` to the rescue.
`instance_eval`可以援救它。
We can define a class Turtle that defines the various methods we need as instance methods.
我们可以定义一个Turtle类，定义几种我们需要方法作为实例方法。
We’ll also define a walk method, which will execute our turtle DSL, and a draw method to draw the resulting picture:
我们也将定义一个walk方法执行我们的海龟绘图语言，一个draw方法来绘制目标图像。

    classTurtle              
    def  left; ... end
    def  right; ... end
    def  forward(n); ... end
    def  pen_up; .. end
    def  pen_down; ... end
    def  walk(...); end
    def  draw; ... end
    end

If we implement walk correctly, we can then write this:
如果我们正确实现了walk方法，我们就可以这样写：

    turtle = Turtle.new
    turtle.walk do
      3.times do
        forward(8)
        pen_down
        4.times do
          forward(4)
          left
        end
        pen_up
      end
    end
    turtle.draw

So, what is the correct implementation of walk? 
所以，walk该怎么正确实现呢？
Well, we clearly have to use `instance_eval`, because we want the DSL commands in the block to call the methods in the turtle object. 
对，我们必须使用`instance_eval`方法，因为我们要在block的DSL命令调用turtle对象的方法。
We also have to arrange to pass the block given to the walk method to be evaluated by that `instance_eval` call. 
我们也必须安排传递指定给walk方法的block，以便被那个`instance_eval`调用计值。
Our implementation looks like this:
我们的实现看起来像这样：

    def walk(&block)
      instance_eval(&block)
    end

Notice how we captured the block into a variable and then expanded that variable back into a block in the call to `instance_eval`.
注意我们如何捕捉block进入一个变量，然后扩展那个变量回到调用`instance_eval`的block。

See Section 24.11, The Turtle Graphics Program, on page 391 for a complete listing of the turtle program.
参见24.11节，是完整的程序清单。

Is this a good use of `instance_eval`? 
`instance_eval`在这里用得可好？
It depends on the circumstances. 
取决于环境。
The benefit is that the code inside the block looks simple—you don’t have to make the receiver explicit:
好的地方是block内部的代码看起来简单--你无需使用显式的接收者：

     4.times do
       turtle.forward(4)
       turtle.left
     end

There’s a drawback, though. 
不过，存在一个缺点。
Inside the block, scope isn’t what you think it is, so this code wouldn’t work:
在block内部，作用域并不像你想像的那样，所以这个代码无法运行：

    @size = 4
    turtle.walk do
      4.times do
        turtle.forward(@size)
        turtle.left
      end
    end

Instance variables are looked up in self, and self in the block isn’t the same as self in the code that sets the instance variable @size. 
实例变量在self查找，而block里的self并不像代码里的self，可以设置实例变量@size。
Because of this, most people are moving away from this style of `instance_evaled` block.
因为这个，许多人不用`instance_evaled`这种风格的block。

## 24.8 Hook Methods 钩子方法
**钩子和种类**
In Class Methods and Modules, on page 375, we defined a method called included in our General- Logger module. 
在前面375页的24.5.1“类方法和模块”，我们定义个了一个方法，它在我们的GeneralLogger模块中被include调用。
When this module was included in a class, Ruby automatically invoked this included method, allowing our module to add class methods to the host class.
当这个模块在类中被include时，ruby自动调用这个被包含的方法，允许我们的模块增加类方法到主类中。

included is an example of a hook method (sometimes called a callback). 
included是hook方法的一个例子（有时被成为回调）
A hook method is a method that you write but that Ruby calls from within the interpreter when some particular event occurs. 
钩子方法是一种方法，该方法在后面的ruby在某些特定的事件发生时从解释器内部调用。
The interpreter looks for these methods by name—if you define a method in the right context with an appropriate name, Ruby will call it when the corresponding event happens.
解释器根据名字寻找方法--如果你在正确的上下文中用适当的名字定义一个方法，ruby将在对应的事件发生的时候调用它。

The methods that can be invoked from within the interpreter are:
可以从解释器内部调用的方法有：

  - Method-related hooks  和方法相关的钩子

    method_added, method_missing, method_removed, method_undefined, 
    singleton_method_added, singleton_method_removed, singleton_method_undefined

  - Class and module-related hooks  和类和模块相关的钩子

    append_features, const_missing, extend_object, extended, included, inherited, initialize_clone, initialize_copy, initialize_dup

  - Object marshaling hooks  对象编组钩子

    marshal_dump, marshal_load

  - Coercion hooks 强制钩子

    coerce, induced_from, to_xxx

We won’t discuss all of them in this chapter—instead, we’ll show just a few examples of use.
在这一章，我们不讨论所有钩子--相反，我们只展示几个用例。

The reference section of this book describes the individual methods, and Chapter 23, Duck Typing, on page 343 discusses the coercion methods in more detail.
本书的“参考”一章描述各个方法，前面343页23章鸭子类型讨论了强制方法的更多细节。

### 24.8.1 The inherited Hook 【继承钩子】
If a class defines a class method called inherited, Ruby will call it whenever that class is subclassed (that is, whenever any class inherits from the original).
如果一个类定义一个调用继承的类方法，ruby将调用它，无论那个类是否子类（就是，不管那个类何时继承原始类）。
This hook is often used in situations where a base class needs to keep track of its children.
钩子通常用在一个基本类需要保持跟踪其子类的情况。

For example, an online store might offer a variety of shipping options. 
比如，在线商店可能提供多个shipping选项。
Each might be represented by a separate class, and each of these classes could be a subclass of a single Shipping class. 
每个选项都可用一个独立的类来表示，这些类每个都能是Shipping类的子类。
This parent class could keep track of all the various shipping options by recording every class that subclasses it. 
这个父类会通过记录每个子类来持续跟踪所有不同的shipping选项。
When it comes time to display the shipping options to the user, the application could call the base class, asking it for a list of its children:
当到了显示shipping选项给用户时，应用程序可调用基本类，向它请求一个子类的清单：

    class Shipping    # 运送类
      @children = []
      # Base class 基类
      # this variable is in the class, not instances 这个变量在类里，不是在实例里面。
      def self.inherited(child)   # 继承钩子方法
        @children << child        # 将所有子类传给@chilren参数
      end
      def self.shipping_options(weight, international)   # 运送选项（重量，是否国际）
        @children.select {|child| child.can_ship(weight, international)}   # 遍历子类，运行can_ship方法进行选择。
      end
    end
    class MediaMail < Shipping   # -媒体邮件类
      def self.can_ship(weight, international)
        !international
      end
    end
    class FlatRatePriorityEnvelope < Shipping  # -统一费率优先信封
      def self.can_ship(weight, international)
        weight < 64 && !international
      end
    end
    class InternationalFlatRateBox < Shipping  # -国际统一费率包裹
      def self.can_ship(weight, international)
        weight < 9*16 && international
      end
    end
    puts "Shipping 16oz domestic"                  # => Shipping 16oz domestic
    puts Shipping.shipping_options(16, false)      # => MediaMail
                                                   # => FlatRatePriorityEnvelope
    puts "\nShipping 90oz domestic"                # => Shipping 90oz domestic
    puts Shipping.shipping_options(90, false)      # => MediaMail
    puts "\nShipping 16oz international"           # => Shipping 16oz international
    puts Shipping.shipping_options(16, true)       # => InternationalFlatRateBox

Command interpreters often use this pattern: the base class keeps a track of available commands, each of which is implemented in a subclass.
命令解释器经常使用这个模式：基类保持不同命令的跟踪，每个命令在子类中实现。

### 24.8.2  The `method_missing` Hook 【方法不见钩子】
Earlier, we saw how Ruby executes a method call by looking for the method, first in the object’s class, then in its superclass, then in that class’s superclass, and so on. 
早前，我们看到ruby如何通过寻找方法来执行方法调用，首先在对象的类中，然后在它的超类中，然后在那个类的超类，以此类推。
If the method call has an explicit receiver, then private methods are skipped in this search. 
如果方法调用有显式的接收者，搜索中会跳过私有方法。
If the method is not found by the time we run out of superclasses (because BasicObject has no superclass), then Ruby tries to invoke the hook method `method_missing` on the original object. 
如果方法在最后的超类（BasicObject没有超类）中都没有找到，ruby尝试在原始对象上调用钩子方法`method_missing`。
Again, the same process is followed—Ruby first looks in the object’s class, then in its superclass, and so on. 
同样的过程再次出现--ruby首先在对象的类中寻找，然后在它的超类，以此类推。
However, Ruby predefines its own version of `method_missing` in class BasicObject, so typically the search stops there. 
不过，ruby在BasicObject类中预先定义了`method_missing`的自己的版本，因此搜索在此结束。
The built-in `method_missing` basically raises an exception (either a NoMethodError or a NameError depending on the circumstances).
内建的`method_missing`基本上抛出一个例外（依据环境可能是NoMethodError或者NameError）。

The key here is that `method_missing` is simply a Ruby method. 
这里的关键是`method_missing`只是一个ruby方法。
We can override it in our own classes to handle calls to otherwise undefined methods in an application-specific way.
我们可以在我们的类中改写它，以便用应用程序特定的方法来处理其他未定义方法的调用。

`method_missing` has a simple signature, but many people get it wrong:
`method_missing`有一个简单的信号（或签字、署名），但很多人弄错了：

    def method_missing(name, *args, &block) # ...

The name argument receives the name of the method that couldn’t be found. 
name参数接收不能找到的方法的名字
It is passed as a symbol. 
作为符号传递。
The args argument is an array of the arguments that were passed in the original call. 
args参数是一个序列，在原始调用中传入。
And the oft-forgotten block argument will receive any block passed to the original method.
健忘的block参数将接收任何传递给原始方法的block。

    def method_missing(name, *args, &block)
      puts "Called #{name} with #{args.inspect} and #{block}"
    end
    wibble
    wobble 1, 2
    wurble(3, 4) { stuff }
    # produces:
    # Called wibble with [] and
    # Called wobble with [1, 2] and
    # Called wurble with [3, 4] and #<Proc:0x007fd7d910fb18@prog.rb:7>

Before we get too deep into the details, I’ll offer a tip about etiquette. 
在我们查看更详细的细节之前，我提供一个关于礼节的提醒。
There are two main ways that people use `method_missing`. 
人们使用`method_missing`有两种主要方式。
The first intercepts every use of an undefined method and handles it. 
第一种截取任何未定义方法的使用，并处理。
The second is more subtle; it intercepts all calls but handles only some of them. 
第二种更巧妙，它截取所有调用，但只处理其中一些。
In the latter case, it is important to forward on the call to a superclass if you decide not to handle it in your `method_missing` implementation:
后一种情况，如果你决定不在你的`method_missing`实现处理它，转发调用一个超类是很重要的：

    class MyClass < OtherClass
      def method_missing(name, *args, &block)
        if <some condition>
          # handle call
        else
          super
          # otherwise pass it on
        end
      end
    end

If you fail to pass on calls that you don’t handle, your application will silently ignore calls to unknown methods in your class.
如果你没有传递你不想处理的调用，你的应用程序将会忽略你类中未知方法的调用。

Let’s show a couple of uses of `method_missing`.
让我们展示一对`method_missing`的使用

### 24.8.3 `method_missing` to Simulate Accessors 【用`method_missing`模拟访问者】
The OpenStruct class is distributed with Ruby. 
OpenStruct类随ruby而发布。
It allows you to write objects with attributes that are created dynamically by assignment. 
它允许你写出带有通过赋值动态创建属性的对象。
(We describe it in more detail in the library documentation on page 786.) 
后面786页的库文档中有更详细的描写。
For example, you could write this:
比如，你可以这样写：

    require 'ostruct'
    obj = OpenStruct.new(name: "Dave")
    obj.address = "Texas"
    obj.likes = "Programming"
    puts "#{obj.name} lives in #{obj.address} and likes #{obj.likes}"
    # produces:
    # Dave lives in Texas and likes Programming

Let’s use `method_missing` to write our own version of OpenStruct:
让我们使用`method_missing`创建我们自己版本的OpenStruct：

    class MyOpenStruct < BasicObject
      def initialize(initial_values = {})
        @values = initial_values
      end
      def _singleton_class
        class << self
          self
        end
      end
      def method_missing(name, *args, &block)
        if name[-1] == "="
          base_name = name[0..-2].intern  # intern是什么方法？拘留？
          _singleton_class.instance_exec(name) do |name|
            define_method(name) do |value|
              @values[base_name] = value
            end
          end
          @values[base_name] = args[0]
        else
          _singleton_class.instance_exec(name) do |name|
            define_method(name) do
              @values[name]
            end
          end
          @values[name]
        end
      end
    end
    obj = MyOpenStruct.new(name: "Dave")
    obj.address = "Texas"
    obj.likes = "Programming"
    puts "#{obj.name} lives in #{obj.address} and likes #{obj.likes}"
    # produces:
    # Dave lives in Texas and likes Programming

Notice how we base our class on BasicObject, a class introduced in Ruby 1.9. 
注意我们怎么将我们的类基于BasicObject，这是在ruby1.9中引入的。
BasicObject is the root of Ruby’s object hierarchy and contains only a minimal number of methods:
BasicObject是ruby的对象层级的根部，只包含很少的方法：

    p BasicObject.instance_methods
    # produces:
    # [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]

This is good, because it means that our MyOpenStruct class will be able to have attributes such as display or class. 
这很好，因为这意味着我们的MyOpenStruct类将能够像类或者我们展示的行为属性。
If instead we’d based MyOpenStruct on class Object, then these names, along with forty-nine others, would have been predefined and hence wouldn’t trigger `method_missing`.
如果我们将MyOpenStruct筑于Object类之上，那么这些名字，还有49个其他的，将被预定义好，因此不会引发`method_missing`。

Notice also another common pattern inside `method_missing`. 
也要注意`method_missing`内部的其他普通模式。
The first time we reference or assign to an attribute of our object, we access or update the @values hash appropriately. 
我们第一次引用或赋值到我们对象的属性时，我们适当地访问或更新@value的散列表。
But we also define the method that the caller was trying to access. 
但我们也定义了调用者尝试访问的方法。
This means that the next time this attribute is used, it will use the method and not invoke `method_missing`. 
这意味着下次使用这个属性时，它会使用这个方法，不再调用`method_missing`。
This may or may not be worth the trouble, depending on the access patterns to your object.
这可能或不可能不会出错，依赖于你的对象的访问模式。

Also notice how we had to jump through some hoops to define the method. 
也要注意我们怎么必须跳过定义方法的圈套。
We want to define the method only for the current object. 
我们只为当前对象定义方法。
This means we have to put the method into the object’s singleton class. 
这意味着我们必须将方法放入对象的单例类。
We can do that using `instance_exec` and `define_method`. 
我们可以用`instance_exec`和`define_method`来做。
But that means we have to use the `class << self` trick to get the object’s singleton class. 
但那意味着我们必须使用`class << self`的技巧来获得对象的单例类。
Through an interesting implementation subtlety, `define_method` will always define an instance method, independent of whether it is invoked via `instance_exec` or `class_exec`.
通过这个有趣的实现的妙处，`define_method`将总是定义一个实例方法，与是否通过`instance_exec`或`class_exec`调用无关。

However, this code reveals a dark underbelly of using `method_missing` and BasicObject:
不过，这个代码暴露了使用`method_missing`和BasicObject时的一个漏洞：

    obj = MyOpenStruct.new(name: "Dave")
    obj.address = "Texas"
    o1 = obj.dup
    o1.name = "Mike"
    o1.address = "Colorado"
    # produces:
    # prog.rb:37:in `<main>': undefined method `name=' for nil:NilClass
    # (NoMethodError)

The dup method is not defined by BasicObject; it appears in class Object. 
BasicObject类没有定义dup方法，dup方法出现在Object类中。
So when we called dup, it was picked up by our `method_missing` handler, and we just returned nil (because we don’t have yet have an attribute called dup). 
所以当我们调用dup，它会被`method_missing`处理，只返回nil（因为我们还没有调用dup的属性）。
We could fix this so that it at least reports an error:
我们能修复它，让它至少报告一个错误：

    def method_missing(name, *args, &block)
      if name[-1] == "="
        # as before...
      else
        super unless @values.has_key? name
        # as before...
      end
    end

This class now reports an error if we call dup (or any other method) on it. 
如果我们调用dup，这个类会报告一个错误。
However, we still can’t dup or clone it (or inspect, convert to a string, and so on). 
不过，我们还是不能dup或者clone它（或inspect, 字符串转换，等等）。
Although BasicObject seems like a natural fit for `method_missing`, you may find it to be more trouble than it’s worth.
虽然BasicObject看起来像是`method_missing`的温床，你可能会发现它其实更麻烦和不值得。

### 24.8.4 `method_missing` as a Filter 【`method_missing`作为过滤器】
As the previous example showed, `method_missing` has some drawbacks if you use it to intercept all calls. 
正如前例所示，如果你用它来截获所有的调用，`method_missing`有一些缺陷。
It is probably better to use it to recognize certain patterns of call, passing on those it doesn’t recognize to its parent class to handle.
用它来识别特定模式的调用，将它不能识别的传递给父类处理。

An example of this is the dynamic finder facility in the Ruby on Rails ActiveRecord module.
其中一个例子是ruby on rails的ActiveRecord模块的动态发现工具。
ActiveRecord is the object-relational library in Rails—it allows you to access relational databases as if they were object stores. 
ActiveRecord是Rails的对象-关系库--它允许你像对象商店那样访问关系性数据库。
One particular feature allows you to find rows that match the criteria of having given values in certain columns. 
一个特性是允许你在特定的列中找到匹配特定值的行。
For example, if an Active Record class called Book were mapping a relational table called books and the books table included columns called title and author, you could write this:
比如，如果一个叫Book的ActiveRecord类被映射到一个叫books的关系表中，books表包含的列有标题、作者，你可以这样写：

    pickaxe = Book.find_by_title("Programming Ruby")
    daves_books = Book.find_all_by_author("Dave Thomas")

Active Record does not predefine all these potential finder methods. 
Active Record没有预定义所有这些潜在的finder方法。
Instead, it uses our old friend `method_missing`.
真相是，它使用了我们的老朋友`method_missing`。
Inside that method, it looks for calls to undefined methods that match the pattern `/^find_(all_)?by_(.*)/`.[7] 
在该方法里，它寻找调用匹配了模式`/^find_(all_)?by_(.*)/`的未定义方法。
[7].It also looks for `/^find_or_(initialize|create)_by_(.*)/`.
它也寻找`/^find_or_(initialize|create)_by_(.*)/`模式。
If the method being invoked does not match this pattern or if the fields in the method name don’t correspond to columns in the database table, Active Record calls super so that a genuine `method_missing` report will be generated.
如果正被调用的方法不匹配这个模式，或者如果方法名里的字段不对应数据表的列，ActiveRecord调用super以便产生真正的`method_missing`

## 24.9 One Last Example 一个最近的例子
Let’s bring together all the metaprogramming topics we’ve discussed in a final example by writing a module that allows us to trace the execution of methods in any class that mixes the module in. 
让我们将讨论过的元编程主题放入最后一个例子：写一个模块，允许我们跟踪混入模块的类的方法的执行。
This would let us write the following:
让我们这么写：

    require_relative 'trace_calls'
    class Example
      def one(arg)
        puts "One called with #{arg}"
      end
    end
    ex1 = Example.new
    ex1.one("Hello") # no tracing from this call

    class Example
      include TraceCalls     # 这个简单的include实在太复杂了！！！所有单例方法在此新建。真是优雅得够呛。
      def two(arg1, arg2)
        arg1 + arg2
      end
    end
    ex1.one("Goodbye") # but we see tracing from these two
    puts ex1.two(4, 5)

    # produces:
    # One  called with Hello
    # ==>  calling one with ["Goodbye"]
    # One  called with Goodbye
    # <==  one returned nil      one方法返回nil。为什么？
    # ==>  calling two with [4, 5]
    # <==  two returned 9
    # 9

We can see immediately that there’s a subtlety here. 
我们可以马上看到这里有些微妙。
When we mix the TraceCalls module into a class, it has to add tracing to any existing instance methods in that class. 
当我们将TraceCalls模块混入类中，它必须增加该类任何已存实例变量的跟踪。
It also has to arrange to add tracing to any methods we subsequently add.
它也必须安排增加对我们随后加入的方法的跟踪。

Let’s start with the full listing of the TraceCalls module:
让我们从TraceCalls模块的全文开始：

    # metaprogramming/trace_calls.rb
    module TraceCalls
      def self.included(klass)                      # + included钩子
        klass.instance_methods(false).each do |existing_method|
          wrap(klass, existing_method)
        end
        def klass.method_added(method) # note: nested definition ++注意:嵌套的定义 ，增加方法钩子
          unless @trace_calls_internal    # unless语句会执行一次
            @trace_calls_internal = true
            TraceCalls.wrap(self, method)
            @trace_calls_internal = false  # 避免下面wrap新建循环
          end
        end
      end
      def self.wrap(klass, method)               # + wrap钩子
        klass.instance_eval do                   # self替换，重新定义单例类方法，执行时本法优先？
          method_object = instance_method(method)
          define_method(method) do |*args, &block|   # 新建一个方法。
            puts "==> calling #{method} with #{args.inspect}"
            result = method_object.bind(self).call(*args, &block)  # bind(self)调用原有方法
            puts "<== #{method} returned #{result.inspect}"
            result
          end
        end
      end
    end

When we include this module in a class, the included hook method gets invoked. 
当我们将这个模块包含进入类中，included钩子方法就会被调用。
It first uses the `instance_methods` reflection method to find all the existing instance methods in the host class (the false parameter limits the list to methods in the class itself, and not in its superclasses). 
它首先使用`instance_methods`反射方法找出主类中所有已存的实例方法（false参数将方法限制在类自身，而不是超类）
For each existing method, the module calls a helper method, wrap, to add some tracing code to it. 
对于每个已存的方法，模块调用一个辅助方法wrap，将跟踪代码添加到里面。
We’ll talk about wrap shortly.
我们将会简短的谈论一下wrap。

Next, the included method uses another hook, `method_added`. 
接着，included方法使用另一个钩子`method_added`。
This is called by Ruby whenever a method is defined in the receiver. 
无论方法何时在接收者定义，ruby都会调用这个方法。
Note that we define this method in the class passed to the included method. 
注意，我们在类中定义这个方法，传给included方法。
This means that the method will be called when methods are added to this host class and not to the module. 
这意味着当方法添加到这个主类中，而不是在模块中时，方法将被调用。
This is what allows us to include TraceCalls at the top of a class and then add methods to that class—all those method definitions will be handled by `method_added`.
就是这个，允许我们在类的顶部包含TraceCalls，然后增加方法到该类中--所有那些方法定义将被`method_added`所处理。

Now look at the code inside the `method_added` method. 
现在看看`method_added`里面的代码。
We have to deal with a potential problem here. 
这里我们必须面对一个潜在的问题。
As you’ll see when we look at the wrap method, we add tracing to a method by creating a new version of the method that calls the old. 
正如你将看到的，当我们看wrap方法时，我们通过调用老方法创建一个新版本的方法，增加了跟踪到方法中。
Inside `method_added`, we call the wrap function to add this tracing. 
在`method_added`内部，我们调用wrap函数类增加跟踪。
But inside wrap, we’ll define a new method to handle this wrapping, and that definition will invoke `method_added` again, and then we’d call wrap again, and so on, until the stack gets exhausted. 
但在wrap内部，我们定义一个新的方法来处理这个包装，那个定义将会再次调用`method_added`，然后又调用wrap，循环往复，直到堆栈消耗殆尽。
To prevent this, we use an instance variable and do the wrapping only if we’re not already doing it.
为了预防这点，我们使用一个实例变量，只有在我们还没有包装的时候才进行wrap包装。

The wrap method takes a class object and the name of a method to wrap. 
wrap方法对一个类对象和方法名进行包装。
It finds the original definition of that method (using `instance_method`) and saves it. 
它使用`instance_method`找到方法的原始定义，并保存好。
It then redefines this method. 
然后重新定义这个方法。
This new method outputs some tracing and then calls the original, passing in the parameters and block from the wrapper.  [8]
这个新的方法输出一些跟踪，然后调用原始的方法，从wrapper包装器传入参数和block。
[8]. The ability of a block to take a block parameter was added in Ruby 1.9.
一个block得到一个block的参数的能力在ruby1.9中被加入。

Note how we call the method by binding the method object to the current instance and then invoking that bound method.
注意我们怎么调用方法：通过将方法对象绑定到当前实例中，然后调用该绑定方法。

The key to understanding this code, and most metaprogramming code, is to follow the basic principles we worked out at the start of this chapter—how self changes as methods are called and classes are defined and how methods are called by looking for them in the class of the receiver. 
理解这段代码、最富有元编程气息的代码的关键，在于跟着我们在本章开头所指出的基本原则--方法调用和类定义时self是怎么变化的，通过在接收者的类中寻找，方法是怎么被调用的。
If you get stuck, do what we do and draw little boxes and arrows. 
如果你模糊了，就像我们做的那样画画箱子和箭头吧。
We find it useful to stick with the convention used in this chapter: class links go to the right, and superclass links go up. 
类连接到右边，而超类连接到上面，我们发现跟随这一章所用的惯例是很有用的。
Given an object, a method call is then a question of finding the receiver object, going right once, and then following the superclass chain up as far as you need to go.
给定一个类，方法调用就要找到接收者对象，因此向右画，然后跟着超类链向上直到你找到你所需要。

## 24.10 Top-level Execution Environment  顶层执行环境
<kinder:note> 这一节的内容大体和2版24.3“顶层执行环境”一样。只是在结尾增加：
Metaprogramming is one of Ruby’s sharpest tools. 
元编程是ruby最锋利的工具之一。
Don’t be afraid to use it to raise up the level at which you program. 
别怕使用它，这回提高你的编程水平。
But, at the same time, use it only when necessary—overly metaprogrammed applications can become pretty obscure pretty quickly.
但同时，只在必要的时候使用--过量的元编程程序会很快变得十分晦涩。

## 24.11 The Turtle Graphics Program 一个海龟图形程序

    class Turtle
      # directions: 0 = E, 1 = S, 2 = W, 3 = N
      # axis: 0 = x, 1 = y
      def initialize
        @board = Hash.new(" ")
        @x = @y = 0
        @direction = 0
        pen_up
      end
      def pen_up
        @pen_down = false
      end
      def pen_down
        @pen_down = true
        mark_current_location
      end
      def forward(n=1)
        n.times { move }
      end
      def left
        @direction -= 1
        @direction = 3 if @direction < 0
      end
      def right
        @direction += 1
        @direction = 0 if @direction > 3
      end
      def walk(&block)
        instance_eval(&block)
      end
      def draw
        min_x, max_x = @board.keys.map{|x,y| x}.minmax
        min_y, max_y = @board.keys.map{|x,y| y}.minmax
        min_y.upto(max_y) do |y|
          min_x.upto(max_x) do |x|
            print @board[[x,y]]
          end
          puts
        end
      end
      private
      def move
        increment = @direction > 1 ? -1 : 1
        if @direction.even?
          @x += increment
        else
          @y += increment
        end
        mark_current_location
      end
      def mark_current_location
        @board[[@x,@y]] = "#" if @pen_down
      end
    end
    turtle = Turtle.new
    turtle.walk do
      3.times do
        forward(8)
        pen_down
        4.times do
          forward(4)
          left
        end
        pen_up
      end
    end
    turtle.draw
    # produces:
    # ##### ##### ##### 
    # #   # #   # #   #
    # #   # #   # #   #
    # #   # #   # #   #
    # ##### ##### #####

# 　第25章　Ruby安全  <kinder:note> 4版为26章
**外部数据和tainted**
Walter的cgi脚本：

    require 'cgi'
    cgi = CGI.new("html4")
    # Fetch the value of the form field "expression"
    # 取出表单字段"expression"的值
    expr = cgi["expression"].to_s
    begin
      result = eval(expr)
    rescue Exception => detail
      # handle bad expressions
      # 处理坏的表达式
    end
    # display result back to user...
    # 将结果返回给用户

可是一个小孩在表单上输入了`system("rm")`，于是Walter的系统报废了！

所有的外部数据都是有危险的。
不要让它们靠近那些可能改动你的系统的接口。

ruby为减少这种风险提供了支持。所有来自外部的数据口可以标记为受污染（tainted,或不受信的）。
当运行在安全模式下时，传递被污染的对象给一个具有潜在威胁的方法会引发SecurityError。

## 　　25.1　安全级别
变量$SAFE决定了ruby的安全级别。
下表25.1列出了每种安全级别下所执行的检查的详细列表

$SAFE    限制
0        对外部提供（受污染）的数据不做检查。默认
>= 1     不允许在具有潜在威胁的操作中使用受污染的数据
             不处理环境变量RUBYLIB RUBYOPT，且不添加当前路径到路径列表。
             不允许eiIrsSx命令行选项
             如果$PATH中的任何目录是任何人可写的，则不能从$PATH中运行程序。
             不能处理或chroot到一个名字为被污染的字符串的目录。
             不能glob受污染的字符串。
             不能eval受污染的字符串。
             不能load或require名字是被污染的字符串的文件（除非load被封装了）<kinder:note> how？
             不能处理或查询名字是受污染的字符串的文件或管道。
             不能执行系统命令或exec来自外部字符串的程序
             不能传递受污染的字符串给trap。
>= 2     禁止从外部可写的位置装载程序文件
             不能改变、创建或删除目录，不能使用chroot
             不能从任何人可写的目录中装载文件
             不能装载名字是以～开头的受污染的字符串的文件
             不能使用File#chmod chown lstat .stat truncate .umask flock 
                     OI# ioctl stat 
                     Kernel(4版是Object)#syscall trap
                     Process.setgid .setsid .setpriority .egid=
             不能用trap处理信号
>= 3     所有新建对象都被认为是受污染的
             所有对象在创建时就被污染
             不能untraint对象
             Can't add trust to an object -- 不能给一个对象增加trust
             Objecs are created untrusted -- 新建对象为untrusted
>= 4     有效地将程序分为两部分；未污染的对象不能被修改
             不能修改未污染的数组、hash或字符串
             不能修改全局变量
             不能访问未污染对象的实例变量
             不能改变环境变量
             不能关闭或重新打开未污染的文件
             不能feeeze未污染的对象
             不能改变方法的可见性(private/public/protected)
             在未污染的类或模块内不能创建别名
             不能获得元信息（例如方法或变量列表）
             不能在未污染的类或模块内定义、重定义、删除或取消定义方法
             不能修改Object
             不能从未污染的对象中删除实例变量或常量
             除了当前线程不能处理线程、终止线程，或者设置abort_on_exception
             不能有线程内的局部变量
             不能在具有较低$SAFE值的线程内引发异常
             不能在ThreadGroups间移动线程
             不能调用exit exit! abort
             只能装载被封装的文件，且在未污染的类或模块中不能include模块
             不能把符号标志转换成对象引用
             不能向文件或管道中写东西
             不能使用autoload
             不能tainte对象
             Can't untrust an object -- 不能untrust对象

在大多数情况下，$SAFE的默认值是0。
然而，如果ruby运行setuid或setid的脚本，或者在`mod_ruby`下执行，安全级别自动变为1。
安全级别还可以通过-T命令行选项设置，也可以通过在程序中对$SAFE重新赋值来设置。但是通过$SAFE赋值不能降低其值的大小。

创建新线程时，$SAFE的当前值将被继承下来。
然而，在每个线程中，可以修改$SAFE的值而不影响其他线程中该变量的值。
使用这个特性可以实现安全“沙箱”，在其中可以安全地运行外部代码而不影响应用程序或系统的其他部分。
通过把从外部文件中装载的代码封装在一个它自己的匿名模块中可以实现这点。
这可以保护你的程序的名字空间不受意外的改动。

    f = Open(filename, "w")
    f.print ... # 将不受信程序写入文件
    f.close
    Thread.start do
      $SAFE = 4
      load(filename, true)
    end

因为$SAFE等于4,你只能装载被封装的文件。详见后面524页关于Kernel.load的描述。

这个概念被Clemens Wyss用来实现Channel（http:///www.ruby.ch）。
从`http://www.approximity.com/cgibin/rubybuch_wiki/wpage.rb?nd=24`中可以看到沙箱的源代码列表。

当创建Proc对象时，实际的安全级别被存储在该对象中。
如果Proc被污染了，且当前的安全级别大于创建block时的实际级别，则Proc不能作为参数传递给方法。

## 　　25.2　受污染的对象
任何从外部资源（例如从文件中读取的字符串或环境变量）派生的ruby对象都被自动标记为被污染。
如下面代码所示，如果程序从受污染的对象中派生了一个新的对象，那么这个新对象也将被污染。以前在某个位置获得外部数据的对象也将被污染。
不管当前的安全级别是什么，污染判断过程总会被执行。

使用Object.tainted?方法可以看到一个对象是否已被污染。

    # internal data                 # external data
    # =============                 # =============
    x1 = "a string"                 y1 = ENV["HOME"]
    x1.tainted?     → false         y1.tainted?      → true
    x2 = x1[2, 4]                   y2 = y1[2, 4]
    x2.tainted?     → false         y2.tainted?      → true
    x1 =~ /([a-z])/  → 0            y1 =~ /([a-z])/  → 2
    $1.tainted?      → false        $1.tainted?      → true

taint方法可以把任意对象强制转换成受污染的对象。
如果安全级别低于3,untaint方法可以把对象的受污染标记去除。但轻易不能做这种操作。
即使不用untaint方法也可以用其他技巧来做到这一点，我们将留给你自己去发现如何做。

对于Walter来说，他应该在1安全级别运行他的CGI脚本。当程序试图传递表单数据给eval方法时将引发一个异常。
一旦发现，他可以实现合适的表达式解析器，避免使用eval的潜在威胁。
但由于人的惰性，更可能的是对表单数据执行一些简单的检查，如果无害，就去掉污染标记：

    require 'cgi'
    $SAFE = 1
    cgi = CGI.new("html4")
    expr = cgi["expression"].to_s
    if expr =~ %r{\A[-+*/\d\seE.()]*\z}
      expr.untaint
      result = eval(expr)   # display result back to user...
    else
      # display error message
    end

从个人角度来说，我们认为Walter仍有些冒险。我们可能更希望看到一个真正的解析器。
## 26.3 Trusted Object
Ruby 1.9 adds trust, a new dimension to the concept of safety. 
Ruby 1.9增加了一个安全概念的新尺度--trust。
All objects are marked as being trusted or untrusted. 
所有的对象都可被标记不信任和不信人。
In addition, running code can be trusted or not. 
另外，运行的代码可被信任或不信人。
And, when you’re running untrusted code, objects that you create are untrusted, and the only objects that you can modify are those that are marked untrusted. 
当你运行不信任的代码时，新建的对象是不受信任的，你只能修改那些被标记为不信任的对象。
What this in effect means is that you can create a sandbox to execute untrusted code, and code in that sandbox cannot affect objects outside that sandbox.
这实际上意味着你可以创建一个沙箱来执行不受信任的代码，沙箱内的代码不能影响沙箱外的对象。

Let’s get more specific. 
让我们更详细些。
Objects created while Ruby’s safe level is less than 3 are trusted.
ruby的安全级别小于3时，所创建的对象是受信任的。
However, objects created while the safe level is 3 or 4 will be untrusted. 
不过，安全级别在3和4时，所创建的将是不受信任的。
Code running at safe levels 3 and 4 is also considered to be untrusted. 
安全级别在3和4时运行的代码也被认为是不受信任的。
Because untrusted code can modify only untrusted objects, code at safe levels 3 and 4 will not be able to modify objects created at a lower safe level.
因为不受信任代码只能修改不受信任对象，安全级别在3和4时的代码不能修改更低安全级别创建的对象。

    dog = "dog is trusted"
    cat = lambda { $SAFE = 3; "cat is untrusted" }.call
    puts "dog.untrusted? = #{dog.untrusted?}"
    puts "cat.untrusted? = #{cat.untrusted?}"
    # running at safe level 1, these operations will succeed
    # 在第一级安全运行，下面这些操作是成功的。
    puts dog.upcase!
    puts cat.upcase!
    # running at safe level 4, we can modify the cat
    # 在第四级安全运行，我们可以修改cat。
    lambda { $SAFE = 4; cat.downcase! }.call
    puts "cat is now '#{cat}'"
    # but we can't modify the dog
    # 但不能修改dog
    lambda { $SAFE = 4; dog.downcase! }.call
    puts "so we never get here"
    # produces:
    # from prog.rb:16:in `block in <main>'
    # from prog.rb:16:in `call'
    # from prog.rb:16:in `<main>'
    # dog.untrusted? = false
    # cat.untrusted? = true
    # DOG IS TRUSTED
    # CAT IS UNTRUSTED
    # cat is now 'cat is untrusted'
    # prog.rb:16:in `downcase!': Insecure: can't modify string (SecurityError)

You can set and unset the trusted status of an object using Object#untrust and Object#trust (but you have to be at below safe level 4 to call untrust and below safe level 3 to call trust). 
你可以使用Object#untrust和Object#trust来设置或撤销对象的信任状态（但你只能在低于4安全级别的使用调用untrust，在低于安全级别3的时候调用trust）。
The method Object#untrusted? returns true if an object is untrusted.
如果该对象是不受信任的Object#untrusted?方法会返回true。

# 　第26章　反射,ObjectSpace和分布式Ruby <kinder:note> 4版为25章
**反射概述**
能够内省--在程序内部自己检验程序的方方面面--是ruby等动态语言的诸多优点之一。
Java把这个特性成为反射（reflection）

对程序内省我们会发现：

  - 包括哪些对象
  - 类的层次结构
  - 对象的属性和方法
  - 有关方法的信息

有了这些信息后，可以查看特定的对象并决定在运行时调用它们的哪个方法--即使当开始编写代码时这些对象的类不存在。
我们也可以开始做些更聪明的事情，比如当程序正在运行的时候修改它。

反射的本领让我们可以做一些非常有用的事情。
比如后面的分布式ruby和列集(marshaling)，这两个基于反射的技术可以让我们穿越时空发送对象。

## 　　26.1　看看对象
**遍历对象**
使用`ObjectSpace.each_object`遍历对象：
<kinder:note> 2版的例子和解说：

    a = 102.7
    b = 95.1
    ObjectSpace.each_object(Number) {|x| p x }
    # 输出结果：
    # 95.1
    # 102.7
    # 2.71828182845905
    # 3.14159265358979
    # 2.22044604925031e-16
    # 1.79769313486232e+308
    # 2.2250738585072e-308

这段代码在Numeric类型的所有对象上迭代。
看看后面487页540页，Float类为最大和最小浮点数定义了常量与epsilon（区分两个浮点数的最小差距）
Math模块为e和pi定义了常量。

没有出现我们创建的那些Fixnum对象。这是因为ObjectSpace并不知晓这些具有立即值的对象：Fixnum Symbol true false nil。

<kinder:note> 4版的例子和解说：

    a = Complex(1, 2)
    b = Complex(99, -100)
    ObjectSpace.each_object(Complex) {|x| puts x }
    # produces:
    # 0+1i
    # 99-100i
    # 1+2i

Where did that extra number, (0+1i), come from? 
那些额外的数字，(0+1i)是从哪儿来的？
We didn’t define it in our program. 
程序里我们并没有定义。
Well, the Complex class defines a constant for I, the square root of -1. 
对了，Comlex类定义了一个常数I，-1的平方根。
Since we are examining all living objects in the system, these turn up as well.
因为我们正在测试所有系统的活动对象，这些就也出现了。

Let’s try the same example with different values. 
让我们用同样的例子但不同的值来尝试：
This time, they’re objects of type Fixnum:
这回是Fixnum类型的对象：

    a = 102
    b = 95
    ObjectSpace.each_object(Fixnum) {|x| p x }
    # (Produces no output.)

⇡New in 2.0⇣
Neither of the Fixnum objects we created showed up. 
我们创建的对象一个都没有显示出来。
That’s because ObjectSpace doesn’t know about objects with immediate values: Fixnum, Symbol, true, false, nil, and (on 64-bit platforms) most Floats.
这是因为ObjectSpace不知道这些具有立即值的对象：Fixnum，Symbol，true，false，nil，和（在64位平台上的）大部分的Float。

### 26.1.1 窥入对象
一旦发现感兴趣的对象，你可能会倾向于找出它能够做什么。
静态语言中变量类型决定了类和支持的方法。
ruby支持自由对象，只有看看它下面到底有什么，才能知道对象的确切能力。
前面鸭子类型一章进行了讨论。 

例如，可以得到对象所能响应的所有方法的一个列表

    r = 1..10 # Create a Range object
    list = r.methods
    list.length → 68 <kinder:note> 68种方法;4版则是111.
    list[0..3] → ["collect", "to_a", "instance_eval", "all?"] 这是前四种方法
                 # 4版的结果则是[:==, :===, :eql?, :hash]


或者，可以看看对象是否支持某个具体的方法

    r.respond_to?("frozen?")  → true
    r.respond_to?(:has_key?)  → false
    "me".respond_to?("==")    → true

确定对象的类以及它的唯一对象ID，并测试它与其他类的关系

    num = 1
    num.id                      → 3
    num.class                   → Fixnum
    num.kind_of? Fixnum         → true
    num.kind_of? Numeric        → true
    num.instance_of? Fixnum     → true
    num.instance_of? Numeric    → false  为什么不是其中一个实例？必须直接隶属？

## 　　26.2　考察类
为了得到全貌，你需要能查看类--它们所包含的方法和常量。
考察类的层次结构很容易。可以使用Class#superclass得到任何类的父类。
对类和模块来说Module#ancestors会同时列出超类和混入的模块。

    klass = Fixnum
    begin
      print klass
      klass = klass.superclass
      print " < " if klass
    end while klass
    puts
    p Fixnum.ancestors
    # produces:
    # Fixnum < Integer < Numeric < Object
    # [Fixnum, Integer, Precision, Numeric, Comparable, Object, Kernel]

如果想构建一个完整的类层次结构，只对系统中的每个类运行那段代码就可以了。
可以使用ObjectSpace来迭代所有Class对象：

    ObjectSpace.each_object(Class) do |klass|
      # ...
    end

### 26.2.1 窥入类
可以在一个特别对象中找出关于其方法和常量的更多信息。
它不是检查对象是否响应了一个给定的消息，可以通过访问级别来查找方法，可以只查找单例方法，也可以查看对象的常量、局部变量和实例变量。

    class Demo
      @@var = 99    # 类变量
      CONST = 1.23  # 常量
      private
      def private_method   # 私有方法
      end
      protected
      def protected_method   # 保护方法
      end
      public
      def public_method  # 公共方法
        @inst = 1
        i = 1
        j = 2
        local_variables
      end
      def Demo.class_method   # 单例类方法
      end
    end
    Demo.private_instance_methods(false)        → ["private_method"]
    Demo.protected_instance_methods(false)      → ["protected_method"]
    Demo.public_instance_methods(false)         → ["public_method"]
    Demo.singleton_methods(false)               → ["class_method"]
    Demo.class_variables                        → ["@@var"]
    Demo.constants - Demo.superclass.constants  → ["CONST"]
    demo = Demo.new
    demo.instance_variables → []
    # Get 'public_method' to return its local variables
    # and set an instance variable
    demo.public_method → ["i", "j"]
    demo.instance_variables → ["@inst"]

Module.constants返回模块中所有可用的常量，包括在模块超类中的常量。

在ruby1.8中，默认情况下这些反射方法会递归进入父类，同样父类会沿着祖先链递归进入它们的父类中。传递false参数会阻止这种刨根问底。

## 　　26.3　动态地调用方法
给定一个方法名的列表，可能会诱惑我们尝试调用它们。
幸运的是，ruby中这是很容易的。

**command**
C和Java程序员经常发现他们自己编写的某种类型的分发表：根据命令调用函数；当需要把字符串转换成函数指针时，就想想典型的C的习惯用法：

    typedef struct {
      char *name;
      void (*fptr)();
    } Tuple;
    Tuple list[]= {
      { "play",   fptr_play },
      { "stop",   fptr_stop },
      { "record", fptr_record },
      { 0, 0 },
    };
    ...
    void dispatch(char *cmd) {
      int i = 0;
      for (; list[i].name; i++) {
        if (strncmp(list[i].name,cmd,strlen(cmd)) == 0) {
          list[i].fptr();
          return;
        }
      }
      /* not found */
    }


在ruby中，可以只用一行代码。
而且是动态的。很容易找到在运行时添加的新方法。
把所有的命令函数塞到一个类中，然后创建类的一个实例（commands），并要求那个对象用`command_string`去执行同一名称的方法：

    Command.send(command_string)

无需编写特别的command类来支持send方法：它适用于任何对象。

    "John Coltrane".send(:length)          → 13 
    "Miles Davis".send("sub", /iles/, '.') → "M. Davis"

**Method**
另一种动态调用方法的方法是使用Method对象。
Method对象类似Proc对象：它表示一段代码以及执行它所在的上下文。
下面的例子中，代码是方法的程序体，而上下文是创建了这个方法的对象。
一旦有了自己的Method对象，我们可以在后面通过发送消息call来执行它。

    trane = "John Coltrane".method(:length)
    miles = "Miles Davis".method("sub")
    trane.call               → 13
    miles.call(/iles/, '.')  → "M. Davis"

可以像对待其他对象一样到处传递Method对象，当调用Method#call时，那个方法就会运行，就像是在原有对象上调用的那样。
它类同C语言中的函数指针，且是以完全面向对象的风格来实现的。

也可以和迭代器一起使用Method对象：

    def double(a)
      2*a
    end
    mObj = method(:double)
    [1, 3, 5,7].collect(&mObj)  # [2, 6, 10, 14]

**绑定和非绑定**
Method对象绑定到一个特别的对象。
可以创建非绑定方法（类是UnboundMethod），然后将它们绑定到一个或多个对象。
这个绑定创建新的Method对象。
如别名一样，非绑定方法所指向的是其被创建时的有效方法定义。

    # 将string#length方法设置为变量unbound_length
    unbound_length = String.instance_method(:length)
    class String
      def length   # 重新定义length方法。
        99
      end
    end
    str = "cat"
    str.length → 99
    # <kinder:note> 下面将非绑定方法特别地绑定到一个对象中去。
    bound_length = unbound_length.bind(str)
    bound_length.call → 3
    /*译注：unbound_length指向的依然是原来的String.length方法*/

**eval方法**
这里还有另一种方法可以动态地调用方法。
eval方法（和它的变种如`class_eval``module_eval``instance_eval`）会解析和执行合法ruby源码的任意字符串。

    trane = %q{"John Coltrane".length}
    miles = %q{"Miles Davis".sub(/iles/, '.')}
    eval trane → 13
    eval miles → "M. Davis"

使用eval时，明确指出表达式求值是使用的上下文而非当前上下文，是有帮助的。
可以在想要的位置调用Kernel#binding来得到上下文：

    def get_a_binding
      val = 123
      binding   # <kinder:note> 强调表达式val = 123.
    end
    val = "cat"
    the_binding = get_a_binding
    eval("val", the_binding) → 123
    eval("val")              → "cat"

对val求值的第一个eval，其执行所在的上下文，就像在``方法中执行那样。在这个绑定中，val变量的值是123.
第二个eval在等层绑定中对val求值，是cat。

### 26.3.1 eval的性能考虑
eval会比send和call的技术慢很多。

    require 'benchmark'
    include Benchmark
    test = "Stormy Weather"
    m = test.method(:length)
    n = 100000
    bm(12) {|x|
                x.report("call") { n.times { m.call } }
                x.report("send") { n.times { test.send(:length) } }
                x.report("eval") { n.times { eval "test.length" } }
    }
    # produces:
    #        user      system    total      real
    # call   0.250000  0.000000  0.250000 ( 0.340967)
    # send   0.210000  0.000000  0.210000 ( 0.254237)
    # eval   1.410000  0.000000  1.410000 ( 1.656809)

## 　　26.4　系统钩子
钩子是一个跟踪一些ruby事件的技术，比如跟踪对象创建。

### 25.4.1 Hooking Method Calls 方法调用钩子
在ruby中，最简单的钩子技术是截取程序执行的系统命令。
你可能想记录程序所执行的所有操作系统命令。
只要重命名Kernel.system方法，用你自己的kernel.system替换它就可以了，它会把系统命令计入日记并调用原来的kernel方法。
<kinder:note> 2版的例子：

    module Kernel
      alias_method :old_system, :system
      def system(*args)
        result = old_system(*args)
        puts "system(#{args.join(', ')}) returned #{result}"
        result
      end
    end
    system("date")
    system("kangaroo", "-hop 10", "skippy")
    # produces:
    # Thu Aug 26 22:37:22 CDT 2004
    # system(date) returned true
    # system(kangaroo, -hop 10, skippy) returned false

<kinder:note> 4版的例子：

    class Object
      alias_method :old_system, :system
      def system(*args)
        old_system(*args).tap do |result|  # <kinder:note> tap方法干嘛的？
          puts "system(#{args.join(', ')}) returned #{result.inspect}"
        end
      end
    end
    system("date")
    system("kangaroo", "-hop 10", "skippy")
    # produces:
    # Mon May 27 12:31:42 CDT 2013
    # system(date) returned true
    # system(kangaroo, -hop 10, skippy) returned nil

**方法对象和prepend** 4版新增
The problem with this technique is that you’re relying on there not being an existing method called `old_system`. 
这个技巧所带的问题是你依赖的那个现存的方法不能叫`old_system`。
A better alternative is to make use of method objects, which are effectively anonymous:
一个更好的选择是使用方法对象，实际上是个匿名类。

    class Object
      old_system_method = instance_method(:system)
      define_method(:system) do |*args|
        old_system_method.bind(self).call(*args).tap do |result|
          puts "system(#{args.join(', ')}) returned #{result.inspect}"
        end
      end
    end
    system("date")
    system("kangaroo", "-hop 10", "skippy")
    # produces:
    # Mon May 27 12:31:43 CDT 2013
    # system(date) returned true
    # system(kangaroo, -hop 10, skippy) returned nil

⇡New in 2.0⇣
Ruby 2.0 gives us a new way of doing this. 
Ruby 2.0给出了一个新方法来干这个。
Modules can be used to include new instance methods in some other module or class. 
模块可用于包含其他一些模块或类的新的实例方法。
Until now, these methods were added behind the host module or class’s own methods—if the module defined a method with the same name as one in the host, the host method would be called. 
直到现在，这些方法被添加在住模块或类自己的方法之后--如果模块定义了一个和主类同名的方法，主方法将被调用。
Ruby 2 adds the prepend method on page 585 to modules. 
ruby2在后面585页增加了模块的prepend方法。
This lets you insert the module’s methods before the host’s. 
这让你在主类方法之前插入一个模块的方法。
Within the module’s methods, calling super calls the host’s method of the same name. 
在模块方法里面，调用super会调用同名的主类方法。
This gives us:
这让我们可以：

    module SystemHook
      private
      def system(*args)
        super.tap do |result|
          puts "system(#{args.join(', ')}) returned #{result.inspect}"
        end
      end
    end
    class Object
      prepend SystemHook
    end
    system("date")
    system("kangaroo", "-hop 10", "skippy")
    # produces:
    # Mon May 27 12:31:43 CDT 2013
    # system(date) returned true
    # system(kangaroo, -hop 10, skippy) returned nil

### 25.4.2 Object Creation Hooks 对象创建钩子
一个更强大的钩子是捕捉对象的创建。
如果当创建每个对象时你都能在场，就可以包装它们，向其中添加方法，从中删除方法，以及把它们添加到容器中以实现持久性，随你自由发挥。

这里有个简单的例子：当每个对象创建时，我们会为其添加时间戳。
首先通过黑掉Object类本身来把timestamp属性添加到系统中的每个对象。

    class Object
      attr_accessor :timestamp
    end

然后需要钩住对象的创建以添加时间戳。
一种方法是在Class#new上使用方法重命名这个小技巧，被调用的方法会为新的对象分配空间。
这项技术并不是完美无缺的--某些如字面量(literal)的内建对象并不是调用new来构造的--但处理我们编写的对象没有问题。
<kinder:note> 2版的代码：

    class Class
      alias_method :old_new, :new
      def new(*args)
        result = old_new(*args)
        result.timestamp = Time.now
        result
      end
    end

<kinder:note> 4版的代码：

    class Class
      old_new = instance_method :new
      define_method :new do |*args, &block|
        result = old_new.bind(self).call(*args, &block)
        result.timestamp = Time.now
        result
      end
    end

最后，我们测试一下。
每隔几个毫秒便创建一个对象，同时检查它的时间戳。
<kinder:note> 2版的测试：

    class Test
    end
    obj1 = Test.new
    sleep(0.002)
    obj2 = Test.new
    obj1.timestamp.to_f → 1093577843.1312
    obj2.timestamp.to_f → 1093577843.14144
    # <kinder:note> 怎么看起来是差了0.01秒，而不是0.002
    # 中间的0.008是ruby执行的速度过慢引起的？

<kinder:note> 4版的测试：

    class Test
    end
    obj1 = Test.new
    sleep(0.002)
    obj2 = Test.new
    obj1.timestamp.to_f # => 1369675903.251721
    obj2.timestamp.to_f # => 1369675903.2541282

<kinder:note> 下面的文字在4版被删除。原因可能是25.4.1已经解释过了：
方法重命名技术真起作用了，但它可能会导致问题。
如果一个子类作同样的事情，用同样的名字对方重命名，那么它最终会进入一个无限循环。
可以通过将方法的别名指定一个唯一的符号名，或采用一致的命名规则来避免这个问题。

还有其他更好的方法可以进入到运行中的程序内部。
ruby提供了几种回调方法，让你以受控的方式去跟踪某些事件。

### 26.4.1 运行时回调函数 <kinder:note> 4版删除

    事件          回调函数
    添加实例方法  Module#method_added
    删除实例方法  Module#method_removed
    撤销实例方法  Module#method_undefined
    添加单例方法  Kernel.singleton_method_added
    删除单例方法  Kernel.singleton_method_removed
    撤销单例方法  Kernel.singleton_method_undefineded
    子类化某个类  Class#inherited
    混入一个模块  Module#extend_object

无论何时发生了上面的事件，你都会被通知。
默认情况下，这些方法什么也不做。
如果在类中回调函数给定义了，则会自动被调用。
它们的实际调用顺序在每个回调函数的ruby库文档描述中详细阐明了。

持续追踪方法和类的创建以及对模块的使用，可以让你精确刻画程序的动态状态，这是很重要的。
比如，你编写代码把所有的方法包装到一个类中，可能是为了添加事务处理支持或实现某种形式的授权。
然任务只完成了一半：ruby的动态特征意味着类的用户可以在任何时候为其添加新的方法。
使用回调函数，当创建那些新方法时可以编写代码对它们进行包装。


## 　　26.5　跟踪程序的执行
当我们饶有兴趣地探查（reflecting）程序中的所有对象和类时，不要忘记那些普通的语句，正是它们才让代码实际运行。
我们发现ruby也可以让我们跟踪语句。
<kinder:note> 2版：`set_trace_func`
首先，你可以在解释器执行代码时观察它。
只要是执行新的代码行、调用方法或创建对象等，`set_trace_func`就可以执行一个Proc，并提供各种丰富的调试信息。
后面529页有详细描述，下面是个小尝试：

    class Test
      def test
        a = 1
        b = 2
      end
    end
    set_trace_func proc {|event, file, line, id, binding, classname|
      printf "%8s %s:%-2d %10s %8s\n", event, file, line, id, classname
    }
    t = Test.new
    t.test
    # produces:
    # line       prog.rb:11             false   <kinder:note> false应该是表示没有返回值，转而调用其他行的意思。
    # c-call     prog.rb:11 new         Class
    # c-call     prog.rb:11 initialize  Object
    # c-return   prog.rb:11 initialize  Object
    # c-return   prog.rb:11 new         Class
    # line       prog.rb:12             false
    # call       prog.rb:2 test         Test
    # line       prog.rb:3 test         Test
    # line       prog.rb:4 test         Test
    # return     prog.rb:4 test         Test

<kinder:note> 4版：TracePoint类
First, you can watch the interpreter as it executes code. 
首先，你可以在解释器执行代码时观察它。
In older Rubies, you use `set_trace_func`, while in Ruby 2 you use the TracePoint class. 
在老版本的ruby，你使用`set_trace_func`，而ruby 2你可使用TracePoint类。
Both are used to execute a proc with all sorts of juicy debugging information whenever a new source line is executed, methods are called, objects are created, and so on.
两者都用于执行一个proc，带有所有类别的丰富调试信息，不论何时一个新的源代码被执行，方法被调用，对象被创建等等。

The reference section contains full descriptions of `set_trace_func` on page 624 and TracePoint on page 722, but here’s a taste:
后面“参考“一章624页有`set_trace_func`的全部描述，722页有TracePoint的全部描述。下面感受一下：

    class Test
      def test
        a = 1
      end
    end
    TracePoint.trace do |tp|
      p tp
    end
    t = Test.new
    t.test
    # produces:
    # #<TracePoint:c_return `trace'@prog.rb:7>
    # #<TracePoint:line@prog.rb:10>
    # #<TracePoint:c_call `new'@prog.rb:10>
    # #<TracePoint:c_call `initialize'@prog.rb:10>
    # #<TracePoint:c_return `initialize'@prog.rb:10>
    # #<TracePoint:c_return `new'@prog.rb:10>
    # #<TracePoint:line@prog.rb:11>
    # #<TracePoint:call `test'@prog.rb:2>
    # #<TracePoint:line@prog.rb:3 in `test'>
    # #<TracePoint:return `test'@prog.rb:4>

`trace_var`方法（后面2版532页4版630页有描述）让你为全局变量添加一个钩子：无论何时对这个全局变量赋值，Proc对象都会被调用。
### 26.5.1 我们如何到这儿的
在ruby中至少可以使用caller方法正确地找到“how you got there”，它返回String对象的数组，表示当前的调用栈。

    def cat_a
      puts caller.join("\n")  # 这是2版的。
      # puts caller 这是4版的。
    end
    def cat_b
      cat_a
    end
    def cat_c
      cat_b
    end
    cat_c
    # produces:
    # prog.rb:5:in `cat_b'
    # prog.rb:8:in `cat_c'
    # prog.rb:10     4版这一行是：prog.rb:10:in `<main>`

一旦你已经了解是如何到这里的，下一步往哪儿走就取决于你了。
Ruby 1.9 also introduces `__callee__`, which returns the name of the current method.
Ruby 1.9也引入了`__callee__`，它可以返回当前方法的名字。

### 26.5.2 源代码
ruby从纯文本文件中执行程序。
你可以使用多种技术，通过查看文件来检验构成程序的代码。

`__FILE__`这个特殊变量包含当前源文件的名称。因此它可以将自身的源代码输出出来。

    print File.read(__FILE__)

Kerner.caller方法返回调用栈--当调用该方法时存在的栈帧(frame)的列表。
表中的每一项以文件名、冒号以及文件中的行号开始。
可以解析这些信息以显示源代码。

下面的例子中，主程序main.rb调用了另一个文件sub.rb中的方法，这个方法反过来调用一个代码块，代码块中我们遍历调用栈并写出相应的源代码行。
注意这里使用了文件内容的散列表，它以文件名为索引。

    #这段代码转储了调用栈，其中包含源代码的信息。
    def dump_call_stack
      file_contents = {}
      puts "File Line Source Line"
      puts "-------------------------+----+------------"
      caller.each do |position|        # <kinder:note> 看到吧，caller在这里！
        next unless position =~ /\A(.*?):(\d+)/
        file = $1
        line = Integer($2)
        file_contents[file] ||= File.readlines(file)
        printf("%-25s:%3d - %s", file, line,
                file_contents[file][line-1].lstrip)
      end
    end

    #这个sub.rb文件只包含一个方法
    def sub_method(v1, v2)
      main_method(v1*3, v2*6)
    end

    # 这里是主程序，在被submethod回调后调用栈转储方法。
    require 'sub'
    require 'stack_dumper'
    def main_method(arg1, arg2)
      dump_call_stack
    end
    sub_method(123, "cat")
    # produces:
    # File                   Line Source Line
    -------------------------+----+------------
    code/caller/main.rb      : 5 - dump_call_stack
    ./code/caller/sub.rb     : 2 - main_method(v1*3, v2*6)
    code/caller/main.rb      : 8 - sub_method(123, "cat")

`SCRIPT_LINE__`常量与这个技术密切相关。
如果程序用散列表初始化了`SCRIPT_LINE__`常量，散列表会得到每个文件的源代码。
这些文件是通过使用require或load依次被载入到解释器中的。
The entry’s key is the name of the file, and the value is the source of the file as an array of strings.
项目的键是文件名，值是文件的源代码构成的字符串序列。
详细示例参见后面528页的Kernel.require。

## 25.6 Behind the Curtain: The Ruby VM  幕布的后面：ruby虚拟机
Ruby 1.9 comes with a new virtual machine, called YARV. 
Ruby 1.9出现了一个新的虚拟机，YARV。
As well as being faster than the old interpreter, YARV exposes some of its state via Ruby classes.
不仅比旧的解释器更快，YARV还通过ruby类曝光一些自身状态。

If you’d like to know what Ruby is doing with all that code you’re writing, you can ask YARV to show you the intermediate code that it is executing. 
如果你想知道ruby在你写的代码下做了什么，你就让YARV展示给你看执行中的即刻代码。
You can ask it to compile the Ruby code in a string or in a file and then disassemble it and even run it. [2]
你可以让它编译在一个字符串或文件里面的ruby代码，并进行分解甚至运行。
[2]
People often ask whether they can dump the opcodes out and later reload them. 
人们常问它们是否能将过程码转储出来，稍后再重载他们。
The answer is no— the interpreter has the code to do this, but it is disabled because there is not yet an intermediate code verifier for YARV.
答案是否--解释器有这样做的代码，但却不能做，因为目前还没有适用YARV的立即代码检验器。
Here’s a trivial example:
这是一个小例子：

    code = RubyVM::InstructionSequence.compile('a = 1; puts 1 + a')
    puts code.disassemble
    # produces:
    # == disasm: <RubyVM::InstructionSequence:<compiled>@<compiled>>==========
    # local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
    # [ 2] a
    # 0000 trace 1 ( 1)
    # 0002 putobject_OP_INT2FIX_O_1_C_
    # 0003 setlocal_OP__WC__0 2
    # 0005 trace 1
    # 0007 putself
    # 0008 putobject_OP_INT2FIX_O_1_C_
    # 0009 getlocal_OP__WC__0 2
    # 0011 opt_plus <callinfo!mid:+, argc:1, ARGS_SKIP>
    # 0013 opt_send_simple <callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP>
    # 0015 leave

Maybe you want to know how Ruby handles #{...} substitutions in strings. 
可能你想知道ruby怎么处理字符串里的#{...}替换。
Ask the VM.
问VM吧：

    code = RubyVM::InstructionSequence.compile('a = 1; puts "a = #{a}."')
    puts code.disassemble
    # produces:
    # == disasm: <RubyVM::InstructionSequence:<compiled>@<compiled>>==========
    # local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
    # [ 2] a
    # 0000 trace 1 ( 1)
    # 0002 putobject_OP_INT2FIX_O_1_C_
    # 0003 setlocal_OP__WC__0 2
    # 0005 trace 1
    # 0007 putself
    # 0008 putobject "a = "
    # 0010 getlocal_OP__WC__0 2
    # 0012 tostring      <kinder:note> 看到了？就是这里！
    # 0013 putobject "."
    # 0015 concatstrings 3
    # 0017 opt_send_simple <callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP>
    # 0019 leave

For a full list of the opcodes, print out `RubyVM::INSTRUCTION_NAMES`.
要过程码的全部清单，打印`RubyVM::INSTRUCTION_NAMES`即可。

## 　　26.6　列集和分布式Ruby
**序列化和列集**
Java提供了序列化serialize对象的特性，可以在某处保存对象，并且需要的话可以重建(reconsitute)它们。
比如可以使用这个功能保存一个对象树，这些对象表示某部分程序的状态--一份文档，一张CAD绘图或一小段音乐等等。

ruby把这个类型的序列化成为列集（marshaling，想想铁路的装货场，在那里每辆汽车依次被装配到火车中，然后发送到别的地方）
可以使用Marshal.dump方法来保存一个对象和它的部分或所有组成对象（component）。
通常你从某些给定的对象作为起点，对其整个对象树进行转储，然后你可以使用Mashal.load方法了重建对象。

下面是一个简短的例子。
这里是一个Chord类，保存有一组音符（note）。
我们希望把一个特别美妙的旋律存储下来，这样可以通过电子邮件把它发送给朋友。
他们可以把它加载到自己的ruby中并进行欣赏它。

    Note = Struct.new(:value)
    class Note
      def to_s
        value.to_s
      end
    end
    class Chord
      def initialize(arr)
        @arr = arr
      end
      def play
        @arr.join('-')
      end
    end

现在开始创作并保存到磁盘：

    c = Chord.new( [ Note.new("G"),
                      Note.new("Bb"),
                      Note.new("Db"),
                      Note.new("E") ] )
    File.open("posterity", "w+") do |f|
      Marshal.dump(c, f)
    end

最终别人读取它：

    File.open("posterity") do |f|
      chord = Marshal.load(f)
    end
    chord.play → "G-Bb-Db-E"

### 26.6.1 定制序列化策略
并不是所有的对象都可以转储：绑定(binding)、过程(procedure)对象、IO类的实例，以及单例对象，不能在正运行的ruby环境之外保存（如果试着这么做，会抛出TypeError）
即使你的对象并不包括这些问题对象，你也可能想自己控制对象的序列化。

Marshal提供了你所需要的钩子。
只要在需要定制序列化的对象中实现两个实例方法：
一个是`marshal_dump`实例方法，把对象写到字符串。它应该返回一个对象，表示要被转储的状态。
一个是`marshal_load`，读取刚才创建的字符串并用它来初始化新分配的对象。它重构对象时，会对这个对象调用`marshal_load`来设置其状态--该方法执行时以目标加载类的已分配但没有初始化的对象为上下文。
<kinder:note> ？？？
（在早期的ruby版本中，你得使用`_dump`和`_load`方法，但在新版本的方法和ruby1.8的新分配方案合作得更好）

比如，这里是一个示范类，它定义了自己的序列化。
不管什么原因，Special不希望把它其中一个内部数据成员@volatile保存下来。
编写者决定将其他两个实例变量序列化到一个数组中。

    class Special
      def initialize(valuable, volatile, precious)
        @valuable = valuable
        @volatile = volatile
        @precious = precious
      end
      def marshal_dump
        [ @valuable, @precious ]
      end
      def marshal_load(variables)
        @valuable = variables[0]
        @precious = variables[1]
        @volatile = "unknown"
      end
      def to_s
        "#@valuable #@volatile #@precious"
      end
    end
    obj = Special.new("Hello", "there", "World")
    puts "Before: obj = #{obj}"
    data = Marshal.dump(obj)
    obj = Marshal.load(data)
    puts "After: obj = #{obj}"
    # produces:
    # Before: obj = Hello there World
    # After: obj = Hello unknown World

更多细节，参见后面535开始的Marshal参考章节。

### 26.6.2 用YAML来列集
Marshal模块内建在解释器中，使用二进制格式在外部保存对象。
尽管速度快，却有很大不足：如果解释器有了非常大的改变，这个marshal二进制格式可能也会改变，而老的转储文件可能再也不能被载入。

另外一个办法是使用不那么严谨的外部格式，这个格式更适合用文本文件而不是二进制文件来表示。
其中一个选择是YAML[2]，ruby1.8有个标准库来支持它。
[2] http:///www/haml.org。YAML代表YAML不是标记语言。

可以改写先前marshal例子来使用YAML格式。
不是实现特定的载入和转储模块来控制marshal处理，在这里我们只是简单定义了`to_yaml_properties`模块，它返回要被保存的实例变量列表。

    require 'yaml'
    class Special
      def initialize(valuable, volatile, precious)
        @valuable = valuable
        @volatile = volatile
        @precious = precious
      end
      def to_yaml_properties
        %w{ @precious @valuable }
      end
      def to_s
        "#@valuable #@volatile #@precious"
      end
    end
    obj = Special.new("Hello", "there", "World")
    puts "Before: obj = #{obj}"
    data = YAML.dump(obj)
    obj = YAML.load(data)
    puts "After: obj = #{obj}"
    # produces:
    # Before: obj = Hello there World
    # After: obj = Hello World

可以看看作为对象的序列化格式，YAML究竟创建了什么--

    obj = Special.new("Hello", "there", "World")
    puts YAML.dump(obj)
    # produces:
    # --- !ruby/object:Special
    # precious: World
    # valuable: Hello

### 26.6.3 分布式ruby
既然可以把对象或一组对象序列化到一种适合进程外（out-of-process）存储的形式，也可以使用这个能力把对象从一个进程发送到另一进程。
把这个本领和联网的威力结合起来，我们就有一个分布式的对象系统了。
为了避免自己写代码的麻烦，我们建议使用Masatoshi Seki的分布式ruby库（drb），它现在是一个标准ruby库。

使用drb的ruby进程可能会作为服务器、客户机或者两者都是。
drb服务器是对象的源，而客户机是对象的使用者。
对客户机来说，这些对象表现为本地对象，但实际上代码仍然在远程执行。

服务器通过将对象与一个给定的端口相关联来启动服务。
线程在内部被创建来处理对这个端口的请求，因此当退出程序时，请记住等待(join)drb线程终止。

    require 'drb'
    class TestServer
      def add(*args)
        args.inject {|n,v| n + v}
      end
    end
    server = TestServer.new
    DRb.start_service('druby://localhost:9000', server)
    DRb.thread.join # 不要马上退出

一个简单的drb客户机只是创建一个本地的drb对象，并把它与在远程服务器上的对象关联起来，这个本地对象只是一个代理。

    require 'drb'
    DRb.start_service()
    obj = DRbObject.new(nil, 'druby://localhost:9000')
    # Now use obj
    puts "Sum is: #{obj.add(1, 2, 3)}"

客户机连接上服务器并调用add方法，这个方法使用inject魔法对参数求和，返回结果并由客户机打印出来：

    Sum is: 6

DRbObject的初始nil参数表明我们希望附着（attach）到一个新的分布式对象，也可以使用现有的对象。

这个例子听起来像Java的RMI，CORBA或别的什么。
是的。drb是一个全功能的分布式对象机制--但仅用几百行ruby代码写成。
当然，它没有命名（naming）服务或交易（trader）服务，或任何你能在CORBA中看到的东西，但它简单，运行起来相当快。
在2.5GHz的PowerMac机器上，这段代码每秒大约可以调用1300个远程消息。

同时，如果你喜欢Sun的JavaSpaces样子（JINI架构的基础），你会有兴趣了解drb是以一个短小的模块来发行的，它完成类似的事情(drb is distributed with a short module that does the same kind of thing)。
JavaSpaces是基于一种被称为Linda的技术，而ruby版本的Linda被称为Rinda。

如果你喜欢臃肿麻木但支持互操作的远程消息调用，可以看看ruby分发中SOAP库。
ruby的SOAP实现是了不起的一项工作。

## 　　26.7　编译时？运行时？任何时
使用ruby要记住的一件重要的事情是：在“编译时”和“运行时”之间没有太大的差别。
它们都是相同的。
可以向一个正运行的进程添加代码，可以动态地重新定义方法，把它们的作用域从public改成private等等，甚至可以修改像Class和Object那样的基本类型。

一旦习惯了这种灵活性，再让你回到如C++的静态语言中甚至如Java的半静态语言，会是一个间困难的事情。
但是你为什么要回头呢？


# 第4部分　Ruby库的参考
# 　第27章　内置的类和模块
## 概述
This chapter documents the classes and modules built into the standard Ruby language.
本章介绍内置在标准Ruby语言中的类和模块。
They are available to every Ruby program automatically; no require is required. 
它们自动被任意一个ruby程序所拥有；不需要使用require。
This section does not contain the various predefined variables and constants; they are listed in Predefined Variables, on page 311.
本章不包含各种与定义的变量和常量；在前面2版333页4版311页有其列表。
In the descriptions that follow, we show sample invocations for each method.
从下面（2版427页开始）的描述中，我们展示了每个方法的用例。

    ---
    new        String.new( val ) → str
    ---

This description shows a class method that is called as String.new. 
该描述展示了一个名为String.new的类方法。
The italic parameter indicates that a single string is passed in, and the arrow indicates that another string is returned from the method. 
用斜体字写的参数表明传入了一个字符串，箭头表明该方法返回另一个字符串。
Because this return value has a different name than that of the parameter, it represents a different object.
因为返回值和参数的名字不同，因此它表示不同的对象。

When we illustrate instance methods, we show a sample call with a dummy object name in italics as the receiver.
当演示实例方法时，我们用斜体表示的伪对象名作为接收者来展示方法调用。

    ---
    lines          str.lines( sep=$/ ) { |line| ... } → str
    ---

The parameter to String#lines is shown to have a default value; call lines with no parameter, and the value of $/ will be used. 
String#lines的参数具有默认值；当不带参数调用lines时，将使用$/的值。
This method is an iterator, so the call is followed by a block.
这个方法是一个迭代器，所以调用后跟一个block。
String#lines returns its receiver, so the receiver’s name (str in this case) appears again after the arrow.
String#lines返回它的接收者，所以接收者的名字（在本例中是str）在箭头后再次出现。

Some methods have optional parameters. 
有些方法具有可选参数。
We show these parameters between angle brackets, ‹ xxx ›. 
我们将这种参数放在尖括号中，如‹ xxx ›。
We use the notation ‹ xxx ›* to indicate zero or more occurrences of xxx, and we use ‹ xxx ›+ to indicate one or more occurrences of xxx.
我们用符号‹ xxx ›*来表示xxx出现0次或多次，用‹ xxx ›+表示xxx出现一次或多次。

    ---
    index         str.index( string ‹ , offset › ) → int or nil
    ---

Finally, for methods that can be called in several different forms, we list each form on a separate line.
最后，对那些具有多种不同调用方式的方法，我们将各种形式列在不同的行上。

## 27.1 Alphabetical Listing 字母顺序列表
Standard classes are listed alphabetically, followed by the standard modules. 
标准类按字母顺序一一列出，其后是标准模块。
Within each, we list the class (or module) methods, followed by the instance methods.
在每个类或模块中，我们先列出类（或模块的方法），然后列出实例方法。
### 27.1.1 内建类
Array (page 421): 
Class [], new, try_convert 
Instance &, *, +, -, <<, <=>, ==, [], []=, |, assoc, at, bsearch, combination, collect!, compact, compact!, concat, count, cycle, delete, delete_at, delete_if, each, each_index, empty?, eql?, fetch, fill, find_index, flatten, flatten!, frozen?, index, insert, join, keep_if, last, length, map!, pack, permutation, pop, product, push, rassoc, reject!, repeated_combination, repeated_permutation, replace, reverse, reverse!, reverse_each, rindex, rotate, rotate!, sample, select!, shift, shuffle, shuffle!, size, slice, slice!, sort!, sort_by!, to_a, to_ary, to_s, transpose, uniq, uniq!, unshift, values_at

BasicObject (page 439): 
Instance !, ==, !=, __id__, equal?, instance_eval, instance_exec, __send__ Private method_missing, singleton_method_added, singleton_method_removed, singleton_method_undefined

Bignum (page 444):
Instance Arithmeticoperations, Bitoperations, <=>, ==, [], abs, div, divmod, eql?, fdiv, magnitude, modulo, remainder, size, to_f, to_s

Binding (page 447): 
Instance eval

Class (page 448): 
Class new 
Instance allocate, new, superclass Private inherited

Complex (page 451): 
Class polar, rect, rectangular 
Instance Arithmeticoperations, ==, abs, abs2, angle, arg, conj, conjugate, denominator, eql?, fdiv, imag, imaginary, magnitude, numerator, phase, polar, quo, rationalize, rect, rectangular, real, real?, to_f, to_i, to_r

Dir (page 456): 
Class [], chdir, chroot, delete, entries, exist?, exists?, foreach, getwd, glob, home, mkdir, new, open, pwd, rmdir, unlink 
Instance close, each, path, pos, pos=, read, rewind, seek, tell, to_path

Encoding (page 462): 
Class aliases, compatible?, default_external, default_external=, default_internal, default_internal=, find, list, locale_charmap, name_list 
Instance ascii_compatible?, dummy?, name, names, replicate

Enumerator (page 477): 
Class new 
Instance each, each_with_index, each_with_object, feed, next, next_values, peek, peek_values, rewind, size, with_index, with_object

Exception (page 483): 
Class exception, new 
Instance ==, backtrace, exception, message, set_backtrace, status, success?, to_s

FalseClass (page 486): 
Instance &, ^, |

Fiber (page 487): 
Class new, yield 
Instance resume

File (page 488): 
Class absolute_path, atime, basename, blockdev?, chardev?, chmod, chown, ctime, delete, directory?, dirname, executable?, executable_real?, exist?, exists?, expand_path, extname, file?, fnmatch, fnmatch?, ftype, grpowned?, identical?, join, lchmod, lchown, link, lstat, mtime, new, owned?, path, pipe?, readable?, readable_real?, readlink, realdirpath, realpath, rename, setgid?, setuid?, size, size?, socket?, split, stat, sticky?, symlink, symlink?, truncate, umask, unlink, utime, world_readable?, world_writable?, writable?, writable_real?, zero? 
Instance atime, chmod, chown, ctime, flock, lstat, mtime, path, size, to_path, truncate

File::Stat (page 503): 
Instance <=>, atime, blksize, blockdev?, blocks, chardev?, ctime, dev, dev_major, dev_minor, directory?, executable?, executable_real?, file?, ftype, gid, grpowned?, ino, mode, mtime, nlink, owned?, pipe?, rdev, rdev_major, rdev_minor, readable?, readable_real?, setgid?, setuid?, size, size?, socket?, sticky?, symlink?, uid, world_readable?, world_writable?, writable?, writable_real?, zero?

Fixnum (page 510): 
Instance Arithmeticoperations, Bitoperations, Comparisons, <=>, [], abs, div, even?, divmod, fdiv, magnitude, modulo, odd?, size, succ, to_f, to_s, zero?

Float (page 513): 
Instance Arithmeticoperations, Comparisons, <=>, ==, abs, ceil, divmod, eql?, fdiv, finite?, floor, infinite?, magnitude, modulo, nan?, quo, rationalize, round, to_f, to_i, to_int, to_r, to_s, truncate, zero?

Hash (page 521): 
Class [], new, try_convert 
Instance ==, [], []=, assoc, clear, compare_by_identity, compare_by_identity?, default, default=, default_proc, default_proc=, delete, delete_if, each, each_key, each_pair, each_value, empty?, fetch, flatten, has_key?, has_value?, include?, index, invert, keep_if, key, key?, keys, length, member?, merge, merge!, rassoc, rehash, reject, reject!, replace, select, select!, shift, size, sort, store, to_a, to_h, to_hash, to_s, update, value?, values, values_at

Integer (page 532): 
Instance ceil, chr, denominator, downto, even?, floor, gcd, gcdlcm, integer?, lcm, next, numerator, odd?, ord, pred, rationalize, round, succ, times, to_i, to_int, to_r, truncate, upto

IO (page 536): 
Class binread, binwrite, copy_stream, for_fd, foreach, new, open, pipe, popen, read, readlines, select, sysopen, try_convert, write 
Instance <<, advise, autoclose=, autoclose?, binmode, binmode?, bytes, chars, close, close_on_exec?, close _on_exec=, close_read, close_write, closed?, codepoints, each, each_byte, each_char, each_codepoint, each_line, eof, eof?, external_encoding, fcntl, fdatasync, fileno, flush, fsync, getbyte, getc, gets, internal_encoding, ioctl, isatty, lineno, lineno=, lines, pid, pos, pos=, print, printf, putc, puts, read, readbyte, readchar, readline, readlines, readpartial, read_nonblock, reopen, rewind, seek, set_encoding, stat, sync, sync=, sysread, sysseek, syswrite, tell, to_i, to_io, tty?, ungetbyte, ungetc, write, write_nonblock

MatchData (page 559): 
Instance [], begin, captures, end, length, names, offset, post_match, pre_match, regexp, size, string,
to_a, to_s, values_at

Method (page 565): 
Instance [], ==, arity, call, eql?, name, owner, parameters, receiver, source_location, to_proc, unbind

Module (page 568): 
Class constants, nesting, new 
Instance <,<=,==,>,>=, <=>, ===, ancestors, autoload, autoload?, class_eval, class_exec, class_variable_defined?, class_variable_get, class_variable_set, class_variables, const_defined?, const_get, const_missing, const_set, constants, include?, included_modules, instance_method, instance_methods, method_defined?, module_eval, module_exec, name, private_class_method, private_constant, private_instance_methods, private_method_defined?, protected_instance_methods, protected_method_defined?, public_class_method, public_constant, public_instance_method, public_instance_methods, public_method_defined?, remove_class_variable Private alias_method, append_features, attr, attr_accessor, attr_reader, attr_writer, define_method, extend_object, extended, include, included, method_added, method _removed, method_undefined, module_function, prepend, private, protected, public, refine, remove_const, remove_method, undef_method

Mutex (page 588): 
Instance lock, locked?, owned?, sleep, synchronize, try_lock, unlock

NilClass (page 589): 
Instance &, ^, |, nil?, rationalize, to_a, to_c, to_f, to_h, to_i, to_r, to_s

Numeric (page 591): 
Instance +@, -@, <=>, %, abs, abs2, angle, arg, ceil, coerce, conj, conjugate, denominator, div, divmod, eql?, fdiv, floor, i, imag, imaginary, integer?, magnitude, modulo, nonzero?, numerator, phase, polar, quo, real, real?, rect, rect-angular, remainder, round, step, to_c, to_int, truncate, zero?

Object (page 599): 
Instance ===, <=>, =~, !~, class, clone, define_singleton_method, display, dup, enum_for, eql?, extend, freeze, frozen?, hash, initialize_clone, initialize_copy, initialize_dup, inspect, instance_of?, instance_variable_defined?, instance_variable_get, instance_variable_set, instance_variables, is_a?, kind_of?, method, methods, nil?, object_id, private_methods, protected_methods, public_method, public_methods, public_send, respond_to?, respond_to_missing?, send, singleton_class, singleton_methods, taint, tainted?, tap, to_enum, to_s, trust, untaint, untrust, untrusted? Private __callee__, __dir__, __method __, ‘(backquote), Array, Complex, Float, Hash, Integer, Rational, String, abort, at_exit, autoload, autoload?, binding, block_given?, caller, caller_locations, catch, chomp, chop, define_method, eval, exec, exit, exit!, fail, fork, format, gem, gem_original_require, gets, global_variables, gsub, initialize, iterator?, lambda, load, local_variables, loop, open, p, print, printf, proc, putc, puts, raise, rand, readline, readlines, remove_instance_variable, require, require_relative, select, set_trace_func, sleep, spawn, sprintf, srand, sub, syscall, system, test, throw, trace_var, trap, untrace_var, using, warn

Proc (page 633): 
Class new 
Instance [], ==, ===, arity, binding, call, curry, lambda?, parameters, source_location, to_proc, to_s, yield

Process::Status (page 644): 
Instance ==, &, >>, coredump?, exited?, exitstatus, pid, signaled?, stopped?, success?, stopsig, termsig, to_i, to_s

Random (page 655): 
Class new, new_seed, rand, srand 
Instance bytes, rand, seed

Range (page 650): 
Class new 
Instance ==, ===, begin, bsearch, cover?, each, end, eql?, exclude_end?, first, include?, last, max, member?, min, size, step

Rational (page 656): 
Instance Arithmeticoperations, Comparisons, <=>, ==, ceil, denominator, fdiv, floor, numerator, quo, rationalize, round, to_f, to_i, to_r, truncate

Regexp (page 659): 
Class compile, escape, last_match, new, quote, try_convert, union 
Instance ==, ===, =~, ~, casefold?,
encoding, fixed_encoding?, match, named_captures, names, options, source, to_s

String (page 666): 
Class new, try_convert 
Instance %, *, +, <<, <=>, ==, =~, [], []=, ascii_only?, b, bytes, bytesize, byteslice, capitalize, capitalize!, casecmp, center, chars, chr, clear, chomp, chomp!, chop, chop!, codepoints, concat, count, crypt, delete, delete!, downcase, downcase!, dump, each_byte, each_char, each_codepoint, each_line, empty?, encode, encode!, encoding, end_with?, eql?, force_encoding, getbyte, gsub, gsub!, hex, include?, index, insert, intern, length, lines, ljust, lstrip, lstrip!, match, next, next!, oct, ord, partition, prepend, replace, reverse, reverse!, rindex, rjust, rpartition, rstrip, rstrip!, scan, setbyte, size, slice, slice!, split, squeeze, squeeze!, start_with?, strip, strip!, sub, sub!, succ, succ!, sum, swapcase, swapcase!, to_c, to_f, to_i, to_r, to_s, to_str, to_sym, tr, tr!, tr_s, tr_s!, unpack, upcase, upcase!, upto, valid_encoding?

Struct (page 693): 
Class new, new, [], members 
Instance ==, [], []=, each, each_pair, length, members, size, to_a, to_h, values, values_at

Struct::Tms (page 697):

Symbol (page 698): 
Class all_symbols 
Instance <=>, ==, =~, [], capitalize, casecmp, downcase, empty?, encoding, id2name, inspect, intern, length, match, next, size, slice, succ, swapcase, to_proc, to_s, to_sym, upcase

Thread (page 702): 
Class abort_on_exception, abort_on_exception=, current, exclusive, exit, fork, kill, list, main, new, pass, start, stop 
Instance [], []=, abort_on_exception, abort_on_exception=, add_trace_func, alive?, backtrace, backtrace_locations, exit, group, join, keys, key?, kill, priority, priority=, raise, run, safe_level, set_trace_func, status, stop?, terminate, thread_variable?, thread_variables, thread_variable_get, thread_variable_set, value, wakeup

ThreadGroup (page 710): 
Class new 
Instance add, enclose, enclosed?, list

Time (page 712): 
Class at, gm, local, mktime, new, now, utc 
Instance +, -, <=>, day-name?, asctime, ctime, day, dst?, getgm, getlocal, getutc, gmt?, gmtime, gmt_offset, gmtoff, hour, isdst, localtime, mday, min, mon, month, nsec, round, sec, strftime, subsec, succ, to_a, to_f, to_i, to_r, to_s, tv_nsec, tv_sec, tv_usec, usec, utc, utc?, utc_offset, wday, yday, year, zone

TracePoint (page 722): 
Class new, trace 
Instance binding, defined_class, disable, enable, enabled?, event, lineno, method_id, path, raised_exception, return_value, self

TrueClass (page 725): 
Instance &, ^, |

UnboundMethod (page 726): 
Instance arity, bind, name, owner, parameters, source_location

### 27.1.2 Built-in Modules 内建模块
Comparable (page 450): 
Instance Comparisons, between?

Enumerable (page 466): 
Instance all?, any?, chunk, collect, collect_concat, count, cycle, detect, drop, drop_while, each_cons, each_entry, each_slice, each_with_index, each_with_object, entries, find, find_all, find_index, first, flat_map, grep, group_by, include?, inject, lazy, map, max, max_by, member?, min, min_by, minmax, minmax_by, none?, one?, partition, reduce, reject, reverse_each, select, slice_before, sort, sort_by, take, take_while, to_a, zip

Errno (page 482):

FileTest (page 509):

GC (page 517): 
Class count, disable, enable, start, stat, stress, stress= 
Instance garbage_collect

GC::Profiler (page 519):
Class clear, disable, enable, enabled?, raw_data, report, result, total_time

Kernel (page 556):

Marshal (page 557): Class dump, load, restore

Math (page 562): 
Class acos, acosh, asin, asinh, atan, atanh, atan2, cbrt, cos, cosh, erf, erfc, exp, frexp, gamma, hypot, ldexp, lgamma, log, log10, log2, sin, sinh, sqrt, tan, tanh

ObjectSpace (page 631): 
Class _id2ref, count_objects, define_finalizer, each_object, garbage_collect, undefine_finalizer

Process (page 637): 
Class abort, daemon, detach, egid, egid=, euid, euid=, exec, exit, exit!, fork, getpgid, getpgrp, getpriority, getrlimit, getsid, gid, gid=, groups, groups=, initgroups, kill, maxgroups, maxgroups=, pid, ppid, setpgid, setpgrp, setpriority, setrlimit, setsid, spawn, times, uid, uid=, wait, waitall, wait2, waitpid, waitpid2

Process::GID (page 643): 
Class change_privilege, eid, eid=, grant_privilege, re_exchange, re_exchangeable?, rid, sid_available?, switch

Process::Sys (page 647): 
Class getegid, geteuid, getgid, getuid, issetugid, setegid, seteuid, setgid, setregid, setresgid, setresuid, setreuid, setrgid, setruid, setuid

Process::UID (page 648): 
Class change_privilege, eid, eid=, grant_privilege, re_exchange, re_exchangeable?, rid, sid_available?, switch

Signal (page 664): 
Class list, signame, trap


## Array 数组
### 概述
relies on:each, <=>
Arrays are ordered, integer-indexed collections of any object. 
数组是有序的、由整数索引的对象组成的集合
Array indexes start at 0, as in C or Java. 
和C或Java一样，数组索引从0开始。
A negative index is relative to the end of the array; that is, an index of -1 indicates the last element of the array, -2 is the next-to-last element in the array, and so on.
负数下标是相对与数组尾部的；也就是说，-1下标表示数组的最后一个元素，-2下标表示倒数第二个元素，以此类推。

### Mixes In 混入
**Enumerable**: 

    all?, any?, 
    chunk, collect, collect_concat, count, cycle, 
    detect, drop, drop_while, each_cons, each_entry, each_slice, each_with_index, each_with_object, entries, 
    find, find_all, find_index, first, flat_map, 
    grep, group_by, 
    include?, inject, 
    lazy, 
    map, max, max_by, member?, min, min_by, minmax, minmax_by, 
    none?, 
    one?, 
    partition, 
    reduce, reject, reverse_each, 
    select, slice_before, sort, sort_by, 
    take, take_while, to_a, zip

### Class Methods 类方法
#### []

    Array[ ‹ obj ›* ] → an_array

Returns a new array populated with the given objects. Equivalent to the operator form
返回一个由给定对象生成的新数组。等价于操作符形式Array.[]{...}

    Array.[...].
    Array.[]( 1, 'a', /^A/ ) # => [1, "a", /^A/]
    Array[ 1, 'a', /^A/ ] # => [1, "a", /^A/]
    [ 1, 'a', /^A/ ] # => [1, "a", /^A/]

#### new

    Array.new → an_array
    Array.new ( size=0, obj=nil ) → an_array
    Array.new( array ) → an_array
    Array.new( size ) { |i| ... } → an_array

Returns a new array. 
返回一个新数组。
In the first form, the new array is empty. 
第一种形式生成的新数组是空的。
In the second, it is created with size copies of obj (that is, size references to the same obj). 
第二种形式生成的数组由size个obj对象的拷贝组成（也就是对同一个对象obj的size个引用）
The third form creates a copy of the array passed as a parameter (the array is generated by calling `to_ary` on the parameter).
第三种形式创建参数数组（数组由调用参数的`to_ary`方法生成）的一个拷贝。
In the last form, an array of the given size is created. 
最后一种形式将创建一个给定大小的数组。
Each element in this array is calculated by passing the element’s index to the given block and storing the return value.
其中每个元素是运行相关联block的返回值（以元素下标为参数）。

    Array.new # => []

    Array.new(2) # => [nil, nil]
    Array.new(5, "A") # => ["A", "A", "A", "A", "A"]

    # only one instance of the default object is created
    # 只创建了默认对象的一个实例
    a = Array.new(2, Hash.new)   #=> [{}, {}]
    # <kinder:note>这种写法创建一个Hash.new对象，该对象的两个引用作为a序列的元素。
    a[0]['cat'] = 'feline'       
    # <kinder:note> a[0]返回一个{}，后面的['cat']是什么意思？还是hash的键。
    a # => [{"cat"=>"feline"}, {"cat"=>"feline"}]
    #<kinder:note> 因为两个元素是引用而已，所以hash对象一变，这两个元素也变了。
    a[1]['cat'] = 'Felix'
    a # => [{"cat"=>"Felix"}, {"cat"=>"Felix"}]

    a = Array.new(2) { Hash.new } # Multiple instances 多个实例
    a[0]['cat'] = 'feline'
    a # => [{"cat"=>"feline"}, {}]
    squares = Array.new(5) {|i| i*i}
    squares # => [0, 1, 4, 9, 16]
    copy = Array.new(squares) # initialized by copying 通过拷贝初始化
    squares[5] = 25
    squares # => [0, 1, 4, 9, 16, 25]
    copy # => [0, 1, 4, 9, 16]   # 因为是拷贝，不是引用，所以没有改变

#### try_convert  1.9 

    Array.try_convert( obj ) → an_array or nil

If obj is not already an array, attempts to convert it to one by calling its to_ary method. 
如果obj还不是一个数组，将试图通过它的`to_ary`方法转为数组。
Returns nil if no conversion could be made.
如果不能转换将返回nil。

    class Stooges
      def to_ary
        [ "Larry", "Curly", "Moe" ]
      end
    end
    Array.try_convert(Stooges.new) # => ["Larry", "Curly", "Moe"]
    Array.try_convert("Shemp") # => nil


### Instance 实例方法
#### &   交集

    arr & other_array → an_array

Set Intersection—Returns a new array containing elements common to the two arrays, with no duplicates. 
设置交集--返回一个含有两个数组共有元素的新数组，且其中没有重复的元素。
The rules for comparing elements are the same as for hash keys. 
比较元素的规则和比较hash键的规则一样。
If you need setlike behavior, see the library class .Set on page 804.
如果需要类似集合的行为，参见2版731页4版804页的Set类。

    [ 1, 1, 3, 5 ] & [ 1, 2, 3 ] # => [1, 3]

#### *   重复

    arr * int → an_array
    arr * str → a_string

Repetition—With an argument that responds to to_str, equivalent to arr.join(str). 
重复--如果参数实现了`to_str`，则等价于arr.join(str)。
Otherwise, returns a new array built by concatenating int copies of arr.
否则返回由串连int个arr拷贝组成的新数组。

    [ 1, 2, 3 ] * 3 # => [1, 2, 3, 1, 2, 3, 1, 2, 3]
    [ 1, 2, 3 ] * "--" # => "1--2--3"

#### +    连接

    arr + other_array → an_array

Concatenation—Returns a new array built by concatenating the two arrays together to produce a third array.
连接--返回通过连接已有的两个数组而形成的一个新数组。

    [ 1, 2, 3 ] + [ 4, 5 ] # => [1, 2, 3, 4, 5]

#### -    差集

    arr - other_array → an_array

Array Difference—Returns a new array that is a copy of the original array, removing any items that also appear in other_array. 
数组差集--返回一个新数组，该数组是原数组的拷贝，并删除了出现在`other_arry`中的元素。
If you need setlike behavior, see the library class Set on page 804.
如果需要类似于集合的差集操作，参见2版731页4版804页的类Set。

    [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ] # => [3, 3, 5]

#### <<    追加

    arr << obj→ arr

Append—Pushes the given object on to the end of this array. 
追加--将给定的对象添加到数组的末尾。
This expression returns the array itself, so several appends may be chained together. 
这个表达式返回数组本身，所以可以链接多个追加操作。
See also Array#push.
参见Array#push。

    [ 1, 2 ] << "c" << "d" << [ 3, 4 ] # => [1, 2, "c", "d", [3, 4]]

#### <=>    比较

    arr <=> other_array → -1, 0, +1, or nil

Comparison—Returns an integer -1, 0, or +1 if this array is less than, equal to, or greater than other_array. 
比较--根据数组小于、等于或大于other_array，分别返回-1, 0或+1.
Successive objects in each array are compared using <=>. 
每个数组中的每个对象都被比较(使用<=>)。
If any pair are not equal, then that inequality is the return value. 
如果有任何值不等，那么这次比较的结果将作为返回值返回。
If all pair are equal, then the longer array is considered greater. 
如果所有的值都相等，则数组长度长的更大。
Thus, two arrays are “equal” according to Array#<=> if and only if they have the same length and the values of each corresponding element are equal. 
因此，根据Array#<=>，当且仅当两个数组长度相同且对应的元素分别相等时才认为它相等。
nil is returned if the argument is not comparable to arr.
如果参数对arr而言不可比较，则返回nil。

    [ "a", "a", "c" ] <=> [ "a", "b", "c" ] # => -1
    [ 1, 2, 3, 4, 5, 6 ] <=> [ 1, 2 ]       # => 1
    [ 1, 2, 3, 4, 5, 6 ] <=> "wombat"       # => nil

#### ==    相等

    arr == obj → true or false

Equality—Two arrays are equal if they contain the same number of elements and if each element is equal to (according to Object#==) the corresponding element in the other array.
相等--如果两个数组包含有相同数目的元素，并且对应的元素分别相等（根据Object#==），则它们相等。
If obj is not an array, attempt to convert it using to_ary and return obj==arr.如果obj不是数组，则使用to_ary将它转换成数组，然后返回obj==arr的值。


    [ "a", "c" ] == [ "a", "c", 7 ] # => false
    [ "a", "c", 7 ] == [ "a", "c", 7 ] # => true
    [ "a", "c", 7 ] == [ "a", "d", "f" ] # => false

#### []    引用元素  1.8

    arr[int] → obj or nil
    arr[start, length] → an_array or nil
    arr[range] → an_array or nil

Element Reference—Returns the element at index int; returns a length element subarray starting at index start; or returns a subarray specified by range. 
元素引用--返回下标int处的元素；返回从下标start开始由length个元素组成的子数组；或者返回由range指定的子数组。
Negative indices count backward from the end of the array (-1 is the last element). 
负数下标从数组尾部开始计算（-1是最后一个元素）。
Returns nil if the index of the first element selected is greater than the array size. 
如果被选的第一个元素的下标大于数组的大小，则返回nil。
If the start index equals the array size and a length or range parameter is given, an empty array is returned. 
如果开始下标等于数组的大小，并且给出了length或rang参数，则返回一个空数组。
Equivalent to Array#slice.
等价于Array#slice。

    a = [ "a", "b", "c", "d", "e" ]
    a[2] + a[0] + a[1] # => "cab"
    a[6] # => nil
    a[1, 2] # => ["b", "c"]
    a[1..3] # => ["b", "c", "d"]
    a[4..7] # => ["e"]
    a[6..10] # => nil
    a[-3, 3] # => ["c", "d", "e"]
    # special cases 特殊情况
    a[5] # => nil
    a[5, 1] # => []
    a[5..10] # => []

#### []=   元素赋值

    arr[int] = obj → obj
    arr[start, length] = obj → obj}
    arr[range] = obj → obj

Element Assignment—Sets the element at index int, replaces a subarray starting at index start and continuing for length elements, or replaces a subarray specified by range. 
元素赋值--设置下标int处的元素，替换从start下标开始、由length个元素组成的子数组，或者替换由range指定的子数组。
If int is greater than the size of the array, the array grows automatically. 
如果int大于数组当前容积，那么数组自动增长。
A negative int counts backward from the end of the array. 
负数int将中数组的末尾开始计数。
Inserts elements if length is zero. 
如果length为0则插入元素。
If obj is an array, the form with the single index inserts that array into arr, and the forms with a length or with a range replace the given elements in arr with the array contents. 
如果obj是个数组，只有一个下标的赋值形式将插入数组到arr中，而带长度参数的形式或以range为参数的形式将用数组内容替换arr中的给定元素。
An IndexError is raised if a negative index points past the beginning of the array. 
如果负数下标超过了数组的开头，则引发IndexError。
(Prior to Ruby 1.9, assigning nil with the second and third forms of element assignment deleted the corresponding array elements; it now assigns nil to them.)
（在Ruby 1.9之前，用第二种或第三种形式将元素赋值为nil，将删除对应的数组元素；现在这样会将nil赋值给它们）
See also Array#push and Array#unshift.
参见Array#push和Array#unshift。

    a = Array.new                    # => []
    a[4] = "4";                    a # => [nil, nil, nil, nil, "4"]
    a[0] = [ 1, 2, 3 ];            a # => [[1, 2, 3], nil, nil, nil, "4"]
    a[0, 3] = [ 'a', 'b', 'c' ];   a # => ["a", "b", "c", nil, "4"]
    a[1..2] = [ 1, 2 ];            a # => ["a", 1, 2, nil, "4"]
    a[0, 2] = "?";                 a # => ["?", 2, nil, "4"]  
    # <kinder:note> 注意：上面这个等于删除了一个元素。
    a[0..2] = "A", "B", "C";       a # => ["A", "B", "C", "4"]
    a[-1] = "Z";                   a # => ["A", "B", "C", "Z"]
    a[1..-1] = nil;                a # => ["A", nil]
    # <kinder:note> 注意：这里1..-1的方向没有变化，不用担心[0]会被设置

#### |    合并

    arr | other_array → an_array

Set Union—Returns a new array by joining this array with other_array, removing duplicates.
联合--返回由本数组和`other_array`联合而成的一个新数组，并去除重复的元素。
The rules for comparing elements are the same as for hash keys. 
元素比较的规则和hash键比较的规则相同。
If you need setlike behavior, see the library class Set on page 804.
如果需要类似于集合的并集操作，参见后面2版731页4版804页的Set类。

    [ "a", "b", "c" ] | [ "c", "d", "a" ] # => ["a", "b", "c", "d"]

#### assoc    关联搜索

    arr.assoc( obj ) → an_array or nil

Searches through an array whose elements are also arrays comparing obj with the first element of each contained array using obj.==. 
通过使用obj.==对obj和子数组的第一个元素进行比较，在数组中搜索子数组元素。
Returns the first contained array that matches (that is, the first associated array) or nil if no match is found. 
返回匹配的一个子数组（也就是第一个associated的数组），如果没有匹配则返回nil。
See also Array#rassoc.
参见Array#rassoc。

    s1 = [ "colors", "red", "blue", "green" ]
    s2 = [ "letters", "a", "b", "c" ]
    s3 = "foo"
    a = [ s1, s2, s3 ]
    a.assoc("letters") # => ["letters", "a", "b", "c"]
    a.assoc("foo") # => nil

<kinder:note> 元素的开头匹配。非常实用！

#### at   引用元素

    arr.at( int ) → obj or nil

Returns the element at index int. 
返回int下标处的元素。
A negative index counts from the end of arr. 
如果下标是负数，则从arr末尾开始计算。
Returns nil if the index is out of range. 
如果下标超出了范围则返回nil。
See also Array#[].
参见 Array#[]
<kinder:note> 2版补充：Array#at比Array#[]稍微快点，因为不接受range参数等等。

    a = [ "a", "b", "c", "d", "e" ]
    a.at(0) # => "a"
    a.at(-1) # => "e"

#### bsearch    二分搜索  ⇡New in 2.0⇣

    arr.bsearch { |val| … } → obj or nil

Assuming arr is sorted in ascending order, performs a binary search in O(log n) time. 
假设arr是按升序排列的数组，在对数时间内执行一个二分搜索。（<kinder:note> 就是折半搜索）
The method operates in two modes depending on the values returned by the block:
根据block的返回值，方法在两个模式操作。

To find the minimum value in arr greater than or equal to the required value, have the block return false if its argument is less than that value, true otherwise.
要在arr找到大于或等于指定值的最小元素，如果它的参数小于该值则block返回false，否则返回true。

    arr = %w{ ant bee cat dog elk fox gnu }
    arr.bsearch {|val| val >= "c" }   # => "cat"
    arr.bsearch {|val| val >= "cod" } # => "dog"
    arr.bsearch {|val| val >= "kea" } # => nil

To find a value in the array that lies between two limits, write the block to return a positive number if the argument is less than the lower bound, a negative number if it is greater than the upper bound, or zero if it is inclusively between the bounds.
要在数组里找到一个位于两个极限的值，写一个block，如果参数少于下限返回正数，如果它大于上限一个负数，或者如果它包含在两极之间返回0。

    arr = [ 1, 1, 2, 3, 5, 8, 13, 21, 34 ]
    res = arr.bsearch do |val|
      case
      when val < 19 then +1
      when val > 23 then -1
      else 0
      end
    end
    res # => 21

#### combination  元素混合  1.9

    arr.combination( size ) → enumerator
    arr.combination( size ) { |array| … } → arr

Constructs all combinations of the elements of arr of length size. 
以size长度为单位构建arr数组所有的元素混合。
If called with a block, passes each combination to that block; otherwise, returns an enumerator object. 
如果调用了block，将传递每个混合到该block中；否则返回一个enumrator对象。
An empty result is generated if no combinations of the given length exist. 
如果没有指定的混合长度存在，返回一个空的数组。
See also Array#permutation.
参见Array#permutation。

    a = [ "a", "b", "c" ]
    a.combination(1).to_a # => [["a"], ["b"], ["c"]]
    a.combination(2).to_a # => [["a", "b"], ["a", "c"], ["b", "c"]]
    a.combination(3).to_a # => [["a", "b", "c"]]
    a.combination(4).to_a # => []

#### clear  删除所有元素 <kinder:note> 在4版中没有，但ruby2还是有这个方法的，现根据2版补上。

    arr.clear -> arr

删除arr的所有元素。

    a = ["a", "b", "c", "d", "e"]
    a.clear  #=> []

#### collect!    遍历收集

    arr.collect! { |obj| … } → arr

Invokes block once for each element of arr, replacing the element with the value returned by block. 
对arr的每个元素调用block，并用block的返回值替换原元素。
See also Enumerable#collect.
参见Enumerable#collect。

    a = [ "a", "b", "c", "d" ]
    a.collect! {|x| x + "!" } # => ["a!", "b!", "c!", "d!"]
    a # => ["a!", "b!", "c!", "d!"]

#### compact    紧凑

    arr.compact → an_array

Returns a copy of arr with all nil elements removed.
返回一个arr的拷贝，并删除其中的nil元素。

    [ "a", nil, "b", nil, "c", nil ].compact # => ["a", "b", "c"]

#### compact!    紧凑

    arr.compact! → arr or nil

Removes nil elements from arr. Returns nil if no changes were made.
删除arr中的所有nil元素。如果没有改变则返回nil。

    [ "a", nil, "b", nil, "c" ].compact! # => ["a", "b", "c"]
    [ "a", "b", "c" ].compact!  # => nil

#### concat    附加连接

    arr.concat( other_array ) → arr

Appends the elements in other_array to arr.
将other_arry附加到arr之后。

    [ "a", "b" ].concat( ["c", "d"] ) # => ["a", "b", "c", "d"]

#### count  计数  1.9

    arr.count( obj ) → int
    arr.count { |obj| … } → int

Returns the count of objects in arr that equal obj or for which the block returns a true value.
返回arr数组中等于obj或者对block中返回真值的对象的数量，。
Shadows the corresponding method in Enumerable.

    [1, 2, 3, 4].count(3) # => 1
    [1, 2, 3, 4].count {|obj| obj > 2 } # => 2

#### cycle  重复  1.9

    arr.cycle { |obj| … } → nil or enumerator
    arr.cycle( times ) { |obj| … } → nil or enumerator

Returns nil if arr has no elements; otherwise, passes the elements, one at a time to the block.
如果arr没有元素则返回nil；否则一次传递一个元素给block。
When it reaches the end, it repeats. 
到达结尾时，重复传递。
The number of times it repeats is set by the parameter.
重复的次数通过参数来设置。
If the parameter is missing, cycles forever. 
如果没有参数，永远重复。
Returns an Enumerator object if no block is given.
如果没有指定block，返回一个Enumerator对象。

    [1,2,3].cycle(3)      # => #<Enumerator: [1, 2, 3]:cycle(3)>
    [1,2,3].cycle(3).to_a # => [1, 2, 3, 1, 2, 3, 1, 2, 3]
    columns = [ 1, 2, 3 ]
    data = %w{ a b c d e f g h }
    columns.cycle do |column_number|
      print column_number, ":", data.shift, "\t"
      puts if column_number == columns.last   # 用于换行
      break if data.empty?
    end
    # produces:
    # 1:a 2:b 3:c
    # 1:d 2:e 3:f
    # 1:g 2:h

#### delete   删除

    arr.delete( obj ) → obj or nil
    arr.delete( obj ) { … } → obj or nil

Deletes items from arr that are equal to obj. 
删除arr中与obj相等的元素。
If the item is not found, returns nil. 
如果没有找到这样的元素，返回nil。
If the optional code block is given, returns the result of block if the item is not found.
如果有关联的block，且没有找到相应的元素，则返回block的结果

    a = [ "a", "b", "b", "b", "c" ]
    a.delete("b")                 # => "b"
    a                             # => ["a", "c"]
    a.delete("z")                 # => nil
    a.delete("z") { "not found" } # => "not found"

#### delete_at    下标删除

    arr.delete_at( index ) → obj or nil

Deletes the element at the specified index, returning that element or nil if the index is out of range. 
删除指定下标处的元素，并返回该元素，如果下标超出了数组的下标范围，则返回nil。
See also Array#slice!.
参见Array#slice!。

    a = %w( ant bat cat dog )
    a.delete_at(2)  # => "cat"
    a               # => ["ant", "bat", "dog"]
    a.delete_at(99) # => nil

#### delete_if   条件删除

    arr.delete_if { |item| … } → arr

Deletes every element of arr for which block evaluates to true.
删除数组arr中那些能使block返回true的元素。

    a = [ "a", "b", "c" ]
    a.delete_if {|x| x >= "b" } # => ["a"]

#### each   遍历元素

    arr.each { |item| … } → arr 

Calls block once for each element in arr, passing that element as a parameter.
对arr数组中的每个元素调用block，并以该元素做block的参数。

    a = [ "a", "b", "c" ]
    a.each {|x| print x, " -- " }
    # produces: 
    # a -- b -- c --

#### each_index   遍历下标

    arr.each_index { |index| … } → arr

Same as Array#each but passes the index of the element instead of the element itself.
除了传递的是元素的下标而不是元素本身之外，其他和Array#each相同。

    a = [ "a", "b", "c" ]
    a.each_index {|x| print x, " -- " }
    # produces: 0 -- 1 -- 2 --

#### empty?   为空

    arr.empty? → true or false

Returns true if arr array contains no elements.
如果arr数组没有元素，返回true

    [].empty?  # => true
    [ 1, 2, 3 ].empty? # => false

#### eql?  相等

    arr.eql?( other ) → true or false

Returns true if arr and other are the same object or if other is an object of class Array with the same length and content as arr. 
如果arr和other是同一个对象，或者other是一个和arr长度相同且内容相同的数组类对象，返回true。
Elements in the arrays are compared using Object#eql?. 
数组中的元素使用Object#eql?进行比较。
See also Array#<=>.
参见Array#<=>。

    [ "a", "b", "c" ].eql?(["a", "b", "c"]) # => true
    [ "a", "b", "c" ].eql?(["a", "b"]) # => false
    [ "a", "b", "c" ].eql?(["b", "c", "d"]) # => false

#### fetch  取出 1.8

    arr.fetch( index ) → obj
    arr.fetch( index, default ) → obj
    arr.fetch( index ) { |i| … } → obj

Tries to return the element at position index. 
返回下标index处的元素。
If the index lies outside the array, the first form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking the block, passing in the index. 
如果index超出了数组的范围，那么第一种形式会引发一个IndexError异常，第二种形式返回default，第三种形式返回以index下标为参数调用block的结果。
Negative values of index count from the end of the array.
负数下标从数组的末尾开始计算。

    a = [ 11, 22, 33, 44 ]
    a.fetch(1)            # => 22
    a.fetch(-1)           # => 44
    a.fetch(-1, 'cat')    # => 44
    a.fetch(4, 'cat')     # => "cat"
    a.fetch(4) {|i| i*i } # => 16 

#### fill  填充 1.8

    arr.fill( obj ) → arr
    arr.fill( obj, start ‹ , length › ) → arr
    arr.fill( obj, range ) → arr
    arr.fill { |i| … } → arr
    arr.fill( start ‹ , length › ) { |i| … } → arr
    arr.fill( range ) { |i| … } → arr

The first three forms set the selected elements of arr (which may be the entire array) to obj.
前三种形式将arr中指定的元素（可以是整个数组）设置为obj。
A start of nil is equivalent to zero. 
start为nil，等同于0。
A length of nil is equivalent to arr.length. 
长度为nil，等同于arr.length。

The last three forms fill the array with the value of the block. 
后三种形式使用block的值填充数组。
The block is passed the absolute index of each element to be filled.
传递给block的参数是被填充元素下标的绝对值。

    a = [ "a", "b", "c", "d" ]
    a.fill("x")            # => ["x", "x", "x", "x"]
    a.fill("z", 2, 2)      # => ["x", "x", "z", "z"]
    a.fill("y", 0..1)      # => ["y", "y", "z", "z"]
    a.fill {|i| i*i}       # => [0, 1, 4, 9]
    a.fill(-3) {|i| i+100} # => [0, 101, 102, 103]

#### find_index  查找序号 1.9

    arr.find_index( obj ) → int or nil
    arr.find_index { |item| … } → int or nil
    arr.find_index → enumerator

Returns the index of the first object in arr that is == to obj or for which the block returns a true value. 
返回arr数组==obj或者block返回true值的第一个对象的下标。
Returns nil if no match is found. 
如果没有匹配则返回nil。
See also Enumerable#select and Array#rindex.
参见Enumerable#select和Array#rindex。

    a = [ "a", "b", "c", "b" ]
    a.find_index("b")                # => 1
    a.find_index("z")                # => nil
    a.find_index {|item| item > "a"} # => 1

#### first  开头 1.8    4版这个方法被定义在Enumerable中。

    arr.first => obj或nil
    arr.first(count) => an_array

返回数组的第一个元素，或前count个元素。
如果数组为空，第一种形式返回nil，第二种形式返回一个空数组。

    a = ["q", "r", "s", "t"]
    a.first  #=> "q"
    a.fisrt(1)  #=> ["q"]
    a.fisrt(3)  #=> ["q", "r", "s"]

#### flatten   变平

    arr.flatten( level = -1 ) → an_array

Returns a new array that is a flattening of this array (recursively). 
递归地将数组扁平化，返回一个新数组，
That is, for every element that is an array, extracts its elements into the new array. 
就是，对于每个元素都是数组的数组，将其中子数组的元素解压出来放在新的数组中。
The level parameter controls how deeply the flattening occurs. 
level参数控制扁平化的深度。
If less than zero, all subarrays are expanded. 
如果小于0,所有的子数组都被扩展。
If zero, no flattening takes place. 
如果为0, 不进行扁平化。
If greater than zero, only that depth of subarray is expanded.
如果大于0, 只有该深度的子数组被扩展。

    s = [ 1, 2, 3 ] # => [1, 2, 3]
    t = [ 4, 5, 6, [7, 8] ] # => [4, 5, 6, [7, 8]]
    a = [ s, t, 9, 10 ]     # => [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
    a.flatten(0)            # => [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
    a.flatten               # => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    a.flatten(1)            # => [1, 2, 3, 4, 5, 6, [7, 8], 9, 10]
    a.flatten(2)            # => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

#### flatten!   变平

    arr.flatten!( level = -1 ) → arr or nil 

Same as Array#flatten but modifies the receiver in place. 
修改接收者，其他和Array#flatten一样。
Returns nil if no modifications were made (i.e., arr contains no subarrays).
如果没有发生修改则返回nil（比如，arr没有包含子数组）。

    a = [ 1, 2, [3, [4, 5] ] ]
    a.flatten! # => [1, 2, 3, 4, 5]
    a.flatten! # => nil
    a          # => [1, 2, 3, 4, 5]

#### frozen?  冻结 1.9

    arr.frozen? → true or false

Returns true if arr is frozen or if it is in the middle of being sorted.
如果arr是冻结的，或如果在被sorted的中间，返回true。
<kinder:note> 怎么理解？

#### include?  包含 1.8   4版没有出现

    arr.include?(obj) => true 或 false

如果所给对象出现在数组中（也就是说数组的任何对象==obj），则返回true，否则返回false。

    a = ["a", "b", "c"=]
    a.include?("b")  #=>true
    a.include?("z")  #=>false

####  index  序号

    arr.index( obj ) → int or nil
    arr.index { |item| … } → int or nil


Synonym for Array#find_index.
和Array#find_index同义。

Table 14—Template characters for Array.pack
Directive Meaning
指示      含义
@         Move to absolute position
A         Sequence of bytes (space padded, count is width)
a         Sequence of bytes (null padded, count is width)
B         Bit string (most significant first)
b         Bit string (least significant first)
C         Unsigned byte
c         Byte
D, d      Double-precision float, native format
E         Double-precision float, little-endian byte order
e         Single-precision float, little-endian byte order
F, f      Single-precision float, native format
G         Double-precision float, network (big-endian) byte order
g         Single-precision float, network (big-endian) byte order
H         Hex string (high nibble first)
h         Hex string (low nibble first)
I         Unsigned integer
i         Integer
L         Unsigned long
l         Long
M         Quoted printable, MIME encoding (see RFC2045)
m         Base64-encoded string; by default adds linefeeds every 60 characters; "m0" suppresses linefeeds
N         Long, network (big-endian) byte order
n         Short, network (big-endian) byte order
P         Pointer to a structure (fixed-length string)
p         Pointer to a null-terminated string
Q, q      64-bit number
S         Unsigned short
s         Short
U         UTF-8
u         UU-encoded string
V         Long, little-endian byte order
v         Short, little-endian byte order
w         BER-compressed integer°
X         Back up a byte
x         Null byte
Z         Same as “a,” except a null byte is appended if the * modifier is given
          ° The octets of a BER-compressed integer represent an unsigned integer in base 128,
          most significant digit first, with as few digits as possible. Bit eight (the high bit) is set
          on each byte except the last (Self-Describing Binary Data Representation, MacLeod).

#### insert  插入 1.8

    arr.insert( index, ‹ obj ›+} ) → arr

If index is not negative, inserts the given values before the element with the given index. 
如果index是非负数，插入指定值在指定下标的元素之前。
If index is negative, adds the values after the element with the given index (counting from the end).
如果index是负数，将给定的值插入到给定下标所对应的元素的后面（跟在尾部）。

    a = %w{ a b c d }
    a.insert(2, 99)       # => ["a", "b", 99, "c", "d"]
                                               - 这里2；
    a.insert(-2, 1, 2, 3) # => ["a", "b", 99, "c", 1, 2, 3, "d"]
                                               - 这里是-2
    a.insert(-1, "e")     # => ["a", "b", 99, "c", 1, 2, 3, "d", "e"]
                                                             - 这里是-1      

#### join   连接

    arr.join( separator=$, ) → str

Returns a string created by converting each element of the array to a string and concatenating them, separated each by separator.
将数组中的每个元素连接成一个字符串，使用分隔符来分隔每个元素，并返回该字符。

    [ "a", "b", "c" ].join # => "abc"
    [ "a", "b", "c" ].join("-") # => "a-b-c"

#### keep_if  留住 1.9

    arr.keep_if { |obj| … } → array or enumerator

Modifies arr by removing all elements for which block is false 
通过删除所有在block中为false的元素来修改arr。
(see also Enumerable#select and Array.select!). 
(另见Enumerable#select和Array.select!)
Returns an Enumerator object if no block is given.
如果没有指定block，返回一个Enumerator对象。

    a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    a.keep_if {|element| element < 6 } # => [1, 2, 3, 4, 5]
    a                                  # => [1, 2, 3, 4, 5]
    a.keep_if(&:odd?)                  # => [1, 3, 5]  注意这个写法！
    a                                  # => [1, 3, 5]

#### last  最后 1.8

    arr.last → obj or nil
    arr.last( count ) → an_array

Returns the last element, or last count elements, of arr. 
返回数组arr的最后一个元素，或最后count个元素。
If the array is empty, the first form returns nil, and the second returns an empty array. 
如果数组为空，第一种形式返回nil，第二种形式返回一个空数组。
(first is defined by Enumerable.)
(firse被定义在Enumerable)

    [ "w", "x", "y", "z" ].last # => "z"
    [ "w", "x", "y", "z" ].last(1) # => ["z"]
    [ "w", "x", "y", "z" ].last(3) # => ["x", "y", "z"]

#### length   长度

    arr.length → int

Returns the number of elements in arr.
返回arr中元素的个数。

    [ 1, nil, 3, nil, 5 ].length # => 5

#### map!  映射

arr.map! { |obj| … } → arr

Synonym for Array#collect!.
同Array#collect!

#### pack   打包 1.8

    arr.pack ( template ) → binary_string

Packs the contents of arr into a binary sequence according to the directives in template (see Table 14, Template characters for Array.pack, on page 430). 
根据模板template中的指定将arr的内容打包成二进制字节序列（参见上面表27.1）。
Directives A, a, and Z may be followed by a count, which gives the width of the resulting field. 
指令A，a和Z后可跟一个计数符，该计数符说明了生成字段的宽度。
The remaining directives also may take a count, indicating the number of array elements to convert. 
其余的指令也可以后跟一个计数符以表明被转换的数组元素的个数。
If the count is an asterisk (*), all remaining array elements will be converted. 
如果计数符是星号(*)，则剩余的所有数组元素都被转换。
The directives s S i I l L may be followed by an underscore (_) or bang (!) to use the underlying platform’s native size for the specified type; otherwise, they use a platform-independent size. 
指令“sSiIlL”中的任何一个都可后跟一个下划线（_）或感叹号（!）以使用底层平台的本地大小来表示指定类型；否则使用平台无关的大小。
The directives s S i I l L q Q may be followed by a less than sign to signify little endian or greater than sign for big endian. 
指令“sSiIlLqQ”可后跟一个小于号表示小端，后跟一个大于号来表示大端。
Spaces are ignored in the template string. 
模板字符串中的空格将被忽略。
Comments starting with # to the next newline or end of string are also ignored. 
以#开头到下一个新行或字符串结尾的注视也被忽略。
See also String#unpack on page 690.
另见后面2版623页4版690页的String#unpack。

    a = [ "a", "b", "c" ]
    n = [ 65, 66, 67 ]
    a.pack("A3A3A3") # => "a␣␣b␣␣c␣␣"
    a.pack("a3a3a3") # => "a\0\0b\0\0c\0\0"
    n.pack("ccc") # => "ABC"

<kinder:note> 不懂。这个pack感觉让人匪夷所思。

#### permutation    置换 1.9

    arr.permutation( size=arr.size ) → enumerator
    arr.permutation( size=arr.size ) { |array| … } → arr}

Constructs all permutations of the elements of arr of length size. 
对arr的size长度的元素构建所有置换。
If called with a block, passes each permutation to that block; otherwise, returns an enumerator object. 
如果调用一个block，传递每个置换到那个block；否则返回一个enumrator对象。
An empty result is generated if no permutations of the given length exist. 
如果没有给定长度的置换存在，将产生一个空的数组。
See also Array#combination.
另见Array#combination。

    words = {}
    File.readlines("/usr/share/dict/words").map(&:chomp).each do |word|
      words[word.downcase] = 1    # 切记words是个hash。
    end
    %w{ c a m e l }.permutation do |letters|
      anagram = letters.join
      puts anagram if words[anagram]   # 如果anagram在words中找到，则puts出来
    end
    # produces:
    # camel
    # clame
    # cleam
    # macle

#### pop  弹出

    arr.pop( ‹ n ›* ) → obj or nil

Removes the last element (or the last n elements) from arr. Returns whatever is removed or nil if the array is empty.
删除arr中的最后一个元素。返回该被删除的元素；如果数组为空，则返回nil。

    a = %w{ f r a b j o u s }
    a.pop     # => "s"
    a         # => ["f", "r", "a", "b", "j", "o", "u"]
    a.pop(3)  # => ["j", "o", "u"]
    a         # => ["f", "r", "a", "b"]

#### product  乘积 1.9

    arr.product( ‹ arrays ›* ) → result_array
    arr.product( ‹ arrays ›* ) ‹ { |combination| … } › → arr

Generates all combinations of selecting an element each from arr and from any arrays passed as arguments. 
从arr或者其他传做参数的数组中产生所有被选元素的联合。
The number of elements in the result is the product of the lengths of arr and the lengths of the arguments (so if any of these arrays is empty, the result will be an empty array). 
结果中元素的值是arr的长度和参数的长度的乘积（因此如果这些数组有哪个是空的，结果将会是空数组）。
Each element in the result is an array containing n+1 elements, where n is the number of arguments. 
结果中的每个元素都是一个数组，包含n+1个元素，n是参数的数目。
If a block is present, it will be passed each combination, and arr will be returned.
如果存在block，每个联合都将被传递，并返回arr。

    suits = %w{ C D H S }
    ranks = [ *2..10, *%w{ J Q K A } ]    # => [2, 3, 4, 5, 6, 7, 8, 9, 10, "J", "Q", "K", "A"]  
    card_deck = suits.product(ranks).shuffle  
    card_deck.first(13) # => [["S", 8], ["D", "K"], ["C", 9], ["S", "A"], ["H", "K"],
                        # .. ["S", 4], ["S", 7], ["D", 2], ["H", 6], ["S", "Q"],
                        # .. ["D", 3], ["D", 4], ["H", 10]]

#### push  压入

    arr.push( ‹ obj ›* ) → arr

Appends the given argument(s) to arr.
将给定（多个或一个）参数添加到数组中。

    a = [ "a", "b", "c" ]
    a.push("d", "e", "f") # => ["a", "b", "c", "d", "e", "f"]

#### rassoc 搜索关联

    arr.rassoc( key ) → an_array or nil

Searches through the array whose elements are also arrays. 
在数组中搜索本身是数组的元素。
Compares key with the second element of each contained array using ==. 
使用==比较key和数组元素的第二个元素。
Returns the first contained array that matches.
返回第一个匹配该key的数组元素。
See also Array#assoc.
另见Array#assoc。

    a = [ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ]
    a.rassoc("two") # => [2, "two"]
    a.rassoc("four") # => nil

#### reject!    否决元素（条件删除）

    arr.reject! { |item| … } → arr or nil

Equivalent to Array#delete_if but returns nil if arr is unchanged. 
等价于Array#delete_if，但如果没有任何改变则返回nil。
Also see Enumerable#reject.
参见Array#assoc。

#### repeated_combination  重复的混合  1.9

    arr.repeated_combination( length ) { |comb| … } → arr
    arr.repeated_combination( length ) → enum

Creates the set of combinations of length length of the elements of arr. 
为arr的元素创建一组长度为length的混合，
If length is greater than arr.size, elements will be allowed to repeat. 
如果length大于arr的长度，元素将允许重复。
Passes each combination to the block, or returns an enumerator if no block is given.
将每个混合传给block，或在没有指定block时返回一个enumerator。

    a = [1, 2, 3]
    a.repeated_combination(2).to_a # => [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3,
                                   # .. 3]]
    a.repeated_combination(3).to_a # => [[1, 1, 1], [1, 1, 2], [1, 1, 3], [1, 2, 2],
                                   # .. [1, 2, 3], [1, 3, 3], [2, 2, 2], [2, 2, 3],
                                   # .. [2, 3, 3], [3, 3, 3]]

#### repeated_permutation   重复调换  1.9

    arr.repeated_permutation( length ) { |comb| … } → arr
    arr.repeated_permutation( length ) → enum

Creates the set of permutations of length length of the elements of arr. 
为arr的元素创建一组长度为length的置换。
If length is greater than arr.size elements will be allowed to repeat. 
如果length大于arr的长度，元素将允许重复。
Passes each permutation to the block, or returns an enumerator if no block given.
将每个混合传给block，或在没有指定block时返回一个enumerator。

    a = [:a, :b]
    a.repeated_permutation(2).to_a # => [[:a, :a], [:a, :b], [:b, :a], [:b, :b]]
    a.repeated_permutation(3).to_a # => [[:a, :a, :a], [:a, :a, :b], [:a, :b, :a],
                                   # .. [:a, :b, :b], [:b, :a, :a], [:b, :a, :b],
                                   # .. [:b, :b, :a], [:b, :b, :b]]

#### replace  替换

    arr.replace( other_array ) → arr

Replaces the contents of arr with the contents of other_array, truncating or expanding arr if necessary.
使用other_array的内容替换arr的内容，并根据需要进行截断或者扩展。

    a = [ "a", "b", "c", "d", "e" ]
    a.replace([ "x", "y", "z" ]) # => ["x", "y", "z"]
    a                            # => ["x", "y", "z"]

#### reverse  逆序

    arr.reverse → an_array

Returns a new array using arr’s elements in reverse order.
颠倒arr的元素，并返回该新元素。

    [ "a", "b", "c" ].reverse # => ["c", "b", "a"]
    [ 1 ].reverse             # => [1]

#### reverse!   逆序  1.8

    arr.reverse! → arr

Reverses arr in place.
颠倒并替换arr。

    a = [ "a", "b", "c" ]
    a.reverse!     # => ["c", "b", "a"]
    a              # => ["c", "b", "a"]
    [ 1 ].reverse! # => [1]

#### reverse_each    逆序遍历

    arr.reverse_each ‹ { |item| … } ›} } → arr

Same as Array#each but traverses arr in reverse order.
和Array#each一样，但按逆序遍历arr。

    a = [ "a", "b", "c" ]
    a.reverse_each {|x| print x, " " }
    # produces:
    # c b a

#### rindex  最后符合条件序号

    arr.rindex( obj ) → int or nil
    arr.rindex { |item| … } → int or nil

Returns the index of the last object in arr that is == to obj or for which the block returns a true value. 
返回数组arr中==obj或让block返回true的最后一个对象。
Returns nil if no match is found. 
如果没有找到匹配则返回nil。
See also Enumerable#select and Array#index.
零件Enumerable#select和Array#index。

    a = [ "a", "b", "e", "b", "d" ]
    a.rindex("b") # => 3
    a.rindex("z") # => nil
    a.rindex {|item| item =~ /[aeiou]/} # => 2

#### rotate  旋转  1.9

    arr.rotate( places=1 ) → new_array

Returns a new array containing the elements of arr rotated places positions
返回一个新的包含arr元素位置旋转之后的元素的数组
 (so that the element that originally was at arr[places] is now at the front of the array.) 
(以便原来位于ar[places]的元素现在放在最前面。)
places may be negative.
places可能是负数。

    a = [1, 2, 3, 4, 5]
    a.rotate(2) # => [3, 4, 5, 1, 2]
    a.rotate(-2) # => [4, 5, 1, 2, 3]

#### rotate!  旋转  1.9

    arr.rotate( places=1 ) → arr

Rotate arr in place.
按place旋转arr。

#### sample  抽样  1.9 

    arr.sample( n=1 ) → an_array or nil

Returns min(n, arr.size) random elements from arr or nil if arr is empty and n is not given.
从arr随机返回特定个数（n和arr长度中较小者）的元素，如果arr是空的或这没有指定n，则返回nil。

    a = [ "a", "b", "c", "d" ]
    a.sample    # => "c"
    a.sample(3) # => ["b", "a", "c"]
    a.sample(6) # => ["b", "d", "a", "c"]
    b = []
    b.sample    # => nil

#### select!   挑选  1.9

    arr.select! { |obj| … } → array, nil, or enumerator

Modifies arr by removing all elements for which block is false 
通过移除所有让block返回false的元素来修改arr。
(see also Enumerable#select and Array#keep_if). 
（另见Enumerable#select和Array#keep_if）。
Returns nil if no changes were made, returns an Enumerator object if no block is given, or returns arr.
如果没有更改则返回nil，如果没有指定block则返回一个Enumerator对象，或返回arr。

    a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    a.select! {|element| element < 6 } # =>  [1, 2, 3, 4, 5] 
    a                                  # =>  [1, 2, 3, 4, 5]
    a.select! {|element| element < 8 } # =>  nil
    a                                  # =>  [1, 2, 3, 4, 5]

#### shift  移除首元素

    arr.shift( n = 1 ) → obj or nil

Returns the first n elements (or the first element with no argument) of arr and removes it (shifting all other elements down by one). 
返回arr的前n个元素，并将它们从数组中删除（其他所有元素左移）。
Returns nil if the array is empty.
如果数组为空则返回nil。

    args = [ "-m", "-q", "-v", "filename" ]
    args.shift # => "-m"
    args.shift(2) # => ["-q", "-v"]
    args # => ["filename"]

#### shuffle   打乱 ⇡New in 2.0⇣

    arr.shuffle → an_array
    arr.shuffle(random: rng)→ an_array

Returns an array containing the elements of arr in random order. 
返回一个数组，包含arr数组的元素，但元素打乱了顺序。
You can pass it a random number generator using the random: keyword parameter. 
你可以使用random:关键字参数传给它一个随机产生器。
Passing rngs with the same seed makes the shuffle deterministic.
带同样的种子传入rngs会让随机变得更确定。

    [ 1, 2, 3, 4, 5 ].shuffle                          # => [4, 5, 2, 1, 3]
    [ 1, 2, 3, 4, 5 ].shuffle                          # => [5, 2, 1, 4, 3]
    [ 1, 2, 3, 4, 5 ].shuffle(random: Random.new(123)) # => [2, 4, 5, 1, 3]
    [ 1, 2, 3, 4, 5 ].shuffle(random: Random.new(123)) # => [2, 4, 5, 1, 3]

#### shuffle!  打乱 2.0

    arr.shuffle! → an_array
    arr.shuffle!(random: rng)→ an_array

Randomizes the order of the elements of arr in place.
随机打乱arr里的元素。

#### size  长度

    arr.size → int

Synonym for Array#length.
和Array#length同义。

#### slice   片段

    arr.slice( int ) → obj
    arr.slice( start, length ) → an_array
    arr.slice( range ) → an_array

Synonym for Array#[ ].
和Array#[]。

    a = [ "a", "b", "c", "d", "e" ]
    a.slice(2) + a.slice(0) + a.slice(1) # => "cab"
    a.slice(6)                           # => nil
    a.slice(1, 2)                        # => ["b", "c"]
    a.slice(1..3)                        # => ["b", "c", "d"]
    a.slice(4..7)                        # => ["e"]
    a.slice(6..10)                       # => nil
    a.slice(-3, 3)                       # => ["c", "d", "e"]
    # special cases
    a.slice(5) # => nil
    a.slice(5, 1) # => []
    a.slice(5..10) # => []

#### slice!   切片

    arr.slice!( int ) → obj or nil
    arr.slice!( start, length ) → an_array or nil
    arr.slice!( range ) → an_array or nil

Deletes the element(s) given by an index (optionally with a length) or by a range. 
删除给定索引（可后跟一个可选的长度参数）处或给定range的元素。
Returns the deleted object, subarray, or nil if the index is out of range.
返回被删除的对象、字数组，如果下标超出数组返回，则返回nil。

    a = [ "a", "b", "c" ]
    a.slice!(1)   # => "b"
    a             # => ["a", "c"]
    a.slice!(-1)  # => "c"
    a             # => ["a"]
    a.slice!(100) # => nil
    a             # => ["a"]

#### sort!   排序

    arr.sort! → arr
    arr.sort! { |a,b| … } → arr

Sorts arr in place (see Enumerable#sort). 
对数组arr进行排序（参加Enumerable#sort）。
arr is effectively frozen while a sort is in progress.
arr在排序的过程中被冻结。

    a = [ "d", "a", "e", "c", "b" ]
    a.sort!  # => ["a", "b", "c", "d", "e"]
    a        # => ["a", "b", "c", "d", "e"]

#### sort_by!    按条件排序  1.9

    arr.sort_by! { |a| … } → arr
    arr.sort_by! → enum

Sorts arr in place (see Enumerable#sort_by). 
对数组arr进行排序（参加Enumerable#sort_by）。
arr is effectively frozen while a sort is in progress.
arr在排序的过程中被冻结。

    a = [ 5, 2, 7, 4, 8, 9 ]
    # Sort even numbers before odd, and then by rank
    # 将偶数放在奇数前面，然后排序
    a.sort_by! {|e| [ e & 1, e ] } # => [2, 4, 8, 5, 7, 9]
    # <kinder:note> [e & 1, e]是什么意思？
    a # => [2, 4, 8, 5, 7, 9]

#### to_a       转换为数组

    arr.to_a → arr
    array_subclass.to_a → array

If arr is an array, returns arr. 
如果arr是一个数组，返回arr。
If arr is a subclass of Array, invokes to_ary and uses the result to create a new array object.
如果arr是数组的子类，调用to_ary并使用该结果来创建一个新的数组对象。

#### to_ary    转换为数组

    arr.to_ary → arr

Returns arr.
返回arr。

#### to_s      转换为字符串

    arr.to_s → str

Returns a string representation of arr. (In Ruby 1.9, the array as a literal.)
返回一个arr的字符串表示法。（在ruby1.9,数组变成一个字面）

    [ 1, 3, 5, 7, 9 ].to_s # => "[1, 3, 5, 7, 9]"

#### transpose    转阵 1.8

    arr.transpose → an_array

Assumes that arr is an array of arrays and transposes the rows and columns.
假设arr是一个由数组组成的数组，并调换其行和列。

    a = [[1,2], [3,4], [5,6]]
    a.transpose # => [[1, 3, 5], [2, 4, 6]]

#### uniq   唯一

    arr.uniq ‹ { |element| … } › → an_array

Returns a new array by removing duplicate values in arr, where duplicates are detected by comparing using eql? and hash. 
删除arr中的重复元素，并返回结果数组，重复元素是通过使用eql?和hash比较检测出来的。
If the block is present, the comparisons are made based on the values returned by that block for each element in the array.
如果存在block，对比将基于数组中每个元素在block返回的值。

    a = %w{ C a a b b A c a }
    a.uniq # => ["C", "a", "b", "A", "c"]
    a.uniq {|element| element.downcase } # => ["C", "a", "b"]
    a.uniq(&:upcase) # => ["C", "a", "b"]

#### uniq!  唯一

    arr.uniq! ‹ { |element| … } › → arr or nil

Same as Array#uniq but modifies the receiver in place. 
和Array#uniq相同，但直接修改数组。
Returns nil if no changes are made (that is, no duplicates are found).
如果没有改变（就是说没有重复元素）则返回nil。

    a = [ "a", "a", "b", "b", "c" ]
    a.uniq!  # => ["a", "b", "c"]
    b = [ "a", "b", "c" ]
    b.uniq!  # => nil

#### unshift   前置

    arr.unshift( ‹ obj ›+} ) → arr

Prepends object(s) to arr.
将对象添加到arr的首部。

    a = [ "b", "c", "d" ]
    a.unshift("a") # => ["a", "b", "c", "d"]
    a.unshift(1, 2) # => [1, 2, "a", "b", "c", "d"]

#### values_at    选取元素 ⇡New in 2.0⇣   但1.8都有了。

    arr.values_at( ‹ selector ›* ) → an_array

Returns an array containing the elements in arr corresponding to the given selector(s). 
返回一个用给定选择符号从arr中选取的元素所组成的数组。
The selectors may be either integer indices or ranges. 
选择符可以是整数下标，或是范围。
Returns nil for selectors beyond the bounds of the array.
选择符号一旦超过了数组的范围将返回nil。

    a = %w{ a b c d e f }
    a.values_at(1, 3, 5)         # => ["b", "d", "f"]
    a.values_at(1, 3, 5, 7)      # => ["b", "d", "f", nil]
    a.values_at(-1, -3, -5, -7)  # => ["f", "d", "b", nil]
    a.values_at(1..3, 2...5)     # => ["b", "c", "d", "c", "d", "e"]
    a.values_at(5..7, 1..2)      # => ["f", nil, nil, "b", "c"]


## BasicObject  基本对象  1.9
### 概述
BasicObject is the root of Ruby’s class hierarchy. 
BasicObject是ruby的类层级的根部。
It deliberately has just a few methods, allowing it to be conveniently used as the basis for a number of metaprogramming techniques.
它只有很少几个方法，允许它方便地作为一下元编程技术的基本。

If you write code in a direct descendent of BasicObject, you will not have unqualified access to the methods in Kernel, which normally get mixed in to Object. 
如果你直接用BasicObject派生代码，你将不能不完全访问Kernel里的方法，Kernel通常混入Object类。
This example illustrates how to invoke Kernel methods explicitly:
下面的示例掩饰如何显式调用Kernel方法。

    class SimpleBuilder < BasicObject
      def __puts_at_indent__(string)
        ::Kernel.puts " " * @indent + string
      end
      def method_missing(name, *args, &block)
        @indent ||= 0
        __puts_at_indent__("<#{name}>")
        @indent += 2
        __puts_at_indent__(args.join) unless args.empty?
        yield if ::Kernel.block_given?
        @indent -= 2
        __puts_at_indent__("</#{name}>")
      end
    end
    r = SimpleBuilder.new
    r.person do
      r.name "Dave"
      r.address do
        r.street "123 Main"
        r.city "Pleasantville"
    #   end
    end
    # produces:
    # <person>
    #   <name>
    #     Dave
    #   </name>
    #   <address>
    #     <street>
    #         123 Main
    #     </street>
    #     <city>
    #       Pleasantville
    #     </city>
    #   </address>
    # </person>

### Instance Methods  实例方法
#### !  非

    ! obj → true or false

Returns false unless obj is false. 
如果obj不是false，则返回false。
Because it’s in BasicObject, ! is defined for all objects in Ruby.
它在BasicObject定义，适用ruby的所有对象。

#### ==  相等

    obj == other_obj → true or false

Equality—At the BasicObject level, == returns true only if obj and other_obj are the same object.
相等 -- 在BasicObject级别，只有在obj和other_obj是同一个对象时才返回true。
Typically, this method is overridden in descendent classes to provide class-specific meaning.
典型的是，这个方法在下层类别中被改写，以提供类别特定的意思。

#### !=  不等

    obj != other → true or false

Returns the opposite of BasicObject#==.
和BasicObject#==的返回相反

#### __id__  号码

    obj.__id__ → fixnum

Synonym for Object#object_id. 
和Object#object_id同义。
Prior to Ruby 1.9.3, this was an instance method of class Object.
在ruby1.9.3之前，这是Object类的一个实例方法。

#### equal?  相等

    obj.equal?( other_obj ) → true or false

Alias for BasicObject#==.
是BasicOject#==的别名。

#### instance_eval  实例赋值

    obj.instance_eval( string ‹ , file ‹ , line ›› ) → other_obj
    obj.instance_eval { |obj| … } → other_obj}

Evaluates a string containing Ruby source code, or the given block, within the context of the receiver (obj). 
在接收者(obj)的上下文中运算包含ruby源代码的字符串、或指定block。
To set the context, the variable self is set to obj while the code is executing, giving the code access to obj’s instance variables. 
要设置上下文，当代码执行时变量self被设置为obj，让代码访问obj的实例变量。
In the version of `instance_eval` that takes a String, the optional second and third parameters supply a filename and starting line number that are used when reporting compilation errors.
`instance_eval`带有一个字符串时，可选的第二和第三参数提供一个文件名或开始行数，用于报告编译错误。

    class Klass
      def initialize
        @secret = 99
      end
    end
    k = Klass.new
    k.instance_eval { @secret } # => 99

When metaprogramming, `instance_eval` is often used to execute the methods in a block in the context of the caller:
元编程时，`instance_eval`经常被用于在调用者的上下文中执行block里的方法。

    class Recorder < BasicObject
      attr_reader :__calls__
      def method_missing(name, *args, &block)
        @__calls__ ||= []
        @__calls__ << [ name, args ]
      end
      def record(&block)
        instance_eval(&block)
      end
    end
    r = Recorder.new
    r.record do
      disable "safety"
      pull
      "control rod", dir: "out"
      run
    end
    p r.__calls__
    # produces:
    # [# [:disable, ["safety"]], [:pull, ["control rod", {:dir=>"out"}]], [:run, []]]
    <kinder:note> 头大了。得回头复习才行。

#### instance_exec  实例执行

    obj.instance_exec(‹ args ›*) { |args| … } → other_obj

Executes the block with self set to obj, passing args as parameters to the block.
执行block，将self设置为obj，将args传递为block的参数。

    class Dummy < BasicObject
      def initialize
        @iv = 33
      end
      def double_and_call(value, &block)
        instance_exec(value*2, &block)
      end
    end
    d = Dummy.new
    d.double_and_call(22) do |param|
      ::Kernel::puts "Parameter = #{param}"
      ::Kernel::puts "@iv = #{@iv}"
    end
    # produces:
    # Parameter = 44
    # @iv = 33

#### __send__  发送

    obj.__send__( symbol ‹ , args ›*‹ , &block › ) → other_obj

Invokes the method identified by symbol, passing it any arguments and block.
通过符号调用方法识别，并传给它一些参数和block。

    class Klass < BasicObject
      def hello(*args)
        "Hello " + args.join(' ')
      end
    end
    k = Klass.new
    k.__send__ :hello, "gentle", "readers" # => "Hello gentle readers"


### Private Instance Methods  私有实例方法
#### method_missing   方法丢失

    method_missing( symbol ‹ , *args › ) → other_obj

Invoked by Ruby when obj is sent a message it cannot handle. 
当obj收到一个它不能处理的消息时，ruby调用该方法。
symbol is the symbol for the method called, and args are any arguments that were passed to it. 
symbol是方法调用的符号，args是传给它的任何参数。
`method_missing` can be used to implement proxies, delegators, and forwarders. 
`method_missing`可用于实现代理，委托和转发。
It can also be used to simulate the existence of methods in the receiver, as the example at the start of this section shows.
它也可用于模拟接收者里面的方法存在，正如这一节开头所展示的那样。

#### singleton_method_added  单例方法添加

    singleton_method_added( symbol )

Invoked as a callback whenever a singleton method is added to the receiver.
单例方法一被加入到接收者中，本方法就作为回调调用。

    module Chatty
      def Chatty.singleton_method_added(id)
        puts "Adding #{id} to #{self.name}"
      end
      def self.one()
      end
      def two()
      end
    end
    def Chatty.three() end
    # produces:
    # Adding singleton_method_added to Chatty
    # Adding one to Chatty
    # Adding three to Chatty

You can add the hook to any object:
你可以将这个钩子添加到任何对象中。

    obj = "cat"
    def obj.singleton_method_added(id)
      puts "Adding #{id} to #{self}"
    end
    def obj.speak
      puts "meow"
    end
    # produces:
    # Adding singleton_method_added to cat
    # Adding speak to cat

#### singleton_method_removed  单例方法删除

    singleton_method_removed( symbol )

Invoked as a callback whenever a singleton method is removed from the receiver.
单例类方法一被从接收者中删除，本方法就作为回调调用。

    module Chatty
      def Chatty.singleton_method_removed(id)
        puts "Removing #{id}"
      end
      def self.one()
      end
      def two()
      end
      def Chatty.three() end
      class <<self
        remove_method :three
        remove_method :one
      end
    end
    # produces:
    # Removing three
    # Removing one

#### singleton_method_undefined  单例方法撤销

    singleton_method_undefined( symbol )

Invoked as a callback whenever a singleton method is undefined in the receiver.
单例类方法一旦从接收者里面撤销，本方法就作为回调调用。

    module Chatty
      def Chatty.singleton_method_undefined(id)
        puts "Undefining #{id}"
      end
      def Chatty.one()
      end
      class << self
        undef_method(:one)
      end
    end
    # produces:
    # Undefining one


## Bignum  < Integer  大整数
### 概述
Bignum objects hold integers outside the range of Fixnum—Bignum objects are created automatically when integer calculations would otherwise overflow. 
Bignum对象容纳Fixnum范围的整数--当整数计算的结果超出Fixnum的范围时，便会自动创建一个Bignum对象。
When a calculation involving Bignum objects returns a result that will fit in a Fixnum, the result is automatically converted.
当包含Bignum对象的计算结果能被Fixnum表示时，结果会自动转换为Fixnum。

For the purposes of the bitwise operations and [ ], a Bignum is treated as if it were an infinitelength bitstring with 2’s complement representation.
为了实现位操作和[]，Bignum都被当作一个以2的补码表示的无限长度的位串。
While Fixnum values are immediate, Bignum objects are not—assignment and parameter passing work with references to objects, not the objects themselves.
虽然Fixnum值是立即数，但Bignum对象不是--对象的引用可以进行赋值操作或当作参数进行传递，但对象本身不可以这样做。

### Instance Methods 实例方法
#### Arithmetic operations  算术操作
Performs various arithmetic operations on big.
对big执行各种各样的算术操作。

    big  +  number Addition  加
    big  –  number Subtraction  减  
    big  *  number Multiplication  乘
    big  /  number Division 除
    big  %  number Modulo 取模
    big  ** number Exponentiation  指数操作
    big  -@        Unary minus 一元减

#### Bit operations   位操作
Performs various operations on the binary representations of the Bignum.
在Bignum的二进制表示上执行各种位操作。

    ~ big             Invert bits  按位取反
    big   |   number  Bitwise or   位或
    big   &   number  Bitwise and  位与
    big   ^   number  Bitwise exclusive or  位异或
    big   <<  number  Left-shift number bits  左移number位
    big   >>  number  Right-shift number bits (with sign extension)  右移number位（带符号扩展）

#### <=>  大小比较

    big <=> number → -1, 0, +1, or nil

Comparison—Returns -1, 0, or +1 depending on whether big is less than, equal to, or greater than number. 
比较--格局big小于、等于或大于number，分别返回-1,0,+1。
This is the basis for the tests in Comparable.
这是Comparable中测试的基础。

#### ==  同值比较

    big == obj → true or false

Returns true only if obj has the same value as big. 
仅当obj和big有相同的值时才返回true。
Contrast this with Bignum#eql?, which requires obj to be a Bignum.
可以和Bignum#eql?相比较，它需要obj是Bignum。

    68719476736 == 68719476736.0 # => true

#### []  位引用

    big[ n ] → 0, 1

Bit Reference—Returns the n-th bit in the (assumed) binary representation of big, where big[0] is the least significant bit.
位引用--返回big（假设）的二进制表示的第n位，其中big[0]是最低位。

     a = 9**15 # that's 9 raised to the 15th power  9的15次方。
     50.downto(0) do |n|
       print a[n]
     end
     # produces:
     # 000101110110100000111000011110010100111100010111001

#### abs  绝对值

    big.abs → bignum

Returns the absolute value of big.
返回big的绝对数。

    1234567890987654321.abs # => 1234567890987654321
    -1234567890987654321.abs # => 1234567890987654321

#### div  除法  1.8

    big.div( number ) → other_number

Synonym for Bignum#/.
和Bignum#/同义。

    -1234567890987654321.div(13731) # => -89910996357706
    -1234567890987654321.div(13731.0) # => -89910996357706
    -1234567890987654321.div(-987654321) # => 1249999989

#### divmod  取模

    big.divmod( number ) → array

See Numeric#divmod on page 595.
参见后面2版565页4版595页的Numeric#divmod。

#### eql?  同值比较

    big.eql?( obj ) → true or false

Returns true only if obj is a Bignum with the same value as big. 
仅当obj是一个和big有相同值的Bignum时返回true。
Contrast this with Bignum#==, which performs type conversions.
可以和Bignum#==比较，后者会执行类型转换。

     68719476736.eql?  68719476736    # => true
     68719476736 ==    68719476736    # => true
     68719476736.eql?  68719476736.0  # => false
     68719476736 ==    68719476736.0  # => true

#### fdiv  浮点除法

    big.fdiv( number ) → float

Returns the floating-point result of dividing big by number. 
在被number除之后返回一个浮点结果。
Alias for Bignum#quo.
是Bignum#quo的别名。

    -1234567890987654321.fdiv(13731) # => -89910996357705.52
    -1234567890987654321.fdiv(13731.0) # => -89910996357705.52
    -1234567890987654321.fdiv(-987654321) # => 1249999989.609375

#### magnitude  震级（绝对值）

    big.magnitude → bignum

Returns the magnitude of big (the distance of big from the origin of the number line). 
返回big的震级。（big到原始数字行的距离）
Synonym for Bignum#abs. 
和Bignum#abs同义。
See also Complex#magnitude.
另见Complex#magnitude。

#### modulo  取模  1.8

    big.modulo( number ) → number

Synonym for Bignum#%.
和Bignum#%同义。

#### remainder  余数（取模）  1.8

    big.remainder( number ) → other_number

Returns the remainder after dividing big by number.
返回big被number除之后的余数。

    -1234567890987654321.remainder(13731) # => -6966
    -1234567890987654321.remainder(13731.24) # => -9906.22531493148

#### size  长度

    big.size → integer

Returns the number of bytes in the machine representation of big.
返回big的机器表示所用的字节数。

    (256**10 - 1).size # => 12
    (256**20 - 1).size # => 20
    (256**40 - 1).size # => 40

#### to_f  转换为浮点

    big.to_f → float

Converts big to a Float. 
将big转换位Float。
If big doesn’t fit in a Float, the result is infinity.
如果big不能用Float表示，则结果无限大。

#### to_s  转换位字符串  1.8

    big.to_s( base=10 ) → str

Returns a string containing the representation of big radix base (2 to 36).
返回包含big的base（2到36）进制表示的字符串。

    12345654321.to_s         # => "12345654321"
    12345654321.to_s(2)      # => "1011011111110110111011110000110001"
    12345654321.to_s(8)      # => "133766736061"
    12345654321.to_s(16)     # => "2dfdbbc31"
    12345654321.to_s(26)     # => "1dp1pc6d"
    78546939656932.to_s(36)  # => "rubyrules"


## Binding  绑定
### 概述
Objects of class Binding encapsulate the execution context at some particular place in the code and retain this context for future use. 
Binding类的对象封装了代码在某个位置的执行上下文，并保留该上下位以备后用。
Access to the variables, methods, value of self, and possibly an iterator block accessible in this context are all retained. 
在该上下文中可能被访问的变量、方法、self的值以及可能的迭代block都将被保存下来。
⇡New in 2.0⇣
Binding objects can be created using Object#binding and are made available to the callback of Object#set_trace_func and to the block passed to TracePoint.new.
绑定对象可以使用Object#binding来创建。可被Object#set_trace_func回调，可被block传递给TracePoint.new方法。 
These binding objects can be passed as the second argument of the Object#eval method, establishing an environment for the evaluation.
这些绑定对象可以作为Object#eval方a的第二个参数，以建立该方法的执行环境。

    class Demo
      def initialize(n)
        @secret = n
      end
      def get_binding
        return binding()
      end
    end
    k1 = Demo.new(99)
    b1 = k1.get_binding
    k2 = Demo.new(-3)
    b2 = k2.get_binding
    # Pass to eval...  传给eval
    eval("@secret", b1) # => 99
    # Or eval via binding...  或者通过绑定eval
    b2.eval("@secret") # => -3
    eval("@secret") # => nil

### Instance Methods
#### eval  1.9

    bind.eval( string ‹ , file ‹ , line ›› ) → obj

Evaluates the Ruby code in string using the context of bind. 
使用bind的上下文运算字符串中的ruby代码。
Equivalent to calling Object#eval with a second argument of bind. 
等同于调用Object#eval，并用绑定作为第二个参数。
See the start of this section for an example.
参看本节开头的例子。


## Class < Module  类
### 概述
Classes in Ruby are first-class objects—each is an instance of class Class.
在ruby中类是最常见的对象--每个类都是类Class的实例。

When a new class is defined (typically using class SomeName ...  end), an object of type Class is created and assigned to a constant (SomeName, in this case). 
当定义一个新类时（通常使用class SomeName ...  end）， Class类型的一个对象将被创建，并赋值给一个常量（在这个例子中是SomeName）。
When Name.new is called to create a new object, the new instance method in Class is run by default, which in turn invokes allocate to allocate memory for the object, before finally calling the new object’s initialize method.
在运行新对象的initialize方法前，默认情况下，Class实例方法new将运行，它会调用allocate来为对象分配内存。

### Class Methods  
#### new  新建

    Class.new( super_class=Object ) ‹ { … } › → cls

Creates a new anonymous (unnamed) class with the given superclass (or Object if no parameter is given). 
根据给定的超类（如果没有给定参数，则使用Object）创建一个新的匿名（未命名）类。
If called with a block, that block is used as the body of the class. 
如果传入一个block，则该block将作为新类的定义体。
Within the block, self is set to the class instance.
在block里面，self被设置为类实例。<kinder:note> 什么意思？

    name = "Dave"
    FriendlyClass = Class.new do
      define_method :hello do
        "Hello, #{name}"
      end
    end
    f = FriendlyClass.new
    f.hello # => "Hello, Dave"

### Instance Methods  
#### allocate  分配  1.8

    cls.allocate → obj

Allocates space for a new object of cls’s class. 
为cls的类的新对象分配空间。
The returned object must be an instance of cls.
返回的对象必须是cls的一个实例。
Calling new is basically the same as calling the class method allocate to create an object, followed by calling initialize on that new object. 
一般来说，调用new创建对象和调用类方法allocate分配新对象，然后调用新对象的initialize方法是一样的。
You cannot override allocate in normal programs; Ruby invokes it without going through conventional method dispatch.
在普通程序中你无法覆盖allocate；ruby调用该方法时不会通过传统的方法分派。

    class MyClass
      def self.another_new(*args)
        o = allocate
        o.send(:initialize, *args)
        o
      end
      def initialize(a, b, c)
        @a, @b, @c = a, b, c
      end
    end
    mc = MyClass.another_new(4, 5, 6)
    mc.inspect # => "#<MyClass:0x007fbdab10f430 @a=4, @b=5, @c=6>"

#### new  新建

    cls.new( ‹ args ›* ) → obj

Calls allocate to create a new object of cls’s class and then invokes the newly created object’s initialize method, passing it args.
调用allocate创建cls的类的一个新对象，然后调用新创建的对象的initialize方法，并以args作为参数。

#### superclass  超类

    cls.superclass → super_class or nil

Returns the superclass of cls or returns nil.
返回cls的超类或返回nil。

    Class.superclass # => Module
    Object.superclass # => BasicObject
    BasicObject.superclass # => nil


### Private Instance Methods
#### inherited  继承

    cls.inherited( sub_class )

Invoked by Ruby when a subclass of cls is created. 
创建cls的子类时，该方法将被ruby调用。
The new subclass is passed as a parameter.
将被创建的子类是参数。

    class Top
      def self.inherited(sub)
        puts "New subclass: #{sub}"
      end
    end
    class Middle < Top
    end
    class Bottom < Middle
    end
    # produces:
    # New subclass: Middle
    # New subclass: Bottom


## Module Comparable  比较模块
### 概述
Relies on: <=>
The Comparable mixin is used by classes whose objects may be ordered. 
Comparable混入可被那些“对象可以排序”的类所使用。
The class must define the <=> operator, which compares the receiver against another object, returning -1, 0, or +1 depending on whether the receiver is less than, equal to, or greater than the other object.
类必须定义<=>操作符，它比较接收者和另外一个对象，并根据接收者小于、等于或大于另一个对象返回-1,0,或+1。
Comparable uses <=> to implement the conventional comparison operators (<, <=, ==, >=, and >) and the method between?.
Comparable使用<=>来实现传统的比较操作符（`<,<=,==,>=,>`）和between?方法。

    class CompareOnSize
      include Comparable
      attr :str
      def <=>(other)
        str.length <=> other.str.length
      end
      def initialize(str)
        @str = str
      end
    end
    s1 = CompareOnSize.new("Z")
    s2 = CompareOnSize.new([1,2])
    s3 = CompareOnSize.new("XXX")
    s1 < s2             # => true
    s2.between?(s1, s3) # => true
    s3.between?(s1, s2) # => false
    [ s3, s2, s1 ].sort # => ["Z", [1, 2], "XXX"]

### Instance Methods   实例方法
#### Comparisons  比较

    obj < other_object → true or false
    obj <= other_object → true or false
    obj == other_object → true or false
    obj >= other_object → true or false
    obj > other_object → true or false

Compares two objects based on the receiver’s <=> method.
基于接收者的<=>方法比较两个对象。

#### between?  中间

    obj.between?( min, max ) → true or false

Returns false if obj <=> min is less than zero or if obj <=> max is greater than zero; returns true otherwise.
如果`obj <=> min`小于0,或者`obj <=> max`大于0,则返回false；否则返回true。

     3.between?(1, 5)             # => true
     6.between?(1, 5)             # => false
     'cat'.between?('ant', 'dog') # => true
     'gnu'.between?('ant', 'dog') # => false


## Complex < Numeric  复数  1.9
### 概述
Represents complex numbers, represented internally as numbers with a real part and an imaginary part, both of which can be any scalar number. 
表示复数，内部表示为一个包含实数部分和虚数部分的数字，两部分都是可以标量的数字。
Note that scalar comparison operations (`<=>, <,` and so on) are not defined on complex numbers (which would argue that Complex should not be a subclass of Numeric, but that ship has sailed). 
注意标量比较操作（`<=>, <,`等）不能在复数中定义（这会让你争论Complex应不应是Numeric的子类，但这无关）。
Also see the standard library named complex on page 738 for a way to add complex number support to standard math functions; also see the mathn library on page 768 for a way of integrating complex numbers into regular arithmetic (so that the square root of -1 returns Complex::I).
另见后面738页的complex标准库，可在标准数学函数中提供复数支持；另见后面768页mathn库，可将复数积分添加到普通算术中（所以-1的平方根将返回Complex::I）

    v1 = Complex(2,3)    # => (2+3i)
    v2 = Complex("0+2i") # => (0+2i)
    v1 + v2              # => (2+5i)
    v1 * v2              # => (-6+4i)
    v2**2                # => (-4+0i)
    v2**2 == -4          # => true
    # Euler's theorem 欧拉定律
    include Math
    E**(PI*Complex::I) # => (-1.0+1.2246467991473532e-16i)

### Class Constants 类常数
#### Complex::I
The imaginary unit.虚数单位。

### Class Methods  类方法
#### polar  极

    Complex.polar( magnitude, angle ) → complex

Returns the complex number represented by the given polar coordinates.
对指定极坐标的表示返回复数。

    Complex.polar(1.23, 0.5)      # => 1.0794265511251584+0.5896934124831696i
    Complex.polar(1, Math::PI/2)  # => 6.123233995736766e-17+1.0i

#### rect  矩

    Complex.rect( read, imag ) → complex

Returns the complex number represented by the given real and imaginary parts.
对给定的实部和虚部的表示返回复数。

    Complex.rect(1.23, 0.5) # => 1.23+0.5i

#### rectangular  矩

    Complex.rectangular( read, imag ) → complex

Synonym for Complex.rect.
和Complex.rect同义。


### Instance Methods 实例方法
#### Arithmetic operations  算术操作
Performs various arithmetic operations on complex.
对复数执行各种算术操作。

    complex +  numeric     Addition 加法      
    complex –  numeric     Subtraction 减法
    complex *  numeric     Multiplication 乘法
    complex /  numeric     Division 除法
    complex ** numeric     Exponentiation 乘方
    complex -@             Unary minus 一元减
    complex -+             Unary plus  一元加

#### ==  比较

    complex == other → true or false

Returns true if complex does equals other, converting other to a complex number if necessary.
如果complex等于other则返回true，如果有必要则将other转为一个复数。

    Complex::I == Complex(0,1) # => true
    Complex::I == Complex(1,0) # => false
    Complex(1,0) == 1          # => true
    Complex(1,0) == "1"        # => false

#### abs  绝对值

    complex.abs → number

Synonym for Complex#magnitude.
和Complex#magnitude同义。

#### abs2  绝对值的平方

    complex.abs2 → number

Returns the square of the absolute value (magnitude) of complex.
返回复数的绝对值的平方。

    Complex::I.abs2 # => 1
    Complex(1,1).abs2 # => 2

#### angle  角度

    complex.angle → number

Returns the angle between the x-axis and a line from the origin to complex. 
返回x轴和从原点到复数的线所构成的角。
By convention, Complex(0,0).angl} is 0.
按惯例，Complex(0,0).angl}为0。

    Complex(1, 0).angle # => 0.0
    Complex(1, 1).angle # => 0.7853981633974483
    Complex(0, 1).angle # => 1.5707963267948966

#### arg  参数

    complex.arg → number

Synonym for Complex#angle.
和Complex#angle同义。

#### conj  变化

complex.conj → a_complex

Synonym for Complex#conjugate.
和Complex#conjugate同义。

#### conjugate  变化

    complex.conjugate → a_complex


Returns the conjugate of complex (the reflection of complex around the x-axis).
返回complex的变化（complex在x轴周围的映射）

    Complex::I.conjugate # => (0-1i)
    Complex(1,1).conjugate # => (1-1i)

#### denominator  分母

    complex.denominator → number

Returns the lowest common multiple of the denominators of the real and imaginary parts of complex.
返回complex的实部和虚部的分母的最小公倍数。

    Complex("1/3+1/4i").denominator # => 12
    Complex(-2, 4).denominator # => 1

#### eql?  相等

    complex.eql( other ) → true or false

Returns true only if other is a complex number with real and imaginary parts eql? to complex’s.
只有other是个复数且实部和虚部都等于complex的，才返回true。

    Complex(1, 0).eql?(Complex(1,0))    # => true
    Complex(1, 0).eql?(Complex(1.0, 0)) # => false
    Complex(1, 0).eql?(1)               # => false
    Complex(1, 0) == Complex(1,0)       # => true
    Complex(1, 0) == Complex(1.0, 0)    # => true
    Complex(1, 0) == 1                  # => true

#### fdiv  浮点除法

    complex.fdiv( other ) → a_complex

Returns complex / other after converting the real and imaginary parts of complex to floats.
返回complex除以other之后的值，该值的实部和虚部会被转为浮点数。
(Contrast with Complex#quo.)
(和Complex#quo对比)

    c1 = Complex(1, 2)
    c2 = Complex(2, 2)
    c1 /c2 # => ((3/4)+(1/4)*i)
    c1.fdiv(c2) # => (0.75+0.25i)

#### imag  虚部

    complex.imag → number

Returns the imaginary part of complex.
返回复数的虚部。

    Complex(2, -3).imag # => -3

#### imaginary  虚部

    complex.imaginary → number

Synonym for Complex#imag.
和Complex#imag同义。

#### magnitude  绝对值

    complex.magnitude → int or float

Returns the magnitude of complex (the distance of complex from the origin of the number line). 
返回复数的绝对值（复数从原点到数字所在行的距离）
The positive square root of real^2 + imag^2 .
实部平方加上虚部平方的正平方根。

    Complex(1, 1).magnitude # => 1.4142135623730951
    Complex(3, 4).magnitude # => 5.0
    Complex::I.magnitude # => 1

#### numerator  分子

    complex.numerator → a_complex

Returns the numerator, treating the real and complex parts of complex as fractions to be combined over a common denominator.
返回分子，将复数的实部和虚部作为分数处理，通过一个公分母联合起来。

    c = Complex('2/3+3/4i')
    c.numerator # => (8+9i)
    c.denominator # => 12

#### phase  相位

    complex.phase → [magnitude, angle ]

Returns the phase angle of complex (the angle between the positive x-axis and the line from the origin to (real, imag)), measured in radians.
返回复数的相位角（正x轴和原点到复数绝对值的线的夹角），用弧度表示。

    Complex(3, 4).phase # => 0.9272952180016122
    Complex(-3, 4).phase # => 2.214297435588181

#### polar  极

    complex.polar → [ magnitude, angle ]

Returns complex as polar coordinates.
返回复数的极坐标。

    Complex(1,1).polar # => [1.4142135623730951, 0.7853981633974483]
    Complex(-2,-3).polar # => [3.605551275463989, -2.158798930342464]

#### quo  分数

    complex.quo( other ) → a_complex

Returns complex / other after converting the real and imaginary parts of complex to rational numbers. 
返回complex除以other之后的值，该值的实部和虚部会被转为有理数。
(Contrast with Complex#fdiv.)
(和Complex#fdiv比较)

    c1 = Complex(1, 2)
    c2 = Complex(2, 2)
    c1 /c2     # => ((3/4)+(1/4)*i)
    c1.quo(c2) # => ((3/4)+(1/4)*i)

#### rationalize  有理化

    complex.rationalize( eps=nil ) → rational

Returns the real part of complex as a rational number, raising an exception if the imaginary part is not zero. 
将complex的实部转为有理数，如果虚部不为0将抛出一个异常。
The argument is always ignored. 
参数常被忽略。
Effectively a synonym for Complex.to_r.
实际上和Complex.to_r同义。

    Complex(2.5, 0).rationalize # => (5/2)

#### rect  矩

    complex.rect → [ complex.real, complex.imag ]

Returns an array containing the real and imaginary components of complex.
返回一个包含复数的实部和虚部的数组。

    Complex::I.rect # => [0, 1]

#### rectangular  矩

    complex.rectangular → [ complex.real, complex.imag ]

Synonym for Complex#rect.
和Complex#rect同义。

#### real  实部

    complex.real → number

Returns the real part of complex.
返回complex的实部。

    Complex(2, 3).real # => 2

#### real?  是否实数

    complex.real? → false

Complex numbers are never real numbers (even if their imaginary part is zero).
复数不可能是实数（即使虚部为0）。

    Complex(1, 1).real? # => false
    Complex(1, 0).real? # => false

#### to_f  转为浮点数

    complex.to_f → float

Returns the real part of complex as a float, raising an exception if the imaginary part is not zero.
将复数的实部转为一个浮点数，如果虚部非零则抛出一个异常。

    Complex(2, 0).to_f # => 2.0

#### to_i  转为整数

    complex.to_i → integer

Returns the real part of complex as an integer, raising an exception if the imaginary part is not zero.
将复数的实部转为一个整数，如果虚部非零则抛出一个异常。

    Complex(2.2, 0).to_i # => 2

#### to_r  转为有理数

    complex.to_r → rational

Returns the real part of complex as a rational number, raising an exception if the imaginary part is not zero.
将复数的实部转为一个有理数，如果虚部非零则抛出一个异常。

    Complex(2.5, 0).to_r # => (5/2)


## Dir   目录
### 目录流
Objects of class Dir are directory streams representing directories in the underlying file system.
Dir类的对象是表示底层文件系统目录的目录流。
They provide a variety of ways to list directories and their contents. 
See also File on page 488.
它们提供了各种各样的方法来列出目录和它的内容。
详见后面2版465页4版488页的File。
The directory used in these examples contains the two regular files (config.h and main.rb), the parent directory (..), and the directory itself (.).
这些例子中用的目录含有两个普通文件（config.h和main.rb）、父目录（..）和目录本身（.）。

### Mixes In 混入
Enumerable: 
  all?, any?, 
  chunk, collect, collect_concat, count, cycle, 
  detect, drop, drop_while, 
  each_cons, each_entry, each_slice, each_with_index, each_with_object, entries,
  find, find_all, find_index, first, flat_map, 
  grep, group_by, 
  include?, inject, 
  lazy, 
  map, max, max_by, member?, min, min_by, minmax, minmax_by, 
  none?, 
  one?, 
  partition, 
  reduce, reject, reverse_each, 
  select, slice_before, sort, sort_by, 
  take, take_while, to_a, 
  zip

### Class Methods 类方法
#### []  


    Dir[ glob_pattern ] → array

Equivalent to calling `Dir.glob(glob_pattern,0)`.
等价于调用`Dir.glob(glob_pattern,0)`.

#### chdir  改变目录

    Dir.chdir( ‹ dir › ) → 0
    Dir.chdir( ‹ dir › ) { |path| … } → obj

Changes the current working directory of the process to the given string. 
改变进程的当前工作目录给给定的字符串。
When called without an argument, changes the directory to the value of the environment variable HOME or LOGDIR. 
不带参数调用此函数时，改变目录为环境变量HOME或LOGDIR的值。
Raises a SystemCallError (probably Errno::ENOENT) if the target directory does not exist.
如果目标目录不存在则抛出一个SystemCallError异常（也可能是Errno::ENOENT）

If a block is given, it is passed the name of the new current directory, and the block is executed with that as the current directory. 
如果给出block，ruby会传递新的工作目录名字给block，并以该目录为当前目录执行block。
The original working directory is restored when the block exits. 
block退出时恢复原来的的工作目录。
The return value of chdir is the value of the block. 
chdir的返回值是block的返回值。
chdir blocks can be nested, but in a multithreaded program an error will be raised if a thread attempts to open a chdir block while another thread has one open. 
chdir的block可以嵌套，但在多线程程序中，如果一个线程试图打开其他线程，则已经打开chdir的block会出现错误。
This is because the underlying operating system only understands the concept of a single current working directory at any one time.
这是因为底层的操作系统只能理解这样的概念：在任何时刻只有一个当前工作目录。

    Dir.chdir("/private/var/log")   # => 0
    Dir.pwd                         # => "/private/var/log"
    Dir.chdir("/private/tmp") do    
      Dir.pwd                       # => "/private/tmp"
      Dir.chdir("/usr") do          
        Dir.pwd                     # => "/usr"
      end                           
      Dir.pwd                       # => "/private/tmp"
    end                             
    Dir.pwd                         # => "/private/var/log"

#### chroot  改变根目录

    Dir.chroot( dirname ) → 0

Changes this process’s idea of the file system root. 
改变进程的文件系统根目录。
Only a privileged process may make this call. 
只有有权限的进程可以调用它。
Not available on all platforms. 
并非在所有平台上都可使用。
On Unix systems, see chroot(2) for more information.
在Unix系统上，参考chroot(2)获得更多信息。

    Dir.chdir("/production/secure/root")
    Dir.chroot("/production/secure/root")  #=> 0
    Dir.pwd                                #=> "/"

#### delete  删除空目录

    Dir.delete( dirname ) → 0

Deletes the named directory. 
删除给定的目录。
Raises a subclass of SystemCallError if the directory isn’t empty.
如果目录不为空，将抛出一个SystemCallError的子类的异常。

#### entries  文件名数组

    Dir.entries( dirname ) → array

Returns an array containing all of the filenames in the given directory. 
返回给定目录中所有文件名组成的数组。
Will raise a SystemCallError if the named directory doesn’t exist.
如果给定的目录不存在，则引发一个SystemCallError异常。

    Dir.entries("testdir") # => [".", "..", ".svn", "config.h", "main.rb"]

#### exist?  目录是否存在  1.9

    Dir.exist?( path ) → true or false

Returns true if path exists and is a directory. 
如果路径存在且是一个目录，返回true。
Alias for File.directory?.
File.directory?的别名。

    Dir.exist?("/tmp") # => true
    Dir.exist?("/temp") # => false

#### exists?  目录是否存在 1.9

    Dir.exists?( path ) → true or false

Alias for Dir.exist?.
Dir.exist?的别名。

#### foreach  遍历目录

    Dir.foreach( dirname ) { |filename| … } → nil

Calls the block once for each entry in the dirname, passing the filename as a parameter.
对给定目录中的每项调用block，并传递每个项的文件名作为blcok的参数。

    Dir.foreach("testdir") {|x| puts "Got #{x}" }
    # produces:
    # Got .
    # Got ..
    # Got .svn
    # Got config.h
    # Got main.rb

#### getwd  当前目录名

    Dir.getwd → dirname

Returns a string containing the canonical path to the current working directory of this process.
返回包含进程的工作目录的规范路径的字符串。
Note that on some operating systems this name may not be the name you gave to Dir.chdir.
注意在某些操作系统上，这个名字可能不是你传递给Dir.chdir的名字。
On OS X, for example, /tmp is a symlink.
比如在OS X，/tmp是一个链接文件。

    Dir.chdir("/tmp") # => 0
    Dir.getwd # => "/private/tmp"

#### glob  匹配模式

    Dir.glob( glob_pattern, ‹ flags › ) → array
    Dir.glob( glob_pattern, ‹ flags › ) { |filename| … } → false

Returns the filenames found by expanding the pattern given in `glob_pattern`, either as elements in array or as parameters to the block. 
扩展给定的模式`glob_pattern`，并返回找到的文件名，返回的文件名或者作为数组的元素，或者作为block的参数。
Note that this pattern is not a regexp (it’s closer to a shell glob). 
注意这里的 模式不是正则表达式（更像shell的glob）。
See File.fnmatch on page 491 for the meaning of the flags parameter. 
关于flags参数的意义请参考2版468页4版491页的File.fnmatch。
Case sensitivity depends on your system (so `File::FNM_CASEFOLD` is ignored). 
大小写敏感性依赖于你的系统（所以`File::FNM_CASEFOLD`将被忽略）。
<kinder:note> `File::FNM_CASEFOLD` 是干嘛的？ 
Metacharacters in the pattern are as follows:
模式中的元字符有：
*
Any sequence of characters in a filename: `*` will match all files, `c*` will match all files beginning with c, `*c` will match all files ending with c, and `*c*` will match all files that have c in their name.
文件名中的任意字符序列：`*`会匹配所有文件，`c*`匹配所有以c开头的文件，`*c`匹配所有以c结尾的文件，而`*c*`匹配所有名字含有字母c的文件。
**
Matches zero or more directories (so `**/fred` matches a file named fred in or below the current directory).
匹配0个或多个目录（所以`**/fred`匹配在当前目录或其子目录中名为fred的文件）。
?
Matches any one character in a filename.
匹配文件名中的任意一个字符。
[chars]
Matches any one of chars. 
匹配chars中的任意一个。
If the first character in chars is ^, matches any character not in the remaining set.
如果chars第一个字符是^，则匹配任意不在其中的字符。
{patt,...} 
Matches one of the patterns specified between braces. 
匹配花括号中给出的模式之一。
These patterns may contain other metacharacters.
这些模式可以含有其他元字符。
\
Removes any special significance in the next character.
去除下一个字符的特殊含义。

    Dir.chdir("testdir")              # => 0
    Dir["config.?"]                   # => ["config.h"]
    Dir.glob("config.?")              # => ["config.h"]
    Dir.glob("*.[a-z][a-z]")          # => ["main.rb"]
    Dir.glob("*.[^r]*")               # => ["config.h"]
    Dir.glob("*.{rb,h}")              # => ["main.rb", "config.h"]
    Dir.glob("*")                     # => ["config.h", "main.rb"] 
    Dir.glob("*", File::FNM_DOTMATCH) # => [".", "..", ".svn", "config.h", "main.rb"]

    Dir.chdir("..")              # => 0                                  
    Dir.glob("code/**/fib*.rb")  # => ["code/irb/fibonacci_sequence.rb",
                                 # .. "code/rdoc/fib_example.rb"]
    Dir.glob("**/rdoc/fib*.rb")  # => ["code/rdoc/fib_example.rb"]

#### home  用户主目录

    Dir.home( ‹ user_name › ) → string

Returns the home directory of the given user (or the current user if no argument is given).
返回指定用户的主目录（如果没有指定参数则是当前用户）。

    Dir.home # => "/Users/dave"
    Dir.home("nobody") # => "/var/empty"

#### mkdir  新建目录

    Dir.mkdir( dirname ‹ , permissions › ) → 0

Makes a new directory named dirname, with permissions specified by the optional parameter permissions. 
创建名为dirname的新目录，权限由可选参数permissions指定。
The permissions may be modified by the value of File.umask and are ignored on Windows. 
权限可以被File.umask的值改变，在windows上将被忽略。
Raises a SystemCallError if the directory cannot be created. 
如果不能创建指定的目录，则引发SytemCallError异常。
See also the discussion of permissions on page 488.
有关权限的讨论参见2版465页4版488页。

#### new  新建目录

    Dir.new( dirname ‹ , :encoding => enc › ) → dir

Returns a new directory object for the named directory. 
为指定名字的目录返回一个新的目录对象。
The optional hash parameter lets you specify the encoding used by filenames. 
可选的hash参数让你指定文件名所使用的编码。
If not given, it defaults to the file system local on the current machine.
如果没有指定，默认为当前机器的文件系统。

#### open  打开

    Dir.open( dirname ‹ , :encoding => enc ›) → dir
    Dir.open( dirname ‹ , :encoding => enc ›) { |dir| … } → obj

With no block, open is a synonym for Dir.new. 
不带block调用时，open和Dir.new同义。
If a block is present, it is passed dir as a parameter. 
如果带有block，将传递dir作为block的参数。
The directory is closed at the end of the block, and Dir.open returns the value of the block.
当block结束时将关闭目录，且Dir.open返回block的值。

#### pwd  当前目录名

    Dir.pwd → dirname

Synonym for Dir.getwd.
同Dir.getwd。

#### rmdir  删除目录

    Dir.rmdir( dirname ) → 0

Synonym for Dir.delete.
同Dir.delete。

#### unlink  删除目录

    Dir.unlink( dirname ) → 0

Synonym for Dir.delete.
同Dir.delete。


### Instance Methods 实例方法
#### close  关闭目录

    dir.close → nil

Closes the directory stream. 
关闭目录流。
Any further attempts to access dir will raise an IOError.
之后对dir的任何访问都会引发IOError异常。

    d = Dir.new("testdir")
    d.close # => nil

#### each  遍历目录内部

    dir.each { |filename| … } → dir


Calls the block once for each entry in this directory, passing the filename of each entry as a parameter to the block.
对目录中每个项都调用block，并以项中含有的文件名作为block参数。

    d = Dir.new("testdir")
    d.each {|name| puts "Got #{name}" }
    # produces:
    # Got .
    # Got ..
    # Got .svn
    # Got config.h
    # Got main.rb

#### path  路径名   1.8

    dir.path → dirname

Returns the path parameter passed to dir’s constructor.
返回传递给dir的构造函数的路径参数。

    d = Dir.new("..")
    d.path # => ".."

#### pos  dir的当前位置    1.8

    dir.pos → int

Synonym for Dir#tell.
同Dir#tell。

#### pos=  定位当前目录   1.8
dir.pos( int ) → int

Synonym for Dir#seek but returns the position parameter.
除了返回位置参数之外，和Dir#seek同义。 

    d = Dir.new("testdir") # =>  #<Dir:testdir>
    d.read                 # =>  "."
    i = d.pos              # =>  1
    d.read                 # =>  ".."
    d.pos = i              # =>  1
    d.read                 # =>  ".."

#### read  读入下一个目录项
    
    dir.read → filename or nil

Reads the next entry from dir and returns it as a string. 
读入dir中的下一项，并作为字符串返回。
Returns nil at the end of the stream.
如果到了目录流的结尾，返回nil。

    d = Dir.new("testdir")
    d.read # => "."
    d.read # => ".."
    d.read # => ".svn"

#### rewind  返回首项

    dir.rewind → dir

Repositions dir to the first entry.
重新定位dir到第一项。

    d = Dir.new("testdir")
    d.read # => "."
    d.rewind # => #<Dir:testdir>
    d.read # => "."

#### seek  定位到特定位置

    dir.seek( int ) → dir

Seeks to a particular location in dir. 
定位到dir中指定的位置。
int must be a value returned by Dir#tell (it is not necessarily a simple index into the entries).
int必须是Dir#tell返回的值（它不必是项中的一个简单索引） 

    d = Dir.new("testdir")   # => #<Dir:testdir>
    d.read                   # => "."
    i = d.tell               # => 1
    d.read                   # => ".."
    d.seek(i)                # => #<Dir:testdir>
    d.read                   # => ".."

#### tell  返回dir中的当前位置。

    dir.tell → int

Returns the current position in dir. 
返回dir中的当前位置。
See also Dir#seek.
参见Dir#seek。

    d = Dir.new("testdir")
    d.tell # => 0
    d.read # => "."
    d.tell # => 1

#### to_path   路径 1.9

    dir.to_path → dirname

Synonym for Dir.path.
同Dir.path。


## Encoding 编码 1.9
### 概述
An encoding describes how to map the binary data in the internal representation of strings into characters. 
encoding描述了怎么内部表征的字符串二进制数据映射为字符。
Ruby has support for a large number of encodings built in—others can be loaded dynamically at runtime.
Ruby已经支持了很多内建编码--其他的可以在运行时动态装载。

Encodings are identified by name (UTF-8 or ISO-8859-1, for example). 
编码通过名字识别（比如UTF-8或者ISO-8859-1）。
They are represented by encoding objects. 
他们通过编码对象表示。
The Encoding class contains predefined constants for these encoding objects.
Encoding类包含了这些编码对象的预定义常数。

Often there are multiple objects for the same encoding. 
通常一个编码有多个对象。
For example, the constants Encoding::IBM860 and Encoding::CP860 are both representations of the encoding named IBM860. 
比如，常数Encoding::IBM860和Encoding::CP860都表示IBM860编码。
In the two-part table Table 15, Encoding names and class names, on page 463, the first column shows the names of the encodings, and the second column lists the names on the constants in the Encoding class for the corresponding encoding object(s). 
在下面463页的两栏的表格15“编码名和类名”中，第一栏显示编码的名字，第二栏列举了Encoding类相关编码对象的常数名字。
An entry such as ISO-8859-1 -11 indicates that there are eleven separate encodings (with the obvious names).
每个项目，比如ISO-8859-1表示有11中独立的编码（带有显式的名字）。

Encodings are used when opening files, creating strings, and so on. 
编码用于打开文件、创建字符串等等。
The methods that accept an encoding as a parameter will take either an encoding name or an encoding object. 
接受编码作为参数的方法将带有一个编码名称或者编码对象。
Use of the object is marginally faster.
使用编码对象会稍微快些。

Chapter 17, Character Encoding, on page 239 is devoted to a discussion of encodings.
前面239页的17章字符编码详细讨论了编码。

Table 15—Encoding names and class names 表格15   编码名和类名

    Encoding      Class name(s)
    编码           类名       
    ASCII-8BIT    ASCII_8BIT, BINARY                
    Big5            Big5, BIG5
    Big5-HKSCS   Big5_HKSCS, BIG5_HKSCS,Big5_HKSCS_2008, BIG5_HKSCS_2008
    Big5-UAO         Big5_UAO, BIG5_UAO
    CP50220       CP50220                           
    CP50221          CP50221 
    CP51932      CP51932                           
    CP850             CP850, IBM850
    CP852        CP852                             
    CP855             CP855
    CP949       CP949                              
    CP950             CP950
    CP951       CP951                              
    Emacs-Mule        Emacs_Mule, EMACS_MULE
    EUC-JP      EUC_JP, EucJP, EUCJP               
    EUC-JP-2004       EUC_JP_2004, EUC_JISX0213
    EUC-KR       EUC_KR, EucKR, EUCKR              
    EUC-TW            EUC_TW, EucTW, EUCTW
    eucJP-ms     EucJP_ms, EUCJP_MS, EUC_JP_MS    
    GB12345            GB12345
    GB18030     GB18030                           
    GB1988             GB1988
    GB2312      EUC_CN, EucCN, EUCCN              
    GBK                GBK, CP936
    IBM437     IBM437, CP437                      
    IBM737             IBM737, CP737
    IBM775    IBM775, CP775                       
    IBM852             IBM852
    IBM855     IBM855                             
    IBM857             IBM857, CP857
    IBM860--6    IBM860--6, CP8600--6          
    IBM869             IBM869, CP869
    ISO-2022-JP  ISO_2022_JP, ISO2022_JP          
    ISO-2022-JP-2      ISO_2022_JP_2, ISO2022_JP2
    ISO-2022-JP-KDDI ISO_2022_JP_KDDI            
    ISO-8859-1 -- 11   ISO8859_1 -- 11
    ISO-8859-13--16 ISO8859_13--16                
    KOI8-R             KOI8_R, CP878
    KOI8-U       KOI8_U                        
    macCentEuro          MacCentEuro, MACCENTEURO
    macCroatian  MacCroatian, MACCROATIAN         
    macCyrillic         MacCyrillic, MACCYRILLIC
    macGreek     MacGreek, MACGREEK              
    macIceland             MacIceland, MACICELAND
    MacJapanese    MacJapanese, MACJAPANESE, MacJapan, MACJAPAN      
    macRoman    MacRoman, MACROMAN
    macRomania      MacRomania, MACROMANIA       
    macThai             MacThai, MACTHAI
    macTurkish       MacTurkish, MACTURKISH       
    macUkraine             MacUkraine, MACUKRAINE
    Shift_JIS           Shift_JIS, SHIFT_JIS        
    SJIS-DoCoMo           SJIS_DoCoMo, SJIS_DOCOMO
    SJIS-KDDI          SJIS_KDDI                   
    SJIS-SoftBank            SJIS_SoftBank, SJIS_SOFTBANK
    stateless-ISO-2022-JP       Stateless_ISO_2022_JP, STATELESS_ISO_2022_JP         
    stateless-ISO-2022-JP-KDDI            Stateless_ISO_2022_JP_KDDI, STATELESS_ISO_2022_JP_KDDI
    TIS-620               TIS_620                  
    US-ASCII           US_ASCII, ASCII, ANSI_X3_4_1968
    UTF-16                  UTF_16                
    UTF-16BE            UTF_16BE, UCS_2BE
    UTF-16LE                UTF_16LE                 
    UTF-32            UTF_32
    UTF-32BE                UTF_32BE, UCS_4BE          
    UTF-32LE         UTF_32LE, UCS_4LE
    UTF-7                   UTF_7, CP65000             
    UTF-8            UTF_8, CP65001
    UTF8-DoCoMo                UTF8_DoCoMo, UTF8_DOCOMO        
    UTF8-KDDI        UTF8_KDDI
    UTF8-MAC               UTF8_MAC, UTF_8_MAC, UTF_8_HFS            
    UTF8-SoftBank            UTF8_SoftBank, UTF8_SOFTBANK
    Windows-1250 -- 1258               Windows_1250 -- 1258, WINDOWS_1250 -1258, CP1250 -- 1258           
    Windows-31J         Windows_31J, WINDOWS_31J, CP932, CsWindows31J, CSWINDOWS31J, SJIS, PCK
    Windows-874             Windows_874, WINDOWS_874, CP874 


### Class Methods 类方法
#### aliases  别名

    Encoding.aliases → hash

Returns a hash whose keys are aliases for encodings and whose values are the corresponding base encoding names.
返回一个散列表，键为编码的别名，值对应的基本编码名字。

    Encoding.aliases["BINARY"] # => "ASCII-8BIT"

#### compatible?  兼容性

    Encoding.compatible?( str1, str2 ) → enc or nil

Determines whether two strings have compatible encodings (meaning, for example, that you could concatenate them). 
决定两个字符串是否编码兼容（意思是，比如你可以将它们连接在一起）。
Returns the encoding of the string that would result from the concatenation or nil if the strings are not compatible.
返回会出现连接的编码的字符串，如果字符串不兼容则返回nil。

    # encoding: utf-8
    ascii1 = "ant"
    ascii2 = "bee"
    iso = "\xee" 
    iso.force_encoding(Encoding::ISO_8859_1)
    utf = "∂og"
    Encoding.compatible?(ascii1, ascii2)  # => #<Encoding:UTF-8>
    Encoding.compatible?(ascii1, iso)     # => #<Encoding:ISO-8859-1>
    Encoding.compatible?(ascii1, utf)     # => #<Encoding:UTF-8>
    Encoding.compatible?(iso,    utf)     # => nil

#### default_external  默认外部编码

Encoding.default_external → enc

Returns the default external encoding, used when reading and writing data from I/O streams.
返回默认的外部编码，当从I/O流中读入和写入时使用该编码。

    Encoding.default_external # => #<Encoding:UTF-8>

#### default_external=  设置默认外部编码

    Encoding.default_external = enc

Sets the default external encoding.
设置默认外部编码。

#### default_internal  内部编码

    Encoding.default_internal → enc or nil

Returns the default internal encoding, used when transcoding data read and written. 
返回默认内部编码，在对读入和写入的数据进行转码时使用。
Returns nil if no default encoding is set.
如果没有设置默认编码，返回nil。

#### default_internal=  设置内部编码

    Encoding.default_internal = enc

Sets the default internal encoding.
设置默认内部编码。

    Encoding.default_internal = 'utf-8'
    Encoding.default_internal # => #<Encoding:UTF-8>

#### find  寻找编码对象

    Encoding.find( name ) → enc

Returns the encoding object for the given encoding name or throws an ArgumentError.
对指定编码名返回编码对象或抛出一个ArgumentError。

    Encoding.find("Shift_JIS") # => #<Encoding:Shift_JIS>

#### list  编码对象列表

    Encoding.list → array

Returns a list of the encoding objects loaded into the current interpreter.
返回一个装载到当前解释器的编码对象的列表。

#### locale_charmap  本地字符映射

    Encoding.locale_charmap → name

Returns the name of the charmap of the current locale. 
返回当前locale的字符映射的名字。
This is normally set externally, often in an environment variable or other operating-system context.
这通常是外部设置的，经常是在一个环境变量或其他操作系统上下文中。

    ENV["LANG"] # => "en_US.UTF-8"
    Encoding.locale_charmap # => "UTF-8"

#### name_list  编码名字列表

    Encoding.name_list → array

Returns a list of the names of loaded encodings.
返回一个已装载编码的名字的列表。

Encoding.name_list.sort.first(5) # => ["646", "ANSI_X3.4-1968", "ASCII",
                                 # .. "ASCII-8BIT", "BINARY"]


### Instance Methods 实例方法
#### ascii_compatible?  ascii兼容性

    enc.ascii_compatible? → true or false

Returns true if the lower 127 codepoints in the encoding overlay the ASCII character set.
如果编码的前127个代码指针包含ASCII字符设置，则返回true。

    Encoding::UTF_8.ascii_compatible? # => true
    Encoding::SJIS.ascii_compatible? # => true
    Encoding::UTF_7.ascii_compatible? # => false

#### dummy? 虚拟性

    enc.dummy? → true or false

Dummy encodings are placeholders for encodings that cannot be handled properly by the current mechanism of Ruby multinationalization, often because they are stateful.
虚拟编码是编码的占位符，它不能被当前的ruby国际化机制适当进行处理，通常是因为他们是有状态的。

    Encoding::UTF_7.dummy? # => true
    Encoding::UTF_8.dummy? # => false

#### name  名字

    enc.name → string

Returns the name of enc.
返回enc的名字。

    Encoding::UTF_8.name # => "UTF-8"
    Encoding::CP65001.name # => "UTF-8"

#### names  所有名字

    enc.names → [ ‹ string ›+ ]

Returns the name of enc, along with the names of enc’s aliases.
返回enc的名字，连同enc的别名的名字。

    Encoding::ISO8859_1.names # => ["ISO-8859-1", "ISO8859-1"]
    Encoding::ASCII.names # => ["US-ASCII", "ASCII", "ANSI_X3.4-1968", "646"]

#### replicate  复制

    enc.replicate( name ) → new_encoding

Create a copy of the encoding enc with the given name (which must be unique).
创建一个enc编码的拷贝，命名为指定的名字（必须是唯一的）。



## Module   Enumerable  可枚举模块
### 概述
Relies on: each, <=>
The Enumerable mixin provides collection classes with traversal and searching methods and with the ability to sort. 
The Enumerable mixin提供了具有遍历和搜索方法、排序能力的集合类。
The class must provide a method each, which yields successive members of the collection. 
类必须提供each方法，该方法获得集合中连续的成员。
If Enumerable#max, min, sort, or sort_by is used, the objects in the collection must also implement a meaningful <=> operator, because these methods rely on an ordering between members of the collection.
如果使用Enumerable#max、min、sort或者sort_by，则集合中的对象必须实现一个有意义的<=>操作符；因为这些方法依赖于集合成员之间的顺序。

Ruby 1.9 adds a substantial number of methods to this module, as well as changing the semantics of many others. 
Ruby 1.9 增加了很多方法，又改变许多其他的语义。
Even experienced Ruby programmers should probably read this section carefully.
即使是经验丰富的ruby程序员也应认真读取这一章。

### Instance Methods 实例方法
#### all?  遍历全部  1.8 

    enum.all? ‹ { |obj| … } › → true or false

Passes each element of the collection to the given block. 
依次传递集合中的各个元素给block。
The method returns true if the block never returns false or nil. 
如果block一直没有返回false或者nil，则本方法返回true。
If the block is not given, Ruby adds an implicit block of {|obj| obj} 
如果没有给定block，那么ruby自动创建一个隐式的{|obj| obj}block。
(that is, all? will return true only if no collection member is false or nil).
（也就是说，如果集合中没有为false或nil的成员，则all?返回true）

    [ nil, true, 99 ].all? # => false

#### any?  遍历任意 1.8

    enum.any? ‹ { |obj| … } › → true or false

Passes elements of the collection in turn to the given block. 
依次传递集合中的各个元素给block。
The method returns true (and stops calling the block) if the block ever returns a value other than false or nil. 
如果block曾经返回一个不是false或nil的值，则本方法返回true（并停止调用block）。
If the block is not given, Ruby adds an implicit block of {|obj|~obj} 
如果没有指定block，ruby自动创建一个隐式的block。
(that is, any? will return true if at least one of the collection members is not false or nil). 
（也就是说，如果集合成员中有一个不是false或nil，则any?返回true。）
See also Enumerable#none? and Enumerable#one?.
另见Enumerable#none?和Enumerable#one?。

    [ nil, true, 99 ].any? # => true

#### chunk  返回大块  1.9 

    enum.chunk { |element| … } → enumerator
    enum.chunk( state ) { |element, state| … } → enumerator

Passes each element of enum to the block. 
传递enum的每个元素到block中。
Use the value returned from the block as a key, and group successive elements with the same key together. 
将block返回的值作为键，用同样的键对连续的元素进行分组。
The enumerator that is returned will yield the key and the successive values corresponding to that key. 
返回的enumerator将产生一个键，连续值对应着那个键。
Here’s a simple example that returns sequences of words that have the same length:
这是一个简单的例子，返回一系列的具有相同长度的单词。

    enum = %w{ ant bee coyote dophin elk }.chunk(&:size)
    enum.next # => [3, ["ant", "bee"]]
    enum.next # => [6, ["coyote", "dophin"]]
    enum.next # => [3, ["elk"]]

If the block returns the values nil or `:_separator`, the corresponding value is not stored in the output enumerator, and a new output element is started.
**如果block返回值nil或`:_separator`**，对应的值不在输出的enumerator上，并开始一个新的输出元素。

    enum = [ 1, 2, 3, 4, 5 ].chunk {|element| element.odd? ? :odd : :_separator}
    enum.to_a # => [[:odd, [1]], [:odd, [3]], [:odd, [5]]]

The following example uses the fact that a failing pattern match returns nil:
下面的例子应用了一个失败的模式匹配返回nil的事实：

    # This code reads its own source and returns each comment block
    File.foreach(__FILE__).chunk do |line|
      # A comment is a group of consecutive
      # lines starting with '#'
      line =~ /^\s*#/
    end.each do |_, lines|
      p lines
    end
    # produces:
    # ["# This code reads its own source and returns each comment block\n"]
    # [" # A comment is a group of consecutive\n", " # lines starting with '#'\n"]

If the block returns `:_alone`, this value is put into its own output element—it will not be grouped with the previous element even if that element’s block also returned `:_alone`.
如果block返回`:_alone`，这个值被放入它的输出元素中--它不会和之前的元素那样被分组，即使该元素的block也返回`:_alone`。

    enum = [ 1, 2, 3 ].chunk { :_alone }
    enum.to_a # => [[:_alone, [1]], [:_alone, [2]], [:_alone, [3]]]

If a state parameter is present, it is passed as the second parameter to every call to the block, permitting state to be maintained across calls.
如果有状态参数存在，将被传递作为第二个单数给每个block调用，权限状态将被多个调用所保持。
See also `Enumerable.slice_before`.
另见`Enumerable.slice_before`。

#### collect  返回收集 1.9

    enum.collect { |obj| … } → array or enumerator

Returns a new array containing the results of running block once for every element in enum.
返回一个新的数组，包含enum每个元素一次运行block之后的结果。
Returns an Enumerator object if no block is given.
如果没有指定block，将返回一个Enumerator对象。

    (1..4).collect {|i| i*i } # => [1, 4, 9, 16]
    (1..4).collect { "cat" } # => ["cat", "cat", "cat", "cat"]
    (1..4).collect(&:even?) # => [false, true, false, true]

#### collect_concat  返回连接收集 1.9

    enum.collect_concat { |obj| … } → array
    enum.collect_concat → enumerator

Synonym for (the better named) Enumerable.flat_map.
同Enumerable.flat_map（这名字更好）。

#### count  符合条件的元素个数 1.9

    enum.count( obj ) → int
    enum.count { |obj| … } → int

Returns the count of objects in enum that equal obj or for which the block returns a true value.
返回enum里等于obj或者让block返回true的对象的数量。
Returns the count of all elements in enum if neither a block nor an argument is given.
如果没有指定block或参数则返回enum所有元素的数量。

    (1..4).count # => 4
    (1..4).count(3) # => 1
    (1..4).count {|obj| obj > 2 } # => 2

#### cycle  循环  1.9

    enum.cycle { |obj| … } → nil or enumerator
    enum.cycle( times ) { |obj| … } → nil or enumerator

Returns nil if enum has no elements; otherwise, passes the elements, one at a time, to the block, repeating when it reaches the end. 
如果enum没有元素，返回nil；否则将一次传递一个元素给block，所有元素传递完毕将再重复一次。
The number of times it repeats is set by the parameter. 
重复的次数由参数设定。
If the parameter is missing, cycles forever. 
如果参数丢失，循环会一直下去。
Equivalent to enum.to_a.cycle. 
等同于enum.to_a.cycle。
See also Array#cycle. 
另见Array#cycle。
Returns an Enumerator object if no block is given.
如果没有指定block，将返回一个Enumerator对象。

    ('a'..'c').cycle(2) # => #<Enumerator: "a".."c":cycle(2)>
    ('a'..'c').cycle(2).to_a # => ["a", "b", "c", "a", "b", "c"]

#### detect  侦测第一个

    enum.detect( ifnone = nil ) { |obj| … } → obj or nil or enumerator

Passes each entry in enum to block. 
依次传递enum中的每项给block。
Returns the first for which block is not false. 
返回第一个使block不为false的元素。
Returns nil if no object matches unless the proc ifnone is given, in which case it is called and its result is returned. 
除非给定了proc ifnone，否则如果没有匹配的对象，将返回nil，在给定了ifnone的情况下，它将被调用，并返回其结果。
Returns an Enumerator object if no block is given.
如果没有指定block将返回一个Enumerator对象。

    (1..10).detect {|i| i % 5 == 0 and i % 7 == 0 } # => nil
    (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 } # => 35
    sorry = lambda { "not found" }
    (1..10).detect(sorry) {|i| i > 50} # => "not found"

#### drop  丢弃前n个   1.9

enum.drop( n ) → an_array

Returns an array containing all but the first n elements of enum.
返回一个数组，包含除了前n个之外的所有enum元素。

    [ 1, 1, 2, 3, 5, 8, 13 ].drop(4) # => [5, 8, 13]
    [ 1, 1, 2, 3, 5, 8, 13 ].drop(99) # => []

#### drop_while  从false开始保留元素  1.9

    enum.drop_while { |item| … } → an_array or enumerator

Passes elements in turn to the block until the block does not return a true value. 
依次传递元素到block中，直到block不返回true。
Starting with that element, copies the remainder to an array and returns it. 
从该元素开始，将剩余的元素复制到一个数组中，并返回。
Returns an Enumerator object if no block is given.
如果没有给定block，将返回一个Enumerator对象。

    [ 1, 1, 2, 3, 5, 8, 13 ].drop_while {|item| item < 6 } # => [8, 13]

#### each_cons  遍历每n个子数组  1.9

    enum.each_cons( length ) { |array| … } → nil or enumerator

Passes to the block each consecutive subarray of size length from enum. 
从enum传递每个连续的length长的子数组到block中。
Returns an Enumerator object if no block is given.
如果没有给定block，将返回一个Enumerator对象。

    (1..4).each_cons(2) {|array| p array }
    # produces:
    # [1, 2]
    # [2, 3]
    # [3, 4]

#### each_entry  遍历每一项 1.9

    enum.each_entry { |element| … } → enum
    enum.each_entry → enumerator

Repeatedly calls enum.each, passing the result to the block. 
重复调用enum.each，将结果传递给block。
If each returns a single value, it is passed unchanged to the block. 
如果每个返回一个值，将被原样传递给block。
If a call to each returns multiple values, they are packaged into an array and passed to the block.
如果each的调用返回多个值，他们将包装进一个数组并传递给block。

    class Generator
      include Enumerable
      def each
        yield 1
        yield 2, 3
        yield 4
      end
    end
    g = Generator.new
    g.each {|entry| print entry, " : "}
    puts
    g.each_entry {|entry| print entry, " : "}
    # produces:
    # 1 : 2 : 4 :
    # 1 : [2, 3] : 4 :

#### each_slice  遍历切片 1.9

    enum.each_slice( length ) { |array| … } → nil or enumerator

Divides enum into slices of size length, passing each in turn to the block. 
将enum分割为length长的片段，并将片段依次传给block。
Returns an Enumerator object if no block is given.
如果没有给定block将返回Enumerator对象。

    (1..10).each_slice(4) {|array| p array }
    # produces:
    # [1, 2, 3, 4]
    # [5, 6, 7, 8]
    # [9, 10]

#### each_with_index  遍历元素和下标

    enum.each_with_index( ‹ args ›* ) { |obj, index| … } → enum or enumerator

Calls block, passing in successive items from enum and the corresponding index. 
调用block，从enum传入连续的项目和对象的索引。
If any arguments are given, they are passed to each during the iteration. 
如果给定参数，将被传入到每个迭代中。
Returns an Enumerator object if no block is given.
如果没有给定block，将返回一个Enumerator对象。

    %w(cat dog wombat).each_with_index do |item, index|
      puts "#{item} is at position #{index}"
    end
    # produces:
    # cat is at position 0
    # dog is at position 1
    # wombat is at position 2

#### each_with_object  遍历对象  1.9

    enum.each_with_object( memo ) → memo or enumerator

Calls block with the item and the memo object, for each item in enum. 
为enum的每个项目，带项目和memo对象调用block。
Returns an Enumerator object if no block is given.
如果没有给定block，返回一个Enumerator对象。

    hash = %w(cat dog wombat).each_with_object({}) do |item, memo|
      memo[item] = item.upcase.reverse
    end
    hash # => {"cat"=>"TAC", "dog"=>"GOD", "wombat"=>"TABMOW"}

#### entries  显示项目

    enum.entries → array

Synonym for Enumerable#to_a.
同Enumerable#to_a。

#### find  查找

    enum.find( ifnone = nil ) { |obj| … } → obj or nil

Synonym for Enumerable#detect.
同Enumerable#detect。

#### find_all  查找所有

    enum.find_all { |obj| … } → array or enumerator

Returns an array containing all elements of enum for which block is not false (see also Enumerable#reject). 
返回一个数组，包含enum所有让block不为false的元素（另见enumerator#reject）。
Returns an Enumerator object if no block is given.
如果没有指定block返回一个Enumerator对象。

    (1..10).find_all {|i| i % 3 == 0 } # => [3, 6, 9]

#### find_index  查找所有符合的下标  1.9

    enum.find_index( obj ) → int or nil
    enum.find_index { |obj| … } → int or nil or enumerator

Returns the index of the first object in arr that is == to obj or for which the block returns a true value. 
返回arr中第一个==obj或让block返回true的对象的下标。
Returns nil otherwise. 
否则返回nil。
See also Enumerable#reject. 
另见Enumerable#reject。
Returns an Enumerator object if no block is given.
如果没有给定block，返回一个Enumerator对象。

    %w{ant bat cat dog}.find_index {|item| item =~ /g/ } # => 3
    %w{ant bat cat dog}.find_index {|item| item =~ /h/ } # => nil

#### first  第一个元素  1.9

    enum.first → an_object or nil
    enum.first( n ) → an_array

With no parameters, returns the first item of enum or nil. 
不带参数返回enum的第一个项目或nil。
With a parameter, returns the first n items of enum.
带参数返回enum的前n个项目。

    %w{ant bat cat dog}.first # => "ant"
    %w{ant bat cat dog}.first(2) # => ["ant", "bat"]

#### flat_map  平面映射 1.9

    enum.flat_map { |obj| … } → array
    enum.flat_map → enumerator

Passes each element in enum to the block. 
将enum的每个元素传给block。
If the returned value is an array (or is compatible with an array), append each element to the result; otherwise, append the block return value to the result. 
如果返回的值是一个数组（或者是数组兼容的对象），将每个元素添加到结果后面；否则将block返回值追加到结果后面。
<kinder:note> 前半句“将每个元素添加到结果后面”容易曲解，作者的意思是将所返回的数组拆成每个元素。
The effect is a single-level flattening of any returned value. 
效果是返回值的单级扩展。
If no block is given, return an enumerator.
如果没有给定block，将返回一个enumerator。

    [ 1, 2, 3 ].flat_map {|e| [ e, 100-e ]} # => [1, 99, 2, 98, 3, 97]

#### grep  模式查找

    enum.grep( pattern ) → array
    enum.grep( pattern ) { |obj| … } → array

Returns an array of every element in enum for which pattern === element. 
返回enum中满足pattern==element的元素组成的数组。
If the optional block is supplied, each matching element is passed to it, and the block’s result is stored in the output array.
如果有可选的block，将传递每个匹配的元素给block，并将block返回的结果存储在输出数组中。

    (1..100).grep 38..44 # => [38, 39, 40, 41, 42, 43, 44]
    c = IO.constants
    c.grep(/SEEK/) # => [:SEEK_SET, :SEEK_CUR, :SEEK_END]
    res = c.grep(/SEEK/) {|v| IO.const_get(v) }
    res # => [0, 1, 2]
    [ 123, 9**11, 12.34 ].grep(Integer) # => [123, 31381059609]

#### group_by  分组  1.9

    enum.group_by { |item| … } → hash or enumerator

Partitions enum by calling the block for each item and using the result returned by the block to group the items into buckets. 
通过为每个项目调用block对enum进行划分，对block返回的结果进行分组。
Returns a hash where the keys are the objects returned by the block, and the values for a key are those items for which the block returned that object.
返回一个散列表，键为block返回的对象，键的值为那些block返回那些对象的项目。<kinder:note> 好像不应该这么翻译。
Returns an Enumerator object if no block is given.
如果没有给定block则返回一个Enumerator对象。

    p (1..5).group_by {|item| item.even? ? "even" : "odd" }
    # produces:
    # {"odd"=>[1, 3, 5], "even"=>[2, 4]}

#### include?  包含性

    enum.include?( obj ) → true or false

Returns true if any member of enum equals obj. 
如果enum的任何一个成员等于obj，返回true。
Equality is tested using ==.
使用==测试等价性。

    IO.constants.include? :SEEK_SET # => true
    IO.constants.include? :SEEK_NO_FURTHER # => false

#### inject  注入  1.8

    enum.inject( initial) { |memo, obj| … } → obj
    enum.inject( initial, sym ) → obj
    enum.inject { |memo, obj| … } → obj
    enum.inject( sym ) → obj

Combines the items in enum by iterating over them. 
通过迭代联合enum的项目。
For each item, passes an accumulator object (called memo in the examples) and the item itself to the block or invokes memo.send(sym, obj). 
对每个项目，传递一个accumulator对象（在这个例子中是memo）和项目自身到block中或调用memo.send(sym, obj)。
At each step, memo is set to the value returned by the block on the previous step. 
在每一步，memo被设置为前一步的block的返回值。
The value returned by inject is the final value returned by the block. 
inject返回的值是block返回的最后一个值。
The first two forms let you supply an initial value for memo. 
前两种形式让你设置一个初始值给memo。
The second two forms use the first element of the collection as the initial value (and skip that element while iterating). 
后两种形式使用集合的第一个元素作为初始值（迭代时跳过那个元素）
Some languages call this operation foldl or reduce. 
一些语言称这个操作为foldl或reduce。
Ruby supports the latter as an alias for inject.
ruby将后者作为inject的别名。

    # Sum some numbers. These forms do the same thing     合计。
    (5..10).inject(0) {|sum, n| sum + n }         # => 45
    (5..10).inject {|sum, n| sum + n }            # => 45
    (5..10).inject(0, :+)                         # => 45    <kinder:note> 厉害这样也可以。
    (5..10).inject(:+)                            # => 45    <kinder:note> 厉害这样也可以。
    # Multiply some numbers            相乘。             
    (5..10).inject(1) {|product, n| product * n } # => 151200
    (5..10).inject(&:*)                           # => 151200
    # find the longest word                寻找最长的词汇。
    longest_word = %w{ cat sheep bear }.inject do |memo, word|
      memo.length > word.length ? memo : word
    end
    longest_word            # => "sheep"
    # find the length of the longest word   寻找最长词汇的长度。
    longest_length = %w{ cat sheep bear }.inject(0) do |memo, word|
      memo >= word.length ? memo : word.length
    end
    longest_length          # => 5

#### lazy 惰性  ⇡New in 2.0⇣  

    enum.lazy → lazy_enum

Returns a lazy enumerator for this enumerable object. 
See the description of lazy enumerators on page 61 for more details.
为这个enumerator对象返回一个惰性的enumerator。
详见前面61页惰性enumerator的细节。

#### map  映射

    enum.map { |obj| … } → array

Synonym for Enumerable#collect.
同Enumerable#collect。

#### max  最大

    enum.max → obj
    enum.max { |a,b| … } → obj

Returns the object in enum with the maximum value. 
返回enum中值最大的对象。
The first form assumes all objects implement <=>; the second uses the block to return a <=> b.
第一种形式假设所有对象实现了<=>方法。第二种使用block来返回a <=> b。


    a = %w(albatross dog horse)
    a.max                                # => "horse"  为什么是这个？ a最小。d次之。h最大。
    a.max {|a,b| a.length <=> b.length } # => "albatross"

#### max_by  根据block最大  1.9

    enum.max_by { |item| … } → obj or enumerator

Passes each item in the collection to the block. 
将集合中的每个项目传递给block。
Returns the item corresponding to the largest value returned by the block. 
根据block返回的最大值返回项目。
Returns an Enumerator object if no block is given.
如果没有给定block，返回Enumerator对象。

    a = %w(albatross dog horse fox)
    a.max_by {|item| item.length } # => "albatross"
    a.max_by {|item| item.reverse } # => "fox"

#### member?  成员

    enum.member?( obj ) → true or false

Synonym for Enumerable#include?.
同Enumerable#include?。

#### min  最小

    enum.min → obj
    enum.min { |a,b| … } → obj

Returns the object in enum with the minimum value. 
返回enum里最小值的对象。
The first form assumes all objects implement Comparable; the second uses the block to return a <=> b.
第一种形式假设所有对象实现了Comparable；第二种形式使用了block来返回a <=> b。

    a = %w(albatross dog horse)
    a.min # => "albatross"
    a.min {|a,b| a.length <=> b.length } # => "dog"

#### min_by  根据block最小 1.9

    enum.min_by { |item| … } → obj or enumerator

Passes each item in the collection to the block. 
将集合中的每个项目传递给block。
Returns the item corresponding to the smallest value returned by the block. 
根据block返回的最小值返回项目。
Returns an Enumerator object if no block is given.
如果没有给定block，返回Enumerator对象。

    a = %w(albatross dog horse fox)
    a.min_by {|item| item.length } # => "dog"
    a.min_by {|item| item.reverse } # => "horse"

#### minmax  最大和最小  1.9

    enum.minmax → [ min, max ]
    enum.minmax { |a,b| … } → [ min, max ]

Compares the elements of enum using either <=> or the given block, returning the minimum and maximum values.
使用<=>或者给定的block比较enum的元素，返回最小和最大的值。

    a = %w(albatross dog horse)
    a.minmax # => ["albatross", "horse"]
    a.minmax {|a,b| a.length <=> b.length } # => ["dog", "albatross"]

#### minmax_by  根据block最大和最小  1.9

    enum.minmax_by { |item| … } → [ min, max ] or enumerator

Passes each item in enum to the block. 
将enum里的每个值传给block。
Returns the items corresponding to the smallest and largest values returned by the block. 
根据block返回的最小和最大值返回项目。
Returns an Enumerator object if no block is given.
如果没有给定block将返回一个Enumerator对象。

    a = %w(albatross dog horse fox)
    a.minmax_by {|item| item.length } # => ["dog", "albatross"]
    a.minmax_by {|item| item.reverse } # => ["horse", "fox"]

#### none?  无  1.9

    enum.none? ‹ { |obj| … } › → true or false

Passes each element of the collection to the given block. 
将集合中的每个元素传递给给定的block。
The method returns true if the block never returns a value other than false or nil. 
如果block从未返回一个非false或非nil的值（全部假值），该方法返回true。
If the block is not given, Ruby adds an implicit block of {|obj| obj} 
如果没有给定block，ruby将增加一个隐式的{|obj| obj} block。
(that is, none? will return false if any of the collection members is not false or nil). 
（即是说，如果集合中任一成员不是false或nil，none?将会返回false）
See also Enumerable#any? and Enumerable#one?.
另见Enumerable#any?和Enumerable#one?

    [ nil, true, 99 ].none? # => false

#### one?  一个  1.9

    enum.one? ‹ { |obj| … } › → true or false

Passes each element of the collection to the given block. 
将集合的每个元素传递给指定的block。
The method returns true if the block returns true exactly one time. 
如果block返回有一次显式地返回true，该方法将返回true。
If the block is not given, Ruby adds an implicit block of {|obj| obj}
如果没有给定block，ruby将添加一个显式的{|obj| obj} block。
(that is, one? will return true if at least one of the collection members is not false or nil). 
（即是说，如果至少一个集合成员不是false或nil，one?将返回true）
See also Enumerable#any? and Enumerable#none?.
另见Enumerable#any?和Enumerable#none?

    [ nil, nil, 99 ].one? # => true

#### partition  区分  1.8

    enum.partition { |obj| … } → [ true_array, false_array ] or enumerator

Returns two arrays, the first containing the elements of enum for which the block evaluates to true and the second containing the rest. 
返回两个数组，第一个数组含有enum中使block为真的元素，第二个数组含有其余的元素。
Returns an Enumerator object if no block is given.
如果没有给定block，返回一个Enumerator对象。

    (1..6).partition {|i| (i&1).zero?} # => [[2, 4, 6], [1, 3, 5]]

#### reduce  减少  1.9

    enum.reduce( initial) { |memo, obj| … } → obj
    enum.reduce( initial, sym ) → obj
    enum.reduce { |memo, obj| … } → obj
    enum.reduce( sym ) → obj


Synonym for Enumerable#inject.
同Enumerable#inject。

#### reject  驳回

    enum.reject { |obj| … } → array or enumerator

Returns an array containing the elements of enum for which block is false (see also `Enumerable#find_all`). 
返回由enum中使block为假的元素组成的数组。（另见`Enumerable#find_all`）
Returns an Enumerator object if no block is given.
如果没有给定block，返回一个Enumerator对象。

    (1..10).reject {|i| i % 3 == 0 } # => [1, 2, 4, 5, 7, 8, 10]

#### reverse_each  倒序遍历 1.9

    enum.reverse_each { |obj| … } → enum

Invokes the block with the elements of enum in reverse order. 
将enum的元素以倒序调用block。
Creates an intermediate array internally, so this might be expensive on large collections. 
在内部创建一个立即数组，所以处理大集合时会比较浪费。
Returns an Enumerator object if no block is given.
如果没有给定block，返回一个Enumerator对象。

    (1..5).reverse_each {|i| print i, " " }
    # produces:
    # 5 4 3 2 1

#### select  选择

    enum.select { |obj| … } → array

Synonym for Enumerable#find_all.
同Enumerable#find_all。

#### slice_before  切片前 1.9   不懂

    enum.slice_before( pattern ) → enumerator
    enum.slice_before( ‹ state › ) { |element, ‹ state › | … } → enumerator

Chunks enum into a set of arrays and returns an enumerator of those arrays. 
将enum分块为一组数组，并返回一个那些数组的enumerator。
A new array is started whenever the next element matches the pattern (using === when the block returns true). 
下一个元素匹配模式时（block返回true时使用===），开始一个新的数组。
Think of this as a generalized String#split method.
可把这个方法当作String#split方法的普通版。

    p DATA.map(&:chomp).slice_before(/\w:/).to_a
    __END__
    colors
      red
      yellow
    pitches
      high
      low
      middle
    # produces:
    # [["colors", "  red", "  yellow", "pitches", "  high", "  low", "  middle"]]

Collapse sequences of three or more consecutive things into first–last.
将三个或多个连续东西的序列放入first-last。

    input = [ 1, 2, 3, 4, 5, 8, 9, 11, 12, 13, 15 ]
    # helper returns its parameter after calling the block
    # 在调用block之后返回它的参数的辅助方法。
    def returning(value)
      yield
      value
    end
    
    State = Struct.new(:last_value)
    # Need to box the value to make it mutable
    # 需要将数值装箱以使它可变动。
    
    # divide the input into runs of consecutive numbers
    # 将输入分割为连续数字的趋向。
    slices = input.slice_before(State.new(input.first)) do |value, state|
      returning(value != state.last_value.succ) do
        state.last_value = value
      end
    end
    p(slices.map do |runs|
    # replace runs of 3 or more with first–last
    # 用first-last替代3个或更多的趋向。
      runs.size < 3 ? runs : "#{ runs.first }-#{ runs.last }"
    end.join(', '))
    # produces:
    # "1-5, 8, 9, 11-13, 15"

#### sort  排序

    enum.sort → array
    enum.sort { |a, b| … } → array

Returns an array containing the items in enum sorted, either according to their own <=> method or by using the results of the supplied block. 
对enum中的元素进行排序，并返回由排序后的元素组成的数组，排序可以用它自己的`<=>`方法，也可以使用给定block的结果。
The block should return -1, 0, or +1 depending on the comparison between a and b. 
根据a和b比较结果block应该返回-1, 0或+1。
See also `Enumerable#sort_by`.
另见`Enumerable#sort_by`。

    (1..10).sort {|a,b| b <=> a} # => [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

#### sort_by  根据排序  1.8

    enum.sort_by { |obj| … } → array

Sorts enum using keys generated by mapping the values in enum through the given block, using the result of that block for element comparison.
使用给定的block对enum中的元素计算的键值进行排序，并使用block的结果进行元素比较。

    %w{ apple pear fig }.sort_by {|word| word.length} # => ["fig", "pear", "apple"]

Internally, `sort_by` generates an array of tuples containing the original collection element and the mapped value. 
`sort_by`在内部生成由原集合元素和映射值的元组所构成的一个数组。
This makes `sort_by` fairly expensive when the keysets are simple.
这使得`sort_by`在键集比较简单时开销较大。

    require 'benchmark'   # <kinder:note> 这个模块用来测试时间。
    a = (1..100000).map {rand(100000)}
    Benchmark.bm(10) do |b|
      b.report("Sort") { a.sort }
      b.report("Sort by") { a.sort_by {|val| val } }
    end
    # produces:
    #          user      system   total       real
    # Sort     0.030000  0.000000 0.030000 (  0.026899)
    # Sort by  0.140000  0.000000 0.140000 (  0.145687)

However, in cases where comparing the keys is a nontrivial operation, the algorithm used by `sort_by` is considerably faster.
然而，在比较键是个特殊操作的情况下，`sort_by`所使用的运算仍是较快的。
`sort_by` can also be useful for multilevel sorts. 
`sort_by`也可用于多级比较。
One trick, which relies on the fact that arrays are compared element by element, is to have the block return an array of each of the comparison keys. 
一个技巧是，让block返回一个由比较键组成的数组，不过这依赖数组是一个元素一个元素进行比较的情况。
For example, to sort a list of words first on their length and then alphabetically, you could write the following:
比如，如果想先根据词的长度排序，再依据字母顺序排序，可以这样实现：

    words = %w{ puma cat bass ant aardvark gnu fish }
    sorted = words.sort_by {|w| [w.length, w] }
    sorted
    # => ["ant", "cat", "gnu", "bass", "fish", "puma", "aardvark"]

Returns an Enumerator object if no block is given.
如果没有给定block，返回一个Enumerator对象。

#### take  截取 1.9

    enum.take( n ) → array

Returns an array containing the first n items from enum.
返回一个包含enum前n个项目的数组。

    (1..7).take(3) # => [1, 2, 3]
    { 'a'=>1, 'b'=>2, 'c'=>3 }.take(2) # => [["a", 1], ["b", 2]]

#### take_while  条件截取

    enum.take_while { |item| … } → array or enumerator

Passes successive items to the block, adding them to the result array until the block returns false or nil. 
将连续的项目传给block，将他们添加到结果数组中，直到block返回false或nil。
Returns an Enumerator object if no block is given.
如果没有给定block，返回一个Enumerator对象。

    (1..7).take_while {|item| item < 3 } # => [1, 2]
    [ 2, 4, 6, 9, 11, 16 ].take_while(&:even?) # => [2, 4, 6]

#### to_a  转为字符串

    enum.to_a(*args) → array

Returns an array containing the items in enum. 
返回由enum中的项组成的数组。
This is done using the each method. 
这使用了each方法。
Any arguments passed to `to_a` are passed to each.
每个传给`to_a`的参数都传给each。

    (1..7).to_a # => [1, 2, 3, 4, 5, 6, 7]
    { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a # => [["a", 1], ["b", 2], ["c", 3]]

#### zip  拉链 1.8

    enum.zip(‹ arg ›+) → array
    enum.zip(‹ arg ›+) { |arr| … } → nil

Converts any arguments to arrays and then merges elements of enum with corresponding elements from each argument. 
将参数转换为数组，然后将enum中的元素和每个参数中对应的元素合并起来。
The result is an array containing the same number of elements as enum. 
结果是一个和enum具有相同数组元素的数组。
Each element is an n-element array, where n is one more than the count of arguments.
其中的每个元素是一个含有n个元素的数组，这里的n比参数个数大1.
If the size of any argument is less than the number of elements in enum, nil values are supplied.
如果任意一个参数的元素个数小于enum的元素个数，则使用nil。
If a block given, it is invoked for each output array; otherwise, an array of arrays is returned.
如果带有block，则以每个输出的数组为参数调用它，否则返回由结果数组组成的数组。

    a = [ 4, 5, 6 ]
    b = [ 7, 8, 9 ]
    (1..3).zip(a, b) # => [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
    [1, 2].zip([3])  # => [[1, 3], [2, nil]]
    (1..3).zip       # => [[1], [2], [3]]



## Enumerator   枚举 1.9
### 概述*
Relies on: each, <=>
依赖：each，<=>

Enumerator allows you to capture the concept of an enumeration as an object. 
枚举允许你将枚举的概念捕获为一个对象。
This allows you to store enumerations in variables, pass them as parameters, and so on.
这允许你在变量中存储枚举，将它们作为参数，等等。

You can also create enumerators with the method `Object#to_enum` (or via its alias, `enum_for`).
你也可以通过`Object#to_enum`方法来创建枚举对象(或通过它的别名`enum_for`)。
By default, these methods look for an each method in the object you’re enumerating, but this can be overridden by passing the name of a method (and possibly parameters to be used) that invokes a block for each item to be enumerated.
默认，这些方法在你要枚举的对象里寻找each方法，但这个可通过传递方法名（和可能使用的参数）调用block对每个项目进行枚举，而被覆写。

    str = "quick brown fox"
    case what_to_process      # set elsewhere to :by_word
    when :by_bytes
      enum = str.to_enum(:each_byte)
    when :by_word
      enum = str.to_enum(:scan, /\w+/)
    end
    enum.each {|item| p item}
    # produces:
    # "quick"
    # "brown"
    # "fox"

### Mixes In  混入
Enumerable:

    all?, any?, 
    chunk, collect, collect_concat, count, cycle, 
    detect, drop, drop_while, 
    each_cons, each_entry, each_slice, each_with_index, each_with_object, entries, 
    find, find_all, find_index, first, flat_map, 
    grep, group_by, 
    include?, inject, 
    lazy, 
    map, max, max_by, member?, min, min_by, minmax, minmax_by, 
    none?, one?, 
    partition, 
    reduce, reject, reverse_each, 
    select, slice_before, sort, sort _by, 
    take, take_while, to_a, 
    zip

### Class Methods 类方法
#### new  新建

    Enumerator.new(‹ size=nil ›) { |yielder| … } → enum

Constructs an enumerator based on the block. 
基于block构建一个枚举。
The block is passed an object of class Enumerator::Yielder. 
block被传到一个Enumerator::Yielder类的对象
You can use the `<<` or yield methods of this yielder to supply values to be returned by the enumerator. 
你可使用`<<`或这个yielder的yield方法来提供值给枚举返回。
This process is performed lazily (similar to the way that fibers can be used to generate sequences).
这个过程可惰性地执行（类似纤程用于普通序列的方式）

    def multiples_of(n)
      Enumerator.new do |yielder|
        number = 0
        loop do
          yielder.yield number
          number += n
        end
      end
    end
    twos = multiples_of(2)
    threes = multiples_of(3)
     5.times do
      puts "#{twos.next} #{threes.next}"
    end
    # produces:
    # 0 0
    # 2 3
    # 4 6
    # 6 9
    # 8 12

⇡New in 2.0⇣
The optional argument specifies the value that will be returned by the size method for this enumerator. 
可选参数指定了这个枚举将被size方法返回的值。
If can be nil (meaning the size cannot be determined), a number, or a proc that returns a number.
它可以是nil（意味着无法确定size），一个数字，或返回一个数组的proc。
（<kinder:note> 这句开头的if应该是it的笔误。）

### Instance Methods 实例方法
#### each  遍历

    enum.each { |item, ...| … } → obj

Calls the block for each item in the enumeration. 
为枚举里的每个项目调用block。
This does not create an intermediate array.
这不会创建一个立即数组。
Instead, the original iterating method (the one used when creating the enumerator) is called, passing it the block passed to this method. 
相反，原iterating方法（创建enumerator时使用的方法）被调用，把传递到这个方法的block传递给它。
The block receives as many parameters as the original method passes.
block接受所有原始方法传递过来的参数。

    enum = (1..10).enum_for(:each_slice, 3)
    enum.each { |item| p item }
    # produces:
    # [1, 2, 3]
    # [4, 5, 6]
    # [7, 8, 9]
    # [10]

Note that because Enumerator defines each and includes Enumerable, all the enumerable methods are available too.
注意因为枚举定义each并包含了Enumerable模块，所有的可枚举方法都可使用。

    enum = "quick brown fox".enum_for(:scan, /\w+/)
    enum.minmax # => ["brown", "quick"]

#### each_with_index  遍历元素和下标

    enum.each_with_index { |item, ..., index| … } → obj

Same as each but appends an index argument when calling the block. 
和each一样，但当调用block时，将一个下标参数追加在后面。
Returns a new Enumerator if no block is given.
如果没有给定block，返回一个新的Enumerator对象。

    enum = (1..10).enum_for(:each_slice, 3)
    enum.each_with_index do |subarray, index|
      puts "#{index}: #{subarray}"
    end
    # produces:
    # 0: [1, 2, 3]
    # 1: [4, 5, 6]
    # 2: [7, 8, 9]
    # 3: [10]

#### each_with_object  遍历对象

    enum.each_with_object( memo ) { |item, memo| … } → memo or enumerator

Calls block for each item in enum, passing it the item and the parameter passed initially to `each_with_object`. 
为enum的每个项目调用block，并将项目和最初传给`each_with_object`的参数传给它。
Returns an Enumerator object if no block is given.
如果没有给定block，返回一个枚举对象。

    animals = %w(cat dog wombat).to_enum
    hash = animals.each_with_object({}) do |item, memo|
      memo[item] = item.upcase.reverse
    end
    hash # => {"cat"=>"TAC", "dog"=>"GOD", "wombat"=>"TABMOW"}

#### feed  饲养

    enum.feed( obj ) → nil

In a normal looping construct, the next keyword can take an optional parameter, which is returned to the code that is controlling the iteration as the value returned by yield. 
在普通的循环结构里，next关键字可带可选的参数，该参数是返回给代码，而代码在值被yield返回控制迭代。
enum.feed does the same thing for enumerators, setting the value returned by yield in the underlying enumerable to obj.
enum.feed为枚举做同样的事情，将潜在枚举里yield返回的值设置给obj。
<kinder:note> 不懂。

#### next  下一个

    enum.next → obj

Returns the next item in the enumeration. 
如果你在最后一个项目之后调用它，将抛出一个StopIteration。
Raises StopIteration if you call it past the last item.
返回下一个enumeration项目。
Internally this is implemented using fibers and so cannot be called across threads. 
这在内部是使用纤程实现的，所以不能被跨线程调用。
See also Enumerator.next_values.
另见Enumerator.next_values。

    array = [ 1, 2, 3, 4 ]
    e1 = array.to_enum
    e2 = array.to_enum
    e1.next # => 1
    e1.next # => 2
    e2.next # => 1

If the underlying method called by the enumerator has side effects (such as moving your position while reading a file), those side effects will be triggered. 
如果被enumerator调用的覆盖方法有些副作用（比如读取一个文件时移动你的位置），那些副作用将会被触发。
For this reason, next breaks the abstraction provided by Enumerator.
因为这个原因，next将破坏Enumerator提供的抽象。

    f = File.open("testfile")
    enum1 = f.to_enum(:each_byte)
    enum2 = f.to_enum
    enum1.next # => 84
    enum1.next # => 104
    enum2.next # => "is is line one\n"
    f.gets # => "This is line two\n"
    enum2.next # => "This is line three\n"

#### next_values  下一个值

    enum.next_values → array

Enumerator.next returns successive values yielded by enum. 
Enumerator.next 返回enum所产生的连续值。
However, it effectively uses raw proc semantics and so is unable to distinguish the case when the iterator yields nil and the case where the yield is passed no parameter. 
不过，它实际上使用原生proc语义，所以不能区分迭代器产生nil和yield没有传入参数的情况。
Similarly, it cannot distinguish yield 1,2 from yield [1,2]—both are received as [1,2]. 
相似的，它也不能区分yield 1,2 和 yield [1,2] -- 两者都接受为[1,2]。

`next_values` overcomes this by always returning an array, and that array contains exactly what was passed to the yield.
`next_values`改进了这个，通过总是返回一个数组，该数组只包含传递给yield的东西。

    def each
      yield 1
      yield nil
      yield 2, 3
      yield [4,5]
    end
    enum = to_enum
    enum.next # => 1
    enum.next # => nil
    enum.next # => [2, 3]
    enum.next # => [4, 5]
    
    enum = to_enum
    enum.next_values # => [1]
    enum.next_values # => [nil]
    enum.next_values # => [2, 3]
    enum.next_values # => [[4, 5]]

#### peek  瞥看

    enum.peek → obj

Returns the value that would be returned by calling next but does not consume that value.
返回值，该值可被next调用返回，但不消耗
Raises a StopIteration exception if called past the end of enum.
如果调用超出了enum将抛出StopIteration异常。

    enum = %w{ ant bee cat }.to_enum
    enum.peek # => "ant"
    enum.peek # => "ant"
    enum.next # => "ant"
    enum.peek # => "bee"

#### peek_values  瞥看值

    enum.peek_values → array

Returns the value that would be returned by calling `next_values`.
返回值，该值可被`next_values`调用所返回。

#### rewind  重绕（返回第一个）

  enum.rewind → enum

Resets the sequence of values to be returned by next.
重设next返回的序列值。

    array = [ 1, 2, 3, 4 ]
    e1 = array.to_enum
    e2 = array.to_enum
    e1.next # => 1
    e1.next # => 2
    e2.next # => 1
    e1.rewind
    e1.next # => 1
    e2.next # => 2

Has no effect if the underlying method of the enumerator has side effects and therefore cannot be rewound.
如果枚举的潜在方法有副作用，则无法重绕。

#### size  长度         ⇡New in 2.0⇣

    enum.size → int or nil

Returns the size of this collection, or nil if the size cannot be calculated (this may or may not be the case with a lazy enumerator).
返回集合的长度。如果不能计算长度则返回nil（在惰性枚举的情况下可能就是这样）。

    File.open("/etc/passwd").to_enum.size # => nil    <kinder:note> 这么奇怪，文件大小不是确定的吗？
    (1..Float::INFINITY).size             # => Infinity
    loop.size                             # => Infinity
    (1..10).find.size                     # => nil

#### with_index  遍历元素和下标

    enum.with_index { |item, ..., index| … } → obj

Synonym for `each_with_index`.
同`each_with_index`。

#### with_object  遍历对象

    enum.with_object( memo ) { |item, memo| … } → memo or enumerator

Synonym for `each_with_object`.
同`each_with_object`。


## Module  Errno   数字错误模块
Ruby exception objects are subclasses of Exception. 
Ruby异常对象是Exception的子类。
However, operating systems typically report errors using plain integers. 
然而，操作系统通常使用单纯的整数来报告错误。
Module Errno is created dynamically to map these operating system errors to Ruby classes, with each error number generating its own subclass of SystemCallError. 
ruby动态创建Errno模块以映射操作系统错误到ruby类，且每个错误号都对应产生SystemCallError的一个子类。
Because the subclass is created in module Errno, its name will start Errno::.
因为子类是在模块Errno中创建的，所以它的名字以`Errno::`开头。

    Exception
      StandardError
        SystemCallError
          Errno::XXX

The names of the Errno:: classes depend on the environment in which Ruby runs. 
Errno::类的名字依赖于ruby运行的环境。
On a typical Unix or Windows platform, you’ll find Ruby has Errno classes such as Errno::EACCES, Errno::EAGAIN, Errno::EINTR, and so on.
在典型的Unix或Windows平台上，你会看到ruby有Errno::EACCES, Errno::EAGAIN, Errno::EINTR等类。

The integer operating system error number corresponding to a particular error is available as the class constant Errno::error::Errno.
某个具体错误对应的整数操作系统错误号可以从常量Errno::error::Errno中获得。

    Errno::EACCES::Errno # => 13
    Errno::EAGAIN::Errno # => 35
    Errno::EINTR::Errno # => 4

The full list of operating system errors on your particular platform is available as the constants of Errno. 
你平台上的操作系统错误的完整列表可以从Errno的常量中获得。
Any user-defined exceptions in this module (including subclasses of existing exceptions) must also define an Errno constant.
这个模块（包括已有异常的子类）中用户自定义的任意异常也必须定义一个Errno常量。

    Errno.constants[0..4] # => [:NOERROR, :EPERM, :ENOENT, :ESRCH, :EINTR]

As of Ruby 1.8, exceptions are matched in rescue clauses using Module#===. 
在ruby 1.8中，在rescue语句中使用Module#===来匹配异常。
The === method is overridden for class SystemCallError to compare based on the Errno value. 
SystemCallError类重载了===方法以基于Errno值进行比较。
Thus, if two distinct Errno classes have the same underlying Errno value, they will be treated as the same exception by a rescue clause.
这样，如果两个不同的Errno类内部有相同的Errno值，那么rescue语句会将它们当作同一个异常对待。

## Exception  例外
### 概述
Descendents of class Exception are used to communicate between raise methods and rescue statements in begin/end blocks. 
Exception类的子类被用来在raise方法和begin/end的block中的rescue语句间进行通信。
Exception objects carry information about the exception—its type (the exception’s class name), an optional descriptive string, and optional traceback information.
Exception对象含有关于异常的信息-- 它的类型（异常类的名字），一个可选的描述性的字符串和一个可选的追踪信息。

The standard library defines the exceptions shown in Figure 1, Standard exception hierarchy, on page 146. 
标准库定义的异常在前面146页的Figure 1, Standard exception hierarchy中显示。
Note that Ruby 1.9 has changed the hierarchy slightly. 
注意ruby 1.9稍微改变了层级。
In particular, SecurityError is no longer a subclass of StandardError and so will not be rescued implicitly.
特别是，SecurityError不再是StandardError的子类，所以不会隐式地rescue。

See also the description of Errno on page 482.
另见前面Errno的描述。

### Class Methods 类方法
#### exception  例外

    Exception.exception( ‹ message › ) → exc

Creates and returns a new exception object, optionally setting the message to message.
创建并返回一个新的异常对象，如果有message参数，则设置异常消息为message。

#### new  新建

    Exception.new( ‹ message › ) → exc

Creates and returns a new exception object, optionally setting the message to message.
创建并返回一个新的异常对象，如果有message参数，则设置异常消息为message。

### Instance Methods 实例方法
#### ==  比较信息和追踪 1.9

    exc == other → true or false

Returns true only if other shares the same message and backtrace as exc.
只有在other的消息和跟踪和exc异常时才返回true。

#### backtrace  追踪

    exc.backtrace → array

Returns any backtrace associated with the exception. 
返回与例外相关的任何追踪。
The backtrace is an array of strings, each containing either filename:line: in ‘method’ or filename:line.
追踪是字符串数组，每个元素包含：文件名:行号:in ‘方法’或这文件名:行号。

    def a
      raise "boom"
    end
    def b
      a()
    end
    begin
      b()
    rescue => detail
      print detail.backtrace.join("\n")
    end
    # produces:
    # prog.rb:2:in `a'
    # prog.rb:5:in `b'
    # prog.rb:8:in `<main>'

#### exception  异常

    exc.exception( ‹ message › ) → exc or exception

With no argument, returns the receiver. 
如果没有参数，返回接收者。
Otherwise, creates a new exception object of the same class as the receiver but with a different message.
否则，创建一个新的异常对象，它和接收者属于相同的类，但所含消息不同。

#### message  消息

    exc.message → msg

Returns the message associated with this exception.
返回与异常对应的消息。

#### set_backtrace  设置追踪

    exc.set_backtrace( array ) → array

Sets the backtrace information associated with exc. 
设置和exc想关联的追踪信息。
The argument must be an array of String objects in the format described in Exception#backtrace.
参数必须是由符合Exception#backtrace所描述的格式的String对象组成的数组。

#### status  退出状态 1.8

    exc.status → status

(SystemExit only.) Returns the exit status associated with this SystemExit exception. 
（只用于SystemExit）返回和SystemExit异常相联系的退出状态。
Normally this status is set using the Object#exit.
通常这个状态是由Object#exit设置的。

    begin
      exit(99)
    rescue SystemExit => e
      puts "Exit status is: #{e.status}"
    end
    # produces:
    # Exit status is: 99

#### success?  成功吗 1.8

    exc.success? → true or false

(SystemExit only.) Returns true if the exit status is nil or zero.
(仅在SystemExit中提供)如果退出状态为nil或0,返回true。

    begin
      exit(99)
    rescue SystemExit => e
      print "This program "
      if e.success?
        print "did"
      else
        print "did not"
      end
      puts " succeed"
    end
    # produces:
    # This program did not succeed

#### to_s  消息

    exc.to_s → msg

Returns the message associated with this exception (or the name of the exception if no message is set).
返回和异常相关的消息（如果没有设置消息，则返回异常的名字）。

    begin
      raise "The message"
    rescue Exception => e
      puts e.to_s
      # This is the same as the previous puts
      # 这个和前面的puts一样。
      puts e
    end
    # produces:
    # The message
    # The message


## FalseClass  错误类
The global value false is the only instance of class FalseClass and represents a logically false value in boolean expressions. 
全局值false是FalseClass类的唯一实例，在逻辑（布尔）表达式上它表示逻辑假。
The class provides operators allowing false to participate correctly in logical expressions.
这个类提供了操作符以使false可以正确用在逻辑表达式上。

### Instance Methods 实例方法
#### &  位与

    false & obj → false

And—Returns false. 
与--返回fasle。
obj is always evaluated because it is the argument to a method call—no short-circuit evaluation is performed in this case. 
因为obj是方法调用的参数，所以总会计算它的值--在这种情况下不遵守短路运算法则。
In other words, the following code, which uses &&, will not invoke the lookup method.
换句话说，下面列出的使用&&的代码不会调用lookup方法。

    def lookup(val)
      puts "Looking up #{val}"
      return true
    end
    false && lookup("cat")

However, this code, using &, will:
然而，如果在这段代码中使用&，则将会：

    false & lookup("cat")
    # produces:
    # Looking up cat
    # <kinder:note> 这不是相反吗？本来这个是返回false的。不懂！

#### ^  位异或

    false ^ obj → true or false

Exclusive Or—If obj is nil or false, returns false; otherwise, returns true.
异或--如果obj是nil或false，则返回false，否则返回true。

#### |  位或

    false | obj → true or false

Or—Returns false if obj is nil or false; true otherwise.
或--如果obj是nil或false，则返回false；否则返回true。


## Fiber  纤程  1.9
### 概述
A fiber is a lightweight asymetrical coroutine. 
纤程是一个轻量级的不对称协同程序。
Code in a fiber is created in a suspended state.
纤程里的代码在挂起状况下被创建。

It runs when resumed and can suspend itself (passing a value back to the code that resumed it). 
当恢复时它运行，并能自己挂起（传递一个值回到恢复它的代码中。)。
There is a full description of fibers in Section 12.1, Fibers, on page 161.
纤程的全部描述在前面161页12.1 纤程中。

    fibonaccis = Fiber.new do
      n1 = n2 = 1
      loop do
        Fiber.yield n1
        n1, n2 = n2, n1+n2
      end
    end
    10.times { print fibonaccis.resume, ' ' }
    # produces:
    # 1 1 2 3 5 8 13 21 34 55

### Class Methods 类方法
#### new  新建

    Fiber.new { … } → fiber

Uses the block as a new, suspended fiber.
使用block作为一个新的挂起的纤程。

#### yield  产生

    Fiber.yield( ‹ val ›* ) → obj

Suspends execution of the current fiber. 
挂起当前纤程的执行。
Any parameters will be returned as the value of the resume call that awoke the fiber. 
任何参数将会返回作为唤醒纤程的resume调用的值。
Similarly, any values passed to resume will become the return value of the subsequent yield.
类似的，任何传递给resume的值将变成并发yield的返回值。

    f = Fiber.new do |first|
      print first
      letter = "A"
      loop do
        print Fiber.yield(letter)
        letter = letter.succ
      end
    end
    10.times { |number| print f.resume(number) }
    # produces:
    # 0A1B2C3D4E5F6G7H8I9J


### Instance Methods 实例方法
#### resume  重开 ⇡New in 2.0⇣

    fiber.resume( ‹ val ›* ) → obj

Resumes fiber. 
重开纤程。
See Fiber.yield for a discussion and example of parameter passing. 
参见Fiber.yield里面对参数传递的讨论和例子。
It is an error to resume a fiber that is being used as a coroutine (one that calls transfer). 
当纤程被用作协同程序(那会调用transfer)时，重开一个纤程会出现错误。
See Fiber, on page 755.
看后面755页的Fiber。


## File < IO  文件
### 概述
A File is an abstraction of any file object accessible by the program and is closely associated with class IO, described later on page 536. 
File是可以被程序访问的任何文件对象的抽象，它和后面4版536页2版503页描述的IO类紧密相关。
File includes the methods of module FileTest as class methods, allowing you to write (for example) File.exist?("foo").
File包含了模块FileTest的方法作为其类方法，这时你可以编写（例如）这样的代码File.exit?("foo")。

Files may be opened in binary mode (where the contents are transferred as 8-bit bytes in binary encoding) or text mode (where the contents are interpreted as codepoints in a particular encoding). 
文件可以在二进制模式（内容被转化为8比特的二进制编码）或文本模式（内容被编译为特定编码的代码点）下被打开。

These options are controlled by the mode parameter when a file is opened.
这些选项是文件打开时mode(模式)参数控制的。

Each file has three associated times: atime is the time the file was last accessed, ctime is the time that the file status (not necessarily the file contents) were last changed, and mtime is the time the file’s data was last modified. 
每个文件都有三个相关的时间：atime是文件最后被访问的时间。ctime是文件状态（不必是文件的内容）最后被改变的时间。最后mtime是文件数据最后被修改的时间。
In Ruby, all these times are returned as Time objects.
在ruby，所有这些时间都作为Time对象返回。

In this section, permission bits are a platform-specific set of bits that indicate permissions of a file. 
在本节中，权限位是和平台相关的、表明文件访问权限的位。
On Unix-based systems, permissions are viewed as a set of three octets, for the owner, the group, and the rest of the world. 
在基于Unix的系统上，权限位被认为是3个8位的字节，分别表示拥有者、组和其他人对文件的访问权限。
For each of these entities, permissions may be set to read, write, or execute the file.
对于每个访问者，文件的访问权限可以设置为读、写或执行。

    Owner            Group         Other
    r    w    x      r   w   x     r  w  x
    400  200  100    40  20  10    4  2  1

The permission bits 0644 (in octal) would thus be interpreted as read/write for owner and read-only for group and other. 
权限位0644（八进制）会被解释为允许文件的拥有者读写，组成员和其他人只读。
Higher-order bits may also be used to indicate the type of file (plain, directory, pipe, socket, and so on) and various other special features. 
高位可以用来表示文件的类型（普通文件、目录、管道、socket等）和其他特殊意义。
If the permissions are for a directory, the meaning of the execute bit changes; when set, the directory can be searched.
如果权限是为目录设置的，那么执行位的含义变为：如果设置，则该目录可以被搜索。

Non-POSIX operating systems may not support the full set of possible permissions. 
在非POSIX系统上，只能标志文件为只读或读/写。
In this case, the remaining permission bits will be synthesized to resemble typical values. 
在这种情况下，其余的权限位将被合成相似的典型值。
For instance, on Windows the default permission bits are 0644, which means read/write for owner and read-only for all others. 
例如在windows上默认权限位是0644,这意味着文件主可以读/写，而其他人只读。
The only change that can be made is to make the file read-only, which is reported as 0444.
唯一可做的改动是使文件只读，权限位对应的是0444.

The constant File::NULL is the name of your system’s null device. 
Reading from it returns endof-file, and writing to it is ignored.
常数File::NULL是系统位桶的名字。
从中读取会返回endof-file，写入则会被忽略。

See also Pathname on page 787 and IO on page 536.
另见后面2版714页4版787页的Pathname和后面536页的IO。

### Class Methods 类方法
#### absolute_path  绝对路径

    File.absolute_path( filename ‹ , dirstring › ) → filename

Converts a path to an absolute path. 
将一个路径转化为绝对路径。
Relative paths are referenced from the current working directory of the process unless dirstring is given, in which case it will be used as the starting point. 
相对路径是相对于进程的当前工作目录的，除非给定了dirstring，在这种情况下会用它作为开始点。
Path names starting with ~ are not expanded, in contrast with `File#expand_path`.
用～开始的路径名不会被扩展，应该用`File#expand_path`。

    puts File.absolute_path("bin")
    puts File.absolute_path("../../bin", "/tmp/x")
    # produces:
    # /Users/dave/BS2/published/ruby4/Book/bin
    # /bin

#### atime  最后访问时间

    File.atime( filename ) → time

Returns a Time object containing the last access time for the named file or returns epoch if the file has not been accessed.
返回一个包含所有文件最后访问时间的Time对象，如果文件没有被访问过，则返回纪元时间。

    File.atime("testfile") # => 2013-05-27 12:32:02 -0500

#### basename  基本文件名   1.8

    File.basename( filename ‹ , suffix › ) → string

Returns the last component of the filename given in filename. 
返回给定文件名filename的最后一部分。
If suffix is given and is present at the end of filename, it is removed. 
如果有suffix参数，且出现在filename的末尾，则它将被删除。
Any extension can be removed by giving an extension of `.*`.
通过使用`.*`可以去除任意扩展名。

    File.basename("/home/gumby/work/ruby.rb") # => "ruby.rb"
    File.basename("/home/gumby/work/ruby.rb", ".rb") # => "ruby"
    File.basename("/home/gumby/work/ruby.rb", ".*") # => "ruby"

#### blockdev?   块设备文件

    File.blockdev?( filename ) → true or false

Returns true if the named file is a block device and returns false if it isn’t or if the operating system doesn’t support this feature.
如果给定的文件是块设备，则返回true；如果不是或操作系统不支持，则返回false。

    File.blockdev?("testfile") # => false

#### chardev?  字符设备文件

    File.chardev?( filename ) → true or false

Returns true if the named file is a character device and returns false if it isn’t or if the operating system doesn’t support this feature.
如果给定文件是字符设备，返回true；如果不是或操作系统不支持此特性，返回false。

    File.chardev?("/dev/tty") # => true

#### chmod  改变权限

    File.chmod( permission ‹ , filename ›+ ) → int

Changes permission bits on the named file(s) to the bit pattern represented by permission.
将指定文件的权限位改为permission。
Actual effects are operating system dependent (see the beginning of this section). 
实际效果依赖于操作系统（参见本节开头）。
On Unix systems, see chmod(2) for details. 
在Unix系统上，详见chmod(2)。
Returns the number of files processed.
返回被处理的文件的个数。

    File.chmod(0644, "testfile", "some_other_file") # => 2

#### chown  改变拥有者

    File.chown( owner, group ‹ , filename ›+ ) → int

Changes the owner and/or group of the named file(s) to the given numeric owner and group IDs. 
将给定文件的所有者和/或所属的组改为给定数字表示的所有者和组ID。
Only a process with superuser privileges may change the owner of a file. 
仅具有超级权限的进程可以改变文件的所有者。
The current owner of a file may change the file’s group to any group to which the owner belongs. 
文件当前的拥有者可以改变文件的组为拥有者所属的任何组。
A nil or -1 owner or group ID is ignored. 
如果拥有者或组ID为nil或-1，它们将被忽略。
Returns the number of files processed.
返回被处理文件的个数。

    File.chown(nil, 100, "testfile")

#### ctime  最后修改状态时间

    File.ctime( filename ) → time

Returns a Time object containing the time that the file status associated with the named file was changed.
返回一个含有给定文件最后状态修改时间的Time对象。

    File.ctime("testfile") # => 2013-05-27 12:32:04 -0500

#### delete  删除

    File.delete( ‹ filename ›+ ) → int

Deletes the named file(s). 
删除给定文件。
Returns the number of files processed. 
返回被处理的文件的个数。
See also Dir.rmdir.
参见Dir.rmdir。

    File.open("testrm", "w+") {}
    File.delete("testrm") # => 1

#### directory?  是否目录

    File.directory?( path ) → true or false

Returns true if the named file is a directory; returns false otherwise.
如果给定的文件是目录，返回true，否则返回false。

    File.directory?(".") # => true

#### dirname  目录名

    File.dirname( filename ) → filename

Returns all components of the filename given in filename except the last one.
返回给定文件filename中除了最后一部分的其余部分。

    File.dirname("/home/gumby/work/ruby.rb") # => "/home/gumby/work"
    File.dirname("ruby.rb") # => "."

#### executable?  是否可执行文件

    File.executable?( filename ) → true or false

Returns true if the named file is executable. 
如果给定文件是可执行文件，返回true。
The tests are made using the effective owner of the process.
该方法用进程的有效拥有者来实现测试。

    File.executable?("testfile") # => false

#### executable_real?  是否真实可执行

    File.executable_real?( filename ) → true or false

Same as File#executable? but tests using the real owner of the process.
和File#executable?一样，但使用进程的真实拥有者来进行测试。

#### exist?  是否存在

    File.exist?( filename ) → true or false

Returns true if the named file or directory exists.
如果给定文件或目录存在，返回true。

    File.exist?("testfile") # => true

#### exists?  是否存在

    File.exists? ( filename ) → true or false

Synonym for File.exist?.
同File.exist?。

#### expand_path  扩展路径

    File.expand_path( filename ‹ , dirstring › ) → filename

Converts a path name to an absolute path name. 
转化路径名为绝对路径。
Relative paths are referenced from the current working directory of the process unless dirstring is given, in which case it will be used as the starting point. 
除非有dirstring参数，相对路径是相对于进程的工作目录而言的，如果给定了dirstring，那么它将作为路径的起点。
The given path name may start with a ~, which expands to the process owner’s home directory (the environment variable HOME must be set correctly). 
给定的路径可能以～开头，它将被扩展为进程主人的主目录（环境变量HOME必须设置正确）。
~user expands to the named user’s home directory. 
~user扩展为给定用户的主目录。
See also `File#absolute_path`.
另见`File#absolute_path`。

    File.expand_path("~/bin") # => "/Users/dave/bin"
    File.expand_path("../../bin", "/tmp/x") # => "/bin"

#### extname  扩展名 1.8

    File.extname( path ) → string

Returns the extension (the portion of filename in path after the period).
返回扩展名（文件path中句点后面的部分）。

    File.extname("test.rb") # => ".rb"
    File.extname("a/b/d/test.rb") # => ".rb"
    File.extname("test") # => ""

#### file?  是否文件

    File.file?( filename ) → true or false

Returns true if the named file is a regular file (not a device file, directory, pipe, socket, and so on).
如果给定的文件是一个普通文件（不是设备文件、目录、管道、Socket等等），则返回true。

    File.file?("testfile") # => true
    File.file?(".") # => false

#### fnmatch  路径匹配

    File.fnmatch( glob_pattern, path, ‹ flags › ) → true or false

Returns true if path matches against `glob_pattern`. 
如果path和`glob_pattern`匹配，则返回true。
The pattern is not a regular expression; instead, it follows rules similar to shell filename globbing. 
这里的模式不是正则表达式，不过它遵从类似shell文件名通配符的规则。

A `glob_pattern` may contain the following metacharacters.
一个`glob_pattern`可以包含如下元字符。
*
Matches zero or more characters in a file or directory name.
匹配文件或目录名的0个或多个字符。
**
Matches zero or more characters, ignoring name boundaries. 
匹配0个或多个字符，忽略名字边界。
递归式匹配子目录。
Most often used to scan subdirectories recursively.
最常用于递归扫描子目录。
?
Matches any single character.
匹配任意单个字符。
[ charset ] 
Matches any character from the given set of characters. 
匹配给定字符集合中的任意一个字符。
A range of characters is written as from-to. 
字符范围可以写作from-to的形式。
The set may be negated with an initial caret (^).
如果开头有个脱字符（），表示不是此集合中的任意字符。
\
Escapes any special meaning of the next character.
转义下一个字符的特殊含义。

flags is a bitwise OR of the `FNM_xxx` constants.
flags可以是本页列出的`FNM_xxx`常数的位或：
`FNM_EXTGLOB`
Expand braces in the pattern. (new in ⇡2.0⇣)
扩展模式中的花括号。
`FNM_NOESCAPE`
A backslash does not escape special characters in globs, and a backslash in the pattern must match a backslash in the filename.
反斜线不会转义glob的特殊字符，模式里的反斜线匹配文件名里的反斜线。
`FNM_PATHNAME`
Forward slashes in the filename are treated as separating parts of a path and so must be explicitly matched in the pattern.
文件名里的正线杠被当作路径的独立部分，必须在模式里显式匹配。
<kinder:note> ？？？
`FNM_DOTMATCH`
If this option is not specified, filenames containing leading periods must be matched by an explicit period in the pattern. 
如果没有指定这个选项，前置句点的文件名匹配模式的显式句点。
<kinder:note> 也就是说有了这个标志，不再匹配显式句点。
A leading period is one at the start of the filename or (if `FNM_PATHNAME` is specified) following a slash.
前置句点是文件名开始处的句点或(如果指定了`FNM_PATHNAME`)跟在一个斜线后面。
`FNM_CASEFOLD`
Filename matches are case insensitive.
文件名匹配时不区分大小写。

See also Dir.glob on page 458.
另见前面2版451页4版458页的Dir.glob

    File.fnmatch('cat', 'cat')       # => true
    File.fnmatch('cat', 'category')  # => false

    File.fnmatch('c?t', 'cat')       # => true
    File.fnmatch('c\?t','cat')       # => false
    File.fnmatch('c??t',   'cat')    # => false                 

    File.fnmatch('c*',     'cats')                       # => true
    File.fnmatch('c/**/t', 'c/a/b/c/t')                  # => true
    File.fnmatch('c**t',   'c/a/b/c/t')                  # => true
    File.fnmatch('c**t',   'cat')                        # => true
    File.fnmatch('**.txt', 'some/dir/tree/notes.txt')    # => true
    File.fnmatch('c*t',    'cat')                        # => true

    File.fnmatch('c\at',   'cat')                        # => true
    File.fnmatch('c\at',   'cat', File::FNM_NOESCAPE)    # => false
    File.fnmatch('a?b',    'a/b')                        # => true
    File.fnmatch('a?b',    'a/b', File::FNM_PATHNAME)    # => false
    
    File.fnmatch('*', '.profile')                             # => false
    File.fnmatch('*', '.profile', File::FNM_DOTMATCH)         # => true   
    File.fnmatch('*', 'dave/.profile')                        # => true   
    File.fnmatch('*', 'dave/.profile', File::FNM_DOTMATCH)    # => true   
    File.fnmatch('*', 'dave/.profile', File::FNM_PATHNAME)    # => false
    File.fnmatch('*/*', 'dave/.profile', File::FNM_PATHNAME)  # => false   <kinder:note> 还需要File::FNM_DOTMATCH标志
    STRICT = File::FNM_PATHNAME | File::FNM_DOTMATCH                      
    File.fnmatch('*/*', 'dave/.profile', STRICT)              # => true   

#### fnmatch?  是否匹配  1.8

    File.fnmatch?( glob_pattern, path, ‹ flags › ) → (true or false)

Synonym for File#fnmatch.
同File#fnmatch。

#### ftype  文件类型

    File.ftype( filename ) → filetype

Identifies the type of the named file. 
确定给定文件的类型。
The return string is one of file, directory, characterSpecial, blockSpecial, fifo, link, socket, or unknown.
返回的字符串可以是file, directory, characterSpecial, blockSpecial, fifo, link, socket, 或unknown。

    File.ftype("testfile")  # => "file"
    File.ftype("/dev/tty")  # => "characterSpecial"
    system("mkfifo wibble") # => true
    File.ftype("wibble")    # => "fifo"

#### grpowned?  是否同组

    File.grpowned?( filename ) → true or false

Returns true if the effective group ID of the process is the same as the group ID of the named file. 
如果进程的有效组ID和给定文件的组ID相同，返回true。
On Windows, returns false.
在 Windows上返回false。

    File.grpowned?("/etc/passwd") # => false

#### identical?  是否同一文件

    File.identical?( name1, name2 ) → true or false

Returns true only if name1 and name2 refer to the same file. 
只有name1和name2指向同一文件时才返回true。
Two separate files with the same content are not considered to be identical.
两个不同文件虽然内容一样，也不会被看作同一文件。

    File.identical?("testfile", "./code/../testfile") # => true
    File.symlink("testfile", "wibble")                
    File.identical?("testfile", "wibble")             # => true
    File.link("testfile", "wobble")                   
    File.identical?("testfile", "wobble")             # => true
    File.identical?("wibble", "wobble")               # => true

#### join  连接

    File.join( ‹ string ›+ ) → filename

Returns a new string formed by joining the strings using File::SEPARATOR. 
使用File::SEPARATOR连接字符串，并返回一个新的字符串。
The various separators are as follows:
分隔符有：
`ALT_SEPARATOR`
Alternate path separator (\ on Windows, nil otherwise)
其他路径分隔符（\在Windows，其他的是nil）
`PATH_SEPARATOR`
Separator for filenames in a search path (such as : or ;)
在搜索路径中文件名分隔符（例如：或者；）
SEPARATOR
Separator for directory components in a filename (such as \ or /)
文件名中路径分隔符（例如\或/）
Separator
Alias for SEPARATOR
SEPARATOR的别名。

    File.join("usr", "mail", "gumby") # => "usr/mail/gumby"

#### lchmod  符号链接模式  1.8

    File.lchmod( permission, ‹ filename ›+ ) → 0

Equivalent to File.chmod but does not follow symbolic links (so it will change the permissions associated with the link, not the file referenced by the link). 
等价于File.chmod，但不跟随符号连接（所以它会改变符号连接文件本身的权限，而不是链接所指向的文件的权限）。
Often not available.
通常不用。

#### lchown  符号链接所有者   1.8

    File.lchown( owner, group, ‹ filename ›+ ) → 0

Equivalent to File.chown but does not follow symbolic links (so it will change the owner associated with the link, not the file referenced by the link). 
等同于File.chown，但不跟随符号链接（所以它会改变符号连接文件本身的权限，而不是链接所指向的文件的权限）。
Often not available.
通常不用。

#### link  创建硬链接

    File.link( oldname, newname ) → 0

Creates a new name for an existing file using a hard link. 
使用硬链接为已有文件创建一个新的名字。
Will not overwrite newname if it already exists (in which case link raises a subclass of SystemCallError). 
如果新名字newname已经存在，则不会覆盖它（在这个情况下link会引发一个SystemCallError的子类的一个错误）。
Not available on all platforms.
不是在所有平台上可用。

    File.link("testfile", "testfile.2") # => 0
    f = File.open("testfile.2")
    f.gets # => "This is line one\n"
    File.delete("testfile.2")

#### lstat  状态信息

    File.lstat( filename ) → stat

Returns status information for file as an object of type File::Stat. 
以File::Stat类型的对象返回文件file的状态信息。
Same as IO#stat on page 554 but does not follow the last symbolic link. 
和2版513页4版554页的IO#stat一样，但不跟随符号链接。
Instead, reports on the link itself.
相反，它报告链接文件的信息。

    File.symlink("testfile", "link2test") # => 0
    File.stat("testfile").size            # => 66
    File.lstat("link2test").size          # => 8
    File.stat("link2test").size           # => 66

#### mtime  最后修改时间

    File.mtime( filename ) → time

Returns a Time object containing the modification time for the named file.
返回一个包含文件被修改时间的Time对象。

    File.mtime("testfile") # => 2013-05-16 20:00:29 -0500
    File.mtime("/tmp") # => 2013-05-27 11:52:10 -0500

#### new  新建文件

    File.new( filename, mode="r" ‹ , permission › ‹ options › ) → file
    File.new( integer_fd ‹ , mode ‹ , options ›› ) → file

If the first parameter is an integer (or can be converted to an integer using to_int), it is the file descriptor or an already-open file. 
如果第一个参数是个整数（或者可以使用to_int转化为整数）,该数是个文件描述符或一个已经打开的文件。
In that case, the call is passed to IO.new for processing.
在那种情况，调用被传到IO.new进行处理。

More commonly, opens the file named by filename according to mode (the default is "r") and returns a new File object. 
更一般的情况是，根据模式（默认r）打开名为filename的文件并返回一个新的File对象。
The mode contains information on the way the file is to be opened and optionally on the encodings to be associated with the file data. 
模式mode包含文件被打开方式的信息，可选的还有文件数据相关的编码信息。
Modes are most commonly represented as a string but can be expressed as an integer. 
模式mode最常表示为一个字符串，但也可表达为一个整数。
Mode strings have the form filemode[:external-encoding[:internal-encoding]]". 
模式字符串的形式是：`文件模式[:外部编码[:内部编码]]`
The file-mode portion is one of the options listed in the following table. 
文件模式部分是下面表格所列出的选项。
The two encodings are the names (or aliases) of encodings supported by your interpreter. 
两种编码是你的解释器所支持的编码名字（或别名）。
See Chapter 17, Character Encoding, on page 239 for more information.
详见前面239页第17章Character Encoding。

Table 16—Mode values 表格16--模式值
**r**
Read-only, starts at beginning of file (default mode).
只读，在文件开头开始（默认模式）。
**r+**
Read/write, starts at beginning of file.
读写，在文件开头开始（默认模式）。
**w**
Write-only, truncates an existing file to zero length or creates a new file for writing.
只写，将已存文件截断为长度0(即清空)，或创建一个新的文件来写入。
**w+** 
Read/write, truncates existing file to zero length or creates a new file for reading and writing.
读写，将已存文件截断为长度0(即清空)，或创建一个新的文件来写入。
**a**
Write-only, starts at end of file if file exists; otherwise, creates a new file for writing.
只写，如果文件存在，则在文件结尾处写入；否则创建一个新文件来写入。
**a+** 
Read/write, starts at end of file if file exists; otherwise, creates a new file for reading and writing.
读写，如果文件存在，则在文件结尾处写入；否则创建一个新文件来写入。
**b**
Binary file mode (may appear with any of the key letters listed earlier). 
二进制文件模式（可以和前面列出的任意关键字一起出现）。
As of Ruby 1.9, this modifier should be supplied on all ports opened in binary mode (on Unix as well as on DOS/Windows). 
在ruby 1.8,应在所有以二进制模式打开的端口上提供这个修饰符。（在Unix和Dos/Windows上都是）
To read a file in binary mode and receive the data as a stream of bytes, use the modestring "rb:ascii-8bit".
要以二进制模式读取文件，并接受数据作为字节流，可使用模式字符串"rb:ascii-8bit"。

When expressed as an integer, the mode is specified by OR-ing together the values in the following table. 
当表示为一个整数时，模式被OR-ing一起指定下表中的值。
If your system does not support the underlying functionality, the constants will not be defined. 
如果你的系统不支持基本功能，常数将不被定义。
The descriptions below are just hints at the underlying functionality—see the man page for open(2) for the details.
下面的描述只提供了基本功能--详情参见open(2)的man页。
File::APPEND
Opens the file in append mode; all writes will occur at end of file.
以追加模式打开文件；所有写入发生在文件末尾。
File::ASYNC
Generate a signal when input or output become possible.
可能出现输出和输入时产生一个信号。
File::BINARY     
Use Ruby’s binary mode.
使用Ruby的二进制模式。
File::CREAT      
Creates the file on open if it does not exist.
如果不存在file文件，则创建并打开它。
File::DIRECT     
Try to minimize the effects of caching.
尝试最小化缓存的效果。
File::DSYNC      
Opens for synchronous I/O, blocking until buffered data (but not necessarily inode information) is written.
为同步I/O打开文件，阻塞文件，直到缓冲输入完全被写入。
File::EXCL       
When used with File::CREAT, opens will fail if the file exists.
和File::CREAT一起使用时，如果文件存在则打开失败。
File::NOATIME    
Do not update the file’s last access time on reading.
读取时不更新文件的最后访问时间。
File::NOCTTY     
When opening a terminal device (see IO#isatty on page 549), does not allow it to become the controlling terminal.
打开一个终端设置时，不允许它变成控制的终端。
<kinder:note> 什么意思？
File::NOFOLLOW   
Do not open the file if the name is a symbolic link.
如果名字是一个符号链接，不打开该文件。
File::NONBLOCK   
Opens the file in nonblocking mode.
在无阻塞模式下打开文件。
File::RDONLY     
Opens for reading only.
只读打开。
File::RDWR       
Opens for reading and writing.
为读/写打开文件。
File::SYNC       
Opens for synchronous I/O, blocking until buffered data is written.
为同步I/O打开文件，阻塞它，直到缓冲数据完全写入。
File::TRUNC      
Opens the file and truncates it to zero length if the file exists.
打开文件，如果该文件存在则清空它。
File::WRONLY     
Opens for writing only.
只读打开文件。

Optional permission bits may be given in permission. 
可选的权限位指定权限。
These bits are platform dependent; on Unix systems, see open(2) for details.
这些位依赖平台；在Unix系统，详见open(2)。

If the final parameter is a hash, it is used to control options, as described in the following table. 
如果最后参数是一个散列表，它将被用作控制选项，正如下面表格所描述。
The mode can be passed as one of the options of this hash.
该模式可被作为这个散列表的一个选项而传递。

Table 17—File and I/O open options  表格17——文件和IO打开选项
**autoclose**:          
If false, the underlying file will not be closed when this I/O object is finalized.
如果为假，底层文件在这个I/O对象结束时将不被关闭。
**binmode**:            
Opens the IO object in binary mode if true (same as mode: "b").
如果为true，用二进制模式打开该I/O对象。
**encoding**:           
Specifies both external and internal encodings as "external:internal" (same format used in mode parameter).
指定内部和外部编码为“外部内部”（同样的格式用于mode参数）
**external_encoding**:  
Specifies the external encoding.
指定外部编码。
**internal_encoding**:  
Specifies the internal encoding.
指定内部编码。
**mode**:               
Specifies what would have been the mode parameter (so File.open("xx", "r:utf-8") is the same as File.open("xx", mode: "r:utf-8").
指定已经确定的mode参数(就是File.open("xx", "r:utf-8))同File.open("xx", mode: "r:utf-8")一样。
**perm**:               
Specifies what would have been the permission parameter.
指定已经确定的权限参数。
**textmode**:           
Open the file in text mode (the default). 
用文本模式打开文件（默认）。
In addition, the options parameter can use the key/value pairs that are specified to String.encode to control the processing of text data. 
另外，options参数可用键值对的方式，指定String.encode来控制文本数据的处理。
See Table 22, Options to encode and encode!, on page 675.
详见后面675页表格22,Options to encode and encode!。

See also IO.open on page 539 for a block form of File.new.
另见后面539页IO.open关于File.new的block形式。

    # open for reading, default external encoding   
    # 打开只读，默认外部编码。
    f = File.new("testfile", "r")
    # open for reading, assume contents are utf-8
    # 打开读取，假设内容是utf-8.
    f = File.new("testfile", "r:utf-8")
    # Same, using an options hash
    # 同样的，使用options散列表。
    f = File.new("testfile", mode: "r", external_encoding: "utf-8")
    # Translate cr/lf to just lf (a String#encode option)
    # 将cr/lf转化为只是lf（一个String#encode选项）
    f = File.new("testfile", universal_newline: true)
    # open for read/write. external utf-8 data will be converted to iso-8859-1
    # when read, and converted from 8859-1 to utf-8 on writing
    # 读写打开。读取时外部utf-8数据将被转化为iso-8859-1，写入时相反。
    f = File.new("newfile", "w+:utf-8:iso-8859-1")
    # same as specifying "w+"
    # 和指定"w+"一样。
    f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)

#### owned?  所有者

    File.owned?( filename ) → true or false

Returns true if the effective user ID of the process is the same as the owner of the named file.
如果进程的有效用户ID和文件的拥有者相同，则返回true。

    File.owned?("/etc/passwd") # => false

#### path  路径  1.9

    File.path( obj ) → string

Returns the path of obj. 
返回obj的路径。
If obj responds to `to_path`, its value is returned. 
如果obj转向`to_path`，它的值将被返回。
Otherwise, attempt to convert obj to a string and return that value.
否则，尝试将obj转换为一个字符串并返回该值。

    File.path("testfile")        # => "testfile"
    File.path("/tmp/../tmp/xxx") # => "/tmp/../tmp/xxx"
    f = File.open("/tmp/../tmp/xxx")
    File.path(f)                 # => "/tmp/../tmp/xxx"

#### pipe?  是否管道

    File.pipe?( filename ) → true or false

Returns true if the OS supports pipes and the named file is one; false otherwise.
如果操作系统支持管道且给定的文件是管道文件，返回true；否则返回false。

    File.pipe?("testfile") # => false

#### readable?  是否可读

    File.readable?( filename ) → true or false

Returns true if the named file is readable by the effective user ID of this process.
如果本进程的有效用户ID可以读取给定文件，返回true。

    File.readable?("testfile") # => true

#### readable_real?  是否真可读

    File.readable_real?( filename ) → true or false

Returns true if the named file is readable by the real user ID of this process.
如果本进程的真实用户ID可以读取给定文件，则返回true。

    File.readable_real?("testfile") # => true

#### readlink  符号链接

    File.readlink( filename ) → filename

Returns the given symbolic link as a string. 
以字符串返回给定的符号链接。
Not available on all platforms.
不是在所有平台上可用。

    File.symlink("testfile", "link2test") # => 0
    File.readlink("link2test") # => "testfile"

#### realdirpath  真实目录路径

    File.realdirpath( path ‹ , relative_to ›) → string

Converts path to a full file path, with all symlinks resolved and relative paths made absolute.
将path转化为一个完整的文件路径，并且将所有已解析的符号链接和相对路径变成绝对的。
If a second parameter if present, it is used as the base for resolving leading relative path segments. 
如果存在第二个参数，将被用作解析前置相对路径分隔的基础。
The actual file (the past component of the path) need not exist.
实际文件（路径的后面部分）无需存在。

    puts File.realdirpath("/var/log/system.log")
    puts File.realdirpath("../Common/xml")
    puts File.realdirpath("Sites", "/Users/dave")
    # produces:
    # /private/var/log/system.log
    # /Users/dave/BS2/published/ruby4/Common/xml
    # /Users/dave/Sites

#### realpath  真实路径

    File.realpath( path ‹ , relative_to ›) → string

Converts path to a full file path, with all symlinks resolved and relative paths made absolute.
将path转化为一个完整的文件路径，并且将所有已解析的符号链接和相对路径变成绝对的。
If a second parameter if present, it is used as the base for resolving leading relative path segments.
如果存在第二个参数，将被用作解析前置相对路径分隔的基础。

    puts File.realpath("/var/log/system.log")
    puts File.realpath("../PerBook/util/xml/ppbook.dtd")
    puts File.realpath("Sites/index.html", "/Users/dave")
    # produces:
    # /private/var/log/system.log
    # /Users/dave/BS2/published/ruby4/PerBook/util/xml/ppbook.dtd
    # /Users/dave/Sites/index.html

#### rename  重命名

    File.rename( oldname, newname ) → 0

Renames the given file or directory to the new name. 
重命名给定的文件或者目录为新名字。
Raises a SystemCallError if the file cannot be renamed.
如果不能成功重命名，抛出一个SystemCallError。

    File.rename("afile", "afile.bak") # => 0

#### setgid?  设置组ID

    File.setgid?( filename ) → true or false

Returns true if the named file’s set-group-id permission bit is set and returns false if it isn’t or if the operating system doesn’t support this feature.
如果设置了给定文件的set-group-id权限位，则返回true，如果没有设置或者操作系统不支持这种特性，则返回false。

    File.setgid?("/usr/sbin/lpc") # => false

#### setuid?  设置用户ID

    File.setuid?( filename ) → true or false

Returns true if the named file’s set-user-id permission bit is set and returns false if it isn’t or if the operating system doesn’t support this feature.
如果设置了给定文件的set-user-id权限位，则返回true，如果没有设置或者操作系统不支持这种特性，则返回false。

File.setuid?("/bin/su") # => false

#### size  文件大小

    File.size( filename ) → int

Returns the size of the file in bytes.
返回文件的字节大小。

    File.size("testfile") # => 66

#### size?  文件大小

    File.size?( filename ) → int or nil

Returns nil if the named file is of zero length; otherwise, returns the size. 
如果给定文件的长度为0,返回0,否则返回文件大小。
Usable as a condition in tests.
在测试的条件语句中很有用。

    File.size?("testfile") # => 66
    File.size?("/dev/zero") # => nil

#### socket?  是否套接字

    File.socket?( filename ) → true or false

Returns true if the named file is a socket and returns false if it isn’t or if the operating system doesn’t support this feature.
如果给定文件是socket文件，则返回true，如果不是或操作系统不支持这种特性，返回false。

#### split  分隔

    File.split( filename ) → array

Splits the given string into a directory and a file component and returns them in a two-element array. 
把给定的字符串分隔成目录和文件，并返回包含它们的具有两个元素的数组。
See also File.dirname and File.basename.
参见File.dirname和File.basename。

    File.split("/home/gumby/.profile") # => ["/home/gumby", ".profile"]
    File.split("ruby.rb") # => [".", "ruby.rb"]

#### stat  信息

File.stat( filename ) → stat

Returns a File::Stat object for the named file (see File::Stat on page 503).
返回给定文件的一个File::Stat对象（参见前面2版477页4版503页的File::Stat）

    stat = File.stat("testfile")
    stat.mtime # => 2013-05-16 20:00:29 -0500
    stat.ftype # => "file"

#### sticky?  是否粘滞

    File.sticky?( filename ) → true or false

Returns true if the named file has its sticky bit set and returns false if it doesn’t or if the operating system doesn’t support this feature.
如果给文件设置了粘滞位，则返回true；如果没有设置或操作系统不支持这种特性，返回false。

#### symlink  创建符号链接

    File.symlink( oldname, newname ) → 0 or nil

Creates a symbolic link called newname for the file oldname. 
为文件oldname创建一个名为newname的符号链接。
Returns nil on all platforms that do not support symbolic links.
在不支持符号链接的平台上将返回nil。

    File.symlink("testfile", "link2test") # => 0

#### symlink?  是否符号链接

    File.symlink?( filename ) → true or false

Returns true if the named file is a symbolic link and returns false if it isn’t or if the operating system doesn’t support this feature.
如果给定文件是符号链接文件，则返回true，如果不是或操作系统不支持这种特性，则返回false。

    File.symlink("testfile", "link2test") # => 0
    File.symlink?("link2test")            # => true

#### truncate  截断文件

    File.truncate( filename, int ) → 0

Truncates the file filename to be at most int bytes long. 
截断文件filename，使其长度至多int字节。
Not available on all platforms.
不是在所有平台上可用。

    f = File.new("out", "w")
    f.write("1234567890")      #=> 10
    f.close                    #=> nil
    File.truncate("out", 5)    #=> 0
    File.size("out")           #=> 5

#### umask  掩码

    File.umask( ‹ int › ) → int

Returns the current umask value for this process. 
返回当前进程的umask值。
If the optional argument is given, sets the umask to that value and returns the previous value. 
如果有参数，则设置umask值为参数值，并返回原来的值。
Umask values are excluded from the default permissions; so, a umask of 0222 would make a file read-only for everyone. 
umask值将从默认权限中移除，所以0222umask值使得文件对所有人只读。
See also the discussion of permissions on page 488.
参见前面2版465页4版488页关于先前的讨论。

    File.umask(0006) # => 18
    File.umask # => 6

#### unlink  删除

    File.unlink( ‹ filename ›+ ) → int

Synonym for File.delete. 
同File.delete。
See also Dir.rmdir.
另见Dir.rmdir。

    File.open("testrm", "w+") {} # => nil
    File.unlink("testrm") # => 1

#### utime  设置访问和修改时间

    File.utime( accesstime, modtime ‹ , filename ›+ ) → int

Changes the access and modification times on a number of files. 
改变多个文件的访问和修改时间。
The times must be instances of class Time or integers representing the number of seconds since epoch. 
时间必须是类Time的实例或表示自纪元开始的秒数的数字。
Returns the number of files processed. 
返回给处理的文件个数。
Not available on all platforms.
不是在所有平台上可用。

    File.utime(0, 0, "testfile")         # => 1
    File.mtime("testfile")               # => 1969-12-31 18:00:00 -0600
    File.utime(0, Time.now, "testfile")  # => 1
    File.mtime("testfile")               # => 2013-05-27 12:32:07 -0500

#### world_readable?   他人可读   1.9

    File.world_readable?( filename ) → perm_int or nil

If filename is readable by others, returns an integer representing the file permission bits of filename. 
如果filename对其他人可读，返回一个表示filename文件权限位的整数。
Returns nil otherwise. 
否则返回nil。
The meaning of the bits is platform dependent; on Unix systems, see stat(2).
权限位的含义是依赖平台的；在Unix系统，参见stat(2)。

    File.world_readable?("/etc/passwd") # => 420
    File.world_readable?("/etc/passwd").to_s(8) # => "644"

#### world_writable?  他人可写  1.9

    File.world_writable?( filename ) → perm_int or nil

If filename is writable by others, returns an integer representing the file permission bits of filename. 
如果filename对其他人可读，返回一个表示filename文件权限位的整数。
Returns nil otherwise. 
否则返回nil。
The meaning of the bits is platform dependent; on Unix systems, see stat(2).
权限位的含义是依赖平台的；在Unix系统，参见stat(2)。

    File.world_writable?("/etc/passwd") # => nil
    File.world_writable?("/tmp") # => 511
    File.world_writable?("/tmp").to_s(8) # => "777"

#### writable?  是否可写

    File.writable?( filename ) → true or false

Returns true if the named file is writable by the effective user ID of this process.
如果给定文件可以被进程的有效用户ID写入，返回true。

    File.writable?("/etc/passwd") # => false
    File.writable?("testfile") # => true

#### writable_real?  是否真实可写

    File.writable_real?( filename ) → true or false

Returns true if the named file is writable by the real user ID of this process.
如果给定的文件可以被进程的真实用户ID写入，则返回true。

#### zero?  是否为0

    File.zero?( filename ) → true or false

Returns true if the named file is of zero length and returns false otherwise.
如果给定的文件长度为0,则返回true，否则返回false。

    File.zero?("testfile") # => false
    File.open("zerosize", "w") {}
    File.zero?("zerosize") # => true


### Instance Methods 实例方法
#### atime  最后访问时间

    file.atime → time

Returns a Time object containing the last access time for file or returns epoch if the file has not been accessed.
返回一个包含所有文件最后访问时间的Time对象，如果文件没有被访问过，则返回纪元时间。

    File.new("testfile").atime # => 1969-12-31 18:00:00 -0600

#### chmod  改变权限

    file.chmod( permission ) → 0

Changes permission bits on file to the bit pattern represented by permission. 
将文件的权限位改为permission。
Actual effects are platform dependent; on Unix systems, see chmod(2) for details. 
实际效果依赖于操作系统；在Unix系统，详见chmod(2)。
Follows symbolic links. 
跟随符号链接
See the discussion of permissions on page 488. 
参见前面488页关于权限的讨论。
Also see File.lchmod.
另见File.lchmod。

    f = File.new("out", "w");
    f.chmod(0644) # => 0

#### chown  改变所有者

    file.chown( owner, group ) → 0

Changes the owner and group of file to the given numeric owner and group IDs. 
将文件的所有者和所属的组改为给定数字表示的所有者和组ID。
Only a process with superuser privileges may change the owner of a file. 
仅具有超级权限的进程可以改变文件的所有者。
The current owner of a file may change the file’s group to any group to which the owner belongs. 
文件当前的拥有者可以改变文件的组为拥有者所属的任何组。
A nil or -1 owner or group ID is ignored. 
如果拥有者或组ID为nil或-1，它们将被忽略。
Follows symbolic links. 
跟随符号链接。
See also File.lchown.
另见File.lchown。

    File.new("testfile").chown(502, 400)

#### ctime  最后改变时间

    file.ctime → time

Returns a Time object containing the time that the file status associated with file was changed.
返回一个含有给定文件最后状态修改时间的Time对象。

    File.new("testfile").ctime # => 2013-05-27 12:32:07 -0500

#### flock  文件锁

    file.flock ( locking_constant ) → 0 or false

Locks or unlocks a file according to `locking_constant` (a logical or of the following values).
根据`locking_constant`（由下表的值组成的逻辑或）锁住或开锁文件。

Table 18—Lock-mode constants   表格18 锁模式常量
`LOCK_EX`
Exclusive lock. 
排他锁。
Only one process may hold an exclusive lock for a given file at a time.
在一个时刻只有一个进程可以获得给定文件的排他锁。
`LOCK_NB`
Don’t block when locking. 
加锁时不阻塞。
May be combined with other lock options using | (or) 
可以使用逻辑或与其他选项的组合
`LOCK_SH`
Shared lock. 
共享锁。
Multiple processes may each hold a shared lock for a given file at the same time.
在一个时刻可以有多个进程获得给定文件的共享锁。
`LOCK_UN`
Unlock.
解锁

Returns false if `File::LOCK_NB` is specified, and the operation would otherwise have blocked.
如果指定了`File::LOCK_NB`，则返回flase，否则操作将阻塞。
Not available on all platforms.
不是在所有平台上可用。

    File.new("testfile").flock(File::LOCK_UN) # => 0

#### lstat  符号链接状态

file.lstat → stat

Same as IO#stat but does not follow the last symbolic link. 
和IO#stat一样，但不跟随最后的符号链接。
Instead, reports on the link itself.
相反，报告链接自身的状态。

    File.symlink("testfile", "link2test")
    File.stat("testfile").size      # => 0
    f = File.new("link2test")       # => 66
    f.lstat.size                    # => 8
    f.stat.size                     # => 66

#### mtime  最后修改时间

    file.mtime → time

Returns a Time object containing the modification time for file.
返回包含文件file修改时间的一个Time对象。

    File.new("testfile").mtime # => 2013-05-27 12:32:07 -0500

#### path  路径

    file.path → filename

Returns the path name used to create file as a string. 
返回创建文件file时的路径名字符串。
Does not normalize the name.
不对名字进行标准化。

    File.new("testfile").path # => "testfile"
    File.new("/tmp/../tmp/xxx", "w").path # => "/tmp/../tmp/xxx"

#### size  大小 1.9

    file.size( filename ) → int

Returns the size of file in bytes.
返回文件的大小（单位：字节）。

    File.open("testfile").size # => 66

#### to_path  路径 1.9

    file.to_path → filename

Alias for File#path.
File#path的别名。

#### truncate  截断

    file.truncate( int ) → 0

Truncates file to at most int bytes. 
截断文件filename，使其长度至多int字节。
The file must be opened for writing. 
文件必须先被打开以便写出。
Not available on all platforms.
不是在所有平台上可用。

    f = File.new("out", "w")
    f.syswrite("1234567890") # => 10
    f.truncate(5)            # => 0
    f.close()                # => nil
    File.size("out")         # => 5


## File::Stat  文件状态
### 概述
Objects of class File::Stat encapsulate common status information for File objects. 
类File::Stat对象封装了File对象的普通状态信息。
The information is recorded at the moment the File::Stat object is created; changes made to the file after that point will not be reflected. 
信息是在对象被创建时记录的；且不受以后对文件的修改的影响。
File::Stat objects are returned by IO#stat, File.stat, File#lstat, and File.lstat. 
IO#stat, File.stat, File#lstat 和File.lstat会返回File::Stat对象。
Many of these methods may return platform-specific values, and not all values are meaningful on all systems. 
这些方法中许多方法会返回平台相关的值，而且返回的值并不是在所有的平台上都有意义。
See also Object#test on page 628.
参见后面2版531页4版628页的Object#test。

### Mixes In  混入  
Comparable: `<, <=, ==, >, >=, between?`

### Instance Methods 实例方法
#### <=>  比较

    statfile <=> other_stat → -1, 0, 1

Compares File::Stat objects by comparing their respective modification times.
通过对比各自的修改时间来对比File:Stat对象。

    f1 = File.new("f1", "w")
    sleep 1
    f2 = File.new("f2", "w")
    f1.stat <=> f2.stat # => -1
    # Methods in Comparable are also available
    # Comparable模块里的方法也可用。
    f1.stat > f2.stat # => false
    f1.stat < f2.stat # => true

#### atime  最后访问时间

    statfile.atime → time

Returns a Time object containing the last access time for statfile or returns epoch if the file has not been accessed.
返回含有statfile最后访问时间的一个Time对象，如果文件未被访问过，返回纪元时间。

    File.stat("testfile").atime # => 1969-12-31 18:00:00 -0600
    File.stat("testfile").atime.to_i # => 0

#### blksize  文件系统块大小

    statfile.blksize → int

Returns the native file system’s block size. 
返回本地文件系统的块大小。
Will return nil on platforms that don’t support this information.
在不支持这类信息的平台上将返回nil。

    File.stat("testfile").blksize # => 4096

#### blockdev?  是否块设备

    statfile.blockdev? → true or false

Returns true if the file is a block device and returns false if it isn’t or if the operating system doesn’t support this feature.
如果文件是块设备，返回true；如果不是或操作系统不支持这种特性，返回false。

    File.stat("testfile").blockdev?  # => false
    File.stat("/dev/disk0").blockdev? # => true

#### blocks  文件块个数

    statfile.blocks → int

Returns the number of native file system blocks allocated for this file or returns nil if the operating system doesn’t support this feature.
返回为文件分配的本地文件系统的块的个数，如果底层操作系统不支持这种特性，返回false。

    File.stat("testfile").blocks # => 8

#### chardev?  是否字符设备

    statfile.chardev? → true or false

Returns true if the file is a character device and returns false if it isn’t or if the operating system doesn’t support this feature.
如果文件是字符设备，返回true；如果不是或操作系统不支持这种特性，返回false。

    File.stat("/dev/tty").chardev? # => true
    File.stat("testfile").chardev? # => false

#### ctime  最后修改时间

    statfile.ctime → time

Returns a Time object set to the time that the file status associated with statfile was changed.
返回含有statfile想关联文件的修改状态的一个Time对象。

    File.stat("testfile").ctime # => 2013-05-27 12:32:07 -0500

#### dev  设备信息

    statfile.dev → int

Returns an integer representing the device on which statfile resides. 
返回表示保存statfile的设备的一个整数。
The bits in the device integer will often encode major and minor device information.
设备整数中的位常常由主设备信息和次设备信息组合而成。

    File.stat("testfile").dev # => 16777219
    "%x" % File.stat("testfile").dev # => "1000003"

#### dev_major  主设备信息  1.8

    statfile.dev_major → int

Returns the major part of File::Stat#dev or nil if the operating system doesn’t support this feature.
返回File::Stat#dev的主设备部分。如果操作系统不支持这种特性，则返回nil。

    File.stat("testfile").dev_major # => 1

#### dev_minor  次设备信息  1.8

    statfile.dev_minor → int

Returns the minor part of File::Stat#dev or nil if the operating system doesn’t support this feature.
返回File::Stat#dev的次设备部分。如果操作系统不支持这种特性，则返回nil。

    File.stat("testfile").dev_minor # => 3

#### directory?  是否目录

statfile.directory? → true or false

Returns true if statfile is a directory and returns false otherwise.
如果statfile是目录，则返回true，否则返回false。

    File.stat("testfile").directory? # => false
    File.stat(".").directory?  # => true

#### executable?  是否可执行

    statfile.executable? → true or false

Returns true if statfile is executable or if the operating system doesn’t distinguish executable files from nonexecutable files. 
如果statfile是可执行文件或者操作系统不区分文件执行与否，则返回true。
The tests are made using the effective owner of the process.
测试是用进程的有效拥有者进行的。

    File.stat("testfile").executable? # => false

#### executable_real?  是否真实可执行

    statfile.executable_real? → true or false

Same as executable? but tests using the real owner of the process.
和executable?一样，但测试使用的是进程的真实拥有者。

#### file?  是否文件

    statfile.file? → true or false

Returns true if statfile is a regular file (not a device file, pipe, socket, and so on).
如果statfile是个普通文件（不是设备文件、管道、套接字等等），返回true。

    File.stat("testfile").file? # => true

#### ftype  文件类型

    statfile.ftype → type_string

Identifies the type of statfile. 
确定statfile的类型。
The return string is one of the following: file, directory, characterSpecial, blockSpecial, fifo, link, socket, or unknown.
返回的字符串有：file、directory、character-Special、blockSpecial、fifo、link、socket或unknown。

    File.stat("/dev/tty").ftype # => "characterSpecial"

#### gid  拥有者组ID

    statfile.gid → int

Returns the numeric group ID of the owner of statfile.
返回statfile拥有者的组ID数字。

    File.stat("testfile").gid # => 20

#### grpowned?  是否同组

    statfile.grpowned? → true or false

Returns true if the effective group ID of the process is the same as the group ID of statfile.
如果进程的有效组ID和statfile的组ID相同，则返回true。
On Windows, returns false.
在Windows上返回false。

    File.stat("testfile").grpowned?  # => true
    File.stat("/etc/passwd").grpowned? # => false

#### ino   节点号

    statfile.ino → int

Returns the inode number for statfile.
返回statfile的inode号。

    File.stat("testfile").ino # => 29399443

#### mode  权限模式

    statfile.mode → int

Returns an integer representing the permission bits of statfile. 
返回表示statfile的权限位的整数。
The meaning of the bits is platform dependent; on Unix systems, see stat(2).
位的含义是平台相关的；在Unix系统上，参见stat(2)。

    File.chmod(0644, "testfile") # => 1
    File.stat("testfile").mode.to_s(8) # => "100644"

#### mtime  最后修改时间

    statfile.mtime → time

Returns a Time object containing the modification time for statfile.
返回包含statfile的修改时间的一个Time对象。

    File.stat("testfile").mtime # => 2013-05-27 12:32:07 -0500

#### nlink  硬链接数

    statfile.nlink → int

Returns the number of hard links to statfile.
返回statfile的硬链接数。

    File.stat("testfile").nlink # => 1
    File.link("testfile", "testfile.bak") # => 0
    File.stat("testfile").nlink # => 2

#### owned?  是否同人

    statfile.owned? → true or false

Returns true if the effective user ID of the process is the same as the owner of statfile.
如果进程的有效用户ID和statfile的拥有者相同，则返回true。

    File.stat("testfile").owned?  # => true
    File.stat("/etc/passwd").owned? # => false

#### pipe?  是否管道

    statfile.pipe? → true or false

Returns true if the operating system supports pipes and statfile is a pipe.
如果操作系统支持管道文件并且statfile是一个管道文件，返回true。

#### rdev  设备类型号码

    statfile.rdev → int

Returns an integer representing the device type on which statfile (which should be a special file) resides. 
返回一个表示statfile所在设备的类型的一个整数，statfile需要的是一个特殊文件。
Returns nil if the operating system doesn’t support this feature.
如果操作系统不支持这种特性，则返回nil。

    File.stat("/dev/disk0s1").rdev # => 16777217
    File.stat("/dev/tty").rdev # => 33554432

#### rdev_major  主设备号

    statfile.rdev_major → int

Returns the major part of File::Stat#rdev or nil if the operating system doesn’t support this feature.
返回File::Stat#rdev的主设备号部分；如果操作系统不支持这种特性，则返回nil。

    File.stat("/dev/disk0s1").rdev_major # => 1
    File.stat("/dev/tty").rdev_major # => 2

#### rdev_minor  次设备号

    statfile.rdev_minor → int

Returns the minor part of File::Stat#rdev or nil if the operating system doesn’t support this feature.
返回File::Stat#rdev的次设备号部分；如果操作系统不支持这种特性，则返回nil。

    File.stat("/dev/disk0s1").rdev_minor # => 1
    File.stat("/dev/tty").rdev_minor # => 0

#### readable?  是否可读

    statfile.readable? → true or false

Returns true if statfile is readable by the effective user ID of this process.
如果进程的有效用户ID对statfile有读权限，则返回true。

    File.stat("testfile").readable? # => true

#### readable_real?  是否真可读

    statfile.readable_real? → true or false

Returns true if statfile is readable by the real user ID of this process.
如果进程的真实用户ID对statfile有读权限，则返回true。

    File.stat("testfile").readable_real?  # => true
    File.stat("/etc/passwd").readable_real? # => true

#### setgid?  是否可设置组id

    statfile.setgid? → true or false

Returns true if statfile has the set-group-id permission bit set and returns false if it doesn’t or if the operating system doesn’t support this feature.
如果statfile设置了set-group-id权限位，返回true；如果没有设置或者操作系统不支持此特性，返回false。

    File.stat("testfile").setgid?  # => false
    File.stat("/usr/sbin/postdrop").setgid? # => true

#### setuid?  是否可设置用户id

    statfile.setuid? → true or false

Returns true if statfile has the set-user-id permission bit set and returns false if it doesn’t or if the operating system doesn’t support this feature.
如果statfile设置了set-user-id权限位，返回true；如果没有设置或者操作系统不支持此特性，返回false。

    File.stat("testfile").setuid?  # => false
    File.stat("/usr/bin/su").setuid? # => true

#### size  文件大小

    statfile.size → int

Returns the size of statfile in bytes.
以字节为单位返回statfile的大小。

    File.stat("/dev/zero").size # => 0
    File.stat("testfile").size # => 66

#### size?  文件大小

    statfile.size? → int or nil

Returns nil if statfile is a zero-length file; otherwise, returns the file size. 
如果statfile文件长度为0, 返回nil，否则返回文件的大小。
Usable as a condition in tests.
在测试条件中很有用。

    File.stat("/dev/zero").size? # => nil
    File.stat("testfile").size? # => 66

#### socket?  是否套接字

    statfile.socket? → true or false

Returns true if statfile is a socket and returns false if it isn’t or if the operating system doesn’t support this feature.
如果statfile是套接字文件，返回true；如果不是或者操作系统不支持此特性，返回false。

    File.stat("testfile").socket? # => false

#### sticky?  是否粘滞

    statfile.sticky? → true or false

Returns true if statfile has its sticky bit set and returns false if it doesn’t or if the operating system doesn’t support this feature.
如果statfile设置了粘滞位，返回true；如果不是或者操作系统不支持此特性，返回false。

    File.stat("testfile").sticky? # => false

#### symlink?  是否符号链接

    statfile.symlink? → true or false

Returns true if statfile is a symbolic link; returns false if it isn’t or if the operating system doesn’t support this feature. 
如果statfile是符号链接文件，返回true；如果不是或者操作系统不支持此特性，返回false。
Because File.stat automatically follows symbolic links, symlink? will always be false for an object returned by File.stat.
因为File.stat会自动跟随符号链接文件，所以对File.stat返回的对象，symlink?总是false。

    File.symlink("testfile", "alink") # => 0
    File.stat("alink").symlink?  # => false
    File.lstat("alink").symlink?  # => true

#### uid  拥有者ID号

    statfile.uid → int

Returns the numeric user ID of the owner of statfile.
返回statfile的拥有者用户ID号。

    File.stat("testfile").uid # => 501

#### world_readable?  他人可读  1.9

statfile.world_readable?( filename ) → perm_int or nil

If filename is readable by others, returns an integer representing the file permission bits of filename. 
如果filename对其他人可读，返回一个表示filename文件权限位的整数。
Returns nil otherwise. 
否则返回nil。
The meaning of the bits is platform dependent; on Unix systems, see stat(2).
权限位的含义是依赖平台的；在Unix系统，参见stat(2)。

    File.stat("/etc/passwd").world_readable?  # => 420
    File.stat("/etc/passwd").world_readable?.to_s(8) # => "644"

#### world_writable?  他人可写  1.9

    statfile.world_writable?( filename ) → perm_int or nil

If filename is writable by others, returns an integer representing the file permission bits of filename. 
如果filename对其他人可读，返回一个表示filename文件权限位的整数。
Returns nil otherwise. 
否则返回nil。
The meaning of the bits is platform dependent; on Unix systems, see stat(2).
权限位的含义是依赖平台的；在Unix系统，参见stat(2)。

    File.stat("/etc/passwd").world_writable? # => nil
    File.stat("/tmp").world_writable?  # => 511
    File.stat("/tmp").world_writable?.to_s(8) # => "777"

#### writable?  是否可写

    statfile.writable? → true or false

Returns true if statfile is writable by the effective user ID of this process.
如果给定文件可以被进程的有效用户ID写入，返回true。

    File.stat("testfile").writable? # => true

#### writable_real?  是否真可写

    statfile.writable_real? → true or false

Returns true if statfile is writable by the real user ID of this process.
如果给定的文件可以被进程的真实用户ID写入，则返回true。

    File.stat("testfile").writable_real? # => true

#### zero?  长度为0

    statfile.zero? → true or false

Returns true if statfile is a zero-length file; returns false otherwise.
如果给定的文件长度为0,则返回true，否则返回false。

    File.stat("testfile").zero? # => false


## Module FileTest  文件测试模块
FileTest implements file test operations similar to those used in File::Stat. 
FileTest实现了文件测试操作，这些操作与File::Stat所用的操作类似。
The methods in FileTest are duplicated in class File. 
FileTest中的方法复制了类File中的方法。
Rather than repeat the documentation here, we list the names of the methods and refer you to the documentation for File on page 488. 
这里我们列出了方法的名字，并指引你参考前面2版465页4版488页开始的关于File的文档，而不再重复其文档。
FileTest appears to be a somewhat vestigial module.
FileTest看起来是一个有点多余的模块。

The FileTest methods are: 
方法有：

    blockdev?, 
    chardev?, 
    directory?, 
    executable?, executable_real?, exist?, exists?,
    file?, 
    grpowned?, 
    identical?, 
    owned?, 
    pipe?, 
    readable?, readable_real?, 
    setgid?, setuid?, size, size?, socket?, sticky?, symlink?, 
    world_readable?, world_writable?, writable?, writable_real?, 
    zero?

## Fixnum  < Integer   定数 
### 概述
A Fixnum holds integer values that can be represented in a native machine word (minus 1 bit). 
Fixnum所保存的integer值是用本机机器字长（减一位）表示的。
If any operation on a Fixnum exceeds this range, the value is converted to a Bignum.
如果Fixnum上的任意操作超出了这个范围，那么值自动被转化为Bignum。

Fixnum objects have immediate value. 
Fixnum对象有立即数。
This means that when they are assigned or passed as parameters, the actual object is passed, rather than a reference to that object. 
这意味着当用它们进行赋值或作为参数传递时，操作的是对象本身而不是对象的引用。
Assignment does not alias Fixnum objects. 
赋值操作不会为Fixnum对象起别名。
Because there is effectively only one Fixnum object instance for any given integer value, you cannot, for example, add a singleton method to a Fixnum.
因为对任何一个给定的整数值，实际上只有一个Fixnum对象实例，所以你不能添加单例方法到Fixnum中。

### Instance Methods 实例方法
#### Arithmetic operations  算术操作
Performs various arithmetic operations on fix.
在fix上执行各种算数操作

    fix  +  numeric     Addition  加
    fix  –  numeric     Subtraction  减
    fix  *  numeric     Multiplication  乘
    fix  /  numeric     Division  除
    fix  %  numeric     Modulo 取模
    fix  ** numeric     Exponentiation  幂运算
    fix  -@             Unary minus  一元减

#### Bit operations  位操作
Performs various operations on the binary representations of the Fixnum.
在Fixnum的二进制表示上执行各种操作。

    ~ fix            Invert bits   按位取反
    fix |  numeric   Bitwise or    按位或
    fix &  numeric   Bitwise and   按位与
    fix ^  numeric   Bitwise exclusive or       按位异或 
    fix << numeric   Left-shift numeric bits    左移numeric位
    fix >> numeric   Right-shift numeric bits (with sign extension)  右移numeric位（带符号）

#### Comparisons  比较  1.9
Compares fix to other numbers. Fixnum. <, <=, ==, >=, and >.
将fix和其他数字进行比较。
<kinder:note> 怎么理解和翻译？

#### <=>  比较

    fix <=> numeric → -1, 0, +1, or nil

Comparison—Returns -1, 0, or +1 depending on whether fix is less than, equal to, or greater than numeric. 
根据fix小于、等于或大于numeric分别返回-1,0或+1。
Although Fixnum’s grandparent mixes in Comparable, Fixnum does not use that module for performing comparisons, instead implementing the comparison operators explicitly.
虽然Fixnum的祖父类混入了comparison模块，Fixnum却不使用该模块进行比较，相反，它显式地实现比较操作符。

    42 <=> 13 # => 1
    13 <=> 42 # => -1
    -1 <=> -1 # => 0

#### []  位引用

    fix[ n ] → 0, 1

Bit Reference—Returns the nth bit in the binary representation of fix, where fix[0] is the least significant bit.
位引用--返回fix的二进制表示的第n位，其中fix[0]是最低位。

    a = 0b11001100101010
    30.downto(0) {|n| print a[n] }
    # produces:
    # 0000000000000000011001100101010

#### abs  绝对值

    fix.abs → int

Returns the absolute value of fix.
返回fix的绝对值。

    -12345.abs # => 12345
    12345.abs # => 12345

#### div  除法  1.8

    fix.div( numeric ) → integer

Division that always produces an integral result. 
除法总是产生整数结果。
Not affected by the mathn library (unlike Fixnum#/).
不受manth库的影响（不像Fixnum#/方法）。

    654321.div(13731) # => 47
    654321.div(13731.34) # => 47

#### even?  是否偶数  1.9

    fix.even? → true or false

Returns true if fix is even.
如果fix是个偶数，返回true。

    1.even? # => false 
    2.even? # => true

#### divmod  商和模（余数）

    fix.divmod( numeric ) → array

See Numeric#divmod on page 595.
参见后面2版565页4版595页的Numeric#divmod。

#### fdiv  浮点除法   1.9

    fix.fdiv( numeric ) → float

Returns the floating-point result of dividing fix by numeric.
fix除以numeric，返回一个浮点结果。

    63.fdiv(9) # => 7.0
    654321.fdiv(13731) # => 47.652829364212366
    654321.fdiv(13731.24) # => 47.65199646936475

#### magnitude   绝对值  1.9  

    fix.magnitude → int

Returns the magnitude of fix (the distance of fix from the origin of the number line). 
返回fix的绝对值（fix到数轴原点的距离）
Synonym for Fixnum#abs. 
和Fixnum#abs同义。
See also Complex#magnitude.
另见Complex#magnitude。

#### modulo  取模（余数） 1.8

    fix.modulo( numeric ) → numeric

Synonym for Fixnum#%.
和Fixnum#%同义.

    654321.modulo(13731) # => 8964
    654321.modulo(13731.24) # => 8952.72000000001

#### odd?  是否奇数  1.9

    fix.odd? → true or false

Returns true if fix is odd.
如果fix是奇数，返回true。

    1.odd? # => true  
    2.odd? # => false

#### size  字节数

    fix.size → int

Returns the number of bytes in the machine representation of a Fixnum.
返回Fixnum的机器表示的字节数。

    1.size # => 8
    -1.size # => 8
    2147483647.size # => 8

#### succ  加一

    fix.succ → int

Returns fix + 1.
返回fix加一

    1.succ   # => 2 
    -1.succ  # => 0

#### to_f  转化为浮点数

    fix.to_f → float

Converts fix to a Float.
将fix转换位浮点数。

#### to_s  转换为字符串

    fix.to_s( base=10 ) → string

Returns a string containing the representation of fix radix base (2 to 36).
返回fix以base（2到36）为基数的值的字符串。
<kinder:note> 这个所谓基数是进制吧。

    12345.to_s                             # =>  "12345"             
    12345.to_s(2)                          # =>  "11000000111001"
    12345.to_s(8)                          # =>  "30071"
    12345.to_s(10)                         # =>  "12345"
    12345.to_s(16)                         # =>  "3039"
    12345.to_s(36)                         # =>  "9ix"
    84823723233035811745497171.to_s(36)    # =>  "anotherrubyhacker"

#### zero?  是否为0

    fix.zero? → true or false

Returns true if fix is zero.
如果fix是0,则返回true。

    42.zero? # => false 
    0.zero?  # => true


## Float < Numeric  浮点数

Float objects hold real numbers using the native architecture’s double-precision floating-point representation.
Float对象使用本机体系结构的双精度浮点数表示实数。

### Class Constants  类常数

    DIG          

Precision of Float (in decimal digits).
Float的精度（以十进制表示）。

    EPSILON      

The smallest Float such that 1.0+EPSILON != 1.0.
使1.0+ EPSILON不等于1.0的最小Float。

    INFINITY     

Positive infinity.
正无穷大。

    MANT_DIG     

The number of mantissa digits (base RADIX).
尾数的个数（基于RADIX）。

    MAX          

The largest Float.
最大的浮点数。

    MAX_10_EXP   

The maximum integer x such that 10^x is a finite Float.
使10的x次方为有限Float的最大整数x。

    MAX_EXP      

The maximum integer x such that `FLT_RADIX`^(x-1) is a finite Float.
使`FLT_RADIX`的(x-1)次方为有限Float的最大整数x。

    MIN          

The smallest Float.
最小的浮点数。

    MIN_10_EXP   

The minimum integer x such that 10^x is a finite Float.
使10的x次方为有限Float的最小整数x。

    MIN_EXP      

The minimum integer x such that FLT_RADIXx-1 is a finite Float.
使FLT_RADIX的(x-1)次方为有限Float的最小整数x。

    NAN          

A value that is not a valid number.
值无效的数

    RADIX        

The radix of floating-point representations.
浮点表示的根。

    ROUNDS       

The rounding mode for floating-point operations. 
浮点操作的舍入模式。
Possible values include 
可能的值有：
-1 if the mode is indeterminate, 
-1 如果是混合模式。
0 if rounding is toward zero, 
0 i如果向0舍入。
1 if rounding is to nearest representable value, 
1 如果向最接近的可表示的值舍入。
2 if rounding is toward infinity, and 
2 如果向正无穷大舍入。
3 if rounding is toward minus infinity. 
3 如果向负无穷大舍入。

### Instance Methods 实例方法
#### Arithmetic operations  算术操作
Performs various arithmetic operations on flt.
在fit上可执行的各种算术操作。

    flt +  numeric  Addition   加
    flt –  numeric  Subtraction   减
    flt *  numeric  Multiplication  乘
    flt /  numeric  Division   除
    flt %  numeric  Modulo     取模
    flt ** numeric  Exponentiation   幂
    flt -@          Unary minus  一元减

#### Comparisons  比较 1.9
Compares flt to other numbers. 
将flt和其他数字进行比较。
<, <=, ==, >=, >.

#### <=>  比较

    flt <=> numeric → -1, 0, +1, or nil

Returns -1, 0, or +1 depending on whether flt is less than, equal to, or greater than numeric.
根据flt小于、等于或大于numeric分别返回-1,0,+1。

#### ==  是否相等

    flt == obj → true or false

Returns true only if obj has the same value as flt. 
如果obj和flt的值相同，返回true。
Contrast this with Float#eql?, which requires obj to be a Float.
和Float#eql?相比，Float#eql?要求obj也是一个浮点数。

    1.0 == 1.0      # => true
    (1.0).eql?(1.0) # => true
    1.0 == 1        # => true
    (1.0).eql?(1)   # => false

#### abs  绝对值

    flt.abs → numeric

Returns the absolute value of flt.
返回flt的绝对值。

    (-34.56).abs # => 34.56
    -34.56.abs # => 34.56

#### ceil  最小整数

    flt.ceil → int

Returns the smallest integer greater than or equal to flt.
返回大于或等于flt的最小整数。

    1.2.ceil     # => 2
    2.0.ceil     # => 2
    (-1.2).ceil  # => -1
    (-2.0).ceil  # => -2

#### divmod  求商和余数

    flt.divmod( numeric ) → array

See Numeric#divmod on page 595.
参见后面2版565页4版595页的Numeric#divmod。

#### eql?  相等

    flt.eql?( obj ) → true or false

Returns true only if obj is a Float with the same value as flt. 
如果obj是和flt有相同值浮点数，返回true。
Contrast this with Float#==, which performs type conversions.
和Float#==相比，Float#==会执行类型转换。

    1.0.eql?(1) # => false
    1.0 == 1 # => true

#### fdiv  浮点模   1.9

    flt.fdiv( number ) → float

Returns the floating-point result of dividing flt by number. 
flt除以number，返回浮点结果。
Alias for Float#quo.
和Float#quo同义。

    63.0.fdiv(9) # => 7.0
    1234.56.fdiv(3.45) # => 357.8434782608695

#### finite?  是否合法

    flt.finite? → true or false

Returns true if flt is a valid IEEE floating-point number (it is not infinite, and nan? is false).
如果flt是合法的IEEE浮点数，返回true（flt不是无限数，且nan?为false）。

    (42.0).finite?  # => true
    (1.0/0.0).finite? # => false

#### floor  最小整数

    flt.floor → int

Returns the largest integer less than or equal to flt.
返回小于或等于flt的最小整数。

    1.2.floor     # => 1
    2.0.floor     # => 2
    (-1.2).floor  # => -2
    (-2.0).floor  # => -2
                       
#### infinite?  是否无限

    flt.infinite? → nil, -1, +1

Returns nil, -1, or +1 depending on whether flt is finite, -infinity, or +infinity.
根据flt是有限数、负无穷大、正无穷大分别返回nil，-1或+1。

    (0.0).infinite?  # => nil
    (-1.0/0.0).infinite? # => -1
    (+1.0/0.0).infinite? # => 1

#### magnitude  绝对值  1.9

    flt.magnitude → float

Returns the magnitude of flt (the distance of flt from the origin of the number line). 
返回flt的绝对值（从数轴原点到flt的距离）
Synonym for Float#abs. 
和Float#abs同义。
See also Complex#magnitude.
另见Complex#magnitude。

    flt.modulo( numeric ) → numeric

#### modulo  取模
Synonym for Float#%.
和Float#%同义。

    6543.21.modulo(137) # => 104.21000000000004
    6543.21.modulo(137.24) # => 92.92999999999961

#### nan?   无效浮点

    flt.nan? → true or false

Returns true if flt is an invalid IEEE floating-point number.
如果flt是一个无效的IEEE浮点数，返回true。

    (-1.0).nan?  # => false
    (0.0/0.0).nan? # => true

#### quo  浮点除法

    flt.quo( number ) → float

Returns the floating-point result of dividing flt by number.
flt除以number返回一个浮点数。

    63.0.quo(9) # => 7.0
    1234.56.quo(3.45) # => 357.8434782608695

#### rationalize  有理化  1.9

    flt.rationalize( ‹ epsilon › ) → rational

Converts flt to a rational number with an approximate precision of epsilon. 
将flt转化为一个有理数，用一个近似精确的epsilon。
If epsilon is not given, a value will be chosen that preserves as many significant digits of the mantissa as possible.
如果epsilon没有指定，会选择一个值，这个值会尽量多地保留尾数的有效数字。

    1.3.rationalize                   # => (13/10)
    1.333.rationalize                 # => (1333/1000)
    1.33333333333333333.rationalize   # => (4/3)
    1.3333.rationalize(0.001)         # => (4/3)
    1.3333.rationalize(1)             # => (1/1)
    Math::PI.rationalize(0.01)        # => (22/7)

#### round  舍入

    flt.round(digits=0) → numeric

Rounds flt to the nearest integer if the parameter is omitted or zero or rounds to the given number of digits.
如果参数被忽略或为0，则舍入flt为最接近的整数，或舍入为给定小数的数字

    1.5.round          # => 2
    (-1.5).round       # => -2
    3.14159.round      # => 3
    3.14159.round(4)   # => 3.1416
    3.14159.round(2)   # => 3.14

#### to_f  返回浮点

    flt.to_f → flt

Returns flt.
返回flt。

#### to_i  截为整数

    flt.to_i → int

Returns flt truncated to an integer.
截断flt为整数，并返回该整数。

    1.5.to_i # => 1
    (-1.5).to_i # => -1

#### to_int  转为整数

    flt.to_int → int

Synonym for `Float#to_i`.
与`Float#to_i`同义。

#### to_r  转为有理数  1.9

    flt.to_r → number

Converts flt to a rational number.
将flt转化为一个有理数。

    1.5.to_r     # => 3/2                                
    (1.0/3).to_r # => 6004799503160661/18014398509481984

#### to_s  转为字符串

    flt.to_s → string

Returns a string containing a representation of flt. 
返回一个包含自身表示的字符串。
As well as a fixed or exponential form of the number, the call may return NaN, Infinity, and -Infinity.
和定点数和指数形式一样，本调用可能返回NaN、正无穷大和负无穷大。

#### truncate  截为整数  1.8

    flt.truncate → int

Synonym for Float#to_i.
和Float#to_i同义。

#### zero?  是否为0

    flt.zero? → true or false

Returns true if flt is 0.0.
如果flt是0.0,返回true。


## Module GC  垃圾收集模块
The GC module provides an interface to Ruby’s mark and sweep garbage collection mechanism. 
GC模块为ruby的标记和清除垃圾回收机制提供了一个接口。
Some of the underlying methods are also available via the ObjectSpace module, described later on page 631.
里面的一些方法也可以通过后面2版578页4版631页描述的ObjectSpace模块获得。

### Class Methods 类方法
#### count  运行个数  1.9

    GC.count → int

Returns a count of the number of times GC has run in the current process.
返回当前进程中GC运行次数的计数。

    GC.count # => 4
    res = ""
    10_000.times { res += "wibble" }
    GC.count # => 42

#### disable  禁用

    GC.disable → true or false

Disables garbage collection, returning true if garbage collection was already disabled.
禁用垃圾回收，如果垃圾回收已经被禁止，返回true。

    GC.disable # => false
    GC.disable # => true

#### enable  启用

    GC.enable → true or false

Enables garbage collection, returning true if garbage collection was disabled.
启用垃圾回收，如果垃圾回收已经被禁用，返回true。

    GC.disable # => false
    GC.enable # => true
    GC.enable # => false

#### start  初始化

    GC.start → nil

Initiates garbage collection, unless manually disabled.
初始化垃圾回收机制，除非已被手动禁止。

    GC.start # => nil

#### stat  状态  1.9

    GC.stat → stats_hash

Returns a hash containing GC statistics. 
返回一个包含GC统计数字的散列表。
The contents of this hash are implementation dependend. 
这个散列表的内容是依赖实现的。
The method may not be present in all Ruby implementations.
这个方法可能不是在所有的ruby实现中都存在。

    GC.stat
    # => {:count=>4, :heap_used=>43, :heap_length=>43, :heap_increment=>0,
    # .. :heap_live_num=>13938, :heap_free_num=>8659, :heap_final_num=>41,
    # .. :total_allocated_object=>36625, :total_freed_object=>22687}

#### stress  强调 1.9

    GC.stress → true or false

Returns the current value of the stress flag (see GC.stress=).
返回重点标志(参见GC.stress=)的当前值。

#### stress=  强调 1.9

    GC.stress = true or false → true or false

Ruby will normally run garbage collection periodically. 
ruby正常情况下会周期性地运行垃圾回收。
Setting the stress flag to true forces garbage collection to occur every time Ruby allocates a new object. 
将重点标志设置为true将强制ruby分配新对象时出现垃圾回收。
This is typically used only for testing extensions (and Ruby itself).
这只典型用于测试扩展（和ruby自身）。

    GC.stress = true


### Instance Methods 实例方法
#### garbage_collect  开始

    garbage_collect → nil

Equivalent to GC.start.
等同于GC.start。

    ilude GC
    garbage_collect # => nil


## Module GC::Profiler  垃圾回收剖析模块  1.9
### 概述
Provides low-level information on the state of garbage collection.
提供一个低水平的垃圾回收状态信息

    GC::Profiler.enable
    animal = "cat"
    22.times { animal *= 2 }
    printf "Took %0.4fs in GC\n", GC::Profiler.total_time
    GC::Profiler.report
    GC::Profiler.disable
    # produces:
    # Took 0.0040s in GC
    # GC 8 invokes.
    #  Index  Invoke    Use Size  Total      Total GC Time(ms)
    #         Time(sec) (byte)    Size(byte) Object
    #    1    0.034     334160    700040     17501 1.286000
    #    2    0.039     329320    700040     17501 1.358000
    #    3    0.045     329320    700040     17501 1.351000
    #    4    0.056     329320    700040     17501 1.347000

### Class Methods 类方法
#### clear  清除

    GC::Profiler.clear → nil

Clears existing profile data.
清楚已存的分析数据。

#### disable  禁用

    GC::Profiler.disable → nil

Disables the collection of profile data.
禁用收集分析数据

#### enable  启用

    GC::Profiler.enable → nil

Enables the collection of profile data.
启用收集分析信息。

#### enabled?  是否启用

    GC::Profiler.enabled? → true or false

Returns true if profile collection is enabled.
如果分析收集已经启用返回true。

#### raw_data  原始数据 ⇡New in 2.0⇣

    GC::Profiler.raw_data → array of hashes

Return raw profiling data, in time order, as an array of hashes, where each hash contains a data sample.
返回原始分析数据，按时间顺序，形成一个数组的散列表，每个散列表包含一个数据样例。

    GC::Profiler.enable
    animal = "cat"
    22.times { animal *= 2 }
    p GC::Profiler.raw_data.size
    p GC::Profiler.raw_data[0, 2]
    # produces:
    # 5
    # [{:GC_TIME=>1.0999999999997123e-05, :GC_INVOKE_TIME=>0.03359,
    # :HEAP_USE_SIZE=>691000, :HEAP_TOTAL_SIZE=>700040, :HEAP_TOTAL_OBJECTS=>17501,
    # :GC_IS_MARKED=>false}, {:GC_TIME=>0.0014199999999999977,
    # :GC_INVOKE_TIME=>0.033891, :HEAP_USE_SIZE=>331080, :HEAP_TOTAL_SIZE=>700040,
    # :HEAP_TOTAL_OBJECTS=>17501, :GC_IS_MARKED=>0}]

#### report  报告

    GC::Profiler.report( to=STDOUT ) → nil

Writes the profile result to the given stream.
就分析结果写入指定流中。

#### result  输出结果

    GC::Profiler.result → string

Returns a string containing a summary of the profile data.
返回一个包含分析数据的摘要的字符串。

#### total_time  总时间

    GC::Profiler.total_time → float

Returns the total time spend in garbage collection during this profile run.
返回这个分析运行时花在垃圾回收的总时间。


## Hash  散列表
### 概述
Relies on: each, <=>
依赖：each, <=>

A Hash is a collection of key/value pairs. 
Hash是键值对组成的集合。
It is similar to an Array, except that indexing is done via arbitrary keys of any object type, not an integer index. 
除了可以用任意对象类型作为键，而不仅仅用整数进行索引之外，它和数组相似。
The order in which keys and/or values are returned by the various iterators over hash contents will generally be the order that those entries were initially inserted into the hash.
基于散列表内容的各种迭代器返回的键和/或值的顺序是随意的，而且一般来说和插入的顺序不同。

Hashes have a default value. 
散列表具有默认值。
This value is returned when an attempt is made to access keys that do not exist in the hash. 
当我们试图用散列表中并不存在的键来访问它时，就会返回这个值。
By default, this value is nil.
默认该值为nil

### Mixes In  混入
Enumerable: 

    all?, any?, 
    chunk, collect, collect_concat, count, cycle, detect, 
    drop, drop_while, 
    each_cons, each_entry, each_slice, each_with_index, each_with_object, entries, 
    find, find_all, find_index, first, flat_map, 
    grep, group_by, 
    include?, inject, 
    lazy, 
    map, max, max_by, member?, min, min_by, minmax, minmax_by, 
    none?, 
    one?, 
    partition, 
    reduce, reject, reverse_each, 
    select, slice_before, sort, sort_by, 
    take, take_while, to_a, 
    zip

### Class Methods 类方法
#### []  创建

    Hash[ ‹ key => value ›* ] → hsh
    Hash[ obj ] → hsh

Creates a new hash populated with the given objects. 
根据给定的对象创建一个新的散列表。
Equivalent to creating a hash using the literal { key => value, ...}. 
和用{ key => value, ...}形式创建散列表一样。
Keys and values occur in pairs, so there must be an even number of arguments. 
键和值成堆出现，所以必须参数个数为偶数。
In the second form, obj must respond to `to_hash`.
第二种形式中obj必须可以响应`to_hash`。

    Hash["a", 100, "b", 200]     # => {"a"=>100, "b"=>200}
    Hash["a" => 100, "b" => 200] # => {"a"=>100, "b"=>200}
    { "a" => 100, "b" => 200 }   # => {"a"=>100, "b"=>200}

#### new  新建  1.8

    Hash.new → hsh
    Hash.new( obj ) → hsh
    Hash.new { |hash, key| … } → hsh

Returns a new, empty hash. 
返回一个新的空散列表。
If this hash is subsequently accessed by a key that doesn’t correspond to a hash entry, the value returned depends on the style of new used to create the hash. 
如果随后在访问散列表时使用了没有对应项的键，返回的值依赖创建散列表时所用的new形式。
In the first form, the access returns nil. 
对第一种形式，返回nil。
If obj is specified, this single object will be used for all default values. 
如果指定了obj，该对象将被用作所有值的默认值。
If a block is specified, it will be called with the hash object and the key, and it should return the default value. 
如果给定了block，将以散列表对象和键为参数调用block，且block会返回默认值。
It is the block’s responsibility to store the value in the hash if required.
如果需要，block负责在散列表中存储值。

    h = Hash.new("Go Fish")
    h["a"] = 100
    h["b"] = 200
    h["a"] # => 100
    h["c"] # => "Go Fish"
    # The following alters the single default object
    # 下面改动一个默认对象。
    h["c"].upcase! # => "GO FISH"
    h["d"] # => "GO FISH"
    h.keys # => ["a", "b"]
    # While this creates a new default object each time
    # 这时每次创建一个新的默认对象
    h = Hash.new {|hash, key| hash[key] = "Go Fish: #{key}" }
    h["c"] # => "Go Fish: c"
    h["c"].upcase! # => "GO FISH: C"
    h["d"] # => "Go Fish: d"
    h.keys # => ["c", "d"]

#### try_convert  尝试转化 1.9

    Hash.try_convert( obj ) → a_hash or nil

If obj is not already a hash, attempts to convert it to one by calling its `to_hash` method. 
如果obj不是一个散列表，尝试将它转化为散列表，通过调用它的`to_hash`方法。
Returns nil if no conversion could be made.
如果没有转化则返回nil。

    class ConfigFile
      def initialize(name)
        @content = File.read(name)
      end
      def to_hash
        result = {}
        @content.scan(/^(\w+):\s*(.*)/) do |name, value|
          result[name] = value
        end
        result
      end
    end
    config = ConfigFile.new("some_config")
    Hash.try_convert(config) # => {"user_name"=>"dave", "password"=>"wibble"}


### Instance Methods 实例方法
#### ==  等价性

    hsh == obj → true or false

Equality—Two hashes are equal if they contain the same number of keys and the value corresponding to each key in the first hash is equal (using ==) to the value for the same key in the second. 
等价性--如果两个散列表有相同的默认值，含有相同数目的键且每个键在第一个散列表中对应的值等于（使用==）在第二个散列表中的值，则两个散列表相等。
If obj is not a hash, attempts to convert it using `to_hash` and returns obj == hsh.
如果obj不是散列表，则试图使用`to_hash`方法先将它转换成散列表然后返回obj == hsh。

    h1 = { "a" => 1, "c" => 2 }
    h2 = { 7 => 35, "c" => 2, "a" => 1 }
    h3 = { "a" => 1, "c" => 2, 7 => 35 }
    h4 = { "a" => 1, "d" => 2, "f" => 35 }
    h1 == h2 # => false
    h2 == h3 # => true  <kinder:note> 没想到吧？
    h3 == h4 # => false

#### []  元素引用

    hsh[ key ] → value

Element Reference—Retrieves the value stored for key. 
元素引用--检索key对应的值。
If not found, returns the default value (see Hash.new for details).
如果没有找到key，返回默认值（详见Hash.new）。

    h = { "a" => 100, "b" => 200 }
    h["a"] # => 100
    h["c"] # => nil

#### [ ]=  元素赋值

    hsh[ key ] = value → value

Element Assignment—Associates the value given by value with the key given by key. 
元素赋值--将value值和给定的键key相关联。
key should not have its value changed while it is in use as a key (a String passed as a key will be duplicated and frozen).
当key被用作键时，它的值不能改变（作为键的String将被复制或冻结）。

    h = { "a" => 100, "b" => 200 }
    h["a"] = 9
    h["c"] = 4
    h # => {"a"=>9, "b"=>200, "c"=>4}

#### assoc  键值对数组  1.9

    hsh.assoc( key ) → [ key, val] or nil

Returns the two element array [ key, hsh[key] ] or nil if key does not reference an entry in the hash.
返回两个元素的数组的[ key, hsh[key] ]，如果键在散列表中没有引用的项目，则返回nil。

    h = { "a" => 100, "b" => 200 } # => {"a"=>100, "b"=>200}
    h.assoc("a") # => ["a", 100]
    h.assoc("c") # => nil

#### clear  清除

    hsh.clear → hsh

Removes all key/value pairs from hsh.
从hsh中删除所有键值对。

    h = { "a" => 100, "b" => 200 } # => {"a"=>100, "b"=>200}
    h.clear # => {}

#### compare_by_identity  身份比较  1.9

    hsh.compare_by_identity → hsh

Hashes normally compare key values using eql?, which returns true if two objects have the same value. 
散列表通常使用eql?比较键值，如果两个对象同值返回true。
If you call compare_by_identity, keys will instead be considered to be equal only if they are the same object. 
如果你调用了compare_by_identity，只有键为同一对象时才被认为相等。
Note that when strings are used as keys, they are automatically duplicated, so you will never be able to retrieve a string-keyed entry if keys are compared using identity.
注意当字符串作为键使用时，他们会自动复制，因此如果键使用身份来比较，你绝不会得到一个字符串键的项目。

    key = "key"
    h = { key => 100, 99 => "ninety nine" }
    h[key] # => 100
    h["key"] # => 100
    h[99] # => "ninety nine"
    h.compare_by_identity
    h[key] # => nil
    h["key"] # => nil
    h[99] # => "ninety nine"

#### compare_by_identity?  是否进行身份比较  1.9

    hsh.compare_by_identity? → true or false

Returns true if hsh compares keys by identity.
如果hsh使用身份进行比较，返回true。

#### default  默认 1.8

    hsh.default( key=nil ) → obj

Returns the default value, the value that would be returned by hsh[key] if key did not exist in hsh. 
返回默认值，即当key在hsh中不存在时由hsh[key]返回的那个值。
See also Hash.new and Hash#default=.
另见Hash.new和Hash#default=。

    h = Hash.new   # => {}
    h.default      # => nil
    h.default(2)   # => nil

    h = Hash.new("cat")   # => {}
    h.default             # => "cat"
    h.default(2)          # => "cat"

    h = Hash.new {|h,k| h[k] = k.to_i*10} # => {}
    h.default       # => nil
    h.default(2)    # => 20

#### default=  设置默认值

    hsh.default = obj → hsh

Sets the value returned for a key that does not exist in the hash. 
设置默认值，即当键在散列表中不存在时返回的值。
Use `Hash#default_proc=` to set the proc to be called to calculate a default.
使用`Hash#default_proc=`设置调用proc来计算默认值。

    h = { "a" => 100, "b" => 200 }
    h.default = "Go fish"
    h["a"]     # => 100
    h["z"]     # => "Go fish"
    # This doesn't do what you might hope... (but see default_proc=)
    # 这可能和你希望的不同（看看default_proc=）
    h.default = lambda { |hash, key| hash[key] = key + key }  # <kinder:note> 这是将默认值设置为一个proc对象，而值为键的两倍。
    h[2]        # => #<Proc:0x007fd91290e870@prog.rb:6 (lambda)>
    h["cat"]    # => #<Proc:0x007fd91290e870@prog.rb:6 (lambda)>

#### default_proc  默认proc  1.8

    hsh.default_proc → obj or nil

If Hash.new was invoked with a block, returns that block; otherwise, returns nil.
如果调用Hash.new时带有一个block，则返回那个block；否则返回nil。

    h = Hash.new {|h,k| h[k] = k*k } # => {}
    p = h.default_proc # => #<Proc:0x007fbfe2847a20@prog.rb:1>
    a = [] # => []
    p.call(a, 2)   # <kinder:note> 这种写法真有意思。
    a # => [nil, nil, 4]

#### default_proc=  设置默认proc ⇡New in 2.0⇣

    hsh.default_proc = proc → proc or nil

Sets the proc to be called to calculate values to be returned when a hash is accessed with a key it does not contain. 
设置调用proc来计算值，当访问散列表不包含键时，返回该值。
Removes the default proc if passed nil.
当传入nil时删除默认proc。

    h = { "a" => 100, "b" => 200 }
    h.default = "Go fish"
    h["a"] # => 100
    h["z"] # => "Go fish"
    h.default_proc = lambda { |hash, key| hash[key] = key + key }
    h[2] # => 4
    h["cat"] # => "catcat"

#### delete  删除  1.8

    hsh.delete( key ) → value
    hsh.delete( key ) { |key| … } → value

Deletes from hsh the entry whose key is to key, returning the corresponding value. 
从hsh中删除键为key的项，并返回对应的值。
If the key is not found, returns nil. 
如果没有找到键，则返回nil。
If the optional code block is given and the key is not found, passes it the key and returns the result of block.
如果提供了一个block且没有找到key，则将key传递给block并返回block的结果。

    h = { "a" => 100, "b" => 200 }
    h.delete("a") # => 100
    h.delete("z") # => nil
    h.delete("z") {|el| "#{el} not found" } # => "z not found"

#### delete_if  条件删除

    hsh.delete_if ‹ { |key, value| … } › → hsh or enumerator

Deletes every key/value pair from hsh for which block is true. 
从hsh中删除所有使block为真的键值对。
Returns an Enumerator object if no block is given.
如果没有指定block，返回一个Enumerator。

    h = { "a" => 100, "b" => 200, "c" => 300 }
    h.delete_if {|key, value| key >= "b" } # => {"a"=>100}

#### each  遍历

    hsh.each { |key, value| … } → hsh

Calls block once for each key in hsh, passing the key and value as parameters.
对hsh中的每个键调用一次block，并传递键和值作为block的参数。

    h = { "a" => 100, "b" => 200 }
    h.each {|key, value| puts "#{key} is #{value}" }
    # produces:
    # 
    # a is 100
    # b is 200

#### each_key  遍历键

    hsh.each_key { |key| … } → hsh

Calls block once for each key in hsh, passing the key as a parameter.
对散列表中每个键调用一次block，并传递键作为block的参数。

    h = { "a" => 100, "b" => 200 }
    h.each_key {|key| puts key }
    # produces:
    # a
    # b

#### each_pair  遍历

    hsh.each_pair { |key, value| … } → hsh

Synonym for Hash#each.
和Hash#each同义。

#### each_value  遍历值

    hsh.each_value { |value| … } → hsh

Calls block once for each key in hsh, passing the value as a parameter.
对hsh中的每个键调用一次block，并传递键对应的值作为block的参数。

    h = { "a" => 100, "b" => 200 }
    h.each_value {|value| puts value }
    # produces:
    # 100
    # 200

#### empty?  是否为空

    hsh.empty? → true or false

Returns true if hsh contains no key/value pairs.
如果hsh没有任何键值对，返回true。

    {}.empty? # => true

#### fetch  取值

    hsh.fetch( key ‹ , default › ) → obj
    hsh.fetch( key ) { |key| … } → obj}

Returns a value from the hash for the given key. 
从散列表中返回给定键对应的值。
If the key can’t be found, several options exist. 
如果找不到键；则有几种可能：
With no other arguments, it will raise an IndexError exception; 
如果没有其他参数，则引发一个IndexError异常。
if default is given, then that will be returned; 
如果有默认参数，则返回默认参数。
if the optional code block is specified, then that will be run and its result returned. 
如果有关联的block，则该block会运行，并返回结果。
fetch does not evaluate any default values supplied when the hash was created—it looks only for keys in the hash.
fetch不会计算创建散列表时提供的任何默认值--只在散列表中查找键。

    h = { "a" => 100, "b" => 200 }
    h.fetch("a") # => 100
    h.fetch("z", "go fish") # => "go fish"
    h.fetch("z") {|el| "go fish, #{el}"} # => "go fish, z"

The following example shows that an exception is raised if the key is not found and a default value is not supplied.
下面的例子演示了当找不到键且没有提供默认值时将引发的一个异常。

    h = { "a" => 100, "b" => 200 }
    h.fetch("z")
    # produces:
    # from prog.rb:2:in `<main>'
    # prog.rb:2:in `fetch': key not found: "z" (KeyError)

#### flatten  扁平化  1.9

    hsh.flatten( depth = 1 ) → an_array

Converts hsh to an array and then invokes Array#flatten! on the result.
将hsh转为一个数组，然后对结果调用方法Array#flatten!处理。

    h = { feline: [ "felix", "tom" ], equine: "ed" }
    h.flatten    # => [:feline, ["felix", "tom"], :equine, "ed"]
    h.flatten(1) # => [:feline, ["felix", "tom"], :equine, "ed"]
    h.flatten(2) # => [:feline, "felix", "tom", :equine, "ed"]

#### has_key?  是否有键

    hsh.has_key?( key ) → true or false

Returns true if the given key is present in hsh.
如果hsh中存在给定的键，返回true。

    h = { "a" => 100, "b" => 200 }
    h.has_key?("a") # => true
    h.has_key?("z") # => false

#### has_value?  是否有值

    hsh.has_value?( value ) → true or false

Returns true if the given value is present for some key in hsh.
如果给定值在hsh中是某个键对应的值，则返回true。

    h = { "a" => 100, "b" => 200 }
    h.has_value?(100) # => true
    h.has_value?(999) # => false

#### include?  是否包含

    hsh.include?( key ) → true or false

Synonym for `Hash#has_key?`.
和`Hash#has_key?`同义。

#### index  键

    hsh.index( value ) → key

Deprecated—use Hash#key instead.
不推荐使用--用Hash#key更好。

#### invert  键值互换

    hsh.invert → other_hash

Returns a new hash created by using hsh’s values as keys and using the keys as values. 
返回一个使用hsh的值为键、键为值的新散列表。
If hsh has duplicate values, the result will contain only one of them as a key—which one is not predictable.
如果hsh有重复的值，新散列表值使用其中一个作为键--到底用哪个是不可预测的。
<kinder:note> 真想看源代码，为什么不可预测呢？

    h = { "n" => 100, "m" => 100, "y" => 300, "d" => 200, "a" => 0 }
    h.invert # => {100=>"m", 300=>"y", 200=>"d", 0=>"a"}

#### keep_if  条件保持元素  1.9

    hsh.keep_if { |key, value| … } → hsh or enumerator

Modifies hsh by removing all elements for which block is false (see also Enumerable#select and Hash.select!.) 
通过删除所有让block返回false的元素，修改hsh。
Returns an Enumerator object if no block is given.
如果没有给定block，返回一个Enumerator对象。

    a = { a: 1, b: 2, c: 3}
    a.keep_if {|key, value| key =~ /[bc]/ } # => {:b=>2, :c=>3}
    a # => {:b=>2, :c=>3}
    a.keep_if {|key, value| value.odd? } # => {:c=>3}
    a # => {:c=>3}

#### key  键

    hsh.key( value ) → key or nil

Returns the key of the first hash entry whose value is value.
返回hsh中第一个值为value的项目的键。

    h = { a: 100, b: 200, c: 100 }
    h.key(100) # => :a
    h.key(200) # => :b
    h.key(300) # => nil

#### key?  是否有键

    hsh.key?( key ) → true or false

Synonym for `Hash#has_key?`.
和`Hash#has_key?`同义。

#### keys  键数组

    hsh.keys → array

Returns a new array populated with the keys from this hash. 
返回由散列表的键组成的数组。
See also Hash#values.
参见Hash#values。

    h = { "a" => 100, "b" => 200, "c" => 300, "d" => 400 }
    h.keys # => ["a", "b", "c", "d"]

#### length  键值对个数

    hsh.length → fixnum

Returns the number of key/value pairs in the hash.
返回散列表中键值对的个数。

    h = { "d" => 100, "a" => 200, "v" => 300, "e" => 400 }
    h.length # => 4
    h.delete("a") # => 200
    h.length # => 3

#### member?  是否有键

    hsh.member?( key ) → true or false

Synonym for `Hash#has_key?`.
和`Hash#has_key?`同义。

#### merge  合并 1.8

    hsh.merge( other_hash ) → result_hash
    hsh.merge( other_hash ) { |key, old_val, new_val| … } → result_hash

Returns a new hash containing the contents of `other_hash` and the contents of hsh. 
返回既含有hsh散列表的内容又含有`other_hash`的内容的新散列表。
With no block parameter, overwrites entries in hsh with duplicate keys with those from `other_hash`.
如果没有block参数，在hsh和`other_hash`有重复键的情况下将使用`other_hash`中的项覆盖hsh的项。
If a block is specified, it is called with each duplicate key and the values from the two hashes.
如果给定了block，将以重复的键和两个散列表的值为参数调用此block。
The value returned by the block is stored in the new hash.
block的返回值将作为新散列表的值。

    h1 = { "a" => 100, "b" => 200  }
    h2 = { "b" => 254, "c" => 300  }
    h1.merge(h2)             # =>  {"a"=>100, "b"=>254, "c"=>300}
    h1.merge(h2) {|k,o,n| o} # =>  {"a"=>100, "b"=>200, "c"=>300}
    h1                       # =>  {"a"=>100, "b"=>200}

#### merge!  合并  1.8

    hsh.merge!( other_hash ) → hsh
    hsh.merge!( other_hash ) { |key, old_val, new_val| … } → hsh

Like Hash#merge but changes the contents of hsh.
和Hash#merge一样，但改变了hsh的内容。

    h1 = { "a" => 100, "b" => 200 }
    h2 = { "b" => 254, "c" => 300 }
    h1.merge!(h2) # => {"a"=>100, "b"=>254, "c"=>300}
    h1            # => {"a"=>100, "b"=>254, "c"=>300}

#### rassoc  查找键值对数组

    hsh.rassoc( val ) → [ key, val] or nil

Searches hsh for the first element whose value is val, returning the key and value as a twoelement array. 
搜索hsh中第一个值为val的元素，返回键值对作为两元素数组。
Returns nil if the value does not occur in the hash.
如果该值在散列表中不存在，则返回nil。

    h = { "a" => 100, "b" => 200, "c" => 100 }
    h.rassoc(100) # => ["a", 100]
    h.rassoc(200) # => ["b", 200]

#### rehash  重构散列表

    hsh.rehash → hsh

Rebuilds the hash based on the current hash values for each key. 
根据每个键的当前值重构散列表。
If values of key objects have changed since they were inserted, this method will reindex hsh. 
如果在键对象插入散列表后其值发生了变化，使用此方法来为hsh重新索引。
If Hash#rehash is called while an iterator is traversing the hash, an IndexError will be raised in the iterator.
如果在用迭代遍历散列表时调用该方法，则迭代内会引发IndexError异常。

    a = [ "a", "b" ]
    c = [ "c", "d" ]
    h = { a => 100, c => 300 }
    h[a] # => 100
    a[0] = "z"
    h[a] # => nil
    h.rehash # => {["z", "b"]=>100, ["c", "d"]=>300}
    h[a] # => 100

#### reject  条件删除

    hsh.reject { |key, value| … } → hash

Same as `Hash#delete_if` but uses (and returns) a copy of hsh. 
和`Hash#delete_if`一样，但是在hsh的拷贝上处理。
Equivalent to `hsh.dup.delete_if`.
等价于`hsh.dup.delete_if`。

#### reject!  条件删除

    hsh.reject! ‹ { |key, value| … } › → hsh or enumerator

Equivalent to `Hash#delete_if` but returns nil if no changes were made. 
等价于`Hash#delete_if`；但如果没有任何改动则返回nil。
Returns an Enumerator object if no block is given.
如果没有给定block，则返回一个Enumerator对象。

#### replace  替换

    hsh.replace( other_hash ) → hsh

Replaces the contents of hsh with the contents of `other_hash`.
使用`other_hash`的内容替换hsh的内容。

    h = { "a" => 100, "b" => 200 }
    h.replace({ "c" => 300, "d" => 400 }) # => {"c"=>300, "d"=>400}

#### select  筛选

    hsh.select { |key, value| … } → hash

Returns a new hash consisting of [ key, value] pairs for which the block returns true. 
返回让block返回true的[key, value]对组成的一个散列表。
Also see `Hash#values_at`. 
参见`Hash#values_at`。
(This behavior differs from Ruby 1.8, which returns an array of arrays.)
(这个表现和ruby 1.8不同，1.8返回的是数组的数组。)

    h = { "a" => 100, "b" => 200, "c" => 300 }
    h.select {|k,v| k > "a"} # => {"b"=>200, "c"=>300}
    h.select {|k,v| v < 200} # => {"a"=>100}

#### select!  筛选  1.9

    hsh.select! { |key, value| … } → hsh, nil, or enumerator

Modifies hsh by removing all elements for which block is false (see also Enumerable#select and `Hash#keep_if`). 
通过移除所有让block返回false的元素来修改hsh（另见Enumerable#select和`Hash#keep_if`）。
Returns nil if no changes were made or returns an Enumerator object if no block is given. 
如果没有改变则返回nil，如果没有指定block则返回一个Enumerator对象。
Otherwise, returns hsh.
其他情况，返回hsh。

    a = { a: 1, b:2, c: 3}
    a.select! {|key, value| value < 2 } # => {:a=>1}
    a                                   # => {:a=>1}
    a.select! {|key, value| value < 3 } # => nil
    a                                   # => {:a=>1}

#### shift  移除  1.8

    hsh.shift → array or nil

Removes a key/value pair from hsh and returns it as the two-item array [ key, value ]. 
从hsh中删除一个键值对，并返回由它们组成的含有两个元素的数组[key,value]。
If the hash is empty, returns the default value, calls the default proc (with a key value of nil), or returns nil.
如果散列表为空，则返回默认值，并调用默认的proc（以nil键值为参数）或返回nil。

    h = { 1 => "a", 2 => "b", 3 => "c" }
    h.shift # => [1, "a"]
    h # => {2=>"b", 3=>"c"}

#### size  项目个数

    hsh.size → fixnum

Synonym for Hash#length.
和Hash#length同义。

#### sort  排序返回数组

    hsh.sort → array
    hsh.sort { |a, b| … } → array

Converts hsh to a nested array of [ key, value ] arrays and sorts it, using Array#sort. 
将hsh转换成一个由[key, value]数组组成的嵌套数组，并使用Array#sort对它进行排序。
(Technically this is just the sort method of Enumerable. 
It’s documented here because it’s unusual for sort to return a different type.)
（技术上说，这只是Enumerable的sort方法。这里将它写入文档，是因为它排序之后返回一个不同的类型，这很不寻常）

    h = { "a" => 20, "b" => 30, "c" => 10 }
    h.sort # => [["a", 20], ["b", 30], ["c", 10]]
    h.sort {|a,b| a[1]<=>b[1] } # => [["c", 10], ["a", 20], ["b", 30]]

#### store  元素赋值

    hsh.store( key, value ) → value

Synonym for Element Assignment (Hash#[]=).
同元素赋值(Hash#[]=)。

#### to_a  转为数组

    hsh.to_a → array

Converts hsh to a nested array of [ key, value ] arrays.
将hsh转换成一个数组，数组元素是[key, value]组成的数组。

    h = { "c" => 300, "a" => 100, "d" => 400, "c" => 300 }
    h.to_a # => [["c", 300], ["a", 100], ["d", 400]] 

#### to_h 转为散列表 ⇡New in 2.0⇣  

    hsh.to_h → hsh


Returns the hash. 
返回散列表。
Converts the receiver to a hash if send to a subclass of Hash.
如果发送到一个Hash的子类，将接受者转换为一个散列表。

#### to_hash  转为散列表

    hsh.to_hash → hsh

See the discussion in the ducktyping chapter on page 351.
参见前面2版372页4版351页的鸭子类型一章。

#### to_s  转为字符串

    hsh.to_s → string

Converts hsh to a string by converting the hash to an array of [ key, value ] pairs and then converting that array to a string using Array#join with the default separator.
将散列表转为一个由[key, value]对组成的数组，然后使用默认分隔符通过Array#join将数组转为字符串。

    h = { "c" => 300, "a" => 100, "d" => 400, "c" => 300 }
    h.to_s # => "{\"c\"=>300, \"a\"=>100, \"d\"=>400}"

#### update  合并

    hsh.update( other_hash ) → hsh
    hsh.update( other_hash ) { |key, old_val,new_val| … } → hsh

Synonym for Hash#merge!.
和Hash#merge!同义。

#### value?  是否有值

    hsh.value?( value ) → true or false

Synonym for `Hash#has_value?`.
同`Hash#has_value?`。

#### values  值数组

    hsh.values → array

Returns an array populated with the values from hsh. 
返回一个由hsh的值组成的数组。
See also Hash#keys.
另见Hash#keys。

    h = { "a" => 100, "b" => 200, "c" => 300 }
    h.values # => [100, 200, 300]

#### values_at  指定键的值数组 1.8

    hsh.values_at( ‹ key ›+ ) → array

Returns an array consisting of values for the given key(s). 
返回又给定键对应的值组成的数组。
Will insert the default value for keys that are not found.
对于没有找到的键，则插入创建数组时指定的默认值。

    h = { "a" => 100, "b" => 200, "c" => 300 }
    h.values_at("a", "c") # => [100, 300]
    h.values_at("a", "c", "z") # => [100, 300, nil]
    h.default = "cat"
    h.values_at("a", "c", "z") # => [100, 300, "cat"]


## Integer  < Numeric  整数
### 概述
Subclasses: Bignum, Fixnum
子类：Bignum, Fixnum
Integer is the basis for the two concrete classes that hold whole numbers, Bignum and Fixnum.
Integer是表示整数的两个具体的类Bignum和Fixnum的基础。

### Instance Methods 实例方法
#### ceil  转为整数

    int.ceil → integer

Synonym for `Integer#to_i`.
同`Integer#to_i`。

#### chr  返回字符串

    int.chr → string
    int.chr(encoding) → string

Returns a string containing the character represented by the receiver’s value. 
返回接收者的值所表示的字符组成的字符串。
Values less that 128 are always returned as ASCII. 
少于128的值总是作为ASCII字符返回。
The encoding of strings representing higher values can be set using the optional parameter.
更高值的字符串编码可用选项参数进行设置。

    65.chr                   # => "A"
    ?a.chr                   # => "a"
    233.chr                  # => "\xE9"
    233.chr(Encoding::UTF_8) # => "é"

#### denominator  分母 1.9

    int.denominator → integer

Converts the denominator of the rational representation of int.
返回int的有理数表示的分母。

    1.denominator    # => 1                                    
    1.5.denominator  # => 2
    num = 1.0/3      
    num.to_r         # => (6004799503160661/18014398509481984)
    num.denominator  # => 18014398509481984

#### downto  递减

    int.downto( integer ) { |i| … } → int

Iterates block, passing decreasing values from int down to and including integer.
迭代block，并传递从int到integer（包括integer）递减的值作为参数。

    5.downto(1) {|n| print n, ".. " }
    print " Liftoff!\n"
    # produces:
    # 5.. 4.. 3.. 2.. 1..
    # Liftoff!  

#### even?  是否偶数 1.9

    int.even? → true or false

Returns true if int is even.
如果int是偶数返回true。

    1.even? # => false 
    2.even? # => true

#### floor  归整

    int.floor → integer

Returns the largest integer less than or equal to int. 
返回小于或等于int的最大整数。
Equivalent to `Integer#to_i`.
同`Integer#to_i`。

    1.floor     # => 1
    (-1).floor  # => -1

#### gcd  最大公约数  1.9

    int.gcd( other_integer ) → integer

Returns the greatest common denominator of int and `other_integer`.
返回int和`other_integer`的最大公约数。

    10.gcd(15) # => 5
    10.gcd(16) # => 2
    10.gcd(17) # => 1

#### gcdlcm  最大公约数和最小公倍数 1.9

    int.gcdlcm( other_integer ) → [ gcd, lcm ]

Returns both the GCD and the LCM of int and other_integer.
返回int和other_integer的最大公约数和最小公倍数。

    10.gcdlcm(15) # => [5, 30]
    10.gcdlcm(16) # => [2, 80]
    10.gcdlcm(17) # => [1, 170]

#### integer?  是否整数

    int.integer? → true

Always returns true.
总是返回true

#### lcm  最小公倍数

    int.lcm( other_integer ) → integer

Returns the lowest common multiple of int and `other_integer`.
返回int和`other_integer`的最小公倍数。

    10.lcm(15) # => 30
    10.lcm(20) # => 20
    10.lcm(-2) # => 10

#### next  下一个

    int.next → integer

Returns the Integer equal to int+1.
返回int+1的整数。

    1.next # => 2
    (-1).next # => 0

#### numerator  分子  1.9

    int.numerator → integer

Converts the numerator of the rational representation of int.
返回int的有理数表示的分子。

    1.numerator   # => 1                                    
    1.5.numerator # => 3
    num = 1.0/3   
    num.to_r      # => (6004799503160661/18014398509481984)
    num.numerator # => 6004799503160661

#### odd?  是否奇数  1.9

    int.odd? → true or false

Returns true if int is odd.
如果int是奇数，返回true。

    1.odd? # => true  
    2.odd? # => false

#### ord   字符序列号   1.9 

    int.ord → int

The ord method was added to assist in the migration from Ruby 1.8 to 1.9. 
添加ord方法是为了帮助人们从Ruby 1.8迁移到1.9。
It allows ?A.ord to return 65. 
它允许?A.ord返回65。
If ?A returns a string, ord will be called on that string and return 65; 
如果?A返回一个字符串，ord将会被调用来处理该字符串并返回65；
if ?A returns an integer, then Numeric#ord is called, which is basically a no-op.
如果?A返回一个整数，Numeric#ord将被调用，基本上是一个noop。
<kinder:note> 什么noop？

#### pred  上一个  1.9

    int.pred → integer

Returns int - 1.
返回int-1。

#### rationalize  有理化  1.9

    int.rationalize( eps=nil ) → rational

Returns the rational number int/1. 
返回有理数int/1。
The argument is always ignored. 
参数总是被忽略。
Effectively a synonym for `Integer.to_r`.
同`Integer.to_r`。

    99.rationalize # => (99/1)
    -12345678.rationalize(99) # => (-12345678/1)

#### round  返回整数 <kinder:note> 本身就是整数，这不折腾吗？

    int.round → integer

Synonym for `Integer#to_i`.
同`Integer#to_i`。

#### succ  下一个

    int.succ → integer

Synonym for `Integer#next`.
同`Integer#next`。

#### times  迭代

    int.times { |i| … } → int

Iterates block int times, passing in values from zero to int - 1.
int次迭代block，并传递从0到int-1的值作为参数。

    5.times do |i|
      print i, " "
    end
    # produces:
    # 0 1 2 3 4

#### to_i  返回整数 <kinder:note> 多此一举

    int.to_i → int

Returns int.
返回int。

#### to_int  返回整数 <kinder:note> 怎么无聊的方法这么多！

    int.to_int → integer

Synonym for `Integer#to_i`.
同`Integer#to_i`。

#### to_r  有理化  1.9

    int.to_r → number

Converts int to a rational number.
将int转化为一个有理数。

    1.to_r    # => 1/1
    -1.to_r   # => -1/1

#### truncate  返回整数 <kinder:note> 又重复？真想跳楼！

    int.truncate → integer

Synonym for `Integer#to_i`.
同`Integer#to_i`。

#### upto  递增

    int.upto( integer ) { |i| … } → int

Iterates block, passing in integer values from int up to and including integer.
迭代block，并传递从int到integer（包括integer）递增的值作为参数。

    5.upto(10) {|i| print i, " " }
    # produces:
    # 5 6 7 8 9 10


## IO  输入输出
### 概述
Subclasses: File
子类：文件。

Class IO is the basis for all input and output in Ruby. 
在Ruby中IO类是所有输入和输出操作的基础。
An I/O stream may be duplexed (that is, bidirectional) and so may use more than one native operating system stream.
一个IO流可以复用（也就是双向），所以可以使用多个本机操作系统流。

Many of the examples in this section use class File, the only standard subclass of IO. 
本节很多例子使用了File类，它是IO的唯一一个标准子类。
The two classes are closely associated.
这两个类联系很紧密。

As used in this section, portname may take any of the following forms:
如本节所用，portname有如下几种形式：

• A plain string represents a filename suitable for the underlying operating system.
一个普通字符串表示使用于底层操作系统的文件名。

• A string starting with | indicates a subprocess. 
以|开头的字符串表示一个子进程。
The remainder of the string following | is invoked as a process with appropriate input/output channels connected to it.
后面其余的字符串作为一个进程被调用，并为之连接适当的输入/输出通道。

• A string equal to |- will create another Ruby instance as a subprocess.
等于 |- 的字符串将创建另一个Ruby实例子进程。

The IO class uses the Unix abstraction of file descriptors (fds), small integers that represent open files. 
类IO使用了Unix文件描述符，文件描述符是表示已打开文件的小整数。
Conventionally, standard input has an fd of 0, standard output has an fd of 1, and standard error has an fd of 2.
传统上，标准输入的文件描述符是0,标注输出的文件描述符是1而标准错误的文件描述符是2.

Ruby will convert path names between different operating system conventions if possible.
如果可能的话，Ruby会根据不同操作系统的用法转换路径名。
For instance, on Windows the filename /gumby/ruby/test.rb will be opened as \gumby\ruby\test.rb.
例如在Windows系统上文件名/gumby/ruby/test.rb将被作为\gumby\ruby\test.rb打开。
When specifying a Windows-style filename in a double-quoted Ruby string, remember to escape the backslashes.
当双引号字符串中指定Windows风格的文件名时，记住要转义反斜线。
"c:\\gumby\\ruby\\test.rb"

Our examples here will use the Unix-style forward slashes; File::SEPARATOR can be used to get the platform-specific separator character.
我们这里的例子使用Unix风格的斜线：可以用File::SEPARATOR来获得平台相关的路径分隔符。

I/O ports may be opened in any one of several different modes, which are shown in this section as mode. 
I/O 有几种不同的打开方式，本节使用mode来表示这些模式。
This mode string must be one of the values listed in Table 16, Mode values, on page 494. 
mode字符串必须是后面2版504页4版494的表16《mode值》列出的值之一。

As of Ruby 1.9, the mode may also contain information on the external and internal encoding of the data associated with the port. 
在ruby 1.9,mode也可能包含port相关数据的内部和外部编码的信息。
If an external encoding is specified, Ruby assumes that the data it received from the operating system uses that encoding. 
如果给定了外部编码，ruby假定它从操作系统接收的数据使用了该编码。
If no internal encoding is given, strings read from the port will have this encoding. 
如果没有给定内部编码，从port读入的字符串将使用这个编码。
If an internal encoding is given, data will be transcoded from the external to the internal encoding, and strings will have that encoding. 
如果给定内部编码，数据将被从外部编码转换为内部编码，字符串将是该编码。
The reverse happens on output.
输出时则相反。

### Mixes In  混入
Enumerable: 

    all?, any?, 
    chunk, collect, collect_concat, count, cycle, 
    detect, drop, drop_while, 
    each_cons, each_entry, each_slice, each_with_index, each_with_object, entries, 
    find, find_all, find_index, first, flat_map, 
    grep, group_by, 
    include?, inject, 
    lazy, 
    map, max, max_by, member?, min, min_by, minmax, minmax_by, 
    none?, 
    one?, 
    partition, 
    reduce, reject, reverse_each, 
    select, slice_before, sort, sort_by, 
    take, take_while, to_a, 
    zip

### Class Methods 类方法
#### binread  二进制读入  1.9

    IO.binread( name ‹ , length ‹ , offset ›› ) → string

Opens name with mode rb:ASCII-8BIT, reads length bytes starting at offset, and then closes the file. 
带mode rb:ASCII-8BIT打开name，从offset开始读取length字节，然后关闭文件。
The bytes are returned in a string with ASCII-8BIT encoding. 
在一个字符串中用ASCII-8BIT编码返回所读字节。
offset defaults to 0, and length defaults to the number of bytes between offset and the end of the file.
offset默认为0,length默认为从offset到文件结束的字节数。

    IO.binread("testfile", 20)       # => "This is line one\nThi"
    IO.binread("testfile", 20, 20)   # => "s is line two\nThis i"
    str = IO.binread("testfile")     
    str.encoding                     # => #<Encoding:ASCII-8BIT>
    str1 = IO.read("testfile")       
    str1.encoding                    # => #<Encoding:UTF-8>

#### binwrite  二进制写入 1.9

    IO.binwrite( portname, string ‹ , offset › ‹ , options ›) → int

Opens the file for writing with mode wb:ASCII-8BIT, optionally seeks to the given offset, and then writes string. 
带mode rb:ASCII-8BIT打开name，可选地寻找offset，开始写入字符串。
Returns the number of bytes written. 
返回写入的字节数。
The file is truncated before writing if no offset is specified.
如果没有指定offset，则在写入前清空文件。

options is an optional hash used to pass parameters to the underlying open call used by write.
options是一个可选的散列表，用于将参数传入到write一个隐藏的open调用。
See IO.foreach for details.
参见IO.foreach。

#### copy_stream  复制流  1.9

    IO.copy_stream( from, to ‹ , max_length ‹ , offset ›› ) → integer

Copies from to to. 
将from复制到to。
These may be specified either as filenames or as open I/O streams. 
这可能被指定为文件名或打开IO流。
You may optionally specify a maximum length to copy and a byte offset to start the copy from.
你可以选择指定一个最大长度来拷贝，一个偏移字节来开始拷贝。
Returns the number of bytes copied.
返回复制的字节数。

    IO.copy_stream("testfile", "newfile", 10, 10)
    ip = File.open("/etc/passwd")
    op = File.open("extract", "w")
    op.puts "First 20 characters of /etc/passwd"
    IO.copy_stream(ip, op, 20)
    op.puts "\nEnd of extract"
    op.close
    puts File.readlines("extract")
    # produces:
    # 
    # First 20 characters of /etc/passwd
    # ##
    # # User Database
    # #
    # End of extract

#### for_fd  新建  1.8

    IO.for_fd( int, mode ) → io

Synonym for IO.new.
同IO.new。

#### foreach  遍历

    IO.foreach( portname, separator=$/ ‹ , options › ) { |line| … } → nil
    IO.foreach( portname, limit ‹ , options › ) { |line| … } → nil
    IO.foreach( portname, separator, limit ‹ , options › ) { |line| … } → nil

Executes the block for every line in the named I/O port, where lines are separated by separator.
为给定名字的IO端口中的每一行执行相关的block，其中行分隔符是separator。

If separator is nil, the entire file is passed as a single string. 
如果separator为nil，整个文件被传递作为一个单个字符串。
If the limit argument is present and positive, at most that many characters will be returned in each iteration. 
如果limit参数存在且为正数，每一个迭代将返回最多limit字符。
If only the limit argument is given and that argument is negative, then encodings will be ignored while looking for the record separator, which increases performance.
如果只指定limit参数且为负数，寻找记录分隔符时编码将被忽略，那会降低性能。

    IO.foreach("testfile") {|x| puts "GOT: #{x}" }
    # produces:
    # GOT: This is line one
    # GOT: This is line two
    # GOT: This is line three
    # GOT: And so on...

options is an optional hash used to pass parameters to the underlying open call used by read.
options是一个可选的散列表，用于将参数传入到read的一个隐藏的open调用。
It may contain one or more of the following:
它可能包含一个或多个下面的参数：
**encoding**
The encoding for the string, either as "external" or "external:internal"
字符串编码，或作为"external"，或作为"external:internal"。
**mode**
The mode string to be passed to open
mode字符串被传给open。
**`open_args`**
An array containing the arguments to be passed to open; other options are ignored if this one is present
一个数组，包含传给open的参数；如果这个选项存在，则其他选项将被忽略。

    IO.foreach("testfile", nil, mode: "rb", encoding: "ascii-8bit") do |content|
      puts content.encoding
    end
    IO.foreach("testfile", nil, open_args: ["r:iso-8859-1"]) do |content|
      puts content.encoding
    end
    # produces:
    # ASCII-8BIT
    # ISO-8859-1

#### new  新建

    IO.new( integer_fd, mode="r" ‹ , options › ) → io

Returns a new IO object (a stream) for the given integer file descriptor and mode. 
根据给定的整数文件描述符和模式字符串返回一个新的IO对象（一个流）。
The mode and options may be given as for File.new 
mode和options可被指定作为File.new。
(see Table 16, Mode values, on page 494, and see Table 17, File and I/O open options, on page 495). 
（参见前面4版494页的表格16《mode值》495页的表格17《文件和I/0打开参数》）
See also IO#fileno and `IO.for_fd`.
参见IO#fileno 和`IO.for_fd`

    a = IO.new(2, "w")    # '2' is standard error 2为标准错误
    STDERR.puts "Hello"
    a.puts "World"
    # produces:
    # Hello
    # World

    # encoding: utf-8
    b = IO.new(2, mode: "w", encoding: "utf-8", crlf_newline: true)
    b.puts "olé"
    # produces:
    # olé

#### open  打开

    IO.open( ‹ args ›+ ) → io
    IO.open( ‹ args ›+ ) { |io| … } → obj

IO.open creates a new IO object, passing args to that object’s initialize method. 
IO.open创建一个新的IO对象，将args传递到该对象的初始化方法中。
If no block is given, simply returns that object. 
如果没有指定block，只返回该对象。
If a block is given, passes the IO object to the block. 
如果指定block，将IO对象传递到block中。
When the block exits (even via exception or program termination), the io object will be closed. 
block退出时（即使通过异常或程序终结），io对象将被关闭。
If the block is present, IO.open returns the value of the block. 
如果block存在，IO.open返回block的值。
The rough implementation is as follows:
执行大概如下：

    class IO
      def open(*args)
        file = return_value = self.new(*args)
        begin
          return_value = yield(file)
        ensure
          file.close
        end if block_given?
        return_value
      end
    end

Note that subclasses of IO such as File can use open even though their constructors take different parameters. 
注意该IO子类，例如File，能使用open，即使他们的构造器存在不同参数。
Calling File.open(...) will invoke File’s constructor, not IO’s.
调用File.open(...)将调用File的构造器，而不是IO的。

    IO.open(1, "w") do |io|
      io.puts "Writing to stdout"
    end
    # produces:
    # Writing to stdout

    File.open("testfile", mode: "r", encoding: "utf-8") do |f|
      puts f.read
    end
    # produces:
    # This is line one
    # This is line two
    # This is line three
    # And so on...

#### pipe  管道

    IO.pipe → [ read_io, write_io ]
    IO.pipe( encoding_string ‹ , encoding_options › ) → [ read_io, write_io ]
    IO.pipe( external, internal ‹ , encoding_options › ) → [ read_io, write_io ]
    IO.pipe( ... as above ... ) { |read_io, write_io| … }

Creates a pair of pipe endpoints (connected to each other) and returns them as a two-element array of IO objects. 
创建一对管道端点（互相连接），并返回它们作为一个含有两个元素的数组的IO对象。
`write_io` is automatically placed into sync mode. 
`write_io`将自动替换为sync模式。
Not available on all platforms.
并不是在所有平台上可用。

Encodings for the pipes can be specified as a string ("external" or "external:internal") or as two arguments specifying the external and internal encoding names (or encoding objects). 
管道的编码可被string指定（"external"或"external:internal"），也可被external和internal两个编码名参数指定。
If both external and internal encodings are present, the `encoding_options` parameter specifies conversion options (see Table 22, Options to encode and encode!, on page 675).
如果两个编码都存在，`encoding_options`参数将指定conversion参数（见后面4版675页的表格22《encode和encode!的选项》）。

If a block is given, it is passed the two I/O objects. 
如果指定了block，将被传递到两个IO对象。
They will be closed at the end of the block if they are still open.
如果他们仍然打开，它们将在block的结尾被关闭。

In the following example, the two processes close the ends of the pipe that they are not using. 
下面的例子中，两个进程关闭了它们不用的管道端点。
 This is not just a cosmetic nicety. 
这不只是为了美观。
The read end of a pipe will not generate an end-of-file condition if any writers have the pipe still open. 
如果有任意一个write打开管道，那么管道的读取端不会产生end-of-file条件。
In the case of the parent process, the rd.read will never return if it does not first issue a wr.close.
在这个例子的父进程中，如果不先调用wr.close，那么rd.read就永远不会返回。

    IO.pipe do |rd, wr|
      if fork
        wr.close
        puts "Parent got: <#{rd.read}>"
        rd.close
        Process.wait
      else
        rd.close
        puts "Sending message to parent"
        wr.write "Hi Dad"
        wr.close
      end
    end
    # produces:
    # Sending message to parent
    # Parent got: <Hi Dad>

#### popen   子进程打开

    IO.popen( cmd, mode="r" ) → io
    IO.popen( cmd, mode="r" ) { |io| … } → obj

Runs the specified command string as a subprocess; the subprocess’s standard input and output will be connected to the returned IO object. 
以子进程运行指定的命令字符串；该子进程的标准输入和输出连接到返回的IO对象上。
The parameter cmd may be a string or (in Ruby 1.9) an array of strings. 
参数cmd可以是一个字符串或者（在ruby 1.9）字符串数组。
In the latter case, the array is used as the argv parameter for the new process, and no special shell processing is performed on the strings. 
在后一种情况下，数组将被作为新进程的argv参数，且在字符串上不执行任何特殊shell处理。
In addition, if the array starts with a hash, it will be used to set environment variables in the subprocess, and if it ends with a hash, the hash will be used to set execution options for the subprocess.
另外，如果数组用一个散列表开始，散列表将被用于设置子进程的环境变量；如果用一个散列表结束，散列表将用于为子进程设置执行选项。
See Object#spawn for details. 
详见Object#spawn。

If cmd is a string, it will be subject to shell expansion. 
如果cmd是个字符串，它将会被shell扩展。
If the cmd string starts with a minus sign (-) and the operating system supports fork(2), then the current Ruby process is forked. 
如果cmd字符串以减号（-）开头，且操作系统支持fork(2)，那么当前的ruby进程将被克隆(forked)。
The default mode for the new file object is r, but mode may be set to any of the modes in Table 16, Mode values, on page 494.
新文件对象的默认模式是r，但modestring可以为前面2版504页4版494页表格16《模式值》列出的任何模式。

If a block is given, Ruby will run the command as a child connected to Ruby with a pipe.
如果带有block，ruby将以通过管道连接到ruby的一个子进程来运行命令。
Ruby’s end of the pipe will be passed as a parameter to the block. 
管道的ruby这一端将作为参数传递给block。
In this case, IO.popen returns the value of the block.
在这种情况下，IO.popen返回block的值。

If a block is given with a `cmd_string` of "-", the block will be run in two separate processes:
如果带有block，且`cmd_string`是“-”，那么block将在两个进程中运行：
once in the parent and once in a child. 
一个是父进程，一个是子进程。
The parent process will be passed the pipe object as a parameter to the block, the child version of the block will be passed nil, and the child’s standard in and standard out will be connected to the parent through the pipe. 
父进程中将传递管道对象作为block的参数，子进程中传递nil作为block的参数，并且子进程的标准输入和标准输出将通过管道链接到父进程。
Not available on all platforms. 
不是在所有平台上都支持。
Also see the Open3 library on page 782 and Object#exec on page 615.
另见后面2版708页4版782页的open3库和后面2版512页4版615页的Object#exec。

    pipe = IO.popen("uname")
    p(pipe.readlines)
    puts "Parent is #{Process.pid}"
    IO.popen("date") {|pipe| puts pipe.gets }
    IO.popen("-") {|pipe| STDERR.puts "#{Process.pid} is here, pipe=#{pipe}" }
    Process.waitall
    # produces:
    # ["Darwin\n"]
    # Parent is 23465
    # Mon May 27 12:32:20 CDT 2013
    # 23465 is here, pipe=#<IO:0x007f935290e768>
    # 23468 is here, pipe=


Here’s an example that uses the Ruby 1.9 options to merge standard error and standard output into a single stream. 
这是一个例子，使用ruby 1.9选项来合并标准错误和标准输出到一个流中。
Note that buffering means that the error output comes back ahead of the standard output.
注意缓冲意味着错误输出返回到标准输出的前面。

    pipe = IO.popen([ "bc", { STDERR => STDOUT }], "r+" )
    pipe.puts '1 + 3; bad_function()'
    pipe.close_write
    puts pipe.readlines
    # produces:
    # Runtime error (func=(main), adr=8): Function bad_function not defined.
    # 4

#### read  读取  1.8

    IO.read( portname, ‹ length=$/ ‹ , offset ›› ‹ , options › ) → string

Opens the file, optionally seeks to the given offset, and then returns length bytes (defaulting to the rest of the file). 
打开文件，将文件指针移动到给定的偏移处，并返回length字节（默认是文件的剩余部分）。
read ensures the file is closed before returning.
read保证返回之前关闭文件。

options is an optional hash used to pass parameters to the underlying open call used by read.
选项是一个可选的散列表，用于传递参数到隐藏的read所用的open调用。

See IO.foreach for details.
详见IO.foreach。

    IO.read("testfile")         # =>  "This is line one\nThis is line two\nThis is
                                # ..  line three\nAnd so on...\n"
    IO.read("testfile", 20)     # =>  "This is line one\nThi"
    IO.read("testfile", 20, 10) # =>  "ne one\nThis is line " 

#### readlines  读取整个文件

    IO.readlines( portname, separator=$/ ‹ , options › ) → array
    IO.readlines( portname, limit ‹ , options › ) → array
    IO.readlines( portname, separator, limit ‹ , options › ) → array

Reads the entire file specified by portname as individual lines and returns those lines in an array. 
读取portname指定的整个文件，把文件内容作为一个个行，并返回由这些行组成的一个数组。
Lines are separated by separator. 
行分隔符为separator。
If separator is nil, the entire file is passed as a single string. 
如果separator是nil，这个文件被作为一个字符串。
If the limit argument is present and positive, at most that many characters will be returned in each iteration. 
如果limit参数存在且为正数，每一个迭代将返回最多limit字符。
If only the limit argument is given and that argument is negative, then encodings will be ignored while looking for the record separator, which increases performance. 
如果只指定limit参数且为负数，寻找记录分隔符时编码将被忽略，那会降低性能。
options is an optional hash used to pass parameters to the underlying open call used by read. 
options是一个可选的散列表，用于传递参数给read使用的隐藏的open调用。
See IO.foreach for details.
详见IO.foreach。

    a = IO.readlines("testfile")
    a[0] # => "This is line one\n"

#### select  选择

    IO.select( read_array ‹ , write_array ‹ , error_array ‹ , timeout ››› ) → array or nil

See Object#select on page 624.
参见后面2版528页4版624页的Object#select。

#### sysopen  文件描述符 1.8

    IO.sysopen( path, ‹ mode ‹ , perm ›› ) → int

Opens the given path, returning the underlying file descriptor as a Fixnum.
打开给定的路径，以Fixnum返回底层的文件描述符。

    IO.sysopen("testfile") # => 5

#### try_convert  尝试转换

    IO.try_convert( obj ) → an_io or nil

If obj is not already an I/O object, attempts to convert it to one by calling its `to_io` method.
如果obj还不是一个I/O对象，尝试通过调用`to_io`方法将它转换为一个IO对象
Returns nil if no conversion could be made.
如果没有进行转换，返回nil。

    class SillyIOObject
      def to_io
        STDOUT
      end
    end
    IO.try_convert(SillyIOObject.new) # => #<IO:<STDOUT>>
    IO.try_convert("Shemp") # => nil

#### write   写入

    IO.write( portname, string ‹ , offset › ‹ , options ›) → int

Opens the file for writing, optionally seeks to the given offset, and then writes string. 
打开文件以便写入，可选地寻找指定的偏移，返回写入字符串。
Returns the number of bytes written. 
然后写入的字节数。
The file is truncated before writing if no offset is specified.
如果没有指定偏移量offset，写入之前文件被清空。
options is an optional hash used to pass parameters to the underlying open call used by read.
options是一个可选的散列表，用于将参数传入到read使用的一个隐藏的open调用。
See IO.foreach for details.
详见IO.foreach。

    IO.write("somefile", "my string") # => 9
    IO.read("somefile")               # => "my string"
    IO.write("somefile", "adden", 1)  # => 5
    IO.read("somefile")               # => "maddening"


### Instance Methods 实例方法
#### <<  字符串输出

    io << obj → io

String Output—Writes obj to io. 
字符串输出--输出obj到io。
obj will be converted to a string using `to_s`.
obj将被`to_s`转换成一个字符串。

    STDOUT << "Hello " << "world!\n"
    # produces:
    # Hello world!

#### advise  优化建议 1.9

    io.advise(advice, offset=0, length=0) → nil

Help your operating system optimize I/O by telling it how you plan to access this I/O object.
通过通报你访问这个IO对象的计划来帮助你的操作系统优化IO。
The first parameter is a symbol from this table:
第一个参数是下面其中一个：

Table 19—advice parameter to advise 表格 19 -- advise的建议参数
**:normal**       
No particular access pattern is being given. 
不指定特别的访问模式。
**:sequential**   
The portion will be read sequentially.
该部分被连续读入。
**:random**       
The portion will be read in random order.
该部分被乱序读入。
**:willneed**     
The portion will be needed in the near future.
该部分最近需要。
**:dontneed**    
The portion will not be needed in the near future.
该部分最近不需要。
**:noreuse**      
The portion will not be reused in the near future.
该部分最近不会重用。


The second and third parameters denote the region of the file to be accessed. 
第二和第三个参数表示被访问的文件区域。
Their default values of zeroes mean the entire file. 
这两个的默认值都为0表示整个文件。
See the `posix_fadvise(2)` man page for details.
详见`posix_fadvise(2)`的手册页。

#### autoclose=  设置自动关闭

    io.autoclose = true or false → io

Normally when an I/O object is finalized, the corresponding fd is automatically closed. 
通常一个IO对象结束时，相应的文件描述符会自动关闭。
By setting autoclose=false, you prevent this behavior. 
通过设置autoclose=false，你可以阻止这个行为。
This is useful if you’re using an I/O object to access an fd that’s open elsewhere in your program, and you don’t want to affect that other object.
如果你正在使用IO对象来访问一个程序中打开的文件描述符，并且你不想影响其他对象，这是很有用的。

#### autoclose?  是否自动关闭

    io.autoclose? → true or false

Returns the state of the autoclose flag for io.
返回io的自动关闭标志的状态。

#### binmode  二进制模式

    io.binmode → io

Puts io into binary mode. 
将io放入二进制模式。
It is more common to use the "b" modifier in the mode string to set binary mode when you open a file. 
当你打开一个文件时，在mode字符串中使用“b”修饰符来设置二进制模式，是很常见的。
Binary mode is required when reading or writing files containing bit sequences that are not valid in the encoding of the file. 
当读取或写入包含无效编码的字节流的文件时，需要二进制模式。
Once a stream is in binary mode, it cannot be reset to nonbinary mode.
一旦流在二进制模式，它不能被重设为非二进制模式。

#### binmode?  是否二进制模式

    io.binmode? → true or false

Returns true if io is in binary mode.
如果io在二进制模式，返回true。

    f = File.open("/etc/passwd")
    f.binmode? # => false
    f = File.open("/etc/passwd", "rb:binary")
    f.binmode? # => true

#### bytes  字节 ⇡New in 2.0⇣

    io.bytes → enumerator

Returns an enumerator that iterates over the bytes (not characters) in io, returning each as an integer. 
迭代io的每个字节返回一个枚举，每个返回为一个整数。
See also IO#getbyte. 
另见IO#getbyte。
Deprecated in Ruby 2.0.
在Ruby 2.0中不推荐。

    enum = File.open("testfile").bytes # => prog.rb:1: warning: IO#bytes is
                                       # .. deprecated; use #each_byte instead
    enum.first(10)                     # => [84, 104, 105, 115, 32, 105, 115, 32,
                                       # .. 108, 105]
                                            
#### chars  字符 ⇡New in 2.0⇣

    io.chars → enumerator

Returns an enumerator that allows iteration over the characters in io. 
允许迭代io里的字符，返回一个枚举。
Deprecated in Ruby 2.0.
在Ruby 2.0中不推荐使用。

    enum = File.open("testfile").chars # => prog.rb:1: warning: IO#chars is
                                       # .. deprecated; use #each_char instead
    enum.first(7)                      # => ["T", "h", "i", "s", " ", "i", "s"]

#### close  关闭

    io.close → nil

Closes io and flushes any pending writes to the operating system. 
关闭io，并将所有未写入的数据写到操作系统中。
The stream is unavailable for any further data operations; an IOError is raised if such an attempt is made. 
此后该流将无法进行任何数据操作；如果试图操作，则该流将引发IOError.
I/O streams are automatically closed when they are claimed by the garbage collector.
当进行垃圾回收时，为关闭的io流将自动被关闭。

#### close_on_exec?  是否执行中关闭  1.9

    io.close_on_exec? → true or false

Returns the state of the close on exec flag for io. 
返回io的执行标志的关闭状态。
Raises NotImplemented if not available.
如果不可用抛出NotImplemented异常。

#### close_on_exec=  设置执行中关闭  1.9

    io.close_on_exec = true or false → nil

Sets the close on exec flag for io. 
设置io的执行标志的关闭状态。
Raises NotImplemented if not available. 
如果不可用抛出一个NotImplemented异常。
I/O objects with this flag set will be closed across exec() calls.
带有这个标志设置的IO对象将通过exec()调用被关闭。

#### close_read  关闭读取端

    io.close_read → nil

Closes the read end of a duplex I/O stream (in other words, one that contains both a read and a write stream, such as a pipe). 
关闭双向IO流（包含读流和写流的流，例如管道）的读取端。
Raises IOError if the stream is not duplexed.
如果流不是双向的，则会引发IOError。

    f = IO.popen("/bin/sh","r+")
    f.close_read
    f.readlines
    # produces:
    # 
    # from prog.rb:3:in `<main>'
    # prog.rb:3:in `readlines': not opened for reading (IOError)

#### close_write  关闭写入端

    io.close_write → nil

Closes the write end of a duplex I/O stream (in other words, one that contains both a read and a write stream, such as a pipe). 
关闭双向IO流（包含读流和写流的流，例如管道）的写入端。
Will raise IOError if the stream is not duplexed.
如果流不是双向的，则会引发IOError。

#### closed?  是否关闭

    io.closed? → true or false

Returns true if io is completely closed (for duplex streams, both reader and writer) and returns false otherwise.
如果io被完全关闭（对双向流而言，包括读和写），则返回true，否则返回false。

    f = File.new("testfile")
    f.close             # => nil
    f.closed?           # => true
    f = IO.popen("/bin/sh","r+")
    f.close_write       # => nil
    f.closed?           # => false
    f.close_read        # => nil
    f.closed?           # => true

#### codepoints  代码点 ⇡New in 2.0⇣

    io.codepoints { |codepoint| … } → io
    io.codepoints → enumerator

Synonym for `IO#each_codepoint`. 
同`IO#each_codepoint`。
Deprecated in Ruby 2.0.
在Ruby 2.0中不推荐。

#### each  遍历

    io.each( separator=$/ ) { |line| … } → io
    io.each( limit ) { |line| … } → io
    io.each( separator, limit ) { |line| … } → io
    io.each( args.. ) → enum

Executes the block for every line in io, where lines are separated by separator. 
对io的每一行执行block，其中行之间由separator分割。
If separator is nil, the entire file is passed as a single string. 
如果separator为nil，整个文件被当作一个字符串来传递。
If the limit argument is present and positive, at most that many characters will be returned in each iteration. 
如果limit参数存在且为正，每个迭代将返回最多limit个字符。
If only the limit argument is given and that argument is negative, then encodings will be ignored while looking for the record separator, which increases performance. 
如果只指定limit参数且为负数，寻找记录分隔符时编码将被忽略，那会降低性能。
Returns an enumerator if no block is given.
如果没有给定block，将返回一个枚举。

    f = File.new("testfile")
    f.each {|line| puts "#{f.lineno}: #{line}" }
    # produces:
    # 1: This is line one
    # 2: This is line two
    # 3: This is line three
    # 4: And so on...

#### each_byte  遍历字节

    io.each_byte { |byte| … } → nil
    io.each_byte → enum

Calls the given block once for each byte (a Fixnum in the range 0 to 255) in io, passing the byte as an argument. 
对io中的每个字节（0到255之间的Fixnum），以该字节为参数调用给定的block。
The stream must be opened for reading, or IOerror will be raised. 
流必须打开以便读取，否则引发IOerror。
Returns an enumerator if no block is given.
如果没有给定block，返回一个枚举。

    f = File.new("testfile")
    checksum = 0
    f.each_byte {|x| checksum ^= x } # => #<File:testfile>
    checksum # => 12

#### each_char  遍历字符  1.9

    io.each_char { |char| … } → nil
    io.each_char → enum

Calls the given block, passing it each character (a string of length 1) in io. 
调用给定block，将io的每个字符（长度1的字符串）传给它。
The stream must be opened for reading, or an IOerror will be raised. 
流必须打开以读取，否则将跑出IOerror。
Returns an enumerator if no block is given.
如果没有给定block，返回一个枚举。

    f = File.new("testfile")
    result = []
    f.each_char {|ch| result << ch} # => #<File:testfile>
    result[0, 5] # => ["T", "h", "i", "s", " "]

#### each_codepoint  遍历代码点 1.9

    io.each_codepoint { |codepoint| … } → io
    io.each_codepoint → enumerator

Iterates over the codepoints in io, returning each as an integer. 
迭代io里的代码点，每个代码点返回一个整数。
With no block, an enumerator is returned.
没有带block则返回一个枚举。

    #encoding: utf-8
    File.open("/tmp/testfile", "w:utf-8") { |f| f.puts "∂og" }
    File.open("/tmp/testfile") do |f|
      f.each_codepoint { |codepoint| printf "%#X ", codepoint }
    end
    # produces:
    # 0X2202 0X6F 0X67 0XA

#### each_line  遍历行

    io.each_line(...) { |line| … } → io

Synonym for IO#each.
同IO#each。

#### eof  是否末尾

    io.eof → true or false

Returns true if io is at the end of the file. 
如果io处于文件末尾，返回true。
The stream must be opened for reading, or an IOError will be raised.
流必须已经以读模式打开，否则引发IOError。

    f = File.open("testfile")
    f.eof # => false
    dummy = f.readlines
    f.eof # => true

#### eof?  是否末尾

    io.eof? → true or false

Synonym for IO#eof.
同IO#eof。

#### external_encoding  外部编码 1.9

    io.external_encoding → encoding

Returns the encoding object representing the external encoding of this I/O object.
返回这个IO对象的代表外边编码的编码对象。

    io = File.open("testfile", "r:utf-8:iso-8859-1")
    io.external_encoding # => #<Encoding:UTF-8>
    io.internal_encoding # => #<Encoding:ISO-8859-1>

#### fcntl  文件控制

    io.fcntl( cmd, arg ) → int

Provides a mechanism for issuing low-level commands to control or query file-oriented I/O streams. 
提供一种机制来调用底层的命令来控制或查询面向文件的IO流。
Commands (which are integers), arguments, and the result are platform dependent.
命令（是整数）、参数和结果是平台相关的。
If arg is a number, its value is passed directly. 
如果arg是一个数字，它的值会被直接传递。
If it is a string, it is interpreted as a binary sequence of bytes. 
如果是一个字符串，它将被解释为二进制字序节。
On Unix platforms, see fcntl(2) for details. 
在Unix平台上，详见fcntl(2)。
See the Fcntl module on page 754 for symbolic names for the first argument. 
Fcntl模块为第一个参数提供了符号名字，详见后面2版677页4版754页。
Not implemented on all platforms.
仍未在所有平台上实现。

#### fdatasync  同步文件数据  1.9

    io.fdatasync → 0

Uses the operating system’s fdatasync(2) call to write all buffered data associated with io.
使用操作系统的fdatasync(2)调用来写入所有和io相关的缓冲数据。
Raises an exception if the operating system does not support fdatasync(2).
如果操作系统不支持fdatasync(2)则抛出一个异常。

#### fileno  文件描述符

    io.fileno → int

Returns an integer representing the numeric file descriptor for io.
返回表示io文件描述符的数字整数。

    STDIN.fileno # => 0
    STDOUT.fileno # => 1

#### flush  刷入系统

    io.flush → io

Flushes any buffered data within io to the underlying operating system (note that this is Ruby internal buffering only; the OS may buffer the data as well).
将io内所有缓冲的数据写入底层的操作系统（注意这只对ruby的内部缓冲；OS也可能缓冲数据）。

    STDOUT.print "no newline"
    STDOUT.flush
    # produces:
    # no newline

#### fsync  写入缓存数据  1.8

    io.fsync → 0 or nil

Immediately writes all buffered data in io to disk. 
立即将io中缓存的所有数据写入磁盘。
Returns nil if the underlying operating system does not support fsync(2). 
如果底层的操作系统不支持fsync(2)，则返回nil。
Note that fsync differs from using IO#sync=. 
注意fsync和IO#sync=不同。
The latter ensures that data is flushed from Ruby’s buffers but does not guarantee that the underlying operating system actually writes it to disk.
后者保证ruby自己缓存的数据被写入操作系统，但是不能保证底层的操作系统真正将数据写入到磁盘。

#### getbyte  获得字节  1.9

    io.getbyte → fixnum or nil

Returns the next 8-bit byte (as opposed to an encoded character) from io or returns nil at the end of the file. 
从io中获得下一个8位字节（和可编码字符0..255相对）；如果到达文件末尾，返回nil。
See also IO#bytes.
另见IO#bytes。

    file = File.open("testfile")
    file.getbyte # => 84
    file.getbyte # => 104

#### getc  获得字符

    io.getc → string or nil


Gets the next character from io. 
从io中获得下一个字符。
Returns nil if called at the end of the file.
如果到达文件末尾，返回nil。

    f = File.new("testfile")
    f.getc # => "T"
    f.getc # => "h"

#### gets  读取行

    io.gets( separator=$/ ) → string or nil
    io.gets( limit ) → string or nil
    io.gets( separator, limit ) → string or nil

Reads the next “line” from the I/O stream; lines are separated by separator. 
从IO流中读取下一“行”，行之间由separator分割。
A separator of nil reads the entire contents, and a zero-length separator reads the input a paragraph at a time (two or more successive newlines in the input separate paragraphs). 
如果分隔符为nil，则读取整个文件；如果分隔符长度为0,则一次读一段（输入中两个或更多的连续的新行分隔段落）。
If the limit argument is present and positive, at most that many characters will be returned in each iteration. 
如果limit参数存在且为正，每个迭代将返回最多limit个字符。
If only the limit argument is given and that argument is negative, then encodings will be ignored while looking for the record separator, which increases performance. 
如果只指定limit参数且为负数，寻找记录分隔符时编码将被忽略，那会降低性能。
The line read in will be returned and also assigned to `$_` (although the setting of `$_` is considered ugly—it may be removed in future). 
读入的行将被返回，并赋予`$_`（不过`$_`的设置被认为很丑陋，未来可能会删除它）
Returns nil if called at the end of the file.
如果到达文件末尾，返回nil。

    file = File.new("testfile")
    file.gets # => "This is line one\n"
    $_ # => "This is line one\n"
    file.gets(10) # => "This is li"
    file.gets("line") # => "ne two\nThis is line"
    file.gets("line", 4) # => " thr"

#### internal_encoding  内部编码  1.9

    io.internal_encoding → encoding

Returns the encoding object representing the internal encoding of this I/O object.
返回代表这个IO对象的内部编码的编码对象。

    io = File.open("testfile", "r:utf-8:iso-8859-1")
    io.external_encoding # => #<Encoding:UTF-8>
    io.internal_encoding # => #<Encoding:ISO-8859-1>

#### ioctl  io控制

    io.ioctl( cmd, arg ) → int

Provides a mechanism for issuing low-level commands to control or query I/O devices. 
提供一种机制来调用底层的命令来控制或查询IO设备。
The command (which is an integer), arguments, and results are platform dependent. 
命令（是整数）、参数和结果是平台相关的。
If arg is a number, its value is passed directly. 
如果arg是一个数字，它的值将被直接传递。
If it is a string, it is interpreted as a binary sequence of bytes. 
如果是一个字符串，它将被解释为二进制字节序。
On Unix platforms, see ioctl(2) for details. 
在Unix平台上，详见ioctl(2)。
Not implemented on all platforms.
仍为在所有平台上实现。

#### isatty  是否关联到终端

    io.isatty → true or false

Returns true if io is associated with a terminal device (tty) and returns false otherwise.
如果io被关联到过终端设备（tty），则返回true，否则返回false。

    File.new("testfile").isatty # => false
    File.new("/dev/tty").isatty # => true

#### lineno  行号

    io.lineno → int

Returns the current line number in io, which must be opened for reading. 
返回io的当前行号，io必须已经以读模式打开。
lineno counts the number of times gets is called, rather than the number of newlines encountered. 
lineno计算gets被调用的次数，它并不计算遇到的新行的个数。
The two values will differ if gets is called with a separator other than newline. 
如果调用gets时的分隔符不是新行符，那么这两个值会不同。
See also the $. variable.
参见$.变量。

    f = File.new("testfile")
    f.lineno # => 0
    f.gets # => "This is line one\n"
    f.lineno # => 1
    f.gets # => "This is line two\n"
    f.lineno # => 2

#### lineno=  设置行号

    io.lineno = int → int

Manually sets the current line number to the given value. 
手动设置当前行号为给定值。
$. is updated only on the next read.
仅在下次读的时候才更新$.。

    f = File.new("testfile")
    f.gets # => "This is line one\n"
    $.  # => 1
    f.lineno = 1000
    f.lineno # => 1000
    $.  # => 1
    f.gets # => "This is line two\n"
    $.  # => 1001

#### lines  分行  1.9 ⇡New in 2.0⇣

    io.lines( separator=$/ ) → enumerator
    io.lines( limit ) → enumerator
    io.lines( separator, limit ) → enumerator

Returns an enumerator that allows iteration over the lines in io, where lines are terminated by separator. 
返回一个允许迭代io里的行的枚举，行由separator分隔。
If separator is nil, the entire file is passed as a single string. 
如果分隔符为nil，则读取整个文件作为一个字符串传递。
If the limit argument is present and positive, at most that many characters will be returned in each iteration. 
如果limit参数存在且为正，每个迭代将返回最多limit个字符。
If only the limit argument is given and that argument is negative, then encodings will be ignored while looking for the record separator, which increases performance. 
如果只指定limit参数且为负数，寻找记录分隔符时编码将被忽略，那会降低性能。
Deprecated in Ruby 2.0.
ruby2.0中不推荐使用。

#### pid  进程ID

    io.pid → int

Returns the process ID of a child process associated with io. 
返回和io相关的子进程的进程ID。
This will be set by IO.popen.
它是由IO.popen设置的。

    pipe = IO.popen("-")
    if pipe
      STDERR.puts "In parent, child pid is #{pipe.pid}"
      pipe.close
    else
      STDERR.puts "In child, pid is #{$$}"
    end
    # produces:
    # In parent, child pid is 23528
    # In child, pid is 23528

#### pos  偏移

    io.pos → int

Returns the current offset (in bytes) of io.
返回io的当前偏移（以字节为单位）。

    f = File.new("testfile")
    f.pos # => 0
    f.gets # => "This is line one\n"
    f.pos # => 17

#### pos=  设置偏移

    io.pos = int → 0

Seeks to the given position (in bytes) in io.
寻找到io的给定位置（以字节为单位）。

    f = File.new("testfile")
    f.pos = 17
    f.gets # => "This is line two\n"

#### print  写入

    io.print( ‹ obj=$_ ›* ) → nil

Writes the given object(s) to io. 
将给定的对象写入io中。
The stream must be opened for writing. 
流必须以写模式打开。
If the output record separator ($\) is not nil, it will be appended to the output. 
如果输出记录分隔符（$\）不为nil，则将附加到输出流中。
If no arguments are given, prints `$_`. 
如果没有参数，输出`$_`。
Objects that aren’t strings will be converted by calling their `to_s` method. 
不是字符串对象将调用`to_s`方法，并将之转换成字符串。
Returns nil.
返回nil。

    STDOUT.print("This is ", 100, " percent.\n")
    # produces:
    # This is 100 percent.

#### printf  格式写入

    io.printf( format ‹ , obj ›* ) → nil

Formats and writes to io, converting parameters under control of the format string. 
格式化并写入io，根据控制字符串的格式转化对应的参数。
See the description Object#sprintf on page 626 for details.
详见后面2版529页4版626页的Object#sprintf。

#### putc  写入首字符

    io.putc( obj ) → obj

If obj is a string, write its first character. 
如果obj是个字符串，写入第一个字符。
Otherwise treat obj as a number, and write its loworder byte as a character. 
否则将obj作为一个数字，并将其低阶字节作为字符。
Note that this is not encoding safe, because the byte may be just part of a multibyte sequence.
注意这并非编码安全的，因为字节可能只是数字流的一部分。

    #encoding: utf-8
    STDOUT.putc "ABC"
    STDOUT.putc "∂og"
    STDOUT.putc 65
    # produces:
    # A∂A

#### puts  换行写入

    io.puts( ‹ obj ›* ) → nil

Writes the given objects to io as with IO#print. 
和IO#print一样，把给定的对象写入io。
Writes a newline after any that do not already end with a newline sequence. 
如果任一被写入对象不以新行符结尾，则输出一个新行符。
If called with an array argument, writes each element on a new line. 
如果以数组为参数，则每个元素都输出到单独的行上。
If called without arguments, outputs a single newline.
如果不带参数，则输出一个新行。

    STDOUT.puts("this", "is", "a", "test")
    # produces:
    # this
    # is
    # a
    # test

#### read  读取 1.8

    io.read( ‹ int ‹ , buffer ›› ) → string or nil

Reads at most int bytes from the I/O stream or to the end of the file if int is omitted. 
从IO流中至多读取int字节；如果int省略了，则读到文件末尾。
Returns nil if called at the end of the file. 
如果已经到达文件末尾，则返回nil。
If buffer (a string) is provided, it is resized accordingly, and input is read directly into it.
如果提供了buffer（一个字符串），则它将相应地重新调整大小，并直接将读取的内容存储其中。

    f = File.new("testfile")
    f.read(16) # => "This is line one"
    str = "cat"
    f.read(10, str) # => "\nThis is l"
    str # => "\nThis is l"

#### readbyte  读取字节

    io.readbyte → fixnum

Returns the next 8-bit byte (as opposed to an encoded character) from io, raising EOFError at end of file. 
从io中获得下一个8位字节（和可编码字符0..255相对）；如果到达文件末尾，返回nil。
See also IO#bytes.
另见IO#bytes。

#### readchar  读取一个字符

    io.readchar → string

Reads a character as with IO#getc but raises an EOFError on end of file.
和IO#getc一样读取一个字符，但如果到达文件末尾，则引发EOFError。

#### readline  读取一行

    io.readline( separator=$/ ) → string or nil
    io.readline( limit ) → string or nil
    io.readline( separator, limit ) → string or nil

Reads a line as with IO#gets but raises an EOFError on end of file.
和IO#gets一样读取一行，但如果到达文件末尾，则引发EOFError。

#### readlines  读取所有行

    io.readlines( separator=$/ ) → array
    io.readlines( limit ) → array
    io.readlines( separator, limit ) → array

Returns all of the lines in io as an array. 
返回io里的所有行作为一个数组。
Lines are separated by the optional separator. 
每行由可选的separator分隔。
If separator is nil, the entire file is passed as a single string. 
如果separator是nil，整个文件作为一个字符串来传递。
If the limit argument is present and positive, at most that many characters will be returned in each iteration. 
如果limit参数存在且为正，每个迭代将返回最多limit个字符。
If only the limit argument is given and that argument is negative, then encodings will be ignored while looking for the record separator, which increases performance.
如果只指定limit参数且为负数，寻找记录分隔符时编码将被忽略，那会降低性能。

    f = File.new("testfile")
    f.readlines 
    # =>  ["This is line one\n", "This is line two\n", "This is
    # ..  line three\n", "And so on...\n"]
    f = File.new("testfile")
    f.readlines("line") 
    # =>  ["This is line", " one\nThis is line", " two\nThis is
    # ..  line", " three\nAnd so on...\n"]
    f = File.new("testfile")
    f.readlines(10)
    # => ["This is li", "ne one\n", "This is li", "ne two\n", 
    # .. "This is li", "ne three\n", "And so on.", "..\n"]

#### readpartial  读取部分 1.9

    io.readpartial( limit, result="" ) → result

Data read from files and devices is normally buffered. 
从文件和设备读取的数据通常是在缓冲区的。
When reading line by line (for example using IO#gets), Ruby will read many lines at a time into an internal buffer and then return lines from that buffer. 
逐行读取行时，ruby将在一个时间读入很多行到内部缓冲区，然后从缓冲区返回行。
This buffering is normally transparent—Ruby will refill the buffer automatically when required. 
这个缓冲通常是透明的--ruby将在需要时重新自动再填充。
However, when reading from a device or pipe (as opposed to a file), you sometimes want to read whatever is in the buffer, reading from the device or pipe only if the buffer is empty when the read starts. 
不过，当从设备或管道（和文件相反）读入文件时，你有时想读取缓冲里的所有东西，只有在读取开始时缓冲是空的，从设备或管道读取。
This is what readpartial does —it returns any data available in local buffers immediately, only reading from the device or pipe (potentially blocking) if the buffer is empty. 
这就是readpartial工作--它立即返回本地缓冲里的任何可用数据，如果缓冲为空、只从设备或管道（潜在bloking）读取。
Raises EOFError when it reached EOF.
它到达文件末尾时返回EOFError。
See also `IO#read_nonblock`.
另见`IO#read_nonblock`。
The following example comes from the internal documentation, with thanks to the anonymous author:
下面的例子来自内部文档，感谢匿名的作者：
<kinder:note> ???

    r, w = IO.pipe         #            buffer           pipe content
    w << "abc"             #            ""               "abc".
    r.readpartial(4096)    #=> "abc"    ""               ""
    r.readpartial(4096)    # blocks because buffer and pipe is empty.因为缓冲管道都是空的，阻塞。
    
    r, w = IO.pipe          #             buffer        pipe content
    w << "abc"              #             ""            "abc"
    w.close                 #             ""            "abc" EOF
    r.readpartial(4096)     #=> "abc"     ""            EOF
    r.readpartial(4096)     # raises EOFError抛出异常
    
    r, w = IO.pipe          #             buffer        pipe content 
    w << "abc\ndef\n"       #             ""            "abc\ndef\n" 
    r.gets                  #=> "abc\n"   "def\n"       ""           
    w << "ghi\n"            #             "def\n"       "ghi\n"      
    r.readpartial(4096)     #=> "def\n"   ""            "ghi\n"      
    r.readpartial(4096)     #=> "ghi\n"   ""            ""           

#### read_nonblock  非阻塞读入  1.9

    io.readpartial( limit, result="" ) → result
    <kinder:note> 但我认为这里是笔误。正确的应该是：
    io.read_nonblock( limit, result="" ) → result

Effectively the same as IO#readpartial, except in cases where no buffered data is available. 
很像IO#readpartial，除了没有可用的缓冲数据的情况。
In this case, it puts io into nonblocking mode before attempting to read data. 
这种情况，它在读取数据之前，将io放入一个非阻塞模式。
This means that the call may return EAGAIN and EINTR errors, which should be handled by the caller.
这意味着调用可能返回EAGAIN和EINTR错误，可被调用者所处理。

#### reopen  重打开

    io.reopen( other_io ) → io
    io.reopen( path, mode ) → io

Reassociates io with the I/O stream given in `other_io` or to a new stream opened on path. 
重新关联io到给定的`other_io`流或在path上打开的新流。
This may dynamically change the actual class of this stream.
这可能会动态地改变流的实际类。

    f1 = File.new("testfile")
    f2 = File.new("testfile")
    f2.readlines[0] # => "This is line one\n"
    f2.reopen(f1)   # => #<File:testfile>
    f2.readlines[0] # => "This is line one\n"

#### rewind  重新开始

    io.rewind → 0

Positions io to the beginning of input, resetting lineno to zero.
重置io到输入流的开始，且重置lineno为0.

    f = File.new("testfile")
    f.readline # => "This is line one\n"
    f.rewind # => 0
    f.lineno # => 0
    f.readline # => "This is line one\n"

#### seek  移动指针

    io.seek( int, whence=SEEK_SET ) → 0

Seeks to a given offset int in the stream according to the value of whence.
根据whence的值，使流指针移动给定的偏移量int。

**`IO::SEEK_CUR`**
Seeks to int plus current position
移动到当前位置加int处。
**`IO::SEEK_END`**
Seeks to int plus end of stream (you probably want a negative value for int)
从流末尾移动int（需要一个负数int）。
**`IO::SEEK_SET`**
Seeks to the absolute location given by int
移动到绝对地址int处。

    f = File.new("testfile")
    f.seek(-13, IO::SEEK_END) # => 0
    f.readline # => "And so on...\n"

#### set_encoding  设置编码  1.9

    io.set_encoding( external, internal=external‹ , options › ) → io
    io.set_encoding( "external-name:internal-name"‹ , options › ) → io

Sets the external and internal encodings for io. 
为io设置外部编码和内部编码。
In the first form, encodings can be specified by name (using strings) or as encoding objects. 
第一种形式，编码通过名字（使用字符串）或编码对象来指定，
In the second form, the external and internal encoding names are separated by a colon in a string. 
第二种形式，外部和内部编码名字在字符串里通过冒号来分隔。
If present, options specifies the conversion options.
如果存在，options指定转换的选项。

    f = File.new("testfile")
    f.internal_encoding # => nil
    f.external_encoding                       # => #<Encoding:UTF-8>
    f.set_encoding("ascii-8bit:iso-8859-1")   # => #<File:testfile>
    f.internal_encoding                       # => #<Encoding:ISO-8859-1>
    f.external_encoding                       # => #<Encoding:ASCII-8BIT>

#### stat  状态信息

    io.stat → stat

Returns status information for io as an object of type File::Stat.
以File:Stat类型对象返回io的状态信息。

    f = File.new("testfile")
    s = f.stat
    "%o" % s.mode # => "100644"
    s.blksize # => 4096
    s.atime # => 2013-05-27 12:32:23 -0500

#### sync  同步

    io.sync → true or false

Returns the current sync mode of io. 
返回io的当前“同步模式”。
When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered by Ruby. 
当同步模式为真时，所有输出将立即传递给底层的操作系统，ruby不会在内部缓存任何输出数据。
See also IO#fsync.
另见IO#fsync。

#### sync=  设置同步模式

    io.sync = true or false → true or false

Sets the sync mode to true or false. 
设置同步模式为true或false。
When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered internally. 
当同步模式为true，所有输出将立即传递给底层操作系统，ruby不会在内部缓存任何输出数据。
Returns the new state.
返回新状态。
See also IO#fsync.
另见IO#fsync。

    f = File.new("testfile")
    f.sync = true

#### sysread  系统读取  1.8

    io.sysread( int ‹ , buffer › ) → string

Reads int bytes from io using a low-level read and returns them as a string. 
使用底层的读函数从io中读int个字节，并以字符串返回。
If buffer (a string) is provided, input is read directly in to it. 
如果提供了buffer（一个字符串）参数，读取的输入将直接到里面。
Do not mix with other methods that read from io, or you may get unpredictable results. 
不要和io读取数据的其他函数相混，否则会得到意想不到的结果。
Raises SystemCallError on error and EOFError at the end of the file.
遇到结果将引发SystemCallError，到文件结尾将引发EOFError。

    f = File.new("testfile")
    f.sysread(16) # => "This is line one"
    str = "cat"
    f.sysread(10, str) # => "\nThis is l"
    str # => "\nThis is l"

#### sysseek  移动指针  1.8

    io.sysseek( offset, whence=SEEK_SET ) → int

Seeks to a given offset in the stream according to the value of whence (see IO#seek for values of whence). 
根据whence的值，使流指针移动到给定的偏移量offset（whence的值参见IO#seek）。
Returns the new offset into the file.
返回文件的新偏移。

    f = File.new("testfile")
    f.sysseek(-13, IO::SEEK_END) # => 53
    f.sysread(10) # => "And so on."

#### syswrite  系统写入

    io.syswrite( string ) → int

Writes the given string to io using a low-level write. 
使用底层的写函数将给定的字符串写入到io中。
Returns the number of bytes written.
返回写入的字节数。
Do not mix with other methods that write to io, or you may get unpredictable results. 
不要和io的其他写函数混淆，否则会有意想不到的结果。
Raises SystemCallError on error.
遇到错误将引发SystemCallError。

    f = File.new("out", "w")
    f.syswrite("ABCDEF") # => 6

#### tell  偏移

    io.tell → int

Synonym for IO#pos.
同IO#pos。

#### to_i  文件描述符

    io.to_i → int

Synonym for IO#fileno.
同IO#fileno。

#### to_io  转换为io

    io.to_io → io

Returns io.
返回io。

#### tty?  是否关联到终端

    io.tty? → true or false

Synonym for IO#isatty.
同IO#isatty。

#### ungetbyte  退回字节  1.9

    io.ungetbyte( string or int ) → nil

Pushes back one or more bytes onto io, such that a subsequent buffered read will return them. 
将一个字节退还给io，以使随后启用了缓冲的读操作再一次返回它。
Has no effect with unbuffered reads (such as IO#sysread).
对未使用缓冲的读操作无效（例如IO#sysread）。

    f = File.new("testfile")  # => #<File:testfile> 
    c = f.getbyte             # => 84
    f.ungetbyte(c)            # => nil
    f.getbyte                 # => 84
    f.ungetbyte("cat")        # => nil
    f.getbyte                 # => 99
    f.getbyte                 # => 97

#### ungetc  退回字符

    io.ungetc( string ) → nil

Pushes back one or more characters onto io, such that a subsequent buffered read will return them. 
将一个字符退还给io，以使随后启用了缓冲的读操作再一次返回它。
Has no effect with unbuffered reads (such as IO#sysread).
对未使用缓冲的读操作无效（例如IO#sysread）。

    # encoding: utf-8
    f = File.new("testfile") # => #<File:testfile>
    c = f.getc               # => "T"
    f.ungetc(c)              # => nil
    f.getc                   # => "T"
    f.ungetc("∂og")          # => nil
    f.getc                   # => "∂"
    f.getc                   # => "o"

#### write  写入

    io.write( string ) → int

Writes the given string to io. 
将给定的字符串写入io。
The stream must be opened for writing. 
流必须以写模式打开。
If the argument is not a string, it will be converted to a string using `to_s`. 
如果参数不是字符串，使用`to_s`将它转换成字符串。
Returns the number of bytes written.
返回写入的字节数。

    count = STDOUT.write( "This is a test\n" )
    puts "That was #{count} bytes of data"
    # produces:
    # This is a test
    # That was 15 bytes of data

#### write_nonblock  非阻塞写入  1.9

    io.write_nonblock( string ) → int

Writes the given string to io after setting io into nonblocking mode. 
在设置io为非阻塞模式之后写入给定的字符串。
The stream must be opened for writing. 
流必须被打开，以便写入。
If the argument is not a string, it will be converted to a string using to_s.
如果参数不是字符串，使用`to_s`将它转换成字符串。
Returns the number of bytes written. 
返回写入的字节数。
Your application should expect to receive errors typical of nonblocking I/O (including EAGAIN and EINTR).
你的应用程序应期待接受非阻塞IO的典型错误（包括EAGAIN和EINTR）。


## Module Kernel  内核模块
The Kernel module is included by class Object, so its methods are available in every Ruby object. 
object类包含了Kernel模块，所以任意ruby对象都可用它的方法。
The Kernel methods are documented in class Object on page 599.
Kernel模块的文档在后面599页的Object类中。

## Module Marshal  序列模块
### 概述
The marshaling library converts collections of Ruby objects into a byte stream, allowing them to be stored outside the currently active script. 
序列库将ruby对象集合转换成字节流，以使它们可以存储在当前脚本之外。
This data may subsequently be read and the original objects reconstituted. 
随后这些数据可以再次被读取，并重新构造原来的对象。
Marshaling is described in Section 25.7, Marshaling and Distributed Ruby, on page 403. 
前面2版414页4版403页25.7节《序列和分布式ruby》。
Also see the YAML library on page 827.
也见后面2版758页4版827页的YAML库。

Marshaled data has major and minor version numbers stored along with the object information. 
除了对象信息本身，被序列化的数据还有主次版本号。
In normal use, marshaling can load only data written with the same major version number and an equal or lower minor version number. 
通常的用法中，序列化仅能装载那些具有相同主版本号且具有相同或较低次版本号的数据。
If Ruby’s “verbose” flag is set (normally using -d, -v, -w, or --verbose), the major and minor numbers must match exactly. 
如果设置了ruby的“verbose”标志（通常使用-d，-v，-w或-verbose），那么主次版本号必须精确匹配。
Marshal versioning is independent of Ruby’s version numbers. 
序列化的版本号和rby的版本号是独立的。
You can extract the version by reading the first two bytes of marshaled data.
通过提取被序列化的数据的前两个字节可以获得版本号。

Some objects cannot be dumped: if the objects to be dumped include bindings, procedure or method objects, instances of class IO, or singleton objects, or if you try to dump anonymous classes or modules, a TypeError will be raised.
有些对象不能转储：如果被转储的对象包含绑定、过程或方法对象、类IO的实力或单例对象，又或者如果试图转储匿名类或模块，则将引发TypeError。

If your class has special serialization needs (for example, if you want to serialize in some specific format) or if it contains objects that would otherwise not be serializable, you can implement your own serialization strategy using the instance methods `marshal_dump` and `marshal_load`. 
如果你的类有特殊的序列化需求（例如假设你想以特定的格式来序列化），或如果它含有其他情况下无法序列化的对象，那么你可以使用实例方法`marshal_dump`和`marshal_load`实现自定义的序列化策略。
If an object to be marshaled responds to `marshal_dump`, that method is called instead of `_dump`. 
如果将要序列化的对象响应，则调用该`marshal_dump`方法而不是`_dump`。
marshal_dump can return an object of any class (not just a string). 
marshal_dump可以返回任何类的的对象。
A class that implements marshal_dump must also implement marshal_load, which is called as an instance method of a newly allocated object and passed the object originally created by marshal_dump.
一个实现了marshal_dump的类也必须实现marshal_load，该方法作为新分配的对象的实例方法被调用，并以marshal_dump最初创建的对象为参数。

The following code uses this to store a Time object in the serialized version of an object. 
下面的代码使用这来将一个Time对象存储到其序列化对象中。
When loaded, this object is passed to marshal_load, which converts this time to a printable form, storing the result in an instance variable.
当装载的时候，该对象被传递到marshal_load，此函数将其转换成可打印的形式，并将结果存储在一个实例变量中。

    class TimedDump
      attr_reader :when_dumped
      attr_accessor :other_data
      def marshal_dump
        [ Time.now, @other_data ]
      end
      def marshal_load(marshal_data)
        @when_dumped = marshal_data[0].strftime("%I:%M%p")
        @other_data = marshal_data[1]
      end
    end
    t = TimedDump.new
    t.other_data = "wibble"
    t.when_dumped # => nil
    str = Marshal.dump(t)
    newt = Marshal.load(str)
    newt.when_dumped # => "12:32PM"
    newt.other_data # => "wibble"

### Module Constants  模块常量
MAJOR_VERSION 
Major part of marshal format version number
序列化格式版本号的主版本号
MINOR_VERSION 
Minor part of marshal format version number
序列化格式版本号的次版本号

### Class Methods 类方法
#### dump  转储序列化

    dump( obj ‹ , io › , limit=-1 ) → io

Serializes obj and all descendent objects. 
序列化obj及其所有派生对象。
If io is specified, the serialized data will be written to it; otherwise, the data will be returned as a String. 
如果带有io参数，序列化的数据将被写入其中；否则数据将作为字符串类返回。
If limit is specified, the traversal of subobjects will be limited to that depth. 
如果带有limit，则对子对象的遍历深度限于此值。
If the limit is negative, no checking of depth will be performed.
住过limit是负数，则不检查遍历深度。

    class Klass
      def initialize(str)
        @str = str
      end
      def say_hello
        @str
      end
    end
    o = Klass.new("hello\n")
    data = Marshal.dump(o)
    obj = Marshal.load(data)
    obj.say_hello # => "hello\n"

#### load  装载序列化

    load( from ‹ , proc › ) → obj

Returns the result of converting the serialized data in from into a Ruby object (possibly with associated subordinate objects). 
转换from中存储的序列化数据为ruby对象（可能带有相关的子集），并返回转换结果。
from may be either an instance of IO or an object that responds to to_str. 
from可以是IO的实例或能响应to_str的对象。
If proc is specified, it will be passed each object as it is deserialized.
如果带有proc，那么反序列化时每个对象将作为参数传递给proc。

#### restore  装载序列化

    restore( from ‹ , proc › ) → obj

A synonym for Marshal.load.
同Marshal.load。


## MatchData  匹配信息  1.8
### 概述
All pattern matches set the special variable $~ to a MatchData object containing information about the match. 
所有的模式匹配都会设置特殊变量$~为一个包含匹配信息的MatchData。
The methods Regexp#match and `Regexp.last_match` also return a MatchData object. 
方法Regexp#match和`Regexp.last_match`也会返回一个MatchData对象。
The object encapsulates all the results of a pattern match, results normally accessed through the special variables $&, $', $`, $1, $2, and so on—see the list on page 311 for details.
该对象封装了一个模式匹配的所有结果，这些结果可以通过特殊变量$& $` $' $1 $2等等访问，详见前面2版334页4版311页。

### Instance Methods 实例方法
#### []  匹配引用

    match[i] → string
    match[name] → string
    match[start, length] → array
    match[range] → array

Match Reference—MatchData acts as an array and/or hash and may be accessed using the normal indexing techniques. 
匹配引用——MatchData和数组一样可以通过使用通常的下标技术来访问。
Numeric indices return the captures at the corresponding position in the regular expression (starting at 1), and symbol indices return the corresponding named capture. 
数字下标返回正则表达式里对应位置的部分（以1开始），符号下标返回对应的名字部分。
match[0] is equivalent to the special variable $& and returns the entire matched string. 
match[0]等价于特殊变量$&，返回含有整个匹配的字符串。
<kinder:note> 这个规矩好怪，一般都是0表示起始位置。
See also `MatchData#values_at`.
另见`MatchData#values_at`。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m[0] # => "HX1138"
    m[1, 2] # => ["H", "X"]
    m[1..3] # => ["H", "X", "113"]
    m[-3, 2] # => ["X", "113"]
    m = /..(?<digit_prefix>\d+)\d/.match("THX1138.")
    m[:digit_prefix] # => "113"

#### begin  匹配偏移量

    match.begin( n ) → int
    match.begin( name ) → int

Returns the offset in the original string of the start of the nth capture or the named capture.
返回字符串中匹配数据的第n个元素的开始字符的偏移。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.begin(0) # => 1
    m.begin(2) # => 2
    m = /..(?<digit_prefix>\d+)\d/.match("THX1138.")
    m.begin(:digit_prefix) # => 3

#### captures  匹配组

    match.captures → array

Returns the array of all the matching groups. 
返回所有匹配组构成的数组。
Compare to `MatchData#to_a`, which returns both the complete matched string and all the matching groups.
和`MatchData#to_a`相比，`MatchData#to_a`返回完成匹配的字符串以及所有的匹配组。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.captures # => ["H", "X", "113", "8"]

captures is useful when extracting parts of a match in an assignment.
在赋值语句中提取匹配中的部分内容时很有用。

    f1, f2, f3 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures
    f1 # => "H"
    f2 # => "X"
    f3 # => "113"

#### end  后面字符

    match.end( n ) → int
    match.end( name ) → int

Returns the offset in the original string of the end of the nth capture or the named capture.
返回匹配数组中第n个元素结尾后的字符，在字符串中的偏移。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    #=> #<MatchData "HX1138" 1:"H" 2:"X" 3:"113" 4:"8">
    m.end(0) # => 7
    m.end(2) # => 3
    m = /..(?<digit_prefix>\d+)\d/.match("THX1138.")
    #=> #<MatchData "HX1138" digit_prefix:"1138">
    m.end(:digit_prefix) # => 6

#### length  个数

    match.length → int

Returns the number of elements in the match array.
返回匹配数组中元素的个数。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.length # => 5
    m.size # => 5

#### names  名字  1.9

    match.names → array

Returns the list of named captures in the regular expression that created match.
返回正则表达式匹配创建的已命名部分的列表

    m = /(?<prefix>[A-Z]+)(?<hyphen>-?)(?<digits>\d+)/.match("THX1138.")
    m.names # => ["prefix", "hyphen", "digits"]
    m.captures # => ["THX", "", "1138"]
    m[:prefix] # => "THX"

#### offset  偏移

    match.offset( n ) → array
    match.offset( name ) → array

Returns an array containing the beginning and ending offsets of the nth or named capture.
返回一个数组，包含第n个匹配的开始偏移和结束偏移这两个元素。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.offset(0) # => [1, 7]
    m.offset(4) # => [6, 7]
    m = /..(?<digit_prefix>\d+)\d/.match("THX1138.")
    m.offset(:digit_prefix) # => [3, 6]

#### post_match  匹配之后

    match.post_match → string

Returns the portion of the original string after the current match. 
返回原字符串中当前匹配后面的部分。
(Same as the special variable $'.)
等价于特殊变量$'。

    m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
    m.post_match # => ": The Movie"

#### pre_match  匹配之前

    match.pre_match → string

Returns the portion of the original string before the current match. 
返回原字符串中当前匹配前面的部分。
(Same as $`.)
等价于特殊变量$`。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.pre_match # => "T"

#### regexp  正则表达式  1.9

    match.regexp → a_regexp

Returns the regexp object for the regular expression that created match.
返回创建匹配的正则表达式对象。

    m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")
    m.regexp # => /(.)(.)(\d+)(\d)/

#### size  大小

    match.size → int

A synonym for MatchData#length.
同MatchData#length。

#### string  目标字符串

    match.string → string

Returns a frozen copy of the string passed in to match.
返回传递给match的字符串的一个冻结拷贝。

    m /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.string # => "THX1138."

#### to_a  转换为数组

    match.to_a → array

Returns the array of matches. 
返回匹配的数组。
Unlike MatchData#captures, returns the full string matched.
和MatchData#captures不同，返回匹配的整个字符串。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.to_a # => ["HX1138", "H", "X", "113", "8"]

#### to_s  转换为字符串

    match.to_s → string

Returns the entire matched string.
返回匹配的整个字符串。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.to_s # => "HX1138"

#### values_at  匹配引用数组

    match.values_at( ‹ index ›* ) → array

Returns the matches corresponding to the given indices.
返回由指定下标相应的匹配组成数组。

    m = /(.)(.)(\d+)(\d)/.match("THX1138.")
    m.values_at(3,1,2) # => ["113", "H", "X"]
    m.values_at(0, 4) # => ["HX1138", "8"]


## Module Math  数学模块
### 概述
The Math module contains module methods for basic trigonometric and transcendental functions. 
Math模块包含基本三角函数和超越函数等模块方法。
See class Float on page 513 for a list of constants that define Ruby’s floating-point accuracy.
参见前面2版487页4版513页Float类中ruby浮点数精度的常量列表。

### Module Constants  模块常量
E
An approximation of e (base of natural logarithms)
e（自然对数的根）的近似值。
PI
An approximation of π
pi的近似值。

### Class Methods 类方法
#### acos  反余弦值  1.8

    Math.acos( x ) → float

Computes the arc cosine of x. Returns 0..π.
计算x的反余弦值，返回值范围为0..π。

#### acosh  反双曲余弦值  1.8

    Math.acosh( x ) → float

Computes the inverse hyperbolic cosine of x.
计算x的反双曲余弦值。

#### asin  反正弦值  1.8

    Math.asin( x ) → float

Computes the arc sine of x. 
Returns -(π⁄2)..(π⁄2).
计算x的反正弦值。
返回-(π⁄2)..(π⁄2)。

#### asinh  反双曲正弦值  1.8

    Math.asinh( x ) → float

Computes the inverse hyperbolic sine of x.
计算x的反双曲正弦值。

#### atan  反正切值  1.8

    Math.atan( x ) → float

Computes the arc tangent of x. 
计算x的反正切值。
Returns -(π⁄2)..(π⁄2).
返回-(π⁄2)..(π⁄2)。

#### atanh  反双曲正切值  1.8

    Math.atanh( x ) → float

Computes the inverse hyperbolic tangent of x.
计算x的反双曲正切值。

#### atan2  y和x的反正切值  

    Math.atan2( y, x ) → float

Computes the arc tangent given y and x. 
返回给定y和x的反正切值。
Returns -π..π.
返回值的范围为-π..π。

#### cbrt  立方根  1.9

    Math.cbrt( numeric ) → float

Returns the cube root of numeric.
返回数字的立方根。

#### cos  余弦

    Math.cos( x ) → float

Computes the cosine of x (expressed in radians). 
计算弧度表示的x的余弦。
Returns -1..1.
返回值范围为-1..1。

#### cosh  双曲弦余弦 1.8

    Math.cosh( x ) → float

Computes the hyperbolic cosine of x (expressed in radians).
计算以弧度表示的x的双曲线余弦。

#### erf   误差函数  1.8

    Math.erf( x ) → float

Returns the error function of x.
返回x的误差函数。

#### erfc  补误差函数 1.8

    Math.erfc( x ) → float

Returns the complementary error function of x.
返回x的补误差函数。

#### exp  x次方

    Math.exp( x ) → float

Returns e^x .
返回e的x次方。

#### frexp  尾数和指数

    Math.frexp( numeric ) → [ fraction, exponent ]

Returns the normalized fraction (a Float) and exponent (a Fixnum) of numeric.
返回一个两元素数组，包含尾数部分（一个浮点数）和指数部分（一个定数）。

    fraction, exponent = Math.frexp(1234) # => [0.6025390625, 11]
    fraction * 2**exponent # => 1234.0

#### gamma  伽马函数  1.9

    Math.gamma( x ) → float

Returns the gamma function. 
返回伽马函数。
For integral x, gamma(x) approximates factorial(x-1).
对于整数的x，gamma(x)近似于阶乘(x-1)。

    Math.gamma(2)     # => 1.0
    Math.gamma(3)     # => 2.0
    Math.gamma(4)     # => 6.0
    Math.gamma(10.34) # => 784993.6091493163

#### hypot  斜边长度  1.8

    Math.hypot( x, y ) → float

Returns sqrt(x^2 + y^2 ), the hypotenuse of a right-angled triangle with sides x and y.
返回(x^2 + y^2 )的平方根，直角边为x和y的直角三角形的斜边长度。

    Math.hypot(3, 4) # => 5.0

#### ldexp  乘以2的指数

    Math.ldexp( float, n ) → float

Returns the value of float × 2^n .
返回float × 2^n的值。

    fraction, exponent = Math.frexp(1234)
    Math.ldexp(fraction, exponent) # => 1234.0

#### lgamma  伽马函数对数  1.9

    Math.lgamma( x ) → [ float, sign ]

The first element of the returned array is the natural logarithm of the absolute value of the gamma function of x. 
返回一个数组。数组的第一个元素是x的伽马函数的绝对值的自然对数。
The second value is -1 if the gamma function returned a negative number, +1 otherwise.
如果伽马函数返回一个负数，则数组的第二个值为-1；否则为+1。

#### log  对数

    Math.log( numeric ‹ , base=E › ) → float

Returns logarithm of numeric. 
返回numeric的自然对数。
With no base parameter, returns the natural logarith.
如果没有base参数，返回自然对数。

#### log10  十根对数

    Math.log10( numeric ) → float

Returns the base 10 logarithm of numeric.
返回numeric的以10为根的对数。

#### log2  二根对数

    Math.log2( numeric ) → float

Returns the base 2 logarithm of numeric.
返回numeric的以2为根的对数。

#### sin  正弦

    Math.sin( numeric ) → float

Computes the sine of numeric (expressed in radians). 
计算以弧度表示的numeric的正弦。
Returns -1..1.
返回值范围为 -1..1。

#### sinh  双曲正弦  1.8

    Math.sinh( float ) → float

Computes the hyperbolic sine of numeric (expressed in radians).
计算以弧度表示的numeric的双曲正弦。

#### sqrt  非负平方根

    Math.sqrt( float ) → float

Returns the non-negative square root of numeric. 
返回numeric的非负平方根。
Raises ArgError if numeric is less than zero.
如果numeric小于0,则抛出ArgError异常。

#### tan  正切

    Math.tan( float ) → float

Returns the tangent of numeric (expressed in radians).
返回以弧度表示的numeric的正切。

#### tanh  双曲正切  1.8

    Math.tanh( float ) → float

Computes the hyperbolic tangent of numeric (expressed in radians).
计算以弧度表示的numeric的双曲正切。


## Method  方法
### 概述
Method objects are created by Object#method. 
method对象是由Object#method方法创建的。
They are associated with a particular object (not just with a class). 
它们和特定的对象（不仅仅和类）想关联。
They may be used to invoke the method within the object and as a block associated with an iterator. 
可以使用它们来调用对象保存的方法或者作为迭代器想关联的block。
They may also be unbound from one object (creating an UnboundMethod) and bound to another.
可以解除它们对一个对象的关联（创建一个UnboundMethod），并关联到其他对象上。

    def square(n)
      n*n
    end
    meth = self.method(:square)
    meth.call(9) # => 81
    [ 1, 2, 3 ].collect(&meth) # => [1, 4, 9]

### Instance Methods 实例方法
#### []  调用

    meth[ ‹ args ›* ] → object

Synonym for Method#call.
同Method#call。

#### ==  是否相同 1.8

    meth == other → true or false

Returns true if meth is the same method as other.
如果meth和other是同一个方法，返回true。

    def fred()
      puts "Hello"
    end
    alias bert fred # => nil
    m1 = method(:fred)
    m2 = method(:bert)
    m1 == m2 # => true

#### arity  参数个数

    meth.arity → fixnum

Returns a non-negative integer for methods that take a fixed number of arguments. 
对于接受固定个数参数的方法所，返回一个非负整数。
For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. 
对于接收可变个数参数的ruby方法而言，返回-n-1, 这里的n是要求的参数的个数。
For methods written in C, returns -1 if the call takes a variable number of arguments. 
对于用C编写的方法，若其参数个数可变，返回-1。
See also Method#parameters.
另见Method#parameters。

    class C
      def one;               end
      def two(a);            end
      def three(*a);         end
      def four(a, b);        end
      def five(a, b, *c);    end
      def six(a, b, *c, &d); end
    end
    c = C.new
    c.method(:one).arity   # => 0
    c.method(:two).arity   # => 1
    c.method(:three).arity # => -1
    c.method(:four).arity  # => 2
    c.method(:five).arity  # => -3
    c.method(:six).arity   # => -3
    "cat".method(:size).arity     # => 0
    "cat".method(:replace).arity  # => 1
    "cat".method(:squeeze).arity  # => -1
    "cat".method(:count).arity    # => -1

#### call  调用

    meth.call( ‹ args ›* ) → object

Invokes the meth with the specified arguments, returning the method’s return value.
以给定的参数调用meth，返回meth方法的返回值。

    m = 12.method("+")
    m.call(3) # => 15
    m.call(20) # => 32

#### eql?  是否相同  1.8

    meth.eql?(other) → true or false

Returns true if meth is the same method as other.
如果meth和other是一样的方法，返回true。

    def fred()
      puts "Hello"
    end
    alias bert fred # => nil
    m1 = method(:fred)
    m2 = method(:bert)
    m1.eql?(m2) # => true

#### name  名字  1.9

    meth.name → string

Returns the name of the method meth.
返回meth方法的名字

    method = "cat".method(:upcase)
    method.name # => :upcase

#### owner  所属类或模块  1.9

    meth.owner → module

Returns the class or module in which meth is defined.
返回定义了meth方法的类或模块。

    method = "cat".method(:upcase)
    method.owner # => String

#### parameters  参数  1.9

    meth.parameters → array

Returns an array describing the parameters taken by the method. 
返回描述方法所带参数的数组。
Each entry in the array is itself an array. 
数组中的每个项目本身是一个数组。
The first entry of each subarray contains the role of the parameter (:req for required, :opt for optional, :rest for a splat parameter, and :block for a block). 
每个子数组的第一个项目是参数的角色（:req是必须，:opt是可选，:rest是长条，:block是区块）。
If the parameter has a name, it will be the second entry in the subarray.
如果参数有名字，该名字将是子数组的第二个项目。

    def m(a, b=1, *c, &d)
    end
    method(:m).parameters # => [[:req, :a], [:opt, :b], [:rest, :c], [:block, :d]]

#### receiver  接收者  1.9

    meth.receiver → obj

Returns the object on which meth is defined.
返回定义该方法的对象。

    method = "cat".method(:upcase)
    method.receiver # => "cat"

#### source_location  源文件位置  1.9

    meth.source_location → [ filename, lineno ] or nil

Returns the source filename and line number where meth was defined or nil if self was not defined in Ruby source.
返回定义了meth的源文件名和行号，如果self没有在ruby源文件中定义则返回nil。

    internal_method = "cat".method(:upcase)
    internal_method.source_location # => nil
    require 'set'
    set = Set.new
    ruby_method = set.method(:clear)
    ruby_method.source_location[0] # => "/Users/dave/.rvm/rubies/ruby-2.0.0-p0/lib/r
                                   # .. uby/2.0.0/set.rb"
    ruby_method.source_location[1] # => 131

#### to_proc  转换为proc  1.8

    meth.to_proc → prc

Returns a Proc object corresponding to this method. 
返回对应该方法的Proc对象。
Because `to_proc` is called by the interpreter when passing block arguments, method objects may be used following an ampersand to pass a block to another method call. 
因为当传递block参数时解释器将调用`to_proc`，所以可以使用跟在&符后面的方法对象将block传递给另一个方法调用。
See the example at the start of this section.
参见本节开始的例子。

#### unbind  解除绑定  1.8

    meth.unbind → unbound_method

Dissociates meth from its current receiver. 
解除emth方法和当前接收者的关联。
The resulting UnboundMethod can subsequently be bound to a new object of the same class (see UnboundMethod on page 726).
返回的UnboundMethod随后可以关联到相同类的一个新对象上（参见后面2版651页4版726页的UnboundMethod）。


## Module  模块
### 概述
Subclasses: Class
子类：Class
A Module is a collection of methods and constants. 
模块是方法和常量的集合。
The methods in a module may be instance methods or module methods. 
模块内的方法可能是实例方法或者是模块方法。
Instance methods appear as methods in a class when the module is included; module methods do not. 
当包含模块时，它的实例方法会作为方法出现在一个类中；而模块方法则不会出现。
Conversely, module methods may be called without creating an encapsulating object, and instance methods may not. 
相反，可以在未创建混合对象实例的情况下调用模块方法，而实例方法则不可以。
See also `Module#module_function` on page 584.
另见后面2版558页4版584页的`Module#module_function`。
In the descriptions that follow, the parameter symbol refers to a name, which is either a quoted string or a symbol (such as :name).
在下面的描述中，参数symbol指的是一个符号，它可能是一个引号字符串或者是一个Symbol（例如:name）。

    module Mod
      include Math
      CONST = 1
      def meth
        # ...
      end
    end
    Mod.class # => Module
    Mod.constants # => [:CONST, :DomainError, :PI, :E]
    Mod.instance_methods # => [:meth]

### Class Methods 类方法
#### constants  常量数组

    Module.constants → array
    Module.constants( include_parents ) → array

With no argument, returns a list of the top-level constants in the interpreter. 
不带参数，返回解释器中的顶级常量的列表。
With one argument, returns the constants defined in class Module (and its parents if the argument is true). 
只有一个参数时，返回Module类（如果参数为true则和它的父类）定义的常量。
This somewhat obscure interface is because Module is a kind of Class, and Class is a subclass of Module. 
这是模糊之处：模块是一种类，而类是模块的子类。
The first form of call is a true call to the class method constants, while the second form actually proxies to the instance method form (see Module#constants later in this section).
第一种形式的的调用是一个对类方法常量的真调用；第二种形式实际上是实例方法形式的代理（参见本章后面的Module#constants）

    module Mixin
      CONST_MIXIN = 1
    end
    class Module
      include Mixin
      SPURIOUS_CONSTANT = 2
    end
    Module.constants.sort[1..3]             # => [:ARGV, :ArgumentError, :Array]   <kinder:note> 这些是顶级常量
    Module.constants.include? :CONST_MIXIN  # => false
    Module.constants(false)                 # => [:SPURIOUS_CONSTANT]  false即不包括父类
    Module.constants(true)                  # => [:SPURIOUS_CONSTANT, :CONST_MIXIN]  true即包含父类

#### nesting  嵌套

    Module.nesting → array

Returns the list of modules nested at the point of call.
返回在当前调用点上嵌套的模块列表。

    module M1
      module M2
        nest = Module.nesting
        p nest
        p nest[0].name
      end
    end
    # produces:
    # [M1::M2, M1]
    # "M1::M2"

#### new  新建  1.8

    Module.new → mod
    Module.new { |mod| … } → mod

Creates a new anonymous module. 
创建一个新的匿名模块。
If a block is given, it is passed the module object, and the block is evaluated in the context of this module using `module_eval`.
如果给定一个block，模块对象会传递给它，并在这个模块的上下文中使用`module_eval`方法对block进行求解。

    Fred = Module.new do
      def meth1
        "hello"
      end
      def meth2
        "bye"
      end
    end
    a = "my string"
    a.extend(Fred) # => "my string"
    a.meth1 # => "hello"
    a.meth2 # => "bye"


### Instance Methods 实例方法
#### <, <=, ==, >, >=  层次查询

    mod relop module → true, false or nil

Hierarchy Query—One module is considered greater than another if it is included in (or is a parent class of) the other module. 
层次结构查询--如果一个模块包含在别的模块中或者它是别的模块的一个父类，这个模块被认为大于另外一个模块。
The other operators are defined accordingly. 
同样依次定义了别的操作符。
If there is no relationship between the modules, all operators return nil.
如果两个模块之间没有任何关系，则所有操作符都返回false。

    module Mixin
    end
    module Parent
      include Mixin
    end
    module Unrelated
    end
    Parent > Mixin     # => false
    Parent < Mixin     # => true  
    Parent <= Parent   # => true
    Parent < Unrelated # => nil
    Parent > Unrelated # => nil

#### <=>  包含比较

    mod <=> other_mod → -1, 0, +1

Comparison—Returns -1 if mod includes `other_mod`, 0 if mod is the same module as `other_mod`, and +1 if mod is included by `other_mod` or if mod has no relationship with `other_mod`.
比较--如果mod包含了`other_mod`，返回-1；如果mod和`other_mod`是相同模块，返回0；如果mod被包含在`other_mod`中或者两者没有任何关系，返回+1.

#### ===  case等式

    mod === obj → true or false

Case Equality—Returns true if obj is an instance of mod or one of mod’s descendents. 
case等式——如果obj是mod或者其派生类的一个实例，返回true。
Of limited use for modules but can be used in case statements to test objects by class.
很少用于模块，但可以用在case语句中来通过类测试对象。

#### ancestors  模块列表

    mod.ancestors → array

Returns a list of modules included in mod (including mod itself).
返回包含在mod中的模块列表（包括mod本身）。

    module Mod
      include Math
      include Comparable
    end
    Mod.ancestors # => [Mod, Comparable, Math]
    Math.ancestors # => [Math]

#### autoload  自动装载

    mod.autoload( name, file_name ) → nil

Registers `file_name` to be loaded (using Object#require) the first time that module name (which may be a String or a Symbol) is accessed in the namespace of mod. 
注册`file_name`，这样当name（可能是一个字符串类或符号类）模块第一次在mod的名字空间内被访问时，会载入（使用Object#require）`file_name`。
Note that the autoloaded file is evaluated in the top-level context. 
注意自动载入的文件实在顶级环境中被求解。
In this example,`module_b.rb` contains the following:
在这个例子中，`module_b.rb`包括了：

    module A::B
    # in module_b.rb
      def doit
        puts "In Module A::B"
      end
      module_function :doit
    end

Other code can then include this module automatically.
然后其他别的代码可以自动包括这个模块。

    module A
      autoload(:B, "module_b")
    end
    A::B.doit # autoloads "module_b"  自动装载module_b.rb文件
    # produces:
    # In Module A::B

#### autoload?  是否自动装载  1.8

    mod.autoload?( name ) → file_name or nil

Returns the name of the file that will be autoloaded when the string or symbol name is referenced in the context of mod or returns nil if there is no associated autoload.
返回在mod的上下文中引用name字符串或name符号时会自动载入的文件名，或者如果没有关联的自动载入，返回nil。

    module A
      autoload(:B, "module_b")
    end
    A.autoload?(:B) # => "module_b"
    A.autoload?(:C) # => nil

#### class_eval  类求值

    mod.class_eval( string ‹ , file_name ‹ , line_number ›› ) → obj
    mod.class_eval { … } → obj

Synonym for `Module#module_eval`.
同`Module#module_eval`。

#### class_exec  类执行

    mod.class_exec( ‹ args ›+ ) { |args| … } → obj

Synonym for `Module#module_exec`.
同`Module#module_exec`。

#### class_variable_defined?  类变量是否定义  1.9

    mod.class_variable_defined?( name ) → true or false

Returns true if the named class variable is defined in mod. The two @ signs are a required part of the name.
如果已命名类变量在mod中被定义，返回true。
@@符号是名字的必要部分。

    class One
      @@var1 = "wibble"
    end
    One.class_variable_defined?(:@@var1) # => true
    One.class_variable_defined?(:@@var2) # => false

#### class_variable_get  类变量的值  1.9

    mod.class_variable_get( name ) → obj

Returns the value of the named class variable. 
返回已命名类变量的值。
The two @ signs must appear in the name.
@@符号必须出现在name中。

    class One
      @@var1 = "wibble"
    end
    One.class_variable_get(:@@var1) # => "wibble"
    One.class_variable_get("@@var1") # => "wibble"

#### class_variable_set  类变量设置  1.9

    mod.class_variable_set( name, value ) → value

Sets the value of the named class variable. 
设置已命名类变量的值。
The two @ signs must appear in the name.
@@符号必须出现在name中。

    class One
      @@var1 = "wibble"
    end
    One.class_variable_set(:@@var1, 99) # => 99
    One.class_variable_get("@@var1") # => 99

#### class_variables  类变量名称列表

    mod.class_variables → array

Returns an array of the names of class variables in mod. 
返回在mod中的类变量名称的数组。
(As of Ruby 1.9, class variables are no longer shared with child classes, so this listing is restricted to the class variables defined in mod.)
(在ruby 1.9中，类变量不再和子类共享，所以这个列表仅限于mod中定义的类变量)
<kinder:note> 那么下面这个例子最后一行就不合适了。可是ruby2中执行结果确实合适。

    class One
      @@var1 = 1
    end
    class Two < One
      @@var2 = 2
    end
    One.class_variables # => [:@@var1]
    Two.class_variables # => [:@@var2, :@@var1]

#### const_defined?  常量是否定义

    mod.const_defined?( symbol ‹ search_parents=true › ) → true or false

Returns true if a constant with the given name is defined by mod or the parents of mod (if the second parameter is true).
如果一个带有指定名字的常量在mod或其父类（第二个参数为true）中定义，返回true。

    Math.const_defined? "PI" # => true

#### const_get  常量值  ⇡New in 2.0⇣

    mod.const_get( symbol ) → obj

Returns the value of the named constant in mod. 
返回mod中的已命名常量的值。
Ruby 2.0 allows this name to be qualified by one or more module names.
Ruby 2.0允许这个名字限定于一个或多个模块名。

    Math.const_get :PI # => 3.141592653589793
    Object.const_get("Math::PI") # => 3.141592653589793

#### const_missing  常量丢失调用  1.8

    mod.const_missing( symbol ) → obj

Invoked when a reference is made to an undefined constant in mod. 
当引用到mod未定义常量时调用。
It is passed a symbol for the undefined constant and returns a value to be used for that constant. 
它为未定义常量传递一个符号并返回一个用于该常量的值。<kinder:note> ？？？
The following code is very poor style. 
接下来的代码是很低级的。
If a reference is made to an undefined constant, it attempts to load a file whose name is the lowercase version of the constant (thus, class Fred is assumed to be in file fred.rb). 
如果引用到了一个未定义常量，它尝试导入一个名字为常量小写的文件（因此，Fred类被假定装入fred.rb）
If found, it returns the value of the loaded class. 
如果找到，它返回装入类的值。
It therefore implements a perverse kind of autoload facility.
因此这是一个自动装入工具的不正当的实现。

    def Object.const_missing(name)
      @looked_for ||= {}
      str_name = name.to_s
      raise "Class not found: #{name}" if @looked_for[str_name]
      @looked_for[str_name] = 1
      file = str_name.downcase
      require file
      klass = const_get(name)
      return klass if klass
      raise "Class not found: #{name}"
    end

#### const_set  设置常量  

    mod.const_set( symbol, obj ) → obj

Sets the named constant to the given object, returning that object. 
将已命名常量设置为指定对象，返回该对象。
Creates a new constant if no constant with the given name previously existed.
如果没有该给定命名常量存在，新建一个新常量。

    Math.const_set("HIGH_SCHOOL_PI", 22.0/7.0) # => 3.142857142857143
    Math::HIGH_SCHOOL_PI - Math::PI # => 0.0012644892673496777

#### constants  常量

    mod.constants( include_parents = true ) → array

Returns an array of the names of the constants accessible in mod. 
返回mod中可访问的常量的名称数组。
If the parameter is true, this includes the names of constants in any included modules.
如果参数为true，这包括在mod中的任何模块的常量名称。

    IO.constants(false) # => [:WaitReadable, :WaitWritable, :SEEK_SET, :SEEK_CUR,
                        # .. :SEEK_END]
    # Now include stuff defined in module File::Constants
    IO.constants(true)[1,6] # => [:WaitWritable, :SEEK_SET, :SEEK_CUR, :SEEK_END,
                            # .. :RDONLY, :WRONLY]

#### include?  是否包含  1.8

    mod.include?( other_mod ) → true or false

Returns true if `other_mod` is included in mod or one of mod’s ancestors.
如果`other_mod`被包含mod或者其祖先中，返回true。

    module A
    end
    class B
      include A
    end
    class C < B
    end
    B.include?(A) # => true
    C.include?(A) # => true
    A.include?(A) # => false

#### included_modules  包含模块列表

    mod.included_modules → array

Returns the list of modules included in mod.
返回包含在mod中的模块列表。

    module Mixin
    end
    module Outer
      include Mixin
    end
    Mixin.included_modules # => []
    Outer.included_modules # => [Mixin]

#### instance_method  调用实例方法  1.8

    mod.instance_method( symbol ) → unbound_method

Returns an UnboundMethod representing the given instance method in mod.
返回在mod中表示这个给定实例方法的UnboundMethod对象。
<kinder:note> 这个UnboundMethod类详见后面。

    class Interpreter
      def do_a() print "there, "; end
      def do_d() print "Hello ";  end
      def do_e() print "!\n";     end
      def do_v() print "Dave";    end
      Dispatcher = {
        'a' => instance_method(:do_a),
        'd' => instance_method(:do_d),
        'e' => instance_method(:do_e),
        'v' => instance_method(:do_v)
      }
      def interpret(string)
        string.each_char {|ch| Dispatcher[ch].bind(self).call }
        # <kinder:note> 注意上行的bind方法。
      end
    end
    interpreter = Interpreter.new
    interpreter.interpret('dave')
    # produces:
    # Hello there, Dave!

#### instance_methods  实例方法数组  1.8

    mod.instance_methods( inc_super=true ) → array

Returns an array containing the names of public and protected instance methods in the receiver. 
返回一个数组，包含在接收者中的public和protected实例方法的名称。
For a module, these are the public methods; for a class, they are the instance (not singleton) methods. 
对于模块，它是public方法；对于类，它是实例方法（不是单例方法）。
With no argument or with an argument that is true, the methods in mod and mod’s superclasses are returned. 
没有任何参数或者参数是true时，会返回在mod以及mod的超类中的方法的名称。
When called with a module as a receiver or with a parameter that is false, the instance methods in mod are returned.
当一个模块作为接收者被调用或者参数是false时，它会返回mod中的实例方法。
2版提示：在2004年1月之前的ruby版本中，这个参数默认false。

    module A
      def method1
      end
    end
    class B
      def method2
      end
    end
    class C < B
      def method3
      end
    end
    A.instance_methods                 # => [:method1]
    B.instance_methods(false)          # => [:method2]
    C.instance_methods(false)          # => [:method3]
    C.instance_methods(true).length    # => 56
                                            
#### method_defined?  是否定义

    mod.method_defined?( symbol ) → true or false

Returns true if the named method is defined by mod (or its included modules and, if mod is a class, its ancestors). 
如果mod（或者它包括的模块；如果mod是类，或者mod的祖先）定义了给定方法，返回true。
Public and protected methods are matched.
匹配public和protected方法。

    module A
      def method1;
      end
      class B
        def method2;
        end
        class C < B
          include A
          def method3;
          end
        end
      end
    end
    A.method_defined? :method1  # => true
    C.method_defined? "method1" # => true
    C.method_defined? "method2" # => true
    C.method_defined? "method3" # => true
    C.method_defined? "method4" # => false

#### module_eval  模块求值  1.8

    mod.module_eval( string ‹ , file_name ‹ , line_number ›› ) → obj
    mod.module_eval { … } → obj

Evaluates the string or block in the context of mod. 
在mod的上下文中对string或block进行求解。
This can be used to add methods to a class. 
这可以用来把方法添加到一个类中。
`module_eval` returns the result of evaluating its argument. 
`module_eval`对它的参数求解后把结果返回。
The optional `file_name` and `line_number` parameters set the text for error messages.
可选的`file_name`和`line_number`参数设置出错信息文件。

    class Thing
    end
    a = %q{def hello() "Hello there!" end}   # %q是单引号字符串。
    Thing.module_eval(a)
    puts Thing.new.hello()  #1 
    Thing.module_eval("invalid code", "dummy", 123)  #2
    # produces:
    #1  Hello there!
    #2  dummy:123:in `<main>': undefined local variable
    # or method `code' for Thing:Class

#### module_exec  模块执行  1.9

    mod.module_exec( ‹ args ›+ ) { |args| … } → obj

Behaves the same as the block form for `Module#module_eval`, except any parameters passed to the method are in turn passed to the block. 
表现和`Module#module_eval`的block形式一样，但传到方法的任意参数依次传到block中。
This gives you a way of passing in values that would otherwise not be in scope in the block (because self is changed).
这给你一个方式去传入值，不同的方式、不在block的作用域(因为self被改变了)。
<kinder:note> 上行的翻译肯定过分了，怎么改进？

    class Thing
    end
    name = :new_instance_variable
    Thing.module_exec(name) do |iv_name|
      attr_accessor iv_name
    end
    t = Thing.new
    t.new_instance_variable = "wibble"
    p t
    # produces:
    # #<Thing:0x007f9b01847fa8 @new_instance_variable="wibble">

#### name  名称

    mod.name → string

Returns the name of the module mod.
返回mod模块的名称。

#### private_class_method  方法私有化

    mod.private_class_method( ‹ symbol ›+ ) → nil

Makes existing class methods private. 
将已有类方法变成private。
Often used to hide the default constructor new.
常常用于隐藏默认构造函数new。

    class SimpleSingleton # Not thread safe 线程不安全。
      private_class_method :new
      def SimpleSingleton.create(*args, &block)
        @me = new(*args, &block) if ! @me
        @me
      end
    end

#### private_constant  私有常量  1.9

    mod.private_constant( ‹ symbol ›+ ) → mod

Makes the given constants (which must already have been defined) private to the module.
将给定常量设为模块的私有常量。
A private constant cannot be referenced using the module name as a scope, so they effectively can only be accessed within the context of the module itself.
私有常量不能被使用模块名引用为一个作用域，它们实际上只能在模块自身的上下文中访问。

    module A
      B = "my constant"
      private_constant :B
      puts "Inside A, B = #{B.inspect}"
    end
    puts "Outside A, A::B = #{A::B.inspect}"
    # produces:
    # Inside A, B = "my constant"
    # prog.rb:7:in `<main>': private constant A::B referenced (NameError)

#### private_instance_methods  私有实例方法  1.8

    mod.private_instance_methods( inc_super=true ) → array

Returns a list of the private instance methods defined in mod. 
返回定义在mod中的私有实例方法的列表。
If the optional parameter is true, the methods of any ancestors are included.
如果可选参数为true，mod所有祖先的方法也会包括在列表中。
<kinder:note> 2版提示：在2004年1月之前的版本中，这个参数默认值是false。

    module Mod
      def method1; end
      private :method1
      def method2; end
    end
    Mod.instance_methods # => [:method2]
    Mod.private_instance_methods # => [:method1]

#### private_method_defined?  方法是否私有  1.8

    mod.private_method_defined?( symbol ) → true or false

Returns true if the named private method is defined by mod (or its included modules and, if mod is a class, its ancestors).
如果mod（或者它包括的模块；如果mod是类，包括它的祖先）定义了给定的私有方法，返回true。

    module A
      def method1;
      end
      class B
        private
        def method2;
        end
        class C < B
          include A
          def method3;
          end
        end
      end
    end
    A.method_defined? :method1           # => true
    C.private_method_defined? "method1"  # => false
    C.private_method_defined? "method2"  # => true
    C.method_defined? "method2"          # => false

#### protected_instance_methods  受保实例方法  1.8

    mod.protected_instance_methods( inc_super=true ) → array

Returns a list of the protected instance methods defined in mod. 
返回定义在mod中的受保实例方法的列表。
If the optional parameter is true, the methods of any ancestors are included.
如果可选参数为true，mod所有祖先的方法也会包括在列表中。
<kinder:note> 2版提示：在2004年1月之前的版本中，这个参数默认值是false。

#### protected_method_defined?  方法是否受保  1.8

    mod.protected_method_defined?( symbol ) → true or false

Returns true if the named protected method is defined by mod (or its included modules and, if mod is a class, its ancestors).
如果mod（或者它包括的模块；如果mod是类，包括它的祖先）定义了给定的受保方法，返回true。

    module A
      def method1;
      end
      class B
        protected
        def method2;
        end
        class C < B
          include A
          def method3;
          end
        end
      end
    end
    A.method_defined? :method1            # =>  true
    C.protected_method_defined? "method1" # =>  false
    C.protected_method_defined? "method2" # =>  true
    C.method_defined? "method2"           # =>  true

#### public_class_method  方法公共化  1.8

    mod.public_class_method( ‹ symbol ›+ ) → nil

Makes a list of existing class methods public.
将一组已存类方法公共化。

#### public_constant  公共常量  1.9

    mod.public_constant( ‹ symbol ›+ ) → mod

Makes the given constants (which must already have been defined) public, overriding the effect of a previous call to `privante_constant`.
将给定常量（必须已经定义）公开化，覆盖前面调用`privante_constant`的效果。

    module A
      B = "my constant"
      private_constant :B
      puts "Inside A, B = #{B.inspect}"
      public_constant :B
    end
    puts "Outside A, A::B = #{A::B.inspect}"
    # produces:
    # Inside A, B = "my constant"
    # Outside A, A::B = "my constant"

#### public_instance_method  公共实例方法  1.9

    mod.public_instance_method( symbol ) → unbound_method

Returns an UnboundMethod representing the given public instance method in mod. 
返回一个表示给定的mod中的公共实例方法的UnboundMethod类实例。
See also `Module#instance_method`, which ignores scope.
另见`Module#instance_method`，它忽略作用域。

    class Test
      def method_a; end
      private
      def method_b; end
    end
    puts "method_a is #{Test.public_instance_method(:method_a)}"
    puts "method_b is #{Test.public_instance_method(:method_b)}"
    # produces:
    # from prog.rb:7:in `<main>'
    # method_a is #<UnboundMethod: Test#method_a>
    # prog.rb:7:in `public_instance_method': method `method_b' for class `Test' is
    # private (NameError)

#### public_instance_methods  公共实例方法列表  1.8

    mod.public_instance_methods( inc_super=true ) → array

Returns a list of the public instance methods defined in mod. 
返回定义在mod中的公共实例方法的列表。
If the optional parameter is true, the methods of any ancestors are included.
如果可选参数为true，mod所有祖先的方法也会包括在列表中。
<kinder:note> 2版提示：在2004年1月之前的版本中，这个参数默认值是false。

#### public_method_defined?  方法是否公共  1.8

    mod.public_method_defined?( symbol ) → true or false

Returns true if the named public method is defined by mod (or its included modules and, if mod is a class, its ancestors).
如果mod（或者它包括的模块；如果mod是类，包括它的祖先）定义了给定的公共方法，返回true。

    module A
      def method1;
      end
      class B
        protected
        def method2;
        end
        class C < B
          include A
          def method3;
          end
        end
      end
    end
    A.method_defined? :method1          # => true
    C.public_method_defined? "method1"  # => true
    C.public_method_defined? "method2"  # => false
    C.method_defined? "method2"         # => true

#### remove_class_variable  移除类变量  1.9

    remove_class_variable( symbol ) → obj

Removes the definition of the symbol, returning that variable’s value. 
移除符号的定义，返回该变量的值。
Prior to Ruby 1.9, this method was private.
在ruby 1.9之前，这个方法是私有的。

    class Dummy
      @@var = 99
    end
    Dummy.class_eval { p defined? @@var }
    puts Dummy.remove_class_variable(:@@var)
    Dummy.class_eval { p defined? @@var }
    # produces:
    # prog.rb:4: warning: class variable access from toplevel
    # nil    为什么是nil？不是99吗？
    # prog.rb:6: warning: class variable access from toplevel
    # 99     这应是puts语句的输出。不过为什么不是出现在上行之上？
    # nil


### Private Instance Methods  私有实例方法
#### alias_method  方法别名

    alias_method( new_id, old_id ) → mod

Makes `new_id` a new copy of the method `old_id`. 
将`new_id`成为`old_id`方法的新拷贝。
This can be used to retain access to methods that are overridden.
这可以用来保留对被覆写方法的访问。
<kinder:note> 看来这个方法的别名不同与变量的别名。

    module Mod
      alias_method :orig_exit, :exit
      def exit(code=0)
        puts "Exiting with code #{code}"
        orig_exit(code)    # <kinder:note> 为什么这一行没有被调用？
      end
    end
    include Mod
    exit(99)
    # produces:
    # Exiting with code 99

#### append_features  追加特性  1.8

    append_features( other_mod ) → mod

When this module is included in another, Ruby calls `append_features` in this module, passing it the receiving module in `other_mod`. 
当这个模块包含在别的模块中时，ruby调用这个模块中的`append_features`，并将接收者模块放在`other_mod`中传递它。
Ruby’s default implementation is to add the constants, methods, and module variables of this module to `other_mod` if this module has not already been added to `other_mod` or one of its ancestors. 
如果这个模块还没有添加到`other_mod`中或它的任何祖先，ruby的默认实现是把这个模块的常量、方法以及模块变量添加到`other_mod`中。
Prior to Ruby 1.8, user code often redefined `append_features`, added its own functionality, and then invoked super to handle the real include.
在ruby 1.8之前，用户代码常常重定义了`append_features`添加自己的功能，然后调用super去处理实际的添加。
Now you should instead implement the method Module#included on page 582.
现在你应该实现后面2版556页4版582页Module#included方法。

#### attr  定义属性

    attr( ‹ symbol ›+ ) → nil

An alias for `Module#attr_reader` (as of Ruby 1.9).
`Module#attr_reader`（在ruby 1.9）的别名

#### attr_accessor  定义访问属性

    attr_accessor( ‹ symbol ›+ ) → nil

Creates a reader and a writer method for each symbol passed as an argument. 
对每个作为参数传入的symbol依次创建一个读取和写入方法。
These methods provide access to the underlying instance variables of the name name (with a leading @ sign).
这些方法提供了对名称name潜藏的实例变量的访问。

    class Test
      attr_accessor :name, :likes
      def initialize(name, likes)
        @name = name
        @likes = likes
      end
    end
    d = Test.new("Dave", "Ruby")
    d.name = "Chad"
    d.name # => "Chad"
    d.likes # => "Ruby"

#### attr_reader  定义读取属性

    attr_reader( ‹ symbol ›+ ) → nil

Creates instance variables and corresponding methods that return their values.
创建实例变量和相应的方法，这个方法返回每个实例变量的值。

    class Test
      attr_reader :name, :likes
      def initialize(name, likes)
        @name = name
        @likes = likes
      end
    end
    d = Test.new("Dave", "Ruby")
    d.name # => "Dave"
    d.likes # => "Ruby"

#### attr_writer  定义写入方法

    attr_writer( ‹ symbol ›+ ) → nil

Creates an accessor method to allow assignment to the attribute symbol.id2name.
创建访问属性，允许对这个symbol.id2name进行赋值。

    class Test
      attr_writer :name, :likes
      def initialize(name, likes)
        @name = name
        @likes = likes
      end
    end
    d = Test.new("Dave", "Ruby")
    d.name = "Chad"
    d # => #<Test:0x007fc52210f8a8 @name="Chad", @likes="Ruby">

#### define_method  定义实例方法  1.8

    define_method( symbol, method ) → method
    define_method( symbol ) { … } → proc

Defines an instance method in the receiver. 
在接收者中定义实例方法。
The method parameter can be a Proc, a Method, or an UnboundMethod object. 
method参数可以是一个Proc对象，Method对象或UnboundMethod对象。
If a block is specified, it is used as the method body. 
如果给定block，则它会被用作这个方法的程序体。
This block is evaluated using `instance_eval`. 
block是通过`instance_eval`来求解的。
This is tricky to demonstrate because `define_method` is private.
很困难去做出示范，因为`define_method`是私有方法。
(This is why we resort to the send hack in this example.) 
(这是为什么我们在这个例子中求助于send方法的原因)
See also `Object#define_singleton_method`.
另见`Object#define_singleton_method`。

    class A
      def fred
        puts "In Fred"
      end
      def create_method(name, &block)
        self.class.send(:define_method, name, &block)
      end
      define_method(:wilma) { puts "Charge it!" }
    end
    class B < A
      define_method(:barney, instance_method(:fred))
    end
    b = B.new
    b.barney
    b.wilma
    b.create_method(:betty) { p self }
    b.betty
    # produces:
    # In Fred
    # Charge it!
    # #<B:0x007fb6bb846600>

Note that it is possible to define methods with names that are not valid if you were to use the def keyword. 
注意定义方法时如果你用def关键字作为名字，可能是无效的。
These methods cannot be invoked directly.
这些方法不能被直接调用。

    class Silly
      define_method("Oh !@!#^!") { "As Snoopy says" }
    end
    Silly.new.send("Oh !@!#^!") # => "As Snoopy says"

#### extend_object  添加常量和方法

    extend_object( obj ) → obj

Extends the specified object by adding this module’s constants and methods (which are added as singleton methods). 
通过添加这个模块的常量和方法（作为单例方法被添加）来扩展制定的对象。
This is the callback method used by Object#extend.
Object#extend会使用这个回调方法。

    module Picky
      def Picky.extend_object(o)
        if String === o
          puts "Can't add Picky to a String"
        else
          puts "Picky added to #{o.class}"
          super
        end
      end
    end
    (s = Array.new).extend Picky # Call Object.extend
    (s = "quick brown fox").extend Picky
    # produces:
    # Picky added to Array
    # Can't add Picky to a String

#### extended  去扩展  1.8

    extended( other_mod )

Callback invoked whenever the receiver is used to extend an object. 
无论合这个接收者何时被用来扩展一个对象，extended回调方法会被调用。
The object is passed as a parameter. 
这个对象作为参数被传入。
This should be used in preference to `Module#extend_object` if your code wants to perform some action when a module is used to extend an object.
当一个模块用来扩展一个对象时，如果你的代码想执行某些动作，你应当优先于`Module#extend_object`而考虑使用这个方法。

    module A
      def A.extended(obj)
        puts "#{self} extending '#{obj}'"
      end
    end
    "cat".extend(A)   # 注意A是self，而cat是obj。真是想不通。？？？
    # produces:
    # A extending 'cat'

#### include  包含 ⇡New in 2.0⇣

    include( ‹ other_mod ›+ ) → mod

Includes the listed modules in self. 
在self里包含列出的模块。
Typically used to make the instance methods in the included modules available in the receiver. 
典型用于让接收者拥有所含模块的实例方法。
Equivalent to the following code:
相当与下面的代码：

    def include(*modules)
      modules.reverse_each do |mod|
        mod.append_features(self)
        # make the methods available
        mod.included(self)
        # invoke a callback
      end
    end

See also Module#prepend.
另见Module#prepend。

#### included  被包含  1.8

    included( other_mod )

Callback invoked whenever the receiver is included in another module or class. 
无论这个接收者何时被包括在别的模块或类中，该回调方法会被调用。
This should be used in preference to `Module#append_features` if your code wants to perform some action when a module is included in another.
当一个模块用来扩展一个对象时，如果你的代码想执行某些动作，你应该优先于`Module#append_features`而考虑这个方法。

    module A
      def A.included(mod)
        puts "#{self} included in #{mod}"
      end
    end
    module Enumerable
      include A
    end
    # produces:
    # A included in Enumerable

#### method_added  添加方法

    method_added( symbol )

Invoked as a callback whenever a method is added to the receiver.
无论一个方法何时被添加到这个接收者中，该回调方法会被调用。

    module Chatty
      def Chatty.method_added(id)
        puts "Adding #{id.id2name}"
      end
      def one; end
    end
    module Chatty
      def two; end
    end
    # produces:
    # Adding one
    # Adding two

#### method_removed  删除方法  1.8

    method_removed( symbol )

Invoked as a callback whenever a method is removed from the receiver.
无论一个方法何时被从这个接收者中删除，该回调方法会被调用。

    module Chatty
      def Chatty.method_removed(id)
        puts "Removing #{id.id2name}"
      end
      def one
      end
    end
    module Chatty
      remove_method(:one)
    end
    # produces:
    # Removing one

#### method_undefined  方法未定义回调  1.8

    method_undefined( symbol )

Invoked as a callback whenever a method is undefined in the receiver.
无论一个方法何时在这个接收者中没有定义，该回调方法会被调用。

    module Chatty
      def Chatty.method_undefined(id)
        puts "Undefining #{id.id2name}"
      end
      def one
      end
    end
    module Chatty
      undef_method(:one)
    end
    # produces:
    # Undefining one

#### module_function  模块函数

    module_function( ‹ symbol ›* ) → mod

Creates module functions for the named methods. 
为已命名方法创建模块函数。
These functions may be called with the module as a receiver. 
把这个模块作为一个接收者，这些函数可以被调用。
Module functions are copies of the original and so may be changed independently. 
模块函数是原始函数的拷贝，所以它们能够独立的被修改。
The instance-method versions are made private. 
这些实例方法版本的函数被变成私有的。
If used with no arguments, subsequently defined methods become module functions.
如果不带任何参数调用该函数，随后定义的方法就成为模块函数。

    module Mod
      def one
        "This is one"
      end
      module_function :one
    end
    class Cls
      include Mod
      def call_one
        one
      end
    end
    Mod.one #=> "This is one"
    c = Cls.new
    c.call_one #=> "This is one"
    module Mod
      def one
        "This is the new one"
      end
    end
    Mod.one    # => "This is one"
    c.call_one # => "This is the new one"

#### prepend  预置  ⇡New in 2.0⇣

    prepend( ‹ other_mod ›+ ) → mod

Includes the listed modules in self. 
在self包含已列出的模块。
Unlike Module#include. 
和Module#include不同。
if the module contains methods with the same names as those in the including module, the included modules methods take precedence.
如果模块包含了同名的方法，当那些方法在所包含的模块中，被包含模块的方法更优先。

    module Mod
      def meth; "In module Mod"; end
    end
    class Cls1
      def meth; "In class Cls1"; end
      include Mod
    end
    class Cls2
      def meth; "In class Cls2"; end
      prepend Mod
    end

See also Module#include.
另见Module#include。

#### private  私有

    private( ‹ symbol ›* ) → mod

With no arguments, sets the default visibility for subsequently defined methods to private.
不带任何参数调用时，把随后定义的方法的默认可见范围设置为私有。
With arguments, sets the named methods to have private visibility. 
带有参数调用时，把给定方法的可见范围设置为私有。
See “Access Control” on page 335.
参见前面2版356页4版335页的“访问控制”。

    module Mod
      def a; end
      def b; end
      private
      def c;
      end
      private :a
    end
    Mod.private_instance_methods # => [:a, :c]

#### protected  受保

    protected( ‹ symbol ›* ) → mod

With no arguments, sets the default visibility for subsequently defined methods to protected.
不带任何参数调用时，把随后定义的方法的默认可见范围设置为受保。
With arguments, sets the named methods to have protected visibility. 
带有参数调用时，把给定方法的可见范围设置为受保。
See “Access Control” on page 335.
参见前面2版356页4版335页的“访问控制”。

#### public  公共

    public( ‹ symbol ›* ) → mod

With no arguments, sets the default visibility for subsequently defined methods to public.
不带任何参数调用时，把随后定义的方法的默认可见范围设置为受保。
With arguments, sets the named methods to have public visibility. 
带有参数调用时，把给定方法的可见范围设置为受保。
See “Access Control” on page 335.
参见前面2版356页4版335页的“访问控制”。

#### refine  提炼 ⇡New in 2.0⇣

    refine( class ) { … } → refmod

Defines a refinement for the given class. 
为给定类定义一个提炼。
This is activated from the top-level of a source file with the Object#using method, which applies the methods defined in the block to the given class for the remainder of that source file. 
这会从源文件的顶级使用Object#using方法来激活，该方法为该源文件的剩余部分应用定义在block的方法到给定类。
The tutorial on page 369 has more information.
前面369页有更多的信息。
refine returns a special kind of module object that represents the change to be made to the host class.
提炼返回一个模块对象的特殊种类，代表host类发生的改变。

    module SuperUpcase
      refine String do
        def upcase
          "!#{super}!"
        end
      end
    end
    puts "wombat".upcase
    using SuperUpcase
    puts "wombat".upcase
    # produces:
    # WOMBAT
    # !WOMBAT!

#### remove_const  删除常量

    remove_const( symbol ) → obj

Removes the definition of the given constant, returning that constant’s value. 
删除给定常量的定义，并返回这个常量的值。
Predefined classes and singleton objects (such as true) cannot be removed.
预置类和单例对象（比如true）不能被删除。

#### remove_method  删除方法

    remove_method( symbol ) → mod

Removes the method identified by symbol from the current class. 
从当前类中删除symbol标识的方法。
For an example, see `Module#undef_method`.
举个例子，参见`Module#undef_method`。

#### undef_method  撤销方法

    undef_method( ‹ symbol ›+ ) → mod

Prevents the current class from responding to calls to the named method(s). 
阻止当前类响应对这些给定方法的调用。
Contrast this with `remove_method`, which deletes the method from the particular class; Ruby will still search superclasses and mixed-in modules for a possible receiver.
这与`remove_method`方法形成鲜明对比：后者从这个特别的类删除方法，而ruby将仍然会从它的超类以及混入模块中查找，以找到一个可能的接收者。

    class Parent
      def hello
        puts "In parent"
      end
    end
    class Child < Parent
      def hello
        puts "In child"
      end
    end
    c = Child.new
    c.hello
    class Child
      remove_method :hello # remove from child, still in parent 
    end
    c.hello
    class Child
      undef_method :hello   # prevent any calls to 'hello'
    end
    c.hello
    # produces:
    # In child
    # In parent
    # prog.rb:24:in `<main>': undefined method `hello' for #<Child:0x007fcfa4042ee8>
    # (NoMethodError)


## Mutex  互斥  1.9  mutual exclusion
### 概述
A mutex is a semaphore object that can be used to synchronize access to resources shared across threads. 
互斥类是可用于同步访问跨线程共享资源的旗语（？发出信号）对象。
We discussed mutexes (and other synchronization mechanisms) in Section 12.4, Mutual Exclusion, on page 167. 
我们在前面167页12.4节的Mutual Exclusion讨论过互斥（和其他同步机制）。
Because the code examples tend to be long, we haven’t duplicated them in this library description.
因为代码样例较长，我们不能将这个库的描述复制过来。

### Instance Methods 实例方法
#### lock  锁定 ⇡New in 2.0⇣

    mutex.lock → mutex

Takes a lock on mutex. 
为mutex上锁。
Suspends if mutex is already locked by another thread and raises a ThreadError if the mutex is already locked by the calling thread or if called from a trap handler.
如果mutex已经被其他线程锁定，则挂起；如果已经被调用中的线程锁定，或被捕捉处理器（？）调用，抛出一个ThreadError异常。

#### locked?  是否锁定

    mutex.locked? → true or false

Returns the current locked state of mutex.
返回mutex的当前锁定状态

#### owned?  是否当前线程处理 ⇡New in 2.0⇣

    mutex.owned? → true or false

Returns true if the mutex is held by the current thread. 
如果mutex为当前线程所处理，返回true。
Experimental in Ruby 2.0.
ruby 2.0的实验特性。

#### sleep  睡眠 ⇡New in 2.0⇣

    mutex.sleep( time | nil ) → seconds_slept

Releases the current thread’s lock on mutex, sleeps for time seconds (or forever if nil is passed), and then regains the lock. 
释放当前线程对mutex的锁定，睡眠times秒（如果传入nil则永远睡眠），然后恢复锁定。
Returns the number of seconds actually slept. 
返回实际睡眠的秒数。
This may be less than the number requested, so it is wise to check. 
这可能少于要求的秒数，因此检查是明智的。
May not be called from a trap handler.
该方法可能不被捕获处理器（？）调用。

#### synchronize  同步 ⇡New in 2.0⇣

    mutex.synchronize { … } → obj

Locks mutex, executes the block, and then unlocks mutex. 
锁住mutex，执行block，然后解锁mutex。
Returns the value returned by the block. 
返回block返回的值。
May not be called from a trap handler.
该方法可能不被捕获处理器（？）调用。

#### try_lock  尝试锁定 ⇡New in 2.0⇣

    mutex.try_lock → true or false

If mutex is not currently locked, locks it and returns true. 
如果mutex还未锁定，将它锁定并返回true。
Otherwise, returns false. 
否则返回fasle。
(That is, `try_lock` is like lock, but it will never wait for a mutex to become available.) 
（就是，`try_lock`很像lock，但它不会等待mutex变成可用。）
May not be called from a trap handler.
该方法可能不被捕获处理器（？）调用。

#### unlock  解锁 ⇡New in 2.0⇣

    mutex.unlock → mutex

Unlock mutex, which must be locked by the current thread. 
为mutex解锁，mutex必须被当前线程锁定。
May not be called from a trap handler.
该方法可能不被捕获处理器（？）调用。


## NilClass  Nil
The class of the singleton object nil.
单例对象nil的类。

### Instance Methods 实例方法
#### &  与

    nil & obj → false

And—Returns false. 
与--返回false。
Because obj is an argument to a method call, it is always evaluated; there is no short-circuit evaluation in this case.
当obj是方法调用的一个参数时，它总会被求解：在这种情况下，不会进行短路求解。

    nil && puts("logical and")
    nil & puts("and")
    # produces:
    # and

#### ^  异或

    nil ^ obj → true or false

Exclusive Or—Returns false if obj is nil or false and returns true otherwise.
异或--如果obj是nil或者false，返回false；否则返回true。

#### |  或

    nil | obj → true or false

Or—Returns false if obj is nil or false and returns true otherwise.
或--如果obj是nil或者false返回false；否则返回true。

    nil | false # => false
    nil | 99 # => true

#### nil?  是否nil

    nil.nil? → true

Always returns true.
总是返回true。

#### rationalize  有理化  1.9

    int.rationalize( eps=nil ) → Rational(0)

Returns Rational("0"). 
返回有理数0.
The argument is always ignored.
参数会被忽略。

    nil.rationalize # => (0/1)

#### to_a  转为数组

    nil.to_a → []

Always returns an empty array.
总是返回空数组。

    nil.to_a # => []

#### to_c  转为复数  1.9

    nil.to_c → Complex(0,0)

Always returns the origin of the complex plane.
总是返回复数平面的原点。

    nil.to_c # => (0+0i)

#### to_f  返回浮点数0

    nil.to_f → 0.0

Always returns zero.
总是返回0.

    nil.to_f # => 0.0

#### to_h  返回散列表 ⇡New in 2.0⇣

    nil.to_h → {}

Always returns an empty hash.
总是返回空散列表

    nil.to_h # => {}

#### to_i  返回整数0

    nil.to_i → 0

Always returns zero.
总是返回0

    nil.to_i # => 0

#### to_r  转为有理数0

    nil.to_r → Rational(0,1)

Always returns zero as a rational number.
总是返回有理数0.

    nil.to_r # => (0/1)

#### to_s  转为字符串

    nil.to_s → ""

Always returns the empty string.
组成返回空字符串。

    nil.to_s # => ""


## Numeric  数字
### 概述
Subclasses: Float, Integer
子类：浮点类、整数类。
Numeric is the fundamental base type for the abstract class Integer and the concrete number classes Bignum, Complex, Float, Fixnum, and Rational. 
Numeric是抽象类Integer和具体数字类Bignum、Complex、Float、Fixnum和Rational类的基础类。
Many methods in Numeric are overridden in child classes, and Numeric takes some liberties by calling methods in these child classes.
Numeric里的许多方法会在子类中被覆写，同时Numeric能够自由调用这些子类的方法。
Here’s a complete list of the methods defined in all five classes:
下面列出了所有这五类中定义方法的完全列表。
Table 20—Methods in the numeric classes 表格 20 -- numeric类中的方法。
打勾意味着这个方法定义在相应的类中。

                Numeric Integer Fixnum Bignum Float Rational Complex
    %            ✓      –       ✓      ✓      ✓      –       – 
    &            –      –       ✓      ✓      –      –       –
    *            –      –       ✓      ✓      ✓      ✓       ✓ 
    **           –      –       ✓      ✓      ✓      ✓       ✓ 
    +            –      –       ✓      ✓      ✓      ✓       ✓ 
    +@           ✓      –       –      –      –      –       – 
    -            –      –       ✓      ✓      ✓      ✓       ✓ 
    -@           ✓      –       ✓      ✓      ✓      –       ✓ 
    /            –      –       ✓      ✓      ✓      ✓       ✓ 
    <            –      –       ✓      ✓      ✓      –       – 
    <<           –      –       ✓      ✓      –      –       – 
    <=           –      –       ✓      ✓      ✓      –       – 
    <=>          ✓      –       ✓      ✓      ✓      ✓       – 
    ==           –      –       ✓      ✓      ✓      ✓       ✓ 
    ===          –      –       ✓      ✓      ✓      –       – 
    >            –      –       ✓      ✓      ✓      –       – 
    >=           –      –       ✓      ✓      ✓      –       – 
    >>           –      –       ✓      ✓      –      –       – 
    []           –      –       ✓      ✓      –      –       – 
    ^            –      –       ✓      ✓      –      –       – 
    abs          ✓      –       ✓      ✓      ✓      –       ✓ 
    abs2         ✓      –       –      –      –      –       ✓ 
    angle        ✓      –       –      –      ✓      –       ✓ 
    arg          ✓      –       –      –      ✓      –       ✓ 
    ceil         ✓      ✓       –      –      ✓      ✓       – 
    chr          –      ✓       –      –      –      –       – 
    coerce       ✓      –       –      ✓      ✓      ✓       ✓ 
    conj         ✓      –       –      –      –      –       ✓ 
    conjugate    ✓      –       –      –      –      –       ✓ 
    denominator  ✓      ✓       –      –      ✓      ✓       ✓ 
    div          ✓      –       ✓      ✓      –      –       – 
    divmod       ✓      –       ✓      ✓      ✓      –       – 
    downto       –      ✓       –      –      –      –       – 
    eql?         ✓      –       –      ✓      ✓      –       ✓ 
    even?        –      ✓       ✓      ✓      –      –       – 
    fdiv         ✓      –       ✓      ✓      ✓      ✓       ✓ 
    finite?      –      –       –      –      ✓      –       – 
    floor        ✓      ✓       –      –      ✓      ✓       – 
    gcd          –      ✓       –      –      –      –       – 
    gcdlcm       –      ✓       –      –      –      –       – 
    i            ✓      –       –      –      –      –       – 
    imag         ✓      –       –      –      –      –       ✓ 
    imaginary    ✓      –       –      –      –      –       ✓ 
    infinite?    –      –       –      –      ✓      –       – 
    integer?     ✓      ✓       –      –      –      –       – 
    lcm          –      ✓       –      –      –      –       – 
    magnitude    ✓      –       ✓      ✓      ✓      –       ✓ 
    modulo       ✓      –       ✓      ✓      ✓      –       – 
    nan?         –      –       –      –      ✓      –       – 
    next         –      ✓       –      –      –      –       – 
    nonzero?     ✓      –       –      –      –      –       – 
    numerator    ✓      ✓       –      –      ✓      ✓       ✓ 
    odd?         –      ✓       ✓      ✓      –      –       – 
    ord          –      ✓       –      –      –      –       – 
    phase        ✓      –       –      –      ✓      –       ✓ 
    polar        ✓      –       –      –      –      –       ✓ 
    pred         –      ✓       –      –      –      –       – 
    quo          ✓      –       –      –      ✓      ✓       ✓ 
    rationalize  –      ✓       –      –      ✓      ✓       ✓ 
    real         ✓      –       –      –      –      –       ✓ 
    real?        ✓      –       –      –      –      –       ✓ 
    rect         ✓      –       –      –      –      –       ✓ 
    rectangular  ✓      –       –      –      –      –       ✓ 
    remainder    ✓      –       –      ✓      –      –       – 
    round        ✓      ✓       –      –      ✓      ✓       – 
    size         –      –       ✓      ✓      –      –       – 
    step         ✓      –       –      –      –      –       – 
    succ         –      ✓       ✓      –      –      –       – 
    times        –      ✓       –      –      –      –       – 
    to_c         ✓      –       –      –      –      –       ✓ 
    to_f         –      –       ✓      ✓      ✓      ✓       ✓ 
    to_i         –      ✓       –      –      ✓      ✓       ✓ 
    to_int       ✓      ✓       –      –      ✓      –       – 
    to_r         –      ✓       –      –      ✓      ✓       ✓ 
    to_s         –      –       ✓      ✓      ✓      ✓       ✓ 
    truncate     ✓      ✓       –      –      ✓      ✓       – 
    upto         –      ✓       –      –      –      –       – 
    zero?        ✓      –       ✓      –      ✓      –       – 
    |            –      –       ✓      ✓      –      –       – 
    ~            –      –       ✓      ✓      –      –       – 

#### Mixes In  混入
Comparable: <, <=, ==, >, >=, between?

### Instance Methods 实例方法
#### +@  一元加

    +num → num

Unary Plus—Returns the receiver’s value.
一元加--返回这个接受者的值。

#### -@  一元减

    –num → numeric

Unary Minus—Returns the receiver’s value, negated.
一元减--返回这个接受者的值

#### <=>  是否相等

    num <=> other → 0 or nil

Returns zero if num equals other and returns nil otherwise.
如果num等于other，返回0；否则返回nil。

#### %  取模  1.9

    num % numeric → numeric

Synonym for Numeric#module. 
同Numeric#module。
Equivalent to num.divmod(numeric)[1].
等于num.divmod(numeric)[1] 。
<kinder:note> 上行的[1]是数组的第二个元素。不是注释。

#### abs  绝对值

    num.abs → numeric

Returns the absolute value of num.
返回num的绝对值。

    12.abs # => 12
    (-34.56).abs # => 34.56
    -34.56.abs # => 34.56

#### abs2  绝对值的平方  1.9

    num.abs2 → numeric

Returns the square of (the absolute value of) num.
返回num的绝对值的平方。

    12.abs2 # => 144
    (-34.56).abs2 # => 1194.3936
    -34.56.abs2 # => 1194.3936

#### angle  角度  1.9

    num.angle → numeric

For noncomplex numbers, returns π for negative numbers, 0 otherwise. 
对于非复数，如果是负数返回π，其他的返回0。
See Complex for more details.
详见Complex。

#### arg  角度  1.9

    num.arg → numeric

Synonym for Numeric#angle.
同Numeric#angle。

#### ceil  向上取整

    num.ceil → int

Returns the smallest integer greater than or equal to num. 
返回大于或等于num的最小整数。
Class Numeric achieves this by converting itself to a Float and then invoking Float#ceil.
Numeric类通过把自己转化为Float，然后调用Float#ceil来实现这个功能。

    1.ceil       # => 1
    1.2.ceil     # => 2
    (-1.2).ceil  # => -1
    (-1.0).ceil  # => -1

#### coerce  强制转换

    num.coerce( numeric ) → array

coerce is both an instance method of Numeric and part of a type conversion protocol. 
coerce是Numeric类的实例方法，同时也是类型转换协议的一部分。
When a number is asked to perform an operation and it is passed a parameter of a class different from its own, it must first coerce both itself and that parameter into a common class so that the operation makes sense. 
当一个数字被要求执行一个操作，而传入的参数其类与其数字本身的类不同，它必须首先把自己和这个参数都墙砖转换成同一类，然后这个操作才有意义。
For example, in the expression 1 + 2.5, the Fixnum 1 must be converted to a Float to make it compatible with 2.5. 
比如，在表达式1 + 2.5中，定数1必须被强制转换成一个浮点数，使得它和2.5保持一直。
This conversion is performed by coerce. 
这个转换是由coerce执行的。
For all numeric objects, coerce is straightforward: if numeric is the same type as num, returns an array containing numeric and num. 
对于所有的数字对象来说，coerce是一目了然的：如果numeric的类型和num的类型相同，则返回一个含有numeric和num的数组。
Otherwise, returns an array with both numeric and num represented as Float objects.
否则返回一个数组，其中numeric和num都是以浮点数对象来表示。

    1.coerce(2.5) # => [2.5, 1.0]
    1.2.coerce(3) # => [3.0, 1.2]
    1.coerce(2) # => [2, 1]

If a numeric object is asked to operate on a non-numeric, it tries to invoke coerce on that other object. 
如果一个numeric对象被要求对一个非数字对象进行操作，它会试图对那个对象调用coerce。
For example, if you write this:
比如，如果写成：

    1 + "2"

then Ruby will effectively execute the code as follows:
ruby将实际上以如下方式执行：

    n1, n2 = "2".coerce(1)
    n2 + n1

In the more general case, this won’t work, because most non-numerics don’t define a coerce method. 
在更普通的情况下，这行不通。因为大多数非数字对象并没有定义这个coerce方法。
However, you can use this (if you feel so inclined) to implement part of Perl’s automatic conversion of strings to numbers in expressions.
当然，你可以使用它（如果你倾向如此）来部分实现Perl表达式中字符串到数字的自动转换功能：

    class String
      def coerce(other)   # 这个方法会把双引号自动去掉吗？
        case other
        when Integer
          begin
            return other, Integer(self)
          rescue
            return Float(other), Float(self)
          end
        when Float
          return other, Float(self)
        else super
        end
      end
    end
    1    + "2"   # => 3
    1    - "2.3" # => -1.2999999999999998
    1.2  + "2.3" # => 3.5
    1.5  - "2"   # => -0.5

coerce is discussed in the tutorial on page 352.
前面2版374页4版352页有更多讨论。

#### conj  复共轭  1.9

    num.conj → num

Synonym for Numeric#conjugate.
同Numeric#conjugate。

#### conjugate  复共轭  1.9

    num.conjugate → num

Returns the complex conjugate of num. 
返回num的复共轭。
For noncomplex numbers, returns num.
对于非复数，返回num

#### denominator  分母  1.9

    num.denominator → integer

Returns the denominator of the rational representation of num.
返回num的实数表示的分母。

    1.denominator   # => 1
    1.5.denominator # => 2
    num = 1.0/3 
    num.to_r            # => (6004799503160661/18014398509481984)
    num.denominator     # => 18014398509481984

#### div  除法  1.8

    num.div( numeric ) → int

Uses / to perform division and then converts the result to an integer. 
使用/来执行除法，然后把结果转换成一个整数。
Numeric does not define the / operator; this is left to subclasses.
Numeric没有定义这个/操作符，留给它的子类来定义。

#### divmod  商和模

    num.divmod( numeric ) → array

Returns an array containing the quotient and modulus obtained by dividing num by numeric. 
返回商和模的数组，对num除以numeric可以得到它们。
If q,r = x.divmod(y), then q = floor(float(x) / float(y)) and x = q * y + r. 
如果q,r = x.divmod(y)，q = floor(float(x) / float(y))和x = q * y + r。
The quotient is rounded toward -infinity.
这个商取整到负无穷大。
Table 21—Division, modulo, and remainder  表格21--模和余数之间的区别
a     b    a.divmod(b)    a/b    a.modulo(b)    a.remainder(b)
13    4    [3, 1]         3      1              1
13    -4   [-4, -3]       -4     -3             1
-13   4    [-4, 3]        -4     3              -1
-13   -4   [3, -1]        3      -1             -1
11.5  4    [2, 3.5]       2.875  3.5            3.5
11.5  -4   [-3, -0.5]     -2.875 -0.5           3.5
-11.5 4    [-3, 0.5]      -2.875 0.5            -3.5
-11.5 -4   [2,  -3.5]     2.875  -3.5           -3.5

The modulo operator % always has the sign of the divisor, whereas remainder has the sign of the dividend.
取模操作复%总是有除数符号，而remainder有被除数的符号。
<kinder:note> 还是第一次发现求模和求余不同。
取模=除数×（商+1）-被除数。

#### eql?  相等

    num.eql?( numeric ) → true or false

Returns true if num and numeric are the same type and have equal values.
如果num和numeric的类型相同并且值相等，返回true。

    1 == 1.0 # => true
    1.eql?(1.0) # => false
    (1.0).eql?(1.0) # => true

#### fdiv  精确除法  1.9

    num.fdiv( numeric ) → numeric

Synonym for Numeric#quo.
同Numeric#quo。

#### floor  向下取整

    num.floor → int

Returns the largest integer less than or equal to num. 
返回小于或者等于num的最大整数。
Numeric implements this by converting int to a Float and invoking Float#floor.
Numeric通过把int转换成一个Float，然后调用Float#floor来实现这个功能。

    1.floor    # => 1
    (-1).floor # => -1

#### i  复数  1.9

    num.i → Complex(0, num)

Returns the complex number whose imaginary part is num.
返回虚部为num的复数。

#### imag  虚部  1.9

    num.imag → 0

Synonym for Numeric#imaginary.
同Numeric#imaginary。

#### imaginary  虚部  1.9

    num.imaginary → 0

Returns the imaginary part of num. 
返回num的虚部。
Always 0 unless num is a complex number.
除非num是个复数，否则总是0.

    1.imaginary # => 0

#### integer?  是否整数

    num.integer? → true or false

Returns true if num is an Integer (including Fixnum and Bignum).
如果num是个整数（包括定数和大数），返回true。

#### magnitude  绝对值  1.9

    num.magnitude → int or float

Returns the magnitude of num (the distance of num from the origin of the number line). 
返回num的绝对值（在数轴上从原点到该点之间的距离）。
See also Complex#magnitude.
另见Complex#magnitude。

    3.magnitude # => 3
    -3.0.magnitude # => 3.0

#### modulo  取模

    num.modulo( numeric ) → numeric

Equivalent to num.divmod(numeric)[1].
等同于num.divmod(numeric)[1]。
<kinder:note> 上行的[1]是数组的第二个元素。不是注释。

#### nonzero?  是否非零

    num.nonzero? → num or nil

Returns num if num is not zero and returns nil otherwise. 
如果num不是0，返回num；否则返回nil。
This behavior is useful when chaining comparisons.
当把比较串联在一起时，这个做法很有用。

    a = %w( z Bb bB bb BB a aA Aa AA A )
    b = a.sort {|a,b| (a.downcase <=> b.downcase).nonzero? || a <=> b }
    b # => ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]
    # <kinder:note>  看起来简单，就是没有想明白啊！

#### numerator  分子

    num.numerator → integer

Returns the numerator of the rational representation of num.
返回num的实数表示的分子部分。

    1.numerator    # => 1
    1.5.numerator  # => 3
    num = 1.0/3    
    num.to_r       # => (6004799503160661/18014398509481984)
    num.numerator  # => 6004799503160661

#### phase  相位  1.9

    num.phase → [magnitude, angle ]

Returns the phase angle of num. 
返回num的相位角度。
See Complex for more information. 
更多信息详见Complex。
For noncomplex numbers, returns 0 if num is nonnegative, π otherwise.
对于非复数，如果num非负数则返回0,其他的返回π。

    123.phase # => 0

#### polar  极坐标  1.9

    num.polar → [magnitude, angle ]

Returns num in polar form. 
返回num的极坐标形式
See Complex for more information. 
更多信息参加Complex。
For noncomplex numbers, returns [num,0].
对于非复数，返回[num, 0]。

    123.polar # => [123, 0]

#### quo  精确除法  1.8

    num.quo( numeric ) → numeric

Equivalent to Numeric#/ but overridden in subclasses. 
等同于Numeric#/，但子类重写该法。
The intent of quo is to return the most accurate result of division (in context). 
quo的意图是返回除法的（在上下文中）尽可能精确的结果。
Thus, 1.quo(2) will equal the rational number 1⁄2, while 1/2 equals 0.
因此，1.quo(2)等于0.5,而1/2等于0.

#### real  实部  1.9

    num.real → num

Returns the real part of num. 
返回num的实部。
Always num unless num is a complex number.
如果num不是复数，总是返回num。

    1.real   # => 1
    1.5.real # => 1.5

#### real?  是否实数  1.9

    num.real? → true

All the built-in numeric classes except Complex represent scalar types and hence respond true to real?.
除了复数，其他内建数字类型表示的标量类型，都返回true。

    1.real?  # => true
    1.0.real?  # => true
    Complex(1,0).real? # => false

#### rect  实部和虚部数组  1.9

    num.rect → [ num, 0 ]

Returns an array containing the real and imaginary components of num. 
返回包含num的实部和虚部的数组。
See also Complex#rect.
另见Complex#rect。

    1.5.rect # => [1.5, 0]

#### rectangular  实部和虚部数组  1.9

    num.rectangular → [ num, 0 ]

Synonym for Numeric#rect.
同Numeric#rect。

#### remainder  余数

    n.remainder( numeric ) → another_numeric

Returns num - (num/numeric).truncate. 
返回num - (num/numeric).truncate。
See Table 21, Division, modulo, and remainder, on page 595.
详见前面2版265页4版595页的表格21 Division, modulo, and remainder

#### round  取整

    num.round → int

Rounds num to the nearest integer.
将num取整到最近的整数。
2版补充：Numeric类通过将int转换成一个Float，然后调用Float#round来实现这个功能。

#### step  计步器  1.8

    num.step( end_num, step ) { |i| … } → num
    num.step( end_num, step ) → enumerator

Invokes block with the sequence of numbers starting at num, incremented by step on each call. 
从num开始的数字序列来调用block，每次调用时，这个数字会增加step。
The loop finishes when the value to be passed to the block is greater than `end_num` (if step is positive) or less than `end_num` (if step is negative). 
当传递给blockde值大于`end_num`（如果step是整数）或者小于`end_num`（如果step是负数），循环结束。
If all the arguments are integers, the loop operates using an integer counter. 
如果所有的参数都是整数，循环操作使用整数计步器。
If any of the arguments are floating-point numbers, all are converted to floats, and the loop is executed `floor(n + n*Float::EPSILON)+1` times, where `n = (end_num - num)/step`. 
如果其中任一参数是浮点，它会把所有参数都转换成浮点数，同时循环会执行`floor(n + n*Float::EPSILON)+1`次，在这里`n = (end_num - num)/step`。
Otherwise, the loop starts at num, uses either the `< or >` operator to compare the counter against `end_num`, and increments itself using the + operator. 
否则，循环从num开始使用`< or >`操作符来对这个计步器和`end_num`进行比较，同时使用+操作符增加自身。
Returns an enumerator if no block is given.
如果没有指定block，返回一个枚举。

    1.step(10, 2) {|i| print i, " " }
    # produces:
    # 1 3 5 7 9
    Math::E.step(Math::PI, 0.2) {|f| print f, " " }
    # produces:
    # 2.718281828459045 2.9182818284590453 3.118281828459045

#### to_c  转换成复数  1.9

    num.to_c → complex

Returns num as a complex number.
将num转化为复数。

    123.to_c # => 123+0i

#### to_int  转换成整数

    num.to_int → int

Invokes the child class’s `to_i` method to convert num to an integer.
调用子类的`to_i`方法把num转换成整数。

#### truncate  截断成整数

    num.truncate → int

Returns num truncated to an integer.
把num截断成一个整数。
2版补充：Numeric类通过把它的值转换成浮点数并调用Float#truncate来实现。

#### zero?  是否为0

    num.zero? → true or false

Returns true if num has a zero value.
如果num为0返回true。


## Object < BasicObject  对象
### 概述
Subclasses:
<kinder:note> 挺怪异的：没有子类，又单独出现标题！本书2版还列出了许多。
Object is the parent class of (almost) all classes in Ruby. 
Object是ruby里几乎所有类的父类。
Its methods are therefore available to all objects unless explicitly overridden.
它的方法因此对所有对象都可用，除非进行显式地改写。
Object mixes in the Kernel module, making the built-in kernel functions globally accessible.
Object混入了kernel模块，使得这些内建的内核函数变得全局可用。
Although the instance methods of Object are defined by the Kernel module, we have chosen to document them here for clarity.
虽然Object的实例方法是Kernel模块定义的，我们这里还是选择写出文档，会更清楚些。
In the descriptions that follow, the parameter symbol refers to a name, which is either a quoted string or a symbol (such as :name).
在接下来的描述中，参数symbol指的是一个符号，它是一个引用字符串或一个symbol（比如:name）。

### Instance Methods 实例方法
#### ===  等式

    obj === other_obj → true or false

Case Equality—A synonym for Object#== but typically overridden by descendents to provide meaningful semantics in case statements.
等式--同Object#==，通常会在派生类中被改写，已提供类的特定功能（含义）

#### <=>  比较  1.9

    obj <=> other_obj → 0 or nil

Comparison—For objects, returns 0 if other_obj is the same object as, or is equal to, obj. 
比较--对于对象，如果other_obj是obj的同类或等于obj，返回0。
Otherwise, returns nil (which should be interpreted to mean that there’s no meaning to the comparison). 
否则返回nil（这会被解释为没有办法进行比较）。
Overridden by subclasses that have comparison semantics.
被子类改写，因此有比较语义。

#### =~  模式匹配

    obj =~ other_obj → nil

Pattern Match—Overridden by descendents (notably Regexp and String) to provide meaningful pattern-match semantics.
模式匹配--在派生类（尤其是Regexp和String类）中被改写，以提供有意义的模式匹配语义。

#### !~  模式不匹配  1.9

    obj !~ other_obj → !(obj =~ other_obj)

Opposite of =~.
和=～相反。

#### class  类

    obj.class → klass

Returns the class object of obj. 
返回obj的类。
This method must always be called with an explicit receiver, because class is also a reserved word in Ruby.
因为class也是rubyde一个保留词，所以这个方法总是必须要用一个显式的接受者来调用。

    1.class # => Fixnum
    self.class # => Object

#### clone  克隆

    obj.clone → other_obj

Produces a shallow copy of obj—the instance variables of obj are copied, but not the objects they reference. 
产生一个obj的浅拷贝--obj的实例变量被拷贝，但obj所引用的对象并未被拷贝。
Copies the frozen and tainted state of obj, along with any associated singleton class. 
拷贝obj的冻结和受污染的状态，以及关联的单例类。
See also the discussion under Object#dup.
另见Object#dup的讨论。

    class Klass
      attr_accessor :str
    end
    s1 = Klass.new # =>   #<Klass:0x007fc1bb10ee90>               
    s1.str = "Hello" # => "Hello"
    s2 = s1.clone # =>    #<Klass:0x007fc1bb10e940 @str="Hello">
    s2.str[1,4] = "i" # =>"i"
    s1.inspect # =>       "#<Klass:0x007fc1bb10ee90 @str=\"Hi\">"
    s2.inspect # =>       "#<Klass:0x007fc1bb10e940 @str=\"Hi\">"

#### define_singleton_method  定义单例类  1.9

    obj.define_singleton_method( symbol, method ) → method
    obj.define_singleton_method( symbol ) { … } → proc

Defines a singleton method in the receiver. 
在接收者追随定义一个单例方法。
The method parameter can be a Proc, Method, or UnboundMethod object. 
方法参数可以是一个Proc、Method或UnboundMethod对象。
If a block is specified, it is used as the method body. 
如果指定block，它将作为方法体。
This block is evaluated usin`g` instance_eval. 
这个block被使用`instance_eval`来求解。
See also `Module#define_method`.
另见`Module#define_method`。

    a = "cat"
    a.define_singleton_method(:speak) do
    "#{self} says miaow"
    end
    a.speak # => "cat says miaow"

define_singleton_method is also useful with Module#class_eval:
和Module#class_eval联用也很有用：

    class Test
      class_eval do
        define_method(:one) { puts "instance method" }
        define_singleton_method(:two) { puts "class method" }
      end
    end
    t = Test.new
    t.one
    Test.two
    # produces:
    # instance method
    # class method

#### display  显示

    obj.display( port=$> ) → nil

Prints obj on the given port (default $>). 
在指定端口（默认$>）打印出obj。
Equivalent to the following:
相当于下面代码：

    def display(port=$>)
      port.write self
    end

For example:
例如：

    1.display
    "cat".display
    [ 4, 5, 6 ].display
    # produces:
    # 1cat[4, 5, 6]

#### dup  复制

    obj.dup → other_obj

Produces a shallow copy of obj—the instance variables of obj are copied, but not the objects they reference. 
产生obj的一个浅拷贝--拷贝了obj的实例变量，但没有拷贝它引用的那些对象。
dup copies the tainted state of obj. 
dup拷贝了obj的受污染状态。
See also the discussion under Object#clone.
另见Object#clone的讨论。

In general, dup duplicates just the state of an object, while clone also copies the state, any associated singleton class, and any internal flags (such as whether the object is frozen). 
一般而言，dup只复制了对象的状态，而clone不仅复制了状态，还包括相关的单例类，内部标志（例如是否冻结）。
The taint status is copied by both dup and clone.
dup和clone都复制了污染状态。

#### enum_for  转为枚举  1.9

    obj.enum_for(using=:each, ‹ args ›+ → enumerator
    obj.enum_for(using=:each, ‹ args ›+ { |*args| … } → enumerator

Synonym for `Object#to_enum`.
同`Object#to_enum`。

#### eql?  是否相同

    obj.eql?( other_obj ) → true or false

Returns true if obj and other_obj have the same value. 
如果obj和other_obj的值相同，返回true。
Used by Hash to test members for equality. 
Hash使用这个方法来测试它的成员是否相等。
For objects of class Object, eql? is synonymous with ==. 
对Object类的对象而言，eql?等同于==。
Subclasses normally continue this tradition, but there are exceptions. 
Object的子类一般会沿用这个传统，但也有例外。
Numeric types, for example, perform type conversion across ==, but not across eql?. 
比如，Numeric类型通过==而不是eql?方法来转换类型。
This means the following:
这意味着下面：

    1 == 1.0 # => true
    1.eql? 1.0 # => false

#### extend  扩展实例方法

    obj.extend( ‹ mod ›+ ) → obj

Mix the instance methods from each of the given modules in to obj. 
将指定的每个模块的实例方法混入obj。
See Chapter 24, Metaprogramming, on page 357 for information on how this works. 
详见前面357页24章元编程描述扩展的工作原理。
See also `Module#extend_object`.
另见`Module#extend_object`。

    module Mod
      def hello
        "Hello from Mod.\n"
      end
    end
    class Klass
      def hello
        "Hello from Klass.\n"
      end
    end
    k = Klass.new
    k.hello # => "Hello from Klass.\n"
    k.extend(Mod) # => #<Klass:0x007f9fe190f208>
    k.hello # => "Hello from Mod.\n"

Writing obj.extend(Mod) is basically the same as the following:
编写obj.extend(Mod)基本上与下面的代码相同。

    class <<obj
      include Mod
    end

#### freeze  冻结

    obj.freeze → obj

Prevents further modifications to obj. 
阻止对obj的进一步修改。
A RuntimeError will be raised if modification is attempted. 
如果试图修改obj，则会引发RuntimeError。
You cannot unfreeze a frozen object. 
你不能解冻一个已经冻结的对象。
See also Object#frozen?.
另见Object#frozen?。

    a = [ "a", "b", "c" ]
    a.freeze
    a << "z"
    # produces:
    # prog.rb:3:in `<main>': can't modify frozen Array (RuntimeError)

#### frozen?  是否冻结

    obj.frozen? → true or false

Returns the freeze status of obj.
返回obj的冻结状态。

    a = [ "a", "b", "c" ]
    a.freeze # => ["a", "b", "c"]
    a.frozen? # => true

#### hash  散列表

    obj.hash → fixnum

Generates a Fixnum hash value for obj. 
生成这个对象的一个Fixnum散列值。
This function must have the property that a.eql?(b) implies a.hash == b.hash. 
这个函数必须包含一个属性，它的`a.eql?(b)`指的是`a.hash == b.hash`。
The hash value is used by class Hash. 
这个散列值会被Hash类实用。
Any hash value that exceeds the capacity of a Fixnum will be truncated before being used. 
任何超出Fixnum范围的散列值在使用之前会被截断。
For instances of class Object, the hash is also the `object_id`. 
对于Object类的实例来说，散列值也是`object_id`。
This will not always be the case for subclasses.
这并不总是针对子类的情况。

#### initialize_clone  初始化克隆  1.9

    obj.initialize_clone(other) → other_obj or obj

Invoked as a callback by Object#clone to initialize the cloned object. 
作为回调函数被Object#clone调用，以初始化已经被克隆的对象。
The default implementation is to call `initialize_copy`.
默认实现是调用`initialize_copy`。

#### initialize_copy  初始化拷贝  1.8

    obj.initialize_copy(other) → other_obj or obj

Part of the protocol used by Object#dup and #clone, `initialize_copy` is the fallback method invoked by `Object#initialize_clone` and `#initialize_dup`. 
作为Object#dup和#clone所用协议的一部分，`initialize_copy`作为一个回调函数会被`Object#initialize_clone`和`#initialize_dup`调用。
If you need specialized copy semantics depending on whether clone or dup is called, override those more specific callbacks. 
如果你需要根据clone和dup调用的不同指定拷贝语义，那么改写那些更明确的回调。
If you want common behavior, override `initialize_copy`.
如果你要普通行为，改写`initialize_copy`。
These methods should copy across any state information that dup and clone cannot copy themselves. 
这些方法应该拷贝无法经由dup和clone自身拷贝的所有状态信息。
For example, in the following code, a and b reference two instances of the container class, but each instance shares a single string object:
比如，在下面的代码中，a和b引用两个Container类的实例，但每个实例都共享一个单例字符串对象：

    class Container
      attr_accessor :content
    end
    a = Container.new
    a.content = "cat"
    b = a.dup
    a.content[1..-1] = "anary"
    a.content # => "canary"
    b.content # => "canary"

The next example uses `initialize_copy` to create a new string in the duplicated object.
下一个例子使用`initialize_copy`来在已dup的对象中创建一个新的字符串。

    class Container
      attr_accessor :content
      def initialize_copy(other)
        @content = String.new(other.content)
      end
    end
    a = Container.new
    a.content = "cat"
    b = a.dup
    a.content[1..-1] = "anary"
    a.content # => "canary"
    b.content # => "cat"

#### initialize_dup  初始化复制  1.9

    obj.initialize_dup(other) → other_obj or obj

Invoked as a callback by Object#dup to initialize the duplicated object. 
作为Object#dup调用的回调函数，初始化已复制的对象。
The default implementation is to call `initialize_copy`.
默认实现是调用`initialize_copy`。

#### inspect  检查 ⇡New in 2.0⇣

    obj.inspect → string

Returns a string containing a human-readable representation of obj. 
返回表示obj的一个可读字符串。
For objects of classes written in Ruby, displays the values of instance variables along with the class name if any instance variables exist. 
对于ruby已写类的对象，显示实例变量的值，如果实例变量存在还显示类的名称。
Override this in subclasses to change their behavior when inspected.
检查完毕时，在子类中改写这个方法可改变它们的表现。
[ 1, 2, 3..4, 'five' ].inspect  # => [1, 2, 3..4, "five"]
Time.new.inspect                 # => 2013-05-27 12:32:34 -0500
class Demo
  def initialize; @a, @b = 1, 2; end
  Demo.new.inspect # => #<Demo:0x007fb6d190f1e8 @a=1, @b=2>
end

#### instance_of?  是否实例

    obj.instance_of?( klass ) → true or false

Returns true if obj is an instance of the given class. 
如果obj是指定类的实例，返回true。
See also `Object#kind_of?`.
另见`Object#kind_of?`。

#### instance_variable_defined?  是否定义实例变量  1.9

    obj.instance_variable_defined?( name ) → true or false

Returns true if the named variable is defined. 
如果该遍量被定义，返回true。
Note that a common idiom, testing to see whether @fred is nil, is incorrect in two ways: first the variable could be defined but set to nil, and second it will generate a warning if debug mode is enabled.
注意那个普遍的用法，测试以便观察@fred是否nil，在两个方面错误：第一，该变量已经被定义，只不过设置为nil；第二，如果开启了调试模式将产生一个警报。

    class Fred
      def initialize(p1, p2)
        @a, @b = p1, p2
      end
    end
    fred = Fred.new('cat', 99)
    fred.instance_variable_defined?(:@a) # => true
    fred.instance_variable_defined?("@b") # => true
    fred.instance_variable_defined?(:@c) # => false

#### instance_variable_get  实例变量的值  1.8

    obj.instance_variable_get( symbol ) → other_obj

Returns the value of the given instance variable (or throws a NameError exception). 
返回指定实例变量的值（或者抛出NameError异常）。
The @ part of the variable name should be included for regular instance variables.
对常规的实例变量而言，symbol应当包括变量名的@部分。

    class Fred
      def initialize(p1, p2)
        @a, @b = p1, p2
      end
    end
    fred = Fred.new('cat', 99)
    fred.instance_variable_get(:@a) # => "cat"
    fred.instance_variable_get("@b") # => 99

#### instance_variable_set  设置实例变量  1.8

    obj.instance_variable_set( symbol, other_obj ) → other_obj

Sets the instance variable names by symbol to `other_obj`, thereby frustrating the efforts of the class’s author to attempt to provide proper encapsulation.
将名为symbol的实例变量设置为`other_obj`，因而打击了类作者尝试提供适当封装的积极性。

    class Fred
      def initialize(p1, p2)
        @a, @b = p1, p2
      end
    end
    fred = Fred.new('cat', 99)
    fred.instance_variable_set(:@a, 'dog')
    fred.inspect # => #<Fred:0x007fcd9b047d40 @a="dog", @b=99>

#### instance_variables  实例变量数组

    obj.instance_variables → array

Returns an array of instance variable names for the receiver. 
返回这个接收者实例变量名称的数组。
Note that simply defining an accessor does not create the corresponding instance variable.
注意：仅定义访问方法并不会创建一个相应的实例变量。

    class Fred
      attr_accessor :a1
      def initialize
        @iv = 3
      end
    end
    Fred.new.instance_variables # => [:@iv]

#### is_a?  对象种类

    obj.is_a?( klass ) → true or false

Synonym for `Object#kind_of?`.
同`Object#kind_of?`。

#### kind_of?  对象种类

    obj.kind_of?( klass ) → true or false

Returns true if klass is the class of obj or if klass is one of the superclasses of obj or modules included in obj.
如果klass是obj的类或者obj的一个超类，或者是包含在obj中的一个模块，返回true。

    module M
    end
    class A
      include M
    end
    class B < A; end
    class C < B; end
    b = B.new
    b.instance_of? A  # => false 
    b.instance_of? B  # => true
    b.instance_of? C  # => false
    b.instance_of? M  # => false
    b.kind_of? A      # => true
    b.kind_of? B      # => true
    b.kind_of? C      # => false
    b.kind_of? M      # => true

#### method  方法

    obj.method( symbol ) → meth

Looks up the named method in obj, returning a Method object (or raising NameError). 
在obj中查询给定的方法，返回一个Method对象（或者引发NameError）。
The Method object is a closure, so instance variables and the value of self remain available.
这是2版的翻译：这个Method对象作为obj对象实例中的一个闭包，因此它依然可以访问实例变量和self的值。

    class Demo
      def initialize(n)
        @iv = n
      end
      def hello()
        "Hello, @iv = #{@iv}"
      end
    end
    k = Demo.new(99)
    m = k.method(:hello)
    m.call # => "Hello, @iv = 99"
    l = Demo.new('Fred')
    m = l.method("hello")
    m.call # => "Hello, @iv = Fred"

#### methods  公开方法数组

    obj.methods( regular=true ) → array

If regular is true, returns a list of the names of methods publicly accessible in obj and obj’s ancestors. 
如果regular为true，返回obj及其祖先里可公开访问的方法的名称列表。
Otherwise, returns a list of obj’s singleton methods.
否则，返回obj的单例方法列表。

    class Klass
      def my_method; end
    end
    k = Klass.new
    def k.single; end
    k.methods[0..6] # => [:single, :my_method, :nil?, :===, :=~, :!~, :eql?]
    k.methods.length # => 56
    k.methods(false) # => [:single]

#### nil?  是否nil

    obj.nil? → true or false

All objects except nil return false.
除了nil外，所有对象都返回false。

#### object_id  对象标识符  1.8

    obj.object_id → fixnum

Returns an integer identifier for obj. 
返回obj的整数标识符。
The same number will be returned on all calls to `object_id` for a given object, and no two active objects will share an ID. 
对于一个给定对象，无论何时`object_id`调用都返回一个相同的数字，没有两个活跃对象回共享一个ID。
`Object#object_id` is a different concept from the :name notation, which returns the symbol ID of name. 
`Object#object_id`是一个与:name表示法不相同的概念，后者返回name的符号ID。
Replaces the deprecated Object#id.
它取代了过时的Object#id。

#### private_methods  私有方法

    obj.private_methods → array

Returns a list of private methods accessible within obj. 
返回obj中可访问的私有方法的列表。
This will include the private methods in obj’s ancestors, along with any mixed-in module functions.
这将包括obj祖先中的私有方法，以及任何混入的模块函数。

#### protected_methods  受保方法

    obj.protected_methods → array

Returns the list of protected methods accessible to obj.
返回obj可访问的受保方法列表。

#### public_method  公共方法

    obj.public_method( symbol ) → meth

Looks up the named public method in obj, returning a Method object (or raising NameError if the method is not found or if it is found but not public).
在obj中查询给定的方法，返回一个Method对象；或者如果方法没有找到或不是公开方法则引发NameError。


    class Demo
      def initialize(n)
        @iv = n
      end
      def hello()
        puts "Hello, @iv = #{@iv}"
      end
    end
    k = Demo.new(99)
    m = k.public_method(:hello)
    m.call
    l = Demo.new('Fred')
    m = l.public_method(:initialize)
    m.call
    # produces:
    # from prog.rb:15:in `<main>'
    # Hello, @iv = 99
    # prog.rb:15:in `public_method': method `initialize' for class `Demo' is private
    # (NameError)

#### public_methods  公共方法列表

    obj.public_methods → array

Synonym for Object#methods.
同Object#methods。

#### public_send  发送公共方法  1.9

    obj.public_send( name, ‹ args ›+ ) → obj

Invokes obj’s public method name, passing in any arguments. 
调用obj的公共方法名称，传入任何参数。
Returns the value returned by the method. 
返回方法返回的值。
See also send, which will also call private and protected methods.
另见send，但它也调用私有和受保方法。

#### respond_to?  是否响应

    obj.respond_to?( symbol, include_priv=false ) → true or false

Returns true if obj responds to the given method. 
如果obj响应给定的方法，返回true。
Private and protected methods are included in the search only if the optional second parameter evaluates to true.
只有当可选的第二个参数被求解为true时，才会在搜索中包括私有方法和受保方法。

#### respond_to_missing?  是否响应方法遗失 ⇡New in 2.0⇣

    obj.respond_to_missing?( symbol, include_priv=false ) → true or false

A callback invoked by the interpreter if `respond_to?` is called and does not find a method. 
如果respond_to?方法被调用且没有找到方法，解释器将调用这个回调函数。
This allows classes to indicate that they implement methods via `method_missing`.
这允许类表现出通过method_missing来实现方法。

    class Example
      def regular
      end
      def method_missing(name, *args, &block)
        if name == :dynamic
          # do something
        else
          super
        end
      end
      def respond_to_missing?(name, include_priv)
        name == :dynamic
      end
    end
    ex = Example.new
    ex.respond_to?(:regular) # => true
    ex.respond_to?(:dynamic) # => true
    ex.respond_to?(:other) # => false

#### send  发送到方法

    obj.send( symbol ‹ , args ›*‹ , &block › ) → other_obj

Invokes the method identified by symbol, passing it any arguments and block. 
调用由symbol标识的方法，把任何参数和block传递给它。
You can use `BasicObject#__send__` if the name send clashes with an existing method in obj.
如果send这个名字和obj中已有方法产生冲突，建议使用`BasicObject#__send__`。

    class Klass
      def hello(*args)
        "Hello " + args.join(' ')
      end
    end
    k = Klass.new
    k.send :hello, "gentle", "readers" # => "Hello gentle readers"

#### singleton_class  单例类

    obj.singleton_class → klass

Returns the singleton class of obj, creating one if necessary. 
返回obj的单例类，如果需要则新建一个。
TrueClass, FalseClass, and NilClass are their own singleton classes. 
TrueClass, FalseClass, 和NilClass是它们拥有的单例类。
Fixnum has no singleton class.
Fixnum没有单例类

    obj = "cat"
    old_way = class << obj; self; end
    new_way = obj.singleton_class
    old_way            # => #<Class:#<String:0x007fa2b1864060>>
    new_way            # => #<Class:#<String:0x007fa2b1864060>>
    new_way == old_way # => true

#### singleton_methods  单例方法数组  1.8

    obj.singleton_methods( all=true ) → array

Returns an array of the names of singleton methods for obj. 
返回obj的单例方法名称数组。
If the optional all parameter is true, the list will include methods in modules included in obj. 
如果可选的参数all为true，这个列表回包括那些被obj包括的模块的方法。
(The parameter defaults to false in versions of Ruby prior to January 2004.)
（在2004年1月之前的ruby版本中，这个参数默认是false）

    module Other
      def three(); end
    end
    class Single
      def Single.four(); end
    end
    a = Single.new
    def a.one(); end
    class << a
      include Other
      def two(); end
    end
    Single.singleton_methods    # => [:four]
    a.singleton_methods(false)  # => [:one, :two]
    a.singleton_methods(true)   # => [:one, :two, :three]
    a.singleton_methods         # => [:one, :two, :three]

#### taint  污染

    obj.taint → obj

Marks obj as tainted. 
将obj标记为受污染。
If the $SAFE level is greater than zero, some objects will be tainted on creation. 
如果$SAVE级别大于0,一些对象会在创建时被标记为受污染。
See Chapter 26, Locking Ruby in the Safe, on page 409.
参见前面2版397页4版409页开始的26章安全锁定。

#### tainted?  是否受到污染

    obj.tainted? → true or false

Returns true if the object is tainted.
如果对象被污染，返回true。

    a = "cat"
    a.tainted?  # => false
    a.taint     # => "cat"
    a.tainted?  # => true
    a.untaint   # => "cat"
    a.tainted?  # => false

#### tap  分流  1.9

    obj.tap { |val| … } → obj

Invokes the block, passing obj as a parameter. 
调用block，传入obj作为参数。
Returns obj. 
返回obj。
Allows you to write code that takes part in a method chain but that does not affect the overall value of the chain.
允许你写代码时，加入一个方法链，但不影响全部的链的值。

    puts "dog".reverse
              .tap {|o| puts "Reversed: #{o}"}
              .capitalize
    # produces:
    # Reversed: god
    # God

#### to_enum  转换为枚举 ⇡New in 2.0⇣

    obj.to_enum(using=:each, ‹ args ›+ ) → enumerator
    obj.to_enum(using=:each, ‹ args ›+ { |*args| … } → enumerator

Returns an Enumerator object that will traverse the content of obj. 
返回一个枚举对象，扫描obj的内容。
By default, this enumerator will invoke the each method of self, but this can be overridden by passing a different method name as the first parameter. 
默认下，这个枚举将调用自己的each方法，但这可以通过传入不同的方法名称作为第一个参数来改写。
Any additional arguments passed to `to_enum` will be passed to the enumerator method.
任何传递到`to_enum`的额外参数将被传递到枚举的方法。

    by_bytes = "∂og".to_enum(:each_byte)
    by_bytes.next # => 226
    by_bytes.next # => 136
    by_bytes.next # => 130
    by_bytes.next # => 111
    by_chars = "∂og".to_enum(:each_char)
    by_chars.next # => "∂"
    by_chars.next # => "o"
    by_chars.next # => "g"

If the block is present, it is called to return the size of the collection without actually iterating over each element. 
如果blok存在，将被调用来返回收集的大小，无需实际上迭代每个元素。
This facilitates calculating the size of lazily evaluated enumerations.
这将方便计算惰性求解枚举的大小。

#### to_s  转换为字符串

    obj.to_s → string

Returns a string representing obj. 
返回obj的字符串表示。
The default to_s prints the object’s class and an encoding of the object ID. 
默认的to_s打印出这个对象的类和对象ID的编码。
As a special case, the top-level object that is the initial execution context of Ruby programs returns “main.”
一个特别情况是，作为ruby程序的初始执行上下文，这个顶层对象回返回"main"。

#### trust  信任

    obj.trust → obj

Marks obj as trusted. 
将obj标记为受信任。
(See the section on trust on page 411.)
（见前面411页的章节）

#### untaint  去除污染

    obj.untaint → obj

Removes the taint from obj.
去除obj的taint状态。

#### untrust  去除信任

    obj.untrust → obj

Marks obj as untrusted. 
将obj标记为不受信任。
(See the section on trust on page 411.)
（参见前面411页的章节）

#### untrusted?  是否不受信任  1.9

    obj.untrusted? → true or false

Returns true if obj is untrusted, false otherwise.
如果obj是不受信任的，返回true；否则返回false。


### Private Instance Methods   私有实例方法
#### __callee__  当前方法  ⇡New in 2.0⇣

    __callee__ → symbol or nil

Returns the name of the current method or nil outside the context of a method. 
返回当前方法的名字，在方法上下文之外则返回nil。
If a method is called by an aliased name, that alias is returned, and not the original name.
如果方法通过别名调用，会返回别名，而不是原名。

    def fred
      puts "I'm in #{__callee__.inspect}"
    end
    fred
    puts "Then in #{__callee__.inspect}"
    # produces:
    # I'm in :fred
    # Then in nil

#### __dir__  文件所在目录绝对路径  New in 2.0⇣

    __dir__ → string

The absolute path to the directory of the file containing the call to this method.
包含调用该方法的文件的目录的绝对路径

#### __method__  当前方法

    __method__ → symbol or nil

Synonym for __callee__.
同__callee__。

#### ‘ (backquote)  反引号

    ‘cmd‘ → string

Returns the standard output of running cmd in a subshell. 
返回子shell中运行cmd的标准输出。
The built-in syntax %x{...} described in the tutorial on page 128 uses this method. 
前面128页描述的内建语法%x{...}使用这个方法。
Sets $? to the process status.
将$?设置为进程状态。

    `date`                   # => "Mon May 27 12:32:35 CDT 2013\n"
    `ls testdir`.split[1]    # => "main.rb"
    `echo oops && exit 99`   # => "oops\n"
    $?.exitstatus            # => 99

#### Array  数组

    Array( arg ) → array

Returns arg as an Array. 
用一个数组返回arg。
First tries to call `arg.to_ary` and then `arg.to_a`. 
首先调用`arg.to_ary`，然后调用`arg.to_a`。
If both fail, creates a single element array containing arg (or an empty array if arg is nil).
如果都失败，则创建一个只包含一个元素arg的数组（除非arg是nil）。

    Array(1..5) # => [1, 2, 3, 4, 5]

#### Complex  复数  1.9

    Complex( real, imag=0 ) → complex

Returns the complex number with the given real and imaginary parts.
返回复数，带有指定的实部和虚部。

    Complex(1)           # => 1+0i
    Complex("1")         # => 1+0i
    Complex("1", "3/2")  # => 1+3/2i
    Complex("3+2i")      # => 3+2i

#### Float  浮点数  1.8

    Float( arg ) → float

Returns arg converted to a float. 
将arg转换为一个浮点数。
Numeric types are converted directly; 
数字类型将被直接转化；
strings are converted by interpreting their content as either a decimal or (with a loading 0x) a hexadecimal floatingpoint constant—see the %a field specifier to sprintf; 
字符串类型则通过解释内容转化十进制（以0x开头）或十六进制浮点常数--参见sprintf的%a字段指示符。
the rest are converted using `arg.to_f`.
剩下的使用`arg.to_f`转换。
Converting nil generates a TypeError.
转换nil将产生一个TypeError。

    Float(1) # => 1.0
    Float("123.456") # => 123.456
    Float("0x1.921fb54442d18p+1") # => 3.141592653589793

#### Hash  散列表  ⇡New in 2.0⇣

    Hash( arg ) → hash

Convert arg to a hash by calling its `to_hash` method.
通过`to_hash`方法将arg转换为一个散列表。

    Hash(nil) # => {}
    Hash(x: 23, y: 67) # => {:x=>23, :y=>67}
    h1 = { a:1, c:3 }
    h2 = { b:2, d:4 }
    Hash(**h1, **h2) # => {:a=>1, :c=>3, :b=>2, :d=>4}

#### Integer  整数

    Integer( arg ) → int

Converts arg to a Fixnum or Bignum. 
将arg转化伟一个定数或大数。
Numeric types are converted directly (floating-point numbers are truncated). 
数值类型被直接转换（浮点数将被截断）。
If arg is a String, leading radix indicators (0, 0b, and 0x) are honored.
如果arg是个字符串，开头可以有基数指示符（0,0b和0x）。
Others are converted using `to_int` and `to_i`. 
对于其他类型将使用`to_int`和`to_i`。
This behavior is different from that of `String#to_i`.
这个行为不同与`String#to_i`。
Converting nil generates a TypeError.
转化nil将产生一个TypeError。

    Integer(123.999) # => 123
    Integer("0x1a") # => 26

#### Rational  有理数  1.9

    Rational( numerator, denominator=1 ) → rational

Returns the rational number with the given representation.
返回一个有理数，带有给定的表示。

    Rational(1)            # => 1/1  
    Rational("1")          # => 1/1
    Rational("1", "2")     # => 1/2
    Rational(1, 0.5)       # => 2/1
    Rational("3/2")        # => 3/2
    Rational("3/2", "4/5") # => 15/8

#### String  字符串

    String( arg ) → string

Converts arg to a String by calling its `to_s` method.
使用`to_s`方法将arg转化为一个字符串。

    String(self) # => "main"
    String(self.class) # => "Object"
    String(123456) # => "123456"

#### abort  终止执行

    abort
    abort( msg )

Terminates execution immediately with an exit code of 1. 
立即终止执行，退出码是1。
The optional String parameter is written to standard error before the program terminates.
如果带有字符串类型参数，则在程序终止前输出该字符串到标准错误中。

#### at_exit  退出运行

    at_exit { … } → proc

Converts block to a Proc object and registers it for execution when the program exits. 
将block转换成一个Proc对象，并注册该block以使它在程序退出时运行。
If multiple handlers are registered, they are executed in reverse order of registration.
如果注册了多个函数，则它们以和注册时间相反的顺序执行。

    def do_at_exit(str1)
      at_exit { print str1 }
    end
    at_exit { puts "cruel world" }
    do_at_exit("goodbye ")
    exit
    # produces:
    # goodbye cruel world

#### autoload  自动装载  1.8

    autoload( name, file_name ) → nil

Registers `file_name` to be loaded (using Object#require) the first time that the module name (which may be a String or a symbol) is accessed.
注册`file_name`，使得第一次访问模块name（可以是String或符号）时（使用Object#require）装载`file_name`

    autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")

Module.autoload lets you define namespace-specific autoload hooks:
Module.autoload 让你定义命名空间--指定自动装载钩子：

    module X
      autoload :XXX, "xxx.rb"
    end

Note that xxx.rb should define a class in the correct namespace. 
That is, in this example, xxx.rb should contain the following:
注意： xxx.rb需要载正确的名字空间中定义类。
例如在这个例子中xxx.rb应该包含：

    class X::XXX
      # ...
    end

#### autoload?  是否自动装载

    autoload?( name ) → file_name or nil

Returns the name of the file that will be autoloaded when the string or symbol name is referenced in the top-level context or returns nil if there is no associated autoload.
返回当顶级上下文中的字符串或符号name被访问时将被自动装载的文件的名字；如果没有相关联的自动装载文件，返回nil。

    autoload(:Fred, "module_fred") # => nil
    autoload?(:Fred) # => "module_fred"
    autoload?(:Wilma) # => nil

#### binding  绑定对象

    binding → a_binding

Returns a Binding object, describing the variable and method bindings at the point of call.
返回一个绑定对象，该对象描述了此函数被调用时绑定的变量和方法。
This object can be used when calling eval to execute the evaluated command in this environment. 
当调用eval时，可以使用这个对象，以其作为执行求解后命令的环境。
Also see the description of class Binding on page 447.
另见前面2版444页4版447页关于绑定类的更多描述。

    def get_binding(param)
      return binding
    end
    b = get_binding("hello")
    eval("param", b) # => "hello"

#### block_given?  是否有block

    block_given? → true or false

Returns true if yield executes a block in the current context.
如果载当前的上下文中进行yield，能够执行到一个block，返回true。

    def try
      if block_given?
        yield
      else
        "no block"
      end
    end
    try # => "no block"
    try { "hello" } # => "hello"
    block = lambda { "proc object" }
    try(&block) # => "proc object"

#### caller  调用器 ⇡New in 2.0⇣

    caller( ‹ start‹ , max_size ›› ) → array
    caller( ‹ range › ) → array

Returns the current execution stack—an array containing strings in the form file:line or file:line: in ‘method’. 
返回当前的执行栈--一个字符串数组，每个元素的格式为file:line或file:line:in'method'。
The optional start parameter determines the number of initial stack entries to omit from the result. 
可选的start参数决定在结果中要忽略的调用栈的最初几项。
The optional max_size parameter sets the maximum size of the returned array. 
可选的maximum参数设置返回数组的最大长度。
Alternatively, passing a range parameter retrieves the given stack entries.
可选的，传入一个范围参数可重新得到给定栈项目。

    def a(skip)
      caller(skip)
    end
    def b(skip)
      a(skip)
    end
    def c(skip)
      b(skip)
    end
    c(0) # => ["prog.rb:2:in `a'", "/tmp/prog.rb:5:in `b'", "/tmp/prog.rb:8:in
         # .. `c'", "/tmp/prog.rb:10:in `<main>'"]
    c(1) # => ["prog.rb:5:in `b'", "/tmp/prog.rb:8:in `c'", "/tmp/prog.rb:11:in
         # .. `<main>'"]
    c(2) # => ["prog.rb:8:in `c'", "/tmp/prog.rb:12:in `<main>'"]
    c(3) # => ["prog.rb:13:in `<main>'"]

#### caller_locations  调用器位置  ⇡New in 2.0⇣

    caller_locations → array of caller sites

Returns an array containing the call stack.
返回包含调用栈的数组。

    def outer
      inner
    end
    def inner
      p caller_locations
    end
    puts outer
    # produces:
    # ["prog.rb:2:in `outer'", "/tmp/prog.rb:9:in `<main>'"]
    # prog.rb:2:in `outer'
    # prog.rb:9:in `<main>'

#### catch  执行block

    catch( object=Object.new ) { … } → obj

catch executes its block. 
catch执行它的block。
If a throw is encountered, Ruby searches up its stack for a catch block with a parameter identical to the throw’s parameter. 
如果执行过程中遇到throw，ruby将在栈中向上搜索参数等于throw的参数的catch block。
If found, that block is terminated, and catch returns the value given as the second parameter to throw. 
如果找到，该block将被终止，并且catch返回传给throw的值。
If throw is not called, the block terminates normally, and the value of catch is the value of the last expression evaluated. 
如果没有调用throw，block将正常终止，且catch的返回值是执行最后一个表达式的值。
catch expressions may be nested, and the throw call need not be in lexical scope. 
catch表达式可以嵌套，且throw不一定在词法（2版译为同一）作用域中。
Prior to Ruby 1.9, the parameters to catch and throw had to be symbols—they can now be any object. 
在ruby 1.9之前，catch和throw的参数必须是符号--现在可以是任何对象了。
When using literals, it probably makes sense to use only immediate objects.
使用迭代器时，只有使用立即对象才是有意义的。

    def routine(n)
      print n, ' '
      throw :done if n <= 0
      routine(n-1)
    end
    catch(:done) { routine(4) }
    # produces:
    # 4 3 2 1 0

#### chomp  去除换行符

    chomp( ‹ rs › ) → $_ or ‹ string ›

Equivalent to `$_ = $_.chomp(rs)`, except no assignment is made if chomp doesn’t change `$_`. 
等同于`$_ = $_.chomp(rs)`，除了chomp没有改变`$_`、不会执行赋值操作。
See String#chomp on page 672. 
参见后面2版610页4版672页的String#chomp。
Available only if the -n or -p command-line options are present.
只有存在-n 或-p命令行选项时才可用。

#### chop  砍尾

    chop → string

(Almost) equivalent to `$_.dup.chop!`, except that if chop performs no action, `$_` is unchanged and nil is not returned. 
除了当chop不做任何操作、不会改变`$_`且不会返回nil之外，几乎等同于`$_.dup.chop!`。
See String#chop! on page 672. 
参见后面2版610页4版672页的。
Available only if the -n or -p commandline option is present.
只有存在-n 或-p命令行选项时才可用。

#### define_method  定义方法  ⇡New in 2.0⇣

    define_method( symbol, method ) → method
    define_method( symbol ) { … } → proc

Defines a global method. 
定义一个全局方法。
The behavior is analogous to `Module#define_method`.
行为类似`Module#define_method`。

    define_method(:adder, -> (a, b) { a+b })
    adder(1, 2) # => 3
    adder("cat", "dog") # => "catdog"

Note that it is possible to define methods with names that are not valid if you were to use the def keyword. 
注意如果你使用def关键字作为所定义方法的名称时，可能无效。
These methods cannot be invoked directly.
这些方法不能直接被调用。

    class Silly
      define_method("Oh !@!#^!") { "As Snoopy says" }
    end
    Silly.new.send("Oh !@!#^!") # => "As Snoopy says"

#### eval  执行字符串表达式  1.8

    eval( string ‹ , binding ‹ , file ‹ , line ›››) → obj

Evaluates the Ruby expression(s) in string. 
执行string中的ruby表达式。
If binding is given, the evaluation is performed in its context. 
如果带有binding参数，则在其上下文中执行计算。
The binding must be a Binding object. 
binding必须是一个Binding对象。
If the optional file and line parameters are present, they will be used when reporting syntax errors.
如果带有可选的file和line参数，当遇到语法错误时，用来报告错误。

    def get_binding(str)
      return binding
    end
    str = "hello"
    eval "str + ' Fred'" # => "hello Fred"
    eval "str + ' Fred'", get_binding("bye") # => "bye Fred"

Local variables assigned within an eval are available after the eval only if they were defined at the outer scope before the eval executed. 
在eval内赋值的局部变量，仅当它在执行eval之前的外部作用域中曾定义过，才会在eval之后仍然有效。
In this way, eval has the same scoping rules as blocks.
在这种方式下，eval和block有相同的作用域规则。

    a = 1
    eval "a = 98; b = 99"
    puts a
    puts b
    # produces:
    # 98
    # prog.rb:4:in `<main>': undefined local variable or method `b' for main:Object
    # (NameError)

#### exec  执行外部命令

    exec(‹ env, › command ‹ , args ›*, ‹ options › )

Replaces the current process by running the given external command. 
通过运行给定的外部命令替换当前进程。
If exec is given a single argument, that argument is taken as a line that is subject to shell expansion before being executed. 
如果exec只有一个参数，那么载执行之前shell将对该参数进行扩展。
If command contains a newline or any of the characters ?*?{}[]<>()~&|$;'`", or under Windows if command looks like a shell-internal command (for example dir), command is run under a shell. 
如果command含有换行符或?*?{}[]<>()~&|$;'`"中的任意一个字符，或者如果在Windows下command是shell的内部命令，那么command将在shell中运行。
On Unix system, Ruby does this by prepending sh -c. 
在Unix系统上，ruby通过添加`sh -c`到command的头部来实现。
Under Windows, it uses the name of a shell in either RUBYSHELL or COMSPEC.
在Windows上，它使用RUBYSHELL或者COMSPEC指定的shell。

If multiple arguments are given, the second and subsequent arguments are passed as parameters to command with no shell expansion. 
如果有多个参数，那么第二个参数和随后的参数将作为参数传递给command，且不执行shell扩展。
If the first argument is a two-element array, the first element is the command to be executed, and the second argument is used as the argv[0] value, which may show up in process listings. 
如果第一个参数是含有两个元素的数组，那么第一个元素将是被执行的命令，第二个参数是argv[0]的值，用来载进程列表中显示进程的名字。
In MSDOS environments, the command is executed in a subshell; otherwise, one of the exec(2) system calls is used, so the running command may inherit some of the environment of the original program (including open file descriptors). 
在MSDOS环境中，命令将在子shell中运行：在其他系统中，exec(2)系统调用中的一个将被使用，所以运行的命令可能会从源程序中继承一些环境变量（包括打开的文件描述符）。
Raises SystemCallError if the command couldn’t execute (typically Errno::ENOENT).
如果不能执行command命令，则引发SystemCallError（通常是Errno:ENOENT）。

    exec "echo *" # echoes list of files in current directory
    # never get here
    
    exec "echo", "*" # echoes an asterisk
    # never get here

env, if present, is a hash that adds to the environment variables in the subshell. 
如果env参数存在，是添加到子shell环境变量中的一个散列表。
An entry with a nil value clears the corresponding environment variable. 
带有nil值的项目将清除相应的环境变量。
The keys must be strings.
键必须是字符串。

options, if present, is a hash that controls the setup of the subshell. 
options，如果存在，是一个控制子shell安装的散列表。
The possible keys and their meanings are listed under #spawn. 
#spaw列出了可能的键和相应的含义。
See also Object#spawn and Object#system.
另见Object#spawn和Object#system。

exit  退出脚本运行  1.8

    exit( true | false | status=1 )

Initiates the termination of the Ruby script. 
终止ruby脚本的运行。
If called in the scope of an exception handler, raises a SystemExit exception. 
如果是在一个异常处理程序的作用域中被调用，则引发SystemExit异常。
This exception may be caught. 
这个异常可被捕获。
Otherwise, exits the process using exit(2). 
否则实用exit(2)退出进程。
The optional parameter is used to return a status code to the invoking environment. 
可选参数用来返回一个状态码给调用环境。
With an argument of true, exits with a status of zero. 
如果参数是true，退出状态为0。
With an argument that is false (or no argument), exits with a status of 1; otherwise, exits with the given status. 
如果参数是flase，或者没有参数，则退出状态为1；否则以给定的退出状态码退出。
The default exit value is 1.
默认退出值是1。

    fork { exit 99 }
    Process.wait
    puts "Child exits with status: #{$?.exitstatus}"
    begin
      exit
      puts "never get here"
    rescue SystemExit
      puts "rescued a SystemExit exception"
    end
    puts "after begin block"
    # produces:
    # Child exits with status: 99
    # rescued a SystemExit exception
    # after begin block

Just prior to termination, Ruby executes any at_exit functions and runs any object finalizers (see ObjectSpace on page 631).
在即将退出之前，ruby回执行任意at_exit函数，以及任意对象清理函数(析构器)（参见后面2版578页4版631页的ObjectSpace）。

    at_exit { puts "at_exit function" }
    ObjectSpace.define_finalizer("xxx",
                                  exit
                                  lambda { |obj| puts "in finalizer" })
    # produces:
    # at_exit function
    # in finalizer

#### exit!  立即退出  1.8

    exit!( true | false | status=1 )

Similar to Object#exit, but exception handling, at_exit functions, and finalizers are bypassed.
和Object#exit类似，但是跳过异常处理、at_exit函数和对象清理函数(<kinder:note> 对象析构器)。

#### fail  抛出异常

    fail( message )
    fail( exception ‹ , message ‹ , array ›› )}

Synonym for Object#raise.
同Object#raise。

#### fork  创建子进程

    fork ‹ { … } › → int or nil

Creates a subprocess. 
创建一个子进程。
If a block is specified, that block is run in the subprocess, and the subprocess terminates with a status of zero. 
如果提供了block，则将在子进程中运行该block，且子进程的退出状态为0.
Otherwise, the fork call returns twice, once in the parent, returning the process ID of the child, and once in the child, returning nil. 
否则fork调用将返回两次，一次在父进程中，返回子进程的进程ID；一次在子进程中，返回nil。
The child process can exit using Object#exit! to avoid running any `at_exit` functions.
子进程可以调用Object#exit!来避免调用任意的`at_exit`函数。 
The parent process should use Process.wait to collect the termination statuses of its children or it should call Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes.
父进程需要用processes.wait来获取子进程的退出状态，或者使用Process.detach来忽略它们的退出状态；否则，
操作系统的僵死进程将将不断增加。

    fork do
      3.times {|i| puts "Child: #{i}" }
    end
    3.times {|i| puts "Parent: #{i}" }
    Process.wait
    # produces:
    # Parent: 0
    # Child: 0
    # Parent: 1
    # Child: 1
    # Parent: 2
    # Child: 2

#### format  格式输出

    format( format_string ‹ , arg ›* ) → string

Synonym for Object#sprintf.
同Object#sprintf。

#### gem  珍宝

    gem( gem_name ‹ , version › ) → true or false

Adds the given gem to the applications include path so that subsequent requires will search.
将给定的gem添加到应用程序中，包括路径以便后面的搜索。
Defaults to the latest version of the gem if no version information is given. 
如果没有给定version默认为最新版本的gem。
See Gems and Versions, on page 220 for more information and examples.
更多信息和例子详见前面220页的Gems和版本。

#### gem_original_require  原版珍宝

    gem_original_require ‹ filename ›+

The version of Object#require that does not know about RubyGems.
Object#require的不知道RubyGems的版本
<kinder:note> 怎么理解啊？

#### gets  读入一行

    gets( separator=$/ ) → string or nil

Returns (and assigns to $_) the next line from the list of files in ARGV (or `$*`) or from standard input if no files are present on the command line. 
返回ARGV（或`$*`)给出的文件列表中文件的下一行，并赋给`$_`，如果命令行未提供文件，则返回标准输入的下一行。
Returns nil at end of file. 
如果到达了文件结尾，返回nil。
The optional argument specifies the record separator. 
可选的参数是记录分隔符。
The separator is included with the contents of each record. 
分隔符包含在每个记录的内容中。
A separator of nil reads the entire contents, and a zero-length separator reads the input one paragraph at a time, where paragraphs are divided by two consecutive newlines.
如果分隔符为nil，则读取全部内容；如果分隔符长度为0,则一次读取一段，其中的段由两个连续的换行符分割。
If multiple filenames are present in ARGV, gets(nil) reads the contents one file at a time. 
如果ARGV中有多个文件，gets(nil)一次读取一个文件。
Programming using `$_` as an implicit parameter is losing favor in the Ruby community.
使用`$_`作为隐含参数的编程风格，逐渐被ruby社区所弃用。

    ARGV << "testfile"
    print while gets
    # produces:
    # This is line one
    # This is line two
    # This is line three
    # And so on...

#### global_variables  全局变量列表

    global_variables → array

Returns an array of the names of global variables.
返回全局变量组成的一个数组。

    global_variables.grep /std/ # => [:$stdin, :$stdout, :$stderr]

#### gsub  替换

    gsub( pattern, replacement ) → string
    gsub( pattern ) { … } → string

Equivalent to $_.gsub(...), except that $_ will be updated if substitution occurs. 
除了在发生替换时会更新`$_`的值之外，与`$_.gsub(...)等价。
Available only when the -n or -p command-line option is present.
仅当-n和-p命令行选项存在时才可用。

#### initialize  初始化

    initialize( ‹ arg ›+ )

Called as the third and final step in object construction, initialize is responsible for setting up the initial state of the new object. 
initialize作为对象构造的第三步也是最后一步被调用，它负责设置新对象的初始状态。
<kinder:note> 另外三步呢？
You use the initialize method the same way you’d use constructors in other languages. 
你可以像在其他语言中使用构造函数那样，来实用initialize方法。
If you subclass classes other than Object, you will probably want to call super to invoke the parent’s initializer.
如果你继承了Object之外的类，你可能想调用super以调用父类的initializer。
<kinder:note> 2版译注：super将调用父类中的同名方法，参见super。

    class A
      def initialize(p1)
        puts "Initializing A: p1 = #{p1}"
        @var1 = p1
      end
    end
    class B < A
      attr_reader :var1, :var2
      def initialize(p1, p2)
        super(p1)
        puts "Initializing B: p2 = #{p2}"
        @var2 = p2
      end
    end
    b = B.new("cat", "dog")
    puts b.inspect
    # produces:
    # Initializing A: p1 = cat
    # Initializing B: p2 = dog
    # #<B:0x007f817990eaa0 @var1="cat", @var2="dog">

#### iterator?  是否有block

    iterator? → true or false

Deprecated synonym for Object#block_given?.
同Object#block_given，但已过时。

#### lambda  拉姆达函数

    lambda { … } → proc

Creates a new procedure object from the given block. 
根据给定的block创建一个新的过程对象。
See the discussion in the tutorial on page 336 for an explanation of the difference between procedure objects created using lambda and those created using Proc.new. 
对于使用lambda和Proc.new创建过程对象的区别，参见2版357页4版336页。
Note that lambda is now preferred over proc.
注意现在推荐尽量实用lambda而不是proc。

    prc = lambda { "hello" }
    prc.call # => "hello"

#### load  装载

    load( file_name, wrap=false ) → true

Loads and executes the Ruby program in the file `file_name`. 
装载和执行ruby程序文件`file_name`。
If the filename does not resolve to an absolute path, the file is searched for in the library directories listed in $:. 
如果文件名不是绝对路径，则ruby将在$:列出的库路径中搜索。
If the optional wrap parameter is true, the loaded script will be executed under an anonymous module, protecting the calling program’s global namespace. 
如果可选的参数wrap为true，被装载的脚本将在一个匿名的模块中执行，以保护调用程序的全局命名空间。
In no circumstance will any local variables in the loaded file be propagated to the loading environment.
无论如何，被装载文件的任何局部变量都不会被传播到装载环境中。

#### local_variables  局部变量列表

    local_variables → array

Returns the names of the current local variables.
返回当前局部变量的名称。

    fred = 1
    for i in 1..10
      # ...
    end
    local_variables # => [:fred, :i]

Note that local variables are associated with bindings.
注意局部变量和绑定相关联。

    def fred
      a = 1
      b = 2
      binding
    end
    freds_binding = fred
    eval("local_variables", freds_binding) # => [:a, :b]

#### loop  循环

    loop ‹ { … } ›

Repeatedly executes the block.
重复执行block。

    loop do
      print "Type something: "
      line = gets
      break if line.nil? || line =~ /^[qQ]/
      # ...
    end

loop silently rescues the StopIteration exception, which works well with external iterators.
循环会静默救援StopIteration异常，该异常在迭代器外部出现。

    enum1 = [1, 2, 3].to_enum
    enum2 = [10, 20].to_enum
    loop do
    puts enum1.next + enum2.next
    end
    # produces:
    # 11
    # 22

#### open  打开IO对象

    open( name ‹ , mode ‹ , permission ›› ) → io or nil
    open( name ‹ , mode ‹ , permission ›› ) { |io| … } → obj

Creates an IO object connected to the given stream, file, or subprocess.
创建一个连接到指定流、文件或子进程的IO对象。
If name does not start with a pipe character (|), treats it as the name of a file to open using the specified mode defaulting to "r" (see Table 16, Mode values, on page 494). 
如果name不是以管道符|开头，那么ruby把它当作要打开的文件名，默认的打开模式是r（参见前面2版504页4版494页的有效模式列表）。
If a file is being created, its initial permissions may be set using the third parameter, which is an integer. 
如果需要创建文件，那么它的初始权限可以通过第三个整数参数来设置。
If this third parameter is present, the file will be opened using the low-level open(2) call rather than the fopen(3) call.
如果提供了第三个参数，则实用底层的open(2)而不是fopen(3)调用打开的文件 。

If a block is specified, it will be invoked with the IO object as a parameter, which will be closed when the block terminates. 
如果带有block，则以IO对象为参数调用该block；当block终止时，IO对象将自动被管理。
The call returns the value of the block in this case.
在这种情况下返回block的值。

If name starts with a pipe character, a subprocess is created, connected to the caller by a pair of pipes. 
如果name以管道符|开头，则将创建一个子进程，并通过一个管道连接到调用者。
The returned IO object may be used to write to the standard input and read from the standard output of this subprocess. 
可以使用返回的IO对象向子进程的标准输入写入，或从其标准输入中读取。
If the command following | is a single minus sign, Ruby forks, and this subprocess is connected to the parent. 
如果|字符后面的命令是一个减号，那么ruby将创建一个子进程，且此子进程连接到父进程。
In the subprocess, the open call returns nil. 
If the command is not "--", the subprocess runs the command. 
如果命令不是“--”，那么子进程将运行该命令。
If a block is associated with an open("|--") call, that block will be run twice—once in the parent and once in the child. 
如果有一个block关联到了open("|--")，那么该block将被运行两次--一次在父进程中一次在子进程中。
The block parameter will be an IO object in the parent and nil in the child. 
在父进程中block的参数是一个IO对象，而在子进程中参数为nil。
The parent’s IO object will be connected to the child’s STDIN and STDOUT. 
父进程的IO对象将被关联到子进程的STDIN和STDOUT。
The subprocess will be terminated at the end of the block.
在block结束时子进程也将终止。

    open("testfile", "r:iso-8859-1") do |f|
      print f.gets
    end
    # produces:
    # This is line one

Open a subprocess, and read its output:
打开一个子进程，并读取其输出：

    cmd = open("|date")
    print cmd.gets
    cmd.close
    # produces:
    # Mon May 27 12:32:39 CDT 2013


Open a subprocess running the same Ruby program:
打开一个运行相同ruby程序的子进程：

    f = open("|-", "w+")
    if f.nil?
      puts "in Child"
      exit
    else
      puts "Got: #{f.gets}"
    end
    # produces:
    # Got: in Child

Open a subprocess using a block to receive the I/O object:
打开一个子进程，使用block来接收IO对象：

    open("|-") do |f|
      if f.nil?
        puts "in Child"
      else
        puts "Got: #{f.gets}"
      end
    end
    # produces:
    # Got: in Child

#### p  美观输出

    p( ‹ obj ›+ ) → obj

For each object, writes obj.inspect followed by the current output record separator to the program’s standard output. 
对于每个对象，输出obj.inpect，后跟当前输出记录分隔符，到程序的标准输出。
Also see the PrettyPrint library on page 789. 
另见后面2版716页4版789页的PrettyPrint库。
Returns obj.
返回obj。

    Info = Struct.new(:name, :state)
    p Info['dave', 'TX']
    # produces:
    # #<struct Info name="dave", state="TX">

#### print  输出  1.8

    print( ‹ obj ›* ) → nil

Prints each object in turn to STDOUT. 
依次打印每个对象到STDOUT。
If the output field separator ($,) is not nil, its contents will appear between each field. 
如果输出域分隔符（$,）不是nil，那么它的内容将出现载每个域之间。
<kinder:note> $,默认为nil。
If the output record separator ($\) is not nil, it will be appended to the output. 
如果输出记录分隔符（$\）不是nil，那么将添加它到输出末尾。
<kinder:note> $\默认为nil。
If no arguments are given, prints `$_`. 
如果没有任何参数，则打印`$_`
Objects that aren’t strings will be converted by calling their to_s print method.
如果对象不是字符串，则调用其`to_s`方法把它转换成字符串。

    print "cat", [1,2,3], 99, "\n"
    $, = ", "
    $\ = "\n"
    print "cat", [1,2,3], 99
    # produces:
    # cat[1, 2, 3]99
    # cat, [1, 2, 3], 99

#### printf  格式打印

    printf( io, format ‹ , obj ›* ) → nil
    printf( format ‹ , obj ›* ) → nil

Equivalent to the following:
等同于下面：

    io.write(sprintf(format, obj, ...))
    # or  或者
    write(sprintf(format, obj, ...))

#### proc  过程  1.8

    proc { … } → a_proc

Creates a new procedure object from the given block. 
使用给定的block创建一个新的过程对象。
Use Object#lambda instead.
不如实用Object#lambda。

    prc = proc {|name| "Goodbye, #{name}" }
    prc.call('Dave') # => "Goodbye, Dave"

#### putc  输出第一个字符

    putc( obj ) → obj

Equivalent to STDOUT.putc(obj). 
同STDOUT.putc(obj)。
<kinder:note> 该方法参见前面的io类。
If obj is a string, output its first character; otherwise, attempts to convert obj to an integer and outputs the corresponding character code.
如果obj是个字符串，输出第一个字符；否则尝试将obj转化为整数然后输出它对应的字符代码。

    putc 65
    putc 66.123
    putc "CAT"
    putc 12 # newline
    # produces:
    # ABC

#### puts  输出字符串

    puts( ‹ arg ›* ) → nil

Equivalent to STDOUT.puts(arg...).
同STDOUT.puts(arg...)。
<kinder:note> 参见前面io类。

#### raise  抛出异常

    raise
    raise( message )
    raise( exception ‹ , message ‹ , array ›› )

With no arguments, raises the exception in $! or raises a RuntimeError if $! is nil. 
如果没有参数，引发$!变量保存的异常；如果$!为nil，引发RuntimeError。
With a single String argument (or an argument that responds to to_str), raises a RuntimeError with the string as a message. 
如果有一个string参数，引发RuntimeError异常，并以该字符串作为消息。
Otherwise, the first parameter should be the name of an Exception class (or an object that returns an Exception when its exception method is called). 
否则第一个参数需要Exception类的名字（或者当发送异常时返回Exception的一个对象）。
The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. 
可选的第二个参数设置和异常相关联的消息，第三个参数是含有调用栈信息的数组。
Exceptions are caught by the rescue clause of begin...end blocks.
异常将被begin...end块的rescue语句所捕获。

    raise "Failed to create socket"
    raise ArgumentError, "No parameters", caller

#### rand  伪随机数

    rand( max=0 ) → number
    rand( range ) → number

Converts max to an integer using `max1 = max.to_i.abs`. 
使用`max1 = max.to_i.abs`将max转化为一个整数。
If the result is zero or nil, returns a pseudorandom floating-point number greater than or equal to 0.0 and less than 1.0. 
如果返回的结果为0,返回一个大于等于0.0且小于1.0的一个伪随机浮点数。
Otherwise, returns a pseudorandom integer greater than or equal to zero and less than max1. 
否则返回一个大于等于0、小于max1的一个伪随机整数。
If a range is passed, return a random number in that range. 
如果传入一个范围，返回一个位于该范围的随机数。
Object#srand may be used to ensure repeatable sequences of random numbers between different runs of the program. 
Object#srand可用来保证每次运行程序时获得不同的随机数。
See also class Random on page 655.
另见后面655页的Random类。

    srand 1234 # => 272125880215485747773990619030416710243
    [ rand, rand ] # => [0.1915194503788923, 0.6221087710398319]
    [ rand(10), rand(1000) ] # => [4, 664]
    srand 1234 # => 1234
    [ rand, rand ] # => [0.1915194503788923, 0.6221087710398319]
    rand(5..10) # => 9
    rand(1.1..1.2) # => 1.1612111893665362

#### readline  读入行

    readline( ‹ separator=$/ › ) → string

Equivalent to Object#gets, except readline raises EOFError at end of file.
除了readline会在遇到文件末尾引发EOFError之外，同Object#gets。

#### readlines  读入所有行

    readlines( ‹ separator=$/ › ) → array

Returns an array containing each of the lines returned by calling gets(separator).
返回一个数组，该数组包含调用gets(separator)直到文件末尾获得的所有行。

#### remove_instance_variable  删除实例变量

    remove_instance_variable( symbol ) → other_obj

Removes the named instance variable from obj, returning that variable’s value.
从obj删除给定的实例变量，并返回这个变量的值。

    class Dummy
      def initialize
        @var = 99
      end
      def remove
        remove_instance_variable(:@var)
      end
      def var_defined?
        defined? @var
      end
    end
    d = Dummy.new
    d.var_defined? # => "instance-variable"
    d.remove # => 99
    d.var_defined? # => nil

#### require  装载库文件  1.8

    require( library_name ) → true or false

Ruby tries to load `library_name`, returning true if successful. 
Ruby试图装载`library_name`，如果成功返回true。
If the filename is not an absolute path, it will be searched for in the directories listed in $:. 
如果文件名不能解析成绝对路径，那么将在$:列出的目录中搜索它。
If the file has the extension .rb, it is loaded as a source file; if the extension is .so, ..o, or ..dll[1], Ruby loads the shared library as a Ruby extension. 
如果文件含有.rb扩展，则作为源文件被装入；如果扩展名是.so，.o或.dll，ruby将把这些共享库作为ruby扩展加以装载。
Otherwise, Ruby tries adding .rb, ..so, and so on, to the name. 
否则，ruby回试图将.rb，.so等扩展名加到文件之后。
The name of the loaded feature is added to the array in $". 
被装载的代码对应的文件名字将被添加到数组$"中。
A feature will not be loaded if its name already appears in $"[2]. 
如果其名字已经出现在$"中，则它将不被装载。
require returns true if the feature was successfully loaded.
如果成功装载，返回ture。
[1].  Or whatever the default shared library extension is on the current platform
或者当前平台上的任意默认共享库扩展名。
[2].  As of Ruby 1.9, this name is converted to an absolute path, so `require 'a';require './a'` will load a.rb once.
在ruby 1.9,这个名字被转化为一个绝对路径，所以`require 'a';require './a'`只将a.rb装载一次。

    require 'my-library.rb'
    require 'db-driver'

#### require_relative  相对路径装载文件  1.9

    require_relative( library_path ) → true or false

Requires a library whose path is relative to the file containing the call. 
读入一个路径相对于包含该调用的文件的路径。
Thus, if the directory /usr/local/mylib/bin contains the file myprog.rb and that program contains the following line:
因此，如果目录/usr/local/mylib/bin包含了文件myprog.rb，该文件包含：

    require_relative "../lib/mylib"

then Ruby will look for mylib in /usr/local/mylib/lib.
ruby将会在/usr/local/mylib/lib寻找mylib。
require_relative cannot be called interactively in irb.
require_relative不能在irb被直接调用。

#### select  等待数据

    select( read_array ‹ , write_array ‹ , error_array ‹ , timeout ››› ) → array or nil

Performs a low-level select call, which waits for data to become available from input/output devices. 
执行底层的select调用，该函数从输入输出设备上等待数据。
The first three parameters are arrays of IO objects or nil. 
前三哥参数是IO对象数组或者nil。
The last is a timeout in seconds, which should be an Integer or a Float. 
最后一个参数是以秒为单位的超时值，可以是整数或浮点数。
The call waits for data to become available for any of the IO objects in `read_array`, for buffers to have cleared sufficiently to enable writing to any of the devices in `write_array`, or for an error to occur on the devices in `error_array`. 
本函数等待，直到`read_array`中任意一个IO对象有数据可以读取，或者`write_array`中的某个设备其缓冲区已经被完全清空得以继续向其写入数据，或者`error_array`中的任意设备出现错误。

If one or more of these conditions are met, the call returns a three-element array containing arrays of the IO objects that were ready. 
如果这些条件有一个或多个满足，那么调用将返回一个含有三个元素的数组，每个数据元素均由已就绪的IO对象所组成的数组。
Otherwise, if there is no change in status for timeout seconds, the call returns nil. 
否则，如果状态在timeout时间内没有变量，返回nil。
If all parameters are nil, the current thread sleeps forever.
如果所有参数都是nil，当前线程永远进入睡眠。

    select( [STDIN], nil, nil, 1.5 ) # => nil

#### set_trace_func  设置跟踪函数 ⇡New in 2.0⇣

    set_trace_func( proc ) → proc
    set_trace_func( nil ) → nil

(This method has been replaced by the TracePoint class in Ruby 2.0.) 
(这个方法在ruby2.0中已经被TracePoint类所替代)
Establishes proc as the handler for tracing or disables tracing if the parameter is nil. 
设立一个过程作为处理跟踪，或如果参数是nil则关闭跟踪。
proc takes up to six parameters: an event name, a filename, a line number, an object ID, a binding, and the name of a class.
proc带有6个参数：时间名称，文件名称，行号，对象ID，绑定，类名。
proc is invoked whenever an event occurs. 
只要事件发生，过程就会被调用。
Events are call (calls a Ruby method), c-call (calls a C-language routine), c-return (returns from a C-language routine), class (starts a class or module definition), end (finishes a class or module definition), line (executes code on a new line), raise (raises an exception), and return (returns from a Ruby method). 
事件包括：调用（调用一个ruby方法），c调用（调用一个c语言程序），c返回（从一个c程序返回），类（开始一个类或模块定义），结束（结束一个类或模块定义），行（在新的一行上执行代码），抛出（抛出异常），返回（从ruby方法返回）。
Tracing is disabled within the context of proc. 
在proc的上下文里，跟踪被关闭。
See the example in the tutorial on page 400 for more information.
更多信息见前面2版412页4版400页的例子。

#### spawn  派生

    spawn(‹ env, › command ‹ , args ›*, ‹ options › ) → pid

Executes command in a subshell, returning immediately. 
在子shell中执行命令，立即返回。
(Compare with Object#system, which waits for the command to complete before returning to the caller.) 
（比起Object#system，后者在返回调用者之前会等待命令完成）
Returns the process ID for the subprocess running the command.
返回运行命令的子进程的进程ID。

The command can be a string, which is passed to the system shell for interpretation or a command name followed by zero or more arguments. 
command（命令）可以是一个传入系统shell解释的字符串，或者是一个有/无参数的命令名。
In this case, the command is executed and passed the given arguments—the shell is not involved. 
在这种情况，命令被执行并传入给定的参数--和shell无关。
The command name may be a string or a two-element array, where the first element is the command itself and the second is the argv[0] value to be passed to exec(2). 
命令名可以是一个字符串或二元素数组（第一个元素是命令本身，第二个是被传给exec(2)的argv[0]的值）。
The latter may be used to change the process name on systems that support it.
后者可用于改变系统上的进程名字，只要系统支持这一特性。

    pid = spawn("echo hello")
    puts "Back in main program"
    STDOUT.flush
    rc, status = Process::waitpid2(pid)
    puts "Status = #{status}"
    # produces:
    # Back in main program
    # hello
    # Status = pid 23941 exit 0


env, if present, is a hash that adds to the environment variables in the subshell. 
**env**，如果存在，是一个散列表，将环境变量添加到子shell中。
An entry with a nil value clears the corresponding environment variable. 
值为nil的项目将清除对应的环境变量。
The keys must be strings.
键必须是字符串。

    pid = spawn({"FRED" => "caveman"}, "echo FRED = $FRED")
    Process::waitpid2(pid)
    # produces:
    # FRED = caveman

The options hash controls the setup of the subshell. 
**options**散列表控制子shell的设置。
Keys and their meanings are:
键和相应的含义是：
Option  选项 Effect on new process  对新进程的影响
`:pgroup => true | 0 | int`
If true or 0, the new process will be a process group leader. 
如果为true或0,新进程将是进程组组长。<kinder:note> ？？？
Otherwise, the process will belong to group int.
否则，进程将从属于组int。<kinder:note> ？？？
`:rlimit_xxx => val | [cur, max]`
Sets a resource limit. 
设置资源限度。
See Process.getrlimit for more information.
更多信息详见Process.getrlimit。
`:unsetenv_others => true`
Clears all environment variables; then sets only those passed in the env parameter.
清除所有的环境变量，然后只设置那些传入的环境参数。
`:chdir => dir`
Changes to directory dir before running the process.
运行进程之前将路径改为dir。
`:umask => int`
Specifies the umask for the process.
为进程指定umask。
`fd_desc => stream`
Sets the process’s standard input, output, or error to stream. 
设置进程的标准输入、输出或错误到流中。
See the description that follows this table for information.
更多信息详见下面表格的描述。
`:close_others => true | false`
By default, all file descriptors apart from 0, 1, and 2 are closed. 
默认关闭所有文件描述符，除了0、1、2。
You can specify false to leave them open.
你可以指定false来打开这些描述符。
`io_obj => :close`
Explicitly closes the file descriptor corresponding to `io_obj` in the child process.
显式关闭子进程中对应`io_obj`的文件描述符。

The `fd_desc` parameter identifies an I/O stream to be opened or assigned in the child process.
**`fd_desc`**参数指定打开或在子进程赋值的IO流。
It can be one of :in, STDIN, or 0 to represent standard input; :out, STDOUT, or 1 for standard output; or :err, STDERR, or 2 for standard error. 
可以是一下之一：:in, STDIN, 或0代表标准输入；:out, STDOUT, 1代表标准输出；:err, STDERR, 2代表标准错误输出。
It can also be an array containing one or more of these, in which case all fds in the array will be opened on the same stream.
也可以是一个包含一个或多个这些的数组，在这种情况下，所有数组里的文件描述符将在同一个流中被打开。

The stream parameter can be the following:
stream参数可以是下面这些：
• One of :in, STDIN, or 0 to represent the current standard input; :out, STDOUT, or 1 for the current standard output; or :err, STDERR, or 2 for the current standard error.
可以是一下之一：:in, STDIN, 或0代表当前的标准输入；:out, STDOUT, 1代表当前的标准输出；:err, STDERR, 2代表当前的标准错误输出。
• A string 
representing the name of a file or device.
字符串代表文件或设备的名字。
• An array. 
数组。
If it contains [:child, fd], redirects to the fd of the child process. 
如果包含[:child, fd]，重定向到子进程的文件描述符。
Otherwise, the first element is the name of a file or device, the optional second element is the mode, and the optional third element the permission. 
否则，第一个元素是文件或设备的名称，可选的第二个元素是模式，可选的第三个元素是权限。
See the description of File#new on page 494 for details.
详见前面494页File#new的描述。
This example shows the options in action:
这个例子表现选项的活动：

    reader, writer = IO.pipe
    pid = spawn("echo '4*a(1)' | bc -l", [ STDERR, STDOUT ] => writer)
    writer.close
    Process::waitpid2(pid)
    reader.gets # => "3.14159265358979323844\n"

#### sprintf  格式打印

    sprintf( format_string ‹ , arguments ›* ) → string

Returns the string resulting from applying `format_string` to any additional arguments.
应用`format_string`到其他参数，并返回结果字符串。
Within the format string, any characters other than format sequences are copied to the result.
在格式字符串内部，除了格式序列的其他任意字符将被直接拷贝到结果中去。
A format sequence consists of a percent sign; followed by optional flags, width, and precision indicators; an optional name; and then terminated with a field type character. 
一个格式序包含：百分号，可选标志、宽度精度描述符，可选名称，最后是一个字段类型字符。
The field type controls how the corresponding sprintf argument is to be interpreted, and the flags modify that interpretation.
域类型控制对相应的sprintf参数如何解释，而标准可以修改此解释。

##### 标志
The flag characters are:
标志字符是：
Flag标志               Applies To 应用到         Meaning含义

␣ (space，空格)        bdEefGgiouXx        
Leaves a space at the start of positive numbers.
在正数前面留一个空格。

digit$                 all（全部）              
Specifies the absolute argument number for this field. 
为这个字段执行绝对的参数个数。
Absolute and relative argument numbers cannot be mixed in a sprintf string.
在sprintf字符串中不能同时使用绝对和相对参数个数。

#                      beEfgGoxX            
Uses an alternative format. 
使用其他格式。
For the conversions b, o, X, and x, prefixes the result with b, 0, 0X, 0x, respectively. 
对b, o, X和x，在结果前面分别加b, o, 0X, 0x。
For E, e, f, G, and g, forces a decimal point to be added, even if no digits follow. 
对于E, e, f, G, 和g，即使没有小数也输出小数点。
For G and g, does not remove trailing zeros.
对于G和g，不去除尾部的零。

+                      bdEefGgiouXx
Adds a leading plus sign to positive numbers.
在正数的前面加一个加号。

-                      all（全部）
Left-justifies the result of this conversion.
使结果左对齐。

0 (zero)               bdEefGgiouXx
Pads with zeros, not spaces.
不用空格，而用0补齐。

*                        all（全部）
Uses the next argument as the field width. 
使用下一个参数作为字段的宽度。
If negative, left-justifies the result. 
如果是负数，则令结果左对齐。
If the asterisk is followed by a number and a dollar sign, uses the indicated argument as the width.
如果星号后跟一个数和一个美元符，则使用指定的参数作为宽度。

##### 字段宽度精度
The field width is an optional integer, followed optionally by a period and a precision. 
可选的字段宽度是一个整数，后可跟一个点和精度。
The width specifies the minimum number of characters that will be written to the result for this field. 
宽度指明了将该字段写入到结果字符串占用的最小字符个数。
For numeric fields, the precision controls the number of decimal places displayed. 
对于数值字段，精度控制要显示的小数个数。
As of Ruby 1.9, the number zero is converted to a zero-length string if a precision of 0 is given.
在ruby 1.9,如果指定了0精度，数字0会被转化为一个零宽度的字符串。
For string fields, the precision determines the maximum number of characters to be copied from the string. 
对于字符串字段，精度指明了将要从字符串中拷贝的字符的最大个数。
(Thus, the format sequence `%10.10s` will always contribute exactly ten characters to the result.)
（这样，格式序列`%10.10s`将总是拷贝十个字符到结果中。）

##### 字段类型
The field type characters are:
字段类型字符

    Field   Conversion
    字段    转换
    A       Same as %a, but uses uppercase X and P.
            同%a，但使用大写的X和P。
    a       Converts a float into hexadecimal representation `0xsignificandpdecimal-exp`.
            将浮点数转换为十六进制表示的`0xsignificandpdecimal-exp`
    B       Converts argument as a binary number (0B0101 if # modifier used).
            把参数转换成二进制（如果使用#修饰符，则是0B0101）
    b       Converts argument as a binary number (0b0101 if # modifier used).
            把参数转换成二进制（如果使用#修饰符，则是0b0101）
    c       Argument is the numeric code for a single character.
            参数是单个字符的数值码。
    d       Converts argument as a decimal number.
            把参数转换成十进制数。
    E       Equivalent to e but uses an uppercase E to indicate the exponent.
            等价于e，但使用大写的E表示指数。
    e       Converts floating point-argument into exponential notation with one digit before the decimal point. 
             把浮点数参数转换成指数形式，使得小数点前只有一个数字。
            The precision determines the number of fractional digits (default six).
             精度确定了小数的个数（默认为6）。
    f       Converts floating-point argument as [|-]ddd.ddd, where the precision determines the number of digits after the decimal point.
            把浮点数参数转换成`[|-]ddd.ddd`，精度确定了小数点后面数字的个数。
    G       Equivalent to g but uses an uppercase E in exponent form.
            等同于g，但使用大写的E表示指数。
             <kinder:note> 最大有效数字位数。
    g       Converts a floating-point number using exponential form if the exponent is less than -4 or greater than or equal to the precision, or in d.dddd form otherwise.
            如果指数小于-4或大于等于精度，则把浮点数转换成指数形式；否则使用`d.ddd`的形式。
             <kinder:note> 最大有效数字位数。
    i       Identical to d.
            等价于d。
            <kinder:note> 即十进制数字。
    o       Converts argument as an octal number.
            把参数转换成八进制数。
    p       The value of argument.inspect.
            argument.inspect的值。
    s       Argument is a string to be substituted. 
            参数是要被替换的字符串。
            If the format sequence contains a precision, at most that many characters will be copied.
            如果格式序列含有精度，那么至多有精度那么多的字符串被拷贝。
    u       Treats argument as an unsigned decimal number.
            把参数转换成无符号十进制数。
    X       Converts argument to hexadecimal with uppercase letters. 
            把参数转换成十六进制数，使用大写字母。
            Negative numbers will be displayed with two leading periods (representing an infinite string of leading FFs).
            负数前面将显示两个点（表示前面有无限个FF）。
    x       Converts argument to hexadecimal. 
            把参数转换成十六进制数。
            Negative numbers will be displayed with two leading periods (representing an infinite string of leading FFs).
            负数前面将显示两个点（表示前面有无限个FF）。

Here are some examples of sprintf in action:
下面是一些运行sprintf的例子：
<kinder:note> 第三行开始看不懂！你赢了，sprintf！

    sprintf("%d %04x", 123, 123)              # => "123␣007b"
    # %d 十进制。
    # %0 零补齐，4 四位，x 十六进制。 
    sprintf("%08b '%4s'", 123, 123)           # => "01111011␣'␣123'"
    # %0 零补齐，8 八位，b 二进制。
    # %4 四位，s替换。 s替换什么？替换原来的123？
    sprintf("%1$*2$s %2$d %1$s", "hello", 8)  # => "␣␣␣hello␣8␣hello"
    # %1$ 绝对参数一个，*2$使用2为宽度，s 替换。<kinder:note> 替换什么？？
    # %2$ 绝对参数两个，d 十进制数字。
    # %1$ 绝对参数一个，s替换。
    sprintf("%1$*2$s %2$d", "hello", -8)      # => "hello␣␣␣␣-8"
    sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)  # => "+1.23:␣1.23:1.23"

In Ruby 1.9, you can pass a hash as the second argument and insert values from this hash into the string. 
在ruby 1.9,你可以传入一个散列表作为第二参数，并从这个散列表中插入值到字符串中。
The notation <name> can be used between a percent sign and a field-type character, in which case the name will be used to look up a value in the hash, and that value will be formatted according to the field specification. 
符号<name>可用于%号和字段类型字符之间，在这种情况，name将用于在散列表中寻找一个值，该值将被根据字段的说明所格式化。
The notation {name} is equivalent to <name>s, substituting the corresponding value as a string. 
符号{name}等同于<name>，作为字符串替换对应的值。
You can use width and other flag characters between the opening percent sign and the {.
在开放的百分号和{之间，你可以使用宽度和其他标志字符。

    sprintf("%<number>d %04<number>x", number: 123)   # => "123␣007b"
    sprintf("%08<number>b '%5{number}'", number: 123) # => "01111011␣'␣␣123'"
    sprintf("%6<k>s: %<v>s", k: "Dave", v: "Ruby")    # => "␣␣Dave:␣Ruby"
    sprintf("%6{k}: %{v}", k: "Dave", v: "Ruby")      # => "␣␣Dave:␣Ruby"

#### srand  伪随机生成器种子

    srand( ‹ number › ) → old_seed

Seeds the pseudorandom number generator to the value of `number.to_i`. 
设置伪随机数生成器的种子为`number.to_i`。
If number is omitted or zero, uses `Random.new_seed`. 
如果number被忽略或为0,使用`Random.new_seed`。
(This is also the behavior if Object#rand is called without previously calling srand but without the sequence.)
（如果没有调用srand就调用Object#rand，也是用这种方法来生成种子，不过不用序号。） 
By setting the seed to a known value, scripts that use rand can be made deterministic during testing. 
通过将一个已知值设为种子，使用rand的脚本在测试时会具有确定性。
The previous seed value is returned.
返回之前的种子值。
Also see Object#rand on page 622 and class Random on page 655.
另见后面622页的Object#rand和655页的Random类。

#### sub  替换

    sub( pattern, replacement ) → $_
    sub( pattern ) { block } → $_

Equivalent to `$_.sub(args)`, except that `$_` will be updated if substitution occurs. 
除了在发生替换时会更新`$_`外，等于`$_.sub(args)`。
Available only if the -n or -p command-line option is present.
只有打开-n或-p命令行参数才可用。

#### syscall  调用系统函数

    syscall( fixnum ‹ , args ›* ) → int

Calls the operating system function identified by fixnum. 
调用ID为fixnum的操作系统函数。
The arguments must be either String objects or Integer objects that fit within a native long. 
参数必须是String对象或是可用本机long类型表示的Integer对象。
Up to nine parameters may be passed.
至多可以传递9个参数。
The function identified by fixnum is system dependent. 
以fixnum为ID的函数是系统相关的。
On some Unix systems, the numbers may be obtained from a header file called syscall.h. 
在某些Unix系统上，该数字可以从头文件syscall.h获得。
System is not always available.
系统并不总是可用。

    syscall 4, 1, "hello\n", 6        # '4' is write(2) on our system

#### system  系统调用

    system(‹ env, › command ‹ , args ›*, ‹ options › ) → true or false~or nil

Executes command in a subshell, returning true if the command was found and ran successfully, false if the command exited with a nonzero exit status, and nil if the command failed to execute. 
在子shell中执行command，如果找到命令并成功运行，返回true；如果命令带非零退出码退出，返回false；如果命令不能执行，返回nil。
An error status is available in $?. 
错误状态码在$?。

The arguments are processed in the same way as for Object#exec on page 615. 
参数的处理方式和前面2版521页4版615页的Kernel.exec一样。
env, if present, is a hash that adds to the environment variables in the subshell. 
如果env参数存在，是添加到子shell环境变量中的一个散列表。
An entry with a nil value clears the corresponding environment variable. 
带有nil值的项目将清除相应的环境变量。
The keys must be strings. 
键必须是字符串。
options, if present, is a hash that controls the setup of the subshell. 
options，如果存在，是一个控制子shell安装的散列表。
The possible keys and their meanings are listed under the spawn method.
spaw列出了可能的键和相应的含义。

    system("echo *")
    system("echo", "*")
    system({"WILMA" => "shopper"}, "echo $WILMA")
    # produces:
    # config.h main.rb
    # *
    # shopper

#### test  测试

    test(cmd, file1 ‹ , file2 › ) → obj

Uses cmd to perform various tests on file1 (see the first table that follows) or on file1 and file2 (see the second table).
使用数值cmd在file1（见下面的第一个表格）上、或file2和file2（见下面的第二个表格）上执行各种测试。

表格一：
Flag Returns        Description
标志 返回值         描述
?A   Time           Last access time for file1
                    file1的最后访问时间
?b   true or false  True if file1 is a block device
                    如果file1是块设备，则为true。
?c   true or false  True if file1 is a character device
                    如果file1是字符设备，则为true。
?C   Time           Last change time for file1
                    file1的最后修改时间。
?d   true or false  True if file1 exists and is a directory
                    如果file1存在且是目录，则为true。
?e   true or false  True if file1 exists
                    如果file1存在，则为true。
?f   true or false  True if file1 exists and is a regular file
                    如果file1存在且是个普通文件，则为true。
?g   true or false  True if file1 has the setgid bit set (false under NT)
                    如果file设置了setgid位，则为true（NT下为flase）
?G   true or false  True if file1 exists and has a group ownership equal to the caller’s group
                    如果file1存在且所属组等于调用者的组，返回true。
?k   true or false  True if file1 exists and has the sticky bit set
                    如果file1存在且设置了粘置位，则为true。
?l   true or false  True if file1 exists and is a symbolic link
                    如果文件file1存在且是符号链接，则为true。 
?M   Time           Last modification time for file1
                    file1的最后更改时间
?o   true or false  True if file1 exists and is owned by the caller’s effective UID
                    如果file1存在且被调用者的有效UID拥有，则为true。
?O   true or false  True if file1 exists and is owned by the caller’s real UID
                    如果file1存在且被调用者的真实UID拥有，则为true。
?p   true or false  True if file1 exists and is a fifo
                    如果file1存在且是一个先进先出文件，则为true。
?r   true or false  True if file1 is readable by the effective UID/GID of the caller
                    如果file1可被调用者的有效UID/GID读取，则为true。
?R   true or false  True if file1 is readable by the real UID/GID of the caller
                    如果file1可被调用者的真实UID/GID读取，则为true。  
?s   Integer or nil If file1 has nonzero size, returns the size; otherwise, returns nil
                    如果file1的大小不是0,则返回大小，否则返回nil。
?S   true or false  True if file1 exists and is a socket
                    如果file1存在且是套接字，则为true。
?u   true or false  True if file1 has the setuid bit set
                    如果file1设置了setuid位，则为true。
?w   true or false  True if file1 exists and is writable by the effective UID/ GID
                    如果file1存在且可被有效UID/GID写，则为true。
?W   true or false  True if file1 exists and is writable by the real UID/GID
                    如果file1存在且可被真实UID/GID写，则为true。
?x   true or false  True if file1 exists and is executable by the effective UID/GID
                    如果file1存在且可被有效UID/GID执行，则为true。
?X   true or false  True if file1 exists and is executable by the real UID/GID
                    如果file1存在且可被真实UID/GID执行，则为true。
?z   true or false  True if file1 exists and has a zero length
                    如果file1存在且长度为0, 则为true。

表格二
Flag  Description
标志  描述
?-    True if file1 is a hard link to file2
      如果file1是到file2的硬链接，则为true。
??=   True if the modification times of file1 and file2 are equal
      如果file1和file2的修改时间相同，则为true。
?<    True if the modification time of file1 is prior to that of file2
      如果file1的修改时间比file2前，则为true。
?>    True if the modification time of file1 is after that of file2
      如果file1的修改时间比file2后，则为true。

#### throw  抛出

    throw( symbol ‹ , obj › )

Transfers control to the end of the active catch block waiting for symbol. 
将控制权转移到等待symbol的活跃catch块的结尾。
Raises NameError if there is no catch block for the symbol. 
如果没有对应此符号的catch，则引发NameError。
The optional second parameter supplies a return value for the catch block, which otherwise defaults to nil. 
可选的第二个参数为catch块提供了返回值；如果没有第二个参数，返回nil。
For examples, see Object#catch on page 614.
例如，参见前面2版519页4版614页的Object#catch。

#### trace_var  追踪全局变量赋值

    trace_var( symbol, cmd ) → nil
    trace_var( symbol ) { |val| … } → nil

Controls tracing of assignments to global variables. 
控制对全局变量的赋值操作的追踪。
The parameter symbol identifies the variable (as either a string name or a symbol identifier). 
参数symbol表示被追踪的变量（或者是字符串名或是符号标识符）。
cmd (which may be a string or a Proc object) or the block is executed whenever the variable is assigned and receives the variable’s new value as a parameter. 
每当对变量赋值时，cmd（可以是字符串页可以是Proc对象）或关联的块将被执行 ，并以变量的新值作为参数。
Only explicit assignments are traced. 
仅追踪显式的赋值。
Also see Object#untrace_var.
另见Object#untrace_var。

    trace_var :$dave, lambda {|v| puts "$dave is now '#{v}'" }
    $dave = "hello"
    $dave.sub!(/ello/, "i")
    $dave += " Dave"
    # produces:
    # $dave is now 'hello'
    # $dave is now 'hi Dave'

#### trap  捕获

    trap( signal, proc ) → obj
    trap( signal ) { … } → obj

See the Signal module on page 664.
参见后面2版604页4版664页的Signal模块。

#### untrace_var  去除追踪变量

    untrace_var( symbol ‹ , cmd › ) → array or nil

Removes tracing for the specified command on the given global variable and returns nil. 
删除全局变量上指定的追踪命令并返回nil。
If no command is specified, removes all tracing for that variable.
如果没提供命令参数，则删除该变量上的所有追踪命令。

#### using  使用模块 ⇡New in 2.0⇣

    using mod

Applies the refinements defined in the given module. 
应用定义在给定模块中的提炼。
The refinements apply to the current file (or string if eval is being used) from the point where using is called.
从我们调用using的点上，将提炼应用到当前文件（或如果使用了eval，则应用到字符串）。

    module SuperUpcase
      refine String do
        def upcase
          "!WOW! #{super} !WOW!"
        end
      end
    end
    "wombat".upcase # => "WOMBAT"
    using SuperUpcase
    "wombat".upcase # => "!WOW! WOMBAT !WOW!"

#### warn  警报

    warn ‹ msgs ›+

Writes the given message to STDERR (unless $VERBOSE is nil, perhaps because the -W0 commandline option was given). 
将给定信息输出到STDERR（除非$VERBOSE为nil，可能因为指定了-W0命令行选项）。
⇡New in 2.0⇣
If multiple messages are given, writes each on a new line.
如果指定了多个信息，每个信息占用一行。

    warn "Danger, Will Robinson!"
    # produces:
    # Danger, Will Robinson!


## Module ObjectSpace  对象空间模块
### 概述
The ObjectSpace module contains a number of routines that interact with the garbage collection facility and allow you to traverse all living objects with an iterator.
ObjectSpace模块包含了许多与垃圾回收设施相互作用的函数，它们允许使用迭代器来遍历所有活跃对象。
ObjectSpace also provides support for object finalizers. 
ObjectSpace页提供了对对象析构器的支持。
These are procs that will be called when a specific object is about to be destroyed by garbage collection.
当特定的对象即将被垃圾回收销毁时，相应的procs将会被调用。

    include ObjectSpace
    a, b, c = "A", "B", "C"
    puts "a's id is #{a.object_id}"
    puts "b's id is #{b.object_id}"
    puts "c's id is #{c.object_id}"
    define_finalizer(a, lambda {|id| puts "Finalizer one on #{id}" })
    define_finalizer(b, lambda {|id| puts "Finalizer two on #{id}" })
    define_finalizer(c, lambda {|id| puts "Finalizer three on #{id}" })
    # produces:
    # a's id is 70124883293000
    # b's id is 70124883292960
    # c's id is 70124883292880
    # Finalizer three on 70124883292880
    # Finalizer two on 70124883292960
    # Finalizer one on 70124883293000

### Class Methods 类方法
#### _id2ref  ID转为引用

    ObjectSpace._id2ref( object_id ) → obj

Converts an object ID to a reference to the object. 
把对象ID转换成对象的引用。
May not be called on an object ID passed as a parameter to a finalizer.
可能会对传入清理器的对象ID参数调用该方法。

    s = "I am a string"          # => "I am a string"
    oid = s.object_id            # => 70207029149080
    r = ObjectSpace._id2ref(oid) # => "I am a string"
    r                            # => "I am a string"
    r.equal?(s)                  # => true

#### count_objects  对象计数  1.9

    ObjectSpace.count_objects → histogram_hash

Returns a hash where the keys are the interpreter-specific internal object types and the values are the number of objects of each type.
返回一个散列表，键为解释器细化的内部对象类型，值为每个类型的对象的数量。

    ObjectSpace.count_objects # =>  {:TOTAL=>17493, :FREE=>60, :T_OBJECT=>49,
                              # ..  :T_CLASS=>471, :T_MODULE=>21, :T_FLOAT=>4,
                              # ..  :T_STRING=>7748, :T_REGEXP=>64, :T_ARRAY=>1464,
                              # ..  :T_HASH=>57, :T_BIGNUM=>3, :T_FILE=>17,
                              # ..  :T_DATA=>701, :T_MATCH=>20, :T_COMPLEX=>1,
                              # ..  :T_RATIONAL=>2, :T_NODE=>6790, :T_ICLASS=>21}

#### define_finalizer  定义析构器

    ObjectSpace.define_finalizer( obj, a_proc=proc() )

Adds `a_proc` as a finalizer, called when obj is about to be destroyed. 
把`a_proc`作为析构器添加，它在obj即将被销毁时会被调用。
Note that if you use lambda to create the proc object, you must remember to include a parameter with the block.
注意，如果你使用lambda来创建一个proc对象，你必须记得包含带block的参数。
If you don’t, the invocation of the lambda will silently fail when the finalizer is called because of a mismatch in the expected and actual parameter count.
如果没有，当析构器被调用时，因为在期待和实际参数计数时错配，lambda调用将会静静地失败。

#### each_object  遍历对象

    ObjectSpace.each_object( ‹ class_or_mod › ) { |obj| … }→ fixnum

Calls the block once for each living, nonimmediate object in this Ruby process. 
对ruby进程中每个活跃且非立即对象调用一次block。
If `class_or_mod` is specified, calls the block for only those classes or modules that match (or are a subclass of) `class_or_mod`. 
如果指定了`class_or_mod`，它只会对那些匹配`class_or_mod`或`class_or_mod`子类的类或者模块调用block。
Returns the number of objects found. 
返回找到的对象个数。
Immediate objects (Fixnums, Symbols true, false, and nil) are never returned. 
永远不会返回立即对象（定数，符号true false和nil）。
In the following example, each_object returns both the numbers we defined and several constants defined in the Math module:
在下面的例子中，each_object返回了我们定义的数字和定义在Math模块中的几个常量：

    a = 102.7
    b = 95
    # Fixnum: won't be returned  定数不会被返回
    c = 12345678987654321
    count = ObjectSpace.each_object(Numeric) {|x| p x }
    puts "Total count: #{count}"
    produces:
    # (0+1i)       这是定义在Math模块中的常量。
    # 9223372036854775807
    # 3
    # NaN
    # Infinity
    # 1.7976931348623157e+308
    # 2.2250738585072014e-308
    # 274193223623034780067407936393989039126
    # 12345678987654321      这是我们定义的数字。
    # Total count: 9

#### garbage_collect  垃圾回收

    ObjectSpace.garbage_collect → nil

Initiates garbage collection (see module GC on page 517).
启用垃圾回收（见前面2版491页4版517页的GC模块）。

#### undefine_finalizer  撤销析构器

    ObjectSpace.undefine_finalizer( obj )

Removes all finalizers for obj.
删除obj所有析构器。


## Proc  过程
### 概述
Proc objects are blocks of code that have been bound to a set of local variables. 
Proc对象是绑定到一组局部变量的代码块。
Once bound, the code may be called in different contexts and still access those variables.
一旦绑定，这些代码可能会在不同的上下文中被调用，同时它们仍然可以访问这些变量。

    def gen_times(factor)
      return Proc.new {|n| n*factor }
    end
    times3 = gen_times(3)
    times5 = gen_times(5)
    times3.call(12) # => 36
    times5.call(5) # => 25
    times3.call(times5.call(4)) # => 60

### Class Methods 类方法
#### new  新建

    Proc.new { … } → a_proc
    Proc.new → a_proc

Creates a new Proc object, bound to the current context. 
创建一个新的Proc对象，把它绑定到当前的上下文中。
Proc.new may be called without a block only within a method with an attached block, in which case that block is converted to the Proc object.
只有在附带block的方法中，才可以不带block调用Proc.new；在这种情况下，这个block会被转换成Proc对象。

    def proc_from
      Proc.new
    end
    proc = proc_from { "hello" }
    proc.call # => "hello"

### Instance Methods 实例方法 
#### []  调用

    prc[ ‹ params ›* ] → obj

Synonym for Proc#call.
同Pro#call。

#### ==  相同 ⇡New in 2.0⇣

Removed in Ruby 2.0.
在ruby 2.0中被移除。

#### ===  调用  1.9

    prc === other → obj

Equivalent to prc.call(other). 
Allows you to use procs in when clauses of case expressions, so you can write stuff such as:
同prc.call(other)。
允许你使用procs在case表达式的when子句中，因此你可以这样写：

    even = lambda {|num| num.even? }
    (0..3).each do |num|
      case num
      when even then puts "#{num} is even"
      else
        puts "#{num} is not even"
      end
    end
    # produces:
    # 0 is even
    # 1 is not even
    # 2 is even
    # 3 is not even
            
#### arity  参数个数  1.8

    prc.arity → integer

Returns the number of arguments required by the block. 
返回block所需的参数个数。
If the block is declared to take no arguments, returns 0. 
如果这个block声明为不带任何参数，返回0.
If the block is known to take exactly n arguments, returns n. 
如果确切知道block接受n个参数，返回n。
If the block has optional arguments, returns -(n+1), where n is the number of mandatory arguments.
如果block有可选参数，返回-(n+1)，n是强制参数的数目。
A proc with no argument declarations also returns -1, because it can accept (and ignore) an arbitrary number of parameters.
没有参数声明的proc也返回-1,因为它可以接受（并忽视）任意个数目的参数。

    Proc.new {}.arity           # => 0
    Proc.new {||}.arity         # => 0
    Proc.new {|a|}.arity        # => 1
    Proc.new {|a,b|}.arity      # => 2
    Proc.new {|a,b,c|}.arity    # => 3
    Proc.new {|*a|}.arity       # => -1
    Proc.new {|a,*b|}.arity     # => -2

In Ruby 1.9, arity is defined as the number of parameters that would not be ignored. 
在ruby1.9,arity被定义为无法被忽视的参数的个数。
In 1.8, Proc.new {}.arity returns -1, and in 1.9 it returns 0.
在1.8，Proc.new {}.arity 返回-1，而在1.9中返回0。

#### binding  绑定  1.8

    prc.binding → binding

Returns the binding associated with prc.
返回和prc关联的绑定。

    def some_method
      a = "wibble"
      lambda {}
    end
    prc = some_method
    eval "a", prc.binding # => "wibble"

#### call  调用

    prc.call( ‹ params ›* ) → obj

Invokes the block, setting the block’s parameters to the values in params using something close to method-calling semantics. 
调用这个block，使用某种接近于方法调用的语义把这个block的参数设置为params的值。
Returns the value of the last expression evaluated in the block.
返回block中最后一个被求解的表达式的值。

    a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}
    a_proc.call(9, 1, 2, 3) # => [9, 18, 27]
    a_proc[9, 1, 2, 3] # => [9, 18, 27]

If the block being called accepts a single parameter and you give call more than one parameter, only the first will be passed to the block. 
如果被调用的这个block只接受一个参数，而你给了调用更多的参数，那么只有第一个参数会被传入block。
This is a change from Ruby 1.8.
这个改变从ruby 1.8开始。

    a_proc = Proc.new {|a| puts a}
    a_proc.call(1,2,3)
    # produces:
    # 1

If you want a block to receive an arbitrary number of arguments, define it to accept `*args`.
如果你希望block接受任意数目的参数，则把它定义为接受`*arg`.

    a_proc = Proc.new {|*a| p a}
    a_proc.call(1,2,3)
    # produces:
    # [1, 2, 3]

Blocks created using Object#lambda check that they are called with exactly the right number of parameters.
使用Object#lambda创建的block会检查，它们调用时使用了完全一致的参数个数。

    p_proc = Proc.new {|a,b| puts "Sum is: #{a + b}" }
    p_proc.call(1,2,3)
    p_proc = lambda {|a,b| puts "Sum is: #{a + b}" }
    p_proc.call(1,2,3)
    # produces:
    # from prog.rb:4:in `call'
    # from prog.rb:4:in `<main>'
    # Sum is: 3
    # prog.rb:3:in `block in <main>': wrong number of arguments (3 for 2)
    # (ArgumentError)

#### curry  重梳参数  1.9

    prc.curry → curried_proc

If you have a proc that takes arguments, you normally have to supply all of those arguments if you want the proc to execute successfully. 
如果你有一个带参数的proc，你一般只能提供所有那些参数，如果你想proc成功执行。
However, it is also possible to consider an n argument proc to be the same as a single-argument proc that returns a new proc that has this first argument fixed and that takes n-1 arguments. 
不过，也可能将一个n参数的proc当作为一个单参数proc，这样会返回一个新的proc，第一个参数固定，并带有n-1个参数。
If you repeat this process recursively for each of these subprocs, you end up with a proc that will take from zero to n arguments.
如果你递归地为这些子进程的每个重复这个过程，你将以一个带有0个到n个参数的proc告终。
If you pass it all n, it simply executes the proc with those arguments. 
如果你传入所有的n个参数，它只带上那些参数执行proc。
If you pass it m arguments (where m < n), it returns a new proc that has those arguments prebaked in and that takes m-n arguments. 
如果你传入m个参数（m小于n），它返回一个新的proc，带着那些的预订参数和m-n个参数。
In this way, it is possible to partially apply arguments to a proc.
按这种方法，可以部分地应用参数到proc中。

    add_three_numbers = lambda {|a,b,c| a + b + c}
    add_10_to_two_numbers = add_three_numbers.curry[10]
    add_33_to_one_number = add_10_to_two_numbers[23]
    add_three_numbers[1,2,3] # => 6
    add_10_to_two_numbers[1,2] # => 13
    add_33_to_one_number[1] # => 34

#### lambda?  是否拉姆达演算  1.9

    prc.lambda? → true or false

Returns true if prc has lambda semantics (that is, if argument passing acts as it does with method calls). 
如果prc有拉姆达语义，就是如果参数传入的表现被当作带有方法调用，返回true。
See the discussion in Section 22.13, Blocks, Closures, and Proc Objects, on page 335.
详见前面335页22.13节“块、闭包和过程对象”的讨论。

#### parameters  参数数组  1.9

    prc.parameters → array

Returns a description of the method’s parameter list. 
返回一个方法参数列表的描述。
See Method#parameters for details.
详见Method#parameters。

    lambda {|a, b=1, *c, &d| }.parameters # => [[:req, :a], [:opt, :b], [:rest, :c],
                                          # .. [:block, :d]]

#### source_location  源位置  1.9

    prc.source_location → [ filename, lineno ] or nil

Returns the source filename and line number where prc was defined or nil if proc was not defined in Ruby source.
prc被定义时返回源文件和行号;或如果proc没有在ruby源文件中定义时，返回nil。

    variable = 123
    prc = lambda { "some proc" }
    prc.source_location # => ["prog.rb", 2]

#### to_proc  转换为proc  1.8

    prc.to_proc → prc

Part of the protocol for converting objects to Proc objects. 
将对象转换成Proc对象协议的一部分。
Instances of class Proc simply return themselves.
Proc类的实例只会返回自己。

#### to_s  转换为字符串

    prc.to_s → string

Returns a description of prc, including information on where it was defined.
返回prc的描述，包括在何处定义它的信息。

    def create_proc
      Proc.new
    end
    my_proc = create_proc { "hello" }
    my_proc.to_s # => "#<Proc:0x007fc7f4864318@prog.rb:5>"

#### yield  调用

    prc.yield( ‹ params ›* ) → obj

Synonym for Proc#call.
同Proc#call。


## Module Process  进程
### 概述
The Process module is a collection of methods used to manipulate processes. 
Process模块是一个用来操作进程的方法集合。
Programs that want to manipulate real and effective user and group IDs should also look at the Process::GID and Process::UID modules. 
希望操作真实和有效用户ID以及真实和有效进程组ID的程序，也应当看看Process::GID和Process::UID模块。
Much of the functionality here is duplicated in the Process::Sys module.
很多在这里介绍的功能都会在Process::Sys模块中重复介绍。

### Module Constants  模块常量

    PRIO_PGRP       Process group priority.
                    进程组优先级。
    PRIO_PROCESS    Process priority.
                    进程优先级。
    PRIO_USER       User priority.
                    用户优先级。
    WNOHANG         Does not block if no child has exited. 
                    如果没有子进程退出，不会阻塞。
                    Not available on all platforms.
                    不是在所有平台上都可用。
    WUNTRACED       Returns stopped children as well. 
                    返回被停止的子进程。
                    Not available on all platforms.
                    不是在所有平台上都可用。
    RLIM[IT]_xxx    Used by getrlimit and setrlimit.
                    被getrlimit（获得资源深度）和setrlimit（设置资源深度）使用。
                     
### Class Methods 类方法
#### abort  中断

  abort
  abort( msg )

Synonym for Object#abort.
同Object#abort。

#### daemon  守护进程  1.9

    Process.daemon( stay_in_dir = false, keep_stdio_open = false ) → 0 or -1

Puts the current process into the background (either by forking and calling Process.setsid or by using the daemon(3) call if available). 
将当前进程放入背景（可以通过分支和调用process.setsid，或如果可以使用daemon(3)调用。）
Sets the current working directory to / unless `stay_in_dir` is true. 
将当前工作目录设置为根目录，除非`stay_in_dir`为true。
Redirects standard input, output, and error to /dev/null unless `keep_stdio_open` is true. 
重定向标准输入、输出和错误输出到/dev/null，除非`keep_stdio_open`为真。
Not available on all platforms.
并非在所有平台上可用。

#### detach  拆清

    Process.detach( pid ) → thread

Some operating systems retain the status of terminated child processes until the parent collects that status (normally using some variant of wait()). 
一些操作系统会一直保留被终止子进程的状态，直到父进程收集这个状态（通常使用wait()的某些变种）为止。。
If the parent never collects this status, the child stays around as a zombie process. 
如果父进程永远不会收集它，子进程会作为一个僵尸进程一直存在。
Process.detach prevents this by setting up a separate Ruby thread whose sole job is to reap the status of the process pid when it terminates. 
Process.detach通过运行一个独立的ruby线程来防止这种情况，它唯一的任务就是当进程pid终止时，收集它的状态。
Use detach only when you do not intend to explicitly wait for the child to terminate. 
只有当你不打算明确等待子进程终止时，才使用detach。
detach checks the status only periodically (currently once each second).
detach只是定时检查状态（当前是每秒检查一次）。
In this first example, we don’t reap the first child process, so it appears as a zombie in the process status display.
在第一个例子中，没有收集第一个子进程的状态，所以它在进程状态中显示为一个僵尸进程。

    pid = fork { sleep 0.1 }
    sleep 1
    system("ps -o pid,state -p #{pid}")
    # produces:
    # dyld: DYLD_ environment variables being ignored because main executable (/bin/ps)
    # is setuid or setgid
    # PID STAT
    # 24002 Z+

In the next example, Process.detach is used to reap the child automatically—no child processes are left running.
在下面的例子中，使用process.detach来自动收集子进程--不会有子进程一直运行。

    pid = fork { sleep 0.1 }
    Process.detach(pid)
    sleep 1
    system("ps -o pid,state -p #{pid}")
    # produces:
    # dyld: DYLD_ environment variables being ignored because main executable (/bin/ps)
    # is setuid or setgid
    # PID STAT

#### egid  有效组ID

    Process.egid → int

Returns the effective group ID for this process.
返回进程的有效组ID。

    Process.egid # => 20

#### egid=  设置有效组ID

    Process.egid= int → int

Sets the effective group ID for this process.
设置进程的有效组ID。

#### euid  有效用户ID

    Process.euid → int

Returns the effective user ID for this process.
返回进程的有效用户ID。

    Process.euid # => 501

#### euid=  设置有效用户ID

    Process.euid= int

Sets the effective user ID for this process. 
设置进程的有效用户ID。
Not available on all platforms.
并非在所有平台都可用。

#### exec  执行

    Process.exec(‹ env, › command ‹ , args ›*, ‹ options › )

Synonym for Object#exec.
同Object#exec。

#### exit  退出进程

    Process.exit( int=0 )

Synonym for Object#exit.
同Object#exit。

#### exit!  立即退出进程

    Process.exit!( true | false | status=1 )

Synonym for Object#exit!. 
同Object#exit!。
No exit handlers are run. 
没有运行退出处理器。
0, 1, or status is returned to the underlying system as the exit status.
把0、1或者status作为退出状态返回给底层系统。

    Process.exit!(0)

#### fork  分叉

    Process.fork ‹ { … } › → int or nil

See Object#fork on page 617.
参见前2版522页4版617页的Object#fork。

#### getpgid  指定进程的进程组id

    Process.getpgid( int ) → int

Returns the process group ID for the given process ID. 
返回给定进程id的进程组ID。
Not available on all platforms.
不是在所有平台上都可用。

    Process.getpgid(Process.ppid()) # => 21366

#### getpgrp  当前进程的进程组ID

    Process.getpgrp → int

Returns the process group ID for this process. 
返回进程id的进程组ID。
Not available on all platforms.
不是在所有平台上都可用。

    Process.getpgid(0) # => 21366
    Process.getpgrp # => 21366

#### getpriority  进程优先级

    Process.getpriority( kind, int ) → int

Gets the scheduling priority for specified process, process group, or user. 
得到指定的进程、进程组或用户的调用优先级。
The kind parameter indicates the kind of entity to find: Process::PRIO_PGRP, Process::PRIO_USER, or Process::PRIO_PROCESS. 
kind指出要查找的实体类型：Process::PRIO_PGRP, Process::PRIO_USER或者Process::PRIO_PROCESS。
int is an ID indicating the particular process, process group, or user (an ID of 0 means current). 
int指出特定的进程ID、进程组ID或者用户ID（ID为0,指的是当前的进程、进程组或胡用）。
Lower priorities are more favorable for scheduling. 
较低优先级的进程会优先得到调度。
Not available on all platforms.
不是在所有平台上可用。

    Process.getpriority(Process::PRIO_USER, 0) # => 0
    Process.getpriority(Process::PRIO_PROCESS, 0) # => 0

#### getrlimit  资源限度  1.9

    Process.getrlimit( name ) → [ current, max ]

Returns the current and maximum resource limit for the named resource. 
返回给定资源的当前最大资源限度。
The name may be a symbol or a string from the following list. 
name可以是下面列出的一个符号或字符串。
It may also be an operating-specific integer constant. 
也可以是一个特定操作的整数常量。
The Process module defines constants corresponding to these integers: the constants are named `RLIMIT_` followed by one of the following: AS, CORE, CPU, DATA, FSIZE, MEMLOCK, NOFILE, NPROC, RSS, or STACK. 
Process模块定义了常量对应这些整数：常量被命名为`RLIMIT_`加下面：AS CORE CUP DATA FSIZE MEMLOCK NOFILE NPROC RSS STACK。
Consult your system’s getrlimit(2) man page for details. 
详情考虑你系统上getrlimit(2)的手册页。
The return array may contain actual values or one of the constants `RLIM_INFINITY`, `RLIM_SAVED_CUR`, or `RLIM_SAVED_MAX`. 
返回的数组可能包含实际值或常量`RLIM_INFINITY`, `RLIM_SAVED_CUR`或`RLIM_SAVED_MAX`之一。
Not available on all platforms. 
不是所有平台都可用。
See also Process.setrlimit.
另见Process.setrlimit。

    Process.getrlimit(:STACK) # => [8388608, 67104768]
    Process.getrlimit("STACK") # => [8388608, 67104768]
    Process.getrlimit(Process::RLIMIT_STACK) # => [8388608, 67104768]

#### getsid  会话id ⇡New in 2.0⇣

    Process.getsid → int

Returns the session id (if supported).
返回会话id（如果支持）。

#### gid  进程的组id

    Process.gid → int

Returns the group ID for this process.
返回进程的组ID.

      Process.gid # => 20

#### gid=  设置进程的组id

    Process.gid= int → int

Sets the group ID for this process.
设置进程的组ID。

#### groups  辅助组ID  1.8

    Process.groups → groups

Returns an array of integer supplementary group IDs. 
返回一个辅助组ID的整数数组。
Not available on all platforms. 
不是在所有平台上都可用。
See also Process.maxgroups.
另见Process.maxgroups。

    Process.groups # => [20, 405, 402, 401, 403, 12, 33, 61, 79, 80, 81, 98, 100,
                   # .. 204, 404]

#### groups=  设置辅助组ID  1.8

    Process.groups = array → groups

Sets the supplementary group IDs from the given array, which may contain either numbers or group names (as strings). 
用给定数组设置这个辅助组ID，该数组可能含有进程组名称（作为字符串）的个数。
Not available on all platforms. 
不是在所有平台上可用。
Available only to superusers.
只有超级用户才可以使用这个方法。
See also Process.maxgroups.
另见Process.maxgroups。

#### initgroups  初始组  1.8

    Process.initgroups( user, base_group ) → groups

Initializes the group access list using the operating system’s initgroups call. 
使用操作系统上的initgroups调用来初始化进程组访问列表。
Not available on all platforms. 
不是在所有平台上都可用。
May require superuser privilege.
可能需要超级用户特权。

    Process.initgroups("dave", 500)

#### kill  杀死进程

    Process.kill( signal, ‹ pid ›+ ) → int

Sends the given signal to the specified process ID(s) or to the current process if pid is zero.
发送给定信号到这个指定的进程ID，如果pid是0，则发送给当前进程。
signal may be an integer signal number or a string or symbol representing a POSIX signal name (either with or without a SIG prefix). 
signal可能是一个整数信号数字或者POSIX信号名（带或不带SIG前缀）。
If signal is negative (or starts with a - sign), kills process groups instead of processes. 
如果signal是负数（或以减号-开始），杀死进程组而不是进程。
Not all signals are available on all platforms.
不是所有信号在所有平台上都可用。

    pid = fork do
      Signal.trap(:USR1) { puts "Ouch!"; exit }
      # ... do some work ...
    end
    # ...
    Process.kill(:USR1, pid)
    Process.wait
    # produces:
    # Ouch!

#### maxgroups  最大辅助组个数  1.8

    Process.maxgroups → count

The Process module has a limit on the number of supplementary groups it supports in the calls Process.groups and Process.groups=. 
Process模块对于它在Process.groups和Process.groups=调用中支持的辅助组的个数有一个上限。
The maxgroups call returns that limit, and the maxgroups= call sets it.
maxgroups调用返回这个上限值（默认是32），而maxgroups= 调用设置它。

    Process.maxgroups # => 16

#### maxgroups=  设置最大辅助组个数  1.8

    Process.maxgroups= limit → count

Sets the maximum number of supplementary group IDs that can be processed by the groups and groups= methods. 
设置可以被groups和groups=方法处理的辅助组ID的最大值。
If a number larger than 4096 is given, 4096 will be used.
如果给定的上限大于4096,将使用4096.

#### pid  进程ID

    Process.pid → int

Returns the process ID of this process. 
返回这个进程的进程id。
Not available on all platforms.
不是在所有平台都可用。

    Process.pid # => 24032

#### ppid  父进程ID

    Process.ppid → int

Returns the process ID of the parent of this process. 
返回这个进程的父进程的进程ID。
Always returns 0 on Windows. 
在Windows上总是返回0.
Not available on all platforms.
不是在所有平台上都可用。

    puts "I am #{Process.pid}"
    # Process.fork { puts "Parent is #{Process.ppid}" }
    # produces:
    # I am 24034
    # Parent is 24034

#### setpgid  设置进程组ID

    Process.setpgid( pid, int ) → 0

Sets the process group ID of pid (0 indicates this process) to int. 
把pid进程的进程组ID设置为int参数。
Not available on all platforms.
不是在所有平台上都可用。

#### setpgrp  设置进程组ID

    Process.setpgrp → 0

Equivalent to setpgid(0,0). 
等同于setpgid(0,0)。
Not available on all platforms.
不是在所有平台上都可用。

#### setpriority  设置优先级

    Process.setpriority( kind, int, int_priority ) → 0

See Process#getpriority.
参见Process#getpriority。

    Process.setpriority(Process::PRIO_USER, 0, 19)     # =>  0
    Process.setpriority(Process::PRIO_PROCESS, 0, 19)  # =>  0
    Process.getpriority(Process::PRIO_USER, 0)         # =>  19
    Process.getpriority(Process::PRIO_PROCESS, 0)      # =>  19

<kinder:note> 不懂 ？？？
#### setrlimit  设置资源限度  1.9

    Process.setrlimit( name, soft_limit, hard_limit=soft_limit ) → nil

Sets the limit for the named resource. 
设置给定名字的资源的限度。
See Process.getrlimit for a description of resource naming.
参见Process.getrlimit关于资源命名的描述。
Your system’s setrlimit(2) man page will have a description of the limits. 
你的系统setrlimit(2)的手册页会有关于限度的描述。
Not available on all platforms.
并非在所有平台都可用。

#### setsid  设置组长

    Process.setsid → int

Establishes this process as a new session and process group leader, with no controlling tty.
把这个进程设置为新的会话和进程组组长，同时没有控制终端。
Returns the session ID. 
返回会话ID。
Not available on all platforms.
并非在所有平台都可用。

    Process.setsid # => 24039

#### spawn  派生  1.9

    Process.spawn(‹ env, › command ‹ , args ›*, ‹ options › ) → pid

Synonym for Object#spawn.
同Object#spawn。

#### times  时间  1.8

    Process.times → struct_tms

Returns a Tms structure (see Struct::Tms on page 697) that contains user and system CPU times for this process.
返回一个Tms构造（参见后面2版630页4版697页的Struct::Tms），它含有这个进程的用户时间和系统CPU时间。

    t = Process.times
    [ t.utime, t.stime ] # => [0.03, 0.01]

#### uid  用户id

    Process.uid → int

Returns the user ID of this process.
返回这个进程的用户id。

    Process.uid # => 501

#### uid=  设置用户id

    Process.uid= int → numeric

Sets the (integer) user ID for this process. 
设置这个进程的用户ID（整数）。
Not available on all platforms.
不是在所有平台上都可用。

#### wait  等待子进程退出

    Process.wait → int

Waits for any child process to exit and returns the process ID of that child. 
等待任何子进程退出并返回子进程的进程ID。
Also sets $? to the Process::Status object containing information on that process. 
同时将$?变量设置为含有子进程信息的Process::Status对象。
Raises a SystemError if there are no child processes. 
如果不存在子进程，则引发SystemError。
Not available on all platforms.
不是在所有平台上都可用。

    Process.fork { exit 99 } # => 24046
    Process.wait # => 24046
    $?.exitstatus # => 99

#### waitall  等待所有进程

    Process.waitall → [ [ pid1,status ], ... ]

Waits for all children, returning an array of pid/status pairs (where status is an object of class Process::Status).
等待所有子进程退出，返回一个pid/status对的数组（这里的status是Process::Status类的一个对象）。

    fork { sleep 0.2; exit 2 } #=> 24049                                           
    fork { sleep 0.1; exit 1 } #=> 24050
    fork { exit 0 }            #=> 24051
    Process.waitall            #=> [[24051, #<Process::Status: pid 24051 exit 0>],
                               #.. [24050, #<Process::Status: pid 24050 exit 1>],
                               #.. [24049, #<Process::Status: pid 24049 exit 2>]]

#### wait2  等待子进程退出2

    Process.wait2 → [ pid, status ]

Waits for any child process to exit and returns an array containing the process ID and the exit status (a Process::Status object) of that child. 
等待任何子进程退出，并返回一个数组，含有退出子进程的进程ID以及它的退出状态（一个Process::Status对象）。
Raises a SystemError if no child processes exist.
如果不存在子进程，引发SystemError。

    Process.fork { exit 99 } # => 24054
    pid, status = Process.wait2
    pid # => 24054
    status.exitstatus # => 99

#### waitpid  等待给定pid子进程退出

    Process.waitpid( pid, int=0 ) → pid

Waits for a child process to exit depending on the value of pid:
等待给定pid等待子进程退出。

    < -1  Any child whose progress group ID equals the absolute value of pid
          任何进程组ID等于pid绝对值的子进程。
    -1    Any child (equivalent to wait)
          任何子进程（同wait方法）
    0     Any child whose process group ID equals that of the current process
          任何进程组ID等于当前进程的进程组ID的子进程。
    >0    The child with the given PID
          给定pid的子进程。

int may be a logical or of the flag values Process::WNOHANG (do not block if no child available) or Process::WUNTRACED (return stopped children that haven’t been reported). 
int参数可能是标志Process::WNOHANG(如果没有已退出的子进程，不会阻塞)或者Process::WUNTRACED(返回未报告的已停止子进程)的逻辑或。
Not all flags are available on all platforms, but a flag value of zero will work on all platforms.
并非所有的标志值在所有的平台上都可用，但值为0的标志在所有平台上都可以工作。

    include Process
    pid = fork { sleep 2 }          #  =>  24057
    Time.now                        #  =>  2013-05-27 12:32:49 -0500
    waitpid(pid, Process::WNOHANG)  #  =>  nil
    Time.now                        #  =>  2013-05-27 12:32:49 -0500
    waitpid(pid, 0)                 #  =>  24057
    Time.now                        #  =>  2013-05-27 12:32:51 -0500

#### waitpid2  等待给定pid子进程退出2

    Process.waitpid2( pid, int=0 ) → [ pid, status ]

Waits for the given child process to exit, returning that child’s process ID and exit status (a Process::Status object). 
等待给定pid的子进程退出，返回这个子进程的进程ID以及退出状态（一个Process::Status对象）。
int may be a logical or of the values Process::WNOHANG (do not block if no child available) or Process::WUNTRACED (return stopped children that haven’t been reported).
int参数可能是标志Process::WNOHANG(如果没有已退出的子进程，不会阻塞)或者Process::WUNTRACED(返回未报告的已停止子进程)的逻辑或。
Not all flags are available on all platforms, but a flag value of zero will work on all platforms.
并非所有的标志值在所有的平台上都可用，但值为0的标志在所有平台上都可以工作。


## Module Process::GID  进程组ID模块  1.8
###概述
Provides a higher-level (and more portable) interface to the underlying operating system’s concepts of real, effective, and saved group IDs. 
对底层操作系统真实的、有效的和保存的[8]组ID概念，提供了更高级的（同时更易移植的）接口。
[8]2版译注：指的是当exec执行一个设置了用户或组ID的程序文件之后，有效用户或组ID将被设置为程序文件的所有者或组ID，而之前的有效用户或组ID则被保存起来。
Discussing the semantics of these IDs is well beyond the scope of this book; readers who want to know more should consult POSIX documentation or read the intro(2) man pages on a recent Unix platform. 
讨论这些ID的语义远远超出了本书的范围：对此感兴趣的读者应该参考POSIX文档或阅读最近任何Unix平台上的intro(2)手册页。
All these methods throw NotImplementedError if the host operating does not support a sufficient set of calls. 
如果宿主操作系统没有支持一个足够的调用集合，所有那些方法会抛出NotImplementedError。
The descriptions that follow are based on notes in ruby-talk:76218 by Hidetoshi Nagai.
接下来的描述是基于Hidetoshi Nagai在ruby-talk:76218中给出的注解。

### Class Methods 类方法
#### change_privilege  改变权限  1.8

    Process::GID.change_privilege( gid ) → gid

Sets the real, effective, and saved group IDs to gid, raising an exception on failure (in which case the state of the IDs is not known). 
将真实的、有效的和保存的组ID设置为gid，如果失败则抛出一个异常。（在这种情况下，步确定这些ID的状态。）
This method is not compatible with Process.gid=.
这个方法与Process.gid=方法不兼容。

#### eid  有效组ID  18

    Process::GID.eid → egid

Returns the effective group ID for this process. 
返回这个进程的有效组ID。
Synonym for Process.egid.
等同于Process.egid。

#### eid=  设置有效组ID  1.8

    Process::GID.eid = egid

Synonym for Process::GID.grant_privilege.
同Process::GID.grant_privilege。

#### grant_privilege  设置有效组ID  1.8

    Process::GID.grant_privilege( egid ) → egid

Sets the effective group ID to egid, raising an exception on failure. 
将有效的组ID设置为egid，如果失败抛出一个异常。
On some environments this may also change the saved group ID (see re_exchangeable?).
在某种环境下，这可能也会改变保存的组ID（参见re_exchangeable?）

#### re_exchange  交换组ID  1.8

    Process::GID.re_exchange → egid

Exchanges the real and effective group IDs, setting the saved group ID to the new effective group ID. 
互换实际的和有效的组ID，同时把保存的组ID设置为新的有效组ID。
Returns the new effective group ID.
返回新的有效组ID。

#### re_exchangeable?  可否交换组ID  1.8

    Process::GID.re_exchangeable → true or false

Returns true if real and effective group IDs can be exchanged on the host operating system and returns false otherwise.
如果在宿主操作系统上实际的和有效的组ID可以互换，则返回true；否则返回false。

#### rid  实际组ID  1.8

    Process::GID.rid → gid

Returns the real group ID for this process. 
返回这个进程的实际组ID。
Synonym for Process.gid.
同Process.gid。

#### sid_available?  可否保存组ID  1.8

    Process::GID.sid_available? → true or false

Returns true if the underlying platform supports saved group IDs and returns false otherwise.
如果底层平台支持保存的组ID，则返回true；否则返回false。
Currently, Ruby assumes support if the operating system has setresgid(2) or setegid(2) calls or if the configuration includes the POSIX_SAVED_IDS flag.
当前如果操作系统有setresgid(2)或者setegid(2)调用，或者配置了包括POSIX_SAVED_IDS标志，ruby会假定底层操作系统支持保存的组ID。

#### switch  特权转换  1.8

    Process::GID.switch → egid
    Process::GID.switch { … } → obj

Handles the toggling of group privilege. 
处理组特权的转换。
In the block form, automatically toggles the IDs back when the block terminates (but only if the block doesn’t use other calls into Process::GID calls, which would interfere). 
在带有block的形式中，原来的这些ID在block终止时会自动转换回去（但前提是block没有调用那些可能会干扰的Process::GID方法）。
Without a block, returns the original effective group ID.
不带block的形式返回初始的有效组ID。


## Process::Status  进程状态
### 概述
Process::Status encapsulates the information on the status of a running or terminated system process. 
Process::Status封装了一个正在运行或已终止的系统进程的状态信息。
The built-in variable $? is either nil or a Process::Status object.
内建的$?变量为nil或者一个Process::Status对象。

    fork { exit 99 } # => 24060
    Process.wait # => 24060
    $?.class # => Process::Status
    $?.to_i # => 25344
    $? >> 8 # => 99
    $?.stopped?  # => false
    $?.exited?  # => true
    $?.exitstatus # => 99

POSIX systems record information on processes using a 16-bit integer. 
POSIX系统使用一个16位的整数记录进程信息。
The lower bits record the process status (stopped, exited, signaled), and the upper bits possibly contain additional information (for example, the program’s return code in the case of exited processes). 
较低位记录了进程状态（已停止、退出或被信号中断），高位可能包含附加信息（比如，在进程已退出的情况下，程序的返回码）。
Before Ruby 1.8, these bits were exposed directly to the Ruby program. 
ruby 1.8之前，ruby程序可以直接访问这些位。
Ruby now encapsulates these in a Process::Status object. 
ruby把它们封装到一个Process::Status对象中。
To maximize compatibility, however, these objects retain a bit-oriented interface. 
当然，为了最大可能地与已有ruby程序兼容，这些对象保留了面向位的处理接口。
In the descriptions that follow, when we talk about the integer value of stat, we’re referring to this 16-bit value.
在接下来的描述中，当谈到stat的整数值时，我们指的是这个16位的整数值。

### Instance Methods 实例方法
#### ==  是否相等

    stat == other → true or false

Returns true if the integer value of stat equals other.
如果stat的整数值与other相等，返回true。

#### &  逻辑与

    stat & num → fixnum

Logical AND of the bits in stat with num.
stat中的位和num的逻辑与。

    fork { exit 0x37 }
    Process.wait
    sprintf('%04x', $?.to_i) # => "3700"
    sprintf('%04x', $? & 0x1e00) # => "1600"

#### >>  右位移

    stat >> num → fixnum

Shifts the bits in stat right num places.
把stat中的位右移num位。

    fork { exit 99 } # => 24066
    Process.wait # => 24066
    $?.to_i # => 25344
    $? >> 8 # => 99

#### coredump?  是否核心转储

    stat.coredump → true or false

Returns true if stat generated a core dump when it terminated. 
stat终止时，如果产生了核心转储，则返回true。
Not available on all platforms.
不是在所有平台上都可用。

#### exited?  是否退出

    stat.exited? → true or false

Returns true if stat exited normally (for example using an exit call or finishing the program).
如果stat正常退出，返回true（比如，使用exit调用或者结束程序）。

#### exitstatus  退出状态

    stat.exitstatus → fixnum or nil

Returns the least significant 8 bits of the return code of stat. 
返回stat返回码的低8位。
Available only if exited? is true.
只有当exit?为true时可用。 

    fork { }           # => 24069
    Process.wait       # => 24069
    $?.exited?         # => true
    $?.exitstatus      # => 0
    
    fork { exit 99 } # => 24070
    Process.wait # => 24070
    $?.exited?  # => true
    $?.exitstatus # => 99

#### pid  进程ID

    stat.pid → fixnum

Returns the ID of the process associated with this status object.
返回与这个status对象相关联的进程的ID。

    fork { exit } # => 24073
    Process.wait # => 24073
    $?.pid # => 24073

#### signaled?  是否信号终止

    stat.signaled? → true or false

Returns true if stat terminated because of an uncaught signal.
如果stat因为未捕获信号而终止，返回true。

    pid = fork { sleep 100 }
    Process.kill(9, pid) # => 1
    Process.wait         # => 24076
    $?.signaled?         # => true

#### stopped?  进程是否停止

    stat.stopped? → true or false

Returns true if this process is stopped. 
如果这个进程已经停止，返回true。
This is returned only if the corresponding wait call had the WUNTRACED flag set.
只有当相应的wait调用设置了WUNTRACED标志时，它才会返回。

#### success?  是否成功退出

    stat.success? → nil, or true or false

Returns true if stat refers to a process that exited successfully, returns false if it exited with a failure, and returns nil if stat does not refer to a process that has exited.
如果stat指的是一个已经成功退出的进程，返回true；如果指的是退出时失败的进程，返回返回false；如果指的是还没有退出的进程，返回nil。

#### stopsig  致停的信号个数

    stat.stopsig → fixnum or nil

Returns the number of the signal that caused stat to stop (or nil if self{} is not stopped).
返回导致stat停止的信号个数（若其本身为停止，返回nil）。

#### termsig  致终的信号个数

    stat.termsig → fixnum or nil

Returns the number of the signal that caused stat to terminate (or nil if self{} was not terminated by an uncaught signal).
返回导致stat终止的信号个数（若本身不是因为未捕捉的信号终止的，返回nil）。

#### to_i  转换为定数

    stat.to_i → fixnum

Returns the bits in stat as a Fixnum. 
把stat中的这些位返回一个定数。
Poking around in these bits is platform dependent.
查看这些位是与平台相关的。

    fork { exit 0xab } # => 24079
    Process.wait # => 24079
    sprintf('%04x', $?.to_i) # => "ab00"

#### to_s  转换为字符串

    stat.to_s → string

Equivalent to stat.to_i.to_s.
等同与stat.to_i.to_i。


## Module Process::Sys  进程系统模块  1.8
### 概述
Process::Sys provides system call–level access to the process user and group environment.
Process::Sys为进程用户和进程组环境劲提供了系统调用级别的访问。
Many of the calls are aliases of those in the Process module and are packaged here for completeness. 
很多调用是Process模块中的那些方法的别名，它们被打包在这个模块来提供一个完全的方法列表。
See also Process::GID and Process::UID for a higher-level (and more portable) interface. 
对于更高级别（同时更易移植的）接口，同时参见Process::GID和Process::UID。
 
### Class Methods 类方法
#### getegid  有效组ID

    Process::Sys.getegid → gid

Returns the effective group ID for this process. 
返回这个进程的有效组ID。
Synonym for Process.egid.
等同于Process.egid。

#### geteuid  有效用户ID

    Process::Sys.getugid → uid

Returns the effective user ID for this process. 
返回这个进程的有效用户ID。
Synonym for Process.euid.
等同于Process.euid。

#### getgid  组ID

    Process::Sys.getgid → gid

Returns the group ID for this process. 
返回这个进程的组ID。
Synonym for Process.gid.
同Process.gid。

#### getuid  用户ID

    Process::Sys.getuid → uid

Returns the user ID for this process. 
返回这个进程的用户ID。
Synonym for Process.uid.
同Process.uid。

#### issetugid  是否用户和组id调用

    Process::Sys.issetugid → true or false

Returns true if this process was made setuid or setgid as a result of the last execve() system call and returns false if not. 
如果这个进程因为最后一个execve()系统调用而导致setuid或者setgid被调用，则返回true：如果没有，返回false。
Raises NotImplementedError on systems that don’t support issetugid(2).
在不支持issetugid(2)的系统上，抛出NotImplementedError。

#### setegid  设置有效组ID

    Process::Sys.setegid( gid )

Sets the effective group ID to gid, failing if the underlying system call fails. 
设置有效组ID为gid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support setegid(2).
在不支持setegid(2)的系统上，抛出NotImplementedError。

#### seteuid  设置有效用户ID

    Process::Sys.seteuid( uid )

Sets the effective user ID to uid, failing if the underlying system call fails. 
设置有效用户ID为uid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support seteuid(2).
在不支持seteuid(2)的系统上，抛出NotImplementedError。

#### setgid  设置组ID

    Process::Sys.setgid( gid )

Sets the group ID to gid, failing if the underlying system call fails. 
设置组ID为gid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support setgid(2).
在不支持setgid(2)的系统上，抛出NotImplementedError。

#### setregid  设置真实有效组ID

    Process::Sys.setregid( rgid, egid )

Sets the real and effective group IDs to rgid and egid, failing if the underlying system call fails. 
设置真实和有效组ID为rgid和egid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support setregid(2).
在不支持setregid(2)的系统上，抛出NotImplementedError。

#### setresgid  设置真实有效保存的组ID

    Process::Sys.setresgid( rgid, egid, sgid )

Sets the real, effective, and saved group IDs to rgid, egid, and sgid, failing if the underlying system call fails. 
设置真实、有效和保存的组ID为rgid、egid和sgid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support setresgid(2).
在不支持setresgid(2)的系统上，抛出NotImplementedError。

#### setresuid  设置真实有效保存的用户ID

    Process::Sys.setresuid( ruid, euid, suid )

Sets the real, effective, and saved user IDs to ruid, euid, and suid, failing if the underlying system call fails. 
设置真实有效和保存的用户ID为ruid、euid和suid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support setresuid(2).
在不支持setresuid(2)的系统上，抛出NotImplementedError。

#### setreuid  设置真实有效的用户ID

    Process::Sys.setreuid( ruid, euid )

Sets the real and effective user IDs to ruid and euid, failing if the underlying system call fails.
设置真实和有效用户ID为ruid和euid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support setreuid(2).
在不支持setreuid(2)的系统上，抛出NotImplementedError。

#### setrgid  设置真实组ID

    Process::Sys.setrgid( rgid )

Sets the real group ID to rgid, failing if the underlying system call fails. 
设置真实组ID为rgid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support setrgid(2).
在不支持setrgid(2)的系统上，抛出NotImplementedError。

#### setruid  设置真实用户ID

    Process::Sys.setruid( ruid )

Sets the real user ID to ruid, failing if the underlying system call fails. 
设置真实用户ID为ruid，如果底层的系统调用失败，则该设置会失败。
Raises NotImplementedError on systems that don’t support setruid(2).
在不支持setruid(2)的系统上，抛出NotImplementedError。

#### setuid  设置用户ID

    Process::Sys.setuid( uid )

Sets the user ID to uid, failing if the underlying system call fails. 
Raises NotImplementedError on systems that don’t support setuid(2).
设置用户ID为uid，如果底层的系统调用失败，则该设置会失败。
在不支持setuid(2)的系统上，抛出NotImplementedError。


## Module Process::UID  进程用户ID模块  1.8
### 概述
Provides a higher-level (and more portable) interface to the underlying operating system’s concepts of real, effective, and saved user IDs. 
对底层操作系统真实的、有效的和保存的用户ID概念，提供了更高级的（同时更易移植的）接口。
For more information, see the introduction to Process::GID on page 648.
更多的信息，详见前面2版589页4版648页的Process::GID。

### Class Methods 类方法
#### change_privilege  改变权限

    Process::UID.change_privilege( uid ) → uid

Sets the real, effective, and saved user IDs to uid, raising an exception on failure (in which case the state of the IDs is not known). 
将真实的、有效的和保存的用户ID设置为uid，如果失败则抛出一个异常。（在这种情况下，步确定这些ID的状态。）
Not compatible with Process.uid=.
它与Process.uid=不兼容。

#### eid  有效用户id

    Process::UID.eid → euid

Returns the effective user ID for this process. 
返回这个进程的有效用户ID。
Synonym for Process.euid.
等同于Process.egid。

#### eid=  设置有效用户id

    Process::UID.eid = euid

Synonym for Process::UID.grant_privilege.
同Process::UID.grant_privilege。

#### grant_privilege  设置有效用户id

    Process::UID.grant_privilege( euid ) → euid

Sets the effective user ID to euid, raising an exception on failure. 
将有效的用户ID设置为egid，如果失败抛出一个异常。
On some environments this may also change the saved user ID.
在某种环境下，这可能也会改变保存的用户ID（参见re_exchangeable?）

#### re_exchange  交换用户ID

    Process::UID.re_exchange → euid

Exchanges the real and effective user IDs, setting the saved user ID to the new effective user ID. 
互换实际的和有效的用户ID，同时把保存的组ID设置为新的有效用户ID。
Returns the new effective user ID.
返回新的有效用户ID。

#### re_exchangeable?  可否交换用户ID

    Process::UID.re_exchangeable → true or false

Returns true if real and effective user IDs can be exchanged on the host operating system and returns false otherwise.
如果在宿主操作系统上实际的和有效的用户ID可以互换，则返回true；否则返回false。

#### rid  实际用户ID 

    Process::UID.rid → uid

Returns the real user ID for this process. 
返回这个进程的实际组ID。
Synonym for Process.uid.
同Process.uid。

#### sid_available?  可否保存用户ID

    Process::UID.sid_available? → true or false

Returns true if the underlying platform supports saved user IDs and returns false otherwise.
如果底层平台支持保存的用户ID，则返回true；否则返回false。
Currently, Ruby assumes support if the operating system has setresuid(2) or seteuid(2) calls or if the configuration includes the POSIX_SAVED_IDS flag.
当前如果操作系统有setresuid(2)或者seteuid(2)调用，或者配置了包括POSIX_SAVED_IDS标志，ruby会假定底层操作系统支持保存的用户ID。

#### switch  特权转换

    Process::UID.switch → euid
    Process::UID.switch { … } → obj

Handles the toggling of user privilege. 
处理用户特权的转换。
In the block form, automatically toggles the IDs back when the block terminates (as long as the block doesn’t use other Process::UID calls to interfere). 
在带有block的形式中，原来的这些ID在block终止时会自动转换回去（但前提是block没有调用那些可能会干扰的Process::UID方法）。
Without a block, returns the original effective user ID.
不带block的形式返回初始的有效用户ID。


## Range  区间
### 概述
A Range represents an interval—a set of values with a start and an end. 
一个区间表示一个间隔--带有开头和结尾的一组值。
Ranges may be constructed using the s..e and s...e literals or using Range.new. 
区间是使用s..e和s...e字面两或者Range.new来构造的。
Ranges constructed using ..  run from the start to the end inclusively. 
使用..构造的区间把从开头到结尾的所有值都包括了。
Those created using ...  exclude the end value. 
使用...创建的区间把结尾值排除在外。
When used as an iterator, ranges return each value in the sequence.
当区间用作一个迭代器时，它会返回这个序列的每个值。

    (-1..-5).to_a     # => []
    (-5..-1).to_a     # => [-5, -4, -3, -2, -1]
    ('a'..'e').to_a   # => ["a", "b", "c", "d", "e"]
    ('a'...'e').to_a  # => ["a", "b", "c", "d"]

Ranges can be constructed using objects of any type, as long as the objects can be compared using their <=> operator and they support the succ method to return the next object in sequence.
可以用任何类型的对象来构造区间，只要这些对象可以使用它们的<=>操作符来进行比较，同时它们支持succ方法，返回序列中的下一个对象。

    class Xs
      # represent a string of 'x's
      include Comparable
      attr :length
      def initialize(n)
        @length = n
      end
      def succ
        Xs.new(@length + 1)
      end
      def <=>(other)
        @length <=> other.length
      end
      def inspect
        'x' * @length
      end
    end
    r = Xs.new(3)..Xs.new(6) # => xxx..xxxxxx
    r.to_a # => [xxx, xxxx, xxxxx, xxxxxx]
    r.member?(Xs.new(5)) # => true

In the previous code example, class Xs includes the Comparable module. 
在前面的代码例子中，Xs类包含了Comparable模块。
This is because Enumerable#member? checks for equality using ==. 
这是因为Enumerable#member?使用==方法来检查相等。
Including Comparable ensures that the == method is defined in terms of the <=> method implemented in Xs.
包含Comparable确保了会根据Xs中<=>方法来定义==方法。

### Mixes In  混入
Enumerable: 
all?, any?, 
chunk, collect, collect_concat, count, cycle, 
detect, drop, drop_while, 
each_ cons, each_entry, each_slice, each_with_index, each_with_object, entries, 
find, find_all, find_index, first, flat_map, 
grep, group_by, 
include?, inject, 
lazy, 
map, max, max_by, member?, min, min_by, minmax, minmax_by, 
none?, one?, 
partition, 
reduce, reject, reverse_each, 
select, slice_before, sort, sort_by, 
take, take_while, to_a, 
zip

### Class Methods 类方法
#### new  新建

    Range.new( start, end, exclusive=false ) → rng

Constructs a range using the given start and end. 
使用给定的start和end来构造区间。
If the third parameter is omitted or is false, the range will include the end object; otherwise, it will be excluded.
如果省略了第三个参数或者它是false，这个区间会包括这个end对象；否则，end会被排除在外。

### Instance Methods 实例方法
#### ==  是否相同

    rng == obj → true or false

Returns true if obj is a range whose beginning and end are the same as those in rng (compared using ==) and whose exclusive flag is the same as rng.
如果obj区间的开头和结尾分别和rng的开头和结尾相同（使用==方法进行比较），同时它的exclusive标志和rng的相同，返回true。

#### ===  是否包含  1.8

    rng === val → true or false

If rng excludes its end, returns rng.start ≤ val < rng.end. 
如果rng把它的结尾值排除在外，返回rng.start ≤ val < rng.end。
If rng is inclusive, returns rng.start ≤ val ≤ rng.end. 
如果rng包含了结尾值，返回rng.start ≤ val ≤ rng.end。
Note that this implies that val need not be a member of the range itself (for example, a float could fall between the start and end values of a range of integers). 
注意：这意味着val不需要是rng区间的成员之一（比如，一个浮点数可以落在一个整数区间的开头和结尾值之间）。
Implemented by calling include?. 
它通过调用include?来完成。
Conveniently, the === operator is used by case statements.
===操作符可以方便地使用在case语句中。

    case 74.95
    when 1...50 then     puts "low"
    when 50...75 then    puts "medium"
    when 75...100 then   puts "high"
    end
    # produces:
    # medium

#### begin  开头

    rng.begin → obj

Returns the first object of rng.
返回rng的第一个对象。

#### bsearch  二分搜索 ⇡New in 2.0⇣

    rng.bsearch { |val| … } → obj or nil>

The same basic functionality as Array#bsearch. 
基本功能和Array#bsearch相同。
However, the range variant is typically used to search for something outside the range itself. 
不过，区间变量典型地用在搜索一些在区间之外的东西。
For example, the range values could be used as a parameter to a function, or to index into some other collection. 
比如，区间值可用做一个传给函数的参数，或索引某些其他的收集。
Remember though that the value returned by that function or collection must increase as its parameter increases.
记住，函数或收集返回的值必须随着它的参数增加而增加。

Here’s a (poor) method that finds the number of binary digits required to represent a number:
这是一个简单的方法，找出要求代表某个数字的二进制数字的数目。

    def bit_size(n)
      (0...(8*n.size)).bsearch { |bitno| (1 << bitno) > n }
    end
    [ 0x05, 0x50, 0x5a010000 ].each do |n|
      printf "Bitsize of %b is %d\n", n, bit_size(n)
    end
    # produces:
    # Bitsize of 101 is 3
    # Bitsize of 1010000 is 7
    # Bitsize of 1011010000000010000000000000000 is 31

And here’s a somewhat surprising example that finds x for which sin(x) equals 0.5.
这是一个有些令人吃惊的例子，找出中sin(x)等于0.5的x。

    (0.0..Math::PI/2).bsearch {|x| Math.sin(x) >= 0.5} # => 0.5235987755982989

On my box, it has the answer correct to 1% within 14 iterations, and takes 62 iterations to find it to the limit of Float precision.
在我的box中，它在14次迭代中把答案改为1%，并花了62次迭代在浮点精度的范围找出。

#### cover?  是否包含  1.9

    rng.cover?( obj ) → true or false

Returns true if obj lies between the start and end of the range. 
如果obj在区间的开头和结尾之间，返回true。
For ranges defined with min..max, this means min ≤ obj ≤ max. 
对于用min..max定义的区间，该方法意味着min ≤ obj ≤ max。
For ranges defined with min...max, it means min ≤ obj < max.
对于用min...max定义的区间，该方法意味着min ≤ obj < max。

    (1..10).cover?(0)   # => false
    (1..10).cover?(5)   # => true
    (1..10).cover?(9.5) # => true
    (1..10).cover?(10)  # => true
    (1...10).cover?(10) # => false

#### each  遍历

    rng.each { |i| … } → rng

Iterates over the elements rng, passing each in turn to the block. 
在元素rng上迭代，把每个元素依次传入到block。
Successive elements are generated using the succ method.
使用succ方法来产生连续元素。

    (10..15).each do |n|
      print n, ' '
    end
    # produces:
    # 10 11 12 13 14 15

#### end  结尾

    rng.end → obj

Returns the object that defines the end of rng.
返回定义rng结尾的对象。

    (1..10).end # => 10
    (1...10).end # => 10

#### eql?  是否相等

    rng.eql?(obj) → true or false

Returns true if obj is a range whose beginning and end are the same as those in rng (compared using eql?) and whose exclusive flag is the same as rng.
如果obj区间的开头和结尾分别和rng的开头和结尾相同（使用eql?方法进行比较），同时它的exclusive标志和rng的相同，返回true。

#### exclude_end?  是否排除尾部

    rng.exclude_end? → true or false

Returns true if rng excludes its end value.
如果rng把它的结尾值排除在外，返回true。

#### first  开头n个元素

    rng.first( n = 1 ) → obj or array

Returns the first (or first n) elements of rng.
返回rng的第一（或前n）个元素。

    ('aa'..'bb').first # => "aa"
    ('aa'..'bb').first(5) # => ["aa", "ab", "ac", "ad", "ae"]

#### include?  是否包含

    rng.include?( val ) → true or false

Returns true if val is one of the values in rng (that is, if Range#each would return val at some point). 
如果val是rng里的值（就是，如果Range#each返回值中有val），返回true。
If the range is defined to span numbers, this method returns true if the value lies between the start and end of the range, even if it is not actually a member (that is, it has the same behavior as Range#cover?). 
如果区间被定义为跨度数字，则如果值在开头和结尾之间的区间内，返回true，即使它实际上不是该区间的成员（就是，和Range#cover?一样的表现）。
Otherwise, the parameter must be a member of the range.
否则，参数必须是区间的成员。

    r = 1..10
    r.include?(5)      # => true  
    r.include?(5.5)    # => true
    r.include?(10)     # => true
    r = 1...10         
    r.include?(10)     # => false
    r = 'a'..'z'       
    r.include?('b')    # => true
    r.include?('ruby') # => false

#### last  结尾n个元素

    rng.last( n = 1 ) → obj or array

Returns the last (or last n) elements of rng.
返回rng的最后（或最后n）个元素。

    ('aa'..'bb').last # => "bb"
    ('aa'..'bb').last(5) # => ["ax", "ay", "az", "ba", "bb"]

#### max  最大值  1.9

    rng.max → obj
    rng.max { |a,b| … } → obj

Returns the maximum value in the range. 
返回区间里的最大值。
The block is used to compare values if present.
如果有block，block用于比较值。

    (-3..2).max # => 2
    (-3..2).max {|a,b| a*a <=> b*b } # => -3

#### member?  是否成员

    rng.member?( val ) → true or false

Synonym for Range#include?.
等同于Rang#include?

#### min  最小值  1.9

    rng.min → obj
    rng.min { |a,b| … } → obj

Returns the minimum value in the range. 
返回区间里的最小值。
The block is used to compare values if present.
如果有block，它用于比较值。

    (-3..2).min # => -3
    (-3..2).min {|a,b| a*a <=> b*b } # => 0

#### size  大小 ⇡New in 2.0⇣

    rng.size → int or nil

Returns the number of elements in rng. 
返回rng里元素的数目。
In Ruby 2.0, only works for ranges of integers.
在 Ruby 2.0, 只用于整数的区间。

    (1..26).size # => 26
    ('a'..'z').size # => nil

#### step  步长  1.8

    rng.step( n=1 ) ‹ { |obj| … } › → rng or enum

Iterates over rng, passing each n·th element to the block. 
在rng区间上迭代，把它的每n个元素传递给block。
If the range contains numbers, addition by one is used to generate successive elements. 
如果这个区间包含数字，每次加 1来产生连续元素。
Otherwise, step invokes succ to iterate through range elements. 
否则，step调用succ方法对这个区间中的元素进行迭代。
If no block is given, an enumerator is returned. 
如果没有指定block，返回一个枚举。
The following code uses class Xs defined at the start of this section:
下面的代码使用定义在本节开始处的Xs类。

    range = Xs.new(1)..Xs.new(10)
    range.step(2) {|x| p x}
    enum = range.step(3)
    p enum.to_a
    # produces:
    # x
    # xxx
    # xxxxx
    # xxxxxxx
    # xxxxxxxxx
    # [x, xxxx, xxxxxxx, xxxxxxxxxx]

Here’s step with numbers:
下面是数字步长:

    (1..5).step(1).to_a         # => [1, 2, 3, 4, 5]
    (1..5).step(2).to_a         # => [1, 3, 5]
    (1..5).step(1.5).to_a       # => [1.0, 2.5, 4.0]
    (1.0..5.0).step(1).to_a     # => [1.0, 2.0, 3.0, 4.0, 5.0]
    (1.0..5.0).step(2).to_a     # => [1.0, 3.0, 5.0]
    (1.0..5.0).step(1.5).to_a   # => [1.0, 2.5, 4.0]


## Random  随机数  1.9
### 概述
A random number generator, based on the Mersenne Twister MT19937 (the period is `2**19937-1`).
一种随机器产生器，基于梅森旋转算法中的MT19937（周期为`2**19937-1`）
The global rand and srand methods are wrappers for this class.
全局的rand和srand方法被封装在这个类中。

### Class Methods 类方法
#### new  新建

    Random.new( ‹ seed=Random.new_seed › ) → rand

Creates a new random random number generator with the given seed. 
用给定的种子创建一个随机的随机数生成器。
The seed will be converted to an integer.
种子将被转为一个整数。

#### new_seed  新种

    Random.new_seed → bignum

Returns a number that can be used as a seed. 
返回一个可用做种子的数。
The value is derived from a system random number generator if available; otherwise, it combines the time, the process ID, and a sequence number.
如果可用，该值从一个系统随机数生成器派生而来；否则，它将时间、进程ID和一个连续值合并在一起。

    Random.new_seed # => 205460400778463129775182461758071944669

#### rand  随机数

    Random.rand( max=0 ) → number
    Random.rand( range ) → number

Synonym for Object#rand on page 622.
同前面622页的Object#rand。

#### srand  随机数种子

    Random.rand( seed ) → old_seed

Synonym for Object#srand on page 628.
同前面628页的Object#srand。


### Instance Methods 实例方法
#### bytes  字节

    rand.bytes( length ) → string

Returns a binary-encoded string, length bytes long, containing random bits.
返回一个二进制码字符串，leng字节长，包含随机位。

    rand = Random.new
    rand.bytes(10) # => "T\xAEP\xD5\0\xAD\x7F\x84b\xC9"

#### rand  随机数

    rand.rand( max=0 ) → number
    rand.rand( range ) → number

Converts max to an integer using max1 = max.to_i.abs. 
使用`max1 = max.to_i.abs`将max转化为一个整数。
If the result is zero or nil, returns a pseudorandom floating-point number greater than or equal to 0.0 and less than 1.0. 
如果结果是0或nil，返回一个大于或等于0而且小于1.0的伪随机浮点数。
Otherwise, returns a pseudorandom integer greater than or equal to zero and less than max1. 
否则，返回一个大于等于0并且小于max1的伪随机整数。
If a range is passed, return a random number in that range.
如果传入一个区间，返回区间内的随机数。

#### seed  种子

    rand.seed → bignum

Returns the seed for this random number generator.
返回该随机数生成器的种子。


## Rational < Numeric  有理数  1.9
### 概述
Rational numbers are expressed as the ratio of two integers. 
有理数被表达为两个整数的比。
When the denominator exactly divides the numerator, a rational number is effectively an integer. 
分母被分子整除时，该有理数实际上是一个整数。
Rationals allow exact representation of fractional numbers, but some real values cannot be expressed exactly and so cannot be represented as rationals.
有理数允许准确表示分数，但一些实数不能被准确表示，因此这些实数不能被表示为有理数。
Class Rational is normally relatively independent of the other numeric classes, in that the result of dividing two integers with the / operator will normally be a (truncated) integer (the quo method will always return a rational result). 
Rational类通常相对独立与其他数字类，其他数字类中两个整数使用/操作符相除时通常产生一个（被截断）的整数（（quo方法则将总是返回一个有理数）。
However, if the mathn library is loaded into a program, integer division may generate a Rational result. 
不过，如果mathn库被载入程序中，整数除法可能产生一个有理数结果。
Also see the rational library on page 794 for additional methods on rational numbers.
有理数的其他加法另见后面794页的有理数库。

    r1 = Rational("1/2")   # => 1/2
    r2 = 4.quo(5)          # => 4/5
    r1 * r2                # => 2/5

### Instance Methods 实例方法
#### Arithmetic operations  算术操作
Performs various arithmetic operations on rat.
对rat进行各种算术操作。

    rat +  numeric  Addition  加法
    rat -  numeric  Subtraction  减法 
    rat *  numeric  Multiplication  乘法
    rat /  numeric  Division  除法
    rat %  numeric  Modulo 取模 
    rat ** numeric  Exponentiation 乘方
    rat -@          Unary minus 一元减

#### Comparisons  比较
Compares rat to other numbers: <, <=, ==, >=, and >.
将rat和其他数字进行各种比较：<, <=, ==, >=,  >。

#### <=>  比较

    rat <=> numeric → -1, 0, +1, or nil

Comparison—Returns -1, 0, or +1 depending on whether rat is less than, equal to, or greater than numeric. 
比较--根据rat是否小于、等于或大于numeric，返回-1, 0, 或+1
Although Rational’s grandparent mixes in Comparable, Rational does not use that module for performing comparisons, instead implementing the comparison operators explicitly.
虽然Rational的祖父类混入了Comparable，Rational不使用该模块进行比较，相反它显式地实现比较操作。

    Rational("4/2") <=> Rational("98/49") # => 0
    Rational("3/4") <=> 41 # => -1
    Rational("0") <=> 0.0 # => 0

#### ==  是否相等

    rat == numeric

Returns true if rat has the same value as numeric. 
如果rat和numeric同值，返回true。
Comparisons against integers and rational numbers are exact; comparisons against floats first convert rat to a float.
对整数和有理数的比较是准确的；对浮点数的比较则需要先将rat转换成浮点数。

#### ceil  向上取整

    rat.ceil → numeric

Returns the smallest integer greater than or equal to rat.
返回大于或等于rat的最小整数。

    Rational("22/7").ceil # => 4
    Rational("-22/7").ceil # => -3

#### denominator  分母

    rat.denominator → a_number

Returns the denominator of rat.
返回rat的分母。

    Rational("2/3").denominator # => 3

#### fdiv  浮点除法

    rat.fdiv( numeric ) → float

Returns the floating-point result of dividing rat by numeric.
返回rat被numeric相除，返回浮点结果。

    Rational("11/2") / 2      # => 11/4 
    Rational("11/2").fdiv 2   # => 2.75

#### floor  向下取整

    rat.floor → numeric

Returns the largest integer less than or equal to rat.
返回小于或等于rat的最大整数。

    Rational("22/7").floor # => 3
    Rational("-22/7").floor # => -4

#### numerator  分子

    rat.numerator → a_number

Returns the numerator of rat.
返回rat的分子。

    Rational("2/3").numerator # => 2

#### quo  除法

    rat.quo( numeric ) → numeric

Synonym for Rational#/.
同Rational#/。

#### rationalize  有理化

    rat.rationalize → rat
    rat.rationalize( epsilon ) → rational

With no argument, returns rat; otherwise, returns a new Rational with the given precision.
不带参数，返回rat；否则，返回一个新的具有给定精度的有理数。

    r = Math::PI.to_r # => (884279719003555/281474976710656)
    r.rationalize # => (884279719003555/281474976710656)
    r.rationalize(0.01) # => (22/7)

#### round  取整

    rat.round → numeric

Rounds rat to the nearest integer.
把rat取整为最接近的整数。

    Rational("22/7").round # => 3
    Rational("-22/7").round # => -3

#### to_f  转换为浮点数

    rat.to_f → float

Returns the floating-point representation of rat.
返回浮点表示的rat

    Rational("37/4").to_f # => 9.25

#### to_i  转换为整数

    rat.to_i → integer

Returns the truncated integer value of rat.
返回截取的rat的整数值。

    Rational("19/10").to_i # => 1
    Rational("-19/10").to_i # => -1

#### to_r  转换为有理数

    rat.to_r → rat

Returns rat.
返回rat。

#### truncate  截断

    rat.truncate → numeric

Returns rat truncated to an integer.
将rat返回为截断的整数。

    Rational("22/7").truncate # => 3
    Rational("-22/7").truncate # => -3


## Regexp  正则表达式
### 概述
A Regexp holds a regular expression, used to match a pattern against strings. 
Regexp保存有一个正则表达式，它用来对字符串匹配一个模式。
Regexps are created using the /.../ and %r{...} literals and using the Regexp.new constructor. 
可以使用/.../或%r...字面量和Regexp.new构造函数来创建Regexp。
See the reference on in Regular Expressions, on page 303 for more details.
更多细节参见前面303页的正则表达式。

### Class Constants  类常量

    EXTENDED   Ignores spaces and newlines in regexp   
               忽视regexp中的空格和回车换行符。
    IGNORECASE Matches are case insensitive
               匹配时大小写无关。
    MULTILINE  Newlines treated as any other character
               换行符被当作任意别的字符对待。

### Class Methods 类方法
#### compile  新建

    Regexp.compile( pattern ‹ , options ‹ , lang ›› ) → rxp

Synonym for Regexp.new.
同Regexp.new。

#### escape  转义

    Regexp.escape( string ) → escaped_string

Escapes any characters that would have special meaning in a regular expression. 
对任何可能在正则表达式中有特殊含义的字符进行转义。
For any string, `Regexp.new(Regexp.escape(str)) =~ str` will be true.
对任何字符串，`Regexp.new(Regexp.escape(str)) =~ str`将是true。

    Regexp.escape('\\[]*?{}.') # => \\\[\]\*\?\{\}\.

#### last_match  最近匹配  1.8

    Regexp.last_match → match
    Regexp.last_match( int ) → string

The first form returns the MatchData object generated by the last successful pattern match.
第一种形式返回一个MatchData对象，它是由最后一个成功的模式匹配所产生的。
This is equivalent to reading the global variable $~. 
这等同于读取全局变量$~的值。
MatchData has its own reference on page 559.
MatchData的参考在前面2版537页4版559页。
The second form returns the n·th field in this MatchData object.
第二种形式返回这个MatchData对象中的第n个字段。

    /c(.)t/ =~ 'cat'      # => 0
    Regexp.last_match     # => #<MatchData "cat" 1:"a">
    Regexp.last_match(0)  # => "cat"
    Regexp.last_match(1)  # => "a"
    Regexp.last_match(2)  # => nil

#### new  新建  1.8

    Regexp.new( string ‹ , options ‹ , lang ›› ) → rxp
    Regexp.new( regexp ) → new_regexp

Constructs a new regular expression from the string or the regexp. 
用string或regexp构造新的正则表达式。
In the latter case, that regexp’s options are propagated, and new options may not be specified. 
在后一种形式，regexp的options会传播，可以不用指定新的options。
If options is a number, it should be one or more of Regexp::EXTENDED, Regexp::IGNORECASE, or Regexp::MULTILINE, or-ed together. 
如果options是一个定数，它应当是一个或多个Regexp::EXTENDED，Regexp::IGNORECASE,或Regexp::MULTILINE的逻辑或。
<kinder:note> 2版的翻译。or-ed together真翻译成逻辑或吗？
Otherwise, if the options parameter is not nil, the regexp will be case insensitive.
否则，如果options参数不是nil，regexp将会是大小写无关的。
The lang can be set to "N" or "n" to force the regular expression to have ASCII-8BIT encoding[3];
lang参数可被设置为"N"或"n"，强制正则表达式用ASCII-8BIT编码。
[3]. No other values are accepted as of Ruby 1.9.
在ruby 1.9,不会接受其他值。
otherwise, the encoding of the string determines the encoding of the regular expression.
否则，string的编码决定正则表达式的编码。

    # encoding: utf-8
    r1 = Regexp.new('^[a-z]+:\\s+\w+')       # => /^[a-z]+:\s+\w+/
    r2 = Regexp.new('cat', true)             # => /cat/i
    r3 = Regexp.new('dog', Regexp::EXTENDED) # => /dog/x
    r4 = Regexp.new(r2)                      # => /cat/i
    r5 = Regexp.new("∂elta")                 #=> /∂elta/
    r1.encoding                              # => #<Encoding:US-ASCII>
    r5.encoding                              # => #<Encoding:UTF-8>

#### quote  转义

    Regexp.quote( string ) → escaped_string

Synonym for Regexp.escape.
同Regexp.escape。

#### try_convert  尝试转换  1.9

    Regexp.try_convert( obj ) → a_regexp or nil

If obj is not already a regular expression, attempts to convert it to one by calling its `to_regexp` method. 
如果obj不是一个正则表达式，尝试调用`to_regexp`方法转换成正则表达式。
Returns nil if no conversion could be made.
如果没有转换，返回nil。

    Regexp.try_convert("cat") # => nil
    class String
      def to_regexp
        Regexp.new(self)
      end
    end
    Regexp.try_convert("cat") # => /cat/

#### union  联合  1.9

    Regexp.union( ‹ pattern ›* ) → a_regexp

Returns a regular expression that will match any of the given patterns. 
返回一个将会匹配任意给定pattern的正则表达式。
With no patterns, produces a regular expression that will never match. 
没有带pattern，将产生一个不会匹配的正则表达式。
If a pattern is a string, it will be given the default regular expression options. 
如果pattern是字符串，将给定默认的正则表达式选项。
If a pattern is a regular expression, its options will be honored in the final pattern. 
如果pattern是一个正则表达式，它的选项将会在最后的模式中被尊重。
<kinder:note> 尊重？？？
The patterns may also be passed in a single array.
pattern也会被传入一个单个元素的数组里。
<kinder:note> 不懂了

    Regexp.union("cat")         # => /cat/
    Regexp.union("cat", "dog")  # => /cat|dog/
    Regexp.union(%w{ cat dog }) # => /cat|dog/
    Regexp.union("cat", /dog/i) # => /cat|(?i-mx:dog)/   <kinder:note> ???


### Instance Methods 实例方法
#### ==  是否相同

    rxp == other_regexp → true or false

Equality—Two regexps are equal if their patterns are identical, they have the same character set code, and their casefold? values are the same.
等同--如果两个正则表达式的模式相同，字符集编码相同，它们的casefold?值相同，那么这两个正则表达式是相等的。

    /abc/ == /abc/x # => false
    /abc/ == /abc/i # => false
    /abc/u == /abc/n # => false

#### ===  是否匹配

    rxp === string → true or false

Case Equality—Like Regexp#=~ but accepts nonstring arguments (returning false). 
case等同--就像Regexp#=～，但接受非字符串参数（返回false）。
Used in case statements.
用于case语句。

    a = "HELLO"
    case a
    when /\A[a-z]*\z/; print "Lower case\n"
    when /\A[A-Z]*\z/; print "Upper case\n"
    else
      print "Mixed case\n"
    end
    # produces:
    # Upper case

#### =~  匹配

    rxp =~ string → int or nil

Match—Matches rxp against string, returning the offset of the start of the match or nil if the match failed. 
匹配--对string匹配rxp，返回匹配开始处的偏移，如果匹配失败，返回nil。
Sets $~ to the corresponding MatchData or nil.
把$~设置为相应的MatchData对象或nil。

    /SIT/ =~ "insensitive" # => nil
    /SIT/i =~ "insensitive" # => 5

#### ~  匹配

    ~ rxp → int or nil

Match—Matches rxp against the contents of `$_`. 
匹配--对`$_`内容匹配rsp。
Equivalent to `rxp =~ $_`. 
等同于`rxp =~ $_`。
You should be ashamed if you use this:
如果你用这个就该感到惭愧了：

    $_ = "input data"
    ~ /at/ # => 7

#### casefold?  是否大小写敏感

    rxp.casefold? → true or false

Returns the value of the case-insensitive flag. 
返回大小写敏感的标志值。
Merely setting the i option inside rxp does not set this flag.
在rxp里面只是设置i选项不会设置这个标志。

    /cat/.casefold?  # => false
    /cat/i.casefold?  # => true
    /(?i:cat)/.casefold? # => false

#### encoding  编码  1.9

    rxp.encoding → an_encoding

Returns the character encoding for the regexp.
返回正则表达式的字符编码。

    /cat/.encoding # => #<Encoding:US-ASCII>
    /cat/s.encoding # => #<Encoding:Windows-31J>
    /cat/u.encoding # => #<Encoding:UTF-8>

#### fixed_encoding?  是否固定编码

    rxp.fixed_encoding? → true or false

A regular expression containing only 7-bit characters can be matched against a string in any encoding. 
只包含7位字符的正则表达式可能被任何编码的字符串所匹配。
In this case, `fixed_encoding?` returns false. 
在这种情况下，`fixed_encoding?`返回false。
Otherwise, it returns true.
否则，它返回true。

    /cat/.fixed_encoding? # => false
    /cat/s.fixed_encoding? # => true
    /cat/u.fixed_encoding? # => true

#### match  匹配

    rxp.match( string, offset=0 ) → match or nil
    rxp.match( string, offset=0 ) { |match| … } → obj

Returns a MatchData object describing the match or nil if there was no match. 
返回描述这匹配的一个MatchData对象。
This is equivalent to retrieving the value of the special variable $~ following a normal match. 
这相当于在一次正常的匹配后，重新获得特别变量$~的值。
The match process will start at offset into string. 
匹配过程将在string的offset处开始。
If a block is given and the match is successful, the block will be invoked with the MatchData object, and the value returned by the block will be the value returned by match.
如果给定了block，且匹配成功，block将会和MatchData一起被调用，block返回的值将是匹配返回的值。<kinder:note> 不懂。

    md = /(.)(d)(.)/.match("abcdefabcdef")
    md       # => #<MatchData "cde" 1:"c" 2:"d" 3:"e">
    md[1]         # => "c"
    md.begin(1) # => 2
    md = /(.)(d)(.)/.match("abcdedcba", 4)
    md       # => #<MatchData "edc" 1:"e" 2:"d" 3:"c">
    md.begin(1)       # => 4  为什么是4？？？
    result = /(...)...(...)/.match("catanddog") do |md|
      md[1] + "&" + md[2]
    end
    result # => "cat&dog"

#### named_captures  命名捕获  1.9

    rxp.named_captures → hash

Returns a hash whose keys are the names of captures and whose values are each an array containing the number of the capture in rxp.
返回一个散列表，键为捕获的名称，值为一个数组，包含rxp中捕获的值。
<kinder:note> 又是不懂。

    /(?<a>.).(?<b>.)/.named_captures # => {"a"=>[1], "b"=>[2]}
    /(?<a>.)(.)(?<b>.)/.named_captures # => {"a"=>[1], "b"=>[2]}
    /(?<a>.)(?<b>.)(?<a>.)/.named_captures # => {"a"=>[1, 3], "b"=>[2]}

#### names  命名  1.9

    rxp.names → array

Returns an array containing the names of captures in rxp.
返回包含rxp里捕获名称的数组。

    /(.)(.)(.)/.names # => []
    /(?<first>.).(?<last>.)/.names # => ["first", "last"]

#### options  选项  1.8

    rxp.options → int

Returns the set of bits corresponding to the options used when creating this regexp (see Regexp.new for details). 
返回对应创建正则表达式时所用的options位的集合（详见后面Regexp.new）。
Note that additional bits may be set in the returned options; these are used internally by the regular expression code. 
注意：可能在返回的options中设置附加的位，正则表达式的代码会在内部使用它们。
These extra bits are ignored if the options are passed to Regexp.new.
这些附加位会被忽视。

    # Let's see what the values are...
    Regexp::IGNORECASE # => 1
    Regexp::EXTENDED # => 2
    Regexp::MULTILINE # => 4
    /cat/.options                       # =>  0
    /cat/ix.options                     # =>  3
    Regexp.new('cat', true).options     # =>  1
    Regexp.new('cat', 0, 'n').options   # =>  32  ???
    r = /cat/ix
    Regexp.new(r.source, r.options) # => /cat/ix   ???

#### source  被匹配字符串

    rxp.source → string

Returns the original string of the pattern.
返回模式的初始字符串。

    /ab+c/ix.source # => "ab+c"

#### to_s  转换为字符串

    rxp.to_s → string

Returns a string containing the regular expression and its options (using the (?xx:yyy) notation).
返回一个字符串，它包含正则表达式和它的options（使用(?xx:???)表示法）。
This string can be fed back into Regexp.new to a regular expression with the same semantics as the original. 
字符串可以作为正则表达式传递给Regexp.new，它与原来的正则表达式有相同的语义。
(However, Regexp#== may not return true when comparing the two, because the source of the regular expression itself may differ, as the example shows.) 
（但是，当对它们进行比较时，Regexp#==可能不会返回true，因为正则表达式的源本身就可能会不相同。如下面的例子所示）。
Regexp#inspect produces a generally more readable version of rxp.
Regexp#inspect产生一个rxp普遍更易读的版本。

    r1 = /ab+c/ix       # => /ab+c/ix
    s1 = r1.to_s        # => "(?ix-m:ab+c)"
    r2 = Regexp.new(s1) # => /(?ix-m:ab+c)/
    r1 == r2            # => false
    r1.source           # => "ab+c"
    r2.source           # => "(?ix-m:ab+c)"
                         

## Module Signal  信号模块
### 概述
Many operating systems allow signals to be sent to running processes. 
很多操作系统允许发送信号给正在运行的进程。
Some signals have a defined effect on the process, and others may be trapped at the code level and acted upon.
一些信号对进程有明确的影响，而别的信号可能会在代码级别中被捕获，并作出相应的处理。
For example, your process may trap the USR1 signal and use it to toggle debugging, and it may use TERM to initiate a controlled shutdown.
比如，你的进程可能捕获USR1信号，使用它来进行切换调试，或者使用TERM信号来发起一次受控的关机。

    pid = fork do
      Signal.trap("USR1") do
        $debug = !$debug
        puts "Debug now: #$debug"
      end
      Signal.trap(:TERM) do
        # symbols work too...
        puts "Terminating..."
        exit
      end
      # . . . do some work . . .
    end
    Process.detach(pid)
    # Controlling program:
    Process.kill("USR1", pid)
    # ...
    Process.kill(:USR1, pid)
    # ...
    Process.kill("TERM", pid)
    # produces:
    # Debug now: true
    # Debug now: false
    # Terminating...

The list of available signal names and their interpretation is system dependent. 
这个可用信号名以及信号名解释的列表是与系统密切相关的。
Signal delivery semantics may also vary between systems; in particular, signal delivery may not always be reliable.
信号发送机制页可能会因系统而异：尤其是信号发送可能不总是可靠的。

### Class Methods 类方法
#### list  信号列表

    Signal.list → hash

Returns a list of signal names mapped to the corresponding underlying signal numbers.
返回一个信号名列表，这些信号名映射相应的底层操作系统信号数值。

    Signal.list 
    # => {"ABRT"=>6, "ALRM"=>14, "BUS"=>10, "CHLD"=>20, "CLD"=>20,
    # .. "CONT"=>19, "EMT"=>7, "EXIT"=>0, "FPE"=>8, "HUP"=>1, "ILL"=>4,
    # .. "INFO"=>29, "INT"=>2, "IO"=>23, "IOT"=>6, "KILL"=>9, "PIPE"=>13,
    # .. "PROF"=>27, "QUIT"=>3, "SEGV"=>11, "STOP"=>17, "SYS"=>12,
    # .. "TERM"=>15, "TRAP"=>5, "TSTP"=>18, "TTIN"=>21, "TTOU"=>22,
    # .. "URG"=>16, "USR1"=>30, "USR2"=>31, "VTALRM"=>26, "WINCH"=>28,
    # .. "XCPU"=>24, "XFSZ"=>25}

#### signame  信号名 ⇡New in 2.0⇣

    Signal.signame( num ) → string

Return the (abbreviated) name of the signal with the given number. 
返回给定数字的（缩写）信号名。
An ArgumentError is raised if the number does not correspond to a signal.
如果数字没有对应的信号，则抛出一个ArgumentError。

    Signal.signame(1) # => "HUP"
    Signal.signame(15) # => "TERM"

#### trap  捕获

    Signal.trap( signal, command ) → obj
    Signal.trap( signal ) { … } → obj

Specifies the handling of signals. 
指定信号的处理方式。
The first parameter is a signal name (a string or symbol such as SIGALRM, SIGUSR1, and so on) or a signal number. 
第一个参数是信号名（例如SIGALRM、SIGUSR1等等那样的字符串或符号）或信号数。
The characters SIG may be omitted from the signal name. 
信号名可能会省略SIG字符。
The command or block specifies code to be run when the signal is raised. 
这个命令或block指定了当这个信号引发时要运行的特定代码。
If the command is nil, the string IGNORE or SIG_IGN, or the empty string, the signal will be ignored. 
如果这个命令是nil，字符串IGNORE或SIG_IGN，或空字符串，这个信号会被忽略。
If the command is DEFAULT or SIG_DFL, the operating system’s default handler will be invoked. 
如果命令是DEFAULT或SIG_DFL，将调用操作系统默认的处理函数。
If the command is EXIT, the script will be terminated by the signal. 
如果命令是EXIT，脚本将被信号所终结。
Otherwise, the given command or block will be run.
否则，将运行给定命令或block。

The special signal name EXIT or signal number zero will be invoked just prior to program termination.
特殊的信号名EXIT或者信号数值0将会在程序即将终止之前被触发。

⇡New in 2.0⇣
Trap cannot be used with the signals BUS, FPE, ILL, SEGV, or VTALRM.
Trap不能和信号BUS FPE ILL SEGV VTALRM一起使用。

trap returns the previous handler for the given signal.
trap返回给定信号的原有处理函数。

    Signal.trap(0, lambda { |signo| puts "exit pid #{$$} with #{signo}" })
    Signal.trap("CLD") { |signo| puts "Child died (#{signo})" }
    if fork
      # parent
      do_something # ...
    else
      puts "In child, PID=#{$$}"
    end        # 关闭的时候触发最上面的两个trap。
    # produces:
    # In child, PID=24189
    # exit pid 24189 with 0
    # Child died (20)
    # exit pid 24188 with 0

Note that you must specify a block taking a parameter if you use lambda to create the proc object.
注意你必须指定一个带一个参数的block，如果你使用lambda来创建一个过程对象。
<kinder:note> why？


## String  字符串
### 概述
A String object holds and manipulates a sequence of characters. 
字符串对象保存炳操作一个字节序列。
String objects may be created using String.new or as literals (see Strings, on page 300).
可以使用String.new或者以字面量来创建字符串对象（参见前面2版320页4版300页）

Because of aliasing issues, users of strings should be aware of the methods that modify the contents of a String object. 
因为存在别名问题，使用字符串时，你应当了解那些会修改字符串对象内容的方法。
Typically, methods with names ending in ! modify their receiver, while those without a ! return a new String. 
通常名称以！结尾的方法会修改它们的接收者；那些不带！的方法返回新的字符串。
However, exceptions exist, such as String#[]=.
当然，也有例外，比如String#[]=。

In this description, I try to differentiate between the bytes in a string and the characters in a string. 
在这里，我尝试区分字符串里的字节和字符串里的字符。
Internally, a string is a sequence of 8-bit bytes. 
在内部，一个字符串是一个八位字节序列。
These are represented externally as small Fixnums. 
这些序列在外部表示为小写的定数。
At the same time, these byte sequences are interpreted as a sequence of characters. 
同时，这些字节序列被解释成字符序列。
This interpretation is controlled by the encoding of the string. 
这个解释为字符串的编码所控制。
In some encodings (such as US-ASCII and ISO-8859), each byte corresponds to a single character. 
在一些编码（比如US-ASCII和ISO-8859），每个字节都对应着一个单个字符。
In other encodings (such as UTF-8), a varying number of bytes comprise each character.
在其他编码（比如UTF-8），多个字节组成每个字符。

As of Ruby 1.9, String no longer mixes in Enumerable.
到了Ruby 1.9，字符串类不再混入Enumerable模块。

### Mixes In  混入
Comparable: <, <=, ==, >, >=, between?

### Class Methods 类方法
#### new  新建

    String.new( val="" ) → str

Returns a new string object containing a copy of val (which should be a String or implement to_str). 
返回新的字符串对象，它含有val的一个拷贝（val应当是一个字符串或者实现了to_str方法）。
Note that the new string object is created only when one of the strings is modified.
注意新的字符串对象只在一个字符串被修改时才新建。

    str1 = "wibble"
    str2 = String.new(str1)
    str1.object_id # => 70198849846720
    str2.object_id # => 70198849846680
    str1[1] = "o"
    str1 # => "wobble"
    str2 # => "wibble"

#### try_convert  尝试转化  1.9

    String.try_convert( obj ) → a_string or nil

If obj is not already a string, attempts to convert it to one by calling its `to_str` method. 
如果obj还不是一个字符串，尝试调用它的`to_str`方法将它转化为一个字符串。
Returns nil if no conversion could be made.
如果没有转换则返回nil。

    String.try_convert("cat") # => "cat"
    String.try_convert(0xbee) # => nil


### Instance Methods 实例方法
#### %  格式化

    str % arg → string

Format—Uses str as a format specification and returns the result of applying it to arg. 
格式化--把str当作格式化的规范，返回作用于arg之后的结果。
If the format specification contains more than one substitution, then arg must be an Array containing the values to be substituted. 
如果这个格式化规范包含多个替换，那么arg必须是一个数组。
See Object#sprintf on page 626 for details of the format string.
关于格式化字符串的详细信息参见前面2版529页4版626页的Object#sprintf。

    puts "%05d" % 123
    puts "%-5s: %08x" % [ "ID", self.object_id ]
    puts "%-5<name>s: %08<value>x" % { name: "ID", value: self.object_id }
    # produces:
    # 00123
    # ID : 3ff795471248
    # ID : 3ff795471248

#### *  复制

    str * int → string

Copies—Returns a new String containing int copies of the receiver.
复制--返新的字符串，含有这个str的int个拷贝。

    "Ho! " * 3 # => "Ho! Ho! Ho! "

#### +  串联

    str + string → string

Concatenation—Returns a new String containing string concatenated to str. 
串联--把string串联到str，返回一个新的字符串。
If both strings contain non-7-bit characters, their encodings must be compatible.
如果两个字符串都包含非七位字符，它们的编码必须兼容。

    "Hello from " + "RubyLand" # => "Hello from RubyLand"

#### <<  附加

    str << fixnum → str
    str << obj → str

Append—Concatenates the given object to str. 
追加--把给定对象串联到str。
If the object is a Fixnum, it is considered to be a codepoint in the encoding of str and converted to the appropriate character before being appended.
如果这个对象是个定数，它被认为是str的编码的代码点，并在追加之前转换为适当的字符。

    a = "hello world"
    a.force_encoding("utf-8")
    a << 33           # => "hello world!"
    a << " Says the " # => "hello world! Says the "
    a << 8706         # => "hello world! Says the ∂"
    a << "og"         # => "hello world! Says the ∂og"

#### <=>  比较

    str <=> other_string → -1, 0, +1, or nil 

Comparison—Returns -1 if str is less than, 0 if str is equal to, and +1 if str is greater than `other_string`. 
比较--根据str小于、等于、大于`other_string`分别返回-1, 0, +1.
If the strings are of different lengths and the strings are equal when compared to the shortest length, then the longer string is considered greater than the shorter one. 
如果这两个字符串长度不同，且比较两者最短长度时相等，则长的字符串要大于短的字符串。
In older versions of Ruby, setting $= allowed case-insensitive comparisons; you must now use String#casecmp.
在ruby的老版本中，设置$=允许大小写敏感比较；现在你必须使用String#casecmp。

<=> is the basis for the methods <, <=, >, >=, and between?, included from module Comparable.
<=> 是< <= > =>和between?方法的基础，这些方法是从Comparable模块中包含进来的。
The method String#== does not use Comparable#==.
而String#==方法没有使用Comparable#==。

    "abcdef" <=> "abcde"    # => 1
    "abcdef" <=> "abcdef"   # => 0
    "abcdef" <=> "abcdefg"  # => -1
    "abcdef" <=> "ABCDEF"   # => 1

#### ==  是否相等

    str == obj → true or false

Equality—If obj is a String, returns true if str has the same encoding, length, and content as obj; returns false otherwise. 
等同--如果obj是一个字符串，并且str有一样的编码，长度和内容都和obj一样，返回true；否则返回false。
If obj is not a String but responds to to_str, returns obj == str; otherwise, returns false.
如果obj不是一个字符串，但会响应`to_str`，则返回`obj == str`；否则返回false。

    "abcdef" == "abcde" # => false
    "abcdef" == "abcdef" # => true

#### =~  匹配

    str =~ regexp → int or nil

Match—Equivalent to regexp =~ str. 
匹配--等同于`regexp =~ str`。
Prior versions of Ruby permitted an arbitrary operand to =~; this is now deprecated. 
之前的版本允许=～有一个任意的操作数；现在已经不推荐使用了。
Returns the position where the match starts or returns nil if  there is no match or if regexp is not a regular expression.[4]
返回匹配的开始位置；如果没有匹配上，或如果regexp不是一个正则表达式，返回nil。
[4].  Except for a strange corner case. 
除了极为特殊的情况。
If regexp is a string or can be coerced into a string, a TypeError exception is raised.
如果regexp是一个字符串或可被强制转换为一个字符串，将抛出一个TypeError异常。

    "cat o' 9 tails" =~ /\d/ # => 7
    "cat o' 9 tails" =~ 9 # => nil
    "cat o' 9 tails" =~ "\d"
    # produces:
    # from prog.rb:1:in `<main>'
    # prog.rb:1:in `=~': type mismatch: String given (TypeError)

#### []  元素引用

    str[ int ] → string or nil
    str[ int, int ] → string or nil
    str[ range ] → string or nil
    str[ regexp ] → string or nil
    str[ regexp, int ] → string or nil
    str[ regexp, name ] → string or nil
    str[ string ] → string or nil

Element Reference—If passed a single int, returns the character at that position. 
元素引用--如果传入单个int，返回在这个位置的字符。
(Prior to Ruby 1.9, an integer character code was returned.) 
（Ruby 1.9之前，返回一个整数字符码）
If passed two ints, returns a substring starting at the offset given by the first, and a length given by the second. 
如果传入两个int，返回一个子字符串，它是从第一个int指定的偏移开始，长度由第二个int参数给定。
If given a range, a substring containing characters at offsets given by the range is returned. 
如果给定一个区间，返回一个子字符串，它包含了在这个区间指定的偏移处的那些字符。
In all three cases, if an offset is negative, it is counted from the end of str. 
在所有这三种情况中，如果偏移是负数，则它从str的结尾处开始数起。
Returns nil if the initial offset falls outside the string and the length is not given, the length is negative, or the beginning of the range is greater than the end.
如果初始的偏移落在字符串之外，没有给定长度，长度是负数，或者区间的开头大于结尾，返回nil。

If regexp is supplied, the matching portion of str is returned. 
如果提供了regexp，返回str匹配的那部分。
If a numeric parameter follows the regular expression, that component of the MatchData is returned instead. 
如果正则表达式后面跟有一个数字参数，则相反，返回MatchData对象的那个成分。
If a String is given, that string is returned if it occurs in str. 
如果给定一个字符串，并且出现在str中，则返回这个字符串。
If a name follows the regular expression, the corresponding named match is returned. 
如果一个名称在正则表达式之后，则返回对应名称的匹配。
In all cases, nil is returned if there is no match.
在所有情况下，如果没有匹配则返回nil。

    a = "hello there"
    a[1]     # => "e"
    a[1,3]   # => "ell"
    a[1..3]  # => "ell"
    a[1...3] # => "el"
    a[-3,2]                        # => "er"
    a[-4..-2]                      # => "her"
    a[-2..-4]                      # => ""
    a[/[aeiou](.)\1/]              # => "ell"
    a[/[aeiou](.)\1/, 0]           # => "ell"
    a[/[aeiou](.)\1/, 1]           # => "l"
    a[/[aeiou](.)\1/, 2]           # => nil，因为只有一个()，即\1
    a[/(..)e/]                     # => "the"
    a[/(..)e/, 1]                  # => "th"
    a[/(?<vowel>[aeiou])/, :vowel] # => "e"
    a["lo"]                        # => "lo"
    a["bye"]                       # => nil

#### [ ]=  元素赋值

    str[ int ] = string
    str[ int, int ] = string
    str[ range ] = string
    str[ regexp ] = string
    str[ regexp, int ] = string
    str[ string ] = string}

Element Assignment—Replaces some or all of the content of str. 
元素赋值--替换str中的部分或者全部内容。
The portion of the string affected is determined using the same criteria as String#[ ]. 
使用与String#[]同样的标准来决定要被替换的那部分字符串。
If the replacement string is not the same length as the text it is replacing, the string will be adjusted accordingly. 
如果替换字符串的长度与要替换的文本长度不同，替换字符串会相应得作出调整。
If the regular expression or string is used because the index doesn’t match a position in the string, IndexError is raised. 
如果用作索引的正则表达式或者字符串没有匹配上字符串中的任何位置，引发IndexError。
If the regular expression form is used, the optional second int allows you to specify which portion of the match to replace (effectively using the MatchData indexing rules). 
如果使用正则表达式形式，可选的第二个int参数允许你指定要替换的匹配部分（实际使用MatchData的索引规则）。
The forms that take a Fixnum will raise an IndexError if the value is out of range; the Range form will raise a RangeError, and the Regexp and String forms will silently ignore the assignment.
如果定数的值超出范围，接受一个定数的形式会引发IndexError；这个区间形式会引发RangeError，而正则表达式和字符串形式会静默地忽略这个赋值。

    a = "hello"
    a[2] = "u" (a → "heulo")
    a[2, 4] = "xyz" (a → "hexyz")
    a[-4, 2] = "xyz" (a → "hxyzlo")
    a[2..4] = "xyz" (a → "hexyz")
    a[-4..-2] = "xyz" (a → "hxyzo")
    a[/[aeiou](.)\1(.)/] = "xyz" (a → "hexyzlo")   
    # [aeiou]匹配e，(.)匹配l，\1匹配l，(.)匹配o
    a[/[aeiou](.)\1(.)/, 1] = "xyz" (a → "hxyz")
    a[/[aeiou](.)\1(.)/, 2] = "xyz" (a → "hellxyz")
    a["l"] = "xyz" (a → "hexyzlo")
    a["ll"] = "xyz" (a → "hexyzo")
    a[2, 0] = "xyz" (a → "hexyzllo")

#### ascii_only?  1.9

    str.ascii_only? → true or false

Returns true if the string contains no characters with a character code greater than 127 (that is, it contains only 7-bit ASCII characters).
如果str没有包含字符编码大于127的字符（就是，只包含七位ASCII字符），返回true。

    # encoding: utf-8
    "dog".ascii_only?  # => true
    "∂og".ascii_only?  # => false
    "\x00 to \x7f".ascii_only? # => true

#### b  转为八位编码   ⇡New in 2.0⇣

    str.b → string

Returns a copy of the contents of str with ASCII-8BIT encoding. 
返回str内容的ASCII-8BIT编码的拷贝。
This is a convenient way to get to the byte values of any string.
这是一个方便的获取任何字符串的字节值的方法。

    str = "∂øg"
    str.length # => 3
    bstr = str.b
    bstr.length # => 6

#### bytes  字节  ⇡New in 2.0⇣

    str.bytes → enum | array
    str.bytes { |byte| … } → str

Returns an enumerator (Ruby 1.9) or array (Ruby 2.0) for the bytes (integers in the range 0 to 255) in str. 
返回str里面的字节（0到255之间的整数）的枚举（ruby 1.9）或数组（ruby 2.0）。
With a block, passes each byte to the block and returns the original string. 
如果带block，将每个字节传递到block中，返回原始的字符串。
See also String#codepoints and #chars.
另见String#codepoints和#chars。

    # encoding: utf-8
    "dog".bytes # => [100, 111, 103]
    "∂og".bytes # => [226, 136, 130, 111, 103]
    result = []
    "∂og".bytes {|b| result << b } # => "∂og"
    result # => [226, 136, 130, 111, 103]

#### bytesize  字节大小  1.9

    str.bytesize → int

Returns the number of bytes (not characters) in str. 
返回str里面字节（不是字符）的数量。
See also String#length.
另见String#length。

    # encoding: utf-8
    "dog".length # => 3
    "dog".bytesize # => 3
    "∂og".length # => 3
    "∂og".bytesize # => 5

#### byteslice  字节片段  1.9

    str.byteslice( offset, length=1 ) → string or nil
    str.byteslice( range ) → string or nil

Returns the string consisting of length bytes starting at byte position offset, or between the offsets given by the range. 
返回包含从offset位开始的length字节长的或在两个offset之间的字符串。
A negative offset counts from the end of the string. 
负数offset从字符串的结尾开始算起。
The returned string retains the encoding of str, but may not be valid in that encoding.
返回的字符串保留了str的编码，但可能在该编码上无效。

    # encoding: utf-8
    a = "∂dog" 
    a.bytes.to_a        # => [226, 136, 130, 100, 111, 103]
    a.byteslice(0)      # => "\xE2"
    a.byteslice(0, 2)   # => "\xE2\x88"
    a.byteslice(0, 3)   # => "∂"   三个字节可解释为一个字符
    a.byteslice(0, 4)   # => "∂d"  ASCII字符则是一个字节？
    a.byteslice(-2, 1)  # => "o"
    a.byteslice(-2, 2)  # => "og"
    a.byteslice(-2..-1) # => "og"

#### capitalize  首字大写

    str.capitalize → string

Returns a copy of str with the first character converted to uppercase and the remainder to lowercase.
返回str的一个拷贝，它的首字符转换成大写，同时其余字符都转换成小写。

    "hello world".capitalize # => "Hello world"
    "HELLO WORLD".capitalize # => "Hello world"
    "123ABC".capitalize      # => "123abc"

#### capitalize!  首字大写

    str.capitalize! → str or nil

Modifies str by converting the first character to uppercase and the remainder to lowercase.
通过把首字符转换成大写，同时把其余字符都转换成小写来修改str。
Returns nil if no changes are made.
如果没有修改则返回nil。

    a = "hello world"
    a.capitalize! # => "Hello world"
    a # => "Hello world"
    a.capitalize! # => nil

#### casecmp 大小写无关的比较  1.8

    str.casecmp( string ) → -1, 0, +1

Case-insensitive version of String#<=>.
String#<=>方法的大小写无关的版本。

    "abcdef".casecmp("abcde")   # => 1
    "abcdef".casecmp("abcdef")  # => 0
    "aBcDeF".casecmp("abcdef")  # => 0
    "abcdef".casecmp("abcdefg") # => -1
    "abcdef".casecmp("ABCDEF")  # => 0

#### center  居中

    str.center( int, pad=" " ) → string

If int is greater than the length of str, returns a new String of length int with str centered between the given padding (defaults to spaces); otherwise, returns str.
如果int大于str的长度，返回新的字符串，int是它的长度，str放置在中间，两边填充给定的内边距（默认空格）；否则返回str。

    "hello".center(4)          # => "hello"
    "hello".center(20)         # => "␣␣␣␣␣␣␣hello␣␣␣␣␣␣␣␣"
    "hello".center(4, "_-^-")  # => "hello"
    "hello".center(20, "_-^-") # => "_-^-_-^hello_-^-_-^-"
    "hello".center(20, "-")    # => "-------hello--------"

#### chars  字符 ⇡New in 2.0⇣

    str.chars → enum | array
    str.chars { |char| … } → str

Returns an enumerator (Ruby 1.9) or array (Ruby 2.0) for the characters (single character strings) in str. 
返回str里面的字符（单个字符的字符串）的枚举（ruby 1.9）或数组（ruby 2.0）。
With a block, passes each character to the block and returns the original string.
如果带block，将每个字符传递到block中，返回原始的字符串。
See also String#bytes and String#codepoints.
另见String#bytes和#codepoints。

    # encoding: utf-8
    "dog".chars.to_a # => ["d", "o", "g"]
    "∂og".chars.to_a # => ["∂", "o", "g"]
    result = []
    "∂og".chars {|b| result << b } # => "∂og"
    result # => ["∂", "o", "g"]

#### chr  第一个字符  1.9

    str.chr → string

Returns the first character of str.
返回str的第一个字符。

    # encoding: utf-8
    "dog".chr # => "d"
    "∂og".chr # => "∂"

#### clear  清空字符串  1.9

    str.clear → str

Removes the content (but not the associated encoding) of str.
删除str的内容（但不删除str相关的编码）。

    # encoding: utf-8
    str = "∂og"
    str.clear # => ""
    str.length # => 0
    str.encoding # => #<Encoding:UTF-8>

#### chomp  去尾符  1.8

    str.chomp( rs=$/ ) → string

Returns a new String with the given record separator removed from the end of str (if present).
在str的结尾处删除给定的记录分隔符（如果有的话），返回新的字符串。
If $/ has not been changed from the default Ruby record separator, then chomp also removes carriage return characters (that is, it will remove \n, \r, and \r\n).
如果未将$/从默认的ruby记录分隔符更改为其他字符，那么chomp也会删除回车换行符（也就是删除\n、\r和\r\n）。

    "hello".chomp           # => "hello"
    "hello\n".chomp         # => "hello"
    "hello\r\n".chomp       # => "hello"
    "hello\n\r".chomp       # => "hello\n"
    "hello\r".chomp         # => "hello"
    "hello \n there".chomp  # => "hello \n there"
    "hello".chomp("llo")    # => "he"

#### chomp!  去尾符

    str.chomp!( rs=$/ ) → str or nil

Modifies str in place as described for String#chomp, returning str or returning nil if no modifications were made.
以String#chomp所描述的方式直接对str进行修改，同时返回str；如果没有做任何修改，返回nil。

#### chop  删尾字

    str.chop → string

Returns a new String with the last character removed. 
返回新的字符串，删除它的最后一个字符。
If the string ends with \r\n, both characters are removed. 
如果这个字符串以\r\n结尾，则两个字符都会被删除。
Applying chop to an empty string returns an empty string. 
把chop应用与空串，会返回空串。
String#chomp is often a safer alternative, because it leaves the string unchanged if it doesn’t end in a record separator.
通常String#chomp是一个更安全的选择，因为如果字符串不是以一个记录分隔符结束，它不会修改这个字符。

    "string\r\n".chop  # => "string"
    "string\n\r".chop  # => "string\n"
    "string\n".chop    # => "string"
    "string".chop      # => "strin"
    "x".chop.chop      # => ""

#### chop!  删尾字

    str.chop! → str or nil

Processes str as for String#chop, returning str or returning nil if str is the empty string. 
以String#chop的方式直接对str进行修改，返回str；如果str是个空串，返回nil。
See also String#chomp!.
另见String#chomp!。

#### codepoints  代码点  ⇡New in 2.0⇣

    str.codepoints → enum | array
    str.codepoints { |integer| … } → str

Returns an enumerator (Ruby 1.9) or array (Ruby 2.0) for the codepoints (integers representation of the characters) in str. 
返回str里面的代码点符（表示字符的整数）的枚举（ruby 1.9）或数组（ruby 2.0）。
With a block, passes each integer to the block and returns the original string. 
如果带block，将每个整数传递到block中，返回原始的字符串。
See also String#bytes and String#chars.
另见String#bytes和#chars。

    # encoding: utf-8
    "dog".codepoints.to_a # => [100, 111, 103]
    "∂og".codepoints.to_a # => [8706, 111, 103]
    result = []
    "∂og".codepoints {|b| result << b } # => "∂og"
    result # => [8706, 111, 103]

#### concat  串联

    str.concat( int ) → str
    str.concat( obj ) → str

Synonym for String#<<.
同String#<<。

#### count  字符计数

    str.count( ‹ string ›+ ) → int

Each string parameter defines a set of characters to count. 
每个string参数都定义了要被计数的字符集合。
The intersection of these sets defines the characters to count in str. 
这些集合的交集定义了str中要被计数的所有字符。
Any parameter that starts with a caret (^) is negated.
任何以^符号开始的参数会被取反。
The sequence c1-c2 means all characters between c1 and c2.
序列c1-c2指的是在c1和c2之间的所有字符。

    a = "hello world"
    a.count "lo"             # => 5
    # l出现3次，o出现2次，加起来就是5次。
    a.count "lo", "o"        # => 2
    # lo和o的交集是o，而o出现2次
    a.count "hello", "^l"    # => 4
    # hello的非l字符就是heo，h出现1次，e出现1次，o出现2次，加起来4次。
    a.count "ej-m"           # => 4
    # e出现1次，j-m表示jklm，其中l出现3次，加起来就是4次。

#### crypt  单向加密

    str.crypt( settings ) → string

Applies a one-way cryptographic hash to str by invoking the standard library function crypt.
通过调用标准库函数crypt来把单向的加密散列算法应用于str。
The argument is to some extent system dependent. 
这个参数某种程度上是与系统相关的。
On traditional Unix boxes, it is often a two-character salt string. 
在传统的Unix机器上，它常常是两个字符的salt字符串。
On more modern boxes, it may also control things such as DES encryption parameters. 
在更现代的机器上，它也可能控制例如DES加密参数等一些事情。
See the man page for crypt(3) for details.
详见crypt(3)手册页。

    # standard salt
    "secret".crypt("sh")   # => "shRK3aVg8FsI2"
    # On OSX: DES, 2 interactions, 24-bit salt
    "secret".crypt("_...0abcd") # => "_...0abcdROn65JNDj12"

#### delete  删除部分字符

    str.delete( ‹ string ›+ ) → new_string

Returns a copy of str with all characters in the intersection of its arguments deleted. 
返回一个str的拷贝，其中在参数交集中出现的所有字符都被删除。
Uses the same rules for building the set of characters as String#count.
使用与String#count相同的规则来定义字符集。

    "hello".delete("l","lo")       # => "heo"
    "hello".delete("lo")           # => "he"
    "hello".delete("aeiou", "^e")  # => "hell"
    "hello".delete("ej-m")         # => "ho"

#### delete!  删除部分字符

    str.delete!( ‹ string ›+ ) → str or nil

Performs a delete operation in place, returning str or returning nil if str was not modified.
直接对str执行删除操作，返回str；如果str没有修改，返回nil。

    a = "hello"
    a.delete!("l","lo") # => "heo"
    a                   # => "heo"
    a.delete!("l")      # => nil

#### downcase  转换为小写

    str.downcase → string

Returns a copy of str with all uppercase letters replaced with their lowercase counterparts.
返回str的一个拷贝，把它的所有大写字母都替换成小写字母。
The operation is locale insensitive—only characters A to Z are affected. 
这个操作是与语言环境无关的--只会影响从A到Z的所有字符。
Multibyte characters are skipped.
会跳过多字节字符。

    "hEllO".downcase # => "hello"

#### downcase!  转换为小写

    str.downcase! → str or nil 

Replaces uppercase letters in str with their lowercase counterparts. 
把str中的大写字母都替换成小写字母。
Returns nil if no changes were made.
如果str没有改变，返回nil。

#### dump  转储

    str.dump → string

Produces a version of str with all nonprinting characters replaced by \nnn notation and all special characters escaped.
产生str用\nnn表示法替换其所有非打印字符、同时转义所有特殊字符的版本。

#### each_byte  遍历字节

    str.each_byte → enum
    str.each_byte { |byte| … } → str

Synonym for String#bytes. 
同String#bytes。
The each_byte form is falling out of favor.
这个形式已经不再受欢迎了。

#### each_char  遍历字符  1.9

    str.each_char → enum
    str.each_char { |char| … } → str

Synonym for String#chars. 
同String#chars。
The each_char form is falling out of favor.
这个形式已经不再受欢迎了。

#### each_codepoint  遍历代码点  1.9

    str.each_codepoint → enum
    str.each_codepoint { |integer| … } → str

Synonym for String#codepoints.
同String#codepoints。

#### each_line  遍历每行

    str.each_line( sep=$/ ) → enum
    str.each_line( sep=$/ ) { |substr| … } → str}

Synonym for String#lines. 
同String#lines。
The each_line form is falling out of favor.
这个形式已经不再受欢迎了。

#### empty?  是否为空

    str.empty? → true or false

Returns true if str has a length of zero.
如果str长度为0,返回true。

    "hello".empty? # => false
    "".empty?  # => true

#### encode  编码  1.9

    str.encode → a_string
    str.encode( to_encoding ‹ , options › ) → a_string
    str.encode( to_encoding, from_encoding, ‹ , options › ) → a_string

Transcodes str, returning a new string encoded with `to_encoding`. 
将str转码，返回一个用`to_encoding`编码的新字符串。
If no encoding is given, transcodes using `default_internal` encoding. 
如果没有给定编码，使用默认的内部编码进行转码。
The source encoding is either the current encoding of the string or from_encoding. 
源编码可以是字符串的当前编码也可以是`from_encoding`。
May raise a RuntimeError if characters in the original string cannot be represented in the target encoding. 
如果源字符串的字符不能被目标编码所表达，可能抛出一个RuntimeError。
The options parameter defines the behavior for invalid transcodings and other boundary conditions. 
options参数定义了无效转码和其他边界条件的表现。
It can be a hash (recommended) or an or-ing of integer values.
它可以是一个散列表（推荐）或一个or-ing数值。
Encodings can be passed as Encoding objects or as names.
编码可以作为编码对象或者名字来传递。
Table 22—Options to encode and encode!  表格22--encode和encode!的选项。

    Option 选项                     Meaning  含义
    :replace => string             Specifies the string to use if :invalid or :undef options are present.
                                   指定string来使用，如果存在:invalid或者：undef选项。
                                   <kinder:note> 即这个选项的前提是下面两个选项。
                                   If not specified, uFFFD is used for Unicode encodings and ? for others.
                                   如不指定，Unicode编码用uFFD，其他编码使用?。
    :invalid => :replace           Replaces invalid characters in the source string with the replacement string. 
                                   用替代字符串来替代源码中无效的字符。
                                   If :invalid is not specified or nil, raises an exception.
                                   如果没有指定:invalid，或者nil，抛出异常。
    :undef => :replace             Replaces characters that are not available in the destination encoding with the replacement string. 
                                   用替代字符串来替代那些在目标编码中不可用的字符。
                                   If :undef not specified or nil, raises an exception.
                                   如果没有指定:undef，或者nil，抛出异常。
    :universal_newline => true     Converts crlf and cr line endings to lf.
                                   将crlf和cr行编码转化lf。
    :crlf_newline => true          Converts lf to crlf.
                                   将lf转换为crlf。
    :cr_newline => true            Converts lf to cr.
                                   将lf转换为cr。
    :xml => :text | :attr          After encoding, escape characters that would otherwise have special meaning in XML PCDATA or attributes. 
                                   编码之后，转义在XML PCDATA或属性中可能有其他特殊含义的字符。
                                   In all cases, converts & to &amp;, < to &lt;, > to &gt;, and undefined characters to a hexadecimal entity (&#xhh;). 
                                   在所有情况下，将&转换为 &amp;，将<转换为&lt;，将>转换为&gt;，将未定义字符转换为十六进制实体（&#xhh;）。
                                   For :attr, also converts " to &quot;.
                                   对于:attr，也将"转换为 &quot;。


# encoding: utf-8
ole_in_utf = "olé"
ole_in_utf.encoding  # => #<Encoding:UTF-8>
ole_in_utf.dump      # => "ol\u{e9}"
ole_in_8859 = ole_in_utf.encode("iso-8859-1")
ole_in_8859.encoding # => #<Encoding:ISO-8859-1>
ole_in_8859.dump # => "ol\xE9"

Using a default internal encoding of ISO-8859-1 and a source file encoding of UTF-8:
使用默认的内部编码ISO-8859-1，而源文件编码为UTF-8：

    #!/usr/local/rubybook/bin/ruby -E:ISO-8859-1
    # encoding: utf-8
    utf_string = "olé"
    utf_string.encoding # => #<Encoding:UTF-8>
    iso_string = utf_string.encode
    iso_string.encoding # => #<Encoding:ISO-8859-1>

Attempt to transcode a string with characters not available in the destination encoding:
尝试将字符串进行转码，但里面的字符在目标编码中无效：

    # encoding: utf-8
    utf = "∂og"
    utf.encode("iso-8859-1")
    # produces:
    # from prog.rb:3:in `<main>'
    # prog.rb:3:in `encode': U+2202 from UTF-8 to ISO-8859-1
    # (Encoding::UndefinedConversionError)

You can replace the character in error with something else:
你也可以用一些其他字符替代出错的字符。

    # encoding: utf-8
    utf = "∂og"
    utf.encode("iso-8859-1", undef: :replace) # => "?og"
    utf.encode("iso-8859-1", undef: :replace, replace: "X" ) # => "Xog"

#### encode!  编码  1.9

    str.encode! → str
    str.encode!( to_encoding ‹ , options › ) → str
    str.encode!( to_encoding, from_encoding, ‹ , options › ) → str

Transcodes str in place.
将str进行转码。

#### encoding  编码  1.9

    str.encoding → an_encoding

Returns the encoding of str.
返回str的编码。

    # encoding: utf-8
    "cat".encoding # => #<Encoding:UTF-8>

#### end_with?  是否这样结尾  1.9

    str.end_with?( ‹ suffix ›+ ) → true or false

Returns true if str ends with any of the given suffixes.
如果str用给定的后缀结尾，返回true。

    "Apache".end_with?("ache") # => true
    "ruby code".end_with?("python", "perl", "code") # => true

#### eql?  是否内容相同

    str.eql?( obj ) → true or false

Returns true if obj is a String with identical contents to str.
如果obj是一个字符串，内容和str相同，返回true。

    "cat".eql?("cat") # => true

#### force_encoding  强制编码  1.9

    str.force_encoding( encoding ) → str

Sets the encoding associated with str to encoding. 
将str相关编码设置为encoding。
Note that this does not change the underlying bytes in str—it simply tells Ruby how to interpret those bytes as characters.
注意这不会改变str的底层字符--只是告诉ruby怎么去将那些字节解释为字符。

    # encoding: utf-8
    ∂og_in_bytes = [226, 136, 130, 111, 103] # utf-8 byte sequence
    str = ∂og_in_bytes.pack("C*")
    str.encoding # => #<Encoding:ASCII-8BIT>
    str.length # => 5
    str.force_encoding("utf-8")
    str.encoding # => #<Encoding:UTF-8>
    str.length # => 3
    str # => "∂og"

#### getbyte  字节

    str.getbyte( offset ) → int or nil

Returns the byte at offset (starting from the end of the string if the offset is negative). 
返回offset偏移处的字节数（如果offset是负数则从字符串的结尾开始）
Returns nil if the offset lies outside the string.
如果offset位于字符串之外，返回nil。

    # encoding: utf-8
    str = "∂og"
    str.bytes.to_a #   => [226, 136, 130, 111, 103]
    str.getbyte(0) #   => 226
    str.getbyte(1) #   => 136
    str.getbyte(-1) #  => 103
    str.getbyte(99) #  => nil

#### gsub  模式替换

    str.gsub( pattern, replacement ) → string
    str.gsub( pattern ) { |match| … } → string
    str.gsub( pattern ) → enum

Returns a copy of str with all occurrences of pattern replaced with either replacement or the value of the block. 
返回str的一个拷贝，其中所有的pattern的出现处都用replacement或者block的值来替换。
The pattern will typically be a Regexp; if it is a String, then no regular expression metacharacters will be interpreted (that is, /\d/ will match a digit, but '\d' will match a backslash followed by a d).
通常pattern是一个正则表达式；如果它是一个字符串，则正则表达式的元字符将不会被解释（也就是说/\d/将匹配一个数字，但'\d'将匹配一条反斜线，后跟一个d）。
If a string is used as the replacement, special variables from the match (such as $& and $1) cannot be substituted into it, because substitution into the string occurs before the pattern match starts. 
如果一个字符串被 用作replacement，由匹配得到的那些特殊变量（例如$&和$1）将不能被替换到这个字符串中。因为在这个字符串中进行的替换发生在模式匹配开始之前。
However, the sequences \1, \2, and so on, may be used to interpolate successive numbered groups in the match, and \k<name> will substitute the corresponding named captures. 
当然，可以使用\1、\2等等序列，在匹配中插入连续的组；使用\k<name>替代对应的命名捕获。
These sequences are shown in the following table.
下表显式了这些序列。
Table 23—Backslash sequences in substitution  表格23--替换中的反斜杠序列

    Sequence 序列   Text That Is Substituted 替换的文本
    \1, \2, ... \9  The value matched by the nth grouped subexpression
                    被第n组子表达式匹配匹配的值。
    \&              The last match
                    最后的匹配。
    \`              The part of the string before the match
                    匹配之前的部分字符串
    \'              The part of the string after the match
                    匹配之后的部分字符串
    \+              The highest-numbered group matched
                    匹配最大编号的组。
    \k<name>        The named capture
                    命名捕获

In the block form, the current match is passed in as a parameter, and variables such as $1, $2, $`, $&, and $' will be set appropriately. 
带block的形式，当前的匹配会作为参数传入block，并且换适当地设置$1 $2 $` $&和$'等变量。
The value returned by the block will be substituted for the match on each call.
每次调用传入的匹配都被block的返回值所替代。
The result inherits any tainting in the original string or any supplied replacement string.
返回的结果继承了在初始字符串或任何给定的replacement字符串的污染状态。

    "hello".gsub(/[aeiou]/, '*')                  # => "h*ll*"
    "hello".gsub(/([aeiou])/, '<\1>')             # => "h<e>ll<o>"
    "hello".gsub(/./) {|s| s[0].to_s + ' '}       # => "h e l l o "
    "hello".gsub(/(?<double>l)/, '-\k<double>-')  # => "he-l--l-o"

If no block or replacement string is given, an enumerator is returned.
如果没有指定block或placement，将产生一个枚举。

    "hello".gsub(/../).to_a # => ["he", "ll"]

If a hash is given as the replacement, successive matched groups are looked up as keys, and the corresponding values are substituted into the string.
如果一个散列表被指定为replacement，连续的匹配组被找出来作为键，而对应的值被替换为字符串。

    repl = Hash.new("?")  #创建一个新的空散列表
    repl["a"] = "*"
    repl["t"] = "T"   # repl这时为：{"a" => "*", "t" => "T"}
    "cat".gsub(/(.)/, repl) # => "?*T"

#### gsub!  模式替换

    str.gsub!( pattern, replacement ) → string
    str.gsub!( pattern ) { |match| … } → string
    str.gsub!( pattern ) → enum

Performs the substitutions of String#gsub in place, returning str, or returning nil if no substitutions were performed. 
直接执行String#gsub替换，返回str，如果没有替换，返回nil。
If no block or replacement string is given, an enumerator is returned.
如果没有给定block或replacement，返回一个枚举对象。

#### hex  十六进制字符转换为数字

    str.hex → int

Treats leading characters from str as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the corresponding number. 
把str的那些前岛字符看作一个十六进制数字（带有可选的符号标记和可选0x）的字符串，返回相应的数值。
Zero is returned on error.
如果出错，返回0.

    "0x0a".hex   # => 10
    "-1234".hex  # => -4660
    "0".hex      # => 0
    "wombat".hex # => 0

#### include?  是否包含

    str.include?( string ) → true or false

Returns true if str contains the given string.
如果str包含了给定的string，返回true。

    "hello".include? "lo" # => true
    "hello".include? "ol" # => false
    "hello".include? ?h # => true

#### index  索引数

    str.index( string ‹ , offset › ) → int or nil
    str.index( regexp ‹ , offset › ) → int or nil

Returns the index of the first occurrence of the given substring or pattern in str. 
返回给定的子字符串、字符或模式的首次出现在str中的索引。
Returns nil if not found. 
如果未发现，返回nil。
If the second parameter is present, it specifies the position in the string to begin the search.
如果提供了第二个参数，指定在string内开始搜寻的位置。

    "hello".index('e')            # => 1
    "hello".index('lo')           # => 3
    "hello".index('a')            # => nil
    "hello".index(/[aeiou]/, -3)  # => 4

#### insert  插入  1.8

    str.insert( index, string ) → str

Inserts string before the character at the given index, modifying str. 
在给定index位置的字符前面把string插入，同时修改str。
Negative indices count from the end of the string and insert after the given character. 
如果index是一个负数，就从string的结尾处开始数起，并在给定的字符后面把string插入。
After the insertion, str will contain string starting at index.
插入完成后，str包含了从index位置开始的string。

    "abcd".insert(0, 'X')  # => "Xabcd"
    "abcd".insert(3, 'X')  # => "abcXd"
    "abcd".insert(4, 'X')  # => "abcdX"
    "abcd".insert(-3, 'X') # => "abXcd"
    "abcd".insert(-1, 'X') # => "abcdX"

#### intern   符号化  1.8

    str.intern → symbol

Returns the Symbol corresponding to str, creating the symbol if it did not previously exist.
返回对应于str的符号，如果原先不存在这个符号，就创建它。
Can intern any string, not just identifiers. 
可以符号化任何字符串，而不仅仅是标识符。
See Symbol#id2name on page 700.
参见后面2版631页4版700页的Symbol#id2nam。

    "Koala".intern # => :Koala
    sym = "$1.50 for a soda!?!?".intern
    sym.to_s # => "$1.50 for a soda!?!?"

#### length  长度

    str.length → int

Returns the number of characters in str. See also String#bytesize.
返回str的长度。

#### lines  分行 ⇡New in 2.0⇣

    str.lines( sep=$/ ) → enum | array
    str.lines( sep=$/ ) { |substr| … } → str}

Splits str using the supplied parameter as the record separator ($/ by default) and passing each substring in turn to the supplied block. 
使用提供的参数作为记录分隔符（默认是$/）将str分割，并将分割的每个子字符串依次传递给提供的block。
If a zero-length record separator is supplied, the string is split into paragraphs, each terminated by multiple \n characters. 
如果提供了一个0长度的记录分隔符，字符串被分割成段落，每个段落用多个\n字符结束。
With no block, returns a enumerator (Ruby 1.9) or an array (Ruby 2.0).
如果没有block，返回一个枚举（Ruby 1.9）或一个数组（Ruby 2.0）。

    print "Example one\n"                    # Example one
    "hello\nworld".lines {|s| p s}           # "hello\n"
                                             # "world"
    print "Example two\n"                    # Example two
    "hello\nworld".lines('l') {|s| p s}      # "hel"
                                             # "l"
                                             # "o\nworl"
                                             # "d"
    print "Example three\n"                  # Example three
    "hello\n\n\nworld".lines('') {|s| p s}   # "hello\n\n\n"

#### ljust  左对齐  1.8

    str.ljust( width, padding=" " ) → string

If width is greater than the length of str, returns a new String of length width with str left justified and padded with copies of padding; otherwise, returns a copy of str.
如果width大于str的长度，返回新的字符串，长度为width，其中str左对齐，用padding填充剩下的空间；否则，返回str的一个拷贝。

    "hello".ljust(4)             # => "hello"
    "hello".ljust(20)            # => "hello␣␣␣␣␣␣␣␣␣␣␣␣␣␣
                                 # .. ␣"
    "hello".ljust(20, "*")       # => "hello***************"
    "hello".ljust(20, " dolly")  # => "hello␣dolly␣dolly␣do"

#### lstrip  删前空格  1.8

    str.lstrip → string

Returns a copy of str with leading whitespace characters removed. 
返回str的一个拷贝，删除其中的前导空格字符。
Also see String#rstrip and String#strip.
另见String#rstrip和#strip。

    " hello ".lstrip # => "hello␣␣"
    "\000 hello ".lstrip # => "\0␣hello␣␣"
    "hello".lstrip # => "hello"

#### lstrip!  删前空格  1.8

    str.lstrip! → str or nil

Removes leading whitespace characters from str, returning nil if no change was made. 
删除str中的前导空格字符，如果没有修改字符则返回nil。
See also String#rstrip! and String#strip!.
另见String#rstrip!和#strip!。

    " hello ".lstrip! # => "hello␣␣"
    "hello".lstrip! # => nil

#### match  匹配  1.8

    str.match( pattern ) → match_data or nil
    str.match( pattern ) { |matchdata| … } → obj

Converts pattern to a Regexp (if it isn’t already one) and then invokes its match method on str.
如果pattern还不是一个正则表达式，把pattern转换成一个；同时对str调用这个正则表达式的match方法。
If a block is given, the block is passed the MatchData object, and the match method returns the value of the block.
如果给定了block，block将会被传入MatchData对象，而match方法返回block的值。
<kinder:note> 什么什么？？翻译错误吧！正确的理解应该是：block对MatchData对象进行操作。

    'seed'.match('(.)\1')                   # => #<MatchData "ee" 1:"e">
    'seed'.match('(.)\1')[0]                # => "ee"
    'seed'.match(/(.)\1/)[0]                # => "ee"
    'seed'.match('ll')                      # => nil
    'seed'.match('ll') {|md| md[0].upcase } # => nil
    'seed'.match('xx')                      # => nil

#### next  下一个

    str.next → string

Synonym for String#succ.
同String#succ。

#### next!  下一个

    str.next! → str

Synonym for String#succ!.
同String#succ!。

#### oct  八进制字符转换数字

    str.oct → int

Treats leading characters of str as a string of octal digits (with an optional sign) and returns the corresponding number. 
将str开头的若干字符看作一个八进制数字（带有可选的符号标记）的字符串，同时返回相应的数字。
Returns 0 if the conversion fails.
如果转换失败，返回0.

    "123".oct       # => 83
    "-377".oct      # => -255
    "bad".oct       # => 0
    "0377bad".oct   # => 255

#### ord  首符代码点  1.9

    str.ord → int

Returns the integer code point of the first character of str.
返回str第一个字符的整数代码点。

    # encoding: utf-8
    "d".ord # => 100
    "dog".ord # => 100
    "∂".ord # => 8706

#### partition  分开  1.9

    str.partition( pattern ) → [ before, match, after ]

Searches str for pattern (which may be a string or a regular expression). 
在str搜索pattern（可以是一个字符串，或正则表达式）。
Returns a three-element array containing the part of the string before the pattern, the part that matched the pattern, and the part after the match. 
返回一个具有三个元素的数组，包含pattern之前的部分字符串，匹配pattern的部分字符串，pattern之后的部分字符串。
If the pattern does not match, the entire string will be returned as the first element of the array, and the other two entries will be empty strings.
如果pattern不能匹配，整个字符串将被返回作为数组的第一个元素，另外两个元素是空字符串。

    "THX1138".partition("11") # => ["THX", "11", "38"]
    "THX1138".partition(/\d\d/) # => ["THX", "11", "38"]
    "THX1138".partition("99") # => ["THX1138", "", ""]

#### prepend  前缀  1.9

    str.prepend( other ) → str

Inserts other at the beginning of str.
在str的开头插入other。

    str = "1138"
    str.prepend("THX") # => "THX1138"
    str # => "THX1138"

#### replace  替换字符串

    str.replace( string ) → str

Replaces the contents, encoding, and taintedness of str with the corresponding values in string.
用string的相应值替换str的内容、编码和受污染度。

    s = "hello" # => "hello"
    s.replace "world" # => "world"

#### reverse  反转

    str.reverse → string

Returns a new string with the characters from str in reverse order.
返回新的字符串，字符顺序和str相反。

    # Every problem contains its own solution...
    "stressed".reverse # => "desserts"

#### reverse!  反转

    str.reverse! → str

Reverses str in place.
将stt反转。

#### rindex  最后匹配处索引

    str.rindex( string ‹ , int › ) → int or nil
    str.rindex( regexp ‹ , int › ) → int or nil

Returns the index of the last occurrence of the given substring, character, or pattern in str.
返回给定的子字符串，字符或模式在str中最后出现的索引。
Returns nil if not found. 
如果未发现，返回nil。
If the second parameter is present, it specifies the position in the string to end the search—characters beyond this point will not be considered.
如果给出了第二个参数，它指定了在这个字符串中搜寻的结束位置--超过这个位置的字符将将不会被考虑。

    "hello".rindex('e')             # => 1
    "hello".rindex('l')             # => 3
    "hello".rindex('a')             # => nil
    "hello".rindex(/[aeiou]/, -2)   # => 1

#### rjust  右对齐  1.8

    str.rjust( width, padding=" " ) → string

If width is greater than the length of str, returns a new String of length width with str right justified and padded with copies of padding; otherwise, returns a copy of str.
如果width大于str的长度，返回新的字符串，长度为width，其中str右对齐，并且用padding填充剩余的空间；否则，返回str的一个拷贝。

    "hello".rjust(4)             # => "hello"
    "hello".rjust(20)            # => "␣␣␣␣␣␣␣␣␣␣␣␣␣␣␣h
                                 # .. ello"
    "hello".rjust(20, "-")       # => "---------------hello"
    "hello".rjust(20, "padding") # => "paddingpaddingphello"

#### rpartition  右分开

    str.rpartition( pattern ) → [ before, match, after ]

Searches str for pattern (which may be a string or a regular expression), starting at the end of the string. 
在str中搜索pattern（可以是一个字符串或一个正则表达式），从字符串的结尾处开始。
Returns a three-element array containing the part of the string before the pattern, the part that matched the pattern, and the part after the match. 
返回一个三元素数组，包含pattern之前的字符串，匹配pattern的部分字符串，匹配之后的部分字符串。
If the pattern does not match, the entire string will be returned as the last element of the array, and the other two entries will be empty strings.
如果pattern不能匹配，整个字符串将被返回作为数组的第一个元素，另外两个元素是空字符串。

    "THX1138".rpartition("1") # => ["THX1", "1", "38"]
    "THX1138".rpartition(/1\d/) # => ["THX1", "13", "8"]
    "THX1138".rpartition("99") # => ["", "", "THX1138"]

#### rstrip  删后空格  1.8

    str.rstrip → string

Returns a copy of str, stripping first trailing null characters and then stripping trailing whitespace characters. 
返回str的一个拷贝，删除第一个结尾的null字符，然后删除结尾的空格字符。
See also String#lstrip and String#strip.
另见String#lstrip和#strip。

    " hello ".rstrip       # => "␣␣hello"
    " hello \000 ".rstrip  # => "␣␣hello"
    " hello \000".rstrip   # => "␣␣hello"
    "hello".rstrip         # => "hello"

#### rstrip!  删后空格  1.8

    str.rstrip! → str or nil

Removes trailing null characters and then removes trailing whitespace characters from str.
删除str的结尾null字符，然后删除结尾的空格字符。
Returns nil if no change was made. 
如果没有做出任何修改，返回nil。
See also String#lstrip! and #strip!.
另见String#lstrip!和#strip!。

    " hello ".rstrip! # => "␣␣hello"
    "hello".rstrip!  # => nil

#### scan  搜索模式

    str.scan( pattern ) → array
    str.scan( pattern ) { |match, ...| … } → str}

Both forms iterate through str, matching the pattern (which may be a Regexp or a String). 
两种形式都通过匹配pattern（可能是一个正则表达式，或是一个字符串），来迭代str。
For each match, a result is generated and either added to the result array or passed to the block.
每次匹配会生成一个结果，然后把结果添加到这个结果数组中，或者传递给block。
If the pattern contains no groups, each individual result consists of the matched string, $&.
如果pattern没有包含任何组，每个结果由匹配的字符串$&组成。
If the pattern contains groups, each individual result is itself an array containing one entry per group. 
如果pattern包含了组，每个结果本身就是一个数组，其中每组是一项。
If the pattern is a String, it is interpreted literally (in other words, it is not taken to be a regular expression pattern).
如果pattern是一个字符串，就从字面意义上解释它（即不会把它当作一个正则表达式）。

    a = "cruel world"
    a.scan(/\w+/)       # => ["cruel", "world"]
    a.scan(/.../)       # => ["cru", "el ", "wor"]
    a.scan(/(...)/)     # => [["cru"], ["el "], ["wor"]]
    a.scan(/(..)(..)/)  # => [["cr", "ue"], ["l ", "wo"]]

And the block form:
block的形式：

    a.scan(/\w+/) {|w| print "<<#{w}>> " }
    puts
    a.scan(/(.)(.)/) {|a,b| print b, a }
    puts
    # produces:
    # <<cruel>> <<world>>
    # rceu lowlr

#### setbyte  设定字符

    str.setbyte( offset, byte ) → byte

Sets the byte at offset (starting from the end of the string if the offset is negative) to byte.
将在offset处的byte设置为byte。
Cannot be used to change the length of the string. 
不能用于改变字符串的长度。
<kinder:note> 可是下面的例子说明字符串的长度发生了改变！
Does not change the encoding of the string.
不能改变字符串的编码。

    str = "defog"
    # a utf-8 delta character
    str.setbyte(0, 226) # => 226
    str.setbyte(1, 136) # => 136
    str.setbyte(2, 130) # => 130
    str                 # => "∂og"
    str.length          # => 3
    str.force_encoding("utf-8")
    str.length          # => 3
    str                 # => "∂og"

#### size  长度

    str.size → int

Synonym for String#length.
同String#length。

#### slice  切片(元素引用)

    str.slice( int ) → string or nil
    str.slice( int, int ) → string or nil
    str.slice( range ) → string or nil
    str.slice( regexp ) → string or nil
    str.slice( match_string ) → string or nil

Synonym for String#[].
同String#[]

    a = "hello there"
    a.slice(1)           # => "e"
    a.slice(1,3)         # => "ell"
    a.slice(1..3)        # => "ell"
    a.slice(-3,2)        # => "er"
    a.slice(-4..-2)      # => "her"
    a.slice(-2..-4)      # => ""
    a.slice(/th[aeiou]/) # => "the"
    a.slice("lo")        # => "lo"
    a.slice("bye")       # => nil

#### slice!  切片

    str.slice!( int ) → string or nil
    str.slice!( int, int ) → string or nil
    str.slice!( range ) → string or nil
    str.slice!( regexp ) → string or nil
    str.slice!( match_string ) → string or nil

Deletes the specified portion from str and returns the portion deleted. 
从str删除指定的部分子字符串，同时返回被删除的部分。
The forms that take a Fixnum will raise an IndexError if the value is out of range; the Range form will raise a RangeError, and the Regexp and String forms will silently not change the string.
如果指定的值超出了字符串的范围，接受一个int的形式会引发IndexError；而接受一个range的形式会引发RangeError；接受regexp和`match_string`的形式则静默、不会修改字符串。

    string = "this is a string"
    string.slice!(2) # => "i"
    string.slice!(3..6) # => " is "
    string.slice!(/s.*t/) # => "sa st"
    string.slice!("r") # => "r"
    string # => "thing"

#### split  分割

    str.split( pattern=$;, ‹ limit › ) → array

Divides str into substrings based on a delimiter, returning an array of these substrings.
基于分隔符把str分割成若干字符串，组成一个数组并返回。

If pattern is a String, then its contents are used as the delimiter when splitting str. 
如果pattern是一个字符串，那么它的内容被当作这个分隔符来对str进行分割。
If pattern is a single space, str is split on whitespace, with leading whitespace and runs of contiguous whitespace characters ignored.
如果pattern是一个空格，str会在空格处分开，忽视前导空格和后面连续的空格。

If pattern is a Regexp, str is divided where the pattern matches. 
如果pattern是一个正则表达式，str会在匹配这个模式的位置分开。
Whenever the pattern matches a zero-length string, str is split into individual characters. 
无论何时当这个模式匹配了一个长度为0的字符串，str会被分隔成单个字符。
If pattern includes groups, these groups will be included in the returned values.
如果pattern包含了组，那些组将会包含在返回的值中。

If pattern is omitted, the value of $; is used. 
如果省略了pattern参数，它会使用变量$;的值。
If $; is nil (which is the default), str is split on whitespace as if “␣” were specified.
如果$;是nil（这是默认值），str会在空格处分开，就如同指定“␣”为分隔符。

If the limit parameter is omitted, trailing empty fields are suppressed. 
如果省略了limit参数，它会抑制结尾的空字符。
If limit is a positive number, at most that number of fields will be returned (if limit is 1, the entire string is returned as the only entry in an array). 
如果limit是正数，最多可能返回那个数目的字段数（如果limit是1,整个字符串会作为数组的唯一元素被返回）。
If negative, there is no limit to the number of fields returned, and trailing null fields are not suppressed.
如果limit是负数，对于要返回的字段数不会有任何限制，同时也不会抑制结尾的空字符。

    " now's the time".split        # => ["now's", "the", "time"]
    " now's the time".split(' ')   # => ["now's", "the", "time"]
    " now's the time".split(/ /)   # => ["", "now's", "", "", "the", "time"]
    "a@1bb@2ccc".split(/@\d/)      # => ["a", "bb", "ccc"]
    "a@1bb@2ccc".split(/@(\d)/)    # => ["a", "1", "bb", "2", "ccc"]
    "1, 2.34,56, 7".split(/,\s*/)  # => ["1", "2.34", "56", "7"]
    "hello".split(//)              # => ["h", "e", "l", "l", "o"]
    "hello".split(//, 3)           # => ["h", "e", "llo"]
    "hi mom".split(/\s*/)          # => ["h", "i", "m", "o", "m"]
    "".split                       # => []
    "mellow yellow".split("ello")  # => ["m", "w y", "w"]
    "1,2,,3,4,,".split(',')        # => ["1", "2", "", "3", "4"]
    "1,2,,3,4,,".split(',', 4)     # => ["1", "2", "", "3,4,,"]  分成四部分
    "1,2,,3,4,,".split(',', -4)    # => ["1", "2", "", "3", "4", "", ""]

#### squeeze  挤压

    str.squeeze( ‹ string ›* ) → squeezed_string

The parameter(s) specify a set of characters using the procedure described for String#count on page 673. 
使用前面2版611页4版673页描述的String#count的步骤，用string参数构造一个字符集合。
Returns a new string where runs of the same character that occur in this set are replaced by a single character. 
返回新的字符串，出现在这个字符集合中的相同连续字符都会被单个字符替代。
If no arguments are given, all runs of identical characters are replaced by a single character.
如果没有给出任何参数，字符串中所有相同的连续字符都会被单个字符替代。

    "yellow moon".squeeze # => "yelow mon"
    " now is the".squeeze(" ") # => " now is the"
    "putters putt balls".squeeze("m-z") # => "puters put balls"

#### squeeze!  挤压

    str.squeeze!( ‹ string ›* ) → str or nil

Squeezes str in place, returning str. 
直接对str进行挤压，同时返回str。
Returns nil if no changes were made.
如果没有作出任何修改，返回nil。

#### start_with?  是否前缀

    str.start_with?( ‹ prefix ›+ ) → true or false

Returns true if str starts with any of the given prefixes.
如果str用指定的前缀，返回true。

    "Apache".start_with?("Apa") # => true
    "ruby code".start_with?("python", "perl", "ruby") # => true

#### strip  删除空格  1.8

    str.strip → string

Returns a new string, stripping leading whitespace and trailing null and whitespace characters from str.
返回str的一个拷贝，删除它开头的空格、结尾的null和空格字符。

    " hello ".strip         # => "hello"
    "\tgoodbye\r\n".strip   # => "goodbye"
    "goodbye \000".strip    # => "goodbye"
    "goodbye \000 ".strip   # => "goodbye"

#### strip!  删除空格  1.8

    str.strip! → str or nil

Removes leading whitespace and trailing null and whitespace characters from str. 
从str删除开头的空格、结尾的null和空格字符。
Returns nil if str was not altered.
如果str没有改变，返回nil。

#### sub  替换第一个匹配

    str.sub( pattern, replacement ) → string
    str.sub( pattern ) { |match| … } → string

Returns a copy of str with the first occurrence of pattern replaced with either replacement or the value of the block. 
返回str的一个拷贝，用replacement或者block的值替换出现在str中的第一个pattern。
See the description of String#gsub on page 677 for a description of the parameters.
详见前面677页描述String#gsub里对参数的描述。

    "hello".sub(/[aeiou]/, '*')                     # => "h*llo"
    "hello".sub(/([aeiou])/, '<\1>')                # => "h<e>llo"
    "hello".sub(/./) {|s| s[0].to_s + ' '}          # => "h ello"
    "hello".sub(/(?<double>l)/, '-\k<double>-')     # => "he-l-lo"

#### sub!  替换第一个匹配

    str.sub!( pattern, replacement ) → str or nil
    str.sub!( pattern ) { |match| … } → str or nil

Performs the substitutions of String#sub in place, returning str. 
直接对str执行String#sub替换，同时返回str。
Returns nil if no substitutions were performed.
如果没有替换，返回nil。

#### succ  进位

    str.succ → string

Returns the successor to str. 
返回str的successor。
The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. 
通过增加在这个字符串中最右边的字母数字（如果步长字母数字，或者最右边的字符）来得到这个successor。
Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. 
增加一个数字总是会导致产生另一个数字，同时增加一个字母总是会导致产生大小写相同的另一个字母。
Incrementing nonalphanumerics uses the underlying character set’s collating sequence.
使用底层的字符集的排序序列来增加非字母数字序列。
If the increment generates a “carry,” the character to the left of it is incremented. 
如果这个增加产生一次“进位”，它会继续增加其左边的字符。
This process repeats until there is no carry, adding a character if necessary. 
这个过程会一直重复，直到没有进位产生为止，如果必要，会添加一个字符。
An exception is when the carry is generated by a sequence of digits in a string containing digits, nonalpha characters, and more digits, in which case the carry applies to the digits. 
一个例外是：当进位是由一个数字序列，该序列在字符串中，包含数字、非字母字符和更多数字，在这个情况进位应用到数字上。
This allows for incrementing (for example) numbers with decimal places.
这允许在十进制位增加数字。

    "abcd".succ        # => "abce"
    "THX1138".succ     # => "THX1139"
    "<<koala>>".succ   # => "<<koalb>>"
    "1999zzz".succ     # => "2000aaa"
    "ZZZ9999".succ     # => "AAAA0000"
    "***".succ         # => "**+"
    "1.9".succ         # => "2.0"
    "1//9".succ        # => "2//0"
    "1/9/9/9".succ     # => "2/0/0/0"
    "1x9".succ         # => "1y0"

#### succ!  进位

    str.succ! → str

Equivalent to String#succ but modifies the receiver in place.
等同于String#succ，但直接修改这个接收者。

#### sum  检验和  1.8

    str.sum( n=16 ) → int

Returns a basic n-bit checksum of the characters in str, where n is the optional parameter, defaulting to 16. 
返回str中字符一个基本的n为检验和，这里n是可选的参数，默认16.
The result is simply the sum of the binary value of each character in str modulo `2**n -1`. 
对str中每个字符的二进制值简单求和，然后用`2**n- 1`求模，得到这个校验和。
This is not a particularly good checksum—see the digest libraries on page 747 for better alternatives.
这不是一个特别号的检验和--要使用更好的检验和，参见后面2版668页4版747页的digest库。

    "now is the time".sum # => 1408
    "now is the time".sum(8) # => 128

#### swapcase  大小写互换

    str.swapcase → string

Returns a copy of str with uppercase alphabetic characters converted to lowercase and lowercase characters converted to uppercase. 
返回str的一个拷贝，把其中的大写字母都转换成小写，同时把小写字母都转换成大写。
The mapping depends on the string encoding, but not all encodings produce expected results.
具体的映射依赖字符串的编码，但不是所有的编码都产生期待的结果。

    # encoding: utf-8
    "Hello".swapcase # => "hELLO"
    "cYbEr_PuNk11".swapcase # => "CyBeR_pUnK11"
    "∂Og".swapcase # => "∂oG"

#### swapcase!  大小写互换

    str.swapcase! → str or nil

Equivalent to String#swapcase but modifies str in place, returning str. 
等同于String#swapcase，但直接对str进行修改，同时返回它。
Returns nil if no changes were made.
如果没有修改，返回nil。

#### to_c  转为复数  1.9

    str.to_c → complex

Returns the result of interpreting leading characters in str as a complex number. 
将str里的前导字符解释为一个复数，并返回结果。
Extraneous characters past the end of a valid number are ignored. 
有效字符结尾之后的额外字符将被忽略。
If there is not a valid number at the start of str, Complex(0,0) is returned. 
如果在str的开头没有有效数字，返回Complex(0,0)。
The method never raises an exception.
这个方法不会抛出异常。

    "123".to_c         # => 123+0i
    "4+5/6i".to_c      # => 4+5/6i
    "thx1138".to_c     # => 0+0i

#### to_f  转换为浮点

    str.to_f → float

Returns the result of interpreting leading characters in str as a floating-point number.
将str里的前导字符解释为一个浮点数，并返回结果。
Extraneous characters past the end of a valid number are ignored. 
有效字符结尾之后的额外字符将被忽略。
If there is not a valid number at the start of str, 0.0 is returned. 
如果在str的开头没有有效数字，返回0.0。
The method never raises an exception (use Object#Float to validate numbers).
这个方法不会抛出异常（使用Object#Float来验证数字）。

    "123.45e1".to_f # => 1234.5
    "45.67 degrees".to_f # => 45.67
    "thx1138".to_f # => 0.0

#### to_i  转换为整数  1.8

    str.to_i( base=10 ) → int

Returns the result of interpreting leading characters in str as an integer base base (2 to 36).
对str中开头的字符进行解释，返回以base（2到36）为进制的整数。
Given a base of zero, to_i looks for leading 0, 0b, 0o, 0d, or 0x and sets the base accordingly.
如果给定的进制为0,`to_i`会寻找0、0b、0o、0d或者0x前缀，并且相应地设置进制。
Leading spaces are ignored, and leading plus or minus signs are honored. 
前导空格会被忽视，同时接受开头的加号或者减号。
Extraneous characters past the end of a valid number are ignored. 
忽视有效数字部分之后的那些无关字符。
If there is not a valid number at the start of str, 0 is returned. 
如果str的首字符不是一个有效数字，返回0.
The method never raises an exception.
这个方法不会引发异常。

    "12345".to_i             # => 12345
    "99 red balloons".to_i   # => 99
    "0a".to_i                # => 0
    "0a".to_i(16)            # => 10
    "0x10".to_i              # => 0
    "0x10".to_i(0)           # => 16
    "-0x10".to_i(0)          # => -16
    "hello".to_i(30)         # => 14167554
    "1100101".to_i(2)        # => 101
    "1100101".to_i(8)        # => 294977
    "1100101".to_i(10)       # => 1100101
    "1100101".to_i(16)       # => 17826049

#### to_r  转换成有理数  1.9

    str.to_r → rational

Returns the result of interpreting leading characters in str as a rational number. 
将str里的前导字符解释为一个有理数，并返回结果。
Extraneous characters past the end of a valid number are ignored. 
忽视有效数字部分之后的那些无关字符。
If there is not a valid number at the start of str, Rational(0,1) is returned. 
如果在str的开头没有有效数字，返回(0,1)。
The method never raises an exception.
这个方法不会引发异常。

    "123".to_r        # => 123/1
    "5/6".to_r        # => 5/6
    "5/six".to_r      # => 5/1
    "thx1138".to_r    # => (0/1)

#### to_s  转换成字符串

    str.to_s → str

Returns the receiver.
返回这个接收者。

#### to_str  转换为字符串

    str.to_str → str

Synonym for `String#to_s`. 
同`String#to_s`。
<kinder:note> 真好奇两者的不同。假如没有实质上的差异，是不会产生第二种方法的。
`to_str` is used by methods such as String#concat to convert their arguments to a string. 
String#concat等方法会使用`to_str`把它们的参数转换成字符串。
Unlike `to_s`, which is supported by almost all classes, `to_str` is normally implemented only by those classes that act like strings. 
不像`to_s`，几乎所有的类都支持`to_s`，而`to_str`方法一般只是实现在那些类似字符串的类中。
Of the built-in classes, only Exception and String implement `to_str`.
在内建类中，只有Exception和String实现了`to_str`。

#### to_sym  转换为符号

    str.to_s → symbol

Returns the symbol for str. 
返回str的符号。
This can create symbols that cannot be represented using the :xxx notation. 
这可以创建那些不能使用:xxx表示法来表示的符号。
A synonym for String#intern.
等同于String#instern。

    s = 'cat'.to_sym      # => :cat
    s == :cat             # => true
    'cat and dog'.to_sym  # => :"cat and dog"
    s == :'cat and dog'   # => false

#### tr  逐字翻译

    str.tr( from_string, to_string ) → string

Returns a copy of str with the characters in `from_string` replaced by the corresponding characters in `to_string`. 
返回str的一个拷贝，用`to_string`相应字符替换`from_string`的字符。
If `to_string` is shorter than `from_string`, it is padded with its last character.
如果`to_string`长度比`from_string`短，就会用`to_string`的最后一个字符来填充 。
Both strings may use the c1–c2 notation to denote ranges of characters, and `from_string` may start with a ^, which denotes all characters except those listed.
这两个字符串可能都使用c1-c2表示法来表示字符的区间，同时`from_string`可能以一个^字符开始，表示除了这些给定字符之外的所有字符。

    "hello".tr('aeiou', '*')   # => "h*ll*"
    "hello".tr('^aeiou', '*')  # => "*e**o"
    "hello".tr('el', 'ip')     # => "hippo"
    "hello".tr('a-y', 'b-z')   # => "ifmmp"

#### tr!  逐字翻译

    str.tr!( from_string, to_string ) → str or nil

Translates str in place, using the same rules as String#tr. 
使用String#tr相同的规则直接对str进行修改。
Returns str or returns nil if no changes were made.
如果没有修改，返回nil。

#### tr_s  逐字翻译并合并翻译

    str.tr_s( from_string, to_string ) → string

Processes a copy of str as described under String#tr and then removes duplicate characters in regions that were affected by the translation.
像String#tr描述的那样处理str的一个拷贝，然后在替换发生的区域删除重复字符。

    "hello".tr_s('l', 'r') # => "hero"
    "hello".tr_s('el', '*') # => "h*o"
    "hello".tr_s('el', 'hx') # => "hhxo"

#### tr_s!   逐字翻译并合并翻译

    str.tr_s!( from_string, to_string ) → str or nil

Performs `String#tr_s` processing on str in place, returning str. 
直接对str进行`String#tr_s`处理，同时返回它。
Returns nil if no changes were made.
如果没有做出修改，返回nil。

#### unpack  解包  1.8

    str.unpack( format ) → array

Decodes str (which may contain binary data) according to the format string, returning an array of the extracted values. 
基于format字符串对str（可能包含二进制数据）进行解码，返回一个含有析取值的数组。
The format string consists of a sequence of single-character directives, summarized in Table 24, Directives for unpack, on page 692. 
format字符串由单个字符的指令序列构成，在下表24 解包指令中有摘要。
Each directive may be followed by a number, indicating the number of times to repeat this directive. 
每个指令后面可能跟有一个数字，它指出重复执行这个指令的次数。
An asterisk (`*`) will use up all remaining elements. 
星号将处理所有剩余的元素。
The directives sSiIlL may each be followed by an underscore (`_`) or bang (!} to use the underlying platform’s native size for the specified type; otherwise, it uses a platform-independent consistent size. 
sSiIlL指令后面可能跟着一个下划线或感叹号，以使用这种指定类型在底层平台上的本机大小；否则，它们会使用一个与平台无关的一致大小。
The directives s S i I l L q Q may be followed by a less than sign to signify little endian or greater than sign for big endian. 
指令sSiIlLqQ可能跟着一个表示小端的小于号，或一个表示大端的大于号。
Spaces are ignored in the format string. 
format字符串里的空格会被忽略。
Comments starting with # to the next newline or end of string are also ignored. 
注释以#开始，直到遇到下一个换行符或字符串结束为止，注释也会被忽略。
The encoding of the string is ignored; unpack treats the string as a sequence of bytes. 
字符串的编码会被忽略；unpack会把字符串当作一系列的字节。
See also Array#pack on page 432.
另见前面2版436页4版432页的Array#pack。

    "abc \0\0abc \0\0".unpack('A6Z6')  # => ["abc", "abc "]
    "abc \0\0".unpack('a3a3')          # => ["abc", " \0\0"]
    "aa".unpack('b8B8')                # => ["10000110", "01100001"]
    "aaa".unpack('h2H2c')              # => ["16", "61", 97]
    "\xfe\xff\xfe\xff".unpack('sS')    # => [-2, 65534]
    "now=20is".unpack('M*')            # => ["now is"]
    "whole".unpack('xax2aX2aX1aX2a')   # => ["h", "e", "l", "l", "o"]

Table 24—Directives for String#unpack   表格24 String#unpack指令
Format格式 Returns返回值 Function功能
A          String        Sequence of bytes with trailing nulls and ASCII spaces removed.
                         一个以null结尾并删除了空格的字节序列。
a          String        Sequence of bytes.
                         字符串。
B          String        Extracts bits from each byte (MSB first).
                         提取每个字节的位（MSB在前）。
b          String        Extracts bits from each byte (LSB first).
                         提取每个字节的为（LSB在前）
C          Fixnum        Extracts a byte as an unsigned integer.
                         将一个字节作为无符号整数提取出来。
c          Fixnum        Extracts a byte as an integer.
                         将一个字节作为整数提取出来。
d,D        Float         Treat sizeof(double) bytes as a native double.
                         将sizeof(double)个字节视为本机的双精度浮点数。
E          Float         Treats sizeof(double) bytes as a double in little-endian byte order.
                         将sizeof(double)个字节视为小端字节顺序的双精度浮点数。
e          Float         Treats sizeof(float) bytes as a float in little-endian byte order.
                         将sizeof(float)个字节视为小端字节顺序的双精度浮点数。
f,F        Float         Treats sizeof(float) bytes as a native float.
                         将sizeof(float)个字节视为本机的双精度浮点数。
G          Float         Treats sizeof(double) bytes as a double in network byte order.
                         将sizeof(float)个字节视为网络字节顺序的双精度浮点数。
g           Float        Treats sizeof(float) bytes as a float in network byte order.
                         将sizeof(float)个字节视为网络字节顺序的浮点数。
H           String        Extracts hex nibbles from each byte (most significant first).
                          提取每个字符的4位十六进制值（最高有效数位在前）
h           String        Extracts hex nibbles from each byte (least significant first).
                          提取每个字符的4位十六进制值（最高有效数位在后）
I           Integer       Treats sizeof(int)° successive bytes as an unsigned native integer.
                          将sizeof(int)的连续字节视为一个无符号的本机整数。
i           Integer       Treats sizeof(int)° successive bytes as a signed native integer.
                          将sizeof(int)的连续字节视为一个有符号的本机整数。
L           Integer       Treats four° successive bytes as an unsigned native long integer.
                          将四个连续字节视为一个无符号的本机整数。 
l           Integer       Treats four° successive characters as a signed native long integer. 
                          将四个连续字节视为一个有符号的本机整数。 
M           String        Extracts a quoted-printable string.
                          提取一个引用可打印的字符。
m           String        Extracts a Base64-encoded string. By default, accepts \n and \r. "m0" rejects these.
                          提取一个Base64编码的字符串。默认接受\n和\r，"m0"则不接受这些。
N           Fixnum        Treats four bytes as an unsigned long in network byte order.
                          将四个字符视为一个网络字节顺序的无符号的长整数。
n           Fixnum        Treats two bytes as an unsigned short in network byte order.
                          将二个字符视为一个网络字节顺序的无符号的长整数。
P           String        Treats sizeof(char *) bytes as a pointer and returns len bytes from the referenced location.
                          将sizeof(char *)个字节视为一个指针，并从指定的位置返回len个字符
p           String        Treats sizeof(char *) bytes as a pointer to a null-terminated string.
                          将sizeof(char *)个字节视为一个指针，指向一个null结尾的字符串
Q           Integer       Treats eight bytes as an unsigned quad word (64 bits).
                          将8个字节视为一个无符号的四个字（64位）

q           Integer       Treats eight bytes as a signed quad word (64 bits).
                          将8个字节视为一个有符号的四个字（64位）
S           Fixnum        Treats two° bytes characters as an unsigned short in native byte order.
                          将两个连续的字符视为一个本机字节顺序的无符号整数。
s           Fixnum        Treats two° successive bytes as a signed short in native byte order.
                          将两个连续的字符视为一个本机字节顺序的有符号整数。
U           Integer       Extracts UTF-8 characters as unsigned integers.
                          将一个UTF-8字符提取为无符号整数。
u           String        Extracts a UU-encoded string.
                          提取一个UU编码的字符串。
V           Fixnum        Treats four bytes as an unsigned long in little-endian byte order.
                          将四个字符视为一个小端 字节顺序的无符号长整数。
v           Fixnum        Treats two bytes as an unsigned short in little-endian byte order.
                          将两个字符视为一个小端 字节顺序的无符号长整数。
w           Integer       BER-compressed integer (see Array#pack for more information).
                          BER压缩的整数（详见Array#pack）
X           —             Skips backward one byte.
                          向后跳过一个字节。
x           —             Skips forward one byte.
                          向前跳过一个字节。
Z           String        String with trailing nulls removed.
                          删除了null结尾的字符串。
@           —             Skips to the byte offset given by the length argument.
                          跳过由长度参数指定的偏移。

° May be modified by appending _ or ! to the directive.
° 可因为向指令附加`_`或!而改变。

#### upcase  转为大写

    str.upcase → string

Returns a copy of str with all lowercase letters replaced with their uppercase counterparts.
返回str的一个拷贝，把其中所有小写字母都用相应的大写字母代替。
The mapping depends on the string encoding, but not all encodings produce expected results.
大小写的映射依赖字符串的编码，但不是所有的编码都能产生期待的结果。

    # encoding: utf-8
    "hEllO".upcase # => "HELLO"
    "∂og".upcase # => "∂OG"

#### upcase!  转为大写

    str.upcase! → str or nil

Upcases the contents of str, returning nil if no changes were made.
把str的内容变成大写；如果没有修改则返回nil。

#### upto  连续值迭代

    str.upto( string, exclude_end=false ) { |s| … } → str or enumerator

Iterates through successive values, starting at str and ending at string inclusive (or omitting string if the second parameter is true). 
在str到string（如果第二个参数为true则不包含string）的连续值上迭代。
Passes each value in turn to the block. 
并且依次把每个值传递给block。
The String#succ method is used to generate each value. 
每个值是通过String#succ产生的。
Returns an Enumerator object if no block is given.
如果没有给出block，返回一个枚举。

    "a8".upto("b6") {|s| print s, ' ' }
    puts
    for s in "a8".."b6"
      print s, ' '
    end
    # produces:
    # a8 a9 b0 b1 b2 b3 b4 b5 b6
    # a8 a9 b0 b1 b2 b3 b4 b5 b6
    "a8".upto("b6", true).to_a # => ["a8", "a9", "b0", "b1", "b2", "b3", "b4", "b5"]


If the two strings contain just the digits 0 to 9, then successive numeric values (as strings) are generated. 
如果两个字符串只包含数字0到9,则产生连续的数值（作为字符串）。
Leading zeros are handled appropriately.
前导的0被以类似的方法处理。

    "99".upto("103").to_a # => ["99", "100", "101", "102", "103"]
    "00008".upto("00012").to_a # => ["00008", "00009", "00010", "00011", "00012"]

#### valid_encoding?  是否有效编码  1.9

    str.valid_encoding? → true or false

Returns true if str contains a valid byte sequence in its current encoding.
如果str在当前编码下包含有效的字节序列，返回true。

    # encoding: binary
    str = "\xE2"
    str.force_encoding("utf-8")
    str.valid_encoding? # => false
    str = "\xE2\x88\x82"
    str.force_encoding("utf-8")
    str.valid_encoding? # => true


## Struct  构造
### 概述
Subclasses: Struct::Tms
子类：Struct::Tms

A Struct is a convenient way to bundle a number of attributes together, using accessor methods, without having to write an explicit class.
构造是一种将许多属性捆绑在一起的便捷方式，可以使用accessor方法访问这些属性，而无需为之编写一个显式的类。
The Struct class is a generator of specific classes, each one of which is defined to hold a set of variables and their accessors. 
构造类是产生特定类的生成器，每个生成的类被定义为存有一组变量以及访问这些变量的accessor方法。
In these examples, we’ll call the generated class Customer, and we’ll show an example instance of that class as joe.
在这些例子中，我们会把这些生成的类称作Customer，同时演示该类的一个示范实例joe。
Also see OpenStruct on page 786.
另见2版710页4版786页的OpenStruct。

In the descriptions that follow, the parameter symbol refers to a name, which is either a quoted string or a Symbol (such as :name).
在接下来的描述中，symblo参数指的是一个符号，它是一个引号字符串或者一个符号（例如:name）。

### Mixes In  混入
Enumerable: 
all?, any?, 
chunk, collect, collect_concat, count, cycle, 
detect, drop, drop_while, 
each_cons, each_entry, each_slice, each_with_index, each_with_object, entries, 
find, find_all, find_index, first, flat_map, 
grep, group_by, 
include?, inject, 
lazy, 
map, max, max_by, member?, min, min_by, minmax, minmax_by, 
none?, 
one?, 
partition, 
reduce, reject, reverse_each, 
select, slice_before, sort, sort_by, 
take, take_while, to_a, 
zip

### Class Methods 类方法
#### new  新建

    Struct.new( ‹ string › ‹ , symbol ›+ ) → Customer
    Struct.new( ‹ string › ‹ , symbol ›+ ) { … } → Customer

Creates a new class, named by string, containing accessor methods for the given symbols. 
创建一个名为string的新类，包含了那些给定符号对应的accessor方法。
If the name string is omitted, an anonymous structure class will be created. 
如果省略了string参数，将会创建一个匿名的结构类。
Otherwise, the name of this struct will appear as a constant in class Struct, so it must be unique for all Structs in the system and should start with a capital letter. 
否则，这个结构的名字将作为一个Struct类中的一个常量，所以它必须对系统中生成的所有结构类是唯一的，并且应当以一个大写字母开始。
Assigning a structure class to a constant effectively gives the class the name of the constant.
把一个结构类赋值给一个常量，这样有效地把常量的名称提供给这个类。

Struct.new returns a new Class object, which can then be used to create specific instances of the new structure. 
Struct.new返回一个新的Class对象，然后可以用它来创建这个新结构的具体实例。
The remaining methods listed next (class and instance) are defined for this generated class. 
下面列出的方法（类和实例的方法），为这个新生成的类所定义。
See the description that follows for an example.
参见位于示例之后的描述。

    # Create a structure with a name in Struct
    # 用构造类的里的名称创建一个构造
    Struct.new("Customer", :name, :address) # => Struct::Customer
    Struct::Customer.new("Dave", "123 Main") # => #<struct Struct::Customer
                                             # .. name="Dave", address="123 Main">
    # Create a structure named by its constant
    # 通过常量的命名创建一个构造
    Customer = Struct.new(:name, :address) # => Customer
    Customer.new("Dave", "123 Main")       # => #<struct Customer name="Dave",
                                           # .. address="123 Main">

A block passed to the constructor is evaluated in the context of the new struct’s class and hence allows you conveniently to add instance methods to the new struct.
传给构造器的block被在新构造的类的上下文中求解，因此允许你方便地将实例方法添加到新的构造中。

    Customer = Struct.new(:name, :address) do
      def to_s
        "#{self.name} lives at #{self.address}"
      end
    end
    Customer.new("Dave", "123 Main").to_s # => "Dave lives at 123 Main"

#### new  新建实例  <kinder:note> 怎么两个new，不冲突吗？

    Customer.new( ‹ obj ›+ ) → joe

Creates a new instance of a structure (the class created by Struct.new). 
创建一个结构（由Struct.new创建的类）的新实例。
The number of actual parameters must be less than or equal to the number of attributes defined for this class; unset parameters default to nil. 
实际的参数个数必须小于或等于定义在这个类中的属性个数；未设置的参数默认是nil。
Passing too many parameters will raise an ArgumentError.
传入太多的参数会引发ArgumentError。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe.name # => "Joe Smith"
    joe.zip # => 12345

#### []  新建实例

    Customer[ ‹ obj ›+ ] → joe

Synonym for new (for the generated structure).
同new（对这个生成的结构而言）。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer["Joe Smith", "123 Maple, Anytown NC", 12345]
    joe.name # => "Joe Smith"
    joe.zip # => 12345

#### members  实例变量名称数组

    Customer.members → array

Returns an array of symbols representing the names of the instance variables.
返回一个字符串数组，其中字符串表示实例变量的名称。

    Customer = Struct.new("Customer", :name, :address, :zip)
    Customer.members # => [:name, :address, :zip]


### Instance Methods 实例方法
#### ==  是否相等

    joe == other_struct → true or false

Equality—Returns true if other_struct is equal to this one: they must be of the same class as generated by Struct.new, and the values of all instance variables must be equal (according to Object#==).
等同--如果`other_struct`与joe的结构相等，返回true：它们必须都是由Struct.new生成的相同类，同时它们的所有实例变量的值必须相等（根据Object#==）。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joejr = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    jane = Customer.new("Jane Doe", "456 Elm, Anytown NC", 12345)
    joe == joejr # => true
    joe == jane # => false

#### []  属性引用

    joe[ symbol ] → obj
    joe[ integer ] → obj

Attribute Reference—Returns the value of the instance variable named by symbol or indexed (0..length-1) by int. 
属性引用--返回以symbol命名的或者由int索引的(0..length-1)实例变量的值。
Raises NameError if the named variable does not exist or raises IndexError if the index is out of range.
如果不存在给定的变量，引发NameError，或者如果索引超出了范围，引发IndexError。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe["name"] # => "Joe Smith"
    joe[:name] # => "Joe Smith"
    joe[0] # => "Joe Smith"

#### [ ]=  属性赋值

    joe[ symbol ] = obj → obj
    joe[ int ] = obj → obj

Attribute Assignment—Assigns to the instance variable named by symbol or int the value obj and returns it. 
把obj的值赋值给以symbol命名的或者由int索引的实例变量，同时返回obj的值。
Raises a NameError if the named variable does not exist or raises an IndexError if the index is out of range.
如果不存在给定的变量，引发NameError，或者如果索引超出了范围，引发IndexError。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe["name"] = "Luke"
    joe[:zip] = "90210"
    joe.name # => "Luke"
    joe.zip # => "90210"

#### each  遍历变量

    joe.each { |obj| … } → joe

Calls block once for each instance variable, passing the value as a parameter.
对每个实例变量调用一次block，把实例变量的值作为参数传入。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe.each {|x| puts(x) }
    # produces:
    # Joe Smith
    # 123 Maple, Anytown NC
    # 12345

#### each_pair  遍历变量/值对   1.8

    joe.each_pair { |symbol, obj| … } → joe

Calls block once for each instance variable, passing the name (as a symbol) and the value as parameters.
为每个实例变量调用一次block，把它的名字（作为一个符号）和值作为参数传入。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe.each_pair {|name, value| puts("#{name} => #{value}") }
    # produces:
    # name => Joe Smith
    # address => 123 Maple, Anytown NC
    # zip => 12345

#### length  长度

    joe.length → int

Returns the number of attributes.
返回属性（实例变量）的个数。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe.length # => 3

#### members  实例变量名称数组

    joe.members → array

Returns the names of the instance variables as an array of symbols.
返回一个符号数组，其中符号表示实例变量的名称。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe.members # => [:name, :address, :zip]

#### size  长度

    joe.size → int

Synonym for Struct#length.
同Struct#length。

#### to_a  转换为数组

    joe.to_a → array

Returns the values for this instance as an array.
将该实例的值以一个数组返回。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe.to_a[1] # => "123 Maple, Anytown NC"

#### to_h  转换为散列表

    joe.to_h → hash

Returns a hash of key/values pairs in this struct.
返回表示joe构造的键值对的一个散列表。

    Customer = Struct.new(:name, :address, :zip)
    joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)
    joe.to_h # => {:name=>"Joe Smith", :address=>"123 Maple, Anytown NC",
             # .. :zip=>12345}

#### values  转换为数组

    joe.values → array

Synonym for `to_a`.
同`to_a`。

#### values_at  匹配引用数组

    joe.values_at( ‹ selector ›* ) → array

Returns an array containing the elements in joe corresponding to the given indices. 
返回一个数组，包含joe里对应着给定索引的元素。
The selectors may be integer indices or ranges.
selector可以是整数索引或区间。

    Lots = Struct.new(:a, :b, :c, :d, :e, :f)
    l = Lots.new(11, 22, 33, 44, 55, 66)  
    l.values_at(1, 3, 5)    # => [22, 44, 66]
    l.values_at(0, 2, 4)    # => [11, 33, 55]
    l.values_at(-1, -3, -5) # => [66, 44, 22]


## Struct::Tms < Struct  构造时间
This structure is returned by Process.times. 
这个结构由Process.times返回。
It holds information on process times on those platforms that support it. 
它含有在支持平台上的进程时间的信息。
Not all values are valid on all platforms. 
并非所有值在所有平台上都有效。
This structure contains the following instance variables and the corresponding accessors:
这个结构包含下面的实例变量和相应的访问方法：

utime  Amount of user CPU time, in seconds
       用户CPU时间数量，以秒计
stime  Amount of system CPU time, in seconds
       系统CPU事件数量，以秒计
cutime Total of completed child processes’ user CPU time, in seconds (always 0 on Windows)
       已结束子进程的用户CPU时间总数，以秒计（在Windows上总是0）
cstime Total of completed child processes’ system CPU time, in seconds (always 0 on Windows)
       已结束子进程的系统CPU时间总数，以秒计（在Windows上总是0）

See also Struct on page 693 and Process.times on page 642.
另见前面2版626页4版693页的Struct和2版587页4版642页的Process.times。

    def eat_cpu
      10_000.times { File.open("/etc/passwd").close
    end
    3.times { fork { eat_cpu } }
    eat_cpu
    Process.waitall
    t = Process::times
    [ t.utime, t.stime] # => [0.13, 0.24]
    [ t.cutime, t.cstime ] # => [0.27, 0.68]
    }

## Symbol  符号
### 概述
Symbol objects represent names inside the Ruby interpreter. 
在Ruby解释器内部，符号对象表示名称。
They are generated using the :name or :"arbitrary text" literal syntax and by using the various to_sym methods. 
可以使用:name字面量语法以及各种各样的`to_sym`方法来生成这些符号对象。
The same Symbol object will be created for a given name string for the duration of a program’s execution, regardless of the context or meaning of that name. 
在程序执行期间，对给定名称的字符串会创建相同的符号对象，而无论名称所处的上下文或者其含义如何。
Symbols can be arbitrary sequences of characters. 
符号可以是任意字符串序列。
Like strings, a symbol literal containing any characters with the top bit set will have an encoding determined by the encoding of the source file containing the definition.
像字符串，符号字面量包含任何字符，顶级位集合有一个编码，该编码由包含定义的源文件的编码决定。
Ruby 1.9 added string-like functionality to symbols.
Ruby 1.9为符号添加了类似字符串的功能。

### Mixes In  混入
Comparable: <, <=, ==, >, >=, between?

### Class Methods 类方法
#### all_symbols  所有符号的列表

    Symbol.all_symbols → array

Returns an array of all the symbols currently in Ruby’s symbol table.
返回一个数组，包含在当前ruby符号表中的所有符号。

    list = Symbol.all_symbols
    list.size # => 2240
    list.grep(/attr_/) # => [:attr_reader, :attr_writer, :attr_accessor, :attr_name]

### Instance Methods 实例方法
#### <=>  比较

    sym <=> other_sym → -1, 0, +1, or nil

Compares sym to `other_sym` after converting each to strings. 
将sym和`other_sym`转化为字符串之后进行比较。
<=> is the basis for the methods <, <=, >, >=, and between?, included from module Comparable. 
<=> 基于< <= > >=和between?方法，在Comparable模块中混入的。
The method Symbol#== does not use Comparable#==.
Symbol#==方法不使用Comparable#==方法。

    :abcdef <=> :abcde   # => 1
    :abcdef <=> :abcdef  # => 0
    :abcdef <=> :abcdefg # => -1
    :abcdef <=> :ABCDEF  # => 1

#### ==  是否相等

    sym == obj → true or false

Returns true only if sym and obj are symbols with the same object_id.
只有sym和obj都是符号，且`object_id`相同时，才返回true。

    :abcdef == :abcde # => false
    :abcdef == :abcdef # => true

#### =~  是否匹配

    sym =~ obj → int or nil

Converts sym to a string and matches it against obj.
将sym转换为一个字符串，然后和obj相匹配。

    :abcdef =~ /.[aeiou]/ # => 3
    :abcdef =~ /xx/ # => nil

#### []  元素引用

    sym[ int ] → string or nil
    sym[ int, int ] → string or nil
    sym[ range ] → string or nil
    sym[ regexp ] → string or nil
    sym[ regexp, int ] → string or nil
    sym[ string ] → string or nil

Converts sym to a string and then indexes it using the same parameters as String#[].
将sym转化为一个字符串，然后使用和String#[]相同的参数进行索引。

    :"hello there"[1]                   # => "e"
    :"hello there"[1,3]                 # => "ell"
    :"hello there"[1..3]                # => "ell"
    :"hello there"[-3,2]                # => "er"
    :"hello there"[-4..-2]              # => "her"
    :"hello there"[-2..-4]              # => ""
    :"hello there"[/[aeiou](.)\1/]      # => "ell"
    :"hello there"[/[aeiou](.)\1/, 1]   # => "l"

#### capitalize  首字母大写

    sym.capitalize → symbol

Returns a symbol with the first character of sym converted to uppercase and the remainder to lowercase.
返回一个符号，sym的第一个字符被转为大写，其他的转为小写。

    :hello.capitalize # => :Hello
    :"HELLO WORLD".capitalize # => :"Hello world"
    :"123ABC".capitalize # => :"123abc"

#### casecmp  大小写无关的比较

    sym.casecmp( other ) → -1, 0, +1, or nil

Case-insensitive version of Symbol#<=>. 
Symbol#<=>的大小写无关的版本。
Returns nil if other is not a symbol.
如果other不是一个符号，返回nil。 

    :abcdef.casecmp(:abcde)    #  =>  1
    :abcdef.casecmp(:abcdef)   #  =>  0
    :abcdef.casecmp(:ABCDEF)   #  =>  0
    :aBcDeF.casecmp(:abcdef)   #  =>  0
    :abcdef.casecmp(:abcdefg)  #  =>  -1
    :abcdef.casecmp("abcdef")  #  =>  nil

#### downcase  小写

    sym.downcase → symbol

Returns a symbol with all the characters of sym converted to lowercase.
返回一个符号，sym所有的的字符都被转为小写。

    :Hello.downcase # => :hello
    :"HELLO WORLD".downcase # => :"hello world"
    :"123ABC".downcase # => :"123abc"

#### empty?  是否为空

    sym.empty → true or false

Returns true if the string representation of sym is empty.
如果表示sym的string为空，返回true。

    :hello.empty? # => false
    :"".empty?  # => true

#### encoding  编码

    sym.encoding → enc

Returns the encoding of sym.
返回sym的编码

    # encoding: utf-8
    :hello.encoding # => #<Encoding:US-ASCII>
    :"∂og".encoding # => #<Encoding:UTF-8>

#### id2name  转为字符串  1.8

    sym.id2name → string

Returns the string representation of sym.
返回表示sym的字符串。

    :fred.id2name # => "fred"
    :"99 red balloons!".id2name # => "99 red balloons!"

#### inspect  字面量

    sym.inspect → string

Returns the representation of sym as a symbol literal.
以一个符号字面量返回sym的表示。

    :fred.inspect # => :fred
    :"99 red balloons!".inspect # => :"99 red balloons!"

#### intern  符号化

    sym.intern → sym

Synonym for `Symbol#to_sym`.
同`Symbol#to_sym`。

#### length  长度

    sym.length → int

Returns the number of characters in the string representation sym.
返回表示sym的字符串的字符的数量。

    # encoding: utf-8
    :dog.length # => 3
    :∂og.length # => 3

#### match  匹配

    sym.match( regexp ) → int or nil

Converts self to a string and then matches it against regexp. 
将self转化为一个字符串，然后和regexp进行匹配。
Unlike String#match, does not support blocks or non-regexp parameters.
不像String#match，这个匹配不支持block和非正则表达式参数。

    :hello.match(/(.)\1/) # => 2
    :hello.match(/ll/) # => 2

#### next  下一个

    sym.next → symbol

Synonym for Symbol#succ.
同Symbol#succ。

#### size  长度

    sym.size → int

Synonym for Symbol#length.
同Symbol#length。

#### slice  元素引用（切片）

    sym.slice( int ) → string or nil
    sym.slice( int, int ) → string or nil
    sym.slice( range ) → string or nil
    sym.slice( regexp ) → string or nil
    sym.slice( match_string ) → string or nil

Synonym for Symbol#[ ].
同Symbol#[ ]。

#### succ  进位

    sym.succ → symbol

Returns the successor to sym using the same rules as String#succ.
返回使用和String#succ同样的规则返回sym的successor。

    :abcd.succ # => :abce
    :THX1138.succ # => :THX1139
    :"1999zzz".succ # => :"2000aaa"

#### swapcase  大小写互换

    sym.swapcase → symbol

Returns a symbol with the case of all the characters of sym swapped.
返回一个symbol，将sym的字母大小写都进行反转。

    :Hello.swapcase # => :hELLO
    :"123ABC".swapcase # => :"123abc"

#### to_proc  转为过程

    sym.to_proc → proc

Allows a symbol to be used when a block is expected. 
当需要block时，允许使用符号。
The symbol acts as a method invoked on each parameter to the block. 
符号作为每个参数的方法调用被传给block。
See The Symbol.to_proc Trick, on page 352 for more information.
要看`Symbol.to_proc`的技巧，详见352页。

    %w{ant bee cat}.map(&:reverse) # => ["tna", "eeb", "tac"]

#### to_s  转换为字符串

    sym.to_s → string

Synonym for Symbol#id2name.
同Symbol#id2name。

#### to_sym  转换为符号

    sym.to_sym → sym

Symbols are symbol-like!
将symbol符号化

#### upcase  大写字母

    sym.upcase → symbol

Returns a symbol with all the characters of sym in uppercase.
返回一个符号，带有sym所有字符的大写。

    :Hello.upcase # => :HELLO
    :"123Abc".upcase # => :"123ABC"


## Thread  线程
### 概述
Thread encapsulates the behavior of a thread of execution, including the main thread of the Ruby script. 
线程封装了一次线程的执行行为，包括了Ruby脚本的主线程。
See the tutorial beginning Chapter 12, Fibers, Threads, and Processes, on page 161.
详见2版135页11章4版161页12章。

In the descriptions that follow, the parameter symbol refers to a name that is either a quoted string or a symbol (such as :name).
在下面的描述中，参数symbol指的是一个符号，它是一个引号字符串或者一个符号（例如:name）。

### Class Methods 类方法
#### abort_on_exception  是否异常终止

    Thread.abort_on_exception → true or false

Returns the status of the global abort on exception condition. 
返回全局“abort on exception（异常发生时终止执行）”条件的状态。
The default is false. 
默认为false。
When set to true or if the global $DEBUG flag is true (perhaps because the command-line option -d was specified), all threads will abort (the process will exit(0)) if an exception is raised in any thread.
当把它设置为true，或者如果全局$DEBUG标志为true（或许因为使用了-d命令行选项），如果在任何线程中引发了异常，所有线程都会终止（这个进程会调用exit(0)）。
See also `Thread.abort_on_exception=`.
另见`Thread.abort_on_exception=`。

#### abort_on_exception=  设置异常终止

    Thread.abort_on_exception= true or false→ true or false

When set to true, all threads will abort if an exception is raised. 
当设置为true时，如果引发了异常，所有线程将会中止。
Returns the new state.
返回新的状态。

    Thread.abort_on_exception = true
    t1 = Thread.new do
      puts "In new thread"
      raise "Exception from thread"
    end
    sleep(0.1)
    puts "not reached"
    # produces:
    # In new thread
    # prog.rb:4:in `block in <main>': Exception from thread (RuntimeError)

#### current  当前执行线程

    Thread.current → thread

Returns the currently executing thread.
返回当前执行的线程。

    Thread.current # => #<Thread:0x007fb2340c0ce0 run>

#### exclusive  独占

    Thread.exclusive { … } → obj

Executes the block and returns whatever the block returns. 
执行block，然后返回，不管block返回什么。
Internally uses a Mutex so that only one thread can be executing code under the control of Thread.exclusive at a time.
内部使用Mutex，以便一个时间内只有一个线程可在Thread.exclusive的控制下被执行代码。

#### exit  退出

    Thread.exit

Terminates the currently running thread and schedules another thread to be run. 
终止当前正在运行的线程，并调度另外的线程来运行。
If this thread is already marked to be killed, exit returns the Thread. 
如果这个线程已经标记为要被杀死，则exit返回这个线程。
If this is the main thread, or the last thread, exits the process.
如果这是主线程或最后一个线程，则退出进程。

#### fork  分叉

    Thread.fork { … } → thread

Synonym for Thread.start.
同Thread.start。

#### kill  杀死

    Thread.kill( thread )

Causes the given thread to exit (see Thread.exit).
导致给定线程退出（参见Thread.exit）。

    count = 0
    a = Thread.new { loop { count += 1 } }
    sleep(0.1)     # => 0
    Thread.kill(a) # => #<Thread:0x007fefc210f400 run>
    count          # => 910465
    # give it time to die...
    sleep 0.01
    a.alive?        # => false

#### list  列出对象数组

    Thread.list → array

Returns an array of Thread objects for all threads that are either runnable or stopped.
返回一个Thread对象的数组，包含了所有可运行或者已停止的线程。

    Thread.new { sleep(200) }
    Thread.new { 1000000.times {|i| i*i } }
    Thread.new { Thread.stop }
    Thread.list.each {|thr| p thr }
    # produces:
    # #<Thread:0x007fa3b90c0cd8 run>
    # #<Thread:0x007fa3b910f810 sleep>
    # #<Thread:0x007fa3b910f630 run>
    # #<Thread:0x007fa3b902b728 sleep>

#### main  主线程

    Thread.main → thread

Returns the main thread for the process.
返回这个进程的主线程。

    Thread.main # => #<Thread:0x007ffc9b8c0ce0 run>

#### new  新建

    Thread.new( ‹ arg ›* ) { |args| … } → thread

Creates and runs a new thread to execute the instructions given in block. 
创建炳运行一个新的线程，它执行在block中给出的指令。
Any arguments passed to Thread.new are passed into the block.
任何传递给Thread.new的参数会传递给这个block。

    x = Thread.new { sleep 0.1; print "x"; print "y"; print "z" }
    a = Thread.new { print "a"; print "b"; sleep 0.2; print "c" }
    x.join; a.join # wait for threads to finish
    # produces:
    # abxyzc

#### pass  让出执行权

    Thread.pass

Invokes the thread scheduler to pass execution to another thread.
调用线程调度器，把执行权让给别的线程。

    a = Thread.new { print "a"; Thread.pass; print "b" }
    b = Thread.new { print "x"; Thread.pass; print "y" }
    a.join; b.join
    # produces:
    # axby

#### start  新建

    Thread.start( ‹ args ›* ) { |args| … } → thread

Basically the same as Thread.new. 
基本上与Thread.new相同。
However, if class Thread is subclassed, then calling start in that subclass will not invoke the subclass’s initialize method.
但是，如果Thread类被子类化，那么在子类中调用start不会调用子类的initialize方法。
<kinder:note> 什么叫做子类化？线程作为一个类的子类？

#### stop  睡眠

    Thread.stop

Stops execution of the current thread, putting it into a sleep state, and schedules execution of another thread. 
停止当前线程的执行，把它置于“睡眠”状态，同时调度另外的线程来运行。
Resets the critical condition to false.
把“critical”条件重置为false。
<kinder:note> “critical”条件在这一版本没有介绍。

    a = Thread.new { print "a"; Thread.stop; print "c" }
    sleep 0.01
    print "b"
    a.wakeup
    a.join
    # produces:
    # abc


### Instance Methods 实例方法
#### []  属性引用  ⇡New in 2.0⇣

    thr[ symbol ] → obj or nil

Attribute Reference—Returns the value of a fiber-local variable, using either a symbol or a string name. 
属性引用--使用符号或者字符串名称，返回线程局部变量的值。
If the specified variable does not exist, returns nil. 
如果指定的变量不存在，返回nil。
Every thread has an implicit root fiber, so this method is always available. 
每个线程都有一个隐含的根纤程，所以这个方法总是可用。
See also `Thread#thread_variable_get`.
另见`Thread#thread_variable_get`。

    a = Thread.new { Thread.current["name"] = "A"; Thread.stop }
    b = Thread.new { Thread.current[:name] =  "B"; Thread.stop }
    c = Thread.new { Thread.current["name"] = "C"; Thread.stop }
    sleep 0.01 # let them all run             
    Thread.list.each {|x| puts "#{x.inspect}: #{x[:name]}" }
    # produces:
    # #<Thread:0x007fd5fc0c0ce0 run>:
    # #<Thread:0x007fd5fc10eda0 sleep>: A
    # #<Thread:0x007fd5fc10ebc0 sleep>: B
    # #<Thread:0x007fd5fc02b898 sleep>: C

#### [ ]=  属性赋值

    thr[ symbol ] = obj→ obj

Attribute Assignment—Sets or creates the value of a fiber-local variable, using either a symbol or a string. 
属性赋值--使用符号或者字符串，设置或者创建线程局部变量的值。
See also `Thread#thread_variable_set`.
另见`Thread#thread_variable_set`。

#### abort_on_exception  是否异常中止

    thr.abort_on_exception → true or false

Returns the status of the thread-local abort on exception condition for thr. 
返回thr线程局部的“abort on exception”条件的状态。
The default is false.
默认为false。
See also `Thread.abort_on_exception=`.
另见`Thread.abort_on_exception=`。

#### abort_on_exception=  设置异常中止

    thr.abort_on_exception= true or false→ true or false

When set to true, causes all threads (including the main program) to abort if an exception is raised in thr. 
当设置为true时，如果thr中发生了异常，将导致所有线程（包括主程序）中止。
The process will effectively exit(0).
这个进程实际上将调用exit(0)。

#### add_trace_func  添加追踪函数 ⇡New in 2.0⇣

    thr.add_trace_func( proc ) → proc
    thr.add_trace_func( nil ) → nil

Adds a trace function to thr (see `Thread#set_trace_func`). 
为thr添加追踪功能（参见`Thread#set_trace_func`。）
(This method has been replaced by the TracePoint class in Ruby 2.0.)
（这个方法可能在ruby 2.0中被TracePoint类替代）

#### alive?  是否存在

    thr.alive? → true or false

Returns true if thr is running or sleeping.
如果thr正在运行或者处于睡眠状态，返回true。

    thr = Thread.new { }
    thr.join # => #<Thread:0x007fd26312c248 dead>
    Thread.current.alive? # => true
    thr.alive?  # => false

#### backtrace  回溯  1.9

    thr.backtrace → array

Returns the backtrace of thr.
返回thr的回溯

    thr = Thread.new do
      print "starting\n"
      def sleeper(n)
        print "sleeping\n"
        sleep n
      end
      sleeper(10)
    end
    p thr.status
    p thr.backtrace
    Thread.pass
    p thr.status
    p thr.backtrace
    # produces:
    # "run"
    # starting
    # sleeping
    # ["prog.rb:5:in `sleep'", "/tmp/prog.rb:5:in `sleeper'", "/tmp/prog.rb:7:in `block
    # in <main>'"]
    # "sleep"
    # ["prog.rb:5:in `sleep'", "/tmp/prog.rb:5:in `sleeper'", "/tmp/prog.rb:7:in `block
    # in <main>'"]

#### backtrace_locations  回溯位置 ⇡New in 2.0⇣

    thr.backtrace → array

Analog of the global `caller_locations` method.
类似全局的`caller_locations`方法。

    thr = Thread.new do
      print "starting\n"
      def sleeper(n)
        print "sleeping\n"
        sleep n
      end
      sleeper(10)
    end
    p thr.backtrace_locations
    # produces:
    # []
    # starting
    # sleeping

#### exit  退出

    thr.exit → thr or nil

Terminates thr and schedules another thread to be run. 
终止thr线程，同时调用另外的线程来运行。
If this thread is already marked to be killed, exit returns the Thread. 
如果这个线程已经标记为要被杀死，exit返回这个线程。
If this is the main thread, or the last thread, exits the process.
如果这是主线，或是最后一个线程，退出这个线程。

#### group  线程组  1.8

    thr.group → thread_group

Returns the ThreadGroup owning thr, or nil.
返回thr所属的线程组，或者返回nil。

    thread = Thread.new { sleep 99 }
    Thread.current.group.list # => [#<Thread:0x007f836a0c0ce8 run>,
                              # .. #<Thread:0x007f836a83f820 run>]
    new_group = ThreadGroup.new 
    thread.group.list         # => [#<Thread:0x007f836a0c0ce8 run>,
                              # .. #<Thread:0x007f836a83f820 run>]
    new_group.add(thread)       
    thread.group.list         # => [#<Thread:0x007f836a83f820 run>]
    Thread.current.group.list # => [#<Thread:0x007f836a0c0ce8 run>]

#### join  等待退出  1.8 ⇡New in 2.0⇣

    thr.join → thr
    thr.join( limit ) → thr

The calling thread will suspend execution and run thr. 
调用者线程会挂起执行，并运行thr线程。
<kinder:note> 谁是调用者？
Does not return until thr exits or until limit seconds have passed. 
它直到thr退出和已经运行了limit秒事件才会退出。
If the time limit expires, nil will be returned; otherwise, thr is returned.
如果事件limit到期，返回nil；否则返回thr。

Any threads not joined will be killed when the main program exits. 
主程序退出时，任何没有被join的线程将会被杀死。
If thr had previously raised an exception and the abort_on_exception and $DEBUG flags are not set (so the exception has not yet been processed), it will be processed at this time.
如果thr先前已经引发了一个异常，同时没有设置`abort_on_exception`和$DEBUG标志（因此这个异常还未处理），这时候异常将被处理。

You cannot join to the current or main thread.
你不能join到当前线程或主线程。
<kinder:note> 看不懂下面的例子。


    a = Thread.new { print "a"; sleep(10); print "b"; print "c" }
    x = Thread.new { print "x"; Thread.pass; print "y"; print "z" }
    x.join # Let x thread finish, a will be killed on exit.
           # 可是x不是pass了吗？a为什么不会打印出bc就退出呢？
    # produces:
    # axyz

The following example illustrates the limit parameter:
下面的例子说明了limit参数：

    y = Thread.new { loop { sleep 0.1; print "tick...\n" }}
    y.join(0.25)
    puts "Gave up waiting..."
    # produces:
    # tick...
    # tick...
    # Gave up waiting...

#### keys  键 ⇡New in 2.0⇣

    thr.keys → array

Returns an array of the names of the fiber-local variables (as symbols).
返回纤程局部变量的名称的数组

    thr = Thread.new do
      Thread.current[:cat] = 'meow'
      Thread.current["dog"] = 'woof'
    end
    thr.join # => #<Thread:0x007feeb312c0d8 dead>
    thr.keys # => [:cat, :dog]

#### key?  是否有键

    thr.key?( symbol ) → true or false

Returns true if the given string (or symbol) exists as a thread-local variable.
如果给定字符串（或符号）作为一个线程局部变量存在，返回true。

    me = Thread.current
    me[:oliver] = "a"
    me.key?(:oliver) # => true
    me.key?(:stanley) # => false

#### kill  杀死

    thr.kill

Synonym for Thread#exit.
同Thread#exit。

#### priority  优先级

    thr.priority → int

Returns the priority of thr. 
The default is zero; higher-priority threads will run before lowerpriority threads.
返回thr的优先级。
默认是0；更高优先级的线程将在较低优先级的线程之前运行。

    Thread.current.priority # => 0

#### priority=  设置优先级

    thr.priority= int → thr

Sets the priority of thr to integer. 
将thr的优先级设为int。
Higher-priority threads will run before lower-priority threads. 
更高优先级的线程将在较低优先级的线程之前运行。
If you find yourself messing with thread priorities to get things to work, you’re doing something wrong.
如果你弄混了线程优先级来安排工作，你一定弄错了。

    count_high = count_low = 0
    Thread.new do
      Thread.current.priority = 1
      loop { count_high += 1 }
    end
    Thread.new do
      Thread.current.priority = -1
      loop { count_low += 1 }
    end
    sleep 0.1
    count_high # => 3651144
    count_low # => 1829723

#### raise  抛出异常  1.8

    thr.raise
    thr.raise( message )
    thr.raise( exception ‹ , message ‹ , array ›› )

Raises an exception (see Object#raise on page 622 for details) from thr. 
从thr抛出一个异常（详见前面2版527页4版622页的Object#raise）。
The caller does not have to be thr.
调用者不用非得是thr。

    Thread.abort_on_exception = true
    a = Thread.new { sleep(200) }
    a.raise("Gotcha")
    a.join
    # produces:
    # from prog.rb:2:in `block in <main>'
    # prog.rb:2:in `sleep': Gotcha (RuntimeError)

#### run  唤醒运行

    thr.run → thr

Wakes up thr, making it eligible for scheduling. 
唤醒thr，使它可以参与调度。
If not in a critical section, then invokes the scheduler.
如果不是在关键区域，则调用调度器。

#### safe_level  安全级别

    thr.safe_level → int

Returns the safe level in effect for thr. 
返回thr的有效安全级别。
Setting thread-local safe levels can help when implementing sandboxes that run insecure code.
设置线程局部安全级别，可以有助于实现用来运行不安全代码的沙箱。

    thr = Thread.new { $SAFE = 3; sleep }
    Thread.current.safe_level # => 0
    thr.safe_level # => 0

#### set_trace_func  设置追踪函数  1.9

    thr.set_trace_func( proc ) → proc
    thr.set_trace_func( nil ) → nil

Analog to the global set_trace_func method, but for a particular thread.
类似全局的`set_trace_func`方法，但只对一个特定的线程。

#### status  状态

    thr.status → string, false or nil

Returns the status of thr: sleep if thr is sleeping or waiting on I/O, run if thr is executing, aborting if thr will raise an exception when joined, false if thr terminated normally, and nil if thr terminated with an exception.
返回htr的状态：如果thr正在睡眠或者在IO等待中，返回sleep；如果htr正在执行，返回run；如果thr将要中止，返回aborting；如果thr已经正常退出，返回false；如果thr由于异常已经被中止，返回nil。

    a = Thread.new { raise("die now") }
    b = Thread.new { Thread.stop }
    c = Thread.new { Thread.exit }
    c.join # => #<Thread:0x007fc28082b6e0 dead>
    sleep 0.1 # => 0
    a.status # => nil
    b.status # => "sleep"
    c.status # => false
    Thread.current.status # => "run"

#### stop?  是否退出或睡眠

    thr.stop? → true or false

Returns true if thr is dead or sleeping.
如果thr已退出或正在睡眠，返回true。

    a = Thread.new { Thread.stop }
    b = Thread.current
    Thread.pass
    a.stop?  # => false
    b.stop?  # => false

#### terminate  终结

    thr.terminate

Synonym for Thread#exit.
同Thread#exit。

#### thread_variable?  是否线程局部变量 ⇡New in 2.0⇣

    thr.thread_variable?(name) → true or false

Determines if there is a thread-local (as opposed to fiber local) variable with the given name.
如果存在给定名字的线程局部（和纤程局部相对）变量，返回true。

#### thread_variables  线程局部变量列表 ⇡New in 2.0⇣

    thr.thread_variables → array

Returns the names of current thread local variables.
返回当前的线程局部变量的名称的数组。

    thr = Thread.current
    thr.thread_variables                    # => []
    thr.thread_variable_set(:option, "X12") # => "X12"
    thr.thread_variable_set(:speed, 123)    # => 123
    thr[:fiber_not_thread] = :other              
    thr.thread_variables                    # => [:option, :speed]
    # fiber variables are in a different bucket
    # 纤程变量在另一个容器中。
    thr.keys                                # => [:__recursive_key__,
                                            # .. :fiber_not_thread]

#### thread_variable_get  线程局部变量的值  ⇡New in 2.0⇣

thr.thread_variable_get(name) → obj or nil

Return the value of the thread-local variable with the given name.
返回给定名字的线程局部变量的值。

#### thread_variable_set  设置线程局部变量的值 ⇡New in 2.0⇣

    thr.thread_variable_get(name, val) → val

Set the value of the thread-local variable with the given name to the given value.
将给出名称的线程局部变量设置为给定的val（值）。

#### value  线程的值 ⇡New in 2.0⇣

    thr.value → obj

Waits for thr to complete (via Thread#join) and returns its value. 
等待thr完成（通过Thread.join），返回它的值。
Because value uses join, you cannot get the value of the current or main thread.
因为value使用join，所以你不能得到当前或主线程的值。

    a = Thread.new { 2 + 2 }
    a.value # => 4

#### wakeup  唤醒

    thr.wakeup → thr

Marks thr as eligible for scheduling (it may still remain blocked on I/O, however). 
将thr标记为可调度（当前，它可能依然还阻塞在IO上）。
Does not invoke the scheduler (see Thread#run).
不会调用调度器（参见Thread#run）。


## ThreadGroup  线程组
### 概述
A ThreadGroup keeps track of a number of threads. 
线程组可以追踪很多线程。
A Thread can belong to only one ThreadGroup at a time; adding a thread to a group will remove it from its current group. 
线程在某个时候只能属于一个线程组；把线程添加到一个线程组，将会把它从当前线程组中删除。
Newly created threads belong to the group of the thread that created them.
新创键的线程属于创建它的那个线程的线程组。

### Class Constants  类常量
Default   Default thread group.
          默认线程组
### Class Methods 类方法
#### new  新建

    ThreadGroup.new → thgrp

Returns a newly created ThreadGroup. 
返回一个新建的线程组。
The group is initially empty.
这个组初始是空的。

### Instance Methods 实例方法
#### add  添加线程

    thgrp.add( thread ) → thgrp

Adds the given thread to this group, removing it from any other group.
把给定的线程添加到这个线程组，从它先前属于的线程组中删除这个线程。

    puts "Default group is #{ThreadGroup::Default.list}"
    tg = ThreadGroup.new
    t1 = Thread.new { sleep }
    t2 = Thread.new { sleep }
    puts "t1 is #{t1}, t2 is #{t2}"
    tg.add(t1)
    puts "Default group now #{ThreadGroup::Default.list}"
    puts "tg group now #{tg.list}"
    # produces:
    # Default group is [#<Thread:0x007fee488c0cd8 run>]
    # t1 is #<Thread:0x007fee4890f1d0>, t2 is #<Thread:0x007fee4890eff0>
    # Default group now [#<Thread:0x007fee488c0cd8 run>, #<Thread:0x007fee4890eff0
    # sleep>]
    # tg group now [#<Thread:0x007fee4890f1d0 sleep>]

#### enclose  关闭增删  1.8

    thgrp.enclose → thgrp

Prevents threads being added to and removed from thgrp. 
阻止向（从）thgrp添加线程或删除线程。
New threads may still be started.
依然可以启动新的线程。

    thread = Thread.new { sleep 99 }
    group = ThreadGroup.new
    group.add(thread)
    group.enclose
    ThreadGroup::Default.add(thread)
    # This will raise an exception
    # produces:
    # from prog.rb:5:in `<main>'
    # prog.rb:5:in `add': can't move from the enclosed thread group (ThreadError)

#### enclosed?  是否关闭增删  1.8

    thgrp.enclose → true or false

Returns true if this thread group has been enclosed.
如果这个线程组已被关闭增删，返回true。

#### list  列出线程数组  1.9

    thgrp.list → array

Returns an array of all existing Thread objects that belong to this group.
返回属于这个组的所有存在的线程对象的数组。

    ThreadGroup::Default.list # => [#<Thread:0x007f82e98c0cd0 run>]


## Time  时间
### 概述
Time is an abstraction of dates and times. 
Time是日期和时间的抽象类。
Time is stored internally as the number of seconds and microseconds since the epoch, January 1, 1970 00:00 UTC. 
ruby在内部将时间存储为自新纪元--1970年1月1日00:00UTC--以来的秒数和微秒数。
On some operating systems, this offset is allowed to be negative. 
在一些操作系统上，该时间偏移允许是负数。
Also see the Date library module on page 744.
同时参见分别在后面2版665页4版744页的Data库模块。

The Time class treats Greenwich mean time (GMT) and Coordinated Universal Time (UTC)[5] as equivalent. 
Time类同等地对待GMT（格林威治标准时间）和UTC（协调通用时间）。
GMT is the older way of referring to these baseline times but persists in the names of calls on POSIX systems.
GMT是指向该基线时间的较早方式，但它一直存在和POSIX系统调用的名称中。
[5].Yes, UTC really does stand for Coordinated Universal Time. 
是的，UTC真的代表Coordinated Universal Time。
There was a committee involved.
有一个委员会涉及此事。

All times are stored with some number of microseconds, so times that are apparently equal when displayed may be different when compared.
所有的时间都保存有微秒数。它们在显示时明显是相等的，但在比较时却可能不同。
2版提醒：当比较两个时间时，请小心这个事实。

As of Ruby 1.9.2, the range of dates that can be represented is no longer limited by the underlying operating system’s time representation (so there’s no year 2038 problem). 
到了ruby 1.9.2，可被表示的日期的区间不再局限于底层操作系统的时间表示（所以没有2038年的问题）。
As a result, the year passed to the methods gm, local, new, mktime, and utc must now include the century—a year of 90 now represents 90 and not 1990.
作为结果，现在传到方法gm local new mktime和utc的年数必须包含世纪--90年只表示公元90年，而不是1990年了。

### Mixes In  混入
Comparable: <, <=, ==, >, >=, between?

### Class Methods 类方法
#### at  时间点

    Time.at( time ) → time
    Time.at( seconds ‹ , microseconds › ) → time

Creates a new Time object with the value given by time or the given number of seconds (and optional microseconds) from epoch. 
使用由time给定的值或者自新纪元以来的秒数（和可选的微秒数）来创建新的时间对象。
Microseconds may be a float—this allows setting times with nanosecond granularity on systems that support it. 
微秒可以是一个浮点数--这允许用纳秒（十亿分之一秒）尺度设置时间，只要系统支持。
A nonportable feature allows the offset to be negative on some systems.
在某些系统上这个时间偏移可以是负数，这不是一个可移植的特性。

    Time.at(0) # => 1969-12-31 18:00:00 -0600
    Time.at(946702800) # => 1999-12-31 23:00:00 -0600
    Time.at(-284061600) # => 1960-12-31 00:00:00 -0600
    t = Time.at(946702800, 123.456)
    t.usec # => 123
    t.nsec # => 123456

#### gm  

    Time.gm( year ‹ , month ‹ , day ‹ , hour ‹ , min ‹ , sec ‹ , usec ›››››› ) → time
    Time.gm( sec, min, hour, day, month, year, wday, yday, isdst, tz ) → time

Creates a time based on given values, interpreted as UTC. 
基于给定的值创建一个时间对象，解释为UTC(GMT)。
The year must be specified. 
必须执行year参数。
Other values default to the minimum value for that field (and may be nil or omitted). 
别的值默认是那个域（可能是nil或者被省略）的最小值。
Months may be specified by numbers from 1 to 12 or by the three-letter English month names. 
可以使用1到12之间的数字或者三个字母的英文月份名称来指定month。
Hours are specified on a 24-hour clock (0..23). 
可以使用24制的小时数（0..23）指定hour。
Raises an ArgumentError if any values are out of range.
如果任一值超出了它的返回，将抛出ArgumentError。
Will also accept ten arguments in the order output by `Time#to_a`.
也可以接受十个以`Time#to_a`的输出顺序传入的参数。

    Time.gm(2000,"jan",1,20,15,1) # => 2000-01-01 20:15:01 UTC

#### local  当地时间

    Time.local( sec, min, hour, day, month, year, wday, yday, isdst, tz ) → time
    Time.local( year ‹ , month ‹ , day ‹ , hour ‹ , min ‹ , sec ‹ , usec ›››››› ) → time

Same as Time.gm but interprets the values in the local time zone. 
和Time.gm相同，但以当地时区来解释这些值。
The first form accepts ten arguments in the order output by Time#to_a.
第一种形式接受以Time#to_a的输出顺序的十个参数。

    Time.local(2000,"jan",1,20,15,1) # => 2000-01-01 20:15:01 -0600

#### mktime  当地时间

    Time.mktime( year ‹ , month ‹ , day ‹ , hour ‹ , min ‹ , sec ‹ , usec ›››››› ) → time
    Time.mktime( sec, min, hour, day, month, year, wday, yday, isdst, tz ) → time

Synonym for Time.local.
同Time.local。

#### new  新建

    Time.new → time
    Time.new( year ‹ , month ‹ , day ‹ , hour ‹ , min ‹ , sec ‹ , utc_offset ›››››› )

The first form returns a Time object initialized to the current system time. 
返回一个Time对象，把它初始化为当前系统时间。
The object created will be created using the resolution available on your system clock and so may include fractional seconds.
该对象将使用系统上可用的时钟分辨率来创建这个对象，所以可能会包含秒的小数位。

    a = Time.new       # => 2013-05-27 12:33:12 -0500
    b = Time.new       # => 2013-05-27 12:33:12 -0500
    a == b             # => false
    "%.6f" % a.to_f    # => "1369675992.686567"
    "%.6f" % b.to_f    # => "1369675992.686600"

The second form creates a Time object for the given date and time. 
第二种形式为给定的日期和时间创建一个Time对象。
The optional `utc_offset` may be a number representing seconds or a string such as "+06:00".
可选的`utc_offset`可以是一个表示秒的数字，或一个类似“+06:00”的字符串。

    Time.new(2010, 12, 25, 8, 0, 0, "-06:00") # => 2010-12-25 08:00:00 -0600

#### now  现在

    Time.now → time

Synonym for Time.new.
同Time.new。

#### utc  协调世界时间

    Time.utc( year ‹ , month ‹ , day ‹ , hour ‹ , min ‹ , sec ‹ , usec ›››››› ) → time
    Time.utc( sec, min, hour, day, month, year, wday, yday, isdst, tz ) → time

Synonym for Time.gm.
同Time.gm。

    Time.utc(2000,"jan",1,20,15,1) # => 2000-01-01 20:15:01 UTC


### Instance Methods 实例方法
#### +  相加

    time + numeric → time

Addition—Adds some number of seconds (possibly fractional) to time and returns that value as a new time.
增加--把若干秒数（可能含有小数）增加time，同时以一个新的时间返回它的值。

    t = Time.now # => 2013-05-27 12:33:12 -0500
    t + (60 * 60 * 24) # => 2013-05-28 12:33:12 -0500

#### -  相减

    time - time → float
    time - numeric → time

Difference—Returns a new time that represents the difference between two times or subtracts the given number of seconds in numeric from time.
差--返回新的时间，表示两个time的差，或者从time中减去给定的numeric秒数。 

    t = Time.now      # =>  2013-05-27 12:33:12 -0500
    t2 = t + 2592000  # =>  2013-06-26 12:33:12 -0500
    t2 - t            # =>  2592000.0
    t2 - 2592000      # =>  2013-05-27 12:33:12 -0500

#### <=>  比较

    time <=> other_time → -1, 0, +1
    time <=> other → nil}

Comparison—Compares time with `other_time` or with numeric, which is the number of seconds (possibly fractional) since epoch. 
比较--使用`other_time`或者numeric与time进行比较，numeric是自新纪元依赖的秒数（可能含有小数）。
As of Ruby 1.9, nil is returned for comparison against anything other than a Time object.
到了ruby 1.9, 比较对象如果不是时间对象，将返回nil。

    t = Time.now      # => 2013-05-27 12:33:13 -0500
    t2 = t + 2592000  # => 2013-06-26 12:33:13 -0500
    t <=> t2          # => -1
    t2 <=> t          # => 1
    t <=> t           # => 0

#### day-name?  是否周几

    time.monday? → true or false
    time.tuesday? → true or false
    time.wednesday? → true or false
    time.thursday? → true or false
    time.friday? → true or false
    time.saturday? → true or false
    time.sunday? → true or false

Returns true if the time is on the given day.
如果time是给出的那一天，返回true。

#### asctime  经典字符串

    time.asctime → string

Returns a canonical string representation of time.
返回一个经典的time的经典字符串表示。

    Time.now.asctime # => "Mon May 27 12:33:13 2013"

#### ctime  经典字符串表示

    time.ctime → string

Synonym for Time#asctime.
同Time#asctime。

#### day  月中日数

    time.day → int

Returns the day of the month (1..n) for time.
返回time在这个月的天数（1..n）。

    t = Time.now # => 2013-05-27 12:33:13 -0500
    t.day # => 27

#### dst?  是否夏令时  1.8

    time.dst? → true or false

Synonym for Time#isdst.
同Time#isdst。

    Time.local(2000, 7, 1).dst? # => true
    Time.local(2000, 1, 1).dst? # => false

#### getgm  协调统一时间  1.8	

    time.getgm → time

Returns a new Time object representing time in UTC.
返回新的Time对象，以UTC表示时间。

    t = Time.local(2000,1,1,20,15,1) # => 2000-01-01 20:15:01 -0600
    t.gmt?                           # => false
    y = t.getgm                      # => 2000-01-02 02:15:01 UTC
    y.gmt?                           # => true
    t == y                           # => true

#### getlocal  当地时间  1.8

    time.getlocal → time
    time.getlocal( utc_offset ) → time

Returns a new Time object representing time in local time (using the local time zone in effect for this process) or with the given offset from UTC.
返回一个新的Time对象，以当地时间（使用这个进程有效的当地时间）来表示time。 

    t = Time.gm(2000,1,1,20,15,1)  # => 2000-01-01  20:15:01 UTC
    t.gmt?                         # => true        
    l = t.getlocal                 # => 2000-01-01  14:15:01 -0600
    l.gmt?                         # => false       
    t == l                         # => true        
    t.getlocal("-06:00")           # => 2000-01-01  14:15:01 -0600
    t.getlocal(-21600)             # => 2000-01-01  14:15:01 -0600

#### getutc  统一协调时间  1.8

    time.getutc → time

Synonym for Time#getgm.
同Time#getgm。

#### gmt?  是否统一协调时间

    time.gmt? → true or false

Returns true if time represents a time in UTC.
如果time以UTC表示，返回true。

    t = Time.now                   # => 2013-05-27 12:33:13 -0500
    t.gmt?                         # => false
    t = Time.gm(2000,1,1,20,15,1)  # => 2000-01-01 20:15:01 UTC
    t.gmt?                         # => true

#### gmtime  转为统一协调时间

    time.gmtime → time

Converts time to UTC, modifying the receiver.
把time转换为UTC，并修改接收者。

    t = Time.now  # => 2013-05-27 12:33:13 -0500
    t.gmt?        # => false
    t.gmtime      # => 2013-05-27 17:33:13 UTC
    t.gmt?        # => true

#### gmt_offset  转换偏移  1.8

    time.gmt_offset → int

Returns the offset in seconds between the time zone of time and UTC.
返回在time和UTC时区之间的描述偏移。

    t = Time.gm(2000,1,1,20,15,1) # => 2000-01-01 20:15:01 UTC
    t.gmt_offset                  # => 0
    l = t.getlocal                # => 2000-01-01 14:15:01 -0600
    l.gmt_offset                  # => -21600

#### gmtoff  转换偏移

time.gmtoff → int

Synonym for `Time#gmt_offset`.
同`Time#gmt_offset`。

#### hour  小时

    time.hour → int

Returns the hour of the day (0..23) for time.
返回time在一天中的小时数。

    t = Time.now # => 2013-05-27 12:33:13 -0500
    t.hour # => 12

#### isdst  是否夏令时

    time.isdst → true or false

Returns true if time occurs during daylight saving time in its time zone.
如果time位于所在时区的夏令时期内，返回true。

    Time.local(2000, 7, 1).isdst # => true
    Time.local(2000, 1, 1).isdst # => false

#### localtime  本地时间

    time.localtime → time
    time.localtime( utc_offset ) → time

Converts time to local time (using the local time zone in effect for this process or the given offset from UTC), modifying the receiver.
把time转换成当地时间（使用这个进程有效的当地时区），同时修改这个接收者。

    t = Time.gm(2000, "jan", 1, 20, 15, 1)
    t.gmt?            # => true
    t.localtime       # => 2000-01-01 14:15:01 -0600
    t.gmt?            # => false
    t = Time.gm(2000, "jan", 1, 20, 15, 1)
    t.localtime(7200) # => 2000-01-01 22:15:01 +0200

#### mday  日

    time.mday → int

Synonym for Time#day.
同Time#day。

#### min  分钟

    time.min → int

Returns the minute of the hour (0..59) for time.
返回time在这个小时的分钟数(0..59).

    t = Time.now # => 2013-05-27 12:33:13 -0500
    t.min # => 33

#### mon  月

    time.mon → int

Returns the month of the year (1..12) for time.
返回time在这年中的月份（1..12）。

    t = Time.now # => 2013-05-27 12:33:14 -0500
    t.mon # => 5

#### month  月

    time.month → int

Synonym for Time#mon.
同Time#mon。

#### nsec  纳秒 1.9

    time.nsec → int

Returns just the number of nanoseconds for time.
返回time的纳秒数。

    t = Time.now       # => 2013-05-27 12:33:14 -0500
    "%10.6f" % t.to_f  # => "1369675994.128473"
    t.nsec             # => 128473000
    t.usec             # => 128473

#### round  取整  1.9

    time.round( digits=0 ) → new_time

Returns a new time with the fractional seconds rounded to the specified number of decimal digits. 
返回一个新的时间，秒的小数部分被取整到指定的位数。
(This may affect the rest of the time fields if the rounding causes the number of seconds to increment.)
（如果取整导致秒数减少，可能会影响其他的时间字段。）

    require 'time'
    t = Time.utc(2010, 10, 11, 12, 13, 59.75)
    t.iso8601(3)            # => "2010-10-11T12:13:59.750Z"
    t.round(2).iso8601(3)   # => "2010-10-11T12:13:59.750Z"
    t.round(1).iso8601(3)   # => "2010-10-11T12:13:59.800Z"
    t.round.iso8601(3)      # => "2010-10-11T12:14:00.000Z"

#### sec  秒

    time.sec → int

Returns the second of the minute (0..60) for time.[6]
返回time在这分钟的秒数（0..60）[6]

    t = Time.now # => 2013-05-27 12:33:14 -0500
    t.sec # => 14

[6]. Yes, seconds really can range from zero to 60. 
是的，秒真的可以处于0到60之间。这
This allows the system to inject leap seconds every now and then to correct for the fact time measured by atomic clocks differs from time measured by a spinning earth.
可以让系统随时插入闰秒来矫正下面这个事实：原子钟测得的时间和地球公转的时间有差别。
2版：年并非是整长的小时数。

#### strftime  格式化时间

    time.strftime( format ) → string

Formats time according to the directives in the given format string. 
根据给定的format字符串中的指令对time进行格式化。
Directives look like:
指令看起来就像：

    %‹ flags ›‹ width › conversion

**flag**
The optional flags may be one or more of:
可选flags（标志）可以是下面的一个或多个：

    - Don’t pad numbers with spaces
      不要用空格来衬托数字。
    _ Pad numbers with spaces
      用空格来衬托数字。
    0 Pad numbers with zeroes
      用0来衬托数字。
    ^ Convert field to uppercase
      将字段转为大写。
    # Reverse the case of the field
      转换字段的大小写。
    : Use colons for the %z conversion. 
      使用冒号进行%z转化。
      One colon in the flag puts a colon between hours and minutes. 
      flag里一个冒号会把一个冒号放在时和分之间
      Two colons in the flag adds a seconds field.
      flag两个冒号会增加秒字段。

**width**
The width specifies the minimum result width for the field.
width指定了字段的最小结果宽度。

**conversion**
The available conversions are:
可用的转换有：
Table 25—Time#strftime directives  表格25 Time#strftime指令

    Format Meaning
    格式   含义
    %%      Literal %
            字面的%
    %a      The abbreviated weekday name (“Sun”)
            缩写的星期名称（“Sun”）
    %A      The full weekday name (“Sunday”)
            完全的星期名称（"Sunday"）
    %b      The abbreviated month name (“Jan”)
            缩写的月份名称
    %B      The full month name (“January”)
            完全的月份名称
    %c      The preferred local date and time representation
            首选当地日期和时间表示
    %C      The two digit century (currently 20)
            两个数字的世纪数（当前20××）
    %d      Day of the month (01..31)
            一个月的天数
    %D      Date (%m/%d/%y)
            日期
    %e      Day of the month, blank padded (␣1..31)
            一个月的天数，单数字的用空格填充
    %F      ISO8601 date (%Y-%m-%d)
            ISO8601格式的日期
    %g      Last 2 digits of ISO8601 week-based year
            ISO8601基于周的年最后两个数字
    %G      ISO8601 week-based year
            ISO8601基于周的年
    %h      The abbreviated month name (“Jan”)
            缩写的月份名称
    %H      Hour of the day, 24-hour clock (00..23)
            一天的小时，24小时制（00..23）
    %I      Hour of the day, 12-hour clock (01..12)
            一天的小时，12小时制（00..23）
    %j      Day of the year (001..366)
            一年中的天数(001...366)
    %k      Hour of the day, 24-hour clock, blank padded (␣0..23)
            一天的小时，24小时制，用空格填充（␣0..23） 
    %l      Hour of the day, 12-hour clock, blank padded (␣1..12)
            一天的小时，12小时制，用空格填充（␣0..23） 
    %L      Milliseconds of the second
            毫秒
    %m      Month of the year (01..12)
            一年中的月份（01..12）
    %M      Minute of the hour (00..59)
            一小时中的分钟数（00..59）
    %n      Newline
            换行
    %N      Fractional seconds
            秒的小数部分
    %p      Meridian indicator (“AM” or “PM”)
            上下午指示（AM或PM）
    %P      Meridian indicator (“am” or “pm”)
            上下午指示（am或pm）
    %r      12 hour time (%I:%M:%S %p)
            12小时制时间 (%I:%M:%S %p)
    %R      24 hour time (%H:%M)
            24小时制时间 (%I:%M)
    %s      Number of seconds since 1970-01-01 00:00:00 UTC
            从开始的秒数
    %S      Second of the minute (00..60)
            一分钟里的秒数（00..60）
    %t      Tab
            指标符
    %T      24 hour time (%H:%M:%S)
            24小时制时间（%H:%M:%S）
    %u      Day of the week (Monday is 1, 1..7)
            一周中的星期几（星期一是1, 1..7）
    %U      Week number of the current year, starting with the first Sunday as the first day of the first week (00..53)
            一年的星期数（00..53）；从第一个星期日开始数起，它作为第一个星期的第一天。
    %w      Day of the week (Sunday is 0, 0..6)
            一周中的星期几（周日是0, 0..6）
    %v      VMS date (%e-%^b-%4Y)
            虚拟机日期 (%e-%^b-%4Y)
    %V      ISO8601 week number (01..53)
            ISO8601 周数（01..53）
    %W      Week number of the current year, starting with the first Monday as the first day of the first week (00..53)
            今年的星期数（00..53）；从第一个星期一开始数起，它作为第一个星期的第一天。
    
    %x      Preferred representation for the date alone, no time
            首选的日期表示；只有日期，没有时间
    %X      Preferred representation for the time alone, no date
            首选的时间表示；只有时间，没有日期
    %y      Year without a century (00..99)
            不带世纪的年数（00..99）
    %Y      Year with century
            带有世纪的年数
    %z      Time zone offset (+/-hhmm). 
            时区偏移（+/=hhmm）
            Use %:z or %::z to format with colons
            使用%:z或%::z带冒号格式 
    %Z      Time zone name
            时区
    %%      Literal % character
            字面上的%字符<kinder:note> 重复了。第一个也是这个。


Any text not listed as a directive will be passed through to the output string.
任何没有作为指定列出的字符串将传给输出字符。

    t = Time.now
    t.strftime("Printed on %m/%d/%Y") # => "Printed on 05/27/2013"
    t.strftime("at %I:%M%P") # => "at 12:33pm"
    # force the am/pm flag to upper case
    t.strftime("at %I:%M%^P") # => "at 12:33PM"

#### subsec  秒小数部分有理化

    time.subsec → tational

Return just the fractional number of seconds in time as a rational. 
将time里秒数的小数部分表示为有理数。
(Compare with Time#usec, which returns an integer.)
（和Time#usec比较，Time#usec返回一个整数）

    t = Time.now
    t.usec   # => 436218
    t.subsec # => (218109/500000)

#### succ  进位

    time.succ → later_time

Deprecated.
不推荐使用。
Use time + 1.
使用time + 1。

#### to_a  转为数组

    time.to_a → array

Returns a ten-element array of values for time: {[sec, min, hour, day, month, year, wday, yday, isdst, zone]}. 
返回表示time值的十个元素的数组：{[秒，分，时，天，月，年，星期几，年中天数，是否夏令时，时区]}。
See the individual methods for an explanation of the valid ranges of each value. 
关于每个值的有效范围的说明，参见各个方法。
The ten elements can be passed directly to the methods Time.utc or Time.local to create a new Time.
这十个元素可以直接传递给Time.utc或者Time.local方法来创建新的Time。

    Time.now.to_a # => [14, 33, 12, 27, 5, 2013, 1, 147, true, "CDT"]

#### to_f  转为浮点数

    time.to_f → float

Returns the value of time as a floating-point number of seconds since epoch. 
以浮点数方式返回time的值--自新纪元以来的秒数。
Consider using `Time#to_r` if accuracy is required.
如果需要精确的值可以考虑使用`Time#to_r`方法。

    Time.now.to_f # => 1369675994.585341

#### to_i  转为整数

    time.to_i → int

Returns the value of time as an integer number of seconds since epoch.
以整数返回time的值--自新纪元以来的秒数。

    Time.now.to_i # => 1369675994

#### to_r  转为有理数

    time.to_r → rational

Returns a rational number containing time as a number of seconds since epoch (including fractional seconds).
以有理数返回time的值--自新纪元以来的秒数。

    Time.now.to_r # => (54787039789213/40000)

#### to_s  转为字符串

    time.to_s → string

Returns a string representing time. 
返回一个表示time的字符串。
Equivalent to calling Time#strftime with a format string of "%Y-%m-%d %H:%M:%S %z" (with UTC replacing the time zone for a UTC time).
等同于以UTC替代时区时间使用格式字符"%Y-%m-%d %H:%M:%S %z"调用Time#strftime。

    Time.now.to_s # => "2013-05-27 12:33:14 -0500"
    Time.utc(2011, 12, 25, 1, 2, 3).to_s # => "2011-12-25 01:02:03 UTC"

#### tv_nsec  纳秒

    time.tv_nsec → int

Synonym for Time#nsec.
同Time#nsec。

#### tv_sec  整秒

    time.tv_sec → int

Synonym for `Time#to_i`.
同`Time#to_i`。

#### tv_usec  毫秒

    time.tv_usec → int

Synonym for Time#usec.
同Time#usec。

#### usec  整毫秒

    time.usec → int

Returns just the number of microseconds for time. 
返回time的毫秒数。
(Compare with Time#subsec, which returns a rational.)
（对比Time#subsec，Time#subsec返回一个有理数。）

    t = Time.now       # => 2013-05-27 12:33:14 -0500
    "%10.6f" % t.to_f  # => "1369675994.878664"
    t.nsec             # => 878664000
    t.usec             # => 878664

#### utc  统一协调时间

    time.utc → time

Synonym for Time#gmtime.
同Time#gmtime。

    t = Time.now # => 2013-05-27 12:33:14 -0500
    t.utc?       # => false
    t.utc        # => 2013-05-27 17:33:14 UTC
    t.utc?       # => true

#### utc?  是否统一协调时间

    time.utc? → true or false

Returns true if time represents a time in UTC.
如果time是用UTC表示一个时间，返回true。

    t = Time.now                        # => 2013-05-27 12:33:15 -0500
    t.utc?                              # => false
    t = Time.gm(2000,"jan",1,20,15,1)   # => 2000-01-01 20:15:01 UTC
    t.utc?                              # => true

#### utc_offset  转换偏移

    time.utc_offset → int

Synonym for `Time#gmt_offset`.
同`Time#gmt_offset`。

#### wday  星期几

    time.wday → int

Returns an integer representing the day of the week, 0..6, with Sunday == 0.
返回一个整数，表示一周中的星期几，从0到6，星期日是0.

    t = Time.now # => 2013-05-27 12:33:15 -0500
    t.wday # => 1

#### yday  年中天数

    time.yday → int

Returns an integer representing the day of the year, 1..366.
返回一个表示年的天数的整数，1..366.

    t = Time.now # => 2013-05-27 12:33:15 -0500
    t.yday # => 147

#### year  年数

    time.year → int

Returns the year for time (including the century).
返回time的年数（包含世纪）。

    t = Time.now # => 2013-05-27 12:33:15 -0500
    t.year # => 2013

#### zone  时区  1.8

    time.zone → string

Returns the name of the time zone used for time.
返回time使用的时区名称。

    t = Time.gm(2000, "jan", 1, 20, 15, 1)
    t.zone # => "UTC"
    t = Time.local(2000, "jan", 1, 20, 15, 1)
    t.zone # => "CST"


## TracePoint  追踪点 ⇡New in 2.0⇣
### 概述
Using tracepoints you can trace the execution of certain events in your running program.
使用追踪点你可以追踪到你运行中的程序里特定时间的执行。
The TracePoint class obsoletes the prior set_trace_func method.
追踪点类废除了之前的`set_trace_func`方法。
When you create a trace point object, you give it the names of one or more events that you want to monitor. 
当你创建一个追踪点对象时，你给你要监视的一个或多个事件命名。
You also pass it a block. 
你也可以将它传入一个block。
Whenever a monitored event fires, the block is invoked, passing in the trace point object, which now contains a description of that particular event event. 
不管被监视事件何时起火，block都会被调用，传入该追踪点对象，该对象现在包含一个该特定事件的事件描述。
Trace point objects are initially disabled—you need to enable them before they start firing.
追踪点对象最初是关闭的--你需要激活它们，在它们开始开火之前。

    tp = TracePoint.new(:line, :call, :return) do |tp|
      p tp
    end
    tp.enable
    def add(a,b)
      a + b
    end
    p add(1,2)
    tp.disable
    # produces:
    # #<TracePoint:line@prog.rb:7>
    # #<TracePoint:line@prog.rb:11>
    # #<TracePoint:call `add'@prog.rb:7>
    # #<TracePoint:line@prog.rb:8 in `add'>
    # #<TracePoint:return `add'@prog.rb:9>
    # 3
    # #<TracePoint:line@prog.rb:13>

The events you can capture are:
你可捕获的事件有：

    :b_call          block entry
                     块项目
    :b_return        block exit
                     块退出
    :c_call          call a C-language routine
                     调用一个C语言程序
    :c_return        return from a C-language routine
                     从C语言程序中返回
    :call            call a Ruby method
                     调用一个Ruby方法
    :class           start class/module definition
                     开始一个类/模块定义
    :end             end a class/module definition
                     结束一个类/模块定义
    :line            execute a ne source code line
                     执行一个ne源代码行
                     <kinder:note> 什么叫做ne？
    :raise           raise an exception
                     抛出一个异常
    :return          return from a Ruby method
                     从一个ruby方法中返回
    :thread_begin    start a thread
                     开始一个线程
    :thread_end      end a thread
                     结束一个线程

### Class Methods 类方法
#### new  新建

    TracePoint.new( ‹ event_names ›* ) { |tp| … } → tp

Creates a new tracer for the given event names (or all events if no list is given). 
为给定事件名称（如果没有给出列表则是所有事件）创建一个新的追踪。
The returned object is both used to enable and disable this tracer and as the object that is passed to the block when the events trigger. 
返回的对象既可用于关闭这个追踪，也在时间被触发时作为传给block。
See the sample code at the start of this section to see this in action, and the table that follows it for a list of event names.
观察这个方法的作用，可参见本章开头的例子代码，和随后的事件名称的表格。

#### trace  追踪

    TracePoint.trace( ‹ event_names ›* ) { |tp| … } → tp

Sets up a trace point handler an immediately enables it.
设置一个追踪点处理器并马上开启它。
<kinder:note> 这个an，应该是and的笔误。

    tp = TracePoint.trace do |tp|
      p tp
    end
    a = 1
    b = 2
    tp.disable
    produces:
    #<TracePoint:c_return `trace'@prog.rb:1>
    #<TracePoint:line@prog.rb:4>
    #<TracePoint:line@prog.rb:5>
    #<TracePoint:line@prog.rb:6>
    #<TracePoint:c_call `disable'@prog.rb:6>


### Instance Methods 实例方法
#### binding  绑定

    tp.binding → binding_of_event

The binding at the time of the event.
当时事件的绑定。

#### defined_class  定义类

    tp.defined_class → singleton class

The class or module in which the event occurred.
事件发生所在的类或模块。

#### disable  关闭跟踪

    tp.disable → true or false

Disable this tracer, returning true if the tracer was enabled at the time.
如果当时跟踪器正打开着，关闭跟踪器，并返回true。

#### enable  激活跟踪

    tp.enable → true or false

Enable this tracer, returning true if the tracer was already enabled.
如果跟踪器已经被开启，开启这个跟踪器，并返回true。
<kinder:note>又是笔误吧。前面部分应该改为：如果跟踪器已经被关闭。

#### enabled?  是否激活跟踪

    tp.enabled? → true or false

Returns true if the tracer is enabled.
如果跟踪器已经被激活，返回true。

#### event  事件

    tp.event → symbol

Returns the name of the event. 
返回事件的名称。
See the table at the start of this section.
参见这一章开头的那个表格。

#### lineno  行号

    tp.lineno → fixnum

The source line number where the event occurred.
所发生事件在源文件的行号。

#### method_id  方法标识符

    tp.method_id → symbol

The name of the method in which the event occurred.
发生的事件所在的方法名。

#### path  路径

    tp.path → string

The full path to the Ruby source file in which the event occurred.
发生事件所在的ruby源文件的完全路径。

#### raised_exception  抛出异常

    tp.raised_exception → Exception

The exception raised for a :raise event.
为一个:raise时间抛出一个异常。

#### return_value  返回值

    tp.return_value → obj

The value returned by a :return event.
一个:return事件返回的值。

#### self  自身

    tp.self → obj

The value of self at the time the event occurred.
事件发生时self的值。


## TrueClass  真

The global value true is the only instance of class TrueClass and represents a logically true value in boolean expressions. 
全局变量true只是TrueClass类的一个实例，它在布尔表达式中表示一个逻辑为真的值。
The class provides operators allowing true to be used in logical expressions.
TrueClass类提供了一些操作符，允许在逻辑表达式中使用true。

### Instance Methods 实例方法
#### &  与

    true & obj → true or false

And—Returns false if obj is nil or false and returns true otherwise.
与--如果obj是nil或者false，返回false；否则返回true。

#### ^  异或

    true ^ obj → true or false

Exclusive Or—Returns true if obj is nil or false and returns false otherwise.
异或--如果obj是nil或者false，返回fasle；否则返回true。

#### |  或

    true | obj → true

Or—Returns true. 
或--返回true。
Because obj is an argument to a method call, it is always evaluated; shortcircuit evaluation is not performed in this case.
当obj是方法调用的一个参数时，它总是被求解；在这种情况下，不会执行短路求解。

    true | puts("or")
    true || puts("logical or")
    # produces:
    # or


## UnboundMethod  未绑定方法  1.8
###   概述
Ruby supports two forms of objectified methods. 
Ruby支持两种方法对象化的形式。

Class Method is used to represent methods that are associated with a particular object: these method objects are bound to that object.
Method类用来表示那些与特定对象相关联的方法：这些方法被绑定到这个对象。
Bound method objects for an object can be created using Object#method.
与一个对象相绑定的方法对象可以用Object#method来创建。

Ruby also supports unbound methods, which are method objects that are not associated with a particular object. 
ruby也支持未绑定方法，它们是那些没有与特定对象相关联的方法对象。
These can be created either by calling unbind on a bound method object or by calling `Module#instance_method`.
可以对一个已绑定的对象调用unbind或者调用`Module#instance_method`来创建这些方法对象。

Unbound methods can be called only after they are bound to an object. 
未绑定方法只有当它们绑定到一个对象后才能被调用。
That object must be a `kind_of?` the method’s original class.
未绑定方法的原始类必须是这个对象的类或者超类（通过`kind_of?`）。

    class Square
      def area
        @side * @side
      end
      def initialize(side)
        @side = side
      end
    end
    area_unbound = Square.instance_method(:area)
    s = Square.new(12)
    area = area_unbound.bind(s)
    area.call # => 144

Unbound methods are a reference to the method at the time it was objectified: subsequent changes to the underlying class will not affect the unbound method.
未绑定方法是当该方法被对象化时对它的一个引用：对这个底层类的后续修改不会影响未绑定方法。
<kinder:note> 这个特性可要当心。

    class Test
      def test
        :original
      end
    end
    um = Test.instance_method(:test)
    class Test
      def test
        :modified
      end
    end
    t = Test.new
    t.test # => :modified
    um.bind(t).call # => :original

### Instance Methods 实例方法
#### arity 参数个数 

    umeth.arity → fixnum

See Method#arity on page 565.
参见前面2版543页4版565页的Method#arity。

#### bind  绑定  1.8

    umeth.bind( obj ) → method

Bind umeth to obj. 
将umeth绑定到obj。
The class of obj must be the same as or a descendent of the class from which umeth was originally obtained.
obj的类必须和umeth的类一样，或者是该类的派生，该umeth是从该类获得。

    Line 1  class A
         -    def test
         -      puts "In test, class = #{self.class}"
         -    end
         5  end
         -  class B < A
         -  end
         -  class C < B
         -  end
         10
         -  um = B.instance_method(:test)
         -  bm = um.bind(C.new)
         -  bm.call
         -  bm = um.bind(B.new)
         15 bm.call
         -  bm = um.bind(A.new)
         -  bm.call
    # produces:
    # from prog.rb:16:in `<main>'
    # In test, class = C
    # In test, class = B
    # prog.rb:16:in `bind': bind argument must be an instance of B (TypeError)

#### name  名称  1.9

    umeth.name → string

Returns the name of the method umeth.
返回umeth方法的名称。

    um = String.instance_method(:upcase)
    um.name # => :upcase

#### owner  所有者  1.9

    umeth.owner → module

Returns the class or module in which umeth is defined.
返回定义了umeth的类或者方法。

    um = String.instance_method(:upcase)
    um.owner # => String

#### parameters  参数  1.9

    umeth.parameters → array

Returns a description of the method’s parameter list. 
返回一个方法参数列表的描述。
See Method#parameters for details.
详见Method#parameters。

#### source_location  源代码位置  1.9

    umeth.source_location → [ filename, lineno ] or nil

Returns the source filename and line number where umeth was defined or nil if self was not defined in Ruby source. 
返回定义了umeth的源文件和行号；如果umeth自身没有在ruby源文件中定义，返回nil。
See `Method#source_location` for an example.
参见`Method#source_location`中的例子。



# 　第28章　标准库
## 概述
The Ruby interpreter comes with a large number of classes, modules, and methods built in —they are available as part of the running program. 
ruby解释器带有大量内建的类、模块和方法--它们成为运行程序的一部分。
When you need a facility that isn’t part of the built-in repertoire, you’ll often find it in a library that you can require into your program.
如果你需要的功能不属于这个内建体系，通常你能在某一个库中找到它，并把这个库包括到你的程序中。
Sometimes you’ll need to download one of these libraries (perhaps as a Ruby gem).
有时你将需要下载这些库中的一个（可能作为ruby的gem）。

However, Ruby also ships as standard with a large number of libraries. 
当然，ruby页提供了数量众多的标准库。
Some of these are written in pure Ruby and will be available on all Ruby platforms. 
其中一些库是纯ruby语言编写的，因此可以在所有ruby平台上使用它们。
Others are Ruby extensions, and some of these will be present only if your system supports the resources that they need.
还有一些库是ruby的扩展，其中某些扩展只有当你的系统支持它们所需要的资源时才是可用的。
All can be included into your Ruby program using require. 
所有标准库都可以通过实用require。
And, unlike libraries you may find on the Internet, you can pretty much guarantee that all Ruby users will have these libraries already installed on their machines.
同时，与互联网上发现的那些库不同，你几乎可以确保所有ruby用户都已经把这些标准库安装到了他们的机器上。

Ruby 1.9 has more than 100 standard libraries included in the distribution.
Ruby 1.9 这个版本拥有超过100个标准库。
For each of these libraries, this section shows a one- or a two-page summary. 
对于这些标准库，这一章每一两页介绍一个库。
For each library, we give some introductory notes and typically an example or two of use. 
对于每个库，我们会给出一些介绍性的注解，和一两个实用样例。
You won’t find detailed method descriptions here; for that, consult the library’s own documentation.
载这里你将找不到详细的方法描述；有关这方面的内容，请参考库本身的文档。

It’s all very well suggesting that you “consult the library’s own documentation,” but where can you find it? The answer is that it depends. 
“请参考库本身的文档”是一个相当好的建议，但是你可以在哪里找到它呢？答案是“视情况而定”。
Some libraries have already been documented using RDoc (see Chapter 19, Documenting Ruby, on page 263). 
一些库已经实用了RDoc文档（参见2版16章4版263页19章）。
That means you can use the ri command to get the documentation.
这意味着你可以使用ri命令来得到它们的文档。

If there’s no RDoc documentation available, the next place to look is the library. 
如果没有RDoc文档可用，下一个要查的地方是库本身。
If you have a source distribution of Ruby, these library files are in the ext/ and lib/ subdirectories. 
如果你要ruby的发行源版，它们位于ext/和lib/ 子目录中。
If instead you have a binary-only installation, you can still find the source of pure-Ruby library modules (normally in the lib/ruby/1.9/ directory under your Ruby installation). 
如果只装了二进制文件，你依然可以找到那些纯ruby库模块的源码（通常是在你ruby安装路径/lib/ruby/1.9/目录中）。
Often, library source directories contain documentation that the author has not yet converted to RDoc format.
通常，库的源码目录包含了一些原作者还未来得及转换成Rdoc格式的文档。

If you still can’t find documentation, turn to your search engine of choice. 
如果你依然没有找到任何文档，那么求助于搜索引擎。
Many of the Ruby standard libraries are also hosted as external projects. 
许多Ruby标准库作为外部项目单独存在。
The authors develop them stand-alone and then periodically integrate the code into the standard Ruby distribution. 
库的作者独立地开发它们，然后定期把代码整合到标准的Ruby发行版中。
For example, if you want detailed information on the API for the YAML library, Try searching for yaml ruby—you’ll probably end up at `http://www.yaml.org/YAML_for_ruby.html`.
比如，你想得到YAML库API的详细信息，可尝试搜索yaml ruby--你将可能找到`http://www.yaml.org/YAML_for_ruby.html`。

The next port of call is the ruby-talk mailing list. 
下一个求助的地方是ruby-talk邮件列表。
Ask a (polite) question there, and chances are that you’ll get a knowledgeable response within hours. 
在那里提出一个（有礼貌的）问题，如果运气好的话，在短短几个小时之内，你就可以得到一个知识渊博的回答。
See the tips in Section A1.3, Mailing Lists, on page 830 for pointers on how to subscribe.
关于如何订阅邮件列表，参见后面2版784页4版A1.3的提示。

And if you still can’t find documentation, you can always follow Obi Wan’s advice and do what we did when documenting Ruby—use the source. 
如果你依然没有找到任何文档，你总是可以遵循Obi Wan的忠告，做我们以前写ruby文档时所做的事情--直接阅读源码。
You’d be surprised at how easy it is to read the actual source of Ruby libraries and work out the details of usage.
你会惊讶地发现，阅读ruby库的实际源码同时弄清用法的细节，是多么简单。

⇡New in 2.0⇣
There are some libraries that we don’t document, either because they are pretty low level or because we cover them extensively elsewhere in the book. 
有些库我们这里没有列出，可能因为它们太低级了，也可能因为我们在书中其他地方讨论到了。
These libraries include:
这些库包括：

•  debug—the Ruby debugger, covered in Section 14.1, Ruby Debugger, on page 195.
         ruby调试器，在195页的14.1节。
•  iconv—has been removed from Ruby 2.0. Use String#encode.
         ruby 2.0已经把它删除。可以使用String#encode。
•  mkmf—covered in the online guide to extending Ruby.
        扩展ruby的在线指南。
•  objspace—extensions to the ObjectSpace class designed to be used by the Ruby core team.
            ObjectSpace类的扩展，ruby核心组所使用。
•  psych—an interface to libyaml. You’ll probably just use the YAML library.
         一个libyaml的界面。你可能只使用YAML库。
•  racc—this is the runtime used by the Racc parser generator. If you need this library, you’ll also need the external Racc system.
        Racc剖析器产生器使用的运行时。如果你需要这个库，将也需要外部的Racc系统。
• rake—see Section 15.6, The Rake Build Tool, on page 222.
       参见前面222页的15.6节。
• rdoc—see Chapter 19, Documenting Ruby, on page 263.
       参见前面263页的19章。
• rubygems—covered in Section 15.5, RubyGems Integration, on page 217 and in Using RubyGems, on page 234.
            在前面217页的15.5节，和234页。

## 28.1 Library Changes in Ruby 1.9  库的变化
These are the library changes in Ruby 1.9:
下面是在ruby 1.9中变化的库。
• Much of the Complex and Rational libraries are now built in to the interpreter.  
很多复数和有理数库已经内建到解释器中了。
However, requiring the external libraries adds some functionally.  
不过，包括外部库可以增加一些功能。
In the case of Rational, this functionality is minimal.
对于有理数来说，这个功能很小。
• The CMath library has been added.
增加了CMath库。
• The Enumerator library is now built in.
Enumerator库已经内建。
• The Fiber library has been added (it adds coroutine support to fibers).
增加了Fiber库（它为纤程增加了协同）。
• The Fiddle library (an interface to libffi, which supports calling functions in shared librries) is documented as a replacement for DL.
Fiddle库（一个libffi的界面，支持在共享库中调用函数）替代了DL库。
• ftools has been removed (and replaced by fileutils).
删除了ftools库，用fileutils替代。
• The Generator library has been removed (use fibers).
删除了Generator库（使用纤程）。
• Notes on using irb from inside applications have been added.
注意增加了从应用程序内部使用irb的功能。
• jcode has been removed in favor of built-in encoding support.
删除了jcode。使用内建的编码支持。
• The json library has been added.
增加了json库。
• The matrix library no longer requires that you include mathn.
包含mathn库时不再需要包含matrix库。
• The mutex library is now built in.
mutex库改为内建。
• parsedate has been removed. The Date class handles most of its functionality.
删除了parsedate。Date类拥有它大部分的功能。
• readbytes has been removed. Class IO now supports the method directly.
删除了readbytes。IO类直接支持该方法。
• A description of Ripper has been added.
增加了Ripper的描述。<kinder:note> 怎么没有印象啊。
• A description of SecureRandom has been added.
增加了SecureRandom的描述。
• The shell library has been omitted, because it seems more like a curiosity than something folks would use (and it’s broken under 1.9).
省略了shell库。因为它看起来让人好奇，而不是能使用的folk（在1.9下不能用了）。
• The soap library has been removed.
删除了soap库。
• I’ve omitted the sync library. It is broken under 1.9, and the monitor library seems to be cleaner.
我忽略了sync库。它在ruby 1.9下不能使用，monitor库看起来更干净。
• Win32API is now deprecated in favor of using the DL library.
不推荐Win32API，推荐使用DL库。

## Library Abbrev  缩写

Generate Sets of Unique Abbreviations
生成唯一缩写集合

Given a set of strings, calculates the set of unambiguous abbreviations for those strings and returns a hash where the keys are all the possible abbreviations and the values are the full strings.  
给定一组字符串，计算出这些字符串的明确的缩写集合，并返回一个散列表，键是所有可能的缩写，值是相应的完整字符串。
Thus, given input of “car” and “cone,” the keys pointing to “car” would be “ca” and “car,” and those pointing to “cone” would be “co,” “con,” and “cone.”
因此，给定输出为“car”和“cone”，指向“car”的键可能是“ca”和"car"，而指向“cone”的键可能是“co”，“con”和“cone”。

An optional pattern or a string may be specified—only those input strings matching the pattern, or beginning with the string, are considered for inclusion in the output hash.
可以指定一个可选的模式或者字符串--只有那些匹配这个模式或者以这个指定字符串开头的输入字符串才会被考虑添加到输出散列表中。

Including the Abbrev library also adds an abbrev method to class Array.
包含Abbre库也会添加abbrev方法到Array类中。

• Shows the abbreviation set of some words:
  显示某些词的缩写集合

    require 'abbrev'
    Abbrev::abbrev(%w{ruby rune}) # => {"ruby"=>"ruby", "rub"=>"ruby",
                                  # .. "rune"=>"rune", "run"=>"rune"}

• A trivial command loop using abbreviations:
  使用缩写的一个普通的命令循环：
   <kinder:note> 看起来这是在解析命令行参数，不过如果输入st，那么下面这个循环会判定它是什么呢？是else。这个库是足够聪明的，它生成的缩写一定是足够和其他元素区别开来的。

    require 'abbrev'
    COMMANDS = %w{ sample send start status stop }.abbrev
    while line = gets
      line = line.chomp
      case COMMANDS[line]
      when "sample" then
        # ...
      when "send" then
        # ...
        # ...
      else
        STDERR.puts "Unknown command: #{line}"
      end
    end


## Library Base64  基于64的表示法

Base64 Conversion Functions
Base64转换函数

Performs encoding and decoding of binary data using a Base64 representation.  
使用Base64表示法对二进制数据进行编码和解码。
This allows you to represent any binary data in purely printable characters.  
这可以让你用纯打印字符表示任何二进制数据。
The encoding is specified  in RFC 2045 and RFC 4648.[1]
在RFC2045和RFC4648中详细说明了这种编码格式。

### wiki资料
<kinder:note> 下面的资料来自wiki（http://zh.wikipedia.org/wiki/Base64）：
Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个位元为一个单元，对应某个可打印字符。三个字节有24个位元，对应于4个Base64单元，即3个字节需要用4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后binhex的版本使用不同的64字符集来代表6个二进制数字，但是它们不叫Base64。
Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据。包括MIME的email，email via MIME,在XML中存储复杂数据.

• Encodes and decodes strings.  
  对字符串进行解码和编码。
  Note the newlines inserted into the Base64 string.
  注意换行符插入了Base64字符串。

    require 'base64'
    str = "Now is the time for all good coders\nto learn Ruby"
    converted = Base64.encode64(str)
    puts converted
    puts Base64.decode64(converted)
    # produces:
    # Tm93IGlzIHRoZSB0aW1lIGZvciBhbGwgZ29vZCBjb2RlcnMKdG8gbGVhcm4g
    # UnVieQ==
    # Now is the time for all good coders
    # to learn Ruby

• Now uses RFC 4648 variants:
  现在使用RFC4648变量：

    require 'base64'
    str = "Now is the time for all good coders\nto learn Ruby"
    converted = Base64.strict_encode64(str)
    puts converted
    puts Base64.strict_decode64(converted)
    # produces:
    # Tm93IGlzIHRoZSB0aW1lIGZvciBhbGwgZ29vZCBjb2RlcnMKdG8gbGVhcm4gUnVieQ==
    # Now is the time for all good coders
    # to learn Ruby

[1].  http://www.faqs.org/rfcs/rfc2045.html and http://www.faqs.org/rfcs/rfc4648.html

## Library Benchmark  基准

Time Code Execution
代码执行时间

Allows code execution to be timed and the results tabulated.  
允许对代码的执行进行计时，并以表格形式给出计时结果。
The Benchmark module is easier to use if you include it in your top-level environment.
如果把Benchmark模块包含在你的顶层环境中，使用这个模块变得更加容易。
See also: Profile (page 791)
另见Profile（见2版717页4版791页）

• Compares the costs of four kinds of method dispatch:
  比较三种类型的dispatch方法的成本。

    require 'benchmark'
    include Benchmark
    string = "Stormy Weather"
    m = string.method(:length)
    bm(6) do |x|
      x.report("direct") { 100_000.times { string.length } }
        x.report("call") { 100_000.times { m.call } }
        x.report("send") { 100_000.times { string.send(:length) } }
        x.report("eval") { 100_000.times { eval "string.length" } }
    end                                    
    # produces:
    #         user      system    total       real
    # direct  0.010000  0.000000  0.010000  ( 0.012705)
    # call    0.020000  0.000000  0.020000  ( 0.022576)
    # send    0.020000  0.000000  0.020000  ( 0.020664)
    # eval    1.220000  0.000000  1.220000  ( 1.224656)

• Which is better: reading all of a dictionary and splitting it or splitting it line by line? 
  哪种方法更好：一次性读取字典的所有内容，然后分割出各个词条；或每次只读取一行内容，然后分割词条？
 Use bmbm to run a rehearsal before doing the timing:
  在计时之前，使用bmbm进行一次预演。

    require 'benchmark'
    include Benchmark
    bmbm(6) do |x|
      x.report("all") do
        str = File.read("/usr/share/dict/words")
        words = str.scan(/[-\w']+/)
      end
      x.report("lines") do
        words = []
        File.foreach("/usr/share/dict/words") do |line|
          words << line.chomp
        end
      end
    end
    # produces:
    # Rehearsal -----------------------------------------
    # all     0.200000   0.010000   0.210000 ( 0.218034)
    # lines   0.150000   0.020000   0.170000 ( 0.165469)
    # --------------------------------- total: 0.380000sec
    #        user     system   total      real
    # all    0.180000 0.010000 0.190000 ( 0.185983)
    # lines  0.290000 0.010000 0.300000 ( 0.302548)

## Library BigDecimal   带小数点的十进制数

Large-Precision Decimal Numbers
高精度十进制数

Ruby’s standard Bignum class supports integers with large numbers of digits.  
Ruby的标准Bignum类支持有很多数字位的整数。
The BigDecimal class supports decimal numbers with large numbers of decimal places.  
而BigDecimal类支持有很多小数位的十进制。
The standard library supports all the normal arithmetic operations.  
这个标准库支持了所有标准的算术运算。
BigDecimal also comes with some extension libraries.
BigDecimal也提供了一些扩展库。
### bigdecimal/ludcmp
Performs an LU decomposition of a matrix.
对矩阵执行LU分解。
### bigdecimal/math
Provides the transcendental functions sqrt, sin, cos, atan, exp, and log, along with functions for computing PI and E.  
连同计算PI和E的函数一起，提供了超越函数sqrt、sin、cos、atan、exp和log。
All functions take an arbitrary precision argument.
所有函数都接受一个任意的精度参数。
### bigdecimal/jacobian
Constructs the Jacobian (a matrix enumerating the partial derivatives) of a given function.
构建给定函数的雅可比行列式（枚举偏导数的一个矩阵）。
Not dependent on BigDecimal.
不依赖BigDecimal。
### bigdecimal/newton
Solves the roots of nonlinear function using Newton’s method. 
使用牛顿方法解决非线性函数的根。
Not dependent on BigDecimal.
不依赖BigDecimal。
### bigdecimal/nlsolve
Wraps the bigdecimal/newton library for equations of big decimals.
为BigDecimal方程式包装bigdecimal/newton库。

You can find English-language documentation in the file `ext/bigdecimal/bigdecimal_en.html` in the Ruby source distribution.
可以在Ruby源发行版的`ext/bigdecimal/bigdecimal_en.html`文件中找到其英文文档。
• Calculate the area of a circle using BigDecimal numbers
  使用BigDecimal数计算圆形的面积

    require 'bigdecimal'
    require 'bigdecimal/math'
    include BigMath
    pi = BigMath::PI(20) # 20 is the number of decimal digits
    radius = BigDecimal("2.14156987652974674392")
    area = pi * radius**2
    area.to_s # => "0.144083540446856044176720033806679561688599846410
              # .. 445032583215824758780405545861780909930190528E2"

•  The same with regular floats
   如果使用普通的浮点数则是：

    radius = 2.14156987652974674392
    Math::PI * radius**2 # => 14.408354044685602

## Library CGI  普通网关接口

CGI Programming Support
CGI编程支持

The CGI class provides support for programs used as Common Gateway Interface (CGI) scripts in a web server.  
在一个web服务器中，CGI类提供了对CGI脚本程序的支持。
CGI objects are initialized with data from the environment and from the HTTP request, and they provide convenient accessors to form data and cookies.  
CGI对象使用来自环境的数据和来自HTTP请求的数据来初始化，同时它们为访问表单数据和cookie也提供了便利。
They can also manage sessions using a variety of storage mechanisms. 
它们也可以使用各种各样的存储机制管理会话。 
Class CGI also provides basic facilities for HTML generation and class methods to escape and unescape requests and HTML.
CGI类也提供了生成HTML的基本设施，和类方法对请求和HTML进行转义和反向转义。
See also: CGI::Session (page 737)
另见后面2版661页4版737页的CGI::Session。

• Escapes and unescapes special characters in URLs and HTML.  
转义和反向转义URL和HTML中的特殊字符。
Numeric entities less than 256 will be encoded based on the encoding of the input string.  
小于256的数字实体将被基于输入字符串的编码进行编码。
Other numeric entities will be left unchanged.
其他数字实体将被保留而不做改变。

    require 'cgi'
    CGI.escape('c:\My Files')                       # => c%3A%5CMy+Files
    CGI.unescape('c%3a%5cMy+Files')                 # => c:\My Files
    CGI::escapeHTML('"a"<b & c')                    # => &quot;a&quot;&lt;b &amp; c
    CGI.unescapeHTML('&quot;a&quot;&lt;=&gt;b')     # => "a"<=>b
    CGI.unescapeHTML('&#65;&#x41;')                 # => AA
    str = '2&#x3c0;r'                               
    str.force_encoding("utf-8")
    CGI.unescapeHTML(str)                           # => 2πr

• Access information from the incoming request:
  访问'进入'请求中的信息：

    require 'cgi'
    c = CGI.new
    c.auth_type   # => "basic"
    c.user_agent  # => "Mozscape Explorari V5.6"

• Access form fields from an incoming request.  
  访问输入请求中的表单字段。
Assume that the following script, installed as test.cgi, was linked to using `http://mydomain.com/test.cgi?fred=10&barney=cat`:
假设下面的脚本已经以test.cgi文件安装在系统中，那么用户可以使用`http://mydomain.com/test.cgi?fred=10&barney=cat`链接到它。

    require 'cgi'
    c = CGI.new
    c['fred'] # => "10"
    c.keys # => ["fred", "barney"]  <kinder:note> barney是在什么地方定义的？
    c.params # => {"fred"=>["10"], "barney"=>["cat"]}

• If a form contains multiple fields with the same name, the corresponding values will be returned to the script as an array.  
如果表单有多个名字相同的字段，这些字段相应的值会以一个数组返回给这个脚本。
The [] accessor returns just the first of these—index the result of the params method to get them all.
[]访问方法只是返回它的第一个值--应当对params方法的结果进行索引以得到所有的值。
In this example, assume the form has three fields called “name”:
在这个例子中，假设这个表单有三个“name”字段。

    require 'cgi'
    c = CGI.new
    c['name']          # => "fred"
    c.params['name']   # => ["fred", "wilma", "barney"]
    c.keys             # => ["name"]
    c.params           # => {"name"=>["fred", "wilma", "barney"]}

• Sends a response to the browser.  
发送一个响应到浏览器。
(Not many folks use this form of HTML generation–use one of the templating libraries described in Section 20.3, Templating Systems, on page 280.
（没有多少人使用这种形式来生成HTML。请考虑使用其中一个模板化库--参见前面2版239页4版280页的20.3节）

    require 'cgi'
    cgi = CGI.new("html5")
    cgi.http_header("type" => "text/html", "expires" => Time.now + 30)
    cgi.out do
      cgi.html do
        cgi.head{ cgi.title{"Hello World!"} } +
        cgi.body do
          cgi.pre do
            CGI::escapeHTML(
            "params: " + cgi.params.inspect + "\n" +
            "cookies: " + cgi.cookies.inspect + "\n")
          end
        end
      end
    end

• Stores a cookie in the client browser:
在客户端浏览器存储cookie。

    require 'cgi'
    cgi = CGI.new("html5")
    cookie = CGI::Cookie.new('name' => 'mycookie',
                              'value' => 'chocolate chip',
                              'expires' => Time.now + 3600)
    cgi.out('cookie' => cookie) do
      cgi.head + cgi.body { "Cookie stored" }
    end


• Retrieves a previously stored cookie:
  得到之前存储的cookie。

    require 'cgi'
    cgi = CGI.new("html5")
    cookie = cgi.cookies['mycookie']
    cgi.out('cookie' => cookie) do
      cgi.head + cgi.body { "Flavor: " + cookie[0] }
    end

## Library CGI::Session  CGI会话

CGI Sessions
CGI会话

A CGI::Session maintains a persistent state for web users in a CGI environment.  
CGI::Session在CGI环境中为web用户维护一个持久的状态。
Sessions may be memory resident or may be stored on disk.  
会话可能驻留在内存中或者存储在硬盘内。
See the discussion in Sessions, on page 285 for details.
详细信息参见2版246页4版285页的讨论。
See also: CGI (page 735)
另见上一个库：CGI。

    # sl_cgi_session/session.rb
    # Store the timestamp of last access, along with the access count
    # 存储最后一次访问的时间戳，和访问次数。
    # using a session object
    # 使用一个会话对象。
    require 'cgi'
    require 'cgi/session'
    cgi = CGI.new("html3")
    sess = CGI::Session.new(cgi,
                            "session_key" => "rubyweb",
                            "prefix" => "web-session.")
    if sess['lastaccess']
      msg = "<p>You were last here #{sess['lastaccess']}.</p>"
    else
      msg = "<p>Looks like you haven't been here for a while</p>"
    end
    count = (sess["accesscount"] || 0).to_i
    count += 1
    msg << "<p>Number of visits: #{count}</p>"
    sess["accesscount"] = count
    sess["lastaccess"] = Time.now.to_s
    sess.close
    cgi.out {
      cgi.html {
        cgi.body {
          msg
        }
      }
    }

## Library CMath   复数超验函数  1.9

Complex Transcendental Functions
复数超验函数

As of Ruby 1.9, the Complex class is built in to the interpreter.  
到了ruby 1.9，复数类内建到了解释器。
There is no need to require the complex library to create and manipulate complex numbers.  
创建和计算复数时没有必要包含复数库了。
However, if you want the transcendental functions defined by Math to work with complex numbers, you must also require the cmath library.  
不过，如果你想通过Math定义超验函数来操作复数，你必须也包含cmath库。
The functions affected are as follows: acosh, acos, asinh, asin, atan2, atanh, atan, cosh, cos, exp, log10, log, sinh, sin, sqrt, tanh, and tan.
受到影响的函数包含下面：acosh, acos, asinh, asin, atan2, atanh, atan, cosh, cos, exp, log10, log, sinh, sin, sqrt, tanh, 和tan。
The complex library makes these complex functions the default (so, if you require 'complex', you can use Math::sin and not CMath::sin).
complex库让这些复数函数返回默认状态（因此，如果你包含了'complex’，你可以使用Math::sin，而不是CMath::sin）

    require 'cmath'
    point = Complex(2, 3)
    CMath::sin(point) # => (9.15449914691143-4.168906959966565i)
    CMath::cos(point) # => (-4.189625690968807-9.109227893755337i)

## Library Complex  实数  1.9更新

Complex Numbers
实数

Loads the cmath library, which defines the transcendental functions for complex numbers.
导入cmath库，该库定义了实数的超验函数。
It then arranges things so that these complex-aware functions are the ones invoked when you use Math::.  
当你使用Math::时，它会进行安排，让这些感知复数函数是被调用中的一个。
The net effect is that, after requiring complex, you can use functions such as Math::sin on any numeric value, including complex numbers.
实际结果是，在你包含这个库之后，你可以使用例如Math::sin这样的函数在你的任何数值上，包括负数。
• Using transcendental numbers with complex arguments will, by default, cause an error:
  带复数参数使用超验数字，默认导致一个错误。

    point = Complex(2, 3)
    Math::sin(point)
    # produces:
    # from prog.rb:2:in `sin'
    # from prog.rb:2:in `<main>'
    # prog.rb:2:in `to_f': can't convert 2+3i into Float (RangeError)

• However...
  不过

    require 'complex'
    point = Complex(2, 3)
    Math::sin(point) # => (9.15449914691143-4.168906959966565i)

## Library Continuation  持续  1.9

Continuations
持续

Continuation objects are generated by the Object#callcc method, which becomes available only when the continuation library is loaded.  
持续对象由Object#callcc方法所创建，该方法只有在载入持续库时才会可用。
They hold a return address and execution context, allowing a nonlocal return to the end of the callcc block from anywhere within a program.
它们保持一个返回地址和执行内容，允许一个nonlocal从程序的任何位置返回到callcc块的结尾。

Continuations are somewhat analogous to a structured version of C’s setjmp/longjmp (although they contain more state, so you may consider them closer to threads).  
持续有些类似于C的setjmp/logjmp的构造版本（虽然c里的包含更多状态信息，所以你可能会认为它们更接近线程）。
This (somewhat contrived) example allows the inner loop to abandon processing early.
这个例子（有些造作）允许内部循环放弃之前的处理。

• Does a nonlocal exit when a condition is met:
  符合条件时进行nonlocal退出：

    require 'continuation'
    callcc do |cont|
      for i in 0..4
        print "\n#{i}: "
        for j in i*5...(i+1)*5
          cont.call() if j == 7
          printf "%3d", j
        end
      end
    end
    print "\n"
    # produces:
    # 0:  0 1 2 3 4
    # 1:  5 6

• The call stack for methods is preserved in continuations:
  方法的调用堆栈在持续中保存：

    require 'continuation'
    def strange
      callcc {|continuation| return continuation}
      print "Back in method, "
    end
    print "Before method. "
    continuation = strange()
    print "After method. "
    continuation.call if continuation
    # produces:
    # Before method. After method. Back in method, After method.


## Library coverage  覆盖  1.9

Experimental Code Coverage Analysis
实验性的代码覆盖分析

The coverage module counts the number of times each line of Ruby code is executed in one or more source files and provides a summary as a hash.  
coverage模块计算一个或多个源文件里面每一行ruby代码执行的次数，并提供一个摘要的散列表。
The keys of the hash are the names of files that were analyzed, and the values are each an array containing counts (on a per-line basis).
散列表的键是所要分析的文件名称，值是包含计数（以行为单位）的数组。

Here’s a simple implementation of the Fizz Buzz program:
这是一个Fizz Buzz程序的简单实现。

    # sl_coverage/fizzbuzz.rb
    1.upto(100).with_object('') do |i, x|
      if i % 3 == 0
        x += 'Fizz'
      end
      if i % 5 == 0
        x += 'Buzz'
      end
      if x.empty?
        puts i
      else
        puts x
      end
    end


And here’s a program that loads and runs that program, using the coverage library to report on execution counts.  
这里的这个程序装载并运行上面的程序，使用coverage库来报告执行的计数。
(Note that it discards the output of the FizzBuzz program, simply to save space on this page.)
（注意它丢弃了FizzBuzz程序的输出，只是为了本页节约空间）

    require 'coverage'
    Coverage.start
    STDOUT.reopen("/dev/null")
    require_relative 'fizzbuzz.rb'
    Coverage.result.each do |file_name, counts|
      File.readlines(file_name).each.with_index do |code_line, line_number|
        count = counts[line_number] || "--"
        STDERR.printf "%3s: %s", count, code_line
      end
    end
    # produces:
    #   1: 1.upto(100).with_object('') do |i, x|
    # 100:   if i % 3 == 0
    #  33:     x += 'Fizz'
    #  --:   end
    # 100:   if i % 5 == 0
    #  20:     x += 'Buzz'
    #  --:   end
    # 100:   if x.empty?
    #  53:     puts i
    #  --:   else
    #  47:     puts x
    #  --:   end
    #  --: end

## Library CSV  逗号分割值

Comma-Separated Values
逗号分割值

Comma-separated data files are often used to transfer tabular information (and are a lingua franca for importing and exporting spreadsheet and database information).
以逗号分隔的数据文件，常常用于传递表格式信息（它们是一种通用语，用来导入和导出电子表格和数据库信息。）  
As of Ruby 1.9, the old library has been replaced by James Edward Gray II’s FasterCSV version.  
到了Ruby 1.9，旧的库已经被James Edward Gray II的FasterCSV版本替代了。
It has a few incompatibilities with the original.  
它和原来的版本有些不兼容。
In particular, CSV.open now works like File.open, not File.foreach, and options are passed as a hash and not positional parameters.
在细节上，CSV.open现在类似File.open，不像File.foreach，而选项也被作为散列表而不是位置参数传递。

Ruby’s CSV library deals with arrays (corresponding to the rows in the CSV file) and strings (corresponding to the elements in a row).  
Ruby的CSV库处理数组（对应于CSV文件中的一行）和字符串（对应于一行中的元素）。
If an element in a row is missing, it will be represented as a nil in Ruby.
如果某行缺少了一个元素，这个元素在ruby中用nil表示。
The files used in these examples are as follows:
用以下示例中使用的数据文件：

    # sl_csv/csvfile
    12,eggs,2.89,
    2,"shirt, blue",21.45,special
    1,"""Hello Kitty"" bag",13.99

    # sl_csv/csvfile_hdr
    Count,Description,Price
    12,eggs,2.89,
    2,"shirt, blue",21.45,special
    1,"""Hello Kitty"" bag",13.99

• Reads a file containing CSV data and processes line by line:
  读取含有CSV数据的文件，一行接一行地处理：

    require 'csv'
    CSV.foreach("csvfile") do |row|
      qty = row[0].to_i
      price = row[2].to_f
      printf "%20s: $%5.2f %s\n", row[1], qty*price, row[3] || "---"
    end
    # produces:
    #              eggs: $34.68 --
    #       shirt, blue: $42.90 special
    # "Hello Kitty" bag: $13.99 ---

• Processes a CSV file that contains a header line.  
  处理带有标题行的CSV文件。
  Automatically converts fields that look like numbers.
  自带转换看起来像是数字的字段。

    require 'csv'
    total_cost = 0
    CSV.foreach("csvfile_hdr", headers: true, converters: :numeric) do |data|
      total_cost += data["Count"] * data["Price"]
    end
    puts "Total cost is #{total_cost}"
    # produces:
    # Total cost is 91.57

• Writes CSV data to an existing open stream (STDOUT in this case).  
  把CSV数据写入到一个已经打开的流（在这个例子中，是STDOUT）。
  Uses | as the column separator.
  使用 | 作为分隔符。

    require 'csv'
    CSV(STDOUT, col_sep: "|") do |csv|
      csv << [ 1, "line 1", 27 ]
      csv << [ 2, nil, 123 ]
      csv << [ 3, "|bar|", 32.5]
    end
    # produces:
    # 1|line 1|27
    # 2||123
    # 3|"|bar|"|32.5

• Accesses a CSV file as a two-dimensional table:
  将CSV文件作为二维表来访问。

    require 'csv'
    table = CSV.read("csvfile_hdr",
                      headers: true,
                      header_converters: :symbol)
    puts "Row count = #{table.count}"
    puts "First row = #{table[0].fields}"
    puts "Count of eggs = #{table[0][:count]}"
    table << [99, "red balloons", 1.23]   # 增加一行
    table[:in_stock] = [10, 5, 10, 10]    # 增加一列
    puts "\nAfter adding a row and a column, the new table is:"
    puts table
    # produces:
    # Row count = 3
    # First row = ["12", "eggs", "2.89", nil]
    # Count of eggs = 12
    # After adding a row and a column, the new table is:
    # 增加一行和一列后，新的表格是：
    # count,description,price,,in_stock
    # 12,eggs,2.89,,10
    # 2,"shirt, blue",21.45,special,5
    # 1,"""Hello Kitty"" bag",13.99,10
    # 99,red balloons,1.23,,10

## Library Curses  CRT屏幕处理

CRT Screen Handling
CRT屏幕处理

The Curses library is a thin wrapper around the C curses or ncurses libraries, giving applications a device-independent way to draw on consoles and other terminal-like devices.  
Curses库是对C语言curses或者ncurses库的一个相当精简的包装，它为程序提供了一种在控制台或其他类终端设备上、与设备无关的绘图方式。
As a nod toward object-orientation, curses windows and mouse events are represented as Ruby objects.  
作为对面向对象的推崇，curses窗口和鼠标事件都是以ruby对象来表示的。
Otherwise, the standard curses calls and constants are simply defined in the Curses module.
另外，在Curses模块中简单定义了标准的curses调用和常量。

Only if: curses or ncurses installed in target environment 
仅当在目标环境中安装有curses或者ncurses时才适用。

    # sl_curses/pong_paddle.rb
    # Draw the paddle for game of 'pong' that moves in response to up and down keys
    # 绘画一个‘pong’游戏，里面的桨可以跟随键盘的上下键移动。
    require 'curses'
    include Curses
    class Paddle
      HEIGHT = 4
      PADDLE = " \n" + "|\n"*HEIGHT + " "
      def initialize
        @top = (Curses::lines - HEIGHT)/2
        draw
      end
      def up
        @top -= 1 if @top > 1
      end
      def down
        @top += 1 if (@top + HEIGHT + 1) < lines
      end
      def draw
        setpos(@top-1, 0)
        addstr(PADDLE)
        refresh
      end
    end
    init_screen
    begin
      cbreak
      noecho
      stdscr.keypad(true)
      paddle = Paddle.new
      loop do
        case ch = getch
        when "Q", "q"            then break
        when Key::UP, 'U', 'u'   then paddle.up
        when Key::DOWN, 'D', 'd' then paddle.down
        else beep
        end
        paddle.draw
      end
    ensure
      close_screen
    end

## Library Date/DateTime  日期和时间操作

Date and Time Manipulation
日期和时间操作

The date library implements classes Date and DateTime, which provide a comprehensive set of facilities for storing, manipulating, and converting dates with or without time components.
date库实现了Date和DateTime类，它们提供了一组完备的设施来保存、操作和转换那些带时间部分或者不带时间部分的日期。
The classes can represent and manipulate civil, ordinal, commercial, Julian, and standard dates, starting January 1, 4713 BCE.  
这些类可以表示和操作始于公元前4713年1月1日的民用日、年日、历周日、儒略日和标准日期。
The DateTime class extends Date with hours, minutes, seconds, and fractional seconds, and it provides some support for time zones.  
DateTime用小时、分、秒和小数秒扩展了Date，它提供了对时区的支持。
The classes also provide support for parsing and formatting date and datetime strings.  
这些类页提供了对解析和格式化date和datetime字符串的支持。
The classes have a rich interface—consult the ri documentation for details.  
这些类的接口很丰富--参考ri文档得到细节。
The introductory notes in the file lib/date.rb in the Ruby source tree are also well worth reading.
在源树上的lib/date.rb文件中的介绍性注释也非常值得一读。

• Experiment with various representations:
  感受各种各样的表示

    require 'date'
    d = Date.new(2000, 3, 31)
    [d.year, d.yday, d.wday]      # =>  [2000, 91, 5]
    [d.month, d.mday]             # =>  [3, 31]
    [d.cwyear, d.cweek, d.cwday]  # =>  [2000, 13, 5]
    [d.jd, d.mjd]                 # =>  [2451635, 51634]
    d1 = Date.commercial(2000, 13, 7)  
    d1.to_s                       # =>  "2000-04-02"
    [d1.cwday, d1.wday]           # =>  [7, 0]

• Essential information about Christmas:
  关于圣诞节的基本信息：

    require 'date'
    now = DateTime.now
    year = now.year
    year += 1 if now.month == 12 && now.day > 25
    xmas = DateTime.new(year, 12, 25)
    diff = xmas - now
    puts "It's #{diff.to_i} days to Christmas"
    puts "Christmas #{year} falls on a #{xmas.strftime('%A')}"
    # produces:
    # It's 211 days to Christmas
    # Christmas 2013 falls on a Wednesday

## Library DBM  数据库管理

Interface to DBM Databases
访问DBM数据库的接口

DBM files implement simple, hashlike persistent stores.  
DBM文件实现了简单、类似散列表的持久存储。
Many DBM implementations exist: the Ruby library can be configured to use one of the DBM libraries db, dbm (ndbm), gdbm, and qdbm.  
现在已经有很多DBM的实现--可以配置这个Ruby库来使用任何一种DBM库db dbm(ndbm) gdbm和qdbm。
The interface to DBM files is similar to class Hash, except that DBM keys and values will be strings.  
除了DBM的键和值是字符串外，DBM的文件接口与Hash类相似。
This can cause confusion, as the conversion to a string is performed silently when the data is written.  
这可能引起混淆，因为当写入数据时，数据会悄悄地被转换成字符串。
The DBM library is a wrapper around the lower-level access method.  
DBM库是对较低底层访问方法的一个包装。
For true low-level access, see also the GDBM and SDBM libraries.
关于真正低级别的对数据库的访问，另见GDBM和SDBM库。

Only if: a DBM library is installed in target environment
仅当在目标环境中安装有DBM库时才适用。

See also: gdbm (page 760) sdbm (page 803)
另见gdbm（后面2版682页4版760页）和sdbm（后面2版730页4版803页）

The following creates a simple DBM file and then reopens it read-only and reads some data.
下面创建一个简单的DBM文件，然后以只读方式重新打开它，并读取一些数据。
Note the conversion of a date object to its string form.
注意date对象转换到了其他字符串形式。

    # sl_dbm/dbm1.rb
    require 'dbm'
    require 'date'
    DBM.open("data.dbm") do |dbm|
      dbm['name'] = "Walter Wombat"
      dbm['dob'] = Date.new(1997, 12,25)
    end
    DBM.open("data.dbm", nil, DBM::READER) do |dbm|
      p dbm.keys
      p dbm['dob']
      p dbm['dob'].class
    end
    # Produces:
    # ["name", "dob"]
    # "1997-12-25"
    # String

## Library Delegator  调用委托

Delegate Calls to Other Object
将调用委托给其他对象

Object delegation is a way of composing objects—extending an object with the capabilities of another—at runtime.  
delegation对象是一种在运行时组合对象的方式--使用其他对象的能力来扩展一个对象。
The Ruby Delegator class implements a simple but powerful delegation scheme, where requests are automatically forwarded from a master class to delegates or their ancestors and where the delegate can be changed at runtime with a single method call.
ruby的Delegator类实现了一个既简单又功能强大的委托机制，它会自动把请求从主类转发到这些委托者或它们的祖先，同时可以使用单个方法调用在运行时改变受托者。
See also: Forwardable (page 759)
另见Forwardable（2版680页4版759页）

• For simple cases where the class of the delegate is fixed, make the master class a subclass of DelegateClass, passing the name of the class to be delegated as a parameter.  
  最简单的情况是受托者类是固定不变的，而使主类成为DelegateClass的一个子类，把要委托的名称作为参数传入。
In the master class’s initialize method, pass the object to be delegated to the superclass.
在主类的initialize方法中，把要委托的对象传递给超类。

    require 'delegate'
    class Words < DelegateClass(Array)
      def initialize(list = "/usr/share/dict/words")
        words = File.read(list).split
        super(words)
      end
    end
    words = Words.new
    words[9999] # => "anticontagionist"
    words.size # => 235886
    words.grep(/matz/) # => ["matzo", "matzoon", "matzos", "matzoth"]

• Use SimpleDelegator to delegate to a particular object (which can be changed):
  使用SimpleDelegator来委托给一个特定的对象（它可以改变）。
require 'delegate'

    words = File.read("/usr/share/dict/words").split
    names = File.read("/usr/share/dict/propernames").split
    stats = SimpleDelegator.new(words)
    stats.size # => 235886
    stats[226] # => "abidingly"
    stats.__setobj__(names)    # <kinder:note> 什么意思？
    stats.size # => 1308
    stats[226] # => "Deirdre"

## Library Digest  安全摘要算法

MD5, RIPEMD-160 SHA1, and SHA2 Digests
MD5, RIPEMD-160 SHA1, 和 SHA2 摘要

The Digest module is the home for a number of classes that implement message digest algorithms: MD5, RIPEMD-160, SHA1, and SHA2 (256, 384, and 512 bit).  
Digest模块包含许多实现了安全摘要算法的类：MD5, RIPEMD-160, SHA1, and SHA2 (256, 384, and 512 bit)。
The interface to all these classes is identical.
所有这些类的接口是一样的。
• You can create a binary or hex digest for a given string by calling the class method digest or hexdigest.
通过调用类方法digest或hexdigest，可以为给定的字符串创建二进制或者十六进制摘要。
• You can also create an object (optionally passing in an initial string) and determine the object’s hash by calling the digest or hexdigest instance methods.  
你也可以创建一个对象（可传入一个可选的初始字符串），同时调用digest或者hexdigest实例方法来得到这个对象的散列值。
You can then append to the string using the update method and then recover an updated hash value.
你可以使用update方法把散列值附加到这个字符串中，然后重新获得一个更新的散列值。
• Calculates some MD5 and SHA1 hashes:
  计算某些MD5和SHA1散列值：

    require 'digest/md5'
    require 'digest/sha1'
    for hash_class in [ Digest::MD5, Digest::SHA1 ]
      puts "Using #{hash_class.name}"  # [1]
      # Calculate directly
      puts hash_class.hexdigest("hello world")  # [2]
      # Or by accumulating
      digest = hash_class.new
      digest << "hello"
      digest << " "
      digest << "world"
      puts digest.hexdigest   # [3]
      puts digest.base64digest # new in 1.9.2  [4]
      puts
    end
    # produces:
    # Using Digest::MD5  [1]
    # 5eb63bbbe01eeed093cb22bb8f5acdc3 [2]
    # 5eb63bbbe01eeed093cb22bb8f5acdc3 [3]
    # XrY7u+Ae7tCTyyK7j1rNww== [4]
    # Using Digest::SHA1         第二个循环[1]
    # 2aae6c35c94fcfb415dbe95f408b9ce91ee846ed [2]
    # 2aae6c35c94fcfb415dbe95f408b9ce91ee846ed  [3]
    # Kq5sNclPz7QV2+lfQIuc6R7oRu0=  [4]

## Library dRuby   分布式ruby

Distributed Ruby Objects (drb)
分布式ruby对象

dRuby allows Ruby objects to be distributed across a network connection.  
dRuby允许ruby对象跨过一个网络连接进行分布式操作。
Although expressed in terms of clients and servers, once the initial connection is established, the protocol is effectively symmetrical: either side can invoke methods in objects on the other side.  
虽然使用了客户端和服务器的术语，一旦建立了初始连接，协议实际是对称的：每一端的对象都可以调用另一端的方法。
Normally, objects passed and returned by remote calls are passed by value; including the DRbUndumped module in an object forces it to be passed by reference (useful when implementing callbacks).
一般，远程调用传递和返回的对象通过value来传递；在一个对象中包含DRbUndumped模块会强制它通过指向（实现调用时是很有用的）来传递。
See also: Rinda (page 798) XMLRPC (page 826)
另见Rinda（798页）和XMLPRC（826页）。

• This server program is observable—it notifies all registered listeners of changes to a count value:
  这个服务器程序是可观察的--它通知所有已注册的听者的改变到一个count值。

    # sl_drb/drb_server1.rb
    require 'drb'
    require 'drb/observer'
    class Counter
      include DRb::DRbObservable
      def run
        5.times do |count|
          changed
          notify_observers(count)
        end
      end
    end
    counter = Counter.new
    DRb.start_service('druby://localhost:9001', counter)
    DRb.thread.join


• This client program interacts with the server, registering a listener object to receive callbacks before invoking the server’s run method:
  这个客户端程序和服务器进行交互，在调用服务器的run方法之前，注册一个听者对象来接受调用。

    # sl_drb/drb_client1.rb
    require 'drb'
    class Listener
      include DRbUndumped
      def update(value)
        puts value
      end
    end
    DRb.start_service
    counter = DRbObject.new(nil, "druby://localhost:9001")
    listener = Listener.new
    counter.add_observer(listener)
    counter.run

## Library English  全局符号的英文名

English Names for Global Symbols
全局符号的英文名

Includes the English library file in a Ruby script, and you can reference the global variables such as `$_` using less-cryptic names, listed in the following table.  
在一个ruby脚本中包含English库，你可以使用没那么隐秘的名称来引用例如`$_`之类的全局变量。
Prior to Ruby 1.9, the name `$PROGRAM_NAME` was declared using English.  
ruby 1.9之前，`$PROGRAM_NAME`被使用Enlish声明。
It is now predefined in the Ruby interpreter.
现在的ruby解释器已经预定义好了。

    \toprule $*  $ARGV                       命令行参数
    $?           $CHILD_STATUS               子进程退出状态
    $<           $DEFAULT_INPUT              默认输入
    $>           $DEFAULT_OUTPUT             默认输出
    $!           $ERROR_INFO                 异常信息；
    $@           $ERROR_POSITION             异常位置；调用栈的数组
    $=           $IGNORECASE                   匹配是忽略大小写；ruby 1.9删除。
    $.           $NR                           读入的最后一行的行号
    $.           $INPUT_LINE_NUMBER            读入的最后一行的行号 
    $,           $OFS                          输出字段分隔符
    $,           $OUTPUT_FIELD_SEPARATOR       输出字段分隔符（同$OFS）
    $;           $FS                           字段分隔符
    $;           $FIELD_SEPARATOR              字段分隔符
    $\           $ORS                          输出记录分隔符
    $\           $OUTPUT_RECORD_SEPARATOR      输出记录分隔符（同$ORS）
    $/           $RS                           输入记录分隔符
    $/           $INPUT_RECORD_SEPARATOR       输入记录分隔符
    $~           $LAST_MATCH_INFO              成功匹配结果的对象
    $+           $LAST_PAREN_MATCH             匹配了的序号最高的组的字符串
    $_           $LAST_READ_LINE               最后读入的一行
    $"           $LOADED_FEATURES              已载入文件名的数组
    $&           $MATCH                        匹配的字符串
    $'           $POSTMATCH                    匹配之后的字符串
    $`           $PREMATCH                     匹配之前的字符串
    $$           $PID                          执行程序的进程号
    $$           $PROCESS_ID                   所执行程序的进程号

The following code shows some regular variable names along with their English counterparts.
下面的代码显示了一些普通的变量名，和它们对应的英语名称。
    require 'English'
    $OUTPUT_FIELD_SEPARATOR = ' -- '
    "waterbuffalo" =~ /buff/
    print $., $INPUT_LINE_NUMBER, "\n"
    print $', $POSTMATCH, "\n"
    print $$, $PID
    # produces:
    # 0 -- 0 --
    # alo -- alo --
    # 24658 -- 24658

## Library erb    模板

Lightweight Templating for HTML
HTML的轻量级模板技术

ERb is a lightweight templating system, allowing you to intermix Ruby code and plain text.
ERb是一个轻量级的模板系统，允许你将Ruby代码和纯文本相互混合。
This is sometimes a convenient way to create HTML documents but also is usable in other plain-text situations.  
通常这是以一种方便的方式来创建HTML文档，但对于其他纯文本的情况也非常有用。
See Section 20.3, Templating Systems, on page 280 for other templating solutions.
关于其他模板方案，参见前面2版239页4版280页20.3节“模板系统”。

ERB breaks its input text into chunks of regular text and program fragments.  
ERB将它的输入文本分解为普通文本和程序段落。
It then builds a Ruby program that, when run, outputs the result text and executes the program fragments.
然后它建立一个ruby程序，在运行时输出结果的文本，并执行程序段 。
Program fragments are enclosed between <% and %> markers.  
程序段用<%和%>标记包围起来。
The exact interpretation of these fragments depends on the character following the opening <%:
对这些段落的实际解释，取决于左标记<%。

Table 26—Directives for ERB  表格26 ERB指令
Sequence                   Action
序列                       动作
<% ruby code %>            Inserts the given Ruby code at this point in the generated program.
                           If it outputs anything, include this output in the result.
                           将此处指定的ruby代码插入到产生的程序中。
                           如果有任何的输出，将它包含在结果中。
<%= ruby expression %>     Evaluate expression and insert its value in the output of the generated program.
                           求解表达式，并将它的值插入到产生程序的输出中。
<%# ... %>                 Comment (ignored).
                           注释（被忽略）。
<%% and %%>                Replaced in the output by <% and%> respectively.
                           在输出中分别替代为<%和%>。

The following code uses <%…%> blocks to execute a Ruby loop, and <%=…%> to substitute a value into the output.
下面的代码使用 <%…%>块来执行一个ruby循环，用 <%=…%>来替代一个值到输出中。

    require 'erb'
    input = %{<% high.downto(low) do |n|
      # set high, low externally %>
      <%= n %> green bottles, hanging on the wall
      <%= n %> green bottles, hanging on the wall
      And if one green bottle should accidentally fall
      There'd be <%= n-1 %> green bottles, hanging on the wall
      <% end %>}
    high,low = 10, 8
    erb = ERB.new(input)
    erb.run(binding)
    # produces:
    # 10 green bottles, hanging on the wall
    # 10 green bottles, hanging on the wall
    # And if one green bottle should accidentally fall
    # There'd be 9 green bottles, hanging on the wall
    # . . .

An optional second parameter to ERB.new sets the safe level for evaluating expressions.  
ERB.new的可选的第二参数可以设置求解表达式的安全级别。
If nil, expressions are evaluated in the current thread; otherwise, a new thread is created, and its $SAFE level is set to the parameter value.
如果为nil，表达式在当前线程中被求解；否则创建一个新线程，并且它的$SAFE级别被设置为参数的值。

The optional third parameter to ERB.new allows some control of the interpretation of the input and of the way whitespace is added to the output.  
ERB.new的第三个可选参数可以对输入的解释以及向输出添加空格的方式进行一定的控制。
If the third parameter is a string and that string contains a percent sign, then ERb treats lines starting with a percent sign specially.
如果第三个参数是一个字符串，并且字符串包含一个百分号，那么ERB会对百分号开始的行有特别的对待。
Lines starting with a single percent sign are treated as if they were enclosed in <%...%>.  
对待一个由带百分号开头的行，如同它们在<%...%>中一样。
Lines starting with a double percent sign are copied to the output with a single leading percent sign.
由双百分号开始的行，会被拷贝到输出中，由一个百分号开头。

    require 'erb'
    str = %{\
    % 2.times do |i|
        This is line <%= i %>
    % end
    %%%done}
    ERB.new(str, 0, '%').run
    # produces:
    # This is line 0
    # This is line 1
    # %%done

If the third parameter contains the string <>, then a newline will not be written if an input line starts with an ERB directive and ends with %>.  
如果第三个参数包括字符串<>，而输入行由一个ERB指令开头并由%>结尾，那么换行不会被输出。
If the trim parameter contains >>, then a newline will not be written if an input line ends %>.
如果修剪的参数包括>>，输入行以%>结尾，那么换行不会被输出。

    require 'erb'
    str1 = %{\
    * <%= "cat" %>
    <%= "dog" %>
    }
    ERB.new(str1, 0, ">").run
    ERB.new(str1, 0, "<>").run
    # produces:
    # * catdog* cat
    # dog

The erb library also defines the helper module ERB::Util that contains two methods: `html_escape` (aliased as h) and `url_encode` (aliased as u).  
erb库也定义了辅助模块ERB:Util，包括两个方法：`html_escape`（别名为h）和`url_encode`（别名为u）。
These are equivalent to the CGI methods escapeHTML and escape, respectively (except escape encodes spaces as plus signs, and `url_encode` uses %20).
这分别对应CGI方法escapeHTML和escape（不同的是，escape将空格编码为0,`url_encode`则使用%20）。

    require 'erb'
    include ERB::Util
    str1 = %{\
              h(a) = <%= h(a) %>
              u(a) = <%= u(a) %>
              }
    a = "< a & b >"
    ERB.new(str1).run(binding)
    # produces:
    # h(a) = &lt; a &amp; b &gt;
    # u(a) = %3C%20a%20%26%20b%20%3E

You may find the command-line utility erb is supplied with your Ruby distribution.  
ruby发布提供了命令行工具erb。
This allows you to run erb substitutions on an input file; see erb --help for details.
对输入文件运行erb时你可以使用对等的选项；更多细节参见--help。

## Library Etc   用户和组信息

Access User and Group Information in /etc/passwd
访问/etc/passwd中的用户和组信息。

Only if: Unix or Cygwin
只是在Unix或Cygwin系统上可用。

The Etc module provides a number of methods for querying the passwd and group facilities on Unix systems.
Etc模块提供了许多方法来查询Unix系统上passwd和group的功能。

• Finds out information about the currently logged-in user:
  找出当前登录的用户信息：

    require 'etc'
    name = Etc.getlogin
    info = Etc.getpwnam(name)
    info.name # => "dave"
    info.uid # => 501
    info.dir # => "/Users/dave"
    info.shell # => "/bin/zsh"
    group = Etc.getgrgid(info.gid)
    group.name # => "staff"

• Returns the names of users on the system used to create this book:
  返回编写本书所用系统的所有用户名。

    require 'etc'
    users = []
    Etc.passwd {|passwd| users << passwd.name }
    users[1,5].join(", ") # => "_appleevents, _appowner, _appserver, _ard,
                          # .. _assetcache"

• Returns the IDs of groups on the system used to create this book:
  返回编写本书所有系统的所有用户组的id。

    require 'etc'
    ids = []
    Etc.group {|entry| ids << entry.gid }
    ids[1,5].join(", ") # => "55, 87, 81, 79, 33"

## Library expect  等待

Expect Method for IO Objects
IO对象的expect方法

The expect library adds the method expect to all IO objects.  
expect库为所有的IO对象添加了expect方法。
This allows you to write code that waits for a particular string or pattern to be available from the I/O stream.  
这让你可以编写代码，来等待I/O流中出现了某个特定的字符串或模式。
The expect method is particularly useful with pty objects (see the Pty library on page 794) and with network connections to remote servers, where it can be used to coordinate the use of external interactive processes.
expect方法对pty对象（见后面2版720页4版794页）和访问远程服务器的网络连接来说特别有用，它可以用来协调对外部交互进程的使用。

If the global variable `$expect_verbose` is true, the expect method writes all characters read from the I/O stream to STDOUT.
如果全局变量`$expect_verbose`为true，expect方法将所有从IO流中读取的字符写入到标准输出中。
See also: pty (page 794)
另见pty（后面2版720页4版794页）。

• Connects to the local FTP server, logs in, and prints out the name of the user’s directory.
  连接到本地的FTP服务器，登录炳输出用户的目录名。
(Note that it would be a lot easier to do this using the net/ftp library.)
（注意：使用net/ftp库来编写可能容易很多。）

    # This code might be specific to the particular ftp daemon.
    # 这个代码可能只是针对部分fpt守护进程。
    require 'expect'
    require 'socket'
    $expect_verbose = true
    socket = TCPSocket.new('localhost', 'ftp')
    socket.expect("ready")
    socket.puts("user testuser")
    socket.expect("331 User testuser accepted, provide password.")
    socket.puts("pass wibble")
    socket.expect("logged in.\r\n")
    socket.puts("pwd")
    puts(socket.gets)
    socket.puts "quit"
    # produces:
    # 220 ::1 FTP server (tnftpd 20100324+GSSAPI) ready.
    # 331 User testuser accepted, provide password.
    # 230 User testuser logged in.
    # 257 "/Users/testuser" is the current directory.

## Library Fcntl  文件描述符控制

Symbolic Names for IO#fcntl Commands
IO#fcntl命令的符号名

<kinder:note> 这个库的作用我还不理解。
The Fcntl module provides symbolic names for each of the host system’s available fcntl(2) constants (defined in fcntl.h).  
Fcntl模块为主机系统上可用的fcntl(2)常量（在fcntl.h定义）提供了一个符号名。
That is, if the host system has a constant named `F_GETLK` defined in fcntl.h, then the Fcntl module will have a corresponding constant `Fcntl::F_GETLK` with the same value as the header file’s #define.
也就是说，如果主机系统的fcntl.h中有一个名为`F_GETLK`的常量，那么Fcntl模块将有一个对应的`Fcntl::F_GETLK`，和头文件中#define有相同的值。
• Different operating system will have different Fcntl constants available.  
  不同的操作系统有不同的Fcntl常量。
The value associated with a constant of a given name may also differ across platforms.  
同一名称的常量在不同的平台上，所对应的值也有可能是不同的。
Here are the values on our Mac OS X system:
下面是在我Mac OS X系统中的值。

    require 'fcntl'
    Fcntl.constants.sort.each do |name|
    printf "%10s: 0x%06x\n", name, Fcntl.const_get(name)
    end
    # produces:                    <kinder:note> 当然这边是我的lubuntu14.04：
    # FD_CLOEXEC:  0x000001        FD_CLOEXEC: 0x000001
    #    F_DUPFD:  0x000000           F_DUPFD: 0x000000
    #    F_GETFD:  0x000001           F_GETFD: 0x000001
    #    F_GETFL:  0x000003           F_GETFL: 0x000003
    #    F_GETLK:  0x000007           F_GETLK: 0x00000c
    #    F_RDLCK:  0x000001           F_RDLCK: 0x000000
    #    F_SETFD:  0x000002           F_SETFD: 0x000002
    #    F_SETFL:  0x000004           F_SETFL: 0x000004
    #    F_SETLK:  0x000008           F_SETLK: 0x00000d
    #   F_SETLKW:  0x000009          F_SETLKW: 0x00000e
    #    F_UNLCK:  0x000002           F_UNLCK: 0x000002
    #    F_WRLCK:  0x000003           F_WRLCK: 0x000001
    #  O_ACCMODE:  0x000003         O_ACCMODE: 0x000003
    #    O_CREAT:  0x000200          O_APPEND: 0x000400
    #     O_EXCL:  0x000800           O_CREAT: 0x000040
    #   O_NDELAY:  0x000004            O_EXCL: 0x000080
    #   O_NOCTTY:  0x020000          O_NDELAY: 0x000800
    # O_NONBLOCK:  0x000004          O_NOCTTY: 0x000100
    #   O_RDONLY:  0x000000        O_NONBLOCK: 0x000800
    #     O_RDWR:  0x000002          O_RDONLY: 0x000000
    #    O_TRUNC:  0x000400            O_RDWR: 0x000002
    #   O_WRONLY:  0x000001           O_TRUNC: 0x000200
                                     O_WRONLY: 0x000001

## Library Fiber   纤程  1.9

Coroutines Using Fibers
使用纤程进行协同

The Fiber class that is built into Ruby provides a generator-like capability—fibers may be created and resumed from some controlling program.  
内建在ruby的纤程类提供了一个类似生成器的能力--可以创建纤程，并从一些控制中的程序里重开。
If you want to extend the Fiber class to provide full, symmetrical coroutines, you need first to require the fiber library.  
如果你想扩展纤程类来提供完整的、对称均匀的协同，你首先需要包含纤程库。
This adds two instance methods, transfer and alive?, to Fiber objects and adds the singleton method current to the Fiber class.
这将给纤程对象增加两个实例变量，transfer和alive?；增加一个单例方法到纤程类中。

• It is difficult to come up with a meaningful, concise example of symmetric coroutines that can’t more easily be coded with asymetric (plain old) fibers.  
  很难拿出对称协同的意义的、简明的例子，这是非对（平的旧的）称纤程不能更容易写出来。
So, here’s an artificial example:
因此，这是一个人造的例子：

    require 'fiber'
    # take items two at a time off a queue, calling the producer
    # if not enough are available
    # 从队列中一次带着两个项目，如果不够则调用producer。
    consumer = Fiber.new do |producer, queue|
      5.times do
        while queue.size < 2
          queue = producer.transfer(consumer, queue)
        end
        puts "Consume #{queue.shift} and #{queue.shift}"
      end
    end
    # add items three at a time to the queue
    # 同时将三个项目添加到队列中
    producer = Fiber.new do |consumer, queue|
      value = 1
      loop do
        puts "Producing more stuff"
        3.times { queue << value; value += 1}
        puts "Queue size is #{queue.size}"
        consumer.transfer queue
      end
    end
    consumer.transfer(producer, [])
    # produces:
    # Producing more stuff
    # Queue size is 3
    # Consume 1 and 2
    # Producing more stuff
    # Queue size is 4
    # Consume 3 and 4
    # Consume 5 and 6
    # Producing more stuff
    # Queue size is 3
    # Consume 7 and 8
    # Producing more stuff
    # Queue size is 4
    # Consume 9 and 10

## Library Fiddle   动态加载库

Access Dynamically Loaded Libraries (.dll and .so)
访问动态加载库（.dll和.so）

The Fiddle module is a wrapper around libffi, a library that provides access to shared libraries.
Fiddle模块是ibffi的包装，libffi是一个提供共享库访问的库。
On Windows boxes, it can be used to interface with functions in DLLs.  
在 Windows机器上，它可用于访问DLL中的函数。
Under Unix it can load shared libraries.  
在Unix上，它可以加载共享库。
Because Ruby does not have typed method parameters or return values, you must define the types expected by the methods you call by specifying their signatures.
因为ruby没有具体类型的方法参数或返回值，你必须通过指定方法的原型特征，定义它所期许的类型。

• Here’s a trivial C program that we’ll build as a shared library:
  这是一个简单的C程序，我们将用它来构建一个共享库。

    # sl_fiddle/lib.c
    #include <stdio.h>
    int print_msg(char *text, int number) {
      int count = printf("Text: %s (%d)\n", text, number);
      fflush(stdout);
      return count;
    }

• Generates a proxy to access the `print_msg` method in the shared library.  
  产生一个代理来访问共享库中的`print_msg`方法。
  The way this book is built, the shared library is in the same directory as the Ruby code; this directory must be added to the directories searched when looking for dynamic objects.  
   本书使用的方式，共享库放在code/dl子目录；这个目录必须被添加到查找动态对象的搜索目录中。
  You can do this by setting the `DYLD_LIBRARY_PATH` environment variable.
  你可以通过设置`DYLD_LIBRARY_PATH`环境变量来实现。

    require 'fiddle'
    include Fiddle
    lib = Fiddle.dlopen("lib.so")
    print_msg = Fiddle::Function.new(lib['print_msg'],           # entry point  项目点       
                                     [TYPE_VOIDP, TYPE_INT],     # parameter types  参数类型
                                     TYPE_INT)                   # return type  返回类型
    msg_size = print_msg.call("Answer", 42)
    puts "Just wrote #{msg_size} bytes"
    # produces:
    # Text: Answer (42)
    # Just wrote 18 bytes


## Library FileUtils  文件工具

File and Directory Manipulation
文件和目录操作

FileUtils is a collection of methods for manipulating files and directories.  
FileUtils是操作文件和目录的方法的集合。
Although generally applicable, the model is particularly useful when writing installation scripts and Rake tasks.
虽然适用一般的情况，但这个模块在**编写安装脚本**时特别有用。

Many methods take a src parameter and a dest parameter. 
许多方法有src参数和dest参数。 
If dest is a directory, src may be a single filename or an array of filenames.  
如果dest是一个目录，那么src可能是一个文件名或者一个文件名数组。
For example, the following copies the files a, b, and c to /tmp:
例如，下面的代码拷贝文件a b和c到/tmp中：

    cp( %w{ a b c }, "/tmp")

Most functions take a set of options.  
大部分函数有一组选项。
These may be zero or more of the following:
可以有0个或多个：
Option     Meaning
选项       含义
**:verbose**
Traces execution of each function (by default to STDERR, although this can be overridden by setting the class variable `@fileutils_output`.)
追踪每个函数的执行（默认输出到STDERR，不过可以通过设置类变量`@fileutils_output`来改写）。
**:noop**
Does not perform the action of the function (useful for testing scripts).
不要执行函数的动作（对测试脚本很有用处）。
**:force**
Overrides some default conservative behavior of the method (for example, overwriting an existing file).
改写方法的某种比较保守的行为（比如，覆盖一个已有的文件）。
**:preserve**
Attempts to preserve atime, mtime, and mode information from src in dest.
尝试在dest中保留src的atime mtime和状态信息。
(Setuid and setgid flags are always cleared.)
（setuid和setgid标志则总会被清除）

For maximum portability, use forward slashes to separate the directory components of filenames, even on Windows.
为了最大的可移植性，使用前斜线（//）来分割文件名中的目录名，即使在Windows。
FileUtils contains three submodules that duplicate the top-level methods but that have different default options: module FileUtils::Verbose sets the verbose option, module FileUtils::NoWrite sets noop, and FileUtils::DryRun sets verbose and noop.
FileUtils包含三个子模块重复了顶层的方法，但是有不同的默认选项：模块FileUtils::Verbose设置了verbose选项，模块Fileutils::NoWrite设置了noop选项，而Fileutils::DryRun设置了verbose和noop选项。
See also: un (page 821)
另见un（后面2版751页4版821页）

    require 'fileutils'
    include FileUtils::Verbose
    cd("/tmp") do
      cp("/etc/passwd", "tmp_passwd")
      chmod(0666, "tmp_passwd")
      cp_r("/usr/include/net/", "headers")
      rm("tmp_passwd")
      # Tidy up
      rm_rf("headers")
    end
    # produces:
    # cd /tmp
    # cp /etc/passwd tmp_passwd
    # chmod 666 tmp_passwd
    # cp -r /usr/include/net/ headers
    # rm tmp_passwd
    # rm -rf headers
    # cd -

## Library Find  寻找

Traverse Directory Trees
遍历目录树

The Find module supports the top-down traversal of a set of file paths, given as arguments to the find method.  
Find模块支持自顶向下地遍历一组由find方法的参数所指定的文件路径。
If an argument is a file, its name is passed to the block associated with the call.  
如果参数是一个文件，它的名字被传入到block中。
If it’s a directory, then its name and the name of all its files and subdirectories will be passed in.  
如果它是一个目录，那么它的名字及其所有子目录的名字会被传入。
If no block is associated with the call, an Enumerator is returned.
如果没有关联到调用的block，返回一个枚举。

Within the block, the method prune may be called, which skips the current file or directory, restarting the loop with the next directory.  
在block内，方法prune可能被调用，它会跳过当前的文件或目录，使用下一个目录重新开始循环。
If the current file is a directory, that directory will not be recursively entered.  
如果当前文件是一个目录，这个目录不会被递归地进入。
In the following example, we don’t list the contents of the local Subversion cache directories:
在下面的例子中，我们不列出本地Subversion缓存目录的内容。

    require 'find'
    Find.find("/etc/passwd", "code/ducktyping") do |f|
      type = case
             when File.file?(f) then "File: "
             when File.directory?(f) then "Dir: "
             else "?"
             end
    puts "#{type} #{f}"
    Find.prune if f =~ /.svn/
    end
    # produces:
    # File:  /etc/passwd
    # Dir:   code/ducktyping
    # Dir:   code/ducktyping/.svn
    # File:  code/ducktyping/addcust.rb
    # File:  code/ducktyping/roman3.rb
    # File:  code/ducktyping/testaddcust1.rb
    # File:  code/ducktyping/testaddcust2.rb
    # File:  code/ducktyping/testaddcust3.rb

## Library Forwardable  可转发

Object Delegation
对象委托

Forwardable provides a mechanism to allow classes to delegate named method calls to other objects.
Forwardable提供了一个机制，允许类将某个已命名的方法的调用委托给其他对象。
See also: Delegator (page 746)
另见Delegator（前面2版667页4版746页）

• This simple symbol table uses a hash, exposing a subset of the hash’s methods:
  这个简单的符号表使用了散列表，暴露了散列表的部分方法：

    require 'forwardable'
    class SymbolTable
      extend Forwardable
      def_delegator(:@hash, :[], :lookup)   # <kinder:note> 干嘛的？
      def_delegator(:@hash, :[]=, :add)
      def_delegators(:@hash, :size, :has_key?)
      def initialize
        @hash = Hash.new
      end
    end
    st = SymbolTable.new
    st.add('cat', 'feline animal') # => "feline animal"
    st.add('dog', 'canine animal') # => "canine animal"
    st.add('cow', 'bovine animal') # => "bovine animal"
    st.has_key?('cow')             # => true
    st.lookup('dog')               # => "canine animal"

• Forwards can also be defined for individual objects by extending them with the SingleForwardable module. 
  Forward也可让对象从SingleForwardable派生，也可以为个别对象定义转发。
  It’s hard to think of a good reason to use this feature, so here’s a silly one:
  虽然很难想象有什么好的原因来使用这一特性。这里有一个无聊的示例：

    require 'forwardable'
    TRICKS = [ "roll over", "play dead" ]
    dog = "rover"
    dog.extend SingleForwardable
    dog.def_delegator(:TRICKS, :each, :can)
    dog.can do |trick|
      puts trick
    end
    # produces:
    # roll over
    # play dead

## Library GDBM   GNU数据库管理

Interface to GDBM Database
GDBM的数据库接口

Only if: gdbm library available
只有gdbm库可用时才适用。

Interfaces to the gdbm database library.[2] 
访问gdbm数据库函数库的接口。
[2].  http://www.gnu.org/software/gdbm/gdbm.html
Although the DBM library provides generic access to gdbm databases, it doesn’t expose some features of the full gdbm interface, such as the cache size, synchronization mode, reorganization, and locking.  
虽然DBM库提供了对gdbm数据库的一般性的访问，但它并没有暴露gdbm完整接口的部分特性，例如缓存大小、同步模式、重组和加锁。
Only one process may have a GDBM database open for writing (unless locking is disabled).
只有一个进程可以打开GDBM书库库进行写入（除非禁止了加锁）。
See also: DBM (page 745) SDBM (page 803)
另见DBM（前面）和SDBM（后面）。

• Stores some values into a database and then reads them back.  
  将某些值保存到数据库中，然后把它们读取回来。
  The second parameter to the open method specifies the file mode, and the next parameter uses two flags that (1) create the database if it doesn’t exist and (2) force all writes to be synced to disk.  
  open方法的第二个参数指定了文件的模式，下一个参数使用两个标志。其中第一个指示：如果数据库不存在则创建它；第二个强制所有的写操作给同步到磁盘上。
  Create on open is the default Ruby gdbm behavior.
  在打开时创建是ruby的gdbm的默认行为。

    require 'gdbm'
    GDBM.open("data.dbm", 0644, GDBM::WRCREAT | GDBM::SYNC) do |dbm|
      dbm['name'] = "Walter Wombat"
      dbm['dob'] = "1969-12-25"
      dbm['uses'] = "Ruby"
    end
    GDBM.open("data.dbm") do |dbm|
      p dbm.keys
      p dbm['dob']
      dbm.delete('dob')
      p dbm.keys
    end

• Opens a database read-only. The attempt to delete a key would fail.
  以只读方式打开数据库。注意删除一个key的尝试会失败。

    require 'gdbm'
    GDBM.open("data.dbm", 0, GDBM::READER) do |dbm|
      p dbm.keys
      dbm.delete('name') # !! fails !!
    end

## Library GetoptLong  解析命令行参数

Parse Command-Line Options
解析命令行参数

Class GetoptLong supports GNU-style command-line option parsing.  
GetoptLong类支持GNU风格的命令行参数解析。
Options may be a minus sign (-) followed by a single character or may be two minus signs (–) followed by a name (a long option).  
选项可能是一个减号（-）跟着单个字符，也可是两个减号（--）跟着一个名字（长选项）。
Long options may be abbreviated to their shortest unambiguous lengths.
长选项可能是它们名字的缩写--最短明晰长度。

A single internal option may have multiple external representations.  
一个内部选项可以有多个外部表示。
For example, the option to control verbose output could be any of -v, --verbose, or --details.  
比如，控制输出详情的选项可以是-v、--verbose或--details中的一个。
Some options may also take an associated value.
一些选项也可能有相关的值。

Each internal option is passed to GetoptLong as an array, containing strings representing the option’s external forms and a flag.  
每个内部选项都被传入GetoptLong，作为一个数组，包含的字符串表示选项的外在形式或标志。
The flag specifies how GetoptLong is to associate an argument with the option (`NO_ARGUMENT`, `REQUIRED_ARGUMENT`, or `OPTIONAL_ARGUMENT`).
标志指定GetoptLong怎么将一个参数和选项(`NO_ARGUMENT`(没有参数), `REQUIRED_ARGUMENT`(必备参数), or `OPTIONAL_ARGUMENT`(可选参数))联系在一起。

If the environment variable `POSIXLY_CORRECT` is set, all options must precede nonoptions on the command line.  
如果设置了环境变量`POSIXLY_CORRECT`，所有选项必须先于命令行的非选项。
Otherwise, the default behavior of GetoptLong is to reorganize the command line to put the options at the front.  
否则，GetoptLong的默认表现是将命令行重组为将选项放在前面。
This behavior may be changed by setting the attribute GetoptLong#ordering= to one of PERMUTE, `REQUIRE_ORDER`, or `RETURN_IN_ORDER`.  
The environment variable `POSIXLY_CORRECT` may not be overridden.
环境变量`POSIXLY_CORRECT`可能不被改写。

See also: OptionParser (page 784)
另见OptionParser（后面）。

    # Call using "ruby example.rb --size 10k -v -q a.txt b.doc"
    require 'getoptlong'
    # Fake out an initial command line
    ARGV.clear.push *%w(--size 10k -v -q a.txt b.doc)
    # specify the options we accept and initialize
    # the option parser
    opts = GetoptLong.new(
                          [ "--size", "-s",              GetoptLong::REQUIRED_ARGUMENT ],
                          [ "--verbose", "-v",           GetoptLong::NO_ARGUMENT ],
                          [ "--query", "-q",             GetoptLong::NO_ARGUMENT ],
                          [ "--check", "--valid", "-c",  GetoptLong::NO_ARGUMENT ]
    )
    
    # process the parsed options
    opts.each do |opt, arg|
      puts "Option: #{opt}, arg #{arg.inspect}"
    end
    puts "Remaining args: #{ARGV.join(', ')}"
    # produces:
    # Option: --size, arg "10k"
    # Option: --verbose, arg ""
    # Option: --query, arg ""
    # Remaining args: a.txt, b.doc

## Library GServer  通用TCP服务器

Generic TCP Server
通用的TCP服务器

This is a simple framework for writing TCP servers.  
这是编写TCP服务器的一个简单框架。
To use it, subclass the GServer class, set the port (and potentially other parameters) in the constructor, and then implement a serve method to handle incoming requests.
要使用它，继承GServer类，先在构造函数中设置端口号（以及可能的其他参数），然后实现serve方法来处理进入的请求。

GServer manages a thread pool for incoming connections, so your serve method may be running in multiple threads in parallel.
GServer为进入的请求管理一个线程池，所以你的serve方法可能并行运行在多个线程中。

You can run multiple GServer copies on different ports in the same application.
你可以在不同的端口运行同一应用的多个GServer拷贝。

• When a connection is made on port 2000, responds with the current time as a string.
  当连接建立在2000端口时，用当前时间的字符串作为响应。
  Terminates after handling three requests.
  在三次请求过后终止。

    require 'gserver'
    class TimeServer < GServer
      def initialize
        super(2000)
        @count = 3
      end
      def serve(client)
        client.puts Time.now
        @count -= 1
        stop if @count.zero?
      end
    end
    server = TimeServer.new
    server.start.join

• You can test this server by reading from localhost on port 2000.  
  你可以通过读取在2000端口的localhost来测试这个服务器。
  We use curl to do this— you could also use telnet:
  可以使用curl，也可以用telnet：

    $ curl -s localhost:2000
    2013-05-27 12:33:22 -0500

## Library IO/console   IO控制台  1.9

Add console support to IO objects
为IO对象增加控制台支持

Require io/console, and I/O objects associated with terminals gain the methods IO#raw, IO#raw!, IO#getch, IO#echo=, IO#echo?, IO#noecho, IO#winsize, IO#winsize=, IO#iflush, IO#oflush, and IO#ioflush.
包含io/console，和终端相连的IO对象可获得IO#raw IO#raw! IO#getch IO#echo= IO#echo? IO#noecho IO#winsize IO#winsize= IO#iflush IO#oflush和IO#ioflush方法。
The IO class also gains a singleton method, IO.console, which returns an I/O object connected to the controlling terminal of the process.
IO类也得到一个单例类方法，IO.console，返回和进程的控制终端相连的一个IO对象。

• Prompt for a password with no echo.
  用noecho提示一个密码。

    require 'io/console'
    password = STDIN.noecho do
      print "Your password: "
      gets
    end


• What’s the size of the controlling terminal?
  控制终端的大小是什么？

    require "io/console"
    IO.console.winsize # => [22, 137]

## Library IO/nonblock   IO非阻塞  1.9

Turn blocking I/O on and off
开启或关闭IO阻塞。

If a program requires io/nonblock, I/O objects gain the methods IO#nonblock, IO#nonblock?, and IO#nonblock=.  
如果一个程序包含了io/nonblock，IO对象将获得IO#nonblock, IO#nonblock?,和IO#nonblock=方法。

The first takes a block, and runs that block with the given file description in nonblocking mode.  
第一个方法带着一个block，带给定文件描述符在非阻塞模式运行block。
The second lets you query the blocking status of a file descriptor, and the last lets you turn blocking on and off.  
第二个方法让你查询文件描述符的阻塞状态，最后一个让你开启或关闭阻塞。

You’ll probably want to investigate IO.select, as you’ll need it to tell when the file cn be read or written.
你可能想要调查IO.select，当你需要它分辨该文件何时可被读取或写入。
<kinder:note> 这个cn，是can的笔误吧。

## Library IO/Wait   等待读取

Check for Pending Data to Be Read
检查是否有未读取的数据

Including the library io/wait adds the methods IO#nread, IO#ready?, and IO#wait to the standard IO class.  
包含io/wait，会在标准IO类中添加IO#nread，IO#ready?，IO#wait方法。
These allow an IO object opened on a stream (not a file) to be queried to see whether data is available to be read without reading it and to wait for a given number of bytes to become available.
这让我们可以查询一个打开了流（非文件）的IO对象，是否有数据可以被读取，而无需实际读取它；并可等待直至可读取的数据到达一定数量的字节。

Only if: FIONREAD feature in ioctl(2)
仅在ioctl(2)支持FIONREAD特性时可用。

• Sets up a pipe between two processes and writes 10 bytes at a time into it.  
  在两个进程间建立一个管道，并且每次向其中写入10个字节。
  Periodically sees how much data is available.
  周期性地查看有多少数据可以读取。

    require 'io/wait'
    reader, writer = IO.pipe
    if (pid = fork)
      writer.close
      8.times do
        sleep 0.03
        if reader.ready?
          len = reader.nread
          puts "#{len} bytes available: #{reader.sysread(len)}"
        else
          puts "No data available"
        end
      end
      Process.waitpid(pid)
    else
      reader.close
      5.times do |n|
        sleep 0.04
        writer.write n.to_s * 10
      end
      writer.close
    end
    # produces:
    # No data available
    # 10 bytes available:  0000000000
    # 10 bytes available:  1111111111
    # 10 bytes available:  2222222222
    # No data available    
    # 10 bytes available:  3333333333
    # 10 bytes available:  4444444444
    # No data available

## Library IPAddr  IP地址  

Represent and Manipulate IP Addresses
表示和操作IP地址

Class IPAddr holds and manipulates Internet Protocol (IP) addresses.  
IPAddr类可以保存并操作IP地址。
Each address contains three parts: an address, a mask, and an address family.  
每个地址包括三部分：地址、掩码和地址族类。
The family will typically be `AF_INET` for IPv4 and IPv6 addresses.  
族类通常是`AF_INET`，表示为IPv4和IPv6的地址。
The class contains methods for extracting parts of an address, checking for IPv4-compatible addresses (and IPv4-mapped IPv6 addresses), testing whether an address falls within a subnet, and performing many other functions.  
这个类的方法包括，提取地址组成部分、检查IPv4的兼容地址（和IPv4映射到IPv6的地址），测试地址是否位于某个子网，以及许多其他的功能。
It is also interesting in that it contains as data its own unit tests.
另外有趣的是，它还包括自己的单元测试数据。

    require 'ipaddr'
    v4 = IPAddr.new('192.168.23.0/24')
    v4 # => #<IPAddr: IPv4:192.168.23.0/ 255.255.255.0>
    v4.mask(16) # => #<IPAddr: IPv4:192.168.0.0/ 255.255.0.0>
    v4.reverse # => "0.23.168.192.in-addr.arpa"
    v6 = IPAddr.new('3ffe:505:2::1')
    v6 # => #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0001/
       # .. ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>
    v6.mask(48) # => #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/
                # .. ffff:ffff:ffff:0000:0000:0000:0000:0000>
                # the value for 'family' is OS dependent. This
                # value is for OS X
    v6.family # => 30
    other = IPAddr.new("192.168.23.56")
    v4.include?(other) # => true

## Library irb  交互ruby  1.9

Interactive Ruby
交互ruby。

The irb library is most commonly associated with the console command irb.  
irb库是最常和控制台命令irb联系在一起的。
However, you can also start an irb session from within your running application.  
不过，你也可以从你运行中的应用中开始一个irb会话。
A common technique is to trap a signal and start irb in the handler.
一个通用的技巧是跟踪一个信号，并在handler开始irb。

The following program sets up a signal handler that runs irb when the user hits ^C.  
下面的程序在用户键入^C的时候建立一个信号handler。
The user can change the value of the instance variable @value.  
用户可以改变实例变量@value的值。
When they exit from irb, the original program continues to run with that new value.
它们从irb退出时，原始程序带着那个新值继续运行。

    # sl_irb/run_irb.rb
    require 'irb'
    trap "INT" do
      IRB.start
    end
    count = 0
    loop do
      count += 1
      puts count
      puts "Value = #{@value}" if defined? @value
      sleep 1
    end


Here’s a simple session using it:
这是它运行后的一个简单会话。

    $ ruby code/sl_irb/run_irb.rb
    1
    2
    3
    ^Cruby-1.9.2-p0 > @value = "wibble"
    => "wibble"
    ruby-1.9.2-p0 > exit
    4
    Value = wibble
    5
    Value = wibble
    . . .


## Library json  js对象标记

Generate and Parse JSON Format
产生并解析JSON格式

JSON is a language-independent data interchange format based on key/value pairs (hashes in Ruby) and sequences of values (arrays in Ruby)[3].  
JSON是一个语言无关的数据交换格式，基于键值（ruby里的散列表）对和值序列（ruby里的数组）。
[3].  http://www.ietf.org/rfc/rfc4627.txt
JSON is frequently used to exchange data between JavaScript running in browsers and server-based applications.  
JSON经常用于在运行在浏览器的JavaScript和基于服务器的应用程序之间交换数据。
JSON is not a general-purpose object marshaling format.  
JSON不是一个通用目的对象列集格式。
Although you can add to_json methods to your own classes, you will lose interoperability.
虽然你可以增加`to_json`方法到你自己的类中，但你会失去互用性 。
See also: yaml (page 827)
另见yaml（后面827页）

• Serializes a data structure into a string and writes that to a file:
  将一个数据构造序列化为一个字符串，并写入一个文件中。

    require 'json'
    data = { name: 'dave', address: [ 'tx', 'usa' ], age: 17 }
    serialized = data.to_json
    serialized # => {"name":"dave","address":["tx","usa"],"age":17}
    File.open("data", "w") {|f| f.puts serialized}

• Reads the serialized data from the file and reconstitutes it:
  从文件中读取序列化数据，并重建：

    require 'json'
    serialized = File.read("data")
    data = JSON.parse(serialized)
    data # => {"name"=>"dave", "address"=>["tx", "usa"], "age"=>17}

• The methods j and jj convert their argument to JSON and write the result to STDOUT (jj prettyprints).  
  方法f和方法jj将它们的参数转为JSON，并将结果写道STDOUT（jj prettyprints）。
  This can be useful in irb.
  这在irb中很有用。

    require 'json'
    data = { name: 'dave', address: [ 'tx', 'usa' ], age: 17 }
    puts "Regular"
    j data
    puts "Pretty"
    jj data
    # produces:
    # Regular
    # {"name":"dave","address":["tx","usa"],"age":17}
    # Pretty
    # {
    #   "name": "dave",
    #   "address": [
    #     "tx",
    #     "usa"
    #   ],
    #   "age": 17
    # }

## Library Logger  日志

Application Logging
应用日志

Writes log messages to a file or stream.  
将日志信息写入到一个文件或流中。
Supports automatic time- or size-based rolling of log files.  
支持自动的基于时间或大小的转储日志文件。
Messages can be assigned severities, and only those messages at or above the logger’s current reporting level will be logged.
信息可被进行严重性赋值，只有那些严重性超过logger的当前报告级别的消息，才会被记录。

• During development, you may want to see all messages:
  开发期间，你可能想看看所有信息：

    require 'logger'
    log = Logger.new(STDOUT)
    log.level = Logger::DEBUG
    log.datetime_format = "%H:%M:%S"
    log.info("Application starting")
    3.times do |i|
      log.debug("Executing loop, i = #{i}")
      temperature = some_calculation(i) # defined externally
      if temperature > 50
        log.warn("Possible overheat. i = #{i}")
      end
    end
    log.info("Application terminating")
    # produces:
    # I, [12:33:23#24712] INFO -- : Application starting
    # D, [12:33:23#24712] DEBUG -- : Executing loop, i = 0
    # D, [12:33:23#24712] DEBUG -- : Executing loop, i = 1
    # D, [12:33:23#24712] DEBUG -- : Executing loop, i = 2
    # W, [12:33:23#24712] WARN -- : Possible overheat. i = 2
    # I, [12:33:23#24712] INFO -- : Application terminating

• In deployment, you can turn off anything below INFO:
  在配置里，你可以关闭小于INFO的消息。

    require 'logger'
    log = Logger.new(STDOUT)
    log.level = Logger::INFO
    log.datetime_format = "%H:%M:%S" # as above...
    # produces:
    # I, [12:33:23#24714] INFO -- : Application starting
    # W, [12:33:23#24714] WARN -- : Possible overheat. i = 2
    # I, [12:33:23#24714] INFO -- : Application terminating

• Logs to a file, which is rotated when it gets to about 10KB.  
  记录到一个文件，当它大约10KB时会进行轮换。
  Keeps up to five old files.
  保留五个旧文件。

    require 'logger'
    log = Logger.new("application.log", 5, 10*1024)
    log.info("Application starting") # ...

## Library mathn   数字系统

Unified Numbers
统一的数字

The mathn library attempts to bring some unity to numbers under Ruby, making classes Bignum, Complex, Fixnum, Integer, and Rational work and play better together.  
mathn库尝试为ruby提供统一的数字系统，让Bignum、Complex、Fixnum、Integer和Rational类能更好地在一起动作。
It automatically includes the libraries complex, rational, matrix, and prime.
他会自动包含复数、有理数、矩阵和素数库。

• Types will tend to convert between themselves in a more natural way (so, for example, Complex::I squared will evaluate to -1, rather than Complex[-1,0]).
  类型将以一种更自然的方式相互进行转换（例如，Complex::I的平方值为-1，而不是Complex[-1, 0]。
• Division will tend to produce more accurate results.  
  除操作将产生更精确的结果。
  The conventional division operator (/) is redefined to use quo, which doesn’t round.
  传统的除操作（/）被重定义为使用quo，不会舍去。
• Related to the previous point, rational numbers will be used in preference to floats when 1 possible.  
  和前面一点有关，尽可能优先使用有理数，而不是浮点数。
Dividing one by two results in the rational number ⁄2, rather than 0.5 (or 0, the result of normal integer division).
用1除以2得到有理数1/2，而不是0.5（或者0,一般整数除法的结果）。

See also: Matrix (page 769) Rational (page 794) Complex (page 738) Prime (page 790)
另见Matrix (后面769页) Rational (后面794页) Complex (前面 738) Prime (后面 790)

• Without mathn:
  不使用mathn的情况：

    require 'matrix'
    36/16               # => 2
    Math.sqrt(36/16)    # => 1.4142135623730951
    Complex::I * Complex::I # => (-1+0i)
    (36/16)**-2      # => 1/4
    (-36/16)**-2     # => 1/9
    (36/16)**(1/2)    # => 1
    (-36/16)**(1/2)   # => 1
    (36/16)**(-1/2)     # => 1/2
    (-36/16)**(-1/2)    # => -1/3
    Matrix.diagonal(6,7,8)/3 # => Matrix[[2, 0, 0], [0, 2, 0], [0, 0, 2]]

• With mathn:
  使用mathn：

    36/16              # => 9/4
    Math.sqrt(36/16)   # => 3/2
    Complex::I * Complex::I # => -1
    (36/16)**-2    # => 16/81
    (-36/16)**-2   # => 16/81
    (36/16)**(1/2)  # => 3/2
    (-36/16)**(1/2) # => (9.184850993605148e-17+1.5i)
    (36/16)**(-1/2)  # => 2/3
    (-36/16)**(-1/2) # => (4.082155997157844e-17-0.6666666666666666i)
    Matrix.diagonal(6,7,8)/3 # => Matrix[[2, 0, 0], [0, 7/3, 0], [0, 0, 8/3]]

<kinder:note> 这一段代码在2版中需要下面语句。complex库已经并入标准库，因此不用包含，是可以理解的。但mathn库和matrix库呢：

    require 'mathn'
    require 'matrix'
    require 'complex'

## Library Matrix   矩阵

Matrix and Vector Manipulation
矩阵和矢量操作

The matrix library defines classes Matrix and Vector, representing rectangular matrices and vectors.  
matrix库定义了类Matrix和Vector，分别代表矩阵和矢量。
As well as the normal arithmetic operations, they provide methods for matrix-specific functions (such as rank, inverse, and determinants) and a number of constructor methods (for creating special-case matrices—zero, identity, diagonal, singular, and vector).
和普通的算术操作一样，它们提供了特定于矩阵的函数（例如秩、逆矩阵和行列式）和许多构造方法（创建特例的矩阵--零阶、单位阵、对等阵、奇异阵和向量）

As of Ruby 1.9, matrices use quo internally for division, so rational numbers may be returned as a result of integer division.  
到了ruby 1.9, matrix内部使用quo进行除法，因此有理数可被返回作为整数除法的结果。
In prior versions of Ruby, you’d need to include the mathn library to achieve this.
而之前的ruby版本，你需要包含mathn库来达到这个效果。
<kinder:note>本书2版指出：因为默认的整数算术会截断，整数矩阵的行列式可能被错误地计算，除非你加载mathn库。

    require 'matrix'
    m1 = Matrix[ [2, 1], [-1, 1] ]
    m1[0,1] # => 1
    m1.inv # => Matrix[[1/3, -1/3], [1/3, 2/3]]
    m1 * m1.inv # => Matrix[[1/1, 0/1], [0/1, 1/1]]
    m1.determinant # => 3
    m1.singular?  # => false
    v1 = Vector[3, 4] # => Vector[3, 4]
    v1.covector # => Matrix[[3, 4]]
    m1 * v1 # => Vector[10, 1]
    
    m2 = Matrix[ [1,2,3], [4,5,6], [7,8,9] ]
    m2.minor(1, 2, 1, 2) # => Matrix[[5, 6], [8, 9]]

## Library MiniTest   最小测试  1.9

Unit Testing Framework
单元测试框架

New in Ruby 1.9, MiniTest is now the standard unit testing framework supplied with Ruby.
ruby 1.9出现的，MiniTest现在是ruby的标准单元测试框架。
The minitest library contains classes for unit tests, mock objects, and a (trivial) subset of RSpec-style testing syntax.
minitest库包含很多类，适用于单元测试、mock对象和RSpec风格的测试语法的子集。
The unit testing framework is similar to the original Test::Unit framework.  
该单元测试框架类似于原来的Test::Unit框架。
However, if you want functionality that is the same as Test::Unit, use the Test::Unit wrappers for MiniTest— simply require "test/unit" as normal.
不过，如果你需要和Test::Unit一样的功能，可使用MiniTest的Test::Unit包装器--只需要像正常那样包含test/unit。
Chapter 13, Unit Testing, on page 175 contains a tutorial on unit testing with Ruby.
前面175页的13章，单元测试包含了一个单元测试的指南。

## Library Monitor  同步监视器

Monitor-Based Synchronization
基于监视器的同步

Monitors are a mutual-exclusion mechanism.  
Monitor是一种互斥机制的形式。
They allow separate threads to define shared resources that will be accessed exclusively, and they provide a mechanism for a thread to wait for resources to become available in a controlled way.
它们可以让不同的线程定义互斥访问的共享资源，并提供一种可控的机制让某个线程等待获得资源。

The monitor library actually defines three separate ways of using monitors: by subclassing, as a mixin, and as a extension to a particular object.  
monitor库实际上定义了三种使用方式：作为父类、作为minin以及作为某个特定对象的扩展。
In this section, we show the mixin form of Monitor.  
在本节，我们展示Monitor的Mixin形式。
The subclassing form is effectively identical.  
子类形式实际上是一样的。
In both it and when including MonitorMixin in an existing class, it is essential to invoke super in the class’s initialize method.
类的形式和混入的形式，本质上都是在类的initialize方法中调用super。

See also: Thread (page 702)
另见线程（见前面702页）

    # This example would be better written using fibers.
    # 这个例子使用纤程来写会更好。
    require 'monitor'
    require 'mathn'
    numbers = []
    numbers.extend(MonitorMixin)
    number_added = numbers.new_cond
    consumer = Thread.new do
      # Reporter thread
      # 报告线程
      5.times do
        numbers.synchronize do
          number_added.wait_while { numbers.empty? }
          puts numbers.shift
        end
      end
    end
    generator = Thread.new do
      primes = Prime.each
      5.times do
        numbers.synchronize do
          numbers << primes.next
          number_added.signal
        end
      end
    end
    
    # Prime number generator thread
    # 主要数字产生器的线程
    generator.join
    consumer.join
    # produces:
    # 2
    # 3
    # 5
    # 7
    # 11

## Library Mutex_m   互斥混入

Mutex Mix-In
互斥混入

`mutex_m` is a variant of class Mutex on page 588 that allows mutex facilities to be mixed into any object.
`mutex_m`是一个前面588页Mutex类的变量，允许互斥便利地混入任何对象。
The `Mutex_m` module defines methods that correspond to those in Mutex but with the prefix `mu_` (so that lock is defined as `mu_lock` and so on).  
`Mutex_m`模块定义一些对应Mutex的方法，但用`mu_`前缀（所以lock方法被定义为`mu_lock`，其他也类似）。
These are then aliased to the original Mutex names.
这是原始Mutex名称的别名。
See also: Mutex (page 588) Thread (page 702)
另见Mutex（前面588页）Thread（前面702页）

    require 'mutex_m'
    class Counter
      include Mutex_m
      attr_reader :count
      def initialize
        @count = 0
        super
      end
      def tick
        lock
        @count += 1
        unlock
      end
    end
    c = Counter.new
    t1 = Thread.new { 100_000.times { c.tick } }
    t2 = Thread.new { 100_000.times { c.tick } }
    t1.join
    t2.join
    c.count # => 200000

## Library Net::FTP   FTP客户端

FTP Client
FTP客户端

The net/ftp library implements a File Transfer Protocol (FTP) client.  
net/ftp库实现了一个文件传输协议客户端。
As well as data transfer commands (getbinaryfile, gettextfile, list, putbinaryfile, and puttextfile), the library supports the full complement of server commands (acct, chdir, delete, mdtm, mkdir, nlst, rename, rmdir, pwd, size, status, and system).  
除了数据传输命令（getbinaryfile, gettextfile, list, putbinaryfile, 和puttextfile）外，该库还支持完整的服务器命令（acct, chdir, delete, mdtm, mkdir, nlst, rename, rmdir, pwd, size, status, 和system）。
Anonymous and password-authenticated sessions are supported.
支持匿名和基于密码认证的会话。
Connections may be active or passive.
连接可以是主动或被动的。  
See also: open-uri (page 781)
另见open-uri（后面781页）。

    require 'net/ftp'
    ftp = Net::FTP.new('ftp.ruby-lang.org')
    ftp.login
    ftp.chdir('pub/ruby/doc')
    puts ftp.list('*txt')
    ftp.getbinaryfile('MD5SUM.txt', 'md5sum.txt', 1024)
    ftp.close
    puts File.read('md5sum.txt')
    # produces:
    # -rw-rw-r-1 1027 100  12149 Sep 10 06:02 MD5SUM.txt
    # -rw-rw-r-1 1027 100  13565 Sep 10 06:03 SHA1SUM.txt
    # d529768c828c930c49b3766d13dc1f2c  ruby-man-1.4.6-jp.tar.gz
    # 8eed63fec14a719df26247fb8384db5e  ruby-man-1.4.6.tar.gz
    # 623b5d889c1f15b8a50fe0b3b8ba4b0f  ruby-man-ja-1.6.6-20011225-rd.tar.gz
    # 5f37ef2d67ab1932881cd713989af6bf  ruby-man-ja-html-20050214.tar.bz2
    # e9949b2023a63b6259b02bed4fb13064  ruby-man-ja-html-20050214.tar.gz
    # . . .

## Library Net::HTTP   HTTP客户端

HTTP Client
HTTP客户端

The net/http library provides a simple client to fetch headers and web page contents using the HTTP and HTTPS protocols.
net/http库提供了一个简单的客户端，使用HTTP协议取得一个HTTP头信息和Web页面的内容。
The get post and head methods return a response object, with the content of the response accessible through the response’s body method.
接口get post和head方法返回一个response对象，它的内容可以通过response的body方法来得到。
See also: OpenSSL (page 783) open-uri (page 781) URI (page 822)
另见OpenSSL（后面783页）open-uri（后面781页）URI（后面822页）。

• Opens a connection and fetches a page, displaying the response code and message, header information, and some of the body:
  打开一个连接，并取得一个页面，显示响应的代码和消息，头信息，以及部分主题。

    require 'net/http'
    Net::HTTP.start('www.pragprog.com') do |http|
    response = http.get('/categories/new')
    puts "Code = #{response.code}"
    puts "Message = #{response.message}"
    response.each {|key, val| printf "%-14s = %-40.40s\n", key, val }
    p response.body[0, 55]
    end
    # produces:
    # Code = 302
    # Message = Found
    # content-type = text/html; charset=utf-8
    # date = Mon, 27 May 2013 17:36:21 GMT
    # location = http://pragprog.com/categories/new
    # server = nginx/1.2.6
    # status = 302 Found
    # x-request-id = 1c76c5446f0a1dd001ceb768f2611364
    # x-runtime = 0.004833
    # x-ua-compatible = IE=Edge,chrome=1
    # content-length = 100
    # connection = keep-alive
    # "<html><body>You are being <a href=\"http://pragprog.com/"

• Fetches a single page, displaying the response code and message, header information, and some of the body:
  取得一个单页，显示响应代码和消息，头消息和部分主体。

    require 'net/http'
    response = Net::HTTP.get_response('www.pragprog.com',
    '/categories/new')
    puts "Code = #{response.code}"
    puts "Message = #{response.message}"
    response.each {|key, val| printf "%-14s = %-40.40s\n", key, val }
    p response.body[0, 55]
    # produces:
    # Code = 302
    # Message = Found
    # content-type = text/html; charset=utf-8
    # date = Mon, 27 May 2013 17:36:21 GMT
    # location = http://pragprog.com/categories/new
    # server = nginx/1.2.6
    # status = 302 Found
    # x-request-id = ab9de753032bb022cbd33fefbe030f56
    # x-runtime = 0.005468
    # x-ua-compatible = IE=Edge,chrome=1
    # content-length = 100
    # connection = keep-alive
    # "<html><body>You are being <a href=\"http://pragprog.com/"


• Follows redirections (the open-uri library does this automatically).  
  追踪重定向（open-uri库会自动完成这一点）。
  This code comes from the RDoc documentation.
  代码取自RDoc文档。

    require 'net/http'
    require 'uri'
    def fetch(uri_str, limit=10)
      fail 'http redirect too deep' if limit.zero?
      puts "Trying: #{uri_str}"
      response = Net::HTTP.get_response(URI.parse(uri_str))
      case response
      when Net::HTTPSuccess then response
      when Net::HTTPRedirection then fetch(response['location'], limit-1)
      else response.error!
      end
    end
    response = fetch('http://www.ruby-lang.org')
    p response.body[0, 50]
    # produces:
    # Trying: http://www.ruby-lang.org
    # "<html>\n <head>\n
    # <script type=\"text/javascript\""


• Searches our site for things about Ruby and lists the authors.  
  在我们的网站搜索关于ruby和作者列表等事情。
  (This would be tidier using Hpricot.)
  使用Hpricot会更简洁。

    require 'net/http'
    uri = URI.parse('http://pragprog.com/search')
    response = Net::HTTP.post_form(uri, "q" => "ruby")
    puts response.body.scan(%r{<p class="by-line">by (.*?)</p>})[0,3]
    # produces:
    # Caleb Tennis
    # Maik Schmidt
    # Bruce Tate

## Library Net::IMAP   电邮访问协议

Access an IMAP Mail Server
访问IMAP邮件服务器

The Internet Mail Access Protocol (IMAP) is used to allow mail clients to access mail servers.
因特网邮件访问协议可以让邮件客户端来访问邮件服务器。
It supports plain-text login and the IMAP login and CRAM-MD5 authentication mechanisms.
它支持明文登录、IMAP登录和CRAM-MD5验证机制。
Once connected, the library supports threading, so multiple interactions with the server may take place at the same time.
一旦连接完成，这个库支持多线程，因此在同一时间可以和服务器进行多个交互。

The examples that follow are taken with minor modifications from the RDoc documentation in the library source file.
下面的实例曲子库源文件的RDoc文件，并稍加修改。
The TMail gem provides an interface for creating and parsing email messages.
TMail包提示了一个创建和解析邮件信息的接口。
See also: Net::POP (page 776)
另见Net::POP（前面776页）

• Lists senders and subjects of messages to “dave” in the inbox:
  列出收件箱中发送给dave的邮件的发送者和主题。

    require 'net/imap'
    imap = Net::IMAP.new('my.mailserver.com')
    imap.authenticate('LOGIN', 'dave', 'secret')
    imap.examine('INBOX')
    puts "Message count: #{ imap.responses["EXISTS"]}"
    imap.search(["TO", "dave"]).each do |message_id|
      envelope = imap.fetch(message_id, "ENVELOPE")[0].attr["ENVELOPE"]
      puts "#{envelope.from[0].name}: \t#{envelope.subject}"
    end

• Moves all email messages with a date in April 2008 from the folder Mail/sent-mail to Mail/sent-apr08:
  将Mail/sentmail文件夹中在2008年4月的所有消息转移到Mial/sent-apr08。

    require 'net/imap'
    imap = Net::IMAP.new('my.mailserver.com')
    imap.authenticate('LOGIN', 'dave', 'secret')
    imap.select('Mail/sent-mail')
    if not imap.list('Mail/', 'sent-apr08')
      imap.create('Mail/sent-apr08')
    end
    imap.search(["BEFORE", "01-May-2008",
    "SINCE", "1-Apr-2008"]).each do |message_id|
      imap.copy(message_id, "Mail/sent-apr08")
      imap.store(message_id, "+FLAGS", [:Deleted])
    end
    imap.expunge

## Library Net::POP  邮箱协议

Access a POP Mail Server
访问POP邮件服务器

The net/pop library provides a simple client to fetch and delete mail on a Post Office Protocol (POP) server.
net/pop库提供了一个简单的客户端，从POP服务器上取回或删除邮件。
The class Net::POP3 is used to access a POP server, returning a list of Net::POPMail objects, one per message stored on the server.  
Net::POP3类被用来访问一个POP服务器，返回Net::POPMail对象的一个列表，对应保存在服务器上的每个消息。
These POPMail objects are then used to fetch and/or delete individual messages.
然后可以使用这些POPMail对象来读取或删除每个消息。
The library also provides class APOP, an alternative to the POP3 class that performs encrypted authentication.
这个库还提供了APOP类，一个POP3的替代类，它可以执行验证。
require 'net/pop'
pop = Net::POP3.new('server.ruby-stuff.com')
pop.start('joe', 'secret') do |server|
  msg = server.mails[0]
  # Print the 'From:' header line
  # 打印‘From’头行。
  from = msg.header.split("\r\n").grep(/^From: /)[0]
  puts from
  puts
  puts "Full message:"
  text = msg.pop
  puts text
end
# produces:
# From: dave@facet.ruby-stuff.com (Dave Thomas)
# Full message:
# Return-Path: <dave@facet.ruby-stuff.com>
# Received: from facet.ruby-stuff.com (facet.ruby-stuff.com [10.96.0.122])
#           by pragprog.com (8.11.6/8.11.6) with ESMTP id i2PJMW701809
#           for <joe@carat.ruby-stuff.com>; Thu, 25 Mar 2008 13:22:32 -0600
# Received: by facet.ruby-stuff.com (Postfix, from userid 502)
#           id 4AF228B1BD; Thu, 25 Mar 2008 13:22:36 -0600 (CST)
# To: joe@carat.ruby-stuff.com
# Subject: Try out the new features!
# Message-Id: <20080325192236.4AF228B1BD@facet.ruby-stuff.com>
# Date: Thu, 25 Mar 2008 13:22:36 -0600 (CST)
# From: dave@facet.ruby-stuff.com (Dave Thomas)
# Status: RO
# 
# Ruby 1.9 has even more new features, both in
# the core language and in the supplied libraries.
# Try it out!

## Library Net::SMTP   简单邮件传输协议

Simple SMTP Client
简单的SMTP客户端

The net/smtp library provides a simple client to send electronic mail using the Simple Mail Transfer Protocol (SMTP).  
net/smtp库提供了一个简单的客户端，使用简单邮件协议来发送电子邮件。
It does not assist in the creation of the message payload—it simply delivers messages once an RFC 822 message has been constructed.  
它并不帮助邮件的创建--只是把一个构造好的RFC822消息发送出去。
The TMail gem provides an interface for creating and parsing email messages.
TMail包提供了一个创建和解析电邮信息的接口。

• Sends an e-mail from a string:
  从一个字符串中发送一个电邮：

    require 'net/smtp'
    msg = "Subject: Test\n\nNow is the time\n"
    Net::SMTP.start('pragprog.com') do |smtp|
      smtp.send_message(msg, 'dave@pragprog.com', ['dave'])
    end

• Sends an e-mail using an SMTP object and an adapter:
  使用一个SMTP对象和一个适配器发送一个电邮：

    require 'net/smtp'
    Net::SMTP::start('pragprog.com', 25, "pragprog.com") do |smtp|
      smtp.open_message_stream('dave@pragprog.com', # from
                                [ 'dave' ]          # to
                              ) do |stream|
        stream.puts "Subject: Test1"
        stream.puts
        stream.puts "And so is this"
      end
    end

• Sends an e-mail to a server requiring CRAM-MD5 authentication:
  向一个包含CRAM-MD5验证的服务器发送电邮。

    require 'net/smtp'
    msg = "Subject: Test\n\nNow is the time\n"
    Net::SMTP.start('pragprog.com', 25, 'pragprog.com',
    'user', 'password', :cram_md5) do |smtp|
      smtp.send_message(msg, 'dave@pragprog.com', ['dave'])
    end

## Library Net::Telnet   远程连接

Telnet Client
Telnet客户端

The net/telnet library provides a complete implementation of a telnet client and includes features that make it a convenient mechanism for interacting with nontelnet services.
net/telnet库为telnet客户端提供了一个完整的实现，并包括其他一些特性，使我们与非telnet服务的交互更方便。

• Connects to localhost, runs the date command, and disconnects:
  连接到localhost，运行date命令，然后断开：

    require 'net/telnet'
    tn = Net::Telnet.new({})
    tn.login "testuser", "wibble"
    tn.cmd "date" # => "date\nMon May 27 12:33:29 CDT 2013\nlight-boy:~ testuser$ "

• The methods new, cmd, login, and waitfor take an optional block.  
  new, cmd, login, waitfor方法可以接受一个可选的block。
  If present, the block is passed output from the server as it is received by the routine.  
  如果存在，通过这些调用从服务器得到的输出会传入到block。
  This can be used to provide real-time output, rather than waiting (for example) for a login to complete before displaying the server’s response.
  这可用于提供实时输出，无需等待（例如）整个登录完成之后才能显示服务器的响应。

    require 'net/telnet'
    tn = Net::Telnet.new({})        {|str| print str }
    tn.login("testuser", "wibble")  {|str| print str }
    tn.cmd("date")                  {|str| print str }
    # produces:
    # Trying localhost...
    # Connected to localhost.
    # Darwin/BSD (light-boy.local) (ttys007)
    # login: testuser
    # Password:
    # Last login: Mon May 27 12:33:29 on ttys007
    # light-boy:~ testuser$ date
    # Mon May 27 12:33:29 CDT 2013
    # light-boy:~ testuser$

• Query a WHOIS server on port 43.
  在端口43查询一个WHOIS服务。

    require 'net/telnet'
    tn = Net::Telnet.new('Host'        => 'whois.domain.com',  
                          'Port'       => '43',
                          'Timeout'    => 5,
                          'Telnetmode' => false)
    tn.write("pragprog.com\r\n")          
    puts tn.sock.grep(/ on /)
    # produces:
    # Record last updated on 15-Oct-2012.
    # Record expires on 19-Jan-2016.
    # Record created on 19-Jan-1999.

## Library NKF  网络Kanji过滤器

Interface to Network Kanji Filter
Kanji网络过滤器接口

The NKF module is a wrapper around Itaru Ichikawa’s Network Kanji Filter (NKF) library (version 1.7).  
NKF模块包装了Itaru Ichikawa的Network Kanji Filter (NKF)库(1.7版)。
It provides functions to guess at the encoding of JIS, EUC, and SJIS streams and to convert from one encoding to another.  
它提供了猜测JIS EUC SJIS流的编码，以及将一种编码转换为另一种编码的函数。
Even though Ruby 1.9 now supports these encodings natively, this library is still useful for guessing encodings.
即使Ruby 1.9现在原生地支持了这些编码，这个库对于猜测编码仍然有用。

• As of Ruby 1.9, NFK uses the built-in encoding objects:
  到了ruby 1.9，NFK使用内建的编码对象：

    require 'nkf'
    NKF::AUTO # =>  nil
    NKF::JIS # =>   #<Encoding:ISO-2022-JP (dummy)>
    NKF::EUC # =>   #<Encoding:EUC-JP>
    NKF::SJIS # =>  #<Encoding:Shift_JIS>

• Guesses at the encoding of a string.  
  猜测一个字符串的编码。
(Thanks to Nobu Nakada for the examples on this page.)
（谢谢Nobu Nakada提供本页的示例。）

    require 'nkf'
    p NKF.guess("Yukihiro Matsumoto")
    p NKF.guess("\e$B$^$D$b$H$f$-$R$m\e(B")
    p NKF.guess("\244\336\244\304\244\342\244\310\244\346\244\255\244\322\244\355")
    p NKF.guess("\202\334\202\302\202\340\202\306\202\344\202\253\202\320\202\353")
    # produces:
    # #<Encoding:US-ASCII>
    # #<Encoding:ISO-2022-JP (dummy)>
    # #<Encoding:EUC-JP>
    # #<Encoding:Shift_JIS>

• The NFK.nkf method takes two parameters.  
  NFK.nkf方法带有两个参数。
The first is a set of options, passed on to the NKF library.  
第一个是一组选项，传递给NKF库。
The second is the string to translate.  
第二个是要翻译的字符串。
The following examples assume that your console is set up to accommodate Japanese characters.  
下面的示例假定你的控制台可以显示日文字符。
The text at the end of the three ruby commands is Yukihiro Matsumoto in Hiragana.
三个ruby命令之后的文本是平假名的Yukihiro Matsumoto。

    $ ruby -e 'p *ARGV' まつもとゅきひろ
    "\244\336\244\304\244\342\244\310\244\346\244\255\244\322\244\355"
    $ ruby -rnkf -e 'p NKF.nkf(*ARGV)' -- -Es まつもとゅきひろ
    "\202\334\202\302\202\340\202\306\202\344\202\253\202\320\202\353"
    $ ruby -rnkf -e 'p NKF.nkf(*ARGV)' -- -Ej まつもとゅきひろ
    "\e$B$^$D$b$H$F$-$R$m\e(B"

## Library Observable  观察者

The Observer Pattern
观察者模式

The Observer pattern, also known as Publish/Subscribe, provides a simple mechanism for one object (the source) to inform a set of interested third-party objects when its state changes (see Design Patterns [GHJV95]).  
Observer模式，也被称为发布/订阅，提供了一种简单的机制，让一个对象（资源）在其状态发生改变时，通知给感兴趣的一组第三方对象（参见《设计模式》[GHJV95]）。
In the Ruby implementation, the notifying class mixes in the module Observable, which provides the methods for managing the associated observer objects.
在ruby实现是，处理通知的类混入Observable模块，该模块提供了管理相关联的观察者对象的方法。
The observers must implement the update method to receive notifications.
观察者对象必须实现update方法来接受通知。

    require 'observer'
    class CheckWaterTemperature 
      # Periodically check the water   周期性地检查水温
      include Observable
      def run
        last_temp = nil
        loop do
          temp = Temperature.fetch
          # external class...
          puts "Current temperature: #{temp}"
          if temp != last_temp
            changed
            # notify observers
            notify_observers(Time.now, temp)
            last_temp = temp
          end
        end
      end
    end
    class Warner    # 警报器
      def initialize(&limit)
        @limit = limit
      end
      def update(time, temp)
        # callback for observer
        if @limit.call(temp)
          puts "--- #{time.to_s}: Temperature outside range: #{temp}"
        end
      end
    end
    checker = CheckWaterTemperature.new
    checker.add_observer(Warner.new {|t| t < 80})
    checker.add_observer(Warner.new {|t| t > 120})
    checker.run
    # produces:
    # Current temperature: 83
    # Current temperature: 75
    # --- 2013-05-27 12:33:30 -0500: Temperature outside range: 75
    # Current temperature: 90
    # Current temperature: 134
    # --- 2013-05-27 12:33:30 -0500: Temperature outside range: 134
    # Current temperature: 134
    # Current temperature: 112
    # Current temperature: 79
    # --- 2013-05-27 12:33:30 -0500: Temperature outside range: 79


## Library open-uri   打开网络地址

Treat FTP and HTTP Resources as Files
将FTP和HTTP资源视为文件

The open-uri library extends Object#open, allowing it to accept URIs for FTP and HTTP as well as local filenames.  
open-uri库扩展了Object#open，可以让它访问FTP或HTTP的URI，像本地的文件名那样。
Once opened, these resources can be treated as if they were local files, accessed using conventional IO methods.  
一旦打开完毕，这些资源可以被看作是本地文件，可以使用传统的IO方法来访问它。
The URI passed to open is either a string containing an HTTP or FTP URL or a URI object (see the URI library on page 822).  
传递给open方法的URI，可以是一个包含HTTP或FTP地址的字符串，或是一个URI对象（见后面2版752页4版822页）。
When opening an HTTP resource, the method automatically handles redirection and proxies.  
当打开一个HTTP资源时，open方法会自动处理重定向和代理。
When using an FTP resource, the method logs in as an anonymous user.
当使用FTP资源时，方法使用匿名用户来登录。

The IO object returned by open in these cases is extended to support methods that return metainformation from the request: `content_type`, charset, `content_encoding`, `last_modified`, status, `base_uri`, meta.
在这种情况下对open返回的IO对象进行了扩展，以支持若干从请求中返回元信息的方法：`content_type`, charset, `content_encoding`, `last_modified`, status, `base_uri`, meta。

See also: URI (page 822)
另见URI（后面822页）。

    require 'open-uri'
    require 'pp'
    open('http://ruby-lang.org') do |f|
      puts "URI: #{f.base_uri}"
      puts "Content-type: #{f.content_type}, charset: #{f.charset}"
      puts "Encoding: #{f.content_encoding}"
      puts "Last modified: #{f.last_modified}"
      puts "Status: #{f.status.inspect}"
      pp f.meta
      puts "----"
      3.times {|i| puts "#{i}: #{f.gets}" }
    end
    # produces:
    # URI: http://www.ruby-lang.org/
    # Content-type: text/html, charset: iso-8859-1
    # Encoding: []
    # Last modified: 2013-05-22 16:31:36 -0500
    # Status: ["200", "OK"]
    # {"date"=>"Mon, 27 May 2013 17:33:23 GMT",
    #  "server"=>"nginx/0.7.67",
    #  "content-type"=>"text/html",
    #  "content-length"=>"748",
    #  "last-modified"=>"Wed, 22 May 2013 21:31:36 GMT",
    #  "accept-ranges"=>"bytes",
    #  "via"=>"1.1 www.ruby-lang.org"}
    # ---
    # 0: <html>
    # 1: <head>
    # 2: <script type="text/javascript">

## Library Open3

Run Subprocess and Connect to All Streams
运行子进程并连接所有的流

Runs a command in a subprocess.  
在子进程中运行一个命令。
Data written to stdin can be read by the subprocess, and data written to standard output and standard error in the subprocess will be available on the stdout and stderr streams.  
写入到stdin的数据可以被子进程读取，子进程中写入到标准输出和标准错误输出的数据，可以从stdout和stderr流中得到。
The subprocess is actually run as a grandchild, and as a result, Process#waitall cannot be used to wait for its termination (hence the sleep in the following example).  
子进程实际上作为一个孙进程在运行，因此无法使用Process#waitall来等待它的终止（因此在下面的示例中使用sleep）。
Note also that you probably cannot assume that the application’s output and error streams will not be buffered, so output may not arrive when you expect it to arrive.
也要注意你可能不能假定应用程序的输出和错误或流不被缓存，所以当你期待时，输出可能没有到达。

    require 'open3'
      def read_from(label, stream)
        while line = stream.gets
        puts "#{label}: #{line}"
      end
    end
    Open3.popen3('bc') do | stdin, stdout, stderr |
      t1 = Thread.new { read_from('STDOUT', stdout) }
      t2 = Thread.new { read_from('STDERR', stderr) }
      stdin.puts "3 * 4"
      stdin.puts "1 / 0"
      stdin.puts "2 ^ 5"
      stdin.close
      t1.join
      t2.join
    end
    # produces:
    # STDOUT: 12
    # STDERR: Runtime error (func=(main), adr=3): Divide by zero
    # STDOUT: 32

## Library OpenSSL 加密套接字协议层

SSL Library
Security Socket Layer， 加密套接字协议层库

Only if: OpenSSL library available
仅在支持OpenSSL库的系统中可用。

The Ruby OpenSSL extension wraps the freely available OpenSSL library. [4]  
Ruby的OpenSSL扩展包包装了可自由获得的OpenSSL函数库。
[4] http://www.openssl.org
It provides the Secure Sockets Layer and Transport Layer Security (SSL and TLS) protocols, allowing for secure communications over networks.  
它提供了安全套接字层和传输层安全协议，支持网络上的安全通信。
The library provides functions for certificate creation and management, message signing, and encryption/decryption.  
这个库提供了函数来进行证书的创建和管理、消息签名以及加密和解密。
It also provides wrappers to simplify access to HTTPS servers, along with secure FTP.  
它还提供封装来简单访问https服务器，以及安全FTP。
The interface to the library is large (roughly 330 methods), but the average Ruby user will probably use only a small subset of the library’s capabilities.
这个库的接口非常庞大（大概有330个方法），但一般的Ruby用户大概只使用库全部功能的一个小子集。

See also: Net::FTP (page 772) Net::HTTP (page 773) Socket (page 807)
另见Net::FTP (前面772页) Net::HTTP (前面773页) Socket (后面807页)

• Accesses a secure website using HTTPS.  
  使用HTTPS访问安全的web站点。
  Note that SSL is used to tunnel to the site, but the requested page also requires standard HTTP basic authorization.
  注意使用SSL作为和站点通信的通道，但是所请求的页面还需要标准的HTTP基础验证。

    require 'net/https'
    USER = "xxx"
    PW = "yyy"
    site = Net::HTTP.new("www.securestuff.com", 443)
    site.use_ssl = true
    response = site.get2("/cgi-bin/cokerecipe.cgi",
                         'Authorization' => 'Basic ' +
                         ["#{USER}:#{PW}"].pack('m').strip)


• Creates a socket that uses SSL.  
  使用SSL创建一个套接字。
  This isn’t a good example of accessing a website.  
  这并非是访问web站点的一个好的示范。
  However, it illustrates how a socket can be encrypted.
  不过，它演示了套接字是如何加密的。

    require 'socket'
    require 'openssl'
    socket = TCPSocket.new("www.secure-stuff.com", 443)
    ssl_context = OpenSSL::SSL::SSLContext.new()
    unless ssl_context.verify_mode
      warn "warning: peer certificate won't be verified this session."
      ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
    end
    sslsocket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
    sslsocket.sync_close = true
    sslsocket.connect
    sslsocket.puts("GET /secret-info.shtml")
    while line = sslsocket.gets
      p line
    end

## Library OptionParser   选项解析器

Option Parsing
选项解析

It has a particularly rich abstraction of the concept of an option.
OptionParser是解析命令行参数的一个灵活和可扩的方式。
OptionParser is a flexible and extensible way to parse command-line arguments. 
它有一个特别丰富的关于选项概念的抽象。

### 选项的特征
• An option can have multiple short names (options preceded by a single hyphen) and multiple long names (options preceded by two hyphens).  
  一个选项可以有多个**短名字**（以单个连字号作前缀的选项）和多个**长名字**（以两个连字号做前缀的选项）。
Thus, an option that displays help may be available as -h, -?, --help, and --about.  
因此，一个显示帮助信息的选项可以是-h, -?, --help, --about。
Users may abbreviate long option names to the shortest nonambiguous prefix.
用户可以将长选项的名字缩写为确保不会混淆的最短前缀。

• An option may be specified as having no argument, an optional argument, or a required argument.  
  一个选项可能被指定为**没有参数**、一个**可选参数**或一个**必要参数**。
Arguments can be validated against patterns or lists of valid values.
参数可被模式或有效值列表所验证。

• Arguments may be returned as objects of any type (not just strings). 
参数可能被作为任何类型的对象返回，不仅仅是字符串。
The argument type system is extensible (we add Date handling in the example).
参数类型系统是可扩展的，我们在例子中增加了日期处理。

• Arguments can have one or more lines of descriptive text, used when generating usage information.
参数可以有一或多行的**描述文本**，生成用法信息时可用。

### 选项的构建
Options are specified using the on and def methods.  
选项使用on和def方法来指定。
These methods take a variable number of arguments that cumulatively build a definition of each option.  
这些方法带有一个不定数量的参数，逐步地构建每个选项的定义。

The arguments accepted by these methods are:
可被这些方法接受的参数有：

#### "-x" "-xARG" "-x=ARG" "-x[OPT]" "-x[=OPT]" "-x PLACE"
Option has short name x.  
选项有一个短名字是x。
First form has no argument, next two have mandatory argument, next two have optional argument, last specifies argument follows option.  
第一种形式没有参数，第二三种形式要一个必要参数，第四五种有可选参数，最后一个指定参数跟随选项。
The short names may also be specified as a range (such as "-[a-c]").
短名字也可以用一个区间来指定，例如“-[a-c]”。

####  "--switch" "--switch=ARG" "--switch=[OPT]" "--switch PLACE"
Option has long name switch.  
选项有一个长名字是switch。
First form has no argument, next has a mandatory argument, the next has an optional argument, and the last specifies the argument follows the switch.
第一种形式没有参数，第二种形式要一个必要参数，第三种有可选参数，最后一个指定参数跟随switch。

####  "--no-switch"
Defines a option whose default value is false.
定义一个默认值为false的选项。

#### "=ARG" "=[OPT]"
Argument for this option is mandatory or optional.  
这个选项的参数是强制或可选的。
For example, the following code says there’s an option known by the aliases -x, -y, and -z that takes a mandatory argument, shown in the usage as N:
比如，下面的代码说有一个选项已知别名为-x，-y和-z，带有一个必需参数，在用法中显示为N：

    opt.on("-x", "-y", "-z", "=N")

#### "description"

Any string that doesn’t start - or = is used as a description for this option in the summary.
任何不以-或=开始的字符串，都用作在摘要中该选项的描述。
Multiple descriptions may be given; they’ll be shown on additional lines.
可以指定多个描述，它们显示在另外的行上。

#### /pattern/

Any argument must match the given pattern.
任何参数必须匹配给定的模式。

#### array

Argument must be one of the values from array.
参数必须是数组中的值。

#### proc or method

Argument type conversion is performed by the given proc or method (rather than using the block associated with the on or def method call).
执行参数类型转换的给定proc或方法（不是使用和on或def方法调用相关的block）。

#### ClassName

Argument must match that defined for ClassName, which may be predefined or added using OptionParser.accept. 
参数必须匹配ClassName的定义，该ClassName可被预制或使用OptionParser.accept添加。

Built-in argument classes are
内建的参数类有：

**Object**
Any string. No conversion. This is the default.
任何字符串。不会转换。默认。
**String** 
Any nonempty string. No conversion.
任何非空字符串。不会转换。
**Integer** 
Ruby/C-like integer with optional sign (0ddd is octal, 0bddd binary, 0xddd hexadecimal). Converts to Integer.
类似Ruby/C整数，带有可选符号（0ddd是八进制，0bddd二进制，0xddd十六进制）。
可转换为整数。
**Float**
Float number format. Converts to Float.
浮点数格式。可转换为浮点。
**Numeric**: Generic numeric format. Converts to Integer for integers, Float for floats.
通用数字格式。整数可转换为Integer，浮点数可转换为Float。
**Array**
Argument must be of list of strings separated by a comma.
参数必须是用逗号分割的字符串列表中的一个。
**OptionParser::DecimalInteger**
Decimal integer. Converted to Integer.
十进制整数。可转换为Integer。
**OptionParser::OctalInteger**
Ruby/C-like octal/hexadecimal/binary integer.
类似Ruby/C的八进制/十六进制/二进制整数。
**OptionParser::DecimalNumeric**
Decimal integer/float number. Integers converted to Integer, floats to Float.
十进制整数/浮点数。整数可转换为Integer，浮点数可转换为Float。
**TrueClass**, **FalseClass**
Boolean switch.
布尔转换。

See also: GetoptLong (page 761)
另见前面GetoptLong（761页）。

    require 'optparse'
    require 'date'
    # Add Dates as a new option type
    # 增加一个日期的选项类型。
    OptionParser.accept(Date, /(\d+)-(\d+)-(\d+)/) do |d, mon, day, year|
      Date.new(year.to_i, mon.to_i, day.to_i)
    end
    opts = OptionParser.new
    opts.on("-x") {|val| puts "-x seen" }
    opts.on("-s", "--size VAL", Integer) {|val| puts "-s #{val}" }
    opts.on("-a", "--at DATE", Date) {|val| puts "-a #{val}" }
    my_argv = [ "--size", "1234", "-x", "-a", "12-25-2008", "fred", "wilma" ]
    rest = opts.parse(*my_argv)
    puts "Remainder = #{rest.join(', ')}"
    puts opts.to_s
    # produces:
    # 这是第一个puts：
    # -s 1234
    # -x seen
    # -a 2008-12-25
    # Remainder = fred, wilma
    # 这是第二个puts：
    # Usage: prog [options]
    #       -x
    #       -s, --size VAL
    #       -a, --at DATE


## Library OpenStruct  开放结构

Open (dynamic) Structure
开放（动态）结构

An open structure is an object whose attributes are created dynamically when first assigned.
开放结构是一个对象，它的属性是在第一次赋值时动态创建的。
In other words, if obj is an instance of an OpenStruct, then the statement obj.abc=1 will create the attribute abc in obj and then assign the value 1 to it.
换言之，如果obj是OpenStruct的一个实例，语句obj.abc=1会在obj中创建属性abc，然后将值1赋值给它。

    require 'ostruct'
    os = OpenStruct.new( "f1" => "one", :f2 => "two" )
    os.f3 = "cat"
    os.f4 = 99
    os.f1 # => "one"
    os.f2 # => "two"
    os.f3 # => "cat"
    os.f4 # => 99

OpenStruct uses `method_missing` to intercept calls.  
OpenStruct使用`method_missing`来截取调用。
This might cause a problem, because calls to a method defined in class Object will not invoke `method_missing`—they’ll simply call the method in Object.  
这可能会引起问题，因为调用一个定义在Object类的方法可能不会调用`method_missing`--它们只会调用Object里的方法。
In practice, this isn’t a problem, because you typically call a setter before calling a getting, and when you do call the setter method, ostruct will defined getter and setter methods, overriding those in Object.  
在实践中，这不是一个问题，因为你一般会在调用一个getting之前调用一个setter，这时你调用setter方法，ostruct将定义getter和setter方法，改写Object里的那些。
Here’s a typical example; because we call ice.freeze= first, the freeze= and freeze methods will be dynamically created in the ostruct, and the getter will work as expected.
下面是一个典型的例子；因为我们首先调用了`ice.freeze=`，`freeze=`和`freeze`方法将会在ostruct里动态地创建，而getter将如预期般运行。

    require 'ostruct'
    ice = OpenStruct.new
    ice.freeze = "yes"
    ice.freeze # => #<OpenStruct freeze="yes">

However, if you don’t first call the setter, the freeze getter will not invoke `method_missing`— it’ll simply call the underlying freeze method in Object.
不过，如果你没有首先调用setter，冻结的getter将不会调用`method_missing`--它只会调用Object里隐藏的freeze方法。

    require 'ostruct'
    ice = OpenStruct.new
    p ice.freeze
    ice.freeze = "yes"
    # produces:
    # #<OpenStruct>
    # prog.rb:5:in `<main>': can't modify frozen OpenStruct (TypeError)

## Library Pathname   路径

Representation of File Paths
表示文件路径

A Pathname represents the absolute or relative name of a file.  
Pathname表示一个文件的绝对或相对路径。
It has two distinct uses.  
它有两个不同的用途。
First, it allows manipulation of the parts of a file path (extracting components, building new paths, and so on).  
首先，它允许操作文件路径的某些部分（提取组成部分、建立新的路径等）。
Second (and somewhat confusingly), it acts as a façade for some methods in classes Dir, File, and module FileTest, forwarding on calls for the file named by the Pathname object.
其次（并且让人有些迷惑），它是Dir、File类和FileTest模块中某些方法的一个门面，将将“被Pathname对象命名的文件”的调用转发给它。

See also: File (page 488)
另见File（前面2版465页4版488页）

• Path name manipulation:
  路径名操作：

    require 'pathname'
    p1 = Pathname.new("/usr/bin")
    p2 = Pathname.new("ruby")
    p3 = p1 + p2
    p4 = p2 + p1
    p3.parent # => #<Pathname:/usr/bin>
    p3.parent.parent # => #<Pathname:/usr>
    p1.absolute?  # => true
    p2.absolute?  # => false
    p3.split # => [#<Pathname:/usr/bin>, #<Pathname:ruby>]
    
    p5 = Pathname.new("testdir")
    puts p5.realpath
    puts p5.children
    # produces:
    # /Users/dave/BS2/published/ruby4/Book/testdir
    # testdir/.svn
    # testdir/config.h
    # testdir/main.rb


• Path name as proxy for file and directory status requests:
  Pathname作为文件和目录状态请求的代理：

    require 'pathname'
    p1 = Pathname.new("/usr/bin/ruby")
    p1.file?       # => true
    p1.directory?  # => false
    p1.executable? # => true
    p1.size        # => 34752
    p2 = Pathname.new("testfile") # => #<Pathname:testfile> 
    p2.read       # => "This is line one\nThis is line two\nThis is
                  # .. line three\nAnd so on...\n"
    p2.readlines  # => ["This is line one\n", "This is line two\n",
                  # .. "This is line three\n", "And so on...\n"]

## Library PP  完美打印

Pretty-print Objects
完美打印对象

PP uses the PrettyPrint library to format the results of inspecting Ruby objects.  
PP使用PrettyPrint库来格式化Ruby对象的检视结果。
As well as the methods in the class, it defines a global function, pp, which works like the existing p method but formats its output.
除了一些类方法，它还定义了一个全局方法pp，该方法和现有的p方法类似，但对输出进行了格式化。
PP has a default layout for all Ruby objects.  
PP对所有ruby对象有一个默认的布局。
However, you can override the way it handles a class by defining the method `pretty_print`, which takes a PP object as a parameter.  
不过，你可以通过定义`pretty_print`方法（以一个PP对象作为参数）来改写它对类的处理方式。
It should use that PP object’s methods text, breakable, nest, group, and pp to format its output (see PrettyPrint for details).
它应该使用PP对象的方法text, breakable, nest, group, pp来格式化它的输出（详见PrettyPrint）。
See also: JSON (page 766) PrettyPrint (page 789) YAML (page 827)
另见JSON（前面4版766页）PrettyPrint（后面2版716页4版766页）YAML（后面2版758页4版827页）。

• Compares “p” and “pp”:
  比较p和pp：

    require 'pp'
    Customer = Struct.new(:name, :sex, :dob, :country)
    cust = Customer.new("Walter Wall", "Male", "12/25/1960", "Niue")
    puts "Regular print"
    #  Regular print
    p cust
    # #<struct Customer name="Walter Wall", sex="Male", dob="12/25/1960",
    #  country="Niue">
    puts "\nPretty print"
    # Pretty print
    pp cust
    # #<struct Customer
    #  name="Walter Wall",
    #  sex="Male",
    #  dob="12/25/1960",
    #  country="Niue">


• You can tell PP not to display an object if it has already displayed it:
  你可以告诉PP不要显示已经显示的对象。

    require 'pp'
    a = "string"
    b = [ a ]
    c = [ b, b ]
    PP.sharing_detection = false
    pp c          # [["string"], ["string"]]
    PP.sharing_detection = true
    pp c          # [["string"], [...]]

## Library PrettyPrint  完美打印

General Pretty Printer
通用完美打印

PrettyPrint implements a pretty printer for structured text.  
PrettyPrint为结构化文本实现了一个完美的打印程序。
It handles details of wrapping, grouping, and indentation.  
它处理换行、分组和缩进的细节。
The PP library uses PrettyPrint to generate more legible dumps of Ruby objects.
PP库使用PrettyPrint来产生更可读的ruby对象的内部信息输出。
See also: PP (page 788)
另见PP（前一页）

The following program prints a chart of Ruby’s classes, showing subclasses as a bracketed list following the parent.  
下面的程序打印Ruby类的图标，在父类后显示子类的括号列表。
To save some space, we show just the classes in the Numeric branch of the tree.
为了节约版面，我们只显示继承树中的Numeric分支。

    require 'prettyprint'
    @children = Hash.new { |h,k| h[k] = Array.new }
    ObjectSpace.each_object(Class) do |cls|
      @children[cls.superclass] << cls if cls <= Numeric
    end
    def print_children_of(printer, cls)
      printer.text(cls.name)
      kids = @children[cls].sort_by(&:name)
      unless kids.empty?
        printer.group(0, " [", "]") do
          printer.nest(3) do
            printer.breakable
            kids.each_with_index do |k, i|
              printer.breakable unless i.zero?
              print_children_of(printer, k)
            end
          end
          printer.breakable
        end
      end
    end
    printer = PrettyPrint.new(STDOUT, 30)
    print_children_of(printer, Object)
    printer.flush
    # produces:
    #   Object [
    #     Numeric [
    #       Complex
    #       Float
    #       Integer [
    #         Bignum
    #         Fixnum
    #       ]
    #       Rational
    #     ]
    #   ]

## Library prime  质数  1.9

Prime Numbers
质数

Provides facilities for generating prime numbers, as well as factoring numbers.  
提供便利来产生质数和因数。
Note that the Prime class is a singleton.
注意质数类是一个单例类。
See also: mathn (page 768)
另见mathn（前面768页）

• The prime library extends the number classes to include new functionality and adds a new class Prime:
  质数库扩展了数字类，包含新功能，并增加了一个新类Prime：

    require 'prime'
    # 60 = 2**2 * 3 * 5
    60.prime?  # => false
    60.prime_division # => [[2, 2], [3, 1], [5, 1]]

• You can also use it to generate sequences of primes:
  你也可以使用它来产生一个质数序列：

    require 'prime'
    Prime.each {|p| break if p > 20; print p, " " }
    # produces:
    # 2 3 5 7 11 13 17 19

• Because Prime.each returns an enumerator if no block is present, we can write the previous example more concisely.
  因为如果没有block存在，Prime.each返回一个枚举，我们可以将前例写得更简洁：

    require 'prime'
    puts Prime.each.take_while {|p| p <= 20 }.join(" ")
    # produces:
    # 2 3 5 7 11 13 17 19

## Library Profile  剖析

Profile Execution of a Ruby Program
剖析ruby程序的执行

The profile library is a trivial wrapper around the Profiler module, making it easy to profile the execution of an entire program.  
profile库是Profiler模块的一个普通包装，使之可以很容易对整个程序的执行进行剖析。
Profiling can be enabled from the command line using the -r profile option or from within a source program by requiring the profile module.
剖析可以使用-r profile命令行选项，或者在源文件中加载profile模块来启动。

Unlike Ruby 1.8, Ruby 1.9 does not profile primitive methods such as Fixnum#== and Fixnum#+.
不像ruby 1.8, Ruby 1.9 不会剖析一些简单的方法，比如Fixnum#==和Fixnum#+。
This helps boost Ruby’s performance.
这有助于提高ruby的性能。

See also: Benchmark (page 733) `Profiler__` (page 792)
另见Benchmark（前面2版657页4版733页） `Profiler__`（前面2版718页4版792页）

    require 'profile'
    def ackerman(m, n)
      if m == 0 then n+1
      elsif n == 0 and m > 0 then ackerman(m-1, 1)
      else ackerman(m-1, ackerman(m, n-1))
      end
    end
    ackerman(3, 3)
    # produces:
    # %        cumulative self            self     total 
    # time     seconds    seconds  calls  ms/call  ms/call  name
    # 100.00   0.04       0.04     2432   0.02     0.64     Object#ackerman
    # 0.00     0.04       0.00     1      0.00     0.00     TracePoint#enable
    # 0.00     0.04       0.00     1      0.00     0.00     Module#method_added
    # 0.00     0.04       0.00     1      0.00     0.00     TracePoint#disable
    # 0.00     0.04       0.00     1      0.00     40.00    #toplevel

## Library Profiler__  剖析控制

Control Execution Profiling
控制执行的剖析

The `Profiler__` module can be used to collect a summary of the number of calls to, and the time spent in, methods in a Ruby program.  
`Profiler__`模块可以用来收集一个ruby程序中方法的调用次数、所花时间等总结信息。
The output is sorted by the total time spent in each method.  
输出按照每个方法花费的总时间进行排序。
The profile library is a convenience wrapper that profiles an entire program.
profile库是一个方便的包装，使剖析整个程序更容易。
See also: Benchmark (page 733) profile (page 791)
另见Benchmark（前面2版657页4版733页）profile（前一页）

    require 'profiler'
    # ...Omit definition of connection and fetching methods...
    # 省略连接的定义并取出方法
    def calc_discount(qty, price)  # 根据数量确定价格折扣
      case qty
      when 0..10 then 0.0
      when 11..99 then price * 0.05
      else price * 0.1
      end
    end
    def calc_sales_totals(rows)
      total_qty = total_price = total_disc = 0
      rows.each do |row|
        total_qty += row.qty             # 统计数量
        total_price += row.price         # 统计价格
        total_disc += calc_discount(row.qty, row.price)   # 折扣后，统计总价格
      end
    end
    connect_to_database
    rows = read_sales_data
    Profiler__::start_profile  # 开始剖析
    calc_sales_totals(rows)
    Profiler__::stop_profile   # 停止剖析
    Profiler__::print_profile(STDOUT)
    # produces:
    # %     cumulative self            self     total    
    # time  seconds    seconds  calls  ms/call  ms/call  name
    # 28.57  0.02      0.02     648    0.03     0.03     Range#include?
    # 28.57  0.04      0.02     1      20.00    70.00    Array#each
    # 14.29  0.05      0.01     325    0.03     0.37     Object#calc_sales_totals
    # 14.29  0.06      0.01     324    0.03     0.12     Object#calc_discount
    # 14.29  0.07      0.01     648    0.02     0.05     Range#===
    # 0.00   0.07      0.00     1      0.00     0.00     TracePoint#enable
    # 0.00   0.07      0.00     648    0.00     0.00     Float#<=>
    # 0.00   0.07      0.00     648    0.00     0.00     Fixnum#<=>
    # 0.00   0.07      0.00     648    0.00     0.00     SalesData#price
    # 0.00   0.07      0.00     3      0.00     0.00     Fixnum#+
    # 0.00   0.07      0.00     648    0.00     0.00     SalesData#qty
    # 0.00   0.07      0.00     1      0.00     0.00     TracePoint#disable
    # 0.00   0.07      0.00     1      0.00     70.00    #toplevel

## Library PStore  持久化对象存储

Persistent Object Storage
持久化对象存储

The PStore class provides transactional, file-based, persistent storage of Ruby objects.  
PStore类为Ruby对象提供了事务的、基于文件的持久化存储。
Each PStore can store several object hierarchies.  
每个PStore可以存储多个对象层次。
Each hierarchy has a root, identified by a key (often a string).  
每个层次由一个根、一个键（通常是一个字符串）来标识。
At the start of a PStore transaction, these hierarchies are read from a disk file and made available to the Ruby program.  
在一个PStore事务的开始时，这些对象层次从磁盘文件读出，并可以为Ruby程序所使用。
At the end of the transaction, the hierarchies are written back to the file.  
在事务结束时，对象层次被写回到文件中。
Any changes made to objects in these hierarchies are therefore saved on disk, to be read at the start of the next transaction that uses that file.
这些对象层次中发生的任何改变都会被保存到磁盘上，并在使用该文件的下一次事务开始时读取出来。

In normal use, a PStore object is created and then is used one or more times to control a transaction.  
对一般的使用，创建一个PStore对象，然后一次或多次使用它来控制一个事务。
Within the body of the transaction, any object hierarchies that had previously been saved are made available, and any changes to object hierarchies, and any new hierarchies, are written back to the file at the end.
在事务主体中，以前保存的对象层次如今可以访问了，对对象层次的任改变，以及任何新的对象层次，都在事务结束时写回到文件中。

The following example stores two hierarchies in a PStore.  
下面的示例在一个PStore中保存了两个对象层次。
The first, identified by the key "names", is an array of strings.  
第一个，由键”names“来标识，是一个字符串数组。
The second, identified by "tree", is a simple binary tree.
第二个，由键“tree”标识，是一个简单的二叉树。

    require 'pstore'
    require 'pp'
    class T
      def initialize(val, left=nil, right=nil)
        @val, @left, @right = val, left, right
      end
      def to_a
        [ @val, @left.to_a, @right.to_a ]
      end
    end
    def T(*args)
      T.new(*args)
    end
    store = PStore.new("/tmp/store")
    store.transaction do
      store['names'] = [ 'Douglas', 'Barenberg', 'Meyer' ]
      store['tree'] = T('top',
                        T('A', T('B')),
                        T('C', T('D', nil, T('E'))))
    end
    # now read it back in
    store.transaction do
      puts "Roots: #{store.roots.join(', ')}"
      puts store['names'].join(', ')
      pp store['tree'].to_a
    end
    # produces:
    # Roots: names, tree
    # Douglas, Barenberg, Meyer
    # ["top",
    # ["A", ["B", [], []], []],
    # ["C", ["D", [], ["E", [], []]], []]]

## Library PTY  伪终端

Only if: Unix with pty support
只有带有伪终端支持的Unix才可用

Pseudo-Terminal Interface: Interact with External Processes
伪终端接口：与外部进程交互

Many Unix platforms support a pseudo-terminal—a device pair where one end emulates a process running on a conventional terminal, and the other end can read and write that terminal as if it were a user looking at a screen and typing on a keyboard.
许多Unix平台支持伪终端--一对设备，一端模拟在传统终端运行的进程，另一端可以读取这个终端，好像用户在看着一个屏幕并用键盘输入。

The PTY library provides the method spawn, which starts the given command (by default a shell), connecting it to one end of a pseudo-terminal.  
PYT库提供俩spawn方法，启动一个指定的命令（由默认的shell启动），将它连接到伪终端的一端。
It then returns the reader and writer streams connected to that terminal, allowing your process to interact with the running process.
然后它返回和这个终端连接的读写流，让你的进程可以同运行的程序交互。

Working with pseudo-terminals can be tricky.  
使用伪终端可能很有技巧。
See IO#expect on page 753 for a convenience method that makes life easier.  
更方便的方法，参见前面2版676页4版753页的IO#expect，可以让你处理得更简单些。
You might also want to track down Ara T. Howard’s Session module for an even simpler approach to driving subprocesses. [5]    
你还可以追踪到Ara T. Howard的Session模块，它是一个驱动子进程的更简单的方法。
[5].  Currently found at http://www.codeforpeople.com/lib/ruby/session/

See also: expect (page 753)
另见expect（见前面2版676页4版753页）

This example runs irb in a subshell and asks it to convert the string “cat” to uppercase:
这个例子在子shell中运行irb，并要求它将字符串cat转换为大写。

    require 'pty'
    require 'expect'
    $expect_verbose = true
    PTY.spawn("irb") do |reader, writer, pid|
      reader.expect(/> /)
      writer.puts "'cat'.upcase"
      reader.expect("=> ")
      answer = reader.gets
      puts "Answer = #{answer}"
    end
    # produces:
    # 2.0.0p0 :001 > 'cat'.upcase  
    # => Answer = "CAT"

## Library Rational  有理数

Rational Numbers
有理数

The Rational class is now built in to Ruby.  
Rational类现在内建到ruby里。
The vestigial Rational library simply defines a few aliases for backward compatibility.  
这个退化的有理数库只定义了一些向后兼容的别名。
For the classes Fixnum and Bignum, the following aliases are defined:
对于Fixnum和Bignum类，定义了下面的别名：

Floating-point division
浮点除法
quof is an alias for fdiv.
quof是fdiv的别名。

Rational division
有理数除法
rdiv is an alias for quo.
rdiv是quo的别名。

Exponentiation
求冪
power! and rpower are aliases for `**`.
power! 和 rpower 是`**`的别名。

## Library Readline  读入行

Interface to GNU Readline Library
访问GNU Readline函数库的接口

Only if: GNU readline present
仅当GNU readline存在时才适用。

The Readline module allows programs to prompt for and receive lines of user input.  
Readline模块可以让程序为用户输入提示符，并接受所输入的行。
The module allows lines to be edited during entry, and command history allows previous commands to be recalled and edited.  
模块允许在得到输入行时进行编辑，命令行历史允许会回忆和编辑之前的命令。
The history can be searched, allowing the user to (for example) recall a previous command containing the text ruby.  
历史可以被搜索，例如，可以让用户回忆起之前包括ruby字样的命令。
Command completion allows context-sensitive shortcuts: tokens can be expanded in the command line under control of the invoking application.  
命令的自动补齐允许上下文敏感的快捷方式：输入的单词根据所调用的应用，可以在命令行展开。
In typical GNU fashion, the underlying readline library supports more options than any user could need and emulates both vi and emacs key bindings.
在典型的GNU方式中，底层的readline库支持远超过一般用户需求的更多选项，它还可以模拟 vi和emacs的键绑定。

This meaningless program implements a trivial interpreter that can increment and decrement a value.  
下面这个无意义的程序实现了一个简单的解释器，可以增加和减少一个值。
It uses the Abbrev on page 731 module to expand abbreviated commands when the Tab key is pressed.
它使用Abbrev模块（前面2版655页4版731页），按下tab键时，展开缩写的命令。

    # sl_readline/readline.rb
    require 'abbrev'
    require 'readline'
    include Readline
    ABBREV = %w{ exit inc dec }.abbrev
    Readline.completion_proc = -> string { ABBREV[string] }
    value = 0
    loop do
      cmd = readline("wibble [#{value}]: ", true) || "exit"
      case cmd.strip
      when "exit" then break
      when "inc" then value += 1
      when "dec" then value -= 1
      else puts "Invalid command #{cmd}"
      end
    end
    wibble [0]: inc
    wibble [1]: <up-arrow>  => inc
    wibble [2]: d<tab>      => dec
    wibble [1]: in<esc><p>  => inc
    wibble [2]: exit

## Library Resolv  域名解析

DNS Client Library
DNS客户端库

The resolv library is a pure-Ruby implementation of a DNS client—it can be used to convert domain names into corresponding IP addresses.  
resolv库是DNS客户端的一个纯ruby的实现--可以摔伤它来将域名转换为相应的IP地址。
It also supports reverse lookups and the resolution of names in the local hosts file.
它还支持反查询，以及解析本地hosts文件中的域名。

Loading the additional library resolv-replace insinuates the resolv library into Ruby’s socket library on page 807.
加载附加库resolv-replace会将resolv库插入到ruby的socket库（后面2版735页4版807页）中。

Basic name lookups are already built-in to the standard socket libraries.  
基本的域名查找已经内建到标准的socket库中了。
The resolv library exists because, prior to Ruby 1.9, calling the operating system to do a name lookup would suspend all interpreter threads.  
resolv库存在的原因是，在ruby 1.9之前，调用操作系统进行一个域名解析会挂起所有的解释器线程。
That is no longer the case.
现在不会出现这种情况了。

## Library REXML  XML处理

XML Processing Library
XML处理库

REXML is a pure-Ruby XML processing library, including DTD-compliant document parsing, XPath querying, and document generation.  
REXML是一个由纯Ruby编写的XML处理库，包括符合DTD的文档解析，XPath查询，以及文档生成。
It supports both tree-based and stream-based document processing.  
它支持基于树和基于流的文档处理。
Because it is written in Ruby, it is available on all platforms supporting Ruby.  
因为它是用ruby编写的，所以它在ruby支持的所有平台都可获得。
REXML has a full and complex interface—this section contains a few small examples.
REXML 有完整但复杂的接口--本节只包括一些小的示例。

• Assume the file demo.xml contains this:
  假定demo.xml文件包括：

    <classes language="ruby">
      <class name="Numeric">
        Numeric represents all numbers.
        <class name="Float">
          Floating point numbers have a fraction and a mantissa.
        </class>
        <class name="Integer">
          Integers contain exact integral values.
          <class name="Fixnum">
            Fixnums are stored as machine ints.
          </class>
          <class name="Bignum">
            Bignums store arbitraty-sized integers.
          </class>
        </class>
      </class>
    </classes>

• Reads and processes the XML:
  读取和处理XML：

    require 'rexml/document'
    xml = REXML::Document.new(File.open("code/sl_rexml/demo.xml"))
    puts "Root element: #{xml.root.name}"
    print "The names of all classes: "
    xml.elements.each("//class") {|c| print c.attributes["name"], " " }
    print "\nDescription of Fixnum: "
    p xml.elements["//class[@name='Fixnum']"].text
    # produces:
    # Root element: classes
    # The names of all classes: Numeric Float Integer Fixnum Bignum
    # Description of Fixnum: "\n Fixnums are stored as machine ints.\n "

• Reads in a document, adds and deletes elements, and manipulates attributes before writing it back out:
  读入一个文档，在写回之前，添加并删除一些元素，操作属性。

    require 'rexml/document'
    include REXML
    xml = Document.new(File.open("code/sl_rexml/demo.xml"))
    cls = Element.new("class")
    cls.attributes["name"] = "Rational"
    cls.text = "Represents complex numbers"
    # Remove Integer's children, and add our new node as
    # the one after Integer
    # 移除Integer的子类，并在后面增加新的节点
    int = xml.elements["//class[@name='Integer']"]
    int.delete_at(1)
    int.delete_at(2)
    int.next_sibling = cls
    # Change all the 'name' attributes to class_name
    # 将所有name属性改为class_name
    xml.elements.each("//class") do |c|
      c.attributes['class_name'] = c.attributes['name']
      c.attributes.delete('name')
    end
    # and write it out with a XML declaration at the front
    xml << XMLDecl.new
    xml.write(STDOUT, 2)
    # produces:
    # <?xml version='1.0'?>
    # <classes language='ruby'>
    #   <class class_name='Numeric'>
    #     Numeric represents all numbers.
    #     <class class_name='Float'>
    #       Floating point numbers have a fraction and a mantissa.
    #     </class>
    #     <class class_name='Integer'>
    #       Integers contain exact integral values.
    #     </class>
    #     <class class_name='Rational'>
    #       Represents complex numbers
    #     </class>
    #   </class>
    # </classes>

## Library Rinda  分布式黑板系统

Tuplespace Implementation
Tuplespace的实现

Tuplespaces are a distributed blackboard system.  
Tuplespace是一个分布式的黑板系统。
Processes may add tuples to the blackboard, and other processes may remove tuples from the blackboard that match a certain pattern.
进程可能向黑板添加元组，而其他进程可能从黑板上删除匹配某个特定模式的元组。
Originally presented by David Gelernter, tuplespaces offer an interesting scheme for distributed cooperation among heterogeneous processes.
最初由David Gelernter提出，tuplespace为异构进程间的分布式合作提供了一种有趣的方式。

Rinda, the Ruby implementation of tuplespaces, offers some interesting additions to the concept.  
Rinda，是tuplespace的ruby实现，并增加了一些有趣的东西。
In particular, the Rinda implementation uses the === operator to match tuples.  
特别地，Rinda实现了使用===操作来匹配元素。
This means that tuples may be matched using regular expressions, the classes of their elements, and the element values.
这意味着，tuples可以使用正则表达式、元素的类以及元素的值来进行匹配。

See also: DRb (page 748)
另见DRb（前面2版670页4版748页）

• The blackboard is a DRb server that offers a shared tuplespace:
  黑板是一个DRb服务器，提供共享的tuplespace。

    require 'rinda/tuplespace'
    MY_URI = "druby://127.0.0.1:12131"
    DRb.start_service(MY_URI, Rinda::TupleSpace.new)
    DRb.thread.join

• The arithmetic agent accepts messages containing an arithmetic operator and two numbers.  
  算术代理接收一个包括算术运算符和两个数字的消息。
  It stores the result back on the blackboard.
  然后它把结果保存在黑板上。

    require 'rinda/rinda'
    MY_URI = "druby://127.0.0.1:12131"
    DRb.start_service
    ts = Rinda::TupleSpaceProxy.new(DRbObject.new(nil, MY_URI))
    loop do
      op, v1, v2 = ts.take([ %r{^[-+/*]$}, Numeric, Numeric])
      ts.write(["result", v1.send(op, v2)])
    end

• The client places tuples on the blackboard and reads back the result of each:
  客户端在黑板上放置一系列元素，然后读回每一个的结果。

    require 'rinda/rinda'
    MY_URI = "druby://127.0.0.1:12131"
    DRb.start_service
    ts = Rinda::TupleSpaceProxy.new(DRbObject.new(nil, MY_URI))
    queries = [[ "+", 1, 2 ], [ "*", 3, 4 ], [ "/", 8, 2 ]]
    queries.each do |q|
      ts.write(q)
      ans = ts.take(["result", nil])
      puts "#{q[1]} #{q[0]} #{q[2]} = #{ans[1]}"
    end
    # produces:
    # 1 + 2 = 3
    # 3 * 4 = 12
    # 8 / 2 = 4

## Library Ripper  裂具  1.9

Parse Ruby Source
剖析ruby源文件

The ripper library gives you access to Ruby’s parser.  
ripper库让你访问ruby的剖析器。
It can tokenize input, return lexical tokens, and return a nested S-expression.  
它能标记输出，返回语义的标记，并返回以挂嵌套的S表达式。
It also supports event-based parsing.
它也支持基于事件的剖析。

• Tokenize a line of Ruby code:
  标记一行ruby代码

    require "ripper"
    content = "a=1;b=2;puts a+b"
    p Ripper.tokenize(content)
    # produces:
    # ["a", "=", "1", ";", "b", "=", "2", ";", "puts", " ", "a", "+", "b"]

• Does a lexical analysis, returning token types, values, and line and column numbers:
  进行一次语义分析，返回标记类型、值和行、列数：

    require "ripper"
    require "pp"
    content = "a=1;b=2;puts a+b"
    pp Ripper.lex(content)[0,5]
    # produces:
    # [[[1, 0], :on_ident, "a"],
    #  [[1, 1], :on_op, "="],
    #  [[1, 2], :on_int, "1"],
    #  [[1, 3], :on_semicolon, ";"],
    #  [[1, 4], :on_ident, "b"]]

• Returns the sexp representing a chunk of code:
  返回表示一块代码的sexp：

    require "ripper"
    require "pp"
    content = "a=1;b=2;puts a+b"
    pp Ripper.sexp(content)
    # produces:
    # [:program,
    #  [[:assign, [:var_field, [:@ident, "a", [1, 0]]], [:@int, "1", [1, 2]]],
    #   [:assign, [:var_field, [:@ident, "b", [1, 4]]], [:@int, "2", [1, 6]]],
    #   [:command,
    #    [:@ident, "puts", [1, 8]],
    #    [:args_add_block,
    #     [[:binary,
    #       [:var_ref, [:@ident, "a", [1, 13]]],
    #       :+,
    #       [:var_ref, [:@ident, "b", [1, 15]]]]],
    #     false]]]]


• As a (silly) example of event-based lexical analysis, here’s a program that finds class definitions and their associated comment blocks.  
  作为基于事件的语义分析的小例子，这一个程序找到类定义和相关的注释块。
  For each, it outputs the class name and the comment.  
  每一次，它输出类名和注释。
  It might be considered the zeroth iteration of an RDoc-like program.
  它可被看作类似RDoc程序的第0代。

  The parameter to parse is an accumulator—it is passed between event handlers and can be used to construct the result.
  要剖析的参数是个积蓄器，它在事件处理器之间传递着，可以被用于构建结果。

    require 'ripper'
    # This class handles parser events, extracting
    # comments and attaching them to class definitions
    class BabyRDoc < Ripper::Filter
      def initialize(*)
        super
        reset_state
      end
      def on_default(event, token, output)
        reset_state
        output
      end
      def on_sp(token, output)
        output
      end
      alias on_nil on_sp
      def on_comment(comment, output)
        @comment << comment.sub(/^\s*#\s*/, "   ")
        output
      end
      def on_kw(name, output)
        @expecting_class_name = (name == 'class')
        output
      end
      def on_const(name, output)
        if @expecting_class_name
          output << "#{name}:\n"
          output << @comment
        end
        reset_state
        output
      end
      private
      def reset_state
        @comment = ""
        @expecting_class_name = false
      end
    end
    BabyRDoc.new(File.read(__FILE__)).parse(STDOUT)
    # produces:
    # BabyRDoc:
    #     This class handles parser events, extracting
    #     comments and attaching them to class definitions

## Library RSS  聚合内容

RSS Feed Generation and Parsing
聚合内容种子的生成和解析

Rich Site Summary or RDF Site Summary or Really Simple Syndication—take your pick.
富网站摘要，或叫资源描述框架网站摘要，或叫真正简单聚合--随你挑一个。
RSS is the protocol of choice for disseminating news on the Internet.  
RSS是特意用于因特网上传播新闻的一种协议。
The Ruby RSS library supports creating and parsing streams compliant with RSS 0.9, RSS 1.0, and RSS 2.0.
ruby的RSS库支持创建和解析符合RSS0.9 RSS1.0 RSS 2.0规范的流。

• Reads and summarizes the latest stories from http://ruby-lang.org:
  读取并总结http://ruby-lang.org上近期的新闻：

    require 'rss/2.0'
    require 'open-uri'
    open('http://ruby-lang.org/en/feeds/news.rss') do |http|
      response = http.read
      result = RSS::Parser.parse(response, false)
      puts "Channel: " + result.channel.title
      result.items.each_with_index do |item, i|
        puts "#{i+1}. #{item.title}" if i < 3
      end
    end
    # produces:
    # Channel: Ruby News
    # 1. Ruby 1.9.3-p429 is released
    # 2. Ruby 2.0.0-p195 is released
    # 3. Object taint bypassing in DL and Fiddle in Ruby (CVE-2013-2065)
 
• Generates some RSS information:
  生成RSS信息：

    require 'rss/0.9'
    rss = RSS::Rss.new("0.9")
    chan = RSS::Rss::Channel.new
    chan.title = "The Daily Dave"
    chan.description = "Dave's Feed"
    chan.language = "en-US"
    chan.link = "http://pragdave.pragprog.com"
    rss.channel = chan
    image = RSS::Rss::Channel::Image.new
    image.url = "http://pragprog.com/pragdave.gif"
    image.title = "PragDave"
    image.link = chan.link
    chan.image = image
    3.times do |i|
      item = RSS::Rss::Channel::Item.new
      item.title = "My News Number #{i}"
      item.link = "http://pragprog.com/pragdave/story_#{i}"
      item.description = "This is a story about number #{i}"
      chan.items << item
    end
    puts rss.to_s

## Library Scanf   扫描格式

Input Format Conversion
输入格式化转换

Implements a version of the C library scanf function, which extracts values from a string under the control of a format specifier.
实现了C库scanf函数的一个ruby版本，按照格式指示符从字符串中提取输入值。
The Ruby version of the library adds a scanf method to both class IO and class String.  
ruby版本的库为IO类和String类添加了scanf方法。
The version in IO applies the format string to the next line read from the receiver.  
IO类中的版本，将格式化字符串作用于读取出的下一行。
The version in String applies the format string to the receiver.  
String中的版本，将格式化字符串作用于接收者（调用字符串对象本身）。
The library also adds the global method Object#scanf, which uses as its source the next line of standard input.
这个库还添加了全局方法Object#scanf，将标准输入的下一行作为格式化的源。

Scanf has one main advantage over using regular expressions to break apart a string: a regular expression extracts strings, whereas scanf will return objects converted to the correct type.
使用scanf来断开一个字符串和使用正则表达式相比，有一个主要的好处：正则表达式提取处字符串，而scanf会将对象转换为正确的类型。
• Splits a date string into its constituents:
  将一个日期字符串分解为它的组成部分：

    require 'scanf'
    date = "2010-12-15"
    year, month, day = date.scanf("%4d-%2d-%2d")
    year # => 2010
    month # => 12
    day # => 15
    year.class # => Fixnum


• The block form of scanf applies the format multiple times to the input string, returning each set of results to the block. 
  scanf的block形式，可以对输入字符串进行多次格式化，将结果的每个集合返回给block。
  The numbers are returned as integers, not strings:
  数字将被作为整数返回，而不是字符串。

    require 'scanf'
    data = "cat:7 dog:9 cow:17 walrus:31"
    data.scanf("%[^:]:%d ") do |animal, value|
      puts "A #{animal.strip} has #{value}"
    end
    # produces:
    # A cat has 7
    # A dog has 9
    # A cow has 17
    # A walrus has 31

• Extracts hex numbers:
  解压十六进制数字：

    require 'scanf'
    data = "decaf bad"
    data.scanf("%3x%2x%x") # => [3564, 175, 2989]

## Library SDBM

Interface to SDBM Database
SDBM数据库的接口
<kinder:note> 什么是SDMB数据库？百度和维基百科都找不到资料。 可以理解为string database manage吗？即字符串数据库管理？ 

The SDBM database implements a simple key/value persistence mechanism.  
SDBM数据库实现了一个简单的key/value的持久化机制。
Because the underlying SDBM library itself is provided with Ruby, there are no external dependencies, and SDBM should be available on all platforms supported by Ruby.  
因为底层的SDBM库本身是由Ruby提供的，没有外部的依赖，所以SDMB在ruby支持的所有平台上都可以获得。
SDBM database keys and values must be strings.  
SDBM数据库的键和值必须是字符串。
SDBM databases are effectively hashlike.
SDBM数据库实际上类似于散列表。

See also: DBM (page 745) GDBM (page 760)
另见DBM（前面2版666页4版745页）GDBM（前面2版682页4版760页）

The example that follows stores a record in a new database and then fetches it back.  
下面的例子将记录保存到一个新的数据库中，然后将其取回。
Unlike the DBM library, all values to SDBM must be strings (or implement `to_str`).
和DBM库不同，SDBM的所有值必须是字符串（或实现了`to_str`）。

    require 'sdbm'
    require 'date'
    SDBM.open("data.dbm") do |dbm|
      dbm['name'] = "Walter Wombat"
      dbm['dob'] = Date.new(1997, 12,25).to_s
      dbm['uses'] = "Ruby"
    end
    SDBM.open("data.dbm", nil) do |dbm|
      p dbm.keys
      p dbm['dob']
    end
    # produces:
    # ["name", "dob", "uses"]
    # "1997-12-25"

## Library SecureRandom  安全随机  1.9

Access to Secure Random Number Generators
访问安全随机数产生器

Provides access to one of your operating system’s secure random number generators.  
提供访问你操作系统的一个安全随机数产生器。
If the OpenSSL library is installed, the module uses its random_bytes method.  
如果安装了OpenSSL库，这个模块使用它的`random_bytes`方法。
Otherwise, the module looks for and uses /dev/urandom or the CryptGenRandom method in the Windows API.
否则，该模块寻找并使用/dev/urandom或者在Windows API的CryptGenRandom方法。

• Generates some random numbers:
  产生一些随机数。

    require 'securerandom' 
    # Random floats such that 0.0 <= rand < 1.0
    # 随机的浮点数，0.0 <= rand < 1.0
    SecureRandom.random_number(0) # => 0.26256698786247024
    SecureRandom.random_number(0) # => 0.6885743213737645
    # Random integers such that 0 <= rand < 1000
    # 随机的整数，0 <= rand < 1000
    SecureRandom.random_number(1000) # => 112
    SecureRandom.random_number(1000) # => 273

• Generates ten random bytes, returning the result as a hex string, a Base64 string, and a string of binary data.  
  删生十个随机字节，返回结果为一个十六进制字符串，一个Base64字符串，和一个二进制数据字符串。
  A different random string is returned for each call.
  为每一个调用返回一个不同的随机字符串。

    require 'securerandom'
    SecureRandom.hex(10) # => "bf4262e94d093ffbb4a7"
    SecureRandom.base64(10) # => "X/8YpCbCEyO2zA=="
    SecureRandom.random_bytes(10) # => "\x7FO\0r\r\xC1?\xB7b#"

## Library Set  集合

Implement Various Forms of Set
实现各种形式的集合

A Set is a collection of unique values (where uniqueness is determined using eql? and hash).
Set是一个唯一值的集合（唯一性由eql?和hash判断）。
Convenience methods let you build sets from enumerable objects.
有方便的方法可以让你将set绑定到可枚举的对象。
• Basic set operations:
  基本的set操作：

    require 'set'
    set1 = Set.new([:bear, :cat, :deer])
    set1.include?(:bat)  # => false
    set1.add(:fox)       # => #<Set: {:bear, :cat, :deer, :fox}>
    partition = set1.classify {|element| element.to_s.length }
    partition            # => {4=>#<Set: {:bear, :deer}>, 3=>#<Set: {:cat, :fox}>}
    set2 =  [ :cat, :dog, :cow ].to_set
    set1 | set2         # => #<Set: {:bear, :cat, :deer, :fox, :dog, :cow}>
    set1 & set2         # => #<Set: {:cat}>
    set1 - set2         # => #<Set: {:bear, :deer, :fox}>
    set1 ^ set2         # => #<Set: {:dog, :cow, :bear, :deer, :fox}>

• Partitions the users in our /etc/passwd file into subsets where members of each subset have adjacent user IDs:
  将/etc/passwd文件中的用户信息隔离到子集中，并且每个子集的成员都具有相邻的用户ID。

    require 'etc'
    require 'set'
    users = []
    Etc.passwd {|u| users << u }
    related_users = users.to_set.divide do |u1, u2|
      (u1.uid - u2.uid).abs <= 1
    end
    related_users.each do |relatives|
      relatives.each {|u| print "#{u.uid}/#{u.name} " }
      puts "\n======="
    end
    # produces:
    # 235/_assetcache 234/_krb_anonymous 233/_krb_kerberos 232/_krb_changepw
    # 231/_krb_kadmin 230/_krb_krbtgt 229/_avbdeviced 228/_netstatistics 227/_dovenull
    # =======
    # 93/_calendar 92/_securityagent 91/_tokend
    # =======
    # 202/_coreaudiod 203/_screensaver 201/Guest 200/_softwareupdate
    # =======
    # ...

## Library Shellwords  分解命令行单词

Manipulate Shell Lines Using POSIX Semantics
使用POSIX语义将命令行分解为单词

Given a string representative of a shell command line, splits it into word tokens according to POSIX semantics.  
给定一个表示shell命令行的字符串，依据POSIX语义，将它分解到单词词条。
Also allows you to create properly escaped shell lines from individual words.
也允许从独立的单词中你创建适当转义的shell行。
• Spaces between double or single quotes are treated as part of a word.
  双引号或单引号之间的空白被视为单词的组成部分。
• Double quotes may be escaped using a backslash.
  双引号可以使用反斜线来转义。
• Spaces escaped by a backslash are not used to separate words.
  由反斜线转义的空白符不会被用以分割单词。
• Otherwise, tokens separated by whitespace are treated as words.
  否则由空白符分割的词条被视为单词。

    require 'shellwords'
    include Shellwords

    line = %{Code Ruby Be Happy!}
    shellwords(line) # => ["Code", "Ruby", "Be", "Happy!"]
    
    line = %{"Code Ruby" 'Be Happy'!}
    shellwords(line) # => ["Code Ruby", "Be Happy!"]
    
    line = %q{Code\ Ruby "Be Happy"!}
    shellwords(line) # => ["Code Ruby", "Be Happy!"]
    
    shelljoin(["Code Ruby", "Be Happy"]) # => Code\ Ruby Be\ Happy

In addition, the library adds shellsplit and shelljoin methods to classes String and Array, respectively:
另外，这个库为String和Array类各增加了shellsplit和shelljoin方法。

    require 'shellwords'
    include Shellwords
    %{Code\\ Ruby Be Happy!}.shellsplit # => ["Code Ruby", "Be", "Happy!"]
    ["Code Ruby", "Be Happy"].shelljoin # => "Code\\ Ruby Be\\ Happy"

## Library Singleton  单例

The Singleton Pattern
单例模式

The Singleton design pattern ensures that only one instance of a particular class may be created for the lifetime of a program (see Design Patterns [GHJV95]).
单例设计模式确保某个特定的类，在程序的生命期内只能创建一个唯一的实例。
在程序的声明期内只能创建一个唯一的实例（参见设计模式[GHJV95]。
The singleton library makes this simple to implement.  
单例库使得它非常容易实现。
Mix the Singleton module into each class that is to be a singleton, and that class’s new method will be made private.  
将单例模块混入到需要成为单例的类中，而且这个类中的new方法会修改为私有方法。
In its place, users of the class call the method instance, which returns a singleton instance of that class.
在它的作用下，这个类的用户可以调用instance方法，返回这个类的单体实例。
In this example, the two instances of MyClass are the same object:
在下面的例子中，MyClass的两个实例是同一个对象：

    require 'singleton'
    class MyClass
      attr_accessor :data
      include Singleton
    end
    a = MyClass.instance   # => #<MyClass:0x007feb190604d0>
    b = MyClass.instance   # => #<MyClass:0x007feb190604d0>
    a.data = 123           # => 123
    b.data                 # => 123
    a.object_id            # => 70323856933480
    b.object_id            # => 70323856933480

## Library Socket  套接字

IP, TCP, Unix, and SOCKS Socket Access
访问IP, TCP, Unix, 和 SOCKS套接字

The socket extension defines nine classes for accessing the socket-level communications of the underlying system.  
套接字扩展定义了九个类来访问底层系统的套接字层的通信。
All of these classes are (indirect) subclasses of class IO, meaning that IO’s methods can be used with socket connections.
所有这些类都（间接）是IO类的子类，意味着IO类中的方法可以用于套接字连接。

The hierarchy of socket classes reflects the reality of network programming and hence is somewhat confusing.  
套接字类的层次反映了网络编程的现实，因此有些令人困惑。
The BasicSocket class largely contains methods common to data transfer for all socket-based connections.  
BasicSocket类包括了大部分用于套接字连接的数据传输的通用方法。
It is subclassed to provide protocol-specific implementations: IPSocket and UNIXSocket (for domain sockets).  
可以对其子类化来提供特定协议的实现： IPSocket 和 UNIXSocket（实现了Unix域套接字）。
These in turn are subclassed by TCPSocket, UDPSocket, and SOCKSSocket.
它们分别被TCPSocket, UDPSocket, 和SOCKSSocket所子类化。

BasicSocket is also subclassed by class Socket, which is a more generic interface to socket-oriented networking.  
BasicSocket也被Socket类子类化，Socket是面向套接字网络的一个更通用的接口。
Although classes such as TCPSocket are specific to a protocol, Socket objects can, with some work, be used regardless of protocol.
诸如TCPSocket这样的类是特定于协议的，而使用Socket，加上一些额外的工作，就可以坐看不依赖特定协议。
TCPSocket, SOCKSSocket, and UNIXSocket are each connection oriented.  
TCPSocket, SOCKSSocket, 和UNIXSocket都是面向连接的。
Each has a corresponding xxxxServer class, which implements the server end of a connection.
每个都有一个对应的xxxxServer类，实现连接的服务器方。

The socket libraries are something that you may never use directly.  
你可能用于不会直接使用Socket库。
However, if you do use them, you’ll need to know the details.  
不过，如果你使用它们，就需要知道很多细节。
For that reason, we’ve put a reference section online at http://pragprog.com/book/ruby3/programming-ruby-1-9?tab=tab-contents.
因为这个原因，我们将参考章节来放在网上http://pragprog.com/book/ruby3/programming-ruby-1-9?tab=tab-contents。

The following code shows a trivial UDP server and client:
下面的代码演示了一个简单的UDP服务器和客户端。

    # Simple logger prints messages received on UDP port 12121
    # 简单日记器在UDP协议12121端口上接受并打印消息
    require 'socket'
    socket = UDPSocket.new
    socket.bind("127.0.0.1", 12121)
    loop do
      msg, sender = socket.recvfrom(100)
      host = sender[3]
      puts "#{Time.now}: #{host} '#{msg}'"
      STDOUT.flush
    end

    # Exercise the logger
    # 演练这个日记器
    require 'socket'
    log = UDPSocket.new
    log.connect("127.0.0.1", 12121)
    log.print "Up and Running!"
    # process ... process ..
    log.print "Done!"

    # produces:
    # 2013-05-27 12:33:39 -0500: 127.0.0.1 'Up and Running!'
    # 2013-05-27 12:33:39 -0500: 127.0.0.1 'Done!'

## Library StringIO   字符串IO

Treat Strings as IO Objects
将字符串视作IO对象

In some ways, the distinction between strings and file contents is artificial: the contents of a file are basically a string that happens to live on disk, not in memory.  
在某种程度上，字符串和文本内容之间的区别是人为的：文件的内容基本上是一个保存在磁盘上（而非内存中）的字符串。
The StringIO library aims to unify the two concepts, making strings act as if they were opened IO objects.  
StringIO库的目的是统一这两个概念，让字符串具有打开IO对象的行为。
Once a string is wrapped in a StringIO object, it can be read from and written to as if it were an open file.  
一旦字符串被包装成StringIO对象之后，你就可以从中读取或向其写入，好像它是一个打开的文件 。
This can make unit testing a lot easier.  
这可以让单元测试简单得多。
It also lets you pass strings into classes and methods that were originally written to work with files.  
你可以把字符串传入到原本为操作文件编写的类和方法中。
StringIO objects take their encoding from the string you pass in or the default external encoding is that no string is passed.
StringIO对象的编码是你传入的字符串的编码，如果没有字符串传入，则是默认外部编码。

• Reads and writes from a string:
  对字符串中进行读写：

    require 'stringio'
    sio = StringIO.new("time flies like an arrow")
    sio.read(5) # => "time "
    sio.read(5) # => "flies"
    sio.pos = 19
    sio.read(5) # => "arrow"
    sio.rewind # => 0
    sio.write("fruit") # => 5
    sio.pos = 16
    sio.write("a banana") # => 8
    sio.rewind # => 0
    sio.read # => "fruitflies like a banana"

• Uses StringIO as a testing aid:
  为测试目的使用StringIO：

    require 'stringio'
    require 'csv'
    require 'test/unit'
    class TestCSV < Test::Unit::TestCase
      def test_simple
        StringIO.open do |op|
          CSV(op) do |csv|
            csv << [ 1, "line 1", 27 ]
            csv << [ 2, nil, 123 ]
          end
          assert_equal("1,line 1,27\n2,,123\n", op.string)
        end
      end
    end
    # produces:
    # Run options:
    # # Running tests:
    # .
    # Finished tests in 0.004047s, 247.0966 tests/s, 247.0966 assertions/s.
    # 1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
    # ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

## Library StringScanner  字符串扫描

Basic String Tokenizer
基本的字符串分词

StringScanner objects progress through a string, matching (and optionally returning) tokens that match a given pattern.  
StringScanner对象处理一个字符串，匹配（并可能返回）符合给定模式的词条。
Unlike the built-in scan methods, StringScanner objects maintain a current position pointer in the string being examined, so each call resumes from the position in the string where the previous call left off.  
和内建的扫描方法不同，StringScanner对象包括字符串当前检验位置的指针，因此，每次调用都沿着上一次调用留下的这个位置。
Pattern matches are anchored to this previous point.
模式匹配定位在上一次的位置。

• Implements a simple language:
  实现一个简单的语言：

    require 'strscan'
    # Handle the language:
    # set <var> = <value>
    # get <var>
    values = {}
    while line = gets
      scanner = StringScanner.new(line.chomp)
      scanner.scan(/(get|set)\s+/) or fail "Missing command"
      cmd = scanner[1]
      var_name = scanner.scan(/\w+/) or fail "Missing variable"
      case cmd
      when "get"
        puts "#{var_name} => #{values[var_name].inspect}"
      when "set"
        scanner.skip(/\s+=\s+/) or fail "Missing '='"
        value = scanner.rest
        values[var_name] = value
      else
        fail cmd
      end
    end

Run this from the command line, typing in phrases from the language:
在命令行运行这个脚本，输入语言的单词。

    $ ruby strscan.rb   # 这一行要你键入
    set a = dave        # 这一行要你键入
    set b = hello       # 这一行要你键入
    get b               # 这一行要你键入
    b => "hello"
    get a               # 这一行要你键入
    a => "dave"

## Library Syslog   系统日志  

Only if: Unix system with syslog
只有带syslog的Unix系统才可用

Interface to Unix System Logging
Unix系统日志接口

The Syslog class is a simple wrapper around the Unix syslog(3) library.  
Syslog类是Unix syslog(3)函数库的一个简单包装。
It allows messages to be written at various severity levels to the logging daemon, where they are disseminated according to the configuration in syslog.conf.  
它可以让消息以不同的安全级别写入到日志守护进程中，按照sysog.conf中的配置传播。
**⇡New in 2.0⇣**
Ruby 2.0 adds support for Syslog::Logger, which is compatible with the Logger API.
Ruby 2.0增加了对Syslog::Logger的支持，它和Logger API兼容。

The following examples assume the log file is /var/log/system.log.
下面的示例假定日志文件为/var/log/system.log。
• Adds to our local system log. 
  添加到我们的本地系统日志。
  We’ll log all the levels configured for the user facility for our system (which is every level except debug and info messages).
  我们将记录所有级别的用户消息（除了调试消息之外）。

    require 'syslog'
    log = Syslog.open("test")   # "test" is the app name 应用程序名称
    log.debug("Warm and fuzzy greetings from your program")
    log.info("Program starting")
    log.notice("I said 'Hello!'")
    log.warning("If you don't respond soon, I'm quitting")
    log.err("You haven't responded after %d milliseconds", 7)
    log.alert("I'm telling your mother...")
    log.emerg("I'm feeling totally crushed")
    log.crit("Aarrgh....")
    system("tail -6 /var/log/system.log")
    # produces:
    # Sep 16 12:48:44 dave-4 test[35121]: Warm and fuzzy greetings from your program
    # Sep 16 12:48:44 dave-4 test[35121]: Program starting
    # Sep 16 12:48:44 dave-4 test[35121]: I said 'Hello!'
    # Sep 16 12:48:44 dave-4 test[35121]: If you don't respond soon, I'm quitting
    # Sep 16 12:48:44 dave-4 test[35121]: You haven't responded after 7 milliseconds
    # Sep 16 12:48:44 dave-4 test[35121]: I'm telling your mother...
    # Sep 16 12:48:44 dave-4 test[35121]: I'm feeling totally crushed
    # Sep 16 12:48:44 dave-4 test[35121]: Aarrgh....

• Logs only errors and above:
  只记录上面的错误消息：

    require 'syslog'
    log = Syslog.open("test")
    log.mask = Syslog::LOG_UPTO(Syslog::LOG_ERR)   # 这一句是关键
    log.debug("Warm and fuzzy greetings from your program")
    log.info("Program starting")
    log.notice("I said 'Hello!'")
    log.warning("If you don't respond soon, I'm quitting")
    log.err("You haven't responded after %d milliseconds", 7)
    log.alert("I'm telling your mother...")
    log.emerg("I'm feeling totally crushed")
    log.crit("Aarrgh....")
    system("tail -4 /var/log/system.log")
    # produces:
    # Sep 16 12:48:44 dave-4 test[35124]:  You haven't responded after 7 milliseconds
    # Sep 16 12:48:44 dave-4 test[35124]:  I'm telling your mother...
    # Sep 16 12:48:44 dave-4 test[35124]:  I'm feeling totally crushed
    # Sep 16 12:48:44 dave-4 test[35124]:  Aarrgh....

## Library Tempfile  临时文件

Temporary File Support
临时文件支持

Class Tempfile creates managed temporary files.  
Tempfile类创建受控的临时文件。
Although they behave the same as any other IO objects, temporary files are automatically deleted when the Ruby program terminates.
虽然它们和其他的IO对象的行为相同，但是当Ruby程序结束时会自动删除这些临时文件。
Once a Tempfile object has been created, the underlying file may be opened and closed a number of times in succession.
当Tempfile对象被创建时，底层的文件可能多次被打开和关闭。

Tempfile does not directly inherit from IO.  
Tempfile 并不直接继承于IO。
Instead, it delegates calls to a File object.  
相反，它将 所有调用委托给一个File对象。
From the programmer’s perspective, apart from the unusual new, open, and close semantics, a Tempfile object behaves as if it were an IO object.
从程序员的角度来看，除了不同的new open close语义外，Tempfile对象的行为就像是一个IO对象。

If you don’t specify a directory to hold temporary files when you create them, the tmpdir library will be used to find a system-dependent location.
如果你创建它们时没有指定保存临时文件的目录，则会使用tmpdir来得到一个系统的相关位置。

See also: tmpdir (page 818)
另见后面2版748页4版818页的tmpdir。

    require 'tempfile'
    tf = Tempfile.new("afile")
    tf.path # => "/var/folders/44/j19_ml3n3dx7bwrb_qmbcjyc0000gn/T/afile20130527-24
            # .. 867-1greefy"
    tf.puts("Cosi Fan Tutte")
    tf.close
    tf.open
    tf.gets # => "Cosi Fan Tutte\n"
    tf.close(true)

## Library Test::Unit  单元测试

Unit Testing Framework
单元测试框架

Test::Unit is a unit testing framework based on the original SUnit Smalltalk framework.  
Test::Unit是一个基于SUnit Smaltalk框架的单元测试框架。
It provides a structure in which unit tests may be organized, selected, and run.  
它提供了用以组织、选取和运行测试的一种结构。
Tests can be run from the command line or using one of several GUI-based interfaces.
测试可以从命令行运行，或使用某个图形界面的接口。

Chapter 13, Unit Testing, on page 175 contains a tutorial on Test::Unit.
在2版151页的12章4版175页的14章，包含了Test::Unit的入门教程。

Maybe we have a simple playlist class, designed to store and retrieve songs:
下面是一个简单的播放列表类，设计用来保存和获取歌曲：

    require_relative 'song.rb'
    require 'forwardable'
    class Playlist
      extend Forwardable
      def_delegator(:@list, :<<, :add_song)
      def_delegators(:@list, :size, :empty?)
      def initialize
        @list = []
      end
      def find(title)
        @list.find {|song| song.title == title}
      end
    end

We can write unit tests to exercise this class.  
我们可以编写一个单元测试来检验这个类。
The Test::Unit framework is smart enough to run the tests in a test class if no main program is supplied.
Test::Unit框架非常聪明，当没有提供主程序时，则运行测试类中的测试项目。`

    require 'test/unit'
    require_relative 'playlist.rb'
    class TestPlaylist < Test::Unit::TestCase
      def test_adding
        pl = Playlist.new
        assert_empty(pl)
        assert_nil(pl.find("My Way"))
        pl.add_song(Song.new("My Way", "Sinatra"))
        assert_equal(1, pl.size)
        s = pl.find("My Way")
        refute_nil(s)
        assert_equal("Sinatra", s.artist)
        assert_nil(pl.find("Chicago"))
        # .. and so on  <kinder:note> 应该是只有5个断言。下面怎么说7个啊！
      end
    end
    # produces:
    # Run options:
    # # Running tests:
    # .
    # Finished tests in 0.004140s, 241.5459 tests/s, 1690.8213 assertions/s.
    # 1 tests, 7 assertions, 0 failures, 0 errors, 0 skips
    # ruby -v: ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.2.0]

## Library thread  线程

Utility Functionality for Threading
多线程的实用功能

The thread library adds some utility functions and classes for supporting threads.  
thread库为支持线程添加了一些实用函数和类。
Much of this has been superseded by the Monitor class, but the thread library contains two classes, Queue and SizedQueue, that are still useful.  
其中大部分已经被Monitor类所取代，不过它包括的两个类Queue和SizeQueue，依然很有用。
Both classes implement a thread-safe queue that can be used to pass objects between producers and consumers in multiple threads.  
这两个类都实现了线程安全的队列，可以用来在多线程环境中的生产者和消费者之间传递对象。
The Queue object implements a unbounded queue.  
Queue对象输出现了一个无大小限制的队列。
A SizedQueue is told its capacity; any producer that tries to add an object when the queue is at that capacity will block until a consumer has removed an object.
SizeQueue有指定的容积：队列已满时，试图向其中添加对象的生产者会被阻塞，直至有一个消费者取出一个对象。

The following example was provided by Robert Kellner.  
下面的示例由Robert Kellner提供。
It has three consumers taking objects from an unsized queue.  
其中有三个消费者从没有大小限制的队列中取得对象。
Those objects are provided by two producers, which each add three items.
这些对象是由两个生产者提供的，每个添加三项。

    require 'thread'
    queue = Queue.new
    consumers = (1..3).map do |i|
      Thread.new("consumer #{i}") do |name|
        begin
          obj = queue.deq
          print "#{name}: consumed #{obj.inspect}\n"
        end until obj == :END_OF_WORK
      end
    end
    producers = (1..2).map do |i|
      Thread.new("producer #{i}") do |name|
        3.times do |j|
          queue.enq("Item #{j} from #{name}")
        end
      end
    end
    producers.each(&:join)
    consumers.size.times { queue.enq(:END_OF_WORK) }
    consumers.each(&:join)
    # produces:
    # consumer 1: consumed "Item 0 from producer 1"
    # consumer 1: consumed "Item 1 from producer 1"
    # consumer 1: consumed "Item 2 from producer 1"
    # consumer 1: consumed "Item 0 from producer 2"
    # consumer 2: consumed "Item 1 from producer 2"
    # consumer 3: consumed "Item 2 from producer 2"
    # consumer 1: consumed :END_OF_WORK
    # consumer 3: consumed :END_OF_WORK
    # consumer 2: consumed :END_OF_WORK














































## Library ThreadsWait  等待线程

Wait for Multiple Threads to Terminate
等待多个线程终止

Class ThreadsWait handles the termination of a group of thread objects.  
ThreadsWait类处理一组线程对象的终止。
It provides methods to allow you to check for termination of any managed thread and to wait for all managed threads to terminate.
它提供了若干方法，让你可以检查某个受控的线程是否终止，并等待所有受控线程终止。

The following example kicks off a number of threads that each wait for a slightly shorter length of time before terminating and returning their thread number.  
下面的示例启动了许多线程，每个线程等待一小段时间，然后退出并返回它们的线程号。
Using ThreadsWait, we can capture these threads as they terminate, either individually or as a group.
使用ThreadsWait，我们可以在线程退出时单独或者成组地捕捉到这些线程。

    require 'thwait'
    group = ThreadsWait.new
    # construct threads that wait for 1 second, .9 second, etc.
    # add each to the group
    # 每隔一秒构建一个线程，并添加到组中。
    9.times do |i|
      thread = Thread.new(i) {|index| sleep 1.0 - index/10.0; index }
      group.join_nowait(thread)
    end
    # any threads finished?
    # 查看是否有线程结束
    group.finished?  # => false
    
    # wait for one to finish
    # 等待一个结束
    group.next_wait.value # => 8
    
    # wait for 5 more to finish
    # 等待五个结束
    5.times { group.next_wait } # => 5
    
    # wait for next one to finish
    # 等待下一个结束
    group.next_wait.value # => 2

    # and then wait for all the rest
    # 等待所有剩下的结束
    group.all_waits # => nil

## Library Time  时间

Extended Functionality for Class Time
扩展Time类的功能。

The time library adds functionality to the built-in class Time, supporting date and/or time formats used by RFC 2822 (e-mail), RFC 2616 (HTTP), and ISO 8601 (the subset used by XML schema).
time库为内建的Time类添加了功能，支持RFC2822(电邮) RFC 2616(HTTP) ISO 8601(XML schema的子集)使用的日期和/或时间格式。

    require 'time'
    # Convert external formats into Time objects
    # 将外部格式转换为Time对象
    Time.rfc2822("Thu, 1 Apr 2010 16:32:45 CST")     # => 2010-04-01 17:32:45 -0500
    Time.rfc2822("Thu, 1 Apr 2010 16:32:45 -0600")   # => 2010-04-01 17:32:45 -0500
    Time.httpdate("Thu, 01 Apr 2010 16:32:45 GMT") # => 2010-04-01 11:32:45 -0500
    Time.httpdate("Thursday, 01-Apr-04 16:32:45 GMT") # => 2004-04-01 16:32:45 UTC
    Time.httpdate("Thu Apr 1 16:32:45 2010") # => 2010-04-01 16:32:45 UTC
    Time.xmlschema("2010-04-01T16:32:45")            # => 2010-04-01 16:32:45 -0500
    Time.xmlschema("2010-04-01T16:32:45.12-06:00")   # => 2010-04-01 22:32:45 UTC
    # Convert time objects into external formats
    # 将Time对象转换为外部格式
    Time.now.rfc2822 # => "Mon, 27 May 2013 12:33:41 -0500"
    Time.now.httpdate # => "Mon, 27 May 2013 17:33:41 GMT"
    Time.now.xmlschema # => "2013-05-27T12:33:41-05:00"

## Library Timeout  超时

Run a Block with Timeout
使用Timeout运行一个block

The Timeout.timeout method takes a parameter representing a timeout period in seconds, an optional exception parameter, and a block.  
Timeout.timeout很阿接收一个表示超时时间段（以秒为单位）的参数和一个可选的异常参数，以及一个block。
The block is executed, and a timer is run concurrently.  
block和定时器同时运行。
If the block terminates before the timeout, timeout returns the value of the block.
如果block在超时之前结束，则timeout返回block的值。
Otherwise, the exception (default Timeout::Error) is raised.
否则，抛出异常（默认为Timeout::Error）。

    require 'timeout'
    for snooze in 1..2
      puts "About to sleep for #{snooze}"
      begin
        Timeout::timeout(1.5) do |timeout_length|
          puts "Timeout period is #{timeout_length}"
          sleep(snooze)
          puts "That was refreshing"
        end
      rescue Timeout::Error
        puts "Woken up early!!"
      end
    end
    # produces:
    # About to sleep for 1
    # Timeout period is 1.5
    # That was refreshing
    # About to sleep for 2
    # Timeout period is 1.5
    # Woken up early!!

Be careful when using timeouts—you may find them interrupting system calls that you cannot reliably restart, resulting in possible data loss.
使用timeout时一定小心--你可能发现它们会打断系统调用，所以你不能可靠地重启，并导致数据丢失的可能。

## Library Tk  Tk图形界面

Wrapper for Tcl/Tk
Tcl/Tk的包装

Only if: Tk library installed
只有安装了Tk库才可用

Of all the Ruby options for creating GUIs, the Tk library is probably the most widely supported, running on Windows, Linux, Mac OS X, and other Unix-like platforms.[6]  
在所有使用Ruby创建图形用户界面的选项中，Tk库可能是支持最广泛的，可以运行在Windows、Linux、Mac OS X和其他类Unix的平台上。
[6].  All these environments require that the Tcl/Tk libraries are installed before the Ruby Tk extension can be used.
不过所有这些环境都需要先安装Tcl/Tk，才能使用ruby的Tk扩展。
Although it doesn’t produce the prettiest interfaces, Tk is functional and relatively simple to program.
虽然它产生的界面并不是最漂亮的，但对于程序来说Tk是实用并相对简单的。
<kinder:note> 2版补充：我们在前面255页19章中，完整地记录了Tk扩展。

# sl_tk/curves.rb
# encoding: utf-8
require 'tk'
include Math
  def plot(val)
    Integer(val * 180 + 200)
  end
TkRoot.new do |root|
  title "Curves"
  geometry "400x400"
  TkCanvas.new(root) do |canvas|
    width 400
    height 400
    pack('side'=>'top', 'fill'=>'both', 'expand'=>'yes')
    points = [ ]
    a = 2
    b = 3
    0.0.step(8, 0.1) do |t|
      x = Math.sin(a*t)
      y = Math.cos(b*t)
      points << plot(x) << plot(y)
    end
    TkcLine.new(canvas, *(points), smooth: 'on', width: 10, fill: 'blue')
  end
end
Tk.mainloop
# produces:
# 

## Library tmpdir  临时文件夹

System-Independent Temporary Directory Location
系统无关的临时目录位置

The tmpdir library adds the tmpdir method to class Dir.  
tmpdir库为Dir类添加了tmpdir方法。
This method returns the path to a temporary directory that should be writable by the current process.  
这个方法返回一个临时目录的路径，这个路径对当前进程来说是可写的。
(This will not be true if none of the well-known temporary directories is writable and if the current working directory is also not writable.) 
（如果没有一个众所周知的临时目录是可写的，并且当前的工作目录也不可以写，则这种情况是不可能出现的。）
Candidate directories include those referenced by the environment variables TMPDIR, TMP, TEMP, and USERPROFILE; the directory /tmp; and (on Windows boxes) the temp subdirectory of the Windows or System directory.
候选的目录包括TMPDIR TMP USERPROFILE环境变量所指向的目录；/tmp目录和Windows机器上的Windows或System目录下的tmep子目录。

    require 'tmpdir'
    Dir.tmpdir # => "/var/folders/44/j19_ml3n3dx7bwrb_qmbcjyc0000gn/T"
    ENV['TMPDIR'] = "/wibble"       # doesn't exist
    ENV['TMP'] = "/sbin"            # not writable
    ENV['TEMP'] = "/Users/dave/tmp" # just right
    Dir.tmpdir                      # => "/Users/dave/tmp"

The mktmpdir method can be used to create a new temporary directory:
mktmpdir方法可用于创建一个新的临时目录：

    require 'tmpdir'
    name = Dir.mktmpdir # .. process, process, process ..
    Dir.rmdir(name)

## Library Tracer  跟踪器

Trace Program Execution
追踪程序的执行

The tracer library uses `Object#set_trace_func` to trace all or part of a Ruby program’s execution.
tracer库使用`Object#set_trace_func`来追踪ruby程序所有部分的执行。
The traced lines show the thread number, file, line number, class, event, and source line.  
追踪得到的输出行显示线程号、文件、行号、类、事件和源代码。
The events shown are - for a change of line, < for a call, > for a return, C for a class definition, and E for the end of a definition.
输出的事件中，- 表示换行，>表示调用，<表示返回，C表示类定义，E表示定义结束

• You can trace an entire program by including the tracer library from the command line:
  你可以通过在命令行中包含tracer库来追踪整个程序。

    class Account
      def initialize(balance)
        @balance = balance
      end
      def debit(amt)
        if @balance < amt
          fail "Insufficient funds"
        else
          @balance -= amt
        end
      end
    end
    acct = Account.new(100)
    acct.debit(40)
    $ ruby -r tracer account.rb
    #0:prog.rb:15::-: acct = Account.new(100)
    #0:prog.rb:3:Account:>: def initialize(balance)
    #0:prog.rb:4:Account:-: @balance = balance
    #0:prog.rb:5:Account:<: end
    #0:prog.rb:16::-: acct.debit(40)
    #0:prog.rb:6:Account:>: def debit(amt)
    #0:prog.rb:7:Account:-: if @balance < amt
    #0:prog.rb:10:Account:-: @balance -= amt
    #0:prog.rb:12:Account:<: end

• You can also use tracer objects to trace just a portion of your code and use filters to select what to trace:
  你也可以使用tracer对象只追踪代码的某个部分，并使用过滤器来选择要追踪的内容。

    require 'tracer'
    tracer = Tracer.new
    tracer.add_filter lambda {|event, *rest| event == "line" }
    acct = Account.new(100)
    tracer.on { acct.debit(40) }
    # produces:
    # #0:prog.rb:18::-: tracer.on { acct.debit(40) }
    # #0:prog.rb:6:Account:-: if @balance < amt
    # #0:prog.rb:9:Account:-: @balance -= amt

## Library TSort  拓扑排序

Topological Sort
拓扑排序

Given a set of dependencies between nodes (where each node depends on zero or more other nodes and there are no cycles in the graph of dependencies), a topological sort will return a list of the nodes ordered such that no node follows a node that depends on it.  
给定各个节点之间的依赖关系（每个节点依赖0或多个其他节点，并且在依赖关系图中没有闭环），拓扑排序将返回一个排好序的节点列表，其三每个节点后续节点都合该节点没有依赖关系。
One use for this is scheduling tasks, where the order means that you complete the dependencies before you start any task that depends on them.  
它的一个用途是调度任务，其中的顺序意味着你在开始一个任务之前，必须先完成它所依赖的任务。
The make program uses a topological sort to order its execution.
make程序使用拓扑排序来规划它的执行步骤。

In the Ruby implementation, you mix in the TSort module and define two methods: `tsort_each_node`, which yields each node in turn, and `tsort_each_child`, which, given a node, yields each of that node’s dependencies.
要使用这个库，在ruby的实现里，你需要混入Tsort模块并定义两个方法：`tsort_each_node`，依次返回每个节点；`tsort_each_child`，在给出一个节点时，返回它所依赖的每个节点。

• Given the set of dependencies among the steps for making a piña colada, what is the optimum order for undertaking the steps?
  给出完成piña colada（2版译注：一种有椰子味的酒精饮料）步骤间的依赖关系，看看什么是制作它的最佳步骤？

    require 'tsort'
    class Tasks
      include TSort
      def initialize
        @dependencies = {}
      end
      def add_dependency(task, *relies_on)
        @dependencies[task] = relies_on
      end
      def tsort_each_node(&block)
        @dependencies.each_key(&block)
      end
      def tsort_each_child(node, &block)
        deps = @dependencies[node]
        deps.each(&block) if deps
      end
    end
    tasks = Tasks.new
    tasks.add_dependency(:add_rum,         :open_blender)
    tasks.add_dependency(:add_pc_mix,      :open_blender)
    tasks.add_dependency(:add_ice,         :open_blender)
    tasks.add_dependency(:close_blender,   :add_rum, :add_pc_mix, :add_ice)
    tasks.add_dependency(:blend_mix,       :close_blender)
    tasks.add_dependency(:pour_drink,      :blend_mix)
    tasks.add_dependency(:pour_drink,      :open_blender)
    puts tasks.tsort
    # produces:
    # open_blender  打开搅拌器
    # add_rum       加入郎姆酒
    # add_pc_mix    加入菠萝切片
    # add_ice       加入冰
    # close_blender 扣好搅拌器
    # blend_mix     搅拌混合
    # pour_drink    饮酒

## Library un  命令行接口

Command-Line Interface to FileUtils
FileUtils的命令行接口

Why un? 
为什么需要un？
When you invoke it from the command line with the -r option to Ruby, it spells -run.  
当你使用ruby的-r选项从命令行调用它时，它拼写为-run。
This pun gives a hint as to the intent of the library: it lets you run commands (in this case, a subset of the methods in FileUtils) from the command line.  
这个双关语提示你这个库的意图：它让你可以从命令行运行命令（这种情况下，是FileUtils的一个方法子集）。
In theory this gives you an operating system–independent set of file manipulation commands, possibly useful when writing portable Makefiles.
理论上，这为你提供了与操作系统无关的文件操作命令，当编写可移植的Makefile时特别有用。
See also: FileUtils (page 757)
另见前面2版678页4版757页的FileUtils。

• The available commands are as follows:
  可用的命令包括：

    $ ruby -run -e cp – ‹ options ›* source dest
    $ ruby -run -e ln – ‹ options ›* target linkname
    $ ruby -run -e mv – ‹ options ›* source dest
    $ ruby -run -e rm – ‹ options ›* file
    $ ruby -run -e mkdir – ‹ options ›* dirs
    $ ruby -run -e rmdir – ‹ options ›* dirs
    $ ruby -run -e install – ‹ options ›* source dest
    $ ruby -run -e chmod – ‹ options ›* octal_mode file
    $ ruby -run -e touch – ‹ options ›* file

Note the use of -- to tell the Ruby interpreter that options to the program follow.
注意，--的使用是告诉ruby解释器，选项是供程序使用的。
You can get a list of all available commands with this:
你可以使用下面的命令得到所有可用的命令列表：

    $ ruby -run -e help

For help on a particular command, append the command’s name:
要得到某个特定命令的帮助，在后面加上命令的名称：

    $ ruby -run -e help mkdir

## Library URI  统一资源标识符

RFC 2396 Uniform Resource Identifier (URI) Support
RFC 2396统一资源标识符支持

URI encapsulates the concept of a Uniform Resource Identifier (URI), a way of specifying some kind of (potentially networked) resource.  
UR代表统一资源标识符的概念，一种指定某种（可能是网络上的）资源的方式。
URIs are a superset of URLs: URLs (such as the addresses of web pages) allow specification of addresses by location, and URIs also allow specification by name.
URI是URL的超集：URL(例如Web页面地址)可以按位置指定地址，URI还可以按名字指定地址。

URIs consist of a scheme (such as http, mailto, ftp, and so on), followed by structured data identifying the resource within the scheme.
URI包括了一个模式（例如http mailto ftp等），其后的结构化数据只是这种模式下的资源。

URI has factory methods that take a URI string and return a subclass of URI specific to the scheme.  
URI有一个factory方法，接收一个URI字符串，并返回一个对应特定模式的子类。
The library explicitly supports the ftp, http, https, ldap, and mailto schemes; others will be treated as generic URIs.  
这个库显式地支持ftp http https ldap mailto模式；其他的则被视为普通的URI。
The module also has convenience methods to escape and unescape URIs.  
这个模块还有一些便捷的方法，对URI进行转义和反转义。
The class Net::HTTP accepts URI objects where a URL parameter is expected.
Net::HTTP类原本期望接受URL参数的地方，也可以接受URI对象。

See also: open-uri (page 781) Net::HTTP (page 773)
另见open-uri(前面2版707页4版781页）Net::HTTP（前面2版699页4版773页）

    require 'uri'
    uri = URI.parse("http://pragprog.com:1234/mypage.cgi?q=ruby")
    uri.class # => URI::HTTP
    uri.scheme # => "http"
    uri.host # => "pragprog.com"
    uri.port # => 1234
    uri.path # => "/mypage.cgi"
    uri.query # => "q=ruby"
    
    uri = URI.parse("mailto:ruby@pragprog.com?Subject=help&body=info")
    uri.class # => URI::MailTo
    uri.scheme # => "mailto"
    uri.to # => "ruby@pragprog.com"
    uri.headers # => [["Subject", "help"], ["body", "info"]]
    
    uri = URI.parse("ftp://dave@anon.com:/pub/ruby;type=i")
    uri.class # => URI::FTP
    uri.scheme # => "ftp"
    uri.host # => "anon.com"
    uri.port # => 21
    uri.path # => "pub/ruby"
    uri.typecode # => "i"

## Library WeakRef  弱引用

Support for Weak References
弱引用支持

In Ruby, objects are not eligible for garbage collection if references still exist to them.  
在ruby中，如果对象还有指向它的引用存在，是无法被垃圾回收的。
Normally, this is a Good Thing—it would be disconcerting to have an object simply evaporate while you were using it.  
通常，这是件好事--如果一个对象在你正使用它时莫名蒸发了，那真是太囧了。
However, sometimes you may need more flexibility.  
不过，有时候你希望多一些灵活性。
For example, you might want to implement an in-memory cache of commonly used file contents.  
比如，你想要实现一个位于内存的常见文件内容的缓存。
As you read more files, the cache grows.  
当你读取更多文件时，缓存随之增长。
At some point, you may run low on memory.  
过些时候，你的可用内存数量可能过低了。
The garbage collector will be invoked, but the objects in the cache are all referenced by the cache data structures and so will not be deleted.
垃圾回收器会被调用，但是缓存中的对象均被缓存数据结构本身所引用，因而无法被删除。

A weak reference behaves like any normal object reference with one important exception— the referenced object may be garbage collected, even while references to it exist.  
弱引用的行为和普通的对象引用基本相同，唯一重要的例外是--即使当引用存在时，被引用的对象依然可以被垃圾回收。
In the cache example, if the cached files were accessed using weak references, once memory runs low, they will be garbage collected, freeing memory for the rest of the application.
以缓存为例，如果被缓存的文件是用弱引用访问的，当可用内存过少时，它们会被垃圾回收掉，释放内存让应用程序的其他部分使用。

• Weak references introduce a slight complexity.  
  弱引用引入了少许复杂性。
Because the object referenced can be deleted by garbage collection at any time, code that accesses these objects must take care to ensure that the references are valid.  
因为被引用的对象可以在任何时候被垃圾收集器删除掉，访问这些对象的代码必须小心确保引用是有效的。
Two techniques can be used.  
可以使用两种计数。
First, the code can reference the objects normally.  
第一，代码可以像平常一样引用这些对象。
Any attempt to reference an object that has been garbage collected will raise a WeakRef::RefError exception.
任何尝试引用已经被垃圾回收的对象，都会抛出WweakRef::RefError异常。

    require 'weakref'
    # Generate lots of small strings. Hopefully the early ones will have
    # been garbage collected...
    # 产生很多小字符串。较早产生的可能已经被回收掉了。
    refs = (1..10000).map {|i| WeakRef.new("#{i}") }
    puts "Last element is #{refs.last}"
    puts "First element is #{refs.first}"
    # produces:
    # Last element is 10000
    # prog.rb:6:in `<main>': Invalid Reference - probably recycled (WeakRef::RefError)

• Alternatively, use `the WeakRef#weakref_alive`? method to check that a reference is valid before using it.  
另一种方法是，使用`the WeakRef#weakref_alive`方法来检查引用在使用之前是否有效。
Garbage collection must be disabled during the test and subsequent reference to the object.  
当测试和后续引用这个对象时，垃圾回收必须被禁止。
In a single-threaded program, you could use something like this:
在一个单线程的程序中，你可以这样使用它：

    ref = WeakRef.new(some_object)
    # .. some time later
    gc_was_disabled = GC.disable
    if ref.weakref_alive?
      # do stuff with 'ref'
    end
    GC.enable unless gc_was_disabled

## Library WEBrick    web服务器

Web Server Toolkit
Web服务器工具包

WEBrick is a pure-Ruby framework for implementing HTTP-based servers.  
WEBrick是一个由纯ruby编写的用来实现基于HTTP服务器的框架。
The Ruby standard library includes WEBrick services that implement a standard web server (serving files and directory listings) and servlets supporting CGI, erb, file download, and the mounting of Ruby lambdas.
标准库包括了WEBrick服务来实现一个标准的Web服务器（支持列出文件和目录的服务），以及若干servlet来支持CGI、erb、文件下载、挂载ruby的lambda函数。

The Web programming chapter has more examples of WEBrick on page 286.
前面2版247页4版286页有更多的WEBrick示例。

• The following code mounts two Ruby procs on a web server.
  下面的代码在Web服务器上挂载两个ruby的proc对象。
Requests to http://localhost:2000/hello run one proc, and the other proc is invoked by requests to http://localhost:2000/bye.
请求URI http://localhost:2000/hello则运行第一个proc，请求http://localhost:2000/bye则运行另一个。

    #!/usr/bin/ruby
    require 'webrick'
    include WEBrick
    hello_proc = lambda do |req, resp|
      resp['Content-Type'] = "text/html"
      resp.body = %{
                    <html><body>
                      Hello. You're calling from a #{req['User-Agent']}
                      <p>
                      I see parameters: #{req.query.keys.join(', ')}
                    </body></html>
      }
    end
    bye_proc = lambda do |req, resp|
      resp['Content-Type'] = "text/html"
      resp.body = %{
        <html><body>
        <h3>Goodbye!</h3>
        </body></html>
      }
    end
    
    hello =  HTTPServlet::ProcHandler.new(hello_proc)
    bye   =  HTTPServlet::ProcHandler.new(bye_proc)
    
    s = HTTPServer.new(:Port => 2000)
    s.mount("/hello", hello)
    s.mount("/bye", bye)
    trap("INT"){ s.shutdown }
    s.start

## Library WIN32OLE  win32对象链接嵌入

Windows Automation
Windows自动化

Only if: Windows
只有在Windows系统上才可用

This is an interface to Windows automation, allowing Ruby code to interact with Windows applications.  
访问Windows自动化的接口，可以让ruby与Windows应用进行交互。
The Ruby interface to Windows is discussed in more detail in Chapter 21, Ruby and Microsoft Windows, on page 289.
ruby访问Windows的接口已经在前面2版267页20章4版289页的21章详细讨论过了。

• Opens Internet Explorer and asks it to display our home page:
  打开IE浏览器，要求它显示我们的主页：

    require 'win32ole'
    ie = WIN32OLE.new('InternetExplorer.Application')
    ie.visible = true
    ie.navigate("http://www.pragprog.com")

• Creates a new chart in Microsoft Excel and then rotates it.  
  在微软的Excel表格中，创建一个新的图表，然后旋转它。
  This code is one of the samples that comes with the library.
  这个代码是伴随库的其中一个示例。

    require 'win32ole'
    # -4100 is the value for the Excel constant xl3DColumn.
    ChartTypeVal = -4100;
    # Creates OLE object to Excel
    #excel = WIN32OLE.new("excel.application.5")
    excel = WIN32OLE.new("excel.application")
    # Create and rotate the chart
    excel.visible = TRUE;
    excel.Workbooks.Add();
    excel.Range("a1").value = 3;
    excel.Range("a2").value = 2;
    excel.Range("a3").value = 1;
    excel.Range("a1:a3").Select();
    excelchart = excel.Charts.Add();
    excelchart.type = ChartTypeVal;
    i = 30
    i.step(180, 10) do |rot|
    # excelchart['Rotation'] = rot;
    excelchart.rotation=rot;
    end
    # Done, bye
    excel.ActiveWorkbook.Close(0);
    excel.Quit();

## Library XMLRPC

Remote Procedure Calls using XML-RPC
使用XML-RPC进行远程过程调用

XMLRPC allows clients to invoke methods on networked servers using the XML-RPC protocol.  
XMLRPC库可以让客户端使用XML-RPC协议，调用网络另一端服务器上的方法。
Communications take place over HTTP.  
通信使用的是HTTP协议。
The server may run in the context of a web server, in which case ports 80 or 443 (for SSL) will typically be used.  
服务器可能运行在一个Web服务器的环境中，这种情况通常使用80或者443（适用于SSL）端口。
The server may also be run stand-alone.  
服务器也可能是单独运行的。
The Ruby XML-RPC server implementation supports operation as a CGI script, as a `mod_ruby` script, as a WEBrick handler, and as a stand-alone server.  
ruby的XML-RPC服务器实现支持一下运作方式：作为CGI脚本、`mod_ruby`脚本、WEBrick的处理方法、单独的服务器。
Basic authentication is supported, and clients can communicate with servers via proxies.  
支持基本的认证，并且客户端可以通过代理和服务器通信。
Servers may throw FaultException errors—these generate the corresponding exception on the client (or optionally may be flagged as a status return to the call).
服务器可能会抛出FaultException错误--这些错误会在客户端产生相应的异常（或者作为调用返回的状态标志）。

See also: dRuby (page 748) WEBrick (page 824)
另见：dRuby（前面2版670页4版748页）WEBrick（前面2版754页4版824页）

• The following simple server accepts a temperature in Celsius and converts it to Fahrenheit.  
下面这个简单的服务器，接受摄氏度并将它转换为华氏度。
It runs within the context of the WEBrick web server.
它运行WEBrick服务器的环境中：

    # sl_xmlrpc/xmlserver.rb
    require 'webrick'
    require 'xmlrpc/server'
    xml_servlet = XMLRPC::WEBrickServlet.new
    xml_servlet.add_handler("convert_celcius") do |celcius|
      celcius*1.8 + 32
    end
    xml_servlet.add_multicall # Add support for multicall
    server = WEBrick::HTTPServer.new(:Port => 2000)
    server.mount("/RPC2", xml_servlet)
    trap("INT"){ server.shutdown }
    server.start

• This client makes calls to the temperature conversion server.  
  这个客户端可以调用温度转换服务器。
Note that in the output we show both the server’s logging and the client program’s output.
注意我们在结果中显示了服务器的日志以及客户程序的输出。

    require 'xmlrpc/client'
    server = XMLRPC::Client.new("localhost", "/RPC2", 2000)
    puts server.call("convert_celcius", 0)
    puts server.call("convert_celcius", 100)
    puts server.multicall(['convert_celcius', -10], ['convert_celcius', 200])
    # produces:
    # [2013-05-27 12:33:44] INFO WEBrick 1.3.1
    # [2013-05-27 12:33:44] INFO ruby 2.0.0 (2013-02-24) [x86_64-darwin12.2.0]
    # [2013-05-27 12:33:44] INFO WEBrick::HTTPServer#start: pid=24895 port=2000
    # localhost - - [27/May/2013:12:33:45 CDT] "POST /RPC2 HTTP/1.1" 200 124
    # -> /RPC2    
    # localhost - - [27/May/2013:12:33:45 CDT] "POST /RPC2 HTTP/1.1" 200 125
    # -> /RPC2    
    # localhost - - [27/May/2013:12:33:45 CDT] "POST /RPC2 HTTP/1.1" 200 290
    # -> /RPC2
    # 32.0
    # 212.0
    # 14.0
    # 392.0

## Library YAML

Object Serialization/Deserialization
对象序列化和反序列化

The YAML library (also described in the tutorial on page 405) serializes and deserializes Ruby object trees to and from an external, readable, plain-text format.  
YAML库（在前面2版416页4版405页的教程也有描述）可以将ruby对象树序列化为一个外部的、可读的、纯文本格式文件，或从这个文件进行反序列化。
YAML can be used as a portable object marshaling scheme, allowing objects to be passed in plain text between separate Ruby processes.  
YAML可以用作一种可移植的对象列集方案，可以让对象以纯文本的方式在两个隔离的ruby进程间传递。
In some cases, objects may also be exchanged between Ruby programs and programs in other languages that also have YAML support.  
某些情况下，对象也可以在ruby程序和其他语言编写的、同样支持YAML的程序之间进行交换。
⇡New in 2.0
While Ruby 1.9.2 can use libyaml if it is available, Ruby 2.0 makes it a requirement, and bundles it with the interpreter.
如果可用，ruby 1.9.2使用libyaml。ruby 2.0让它成为必备，并将它和解释器绑定在一起。
See also: json (page 766)
另见前面766页的json。

• YAML can be used to store an object tree in a flat file:
  YAML可用来将对象树保存在一个纯文本文件中。 

    require 'yaml'
    tree = { name: 'ruby',
             uses: [ 'scripting', 'web', 'testing', 'etc' ]
    }
    File.open("tree.yml", "w") {|f| YAML.dump(tree, f)}

• Once stored, it can be read by another program:
  保存之后，它可以被另一个程序读取：

    require 'yaml'
    tree = YAML.load_file("tree.yml")
    tree[:uses][1] # => "web"

• The YAML format is also a convenient way to store configuration information for programs.  
  YAML格式也是为程序保存配置信息的一种方便的方式。
Because it is readable, it can be maintained by hand using a normal editor and then read as objects by programs.  
因为它是可读的，可以使用常见的编辑器来维护它，并且让程序以对象的形式读取出来。
For example, a configuration file may contain the following:
例如，一个配置文件可能包括：

    # sl_yaml/config.yml
    --
    username: dave
    prefs:
      background: dark
      foreground: cyan
      timeout: 30

We can use this in a program:
我们可以在程序中使用它将：

    require 'yaml'
    config = YAML.load_file("code/sl_yaml/config.yml")
    config["username"] # => "dave"
    config["prefs"]["timeout"] * 10 # => 300

## Library Zlib  读取压缩的文件

Read and Write Compressed Files
读取压缩的文件

Only if: zlib library available
只有zlib库可用的系统才适用

The Zlib module is home to a number of classes for compressing and decompressing streams and for working with gzip-format compressed files.  
Zlib模块是处理压缩和解压流的ruby类，处理gzip格式压缩文件的ruby类的汇总。
They also calculate zip checksums.
它们还可以计算zip的校验和。

• Compresses /etc/passwd as a gzip file and then reads the result back:
  将/etc/passwd压缩为一个gzip文件，并将结果读取回来。

    require 'zlib'
    # These methods can take a filename
    Zlib::GzipWriter.open("passwd.gz") do |gz|
      gz.write(File.read("/etc/passwd"))
    end
    system("ls -l /etc/passwd passwd.gz")
    puts
    # or a stream
    File.open("passwd.gz") do |f|
      gzip = Zlib::GzipReader.new(f)
      data = gzip.read.split(/\n/)
      puts data[15,3]
    end
    # produces:
    # -rw-r--r-- 1 root wheel 5086 Jul 20 2011 /etc/passwd 
    # -rw-rw-r-- 1 dave staff 1621 May 27 12:33 passwd.gz
    # _installassistant:*:25:25:Install Assistant:/var/empty:/usr/bin/false
    # _lp:*:26:26:Printing Services:/var/spool/cups:/usr/bin/false
    # _postfix:*:27:27:Postfix Mail Server:/var/spool/postfix:/usr/bin/false

• Compresses data sent between two processes:
  压缩在两个进程间发送的数据：

    require 'zlib'
    rd, wr = IO.pipe
    if fork
      rd.close
      zipper = Zlib::Deflate.new
      zipper << "This is a string "
      data = zipper.deflate("to compress", Zlib::FINISH)
      wr.write(data)
      wr.close
      Process.wait
    else
      wr.close
      text = Zlib.inflate(rd.read)
      puts "We got: #{text}"
    end
    # produces:
    # We got: This is a string to compress


# 第5部分 附录
# A1 Support 支持
## ruby 社区
One of the major features of open source projects is the technical support.  
开放源码项目的一大特色之一是技术支持。
Articles in the media often criticize open source efforts for not having the same tech support that a commercial product has.  
各大媒体上的文章常常批评开放源码的努力，认为开源没有提供像商业产品那样的技术支持。
And boy is that a good thing! 
不过伙计，这是个好事情！
Instead of dialing up some overworked and understaffed help desk and being treated to music for an hour or so without ever getting the answer you need, we have a better solution: the Ruby community.  
与其打电话给那些过劳且人手不足的服务部门，并享受一小时的等候音乐，甚至这样都无法得到你要的解答，我们有更好的方案：ruby社区。
The author of Ruby, the authors of this book, and many other Ruby users are willing and able to lend you a hand, should you need it.
ruby的作者，本书的作者，以及许多ruby用户，都愿意并且能够在你需要的时候帮你一把。

The syntax of Ruby remains fairly stable, but as with all evolving software, new features are added every now and again.  
ruby的语法保持着相当的稳定，但随着软件的进化，新的特性不断加入。
As a result, both printed books and the online documentation can fall behind.  
结果印刷的书籍和在线文档都可能落在后面。
All software has bugs, and Ruby is no exception.  
所有的软件都有bug，ruby也不例外。
There aren’t many, but they do crop up.
虽然没有很多，但是它们的确有时突然出现。

If you experience a problem with Ruby, feel free to ask in the mailing lists.  
如果你遇到ruby的问题，尽管在邮件列表或新闻组中发问。
Generally you’ll get timely answers from knowledgeable folks.  
通常，你可以及时地从博学的人们那里得到答案。
However, as with all large communities, you may also find people with a less-than-perfect understanding of Ruby responding.  
不过，正如所有的大社区，你也可找到与你相似问题的解答。
As with all things on the Internet, use your judgment.
正如所有因特网上的东西一样，使用你的判断。

Before posting, do the right thing and search the Web for similar questions—by now most common questions have already been answered in the mailing lists or on someone’s blog.
在你发帖之前，可以查找相似的问题--那时可能大部分的普通问题已经在邮件列表或某人的博客上回答了。

But if you can’t find the answer you need, ask, and a correct answer will usually show up with remarkable speed and precision.
但如果你找不到你需要的答案，那就发问，正确的答案通常会很快出现，而且正确性很高。

## A1.1 Web Sites  网站
Because the Web changes too fast, we’ve kept this list short.  
因为web的改变太快速，我发尽量让这个列表简短。
Visit one of the sites here, and you’ll find a wealth of links to other online Ruby resources.
访问下面列出的某个链接，你会发现许多其他有价值的ruby在线资源。

The official Ruby home page is http://www.ruby-lang.org.
ruby的官方主页是http://www.ruby-lang.org。

You’ll find many open source Ruby projects on Github (http://github.com) and RubyForge (http://www.rubyforge.org). 
你可以在RubyForge上找到许多ruby的类库和应用。

http://rubygems.org is the official RubyGems repository. [1]
http://rubygems.org 是官方rubygems仓库。
(GitHub used to be another source of RubyGems—this is no longer the case.)
（GitHub过去是另一个RubyGems仓库--现在不是了）。
[1].  In March 2010, RubyGems.org, GemCutter.org, and RubyForge.org became a single, unified server of gems.
在2010年3月，RubyGems.org, GemCutter.org, 和RubyForge.org合并，统一gems服务器。

http://www.ruby-doc.org is a portal to various sources of Ruby documentation.  
http://www.ruby-doc.org是各种ruby文档源的入口。
Much of it comes from previous editions of this book.
很多文档来自这本书之前的版本。

While you’re surfing, drop in on http://www.pragprog.com and see what we’re up to.
 当你遇到麻烦时，顺便访问一下http://www.pragprog.com，看看我们能帮你什么。

## A1.2 Usenet Newsgroup Usenet新闻组
Ruby has its own newsgroup, comp.lang.ruby.  
ruby有自己的新闻组：comp.lang.ruby。
Traffic on this group is archived and mirrored to the ruby-talk mailing list.  
在这个新闻组上的讨论，被归档并镜像到ruby-talk邮件列表。
It can be read via Google Groups.
可以通过Google Groups阅读。

## A1.3 Mailing Lists  邮件列表
You’ll find many mailing lists talking about Ruby. 
你可以发现许多关于ruby的邮件列表。
The first three here are in English, and the remainder are mostly Japanese but with some English-language posts.
下面列出的前三个是英文的，其余大部分是日文的，但其中也有一些英文帖子。

ruby-talk@ruby-lang.org   English-language discussion of Ruby (mirrored to comp.lang.ruby)
                          英文讨论（comp.lang.ruby的镜像）
ruby-doc@ruby-lang.org    Documentation standards and tools
                          标准和工具的文档
ruby-core@ruby-lang.org   English discussion of core implementation topics
                          核心实现的讨论
ruby-list@ruby-lang.org   Japanese language discussion of Ruby
                          日文讨论
ruby-dev@ruby-lang.org    List for Ruby developers
                          开发者列表
ruby-ext@ruby-lang.org    List for people writing extensions for or with Ruby
                          扩展的开发者列表
ruby-math@ruby-lang.org   Ruby in mathematics
                          用于计算的ruby讨论

See the “Mailing Lists” topic under http://www.ruby-lang.org/ for details on joining a list.
关于如何加入邮件列表，参见http://www.ruby-lang.org/下面的“Mailing Lists”主题。
The mailing lists are archived and can be searched here: http://blade.nagaokaut.ac.jp/ruby/rubytalk/index.shtml or here: http://www.ruby-talk.org
邮件列表被归档到下面的地址，并可以进行搜索：http://blade.nagaokaut.ac.jp/ruby/rubytalk/index.shtml，或使用：http://www.ruby-talk.org。

## A1.4 Bug Reporting 报告错误  1.9
If you think you’ve spotted a bug in Ruby, you may want to browse the Ruby Issue Tracking system at http://redmine.ruby-lang.org/.  
如果你觉得你发现了ruby的bug，你可能想浏览ruby的事件跟踪系统，在http://redmine.ruby-lang.org/。
You may also want to check to see whether a new version of Ruby is available—perhaps the bug you’ve found has already been fixed.
你可能也想检查是否有ruby的新版本--可能你找到的bug已经被修复了。

Before submitting a bug, it might be a good idea to post a question about it to the ruby-talk mailing list.  
在提交一个bug之前，将它在ruby-talk邮件列表中贴个问题，会更好。
Often, one person’s bug is another person’s language feature. 
经常，一个人认为是bug，另一个人会觉得是语言的特性。 
Also, Ruby can be complicated, and sometimes its behavior can be subtle.
ruby也可以很复杂，有时它的表现很微妙。

Once you’ve decided you have a genuine bug, submit a bug report via the Ruby Issue Tracking site mentioned previosuly.  
你一旦确信找到了真正的bug，可通过前面提到的ruby的事件追踪网站提交一个bug报告。

When reporting a suspected bug, it’s a good idea to include the output of running ruby -v along with any problematic source code.  
报告一个可疑的bug时，要包含ruby带-v运行时的输出，和出问题的源代码。

People will also need to know the operating system you’re running. 
人们也需要直到你运行的操作系统。 

If you compiled your own version of Ruby, it may be a good idea to attach your rbconfig.rb file as well.
如果你编译自己的ruby版本，应该贴上你的rbconfig.rb文件。

If you have a problem using irb, be aware of its limitations (see the reference section on page 253.  
如果你有使用irb的问题，一定要知道irb的局限（详见前面253页的相关章节）。
See what happens using just Ruby itself.
再看看用ruby自身会发生什么。


# A2 Bibliography  参考书目
[Fri97]
Jeffrey E. F. Friedl. Mastering Regular Expressions. O’Reilly & Associates, Inc., Sebastopol, CA, 1997.
《精通正则表达式》

[GHJV95]
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, Reading, MA, 1995.
《设计模式》

[Mey97]

Bertrand Meyer. Object-Oriented Software Construction. Prentice Hall, Englewood Cliffs,
NJ, Second, 1997.
《面向对象的软件构建》

# 　附录A　Socket库
## 概述
The socket and network libraries are such important parts of integrating Ruby applications with the Internet and other communications-based environments.  
socket和network库对于ruby应用集成到网络和基于通信的环境是如此重要的部分。
However, the chances are pretty good that you’ll never need to code down at this level—if you’re writing a web applications, tools such as Rack abstract the communications layers away.  
不过，运气相当好，你将不用在这个级别上写代码--如果你正在写web应用，像Rack这样的工具抽象了通信层。
If you want to write a socket-based server, the GServer library will keep you away from the messy details.  
如果你想写一个基于套接字的服务器，GServer库将确保你远离凌乱的细节。
So this documentation is primarily of interested to those hardy, dedicated folks who write the frameworks and libraries that the rest of us use.
所以这个文档的首要兴趣对象是那些努力的专业人员，他要写框架和库给我们使用。

The socket classes form a hierarchy based on class IO.
套接字类基于IO在形成一个层次结构:

    IO
      BasicSocket
        IPSocket
          TCPSocket
            TCPServer
          UDPSocket
        Socket
        UNIXSocket
          UNIXServer

Because the socket calls are implemented in a library, you’ll need to remember to add the following line to your code:
因为套接字调用被实现在库里，你将需要记住在你的代码里添加下面这一行：

    require 'socket'

## Addrinfo < Data 
### 概述
The socket classes used to manipulate addresses using something called a struct sockaddr, which is effectively an opaque binary string.  
套接字类常被用于操作地址，使用一个叫做struct sockaddr的东西，它实际上是一个迟钝二进制字符串。
As of Ruby 1.9.2, the library now uses Addrinfo objects to represent addresses.  
到了ruby 1.9.2，这个库现在使用Addrinfo对象来表示地址。
For now, both the opaque string and an Addrinfo object are accepted whereever an address is expected.
现在，不管哪里期待地址，都可以接受晦涩的字符串和Addrinfo对象。

Socket-based programming spans a range of communications protocols, addressing schemes, and transport mechanisms.  
基于套接字的编程跨越通信协议、寻址方案和传送机制的区间。
The interested reader should have a look at Unix Network Programming, Volume 1: Networking APIs: Sockets and Xti [Ste98] by the late W. Richard Stevens for the definitive description of how this addressing works.
感兴趣的读者应该看看已故的W. Richard Stevens写的《Unix网络编程第一卷网络API：套接字和Xti》，里面有进行寻址的权威叙述 。

The Addrinfo class captures the protocol family (also called the communications domain), the socket type, the protocol, and the socket address.  
Addrinfo类捕捉协议族（也称为通信域）、套接字类型、协议和套接字地址。
Between them, these four fields uniquely identify a socket endpoint.
在它们之间，有四个字段明确地区别一个套接字的端点。

The socket address (often called a sockaddr) has its own internal structure.  
套接字地址（通常叫做sockaddr）有自己的内部结构。
Just to make things interesting, that structure varies depending on the protocol family of the socket.  
有趣的是，那个结构会随着套接字的协议族而变化。
A `PF_INET` socket, representing a TCP or UDP protocol, will need an IP address and a port, whereas a `PF_LOCAL` socket (sometimes called `PF_UNIX`) needs a path to a local file.
一个`PF_INET`套接字代表一个TCP或UDP协议，需要一个IP地址和端口，而一个`PF_LOCAL`套接字需要一个路径和本地文件。

You construct a sockaddr as either an array or as a binary string. 
你可构建一个sockaddr，是一个数组或是一个二进制字符串。
The array form is most commonly used when people create the sockaddr, and the binary form when it is returned by API calls such as `Socket#sockaddr_in`.
当人们创建sockaddr时，数组形式是最常用的；当它被诸如`Socket#sockaddr_in`的API调用所返回时，则是二进制形式。

For `PF_INET` and `PF_INET6` socket, the sockaddr array should contain
对于`PF_INET`和`PF_INET6`套接字，sockaddr数组应该包含：

    [ family, port, name, address ]

family: The protocol family, expressed as an integer (`Socket::PF_INET`) or a string with or without the leading `PF_` (`"PF_INET", "INET", "INET6"`).
        协议族，表示为一个整数（`Socket::PF_INET`）或一个带有/不带`PF_`前缀的字符串（`"PF_INET", "INET", "INET6"`）。
port: is the numeric port number.
      是一个数字的端口数。
name: Is not used in address manipulation—it is used as a documentation field when creating addr.inspect.
      不能用于地址操作--它被用作文档字段，当创建addr.inspect时。
address: The IP address as a string (a dotted quad for INET and a colon separated set of hex digits for INET6).
         IP地址是一个字符串（INET是点分四组，INET6是冒号分割的十六进制数字集）

The address array for Unix domain sockets looks like 
Unix域套接字的地址数组看起来像：

    [ family, path ]

The family is `Socket::PF_LOCAL` (or "`PF_LOCAL`" or "LOCAL") and the path is a locat filesystem path.
family是`Socket::PF_LOCAL`（或"`PF_LOCAL`"或"LOCAL"），path是本地文件系统路径。

### Class methods  类方法
#### foreach  遍历

    Addrinfo.foreach(nodename, service) { | addr | . . . } → [ addr... ]
    Addrinfo.foreach(nodename, service, family) { | addr | . . . } → [ addr... ]
    Addrinfo.foreach(nodename, service, family, socktype) { | addr | . . . } → [ addr... ]
    Addrinfo.foreach(nodename, service, family, socktype, protocol) { | addr | . . . } → [ addr... ]
    Addrinfo.foreach(nodename, service, family, socktype, protocol, flags) { | addr | . . . } → [ addr... ]

Calls Addrinfo#getsockinfo with the given parameters, then passes each of the returned addr objects to the block.  
带指定参数调用Addrinfo#getsockinfo，并将每个返回的addr对象传入block中。
Returns the array returned by getaddrinfo.
返回getaddrinfo所返回的数组。

#### getaddrinfo  取得地址信息

    Addrinfo.getaddrinfo(nodename, service) → [ addr... ]
    Addrinfo.getaddrinfo(nodename, service, family) → [ addr... ]
    Addrinfo.getaddrinfo(nodename, service, family, socktype) → [ addr... ]
    Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol) → [ addr... ]
    Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol, flags) → [ addr... ]

Returns all possible Address objects for the given nodename and service.  
返回给定的nodename和service所有可能的地址对象。
The result set may be constrained to addresses that have a particular family, socket type, protocol.  
结果的集合可能被强制为地址，有一个特定的族、套接字类型、协议。
The flags may be a bitwise OR of the `Socket::AI_xxx` values.
flag可能是一个`Socket::AI_xxx`值的按位OR。

    require 'socket'
    puts Addrinfo.getaddrinfo('localhost', 80).map(&:inspect)
    # produces:
    # #<Addrinfo: [::1]:80 UDP (localhost)>
    # #<Addrinfo: [::1]:80 TCP (localhost)>
    # #<Addrinfo: [fe80::1%lo0]:80 UDP (localhost)>
    # #<Addrinfo: [fe80::1%lo0]:80 TCP (localhost)>
    # #<Addrinfo: 127.0.0.1:80 UDP (localhost)>
    # #<Addrinfo: 127.0.0.1:80 TCP (localhost)>

#### ip  地址

    Addrinfo.ip( host ) → addr

Returns an Addrinfo with the address portion only filled in.  
返回一个Addrinfo，只有地址部分。
The given host is looked up, and the address is extracted from the first sockaddr returned.  
给定的host会被查找，地址从第一个返回的sockaddr解压出来。
The protocol, socket type, and port fields of the address are left as zero.
地址的协议、套接字类型和端口字段被设为0.

    require 'socket'
    Addrinfo.ip("127.0.0.1") # => #<Addrinfo: 127.0.0.1>
    Addrinfo.ip("localhost") # => #<Addrinfo: ::1 (localhost)>

#### new  新建

    Addrinfo.new( sockaddr , family , socktype , protocol → addr

Creates an Addrinfo object for the given Unix or INET6 sockaddr.  
为指定个Unix或INET6 sockaddr创建一个Addrinfo对象。
The format of sockaddr is described at the start of this section.  
sockaddr的格式描述见本章开头。
Normally the family, socktype, and protocol can be inferred from the sockaddr—if specified they override the sockaddr information.  
通常族、套接字类型和协议可从sockaddr推断出来--如果规定它们改写sockaddr信息。
The family and socktype can be specified as integers (using the constants defined in class Socket) or as symbols or strings.  
族和套接字类型可被指定为整数（使用Socket类中定义的常数），或符号、字符串。
The protocol can only be specified as an integer.
协议可被指定为一个整数。

    require 'socket'
    p Addrinfo.new(["LOCAL", "/tmp/control_socket"])
    p Addrinfo.new(["INET", 80, "dave.local", "127.0.0.1"])
    # produces:
    # #<Addrinfo: /tmp/control_socket SOCK_STREAM>
    # #<Addrinfo: 127.0.0.1:80 (dave.local)>

#### tcp  传输控制协议

    Addrinfo.tcp( host, port) → addr

Returns a TCP Addrinfo object for the given host and port.
为给定的host和port返回一个TCP Addrinfo对象。

    require 'socket'
    Addrinfo.tcp('localhost', 80) # => #<Addrinfo: [::1]:80 TCP (localhost)>
    Addrinfo.tcp('localhost', 'www') # => #<Addrinfo: [::1]:80 TCP (localhost:www)>
    Addrinfo.tcp('127.0.0.1', 'www') # => #<Addrinfo: 127.0.0.1:80 TCP (:www)>

#### udp  用户数据报协议

    Addrinfo.udp( host, port) → addr

Returns a UDP Addrinfo object for the given host and port.
为给定的host和port返回一个UDP Addrinfo对象。

    require 'socket'
    Addrinfo.udp('localhost', 'ntp') # => #<Addrinfo: [::1]:123 UDP (localhost:ntp)>

#### unix  

    Addrinfo.unix( path, socktype="SOCK_STREAM") → addr

Returns a `PF_LOCAL` Addrinfo object for the given path.
为给定的路径返回一个`PF_LOCAL` Addrinfo对象。

    require 'socket'
    Addrinfo.unix('/tmp/mysock')              # =>  #<Addrinfo: /tmp/mysock
                                              # ..  SOCK_STREAM>
    Addrinfo.unix('/tmp/mysock', :SOCK_DGRAM) # =>  #<Addrinfo: /tmp/mysock
                                              # ..  SOCK_DGRAM>


### Instance methods  实例方法
#### Predicates  断言

    addr.ip? → true or false
    addr.ipv4? → true or false
    addr.ipv4_loopback? → true or false
    addr.ipv4_multicast? → true or false
    addr.ipv4_private? → true or false
    addr.ipv6? → true or false
    addr.ipv6_linklocal? → true or false
    addr.ipv6_loopback? → true or false
    addr.ipv6_mc_global? → true or false
    addr.ipv6_mc_linklocal? → true or false
    addr.ipv6_mc_nodelocal? → true or false
    addr.ipv6_mc_orglocal? → true or false
    addr.ipv6_mc_sitelocal? → true or false
    addr.ipv6_multicast? → true or false
    addr.ipv6_sitelocal? → true or false
    addr.ipv6_unspecified? → true or false
    addr.ipv6_v4compat? → true or false
    addr.ipv6_v4mapped? → true or false
    addr.unix? → true or false

Returns a boolean depending on the value of the given property.
根据给定属性的值返回一个布尔值。

#### Properties  属性

    addr.afamily → integer
    addr.ip_port → integer
    addr.pfamily → integer
    addr.protocol → integer
    addr.socktype → integer
    addr.unix_path → string

Returns the given property of addr.
返回addr的给定属性。

#### bind 绑定

    addr.bind → sock
    addr.bind { | sock | . . . } → obj

Binds a socket to the address and protocol given by addr.  
将一个套接字绑定到addr指定的地址和协议中。
With no block returns the socket object.  
如果没有带block则返回套接字对象。
With a block, invokes it with the socket, closes the socket when the block returns, and returns the value of the block.
如果带了block，则带套接字调用它，block返回时关闭套接字，并返回block的值。

#### canonname  

    addr.canonname → string or nil

If the address was created with the `Socket::AI_CANONNAME` option, return the actual host name, resolving any CNAMEs.
如果带`Socket::AI_CANONNAME`选项新建地址，返回实际的主机名，解析任何CNAME(别名记录)。

    require 'socket'
    addr = Addrinfo.getaddrinfo("pragprog.com", 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)
    addr.first.canonname # => "pragprog.com"
    addr = Addrinfo.getaddrinfo("wiki.pragprog.com", 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)
    addr.first.canonname # => "pragprog.com"
    addr = Addrinfo.getaddrinfo("wiki.pragprog.com", 80, :INET, :STREAM, nil)
    addr.first.canonname # => nil

#### connect  连接

    addr.connect → sock
    addr.connect { | sock | . . . } → obj

Creates a socket connection to the address and protocol given by addr.  
创建一个连接到addr给定的地址和协议的套接字。
With no block returns the socket object.  
没有block，返回一个套接字对象。
With a block, invokes it with the socket, closes the socket when the block returns, and returns the value of the block.
如果带了block，则带套接字调用它，block返回时关闭套接字，并返回block的值。

    require 'socket'
    addr = Addrinfo.tcp('localhost', 80)
    addr.connect do |socket|
      socket.puts "GET / HTTP/1.0\r\n\r\n"
      3.times { puts socket.gets }
    end
    # produces:
    # HTTP/1.1 200 OK
    # Date: Thu, 11 Nov 2010 19:01:27 GMT
    # Server: Apache/2.2.14 (Unix) mod_ssl/2.2.14 OpenSSL/0.9.8l DAV/2

#### connect_from  从某处连接

    addr.connect_from( local_addr ∗ ) → sock
    addr.connect_from( local_addr ∗ ) { | sock | . . . } → obj

Works like Addrinfo#connect, but binds the local end of the connection to any interface or port given as parameters.  
很像Addrinfo#connect，但将连接的本地端绑定到参数给定的任何接口或端口。
The parameters can be an Addrinfo object, the same parameters taken by Addrinfo.getaddrinfo if addr is an `PF_INET` object, or a path if addr is a `PF_LOCAL` object.
参数可以是一个Addrinfo对象， 如果addr是一个`PF_INET`对象，则同样的参数被Addrinfo.getaddrinfo所处理，如果addr是一个`PF_LOCAL`对象，则是一个路径。

#### connect_to  连接到某处

    addr.connect_to( remote_addr ∗ ) → sock
    addr.connect_to( remote_addr ∗ ) { | sock | . . . } → obj

Works like Addrinfo#connect_from, but addr specifies the local end and the parameters specify the remote end of the connection.
像Addrinfo#connect_from，但addr指定了本地端，参数指定了连接的远程端。

#### family_addrinfo  族

    addr.family_addrinfo( args ∗ ) → new_addr

Constructs a new Addrinfo with the same protocol family as addr but with a different address.
用和addr同样的协议，但不同的地址，构造一个新的Addrinfo。

    require 'socket'
    addr = Addrinfo.tcp('127.0.0.1', 80)
    addr.family_addrinfo('google.com', 'ftp') # => #<Addrinfo: 74.125.45.99:21 TCP
                                              # .. (google.com:ftp)>

#### getnameinfo  取得名称信息

    addr.getnameinfo( options=0 ) → [ node, service ]

Extract the node name (or address) and the service name (or port number) from the sockaddr help in addr.  
从addr的sockaddr帮助中提取node名（或地址）和服务名称（或端口数）。
The options are a bitwose OR of the `Socket::NI_xxx` constants.
options是一个`Socket::NI_xxx`常数的按位或。

    require 'socket'
    a = Addrinfo.tcp('pragprog.com', 80)
    a                                     # => #<Addrinfo: 209.251.185.98:80 TCP
                                          # .. (pragprog.com)>
    a.getnameinfo                         # => ["209.251.185.98", "http"]
    a.getnameinfo(Socket::NI_NUMERICHOST) # => ["209.251.185.98", "http"]
    a.getnameinfo(Socket::NI_NUMERICSERV) # => ["209.251.185.98", "80"]

#### inspect_sockaddr  检视套接字地址

    addr.inspect_sockaddr → string

Inspect just the sockaddr portion of addr.
只是监视addr的套接字地址部分。

#### ip_unpack  ip解包

    addr.ip_unpack → [ host, port ]

Returns the numeric host and port for an `AF_INET` Addrinfo.
返回`AF_INET`Addrinfo的数值host和端口。

    require 'socket'
    Addrinfo.tcp("pragprog.com", "www").ip_unpack # => ["209.251.185.98", 80]

#### ipv6_to_ipv4  ipv4转换为ipv6

    addr.ipv6_to_ipv4 → ipv4_addr or nil

If addr is an IPV4-mapped IPV6 address, return a new Addrinfo containing the corresponding IPV4 address.
如果addr是一个映射IPV4的IPV6地址，返回一个新的Addrinfo，包含对应的IPV4地址。

    require 'socket'
    Addrinfo.ip("::ffff:192.0.2.128").ipv6_to_ipv4 # => #<Addrinfo: 192.0.2.128>
    Addrinfo.ip("::1").ipv6_to_ipv4 # => nil

#### listen  监听

    addr.listen( backlog=5 ) → sock
    addr.listen( backlog=5 ) { | sock | . . . } → obj

Binds a socket to addr and then issues a listen on it.  
将一个套接字绑定到addr中，然后进行监听。
With no block, returns the socket.  
在没有带block，返回一个套接字。
With a block, passes the socket as a parameter, closes the socket at the end, and returns the block’s value.
如果带了block，则带套接字调用它，block返回时关闭套接字，并返回block的值。

#### to_sockaddr  转为套接字地址

    addr.to_sockaddr → binary_string

Returns the sockaddr component of addr as a packed binary string. 
(For the layout, see the Unix documentation for inet(4) and unix(4).
返回addr的套接字地址组件为一个打包的二进制字符。
对于该层，参见inet(4)和unix(4)的Unix文档。


## BasicSocket <  IO   基本套接字类

BasicSocket is an abstract base class for all other socket classes.
BasicSocket是其他所有套接字类的抽象类。

### Class methods  类方法
#### do_not_reverse_lookup  全局反向查找标志

    BasicSocket.do_not_reverse_lookup → true or false

Returns the value of the global reverse lookup flag.
返回全局反向查找标志。

#### do_not_reverse_lookup=  设置全局反向查找标志

    % BasicSocket.do_not_reverse_lookup = true or false

Sets the global reverse lookup flag.  
设置全局反向查找标志。
If set to true, queries on remote addresses will return the numeric address but not the host name.
如果设置为true，对远程地址的查询将返回数字型地址，而不是主机名。

**1.9.2**
Previously this flag defaulted to false, which caused the occasional performance problem.  
之前这个标志默认为false，导致偶然的性能问题。
<kinder:note> 关于这个性能问题，2版补充：套接字库默认在连接时进行反向查找。如果由于某种原因查找过慢或超时，连接到一个主机将花费很长时间。
It now defaults to true.
现在默认为true了。

#### for_fd 包找文件描述符

    BasicSocket.for_fd( fd ) → sock

Wraps an already open file descriptor into a socket object.
将一个已经打开的文件描述符包找为一个socket对象。


### Instance methods 实例方法
#### close_read  关闭可读连接

    sock.close_read → nil

Closes the readable connection on this socket.
关闭这个套接字的可读连接。

#### close_write  关闭可写连接

    sock.close_write → nil

Closes the writable connection on this socket.
关闭这个套接字的可写连接。

#### connect_address  连接地址    1.9.2

    sock.connect_address → addr_info

Return the address that should be used to connect to this socket.  
返回一个可用于连接这个套接字的地址。
Normally this is the same as `local_address`, but the IPV4 and IPV4 unspecified addresses are replaced by their corresponding loopback addresses.
通常这个和`local_address`一样，但IPV4和IPV4未定地址被它们对应的回送地址所替代。

    require 'socket'
    listening_socket = Addrinfo.tcp('::', 0).listen
    listening_socket.local_address # => #<Addrinfo: [::]:56676 TCP>
    listening_socket.connect_address # => #<Addrinfo: [::1]:56676 TCP>

#### getpeereid  取得套接字另一端ID   1.9.2

    sock.getpeereid → [ euid, egid ]

Return the effective user ID and effective group ID of the socket.
返回套接字连的有效用户ID和有效组ID。

#### getpeername  取得套接字另一端名字

    sock.getpeername → string

Returns the struct sockaddr structure associated with the other end of this socket connection.
返回套接字连接到另一端所关联的struct sockaddr结构。

#### getsockname  取得套接字名称

    sock.getsockname → string

Returns the struct sockaddr structure associated with sock.
返回和套接字关联的struct sockaddr结构。

#### getsockopt  取得套接字选项

    sock.getsockopt( level, optname ) → sockopt

Returns the value of the specified option as a Socket::Option object.  
以一个Socket::Option对象返回指定选项的值。
The level is an integer, string, or symbol drawn from the `SOL_xxx` constants, and the option is an integer, symbol, or string drawn from the `SO_xxx` constants.
level是一个从`SOL_xxx`常数得到的整数、字符串或符号；option是一个从`SO_xxx`常数得到的整数、字符串或符号。

    require 'socket'
    sock = Socket.new(Socket::PF_INET, Socket::SOCK_STREAM) # => #<Socket:fd 3>
    opt = sock.getsockopt(:SOL_SOCKET, :SO_DEBUG)           # => #<Socket::Option:
                                                            # .. INET SOCKET DEBUG
                                                            # .. 0>
    opt.bool                                                # => false
    opt = sock.getsockopt(:SOL_SOCKET, :SO_RCVBUF)          # => #<Socket::Option:
                                                            # .. INET SOCKET RCVBUF
                                                            # .. 262140>
    opt.int                                                 # => 262140

#### local_address  本地地址    1.9.2

    sock.local_address → addr_info

Return the address information for the local end of a socket.
返回套接字的本地端的地址信息。

    require 'socket'
    s = Socket.tcp('google.com', 80)
    s.local_address # => #<Addrinfo: 192.168.1.17:56677 TCP>
    s.remote_address # => #<Addrinfo: 74.125.45.99:80 TCP>

#### recv  接收的字节

    sock.recv( len, , flags ) → string

Receives up to len bytes from sock.
从sock接收至多len个字节。

#### recvmsg  接收的消息    1.9.2

    sock.recvmsg( max_data_len=nil, flags=0, max_control_len=nil, options={} ) → [ data, sender_addr, flags, controls ]

Uses the recvmsg(2) call to receive a message from a socket.  
使用recvmsg(2)调用从一个套接字接收一个消息。
One use of this is to pass open file descriptors between processes.  
这个方法的一个用处是在进程之间传递打开的文件描述符。
The ancillary parameter can be the three-element array [ `cmsg_level`, `cmsg_type`, `cmsg_data` ] or a Socket::AncillaryData object.
辅助参数可以是一个三元素的[ `cmsg_level`, `cmsg_type`, `cmsg_data` ]数组或Socket::AncillaryData对象。

#### recvmsg_nonblock  无block的接收消息    1.9.2

    sock.recvmsg_nonblock( max_data_len=nil, flags=0, max_control_len=nil, options={} ) → [ data, sender_addr, flags, controls ]

Nonblocking version of recvmsg.
recvmsg的无block版。

#### recv_nonblock   无block的接收字节    1.9

    sock.recv_nonblock( len, , flags ) → string

Receives up to len bytes from sock after first setting the socket into nonblocking mode.  
在第一次设置套接字为非block模式后，从sock接收最多len字节。
If the underlying recvfrom call returns 0, an empty string is returned.
如果底层的recvfrom调用返回0，将返回一个空的字符串。

#### remote_address  远程地址   1.9.2

    sock.remote_address → addr_info

Return the address information for the remote end of a socket.
为套接字的远程端返回地址信息。

    require 'socket'
    s = Socket.tcp('google.com', 80)
    s.local_address # => #<Addrinfo: 192.168.1.17:56678 TCP>
    s.remote_address # => #<Addrinfo: 74.125.45.99:80 TCP>

#### send  发送字符串

    sock.send( string, flags, , to ) → int

Sends string over sock.  
通过sock发送字符串。
If specified, to is a struct sockaddr or an Addrinfo specifying the recipient address.  
如果指定了目标，to是一个表示接收地址的struct sockaddr结构。
flags are the sum of one or more of the `MSG_` options (listed on page 18).  
flags是某个或某几个`MSG_`选项（下面列出）的和。
Returns the number of characters sent.
返回发送的字符数目。

#### sendmsg  发送信息    1.9.2

    sock.sendmsg( data, flags=0, , to , ancillary ∗ ) → int

Uses the sendmsg(2) call to send a message with optional access rights data to another socket.
使用sendmsg(2)调用来发送一个带可选的访问权利数据到另一个套接字。
One use of this is to pass open file descriptors between processes.  
这个方法的一个用途是在进程之间传递打开文件描述符。
The ancillary parameter can be the three-element array [ `cmsg_level`, `cmsg_type`, `cmsg_data` ] or a Socket::AncillaryData object.
辅助参数可以是一个三元素的[ `cmsg_level`, `cmsg_type`, `cmsg_data` ]数组或Socket::AncillaryData对象。

#### sendmsg_nonblock  无block发送信息  1.9.2

    sock.sendmsg_nonblock( data, flags=0, , to , ancillary ∗ ) → int

Nonblocking version of sendmsg.
sendmsg的无block版本。

#### setsockopt  设置套接字选项  1.9.2

    sock.setsockopt( level, optname, optval ) → 0

Sets a socket option.  
设置一个套接字选项。
level is one of the socket-level options (listed on the next page).  
level是一个套接字级的选项（在下面列出）。
optname and optval are protocol specific—see your system documentation for details.
optname和optval是特定于协议的--有关细节参见系统文档。

#### shutdown  关闭接收者

    sock.shutdown( how=2 ) → 0

Shuts down the receive (how == 0), sender (how == 1), or both (how == 2), parts of this socket.
关闭套接字的接收者（how == 0），发送者（how == 1），和同时关闭（how = 2）部分。


## Module Socket::Constants  套接字常数模块
Defines the constants used as options and parameters throughout the socket library.
定义这些常数，用作整个套接字库的选项和参数。
Constants are available only on architectures that support the related facility.
只有支持相关工具的架构，常数方为可用。

### Types  类型

    SOCK_DGRAM, SOCK_PACKET, SOCK_RAW, SOCK_RDM, SOCK_SEQPACKET, SOCK_STREAM

### Protocol families   协议族

    PF_APPLETALK, PF_ATM, PF_AX25, PF_CCITT, PF_CHAOS, PF_CNT, PF_COIP,
    PF_DATAKIT, PF_DEC, PF_DLI, PF_ECMA, PF_HYLINK, PF_IMPLINK, PF_INET,
    PF_INET6, PF_IPX, PF_ISDN, PF_ISO, PF_KEY, PF_LAT, PF_LINK, PF_LOCAL, PF_MAX,
    PF_NATM, PF_NDRV, PF_NETBIOS, PF_NETGRAPH, PF_NS, PF_OSI, PF_PACKET, PF_PIP,
    PF_PPP, PF_PUP, PF_ROUTE, PF_RTIP, PF_SIP, PF_SNA, PF_SYSTEM, PF_UNIX,
    PF_UNSPEC, PF_XTP

### Address families  地址族

    AF_APPLETALK, AF_ATM, AF_AX25, AF_CCITT, AF_CHAOS, AF_CNT, AF_COIP,
    AF_DATAKIT, AF_DEC, AF_DLI, AF_E164, AF_ECMA, AF_HYLINK, AF_IMPLINK,
    AF_INET, AF_INET6, AF_IPX, AF_ISDN, AF_ISO, AF_LAT, AF_LINK, AF_LOCAL,
    AF_MAX, AF_NATM, AF_NDRV, AF_NETBIOS, AF_NETGRAPH, AF_NS, AF_OSI,
    AF_PACKET, AF_PPP, AF_PUP, AF_ROUTE, AF_SIP, AF_SNA, AF_SYSTEM, AF_UNIX,
    AF_UNSPEC

### Send/receive options  发送/接收选项

    MSG_COMPAT, MSG_CONFIRM, MSG_CTRUNC, MSG_DONTROUTE, MSG_DONTWAIT,
    MSG_EOF, MSG_EOR, MSG_ERRQUEUE, MSG_FIN, MSG_FLUSH, MSG_HAVEMORE,
    MSG_HOLD, MSG_MORE, MSG_NOSIGNAL, MSG_OOB, MSG_PEEK, MSG_PROXY,
    MSG_RCVMORE, MSG_RST, MSG_SEND, MSG_SYN, MSG_TRUNC, MSG_WAITALL

#### Socket-level options  套接字级选项

    SOL_ATALK, SOL_AX25, SOL_IP, SOL_IPX, SOL_SOCKET, SOL_TCP, SOL_UDP

#### Socket options  套接字选项

    SO_ACCEPTCONN, SO_ACCEPTFILTER, SO_ALLZONES, SO_ATTACH_FILTER,
    SO_BINDTODEVICE, SO_BINTIME, SO_BROADCAST, SO_DEBUG,
    SO_DETACH_FILTER, SO_DONTROUTE, SO_DONTTRUNC, SO_ERROR,
    SO_KEEPALIVE, SO_LINGER, SO_MAC_EXEMPT, SO_NKE, SO_NOSIGPIPE,
    SO_NO_CHECK, SO_NREAD, SO_OOBINLINE, SO_PASSCRED, SO_PEERCRED,
    SO_PEERNAME, SO_PRIORITY, SO_RCVBUF, SO_RCVLOWAT, SO_RCVTIMEO,
    SO_RECVUCRED, SO_REUSEADDR, SO_REUSEPORT,
    SO_SECURITY_AUTHENTICATION, SO_SECURITY_ENCRYPTION_NETWORK,
    SO_SECURITY_ENCRYPTION_TRANSPORT, SO_SNDBUF, SO_SNDLOWAT,
    SO_SNDTIMEO, SO_TIMESTAMP, SO_TIMESTAMPNS, SO_TYPE, SO_USELOOPBACK,
    SO_WANTMORE, SO_WANTOOBFLAG

#### Qualtity-of-service options  服务品质(QOS)选项
<kinder:note> qualtity是quality的笔误吗？

    SOPRI_BACKGROUND, SOPRI_INTERACTIVE, SOPRI_NORMAL

#### Multicast options  多播选项

    IP_ADD_MEMBERSHIP, IP_ADD_SOURCE_MEMBERSHIP, IP_BLOCK_SOURCE,
    IP_DEFAULT_MULTICAST_LOOP, IP_DEFAULT_MULTICAST_TTL, IP_DONTFRAG,
    IP_DROP_MEMBERSHIP, IP_DROP_SOURCE_MEMBERSHIP, IP_FREEBIND,
    IP_HDRINCL, IP_IPSEC_POLICY, IP_MAX_MEMBERSHIPS, IP_MINTTL, IP_MSFILTER,
    IP_MTU, IP_MTU_DISCOVER, IP_MULTICAST_IF, IP_MULTICAST_LOOP,
    IP_MULTICAST_TTL, IP_ONESBCAST, IP_OPTIONS, IP_PASSSEC, IP_PKTINFO,
    IP_PKTOPTIONS, IP_PMTUDISC_DO, IP_PMTUDISC_DONT, IP_PMTUDISC_WANT,
    IP_PORTRANGE, IP_RECVDSTADDR, IP_RECVERR, IP_RECVIF, IP_RECVOPTS,
    IP_RECVRETOPTS, IP_RECVSLLA, IP_RECVTOS, IP_RECVTTL, IP_RETOPTS,
    IP_ROUTER_ALERT, IP_SENDSRCADDR, IP_TOS, IP_TTL, IP_UNBLOCK_SOURCE,
    IP_XFRM_POLICY

#### TCP options  TCP选项

    TCP_CORK, TCP_DEFER_ACCEPT, TCP_INFO, TCP_KEEPCNT, TCP_KEEPIDLE,
    TCP_KEEPINTVL, TCP_LINGER2, TCP_MAXSEG, TCP_MD5SIG, TCP_NODELAY,
    TCP_NOOPT, TCP_NOPUSH, TCP_QUICKACK, TCP_SYNCNT, TCP_WINDOW_CLAMP

#### getaddrinfo error codes  取得地址信息的错误代码

    EAI_ADDRFAMILY, EAI_AGAIN, EAI_BADFLAGS, EAI_BADHINTS, EAI_FAIL,
    EAI_FAMILY, EAI_MAX, EAI_MEMORY, EAI_NODATA, EAI_NONAME,
    EAI_OVERFLOW, EAI_PROTOCOL, EAI_SERVICE, EAI_SOCKTYPE, EAI_SYSTEM

#### ai_flag values  ai_flag的值

    AI_ADDRCONFIG, AI_ALL, AI_CANONNAME, AI_DEFAULT, AI_MASK,
    AI_NUMERICHOST, AI_NUMERICSERV, AI_PASSIVE, AI_V4MAPPED,
    AI_V4MAPPED_CFG


## Socket < BasicSocket  套接字
###  概述
Class Socket provides access to the operating system socket implementation.  
Socket类提供了对底层操作socket实现的访问。
It can be used to provide more system–specific functionality than the protocol-specific socket classes but at the expense of greater complexity.
它可以用来提供更多特定于操作系统而不是特定于协议的功能，但以更多的复杂性为代价。

### Class methods  类方法
#### accept_loop  接受循环 1.9.2

    Socket.accept_loop( sockets... ) { | socket, client_addr_info | . . . }

Takes a list of listening sockets or arrays of listening sockets.  
得到一个监听套接字的列表或数组。
When a connection arrives on any, accepts it and invokes the block, passing in the new socket and the client address.  
当一个连接到达时，接受它并调用block，传入新的套接字和客户端地址。
The block is invoked serially—if you need to handle multiple concurrent connections, you’ll need to do your own threading in the block (or simply use listen, accept, and select yourself.
block被连续地调用--如果你需要处理多个并发连接，你将需要在block里运行你自己的线程（或只是使用监听、接受、选择自己）。
<kinder:note> 好吧，下面这个例子显然不是这个方法的。这个笔误也太大了。

    require 'socket'
    Socket.getaddrinfo('www.microsoft.com', 'http').each do |addr|
      puts addr.join(", ")
    end
    # produces:  
    # AF_INET, 80, 207.46.170.123, 207.46.170.123, 2, 2, 17
    # AF_INET, 80, 207.46.170.123, 207.46.170.123, 2, 1, 6
    # AF_INET, 80, 207.46.170.10, 207.46.170.10, 2, 2, 17
    # AF_INET, 80, 207.46.170.10, 207.46.170.10, 2, 1, 6

#### getaddrinfo  取得地址信息

    Socket.getaddrinfo( hostname, port, , family , socktype , protocol , flags , rlookup) → array

Returns an array of arrays describing the given host and port (optionally qualified as shown).
返回描述指定主机和端口（可以使用如上所示的限定参数）数组的一个数组。
Each subarray contains the address family, port number, host name, host IP address, protocol family, socket type, and protocol. 
每个子数组，包括地址族、端口号、主机名、主机IP地址、协议族、套接字类型和协议。
1.9.2
The rlookup parameter overrides the default reverse name lookup option.
rlookup参数改写默认的反向名字查找选项。

    require 'socket'
    Socket.getaddrinfo('www.microsoft.com', 'http').each do |addr|
      puts addr.join(", ")
    end
    # produces:
    # AF_INET, 80, 207.46.170.123, 207.46.170.123, 2, 2, 17
    # AF_INET, 80, 207.46.170.123, 207.46.170.123, 2, 1, 6
    # AF_INET, 80, 207.46.170.10, 207.46.170.10, 2, 2, 17
    # AF_INET, 80, 207.46.170.10, 207.46.170.10, 2, 1, 6

#### gethostbyaddr  根据地址获得主机

    Socket.gethostbyaddr( addr, type=AF_INET ) → array

Returns the host name, address family, and sockaddr component for the given address.
返回给定地址的主机名、地址族、套接字地址组成部分。

    require 'socket'
    a = Socket.gethostbyname("221.186.184.68")
    res = Socket.gethostbyaddr(a[3], a[2])
    res.join(', ') # => "carbon.ruby-lang.org, 68.184.186.221.in-addr.arpa,
                   # .. 68.64.184.186.221.in-addr.arpa, 2, \xDD\xBA\xB8D"

#### gethostbyname  根据名字获得主机

    Socket.gethostbyname( hostname ) → array

Returns a four-element array containing the canonical host name, a subarray of host aliases, the address family, and the address portion of the sockaddr structure.
返回一个四个元素的数组，包括规格化的主机名、主机别名的子数组、地址族，以及套接字地址结构的地址部分。

    require 'socket'
    a = Socket.gethostbyname("63.68.129.130")
    a.join(', ') # => "63.68.129.130, , 2, ?D\x81\x82"

#### gethostname  取得主机名

    Socket.gethostname → string

Returns the name of the current host.
返回当前主机的名称。

    require 'socket'
    Socket.gethostname # => "wide-boy"

#### getnameinfo  取得名称信息

    Socket.getnameinfo( addr , flags ) → array

**1.9.2**
Looks up the given address, which may be either a string containing a sockaddr, a Addrinfo, or a three- or four-element array.  
查询给定的地址，可能是一个包括套接字地址的字符串，一个Addrinfo，或一个三个或四个元素的数组。
If addr is an array, it should contain the string address family, the port (or nil), and the host name or IP address.  
如果addr是一个数组，它应该包括地址族字符串、端口（或nil）和主机名或IP地址。
If a fourth element is present and not nil, it will be used as the host name.  
如果存在第四个元素或者非nil，它将被作为主机名。
Returns a canonical host name (or address) and port number as an array.
以数组返回一个规格化的主机名（或地址）和端口号。

    require 'socket'
    puts Socket.getnameinfo(["AF_INET", '23', 'www.ruby-lang.org'])
    # produces:
    # carbon.ruby-lang.org
    # telnet

#### getservbyname  根据名称取得服务端口

    Socket.getservbyname( service, proto=’tcp’ ) → int

Returns the port corresponding to the given service and protocol.
返回给定服务和协议对应的端口号

    require 'socket'
    Socket.getservbyname("telnet") # => 23

#### getservbyport  根据端口取得服务端口    1.9

    Socket.getservbyport( port, proto=’tcp’ ) → string

Returns the port corresponding to the given service and protocol.
返回给定服务和协议对应的端口号。
<kinder:note> 可是下面的示例返回的是协议的名称。

    require 'socket'
    Socket.getservbyport(23) # => "telnet"

#### ip_address_list  IP地址列表   1.9.2

    Socket.ip_address_list → [ addr... ]

Retrurns the addresses of the local network interfaces.
返回本地网络接口的地址。

    require 'socket'
    puts Socket.ip_address_list.map(&:inspect)
    # produces:
    # #<Addrinfo: ::1>
    # #<Addrinfo: fe80::1%lo0>
    # #<Addrinfo: 127.0.0.1>
    # #<Addrinfo: fdd7:b0e5:d31f:2e70:225:4bff:feb8:f12c>
    # #<Addrinfo: fe80::225:ff:fe44:ac61%en1>
    # #<Addrinfo: 192.168.1.17>
    # #<Addrinfo: fe80::225:4bff:feb8:f12c%en2>
    # #<Addrinfo: 169.254.97.62>

#### new  新建

    Socket.new( domain, type , protocol ) → sock

Creates a socket using the given parameters.  
使用给定的参数创建一个套接字。
If missing, the protocol parameter is inferred from the other two.
如果丢失，protocol参数从其他两个参数中推想出来。

#### open  打开   1.9.2

    Socket.open( domain, type, protocol ) → sock

Synonym for Socket.new.
同Socket.new。

#### pack_sockaddr_in  inet套接字地址结构

    Socket.pack_sockaddr_in( port, host ) → str_address

Given a port and a host, returns the (system dependent) `AF_INET` sockaddr structure as a string of bytes.
给定一个端口和主机，以字符串的形式，返回`AF_INET`sockaddr结构（系统相关的）。

    require 'socket'
    addr = Socket.pack_sockaddr_in(80, "pragprog.com") # Pragprog.com is 65.74.171.137
    addr.unpack("CCnC4") # => [16, 2, 80, 209, 251, 185, 98]

#### pack_sockaddr_un  域套接字地址结构

    Socket.pack_sockaddr_un( path ) → str_address

Given a path to a Unix socket, returns the (system dependent) `sock_addr_un` structure as a string of bytes.  
给定一个Unix套接字的路径，以字符串的形式返回`sock_addr_un`结构（系统相关）。
Available only on boxes supporting the Unix address family.
仅在支持Unix地址族的系统上可用。

    require 'socket'
    sock = UNIXServer.open("/tmp/sample")
    addr = Socket.pack_sockaddr_un("/tmp/sample")
    addr[0,20] # => "\x00\x01/tmp/sample\x00\x00\x00\x00\
               # .. x00\x00\x00"

#### pair  对

    Socket.pair( domain, type , protocol ) → array
    Socket.pair( domain, type , protocol ) { | sock1, sock2 | . . . } → obj

Returns an array containing a pair of connected, anonymous Socket objects with the given domain, type, and protocol.  
返回一个数组，包括用给定的域、类型和协议连接的一对匿名的Socket对象。
**1.9.2**
If omitted, the protocol parameter is inferred from the other two.  
如果忽略，protocol参数从另外两个参数里推导出来。
If a block is given, it is passed the two sockets, and the first socket is closed when the block exits.
如果给定了一个block，它传递两个套接字，block存在时第一个套接字被关闭。

#### socketpair  套接字对 

    Socket.socketpair( domain, type, protocol ) → array

Synonym for Socket.pair.
同Socket.pair。

#### sockaddr_in  inet套接字地址结构

    Socket.sockaddr_in( port, host ) → str_address

Synonym for `pack_sockaddr_in`.
同前面的`pack_sockaddr_in`。

#### sockaddr_un  域套接字地址结构 1.9

    Socket.sockaddr_un( path ) → str_address

Synonym for `pack_sockaddr_un`.
同前面的`pack_sockaddr_un`。

#### socket_pair  套接字对 1.9

    Socket.socket_pair( domain, type, protocol ) → array

Synonym for Socket.pair.
同Socket.pair。

#### tcp 1.9.2

    Socket.tcp( host, port , local_interface , local_port ) { | socket | . . . } → obj
    Socket.tcp( host, port , local_interface , local_port ) → socket

Create a TCP connection to the given host and port, optionally setting the local interface and port to use.  
创建一个到给定主机和端口的TCP连接，可选地设置本地接口和端口号来使用。
If given a block, pass it the socket, and close the connection, and return the block’s value; otherwise return the open socket.
如果给定了一个block，将它传到套接字，并关闭连接，返回block的值；否则返回一个打开的套接字。


#### tcp_server_loop  tcp服务循环 1.9.2

    Socket.tcp_server_loop( host=nil, port ) { | socket, client_addr_info | . . . }

Accepts connections on all the interfaces for the given port (and optionally host).  
为给定端口（和可选主机）接受在所有接口的连接。
When a connection arrives, call the block, passing in the connected socket and an Addrinfo structure describing the client.  
当一个连接到达时，调用该block，传入已经连接的套接字和一个描述客户端的Addrinfo接口。
Connections are serialized through the block, so you’ll need add concurrently yourself (for example, using threading).  
连接被block系列化，所以你将需要自己添加并发（比如，使用线程）。
In reality, this is a bad idea unless you can control the rate at which clients connect—you’re probably better off using listen and accept directly in these cases.  
现实中，这是个坏主意，除非你可以控制客户端连接的速率--在这些情况，可能你最好关闭使用监听并直接接受。
In all cases, your code is responsible for closing the socket passed to the block.
在所有的情况下，你的代码响应着传给block的正在关闭的套接字。

#### tcp_server_sockets  tcp服务器套接字 1.9.2

    Socket.tcp_server_sockets( host=nil, port ) → [ socket... ]
    Socket.tcp_server_sockets( host=nil, port ) { | sockets | . . . } → obj

Opens a listening socket on each on the interfaces for the host, using the given port or a dynamically assigned port if port is zero.  
为主机打开一个监听中的套接字，使用给定的端口；或如果端口为零则打开一个动态赋值的端口。
If a block is given, passes the array of sockets to it and closes them when the block exits; otherwise returns the array of sockets.  
如果给定了block，传递套接字的数组给它，并在block退出时关闭它们；否则返回套接字的数组。
The list of sockets is effectively that given by calling 
套接字列表是有效地调用，通过：

    Addrinfo.foreach(host, port, nil, :STREAM, nil, Socket::AI_PASSIVE).map(&:listen)

#### udp_server_loop  udp服务器 套接字  1.9.2

    Socket.udp_server_loop( host=nil, port ) { | msg, source_addr | . . . }

Invokes the block for every message that arrives on the given UDP port, passing in the message (a string) and the address of the sender (a Socket::UDPSource object).  
为每个到达给定UDP端口的信息调用block，传入信息（一个字符串）和发送者的地址（一个Socket::UDPSource对象）。

    # From the internal documentation...
    # UDP/IP echo server.
    Socket.udp_server_loop(9261) do |msg, msg_src|
      msg_src.reply msg
    end

#### udp_server_loop_on  udp服务器循环 1.9.2

    Socket.udp_server_loop_on( sockets=nil ) { | msg, source_addr | . . . }

Takes an array of sockets (probably created using `udp_server_sockets`), and invokes the block repeatedly for each message that arrives on any of them, passing in the message (a string) and the address of the sender (a Socket::UDPSource object).
带一个套接字数组（可使用`udp_server_sockets`创建），并对到达它们的每个信息（一个字符串）和发送者的地址（一个Socket::UDPSource对象）重复调用block，。

#### udp_server_sockets  udp服务器套接字  1.9.2

    Socket.udp_server_sockets( host=nil, port ) → [ socket... ]
    Socket.ucp_server_sockets( host=nil, port ) { | sockets | . . . } → obj

Opens a UDP socket on each on the interfaces for the host, using the given port or a dynamically assigned port if port is zero.  
为主机在每个在界面打开一个UDP接口，使用给定的端口，如果端口为零，则使用动态赋值的端口。
If a block is given, passes the array of sockets to it and closes them when the block exits; otherwise returns the array of sockets.
如果给定了block，传递套接字的数组给它，并在block退出时关闭它们；否则返回套接字的数组。

#### unit  单元  1.9.2

    Socket.unit( path ) { | socket | . . . } → obj
    Socket.unit( path ) → socket

Create a domain socket connection on the given path.  
在给定的路径上创建一个域套接字连接。
If given a block, pass it the socket, and close the connection, and return the block’s value; otherwise return the open socket.
如果给定了block，传递套接字的数组给它，并在block退出时关闭它们；否则返回套接字的数组。

#### unix_server_loop  域服务器循环  1.9.2

    Socket.tcp_server_loop( path ) { | socket, client_addr_info | . . . }

Accepts connections on all the the Unix domain socket identified by path.  
在所有用path标识的Unix域套接字上接受连接。
When a connection arrives, call the block, passing in the connected socket and an Addrinfo structure describing the client.  
当一个连接到达时，调用block，传入已经连接的套接字和一个描述客户端的Addrinfo结构。
Connections are serialized through the block, so you’ll need add concurrently yourself (for example, using threading).  
连接在block中被序列化，所以你需要自己添加并发（比如使用线程）。
In reality, this is a bad idea unless you can control the rate at which clients connect—you’re probably better off using listen and accept directly in these cases.
现实中，这是个坏主意，除非你可以控制客户端连接的速率--在这些情况，可能你最好关闭使用监听并直接接受。
In all cases, your code is responsible for closing the socket passed to the block.
在所有的情况下，你的代码响应着传给block的正在关闭的套接字。

#### unix_server_socket  域服务器套接字 1.9.2

    Socket.unix_server_socket( path ) → socket
    Socket.unix_server_socket( path ) { | socket | . . . } → obj

Create a domain socket on the given path (first deleting any existing socket if it is owned by the caller) If a block is given, passes the socket to it and closes and deletes the socket when the block exits; otherwise returns the socket.
在给定的path上（如果为调用者所有，则首先删除任何存在的套接字）创建一个域套接字。
如果给定了block，将套接字传入它，并在block退出时关闭和删除套接字；否则返回套接字。

#### unpack_sockaddr_in  解包inet套接字地址  1.8

    Socket.pack_sockaddr_in( string_address ) → [ port, host ]

Given a string containing a binary addrinfo structure, return the port and host.
给定一个含有二进制地址信息结构的字符串，返回端口和主机。

    require 'socket'
    addr = Socket.pack_sockaddr_in(80, "pragprog.com")
    Socket.unpack_sockaddr_in(addr) # => [80, "209.251.185.98"]

#### unpack_sockaddr_un  解包域套接字地址 1.8

    Socket.pack_sockaddr_un( string_address ) → path

Return the path for an AF_LOCAL socket.
返回`AF_LOCAL`套接字的路径。
<kinder:note> 这个方法和2版的同名方法很不一样。

    require 'socket'
    addr = Addrinfo.unix("/tmp/socket")
    Socket.unpack_sockaddr_un(addr) # => "/tmp/socket"


### Instance methods  实例方法
#### accept  接受

    sock.accept → [ socket, caller_address ]

Accepts an incoming connection returning an array containing a new Socket object and an Addrinfo object containing the address of the caller.
接受一个进入的连接，返回一个数组，包括一个新的Socket对象和一个包含发起者地址的Addrinfo对象。

#### accept_nonblock  无block接受 1.9

    sock.accept_nonblock → [ socket, caller_address ]

Puts the listening socket into nonblocking mode and then accepts an incoming connection.
将监听的套接字放进无block模式，返回接受一个进入的连接。
Throws an exception if no connection is pending.  
如果没有未决连接，抛出一个异常。
You’ll probably use this in conjunction with select.
你将可能在使用select联合时使用这个。

#### bind  绑定 1.9.2

sock.bind( addr ) → 0

Binds to the given addr, contained in a struct sockaddr string or a Addrinfo object.
绑定到一个指定的addr，包含在一个struct sockaddr字符串或Addrinfo对象。

#### connect  连接  1.9.2

    sock.connect( addr ) → 0

Connects to the given addr, contained in a struct sockaddr string or a Addrinfo object.
连接到给定的addr，包含在一个struct sockaddr字符串或Addrinfo对象。

#### connect_nonblock  无block连接  1.9.2

    sock.connect_nonblock( addr ) → 0

Connects to the given addr, contained in a struct sockaddr string or a Addrinfo object.  
连接到给定的addr，包含在一个struct sockaddr字符串或Addrinfo对象。
The nonblocking option `O_NONBLOCK` is set on the underlying file descriptor.
无block选项`O_NONBLOCK`在底层的文件描述符中被开启。

#### ipv6-only!  只用于ipv6  1.9.2

    sock.ipv6_only!

Set the `SO_IPV6_ONLY` option on the socket if supported by the underlying operating system.
如果底层操作系统支持的化，在套接字上设置`SO_IPV6_ONLY`。
Equivalent to:
等同于：

    def ipv6only!
      if defined? Socket::IPV6_V6ONLY
        self.setsockopt(:IPV6, :V6ONLY, 1)
      end
    end

#### listen  监听

    sock.listen( int ) → 0

Listens for connections, using the specified int as the backlog.
监听连接，使用指定的int作为最大的连接数目。

#### recvfrom  接收

    sock.recvfrom( len , flags ) → [ data, sender_addr ]

Receives up to len bytes from sock.  
从sock接收至多len个字节。
**1.9.2**
flags is zero or more of the `MSG_` options.  
flags为0或多个的`MSG_`选项。
The first element of the result is the data received.  
结果的第一个元素是接收到的数据。
The second element contains an Addrinfo object containing the address of the sender.
第二个元素包含一个Addrinfo对象，包含发送者的地址。

#### recvfrom_nonblock  无block接收   1.9

    sock.recvfrom_nonblock( len , flags ) → [ data, sender_addr ]

Receives up to len bytes from sock in nonblocking mode.  
在无block模式下从套接字接收至多len字节。
1.9.2
flags is zero or more of the `MSG_` options.  
flags为0或多个的`MSG_`选项。
The first element of the result is the data received.  
结果的第一个元素是接收到的数据。
The second element contains an Addrinfo object containing the address of the sender.
第二个元素包含一个Addrinfo对象，包含发送者的地址。

#### sysaccept  系统接收  1.8

    sock.sysaccept → [ socket_fd, address ]

Accepts an incoming connection. 
接收一个进入的连接。
**1.9.2**
Returns an array containing the (integer) file descriptor of the incoming connection and an Addrinfo object containing the address of the caller.
返回一个数组，包含进入的连接的（整形）文件描述符，和一个包含调用者地址的Addrinfo对象。


## IPSocket < BasicSocket  IP套接字

Class IPSocket is a base class for sockets using IP as their transport.  
IPSocket类是使用IP作为传输层的socket基础类。
TCPSocket and UDPSocket are children of this class.
TCPSocket和UDPSocket是这个类的子类。

### Class methods  类方法
#### getaddress  取得地址

    IPSocket.getaddress( hostname ) → string

Returns the dotted-quad IP address of hostname.
返回主机名的点段式IP地址。

    require 'socket'
    IPSocket.getaddress('www.ruby-lang.org') # => "221.186.184.68"

### Instance methods  实例方法
#### addr  地址

    sock.addr( rlookup ) → array

Returns the domain, port, name, and IP address of sock as a four-element array.  
以一个四元素数组返回sock的域、端口、名称和ip地址。
**1.9.2**
If the rlookup parameter is absent, the global `do_not_reverse_lookup` flag determines if the host address is returned as an address or a name.  
如果省略了rlookup参数，全局的`do_not_reverse_lookup`flag决定让主机地址返回为一个地址或是名称。
If the parameter is present, a value of true or :hostname causes a name to be returned; false or :numeric causes a number to be returned.
如果参数存在，true或:hostname的值决定返回名字，false或:numeric决定返回一个数字。

    require 'socket'
    u = UDPSocket.new
    u.bind('localhost', 8765)     # => 0
    u.addr              # => ["AF_INET", 8765, "127.0.0.1", "127.0.0.1"]
    u.addr(:numeric)    # => ["AF_INET", 8765, "127.0.0.1", "127.0.0.1"]
    u.addr(:hostname)   # => ["AF_INET", 8765, "localhost", "127.0.0.1"]
    BasicSocket.do_not_reverse_lookup = false
    u.addr              # => ["AF_INET", 8765, "127.0.0.1", "127.0.0.1"]

#### peeraddr  点地址

    sock.peeraddr( rlocal ) → array

Returns the domain, port, name, and IP address of the peer.  
以一个四元素数组返回sock对方的域、端口、名称和ip地址。
**1.9.2**
If the rlookup parameter is absent, the global `do_not_reverse_lookup` flag determines if the host address is returned as an address or a name.  
如果省略了rlookup参数，全局的`do_not_reverse_lookup`flag决定让主机地址返回为一个地址或是名称。
If the parameter is present, a value of true or :hostname causes a name to be returned; false or :numeric causes a number to be returned.
如果参数存在，true或:hostname的值决定返回名字，false或:numeric决定返回一个数字。

#### recvfrom  接收

    sock.recvfrom( len , flags ) → [ data, sender ]

Receives up to len bytes on the connection.  
在连接中接受至多len个字节。
flags is zero or more of the `MSG_` options (listed on page 18).  
flags为0或多个的`MSG_`选项（在前面18页列出的）。
Returns a two-element array.  
返回一个两元素数组。
The first element is the received data, and the second is an array containing information about the peer.  
第一个元素是接收的数据，第二个元素是一个数组，包含关于对方点的信息。
On systems such as my Mac OS X box where the native recvfrom() method does not return peer information for TCP connections, the second element of the array is nil.
在Mac OS X电脑原生recvfrom()方法不会为TCP连接返回对方信息，诸如这样的系统，第二个参数的数组为nil。

    require 'socket'
    t = TCPSocket.new('127.0.0.1', 'ftp')
    data = t.recvfrom(40)
    data # => ["220 127.0.0.1 FTP server (tnftpd 2008092", nil]
    t.close # => nil


## TCPSocket < IPSocket  TCP套接字

    require 'socket'
    t = TCPSocket.new('localhost', 'ftp')
    t.gets # => "220 ::1 FTP server (tnftpd 20080929) ready.\r\n"
    t.close # => nil

### Class methods  类方法
#### gethostbyname  取得主机名

    TCPSocket.gethostbyname( hostname ) → array

Looks up hostname and returns its canonical name, an array containing any aliases, the address type (`AF_INET`), and the dotted-quad IP address.
查询主机名，并返回它的规格化名称、别名的数组、`AF_INET`的地址类型和点段式IP地址。

    require 'socket'
    TCPSocket.gethostbyname('ns.pragprog.com') # => ["pragprog.com", [], 2,
                                               # .. "209.251.185.98"]

#### new  新建

    TCPSocket.new( hostname, port ) → sock

Opens a TCP connection to hostname on the port.
在port端口打开一个TCP连接到hostname。

#### open  打开

    TCPSocket.open( hostname, port ) → sock

Synonym for TCPSocket.new.
同TCPSocket.new。


## SOCKSSocket < TCPSocket

Class SOCKSSocket supports connections based on the SOCKS protocol.
SOCKSSocket类支持基于SOCKS协议的连接。

### Class methods  类方法
#### new  新建

    SOCKSSocket.new( hostname, port ) → sock

Opens a SOCKS connection to port on hostname.
打开一个连接到hostname的port的SOCKS。

#### open  打开

    SOCKSSocket.open( hostname, port ) → sock

Synonym for SOCKSSocket.new.
同SOCKSSocket.new。


### Instance methods  实例方法
#### close  关闭

    sock.close → nil

Closes this SOCKS connection.
关闭这个SOCKS连接。


## TCPServer < TCPSocket  TCP服务器
### 概述
A TCPServer accepts incoming TCP connections.  
TCPServer接受进来了的TCP连接。
Here is a web server that listens on a given port and returns the time:
这是一个web服务器，在给定的端口上监听，并返回时间：

    require 'socket'
    port = (ARGV[0] || 80).to_i
    server = TCPServer.new('0.0.0.0', port)
    while (session = server.accept)
      puts "Request: #{session.gets}"
      session.print "HTTP/1.1 200/OK\r\nContent-type: text/html\r\n\r\n"
      session.print "<html><body><h1>#{Time.now}</h1></body></html>\r\n"
      session.close
    end

### Class methods  类方法
#### new  新建

    TCPServer.new( hostname, port ) → sock

Creates a new socket on the given interface (identified by hostname and port).  
在指定的接口（通过hostname和port标识）上创建一个新的socket。
If hostname is omitted, the server will listen on all interfaces on the current host (equivalent to an address of 0.0.0.0).
如果省略了hostname，服务器会监听当前主机的所有接口（等价于地址0.0.0.0）。

#### open  打开

    TCPServer.open( hostname, port ) → sock

Synonym for TCPServer.new.
同TCPServer.new。

### Instance methods  实例方法
#### accept  接收

    sock.accept → tcp_socket

Waits for a connection on sock and returns a new `tcp_socket` connected to the caller.  
等待sock上进入的连接，并返回一个连接到调用者的新 `tcp_socket`。
See the example on page ??.
参见上面的示例。


## UDPSocket < IPSocket  UDP套接字
### 概述
UDP sockets send and receive datagrams.  
UDPsockets 发送和接收数据包。
To receive data, a socket must be bound to a particular port.  
要接受数据，必须将socket绑定到一个特定的端口。
You have two choices when sending data: you can connect to a remote UDP socket and thereafter send datagrams to that port, or you can specify a host and port every time you send a packet.  
你在发送数据时有两个选择：你可连接到一个远程的UDPsocket，然后向这个端口发送数据包，或者你可以为发送的每个包执行主机和端口。
The following example is a UDP server that prints the message it receives.  
下面的例子是一个UDP服务器，打印它接收的消息。
It is called by both connectionless and connection-based clients.
无连接和基于连接的客户端都可以呼叫它。

    require 'socket'
    PORT = 4321
    server = UDPSocket.open
    server.bind(nil, PORT)
    # run server in a thread
    server_thread = Thread.start(server) do |server|
      3.times { p server.recvfrom(64) }
    end

    # Ad-hoc client
    UDPSocket.open.send("ad hoc", 0, 'localhost', PORT)

    # Connection based client
    sock = UDPSocket.open
    sock.connect('localhost', PORT)
    sock.send("connection-based", 0)
    sock.send("second message", 0)
    server_thread.join
    # produces:
    # ["ad hoc", ["AF_INET", 60665, "127.0.0.1", "127.0.0.1"]]
    # ["connection-based", ["AF_INET", 55041, "127.0.0.1", "127.0.0.1"]]
    # ["second message", ["AF_INET", 55041, "127.0.0.1", "127.0.0.1"]]

### Class methods  类方法
#### new  新建

    UDPSocket.new( family = AF_INET ) → sock

Creates a UDP endpoint, optionally specifying an address family.
创建一个UDP端点，可以指定一个地址族。

#### open  打开

    UDPSocket.open( family = AF_INET ) → sock

Synonym for UDPSocket.new.
同UDPSocket.new。

### Instance methods  实例方法
#### bind  绑定

    sock.bind( hostname, port ) → 0

Associates the local end of the UDP connection with a given hostname and port.  
将UDP连接的本地端关联到一个指定的hostname和port。
As well as a host name, the first parameter may be "<broadcast>" or "" (the empty string) to bind to `INADDR_BROADCAST` and `INADDR_ANY`, respectively.  
第一个参数主机名，可以是"<broadcast>"或“”(空字符串)，以分别绑定到`INADDR_BROADCAST`和`INADDR_ANY`。
Must be used by servers to establish an accessible endpoint.
服务器必须使用它来建立可访问的端点。

#### connect  连接

    sock.connect( hostname, port ) → 0

Creates a connection to the given hostname and port.  
创建一个连接，到给定的主机名和端口。
Subsequent UDPSocket#send requests that don’t override the recipient will use this connection.  
如果后续的 UDPSocket#send 请求没有修改接收者，将使用这个连接。
Multiple connect requests may be issued on sock: the most recent will be used by send.  
可以对sock调用多个连接请求：send将使用最近的一个。
As well as a host name, the first parameter may be "<broadcast>" or "" (the empty string) to bind to `INADDR_BROADCAST` and `INADDR_ANY`, respectively.
第一个参数主机名，可以是"<broadcast>"或“”(空字符串)，以分别绑定到`INADDR_BROADCAST`和`INADDR_ANY`。

#### recvfrom  接收

    sock.recvfrom( len , flags ) → [ data, sender ]

Receives up to len bytes from sock.  
从sock接受最多len字节。
flags is zero or more of the `MSG_` options (listed on page 18).
flags为0或多个的`MSG_`选项（在前面18页列出的）。
The result is a two-element array containing the received data and information on the sender.
返回一个两元素数组，包含接受的数据和发送者的信息。
See the example on page ??.
参见前面的示例。

#### recvfrom_nonblock  无block接收 1.9

    sock.recvfrom_nonblock( len , flags ) → [ data, sender ]

Receives up to len bytes from sock in nonblocking mode.
在无block模式下，从sock接收最多len字节。

#### send  发送

    sock.send( string, flags ) → int
    sock.send( string, flags, hostname, port ) → int

The two-parameter form sends string on an existing connection.  
两参数的send使用一个已经建立的连接来发送string。
The four-parameter form sends string to port on hostname.
四参数的形式将string发送到hostname的port端口。


## UnixSocket < BasicSocket  域套接字
### 概述
A UNIXSocket supports interprocess communication using the Unix domain protocol.  
UNIXSocket支持使用Unix域协议进行通讯。
Although the underlying protocol supports both datagram and stream connections, the Ruby library provides only a stream-based connection.
虽然底层的协议支持数据报和流连接，ruby库只提供了基于流的连接。

    require 'socket'
    SOCKET = "/tmp/sample"
    sock = UNIXServer.open(SOCKET)
    # run server in a thread
    server_thread = Thread.start(sock) do |sock|
      s1 = sock.accept
      p s1.recvfrom(124)
    end
    
    client = UNIXSocket.open(SOCKET)
    client.send("hello", 0)
    client.close
    server_thread.join
    
    # produces:
    # ["hello", ["AF_UNIX", ""]]

### Class methods  类方法
#### new  新建

    UNIXSocket.new( path ) → sock

Opens a new domain socket on path, which must be a path name.
在path打开一个新的域套接字，path必须是一个路径名。

#### open  打开

    UNIXSocket.open( path ) → sock

Synonym for UNIXSocket.new.
同UNIXSocket.new。

### Instance methods  实例变量
#### addr  地址

    sock.addr → array

Returns the address family and path of this socket.
返回这个套接字的地址族和路径。

#### path  路径

    sock.path → string

Returns the path of this domain socket.
返回域套接字的路径。

#### peeraddr  对方地址

    sock.peeraddr → array

Returns the address family and path of the server end of the connection.
返回连接服务器端的地址族和路径。

#### recvfrom  接收

    sock.recvfrom( len , flags ) → array

Receives up to len bytes from sock.  
从sock接受至多len字节。
flags is zero or more of the MSG_ options (listed on page 18).
flags为0或多个`MSG_`选项。（2版766页4版18页）
The first element of the returned array is the received data, and the second contains (minimal) information on the sender.
返回数组的第一个元素是接收的数据，第二个包括发送者的（最少）信息。


## UnixServer < UnixSocket  域服务器
### 概述
Class UNIXServer provides a simple Unix domain socket server.  
UNIXServer类提供了一个简单的Unix域套接字服务器。
See UNIXSocket for example code.
实例代码见上面UnixSocket一节。

### Class methods  类方法
#### new  新建

    UNIXServer.new( path ) → sock

Creates a server on the given path.  
在给定的path上创建一个服务器。
The corresponding file must not exist at the time of the call.
对应文件在调用这个方法时必须是不存在的。

#### open  打开

    UNIXServer.open( path ) → sock

Synonym for UNIXServer.new.
同UNIXServer.new。

#### Instance methods  实例变量
#### accept  接受

    sock.accept → unix_socket

Waits for a connection on the server socket and returns a new socket object for that connection.
等待服务器socket上接收到的连接，并为这个连接返回一个新的socket对象。
See the example for UNIXSocket on page 34.
参见上一节UNIXSocket中的示例。


## 　附录B　MKMF参考
##   2.11 MKMF参考
### Module mkmf  mkmf模块

To build an extension, you create a program named extconf.rb , which may be as simple as this:
要建立一个扩展，你创建一个名为extconf.rb的程序，它可能像下面那样简单：

    require 'mkmf'
    create_makefile("Test")

When run, this script will produce a Makefile suited to the target platform.  
运行时，这个脚本会产生一个适合目标平台的Makefile。
It also produces a log file, mkmf.log , which may help in diagnosing build problems.
它还会产生一个日志文件mkmf.log，可以帮你诊断构建时的问题。

mkmf contains several methods you can use to find libraries and include files and to set compiler flags.
mkmf包含一些方法，你可以使用它来找出库和包含的文件，以设置编译器标志。
mkmf takes configuration information from a variety of sources:
mkmf可以从多个源得到配置信息：
• The configuration used when Ruby was built
  在构建ruby时使用的配置。
• The environment variable `CONFIGURE_ARGS` , a list of key=value pairs
  环境变量`CONFIGURE_ARGS`，一个key=value对。
• Command-line arguments of the form key=value or --key=value
  `key=value`或`--key=value`形式的命令行参数。

You can examine the configuration by dumping the variable `$configure_args` :
你可以通过转储变量`$configure_args`来检查构建的配置：
<kinder:note> 这个例子和2版的有所区别。

    require 'mkmf'
    require 'pp'
    pp $configure_args
    # produces:
    # {"--prefix"=>"/Users/dave/.rvm/rubies/ruby-1.9.2-p0",
    #  "--enable-shared"=>true,
    #  "--topsrcdir"=>"/tmp",
    #  "--topdir"=>"."}

#### 配置选项
The following configuration options are recognized:
下面的配置选项是被认可的：
#### CFLAGS
Flags passed to the C compiler (overridden by --with-cflags ).
传递给C编译器的标志（可以被--with-cflags改写）。
#### CPPFLAGS
Flags passed to the C++ compiler (overridden by --with-cppflags ).
传递给C++编译器的标志（可以被--with-cppflags改写）
#### curdir
Sets the global $curdir , which may be used inside the extconf.rb script. 
设置全局的$curdir，可以在extconf.rb脚本中使用。
Otherwise, has no effect.
否则无效。
#### disable-xxx
Disables extension-specific option xxx.
关闭特定于扩展的选项xxx。
#### enable-xxx
Enables extension-specific option xxx.
开启特定于扩展的选项xxx。
#### LDFLAGS
Flags passed to the linker (overridden by --with-ldlags ).
传递给链接器的标志（可以被--with-ldflags改写）。
#### ruby
Sets the name and/or path of the Ruby interpreter used in the Makefile .
设置在Makefile中使用的ruby解释器的名字和/或路径。
#### srcdir
Sets the path to the source directory in the Makefile .
设置Makefile的源代码目录路径。
#### with-cflags
Flags passed to the C compiler. 
传递给C编译器的标志。
Overrides the CFLAGS environment variable.
改写CFLAGS环境变量。
#### with-cppflags
Flags passed to the C++ compiler. 
传递给C++编译器的标志。
Overrides the CPPFLAGS environment variable.
改写CPPFLAGS环境变量。
#### with-ldflags
Flags passed to the linker. 
传递给链接器的标志。
Overrides the LDFLAGS environment variable.
改写LDFLAGS环境变量。
#### with-make-prog
Sets the name of the make program.  
设置make程序的名字。
If running on Windows, the choice of make program affects the syntax of the generated Makefile ( nmake vs. Borland make ).
如果在Windows上运行，make程序的选择会影响所产生Makefile文件的语法（nmake vs. Borland make）。
#### with-xxx-{dir | include | lib}
Controls where the `dir_config` method looks.
控制`dir_config`方法查找的位置。

### Instance methods  实例方法
#### create_makefile  创建makefile文件

    create_makefile( target, srcprefix= nil )

Creates a Makefile for an extension named target.  
为名为target的扩展创建一个Makefile。
The srcprefix can override the default source directory.  
srcprefix可以改写默认的源代码目录。
If this method is not called, no Makefile is created.
如果没有调用这个方法，不会创建Makefile。

#### dir_config  目录配置

    dir_config( name )

Looks for directory configuration options for name given as arguments to this program or to the original build of Ruby.  
查找name对应的目录配置选项，作为程序或者原本构建ruby的参数。
These arguments may be one of the following:
这些参数可以是下列之一：
--with-name-dir =directory
--with-name-include =directory
The given directories will be added to the appropriate search paths (include or link) in the Makefile .
所给出的目录会被加入Makefile内适当的搜索路径（头文件或链接）中。

#### enable_config  开启配置

    enable_config( name, default= nil ) → true or false or default

Tests for the presence of an --enable-name or --disable-name option.  
测试选项中是否含有 --enable-name或--disable-name。
Returns true if the enable option is given, false if the disable option is given, and the default value otherwise.
如果给出的是enable选项，则返回true；如果给出的是disable选项，则返回false；否则返回默认的值nil。

#### find_library  查找库文件

    find_library( name, function, path +) → true or false

Same as `have_library` but will also search in the given directory paths.
和`have_library`一样，但还会在给出的目录路径中搜索。

#### have_func  查找方法后添加

    have_func( function ) → true or false

If the named function exists in the standard compile environment, adds the directive `-D HAVE_FUNCTION` to the compile command in the Makefile and returns true .
如果指定的方法在标准编译环境中存在，则将指令`-D HAVE_FUNCTION`添加到Makefile的编译命令行中，并返回true。

#### have_header  查找头文件后添加

    have_header( header ) → true or false

If the given header file can be found in the standard search path, adds the directive `-D HAVE_HEADER` to the compile command in the Makefile and returns true .
如果指定的头文件可以在标准的搜索路径中找到，将指令`-D HAVE_HEADER`添加到Makefile的编译命令行中，并返回true。

#### have_library  查找库后添加

    have_library( library, function ) → true or false

If the given function exists in the named library, which must exist in the standard search path or in a directory added with `dir_config` , adds the library to the link command in the Makefile and returns true .
如果在给定的库（必须位于标准搜索路径，或者由`dir_config`添加的路径内）中存在指定的函数，将这个库添加到Makefile的链接命令中，炳返回true。


### Appendix A Bibliography  书目
[TFH08]
David Thomas, Chad Fowler, and Andrew Hunt. Programming Ruby: The Prag-
matic Programmers’ Guide. The Pragmatic Programmers, LLC, Raleigh, NC, and
Dallas, TX, third edition, 2008.

# 　附录C　支持   --- A1
# 　附录D　书目   --- A2
# 　索引（Index） ---省略
