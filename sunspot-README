# Sunspot 全文搜索

## 概述
[![Gem Version](https://badge.fury.io/rb/sunspot.png)](http://badge.fury.io/rb/sunspot)
[![Build Status](https://secure.travis-ci.org/sunspot/sunspot.png)](http://travis-ci.org/sunspot/sunspot)

Sunspot is a Ruby library for expressive, powerful interaction with the Solr search engine.
Sunspot 是一个富有表现力的、强大互动能力的搜索引擎。
Sunspot is built on top of the RSolr library, which provides a low-level interface for Solr interaction; Sunspot provides a simple, intuitive, expressive DSL backed by powerful features for indexing objects and searching for them.
Sunspot 基于 RSolr 库而构建，这个库提供了一些低级别的接口进行 Solr 交互；Sunspot 通过强大的特性提供了一个简单的、直接的、富有表现力的 DSL 后台来进行索引和搜索。

Sunspot is designed to be easily plugged in to any ORM, or even non-database-backed objects such as the filesystem.
Sunspot 设计来简便地插入到任何对象关系映射中，甚至是非数据库后台的对象（例如文件系统）。

This README provides a high level overview; class-by-class and method-by-method documentation is available in the [API reference](http://sunspot.github.com/sunspot/docs/).
自述文件提供了一个高级别的概览，逐个类、逐个方法地记述了 API 参考。

For questions about how to use Sunspot in your app, please use the
[Sunspot Mailing List](http://groups.google.com/group/ruby-sunspot) or search
[Stack Overflow](http://www.stackoverflow.com).
在程序中使用Sunspot的过程中遇到什么问题，请使用邮件列表或搜索stackoverflow。

## Quickstart with Rails 3 / 4  快速开始

Add to Gemfile:
第一步，添加 Gemfile：
```ruby
gem 'sunspot_rails'
gem 'sunspot_solr' # optional pre-packaged Solr distribution for use in development
```

Bundle it!
第二步，绑定：

```bash
bundle install
```

Generate a default configuration file:
第三步，生成默认的配置文件：

```bash
rails generate sunspot_rails:install
```

If `sunspot_solr` was installed, start the packaged Solr distribution with:
第四步，如果安装了`sunspot_solr`，开始`Solr`发布包:

```bash
bundle exec rake sunspot:solr:start # or sunspot:solr:run to start in foreground
```

## Setting Up Objects 设置对象

Add a `searchable` block to the objects you wish to index.
添加一个`searchable`代码块到你想索引的对象里：

```ruby
class Post < ActiveRecord::Base
  searchable do
    text :title, :body
    text :comments do
      comments.map { |comment| comment.body }
    end

    boolean :featured
    integer :blog_id
    integer :author_id
    integer :category_ids, :multiple => true
    double  :average_rating
    time    :published_at
    time    :expired_at

    string  :sort_title do
      title.downcase.gsub(/^(an?|the)/, '')
    end
  end
end
```

`text` fields will be full-text searchable. 
`text` 字段将被全文搜索。
Other fields (e.g., `integer` and `string`) can be used to scope queries.
其他字段（比如`integer`和`string`）则是作用域查询。

## Searching Objects  搜索对象

```ruby
Post.search do
  fulltext 'best pizza'

  with :blog_id, 1
  with(:published_at).less_than Time.now
  order_by :published_at, :desc
  paginate :page => 2, :per_page => 15
  facet :category_ids, :author_id
end
```

## Search In Depth  深度搜索

Given an object `Post` setup in earlier steps ...
假设前面已经设置了`Post`对象：

### Full Text  全文

#### 一个单词
```ruby
# All posts with a `text` field (:title, :body, or :comments) containing 'pizza'
# 在所有`post`的`text`字段（包括标题、主体和所有评论）查找包含`pizza`
Post.search { fulltext 'pizza' }

# Posts with pizza, scored higher if pizza appears in the title
# 带有`pizza`的`post`，如果出现在标题中，则搜索得分更高。
Post.search do
  fulltext 'pizza' do
    boost_fields :title => 2.0
  end
end

# Posts with pizza, scored higher if featured
# 带有`pizza`的`post`，如果有`featured`，则搜索得分更高。
Post.search do
  fulltext 'pizza' do
    boost(2.0) { with(:featured, true) }
  end
end

# Posts with pizza *only* in the title
# 只搜索标题带有`pizza`的`Post`
Post.search do
  fulltext 'pizza' do
    fields(:title)
  end
end

# Posts with pizza in the title (boosted) or in the body (not boosted)
# 搜索标题带有`pizza`或者主体带有`pizza`的`post`，标题带有的基本更高
Post.search do
  fulltext 'pizza' do
    fields(:body, :title => 2.0)
  end
end
```

#### Phrases  短语和短语之间

Solr allows searching for phrases: search terms that are close together.
Solr 允许搜索短语：搜索相近的条件。

In the default query parser used by Sunspot (edismax), phrase searches are represented as a double quoted group of words.
在 Sunspot 使用的默认查询解析器里，短语查询被描述为双引号扩起来的单词。

```ruby
# Posts with the exact phrase "great pizza"
# 搜索带有`greate pizza`的`post`
Post.search do
  fulltext '"great pizza"'
end
```

If specified, **query_phrase_slop** sets the number of words that may appear between the words in a phrase.
如果指定了`query_phrase_slop`的数量，则会设置该数量为短语单词之间的单词的个数。

```ruby
# One word can appear between the words in the phrase, so "great big pizza"
# also matches, in addition to "great pizza"
# 一个单词可以出现在短语的单词之间，所以除了`greate pizza`，`greate big pizza`也会匹配
Post.search do
  fulltext '"great pizza"' do
    query_phrase_slop 1
  end
end
```

##### Phrase Boosts 短语高权重

Phrase boosts add boost to terms that appear in close proximity; the terms do not *have* to appear in a phrase, but if they do, the document will score more highly.
短语高权重可以添加高权重给最接近的条件；该条件不一定要出现在短语中，但如果出现在该短语中，该文档的得分会更高。

```ruby
# Matches documents with great and pizza, and scores documents more
# highly if the terms appear in a phrase in the title field
# 匹配`greate`和`pizza`的文档，如果条件出现在标题字段的短语上，该文档会有更高得分
Post.search do
  fulltext 'great pizza' do
    phrase_fields :title => 2.0
  end
end

# Matches documents with great and pizza, and scores documents more
# highly if the terms appear in a phrase (or with one word between them)
# in the title field
# 匹配`greate`和`pizza`的文档，如果条件出现在标题字段的短语上或在它们之间有一个单词），该文档会有更高得分
Post.search do
  fulltext 'great pizza' do
    phrase_fields :title => 2.0
    phrase_slop   1
  end
end
```


### Scoping (Scalar Fields)  作用域（标量字段）

Fields not defined as `text` (e.g., `integer`, `boolean`, `time`, etc...) can be used to scope (restrict) queries before full-text matching is performed.
没有定义为`text`的字段（比如`integer`、`boolean`、`time`等等）可以在执行全文匹配之前用作作用域（严格）查询。

#### Positive Restrictions  正向约束

```ruby
# Posts with a blog_id of 1
# 搜索 blog_id 字段为1的`post`
Post.search do
  with(:blog_id, 1)
end

# Posts with an average rating between 3.0 and 5.0
# 搜索:average_rating 为3到5的`post`。
Post.search do
  with(:average_rating, 3.0..5.0)
end

# Posts with a category of 1, 3, or 5
# 搜索 :category_id 为 1 3 或 5的`post`
Post.search do
  with(:category_ids, [1, 3, 5])
end

# Posts published since a week ago
# 搜索 :published_at 字段为一周前的`post`
Post.search do
  with(:published_at).greater_than(1.week.ago)
end
```

#### Negative Restrictions  反向约束

```ruby
# Posts not in category 1 or 3
# 搜索 :category_id 不是 1 或 3 的`post`
Post.search do
  without(:category_ids, [1, 3])
end

# All examples in "positive" also work negated using `without`
# 所有正向约束都可使用`without`来变成反向约束。
```

#### Empty Restrictions 没有约束

```ruby
# Passing an empty array is equivalent to a no-op, allowing you to replace this...
# 传入一个空数组等同于没有条件，允许替换
Post.search do
  with(:category_ids, id_list) if id_list.present?
end

# ...with this
# 替换成这个：
Post.search do
  with(:category_ids, id_list)
end
```


#### Disjunctions and Conjunctions 分离和联合

```ruby
# Posts that do not have an expired time or have not yet expired
# 搜索没有过期时间或还未过期的`post`
Post.search do
  any_of do
    with(:expired_at).greater_than(Time.now)
    with(:expired_at, nil)
  end
end
```

```ruby
# Posts with blog_id 1 and author_id 2
# 搜索 blog_id 为 1 并且 author_id 为 2 的`post`
Post.search do
  all_of do
    with(:blog_id, 1)
    with(:author_id, 2)
  end
end
```

```ruby
# Posts scoring with any of the two fields.
# 搜索作用域为任意两个字段的`post`
Post.search do
  any do
    fulltext "keyword1", :fields => :title
    fulltext "keyword2", :fields => :body
  end
end
```

Disjunctions and conjunctions may be nested
分离和联合都可以嵌套。

```ruby
Post.search do
  any_of do
    with(:blog_id, 1)
    all_of do
      with(:blog_id, 2)
      with(:category_ids, 3)
    end
  end
  
  any do
    all do
      fulltext "keyword", :fields => :title
      fulltext "keyword", :fields => :body
    end
    all do
      fulltext "keyword", :fields => :first_name
      fulltext "keyword", :fields => :last_name
    end
    fulltext "keyword", :fields => :description
  end
end
```

#### Combined with Full-Text  与全文搜索连用

Scopes/restrictions can be combined with full-text searching.
作用域或约束可以和全文搜索连用。
The scope/restriction pares down the objects that are searched for the full-text term.
作用域或约束可以减少全文术语的搜索对象

```ruby
# Posts with blog_id 1 and 'pizza' in the title
Post.search do
  with(:blog_id, 1)
  fulltext("pizza")
end
```


### Pagination  分页

**All results from Solr are paginated**
**Solr 搜索出的所有结果是分页的**

The results array that is returned has methods mixed in that allow it to operate seamlessly with common pagination libraries like will\_paginate and kaminari.
返回的结果数组有一些混入方法，允许它无缝操作普通的分页库，例如 will_paginate 或 kaminari。

By default, Sunspot requests the first 30 results from Solr.
默认情况下，Sunspot 会从 Solr 请求前 30 个结果。

```ruby
search = Post.search do
  fulltext "pizza"
end

# Imagine there are 60 *total* results (at 30 results/page, that is two pages)
# 假设共有 60 个结果（每页30个，2页）。
results = search.results # => Array with 30 Post elements

search.total           # => 60

results.total_pages    # => 2
results.first_page?    # => true
results.last_page?     # => false
results.previous_page  # => nil
results.next_page      # => 2
results.out_of_bounds? # => false
results.offset         # => 0
```

To retrieve the next page of results, recreate the search and use the `paginate` method.
要取得下一页的结果，可重建搜索并使用`paginate`方法。

```ruby
search = Post.search do
  fulltext "pizza"
  paginate :page => 2
end

# Again, imagine there are 60 total results; this is the second page
# 还是假设有60歌结果，这是第二页：
results = search.results # => Array with 30 Post elements

search.total           # => 60

results.total_pages    # => 2
results.first_page?    # => false
results.last_page?     # => true
results.previous_page  # => 1
results.next_page      # => nil
results.out_of_bounds? # => false
results.offset         # => 30
```

A custom number of results per page can be specified with the `:per_page` option to `paginate`:
要自定义每页结果数量可以在`paginate`的`:per_page`选项上指定：

```ruby
search = Post.search do
  fulltext "pizza"
  paginate :page => 1, :per_page => 50
end
```

#### Cursor-based pagination  基于指针的分页

**Solr 4.7 and above**

With default Solr pagination it may turn that same records appear on different pages (e.g. if many records have the same search score). 
使用默认的 Solr 分页，它可能会在不同的页面上返回同样的记录。（比如多个记录拥有同样的搜索分数）。
Cursor-based pagination allows to avoid this.
基于指针的分页可以避免这一点。

Useful for any kinds of export, infinite scroll, etc.
这对数据导出、无限滚动等都非常有用。

Cursor for the first page is "*".
第一页的指针是`*`。

```ruby
search = Post.search do
  fulltext "pizza"
  paginate :cursor => "*"
end

results = search.results

# Results will contain cursor for the next page
# 结果将会包含下一页的指针
results.next_page_cursor # => "AoIIP4AAACxQcm9maWxlIDEwMTk="

# Imagine there are 60 *total* results (at 30 results/page, that is two pages)
# 假设共有 60 个记录（每页30歌，2页）
results.current_cursor # => "*"
results.total_pages    # => 2
results.first_page?    # => true
results.last_page?     # => false
```

To retrieve the next page of results, recreate the search and use the `paginate` method with cursor from previous results.
要重获下一页的结果，可重建搜索，并使用带有上一页的指针的`paginate`方法
```ruby
search = Post.search do
  fulltext "pizza"
  paginate :cursor => "AoIIP4AAACxQcm9maWxlIDEwMTk="
end

results = search.results

# Again, imagine there are 60 total results; this is the second page
# 还是假设总共有60个记录，这是第二页
results.next_page_cursor # => "AoEsUHJvZmlsZSAxNzY5"
results.current_cursor   # => "AoIIP4AAACxQcm9maWxlIDEwMTk="
results.total_pages      # => 2
results.first_page?      # => false
# Last page will be detected only when current page contains less then per_page elements or contains nothing
# 最后一页会在当前页面包含的元素少于`per_page`的时候，或没有包含元素的时候，才会被检测出来。
results.last_page?       # => false
```
 
`:per_page` option is also supported.
`:per_page`选项也支持。

### Faceting 刻面

Faceting is a feature of Solr that determines the number of documents that match a given search *and* an additional criterion.
刻面是 Solr 的特性，他决定匹配了给定搜索和额外标准的文档的数量。
This allows you to build powerful drill-down interfaces for search.
这允许构建强有力的牢固的搜索界面。

Each facet returns zero or more rows, each of which represents a particular criterion conjoined with the actual query being performed.
每个刻面会返回0或多行，每一行表达一个特定的标准并联合一个真正执行的查询。
For **field facets**, each row represents a particular value for a given field.
对于字段刻面，每一行为给定字段表达特定的值。
For **query facets**, each row represents an arbitrary scope; the facet itself is just a means of logically grouping the scopes.
对于查询刻面，每一行代表一个任意作用域；刻面本身只是作用域逻辑分组的方式。

By default Sunspot will only return the first 100 facet values.
默认情况下，Sunspot 只会返回前100个刻面的值。
 You can increase this limit, or force it to return *all* facets by setting **limit** to **-1**.
可以减少这个限制，或者通过设置`limit`为`-1`来要求返回所有刻面。

#### Field Facets  字段刻面

```ruby
# Posts that match 'pizza' returning counts for each :author_id
# 匹配`pizza`的`post，返回每个`:author_id`的总数。
search = Post.search do
  fulltext "pizza"
  facet :author_id
end

search.facet(:author_id).rows.each do |facet|
  puts "Author #{facet.value} has #{facet.count} pizza posts!"
end
```

If you are searching by a specific field and you still want to see all the options available in that field you can **exclude** it in the faceting.
如果正在通过指定字段搜索，并且还想看看哪个字段所有的选项，可以在刻面中将它`exclude`。

```ruby
# Posts that match 'pizza' and author with id 42
# 搜索匹配`pizza`并且`author_id`为42的`post`
# Returning counts for each :author_id (even those not in the search result)
# 返回每个`:author_id`的数量（即使没有搜索结果）
search = Post.search do
  fulltext "pizza"
  author_filter = with(:author_id, 42)
  facet :author_id, exclude: [author_filter]
end

search.facet(:author_id).rows.each do |facet|
  puts "Author #{facet.value} has #{facet.count} pizza posts!"
end
```

#### Query Facets  查询刻面

```ruby
# Posts faceted by ranges of average ratings
# 通过平均率来刻面`post`
search = Post.search do
  facet(:average_rating) do
    row(1.0..2.0) do
      with(:average_rating, 1.0..2.0)
    end
    row(2.0..3.0) do
      with(:average_rating, 2.0..3.0)
    end
    row(3.0..4.0) do
      with(:average_rating, 3.0..4.0)
    end
    row(4.0..5.0) do
      with(:average_rating, 4.0..5.0)
    end
  end
end

# e.g., 
# 例如输出：
# Number of posts with rating within 1.0..2.0: 2
# 平均率在1.0和2.0之间的post的数量： 2
# Number of posts with rating within 2.0..3.0: 1
# 平均率在2.0和3.0之间的post的数量：1
search.facet(:average_rating).rows.each do |facet|
  puts "Number of posts with rating within #{facet.value}: #{facet.count}"
end
```

#### Range Facets 范围刻面

```ruby
# Posts faceted by range of average ratings
# 搜索刻面平均率范围内的post
Sunspot.search(Post) do
  facet :average_rating, :range => 1..5, :range_interval => 1
end
```


### Ordering 排序

By default, Sunspot orders results by "score": the Solr-determined relevancy metric.
默认情况下，Sunspot 根据`score`来排列结果：Solr决定的关联制。
Sorting can be customized with the `order_by` method:
排序可以用`order_by`方法来定制：

```ruby
# Order by average rating, descending
# 根据平均率降序
Post.search do
  fulltext("pizza")
  order_by(:average_rating, :desc)
end

# Order by relevancy score and in the case of a tie, average rating
# 根据关联分数和平均率降序
Post.search do
  fulltext("pizza")

  order_by(:score, :desc)
  order_by(:average_rating, :desc)
end

# Randomized ordering
# 随机排序
Post.search do
  fulltext("pizza")
  order_by(:random)
end
```

**Solr 3.1 and above**

Solr supports sorting on multiple fields using custom functions.
Solr 支持使用自定义函数给多个字段排序。
Supported operators and more details are available on the [Solr Wiki](http://wiki.apache.org/solr/FunctionQuery) To sort results by a custom function use the `order_by_function` method.
支持的操作符、更多细节参见 wiki，使用`order_by_function`方法。 

Functions are defined with prefix notation:
函数用前置标记定义：

```ruby
# Order by sum of two example fields: rating1 + rating2
# 按两个字段`比率1`和`比率2`的和来排序
Post.search do
  fulltext("pizza")
  order_by_function(:sum, :rating1, :rating2, :desc)
end

# Order by nested functions: rating1 + (rating2*rating3)
# 按嵌套函数排序
Post.search do
  fulltext("pizza")
  order_by_function(:sum, :rating1, [:product, :rating2, :rating3], :desc)
end

# Order by fields and constants: rating1 + (rating2 * 5)
# 按字段和常量的函数来排序
Post.search do
  fulltext("pizza")
  order_by_function(:sum, :rating1, [:product, :rating2, '5'], :desc)
end

# Order by average of three fields: (rating1 + rating2 + rating3) / 3
# 按三个字段的平均值排序
Post.search do
  fulltext("pizza")
  order_by_function(:div, [:sum, :rating1, :rating2, :rating3], '3', :desc)
end
```

### Grouping 分组

**Solr 3.3 and above**

Solr supports grouping documents, similar to an SQL `GROUP BY`.
Solr 支持对文档进行分组，类似于 SQL 的`GROUP BY`。
More information about result grouping/field collapsing is available on the [Solr Wiki](http://wiki.apache.org/solr/FieldCollapsing).
关于结果分组或字段折叠的更多信息参见 wiki。


**Grouping is only supported on `string` fields that are not multivalued. To group on a field of a different type (e.g., integer), add a denormalized `string` type**
**分组只支持字符串字段，且不能是多个值。其他类型的字段要想分组，可添加一个非正常的字符串字段。**
<kinder:note> 什么叫做“denormalized”？就是进行`to_s`。

```ruby
class Post < ActiveRecord::Base
  searchable do
    # Denormalized `string` field because grouping can only be performed
    # on string fields
    # 因为只有字符串字段才能分组，所以该字段需要字符串化。
    string(:blog_id_str) { |p| p.blog_id.to_s }
  end
end

# Returns only the top scoring document per blog_id
# 只返回每个`blog_id`得分最高的文档
search = Post.search do
  group :blog_id_str
end

search.group(:blog_id_str).matches # Total number of matches to the query
                                   # 匹配查询的总数量
search.group(:blog_id_str).groups.each do |group|
  puts group.value # blog_id of the each document in the group

  # By default, there is only one document per group (the highest
  # scoring one); if `limit` is specified (see below), multiple
  # documents can be returned per group
  # 默认情况下，每个分组只有一个文档（得分最高的）；
  # 如果指定了`limit`（见下面），每个分组可以返回多个文档。
  group.results.each do |result|
    # ...
  end
end
```

Additional options are supported by the DSL:
通过 DSL 可以支持其他选项：

```ruby
# Returns the top 3 scoring documents per blog_id
# 每个`blog_id`返回得分最高的3个文档
Post.search do
  group :blog_id_str do
    limit 3
  end
end

# Returns document ordered within each group by published_at (by
# default, the ordering is score)
# 返回每个分组里依据`published_at`排序后的文档（默认是依据得分排序）。
Post.search do
  group :blog_id_str do
    order_by(:average_rating, :desc)
  end
end

# Facet count is based on the most relevant document of each group
# matching the query (>= Solr 3.4)
# 刻面计数基于每个匹配查询的分组最相关的文档
Post.search do
  group :blog_id_str do
    truncate
  end

  facet :blog_id_str, :extra => :any
end
```

### Geospatial 空间

**Sunspot 2.0 only**
**只在 Sunspot 2.0 支持**

Sunspot 2.0 supports geospatial features of Solr 3.1 and above.
Sunspot 2.0 支持 Solr 3.1 版以上的“空间”特性。
Geospatial features require a field defined with `latlon`:
空间特性需要一个用`latlon`定义的字段。

```ruby
class Post < ActiveRecord::Base
  searchable do
    # ...
    latlon(:location) { Sunspot::Util::Coordinates.new(lat, lon) }
  end
end
```

#### Filter By Radius 半径过滤

```ruby
# Searches posts within 100 kilometers of (32, -68)
# 搜索（32, -68） 100 公里以内的`post`：
Post.search do
  with(:location).in_radius(32, -68, 100)
end
```

#### Filter By Radius (inexact with bbox) 近似半径过滤

```ruby
# Searches posts within 100 kilometers of (32, -68) with `bbox`. This is
# an approximation so searches run quicker, but it may include other
# points that are slightly outside of the required distance
# 带`bbox`搜索（32, -68）100公里以内的`post`。
# 这是一个近似值，因此搜索会更快，但它可能包含其他稍微超出距离的点
Post.search do
  with(:location).in_radius(32, -68, 100, :bbox => true)
end
```

#### Filter By Bounding Box  范围方块过滤

```ruby
# Searches posts within the bounding box defined by the corners (45,
# -94) to (46, -93)
# 搜索坐标（45, -94）和（46, -93）的方块里的`post`
Post.search do
  with(:location).in_bounding_box([45, -94], [46, -93])
end
```

#### Sort By Distance  按距离排序

```ruby
# Orders documents by closeness to (32, -68)
# 依据距离（32, -68）的远近排序
Post.search do
  order_by_geodist(:location, 32, -68)
end
```


### Joins  连接

**Solr 4 and above**
**Solr 4 以上**

Solr joins allow you to filter objects by joining on additional documents.
Solr 连接允许通过连接其他文档来过滤对象。
More information can be found on the [Solr Wiki](http://wiki.apache.org/solr/Join).
更多信息参见 wiki。

```ruby
class Photo < ActiveRecord::Base
  searchable do
    text :description
    string :caption, :default_boost => 1.5
    time :created_at
    integer :photo_container_id
  end
end

class PhotoContainer < ActiveRecord::Base
  searchable do
    text :name
    join(:description, :target => Photo, :type => :text, :join => { :from => :photo_container_id, :to => :id })
    join(:caption, :target => Photo, :type => :string, :join => { :from => :photo_container_id, :to => :id })
    join(:photos_created, :target => Photo, :type => :time, :join => { :from => :photo_container_id, :to => :id }, :as => 'created_at_d')
  end
end

PhotoContainer.search do
  with(:caption, 'blah')
  with(:photos_created).between(Date.new(2011,3,1), Date.new(2011,4,1))
  
  fulltext("keywords", :fields => [:name, :description])
end

# ...or

PhotoContainer.search do
  with(:caption, 'blah')
  with(:photos_created).between(Date.new(2011,3,1), Date.new(2011,4,1))
  
  any do
    fulltext("keyword1", :fields => :name)
    fulltext("keyword2", :fields => :description) # will be joined from the Photo model
  end
end
```

#### If your models have fields with the same name  如果模型有同名字段

```ruby
class Tweet < ActiveRecord::Base
  searchable do
    text :keywords
    integer :profile_id
  end
end

class Rss < ActiveRecord::Base
  searchable do
    text :keywords
    integer :profile_id
  end
end

class Profile < ActiveRecord::Base
  searchable do
    text :name
    join(:keywords, :prefix => "tweet", :target => Tweet, :type => :text, :join => { :from => :profile_id, :to => :id })
    join(:keywords, :prefix => "rss", :target => Rss, :type => :text, :join => { :from => :profile_id, :to => :id })
  end
end

Profile.search do
  any do
    fulltext("keyword1 keyword2", :fields => [:tweet_keywords]) do
      minimum_match 1
    end
    
    fulltext("keyword3", :fields => [:rss_keywords])
  end
end

# ...produces:
# sort: "score desc", fl: "* score", start: 0, rows: 20,
# fq: ["type:Profile"],
# q: "(_query_:"{!join from=profile_ids_i to=id_i v=$qTweet91755700 fq=$fqTweet91755700}" OR _query_:"{!join from=profile_ids_i to=id_i v=$qRss91753840 fq=$fqRss91753840}")",
# qTweet91755700: "_query_:"{!edismax qf='keywords_text' mm='1'}keyword1 keyword2"", fqTweet91755700: "type:Tweet",
# qRss91753840: "_query_:"{!edismax qf='keywords_text'}keyword3"", fqRss91753840: "type:Rss"
```

### Highlighting  高亮

Highlighting allows you to display snippets of the part of the document that matched the query.
高亮允许显示显示匹配查询的部分文档的片段。

The fields you wish to highlight must be **stored**.
你想高亮的字段一定是已存储的。

```ruby
class Post < ActiveRecord::Base
  searchable do
    # ...
    text :body, :stored => true
  end
end
```

Highlighting matches on the `body` field, for instance, can be achieved like:
高亮匹配`body`字段，比如，可以这样：

```ruby
search = Post.search do
  fulltext "pizza" do
    highlight :body
  end
end

# Will output something similar to:
# 输出类似于：
# Post #1
#   I really love *pizza*
#   *Pizza* is my favorite thing
# Post #2
#   Pepperoni *pizza* is delicious
search.hits.each do |hit|
  puts "Post ##{hit.primary_key}"

  hit.highlights(:body).each do |highlight|
    puts "  " + highlight.format { |word| "*#{word}*" }
  end
end
```

### Stats 状态

Solr can return some statistics on indexed numeric fields. 
Solr 可以基于索引的数字型字段返回一些统计信息。

Fetching statistics for `average_rating`:
获取平均率的统计信息：

```ruby
search = Post.search do
  stats :average_rating
end

puts "Minimum average rating: #{search.stats(:average_rating).min}"
puts "Maximum average rating: #{search.stats(:average_rating).max}"
```

#### Stats on multiple fields 多个字段的状态

```ruby
search = Post.search do
  stats :average_rating, :blog_id
end
```

#### Faceting on stats  状态的刻面

It's possible to facet field stats on another field:
可以在另一个字段上刻面字段状态：

```ruby
search = Post.search do
  stats :average_rating do
    facet :featured
  end
end

search.stats(:average_rating).facet(:featured).rows do |row|
  puts "Minimum average rating for featured=#{row.value}: #{row.min}"
end
```

Take care when requesting facets on a stats field, since all facet results are returned by Solr!
注意，当请求的是一个状态字段的刻面，但 Solr 返回的是所有的刻面结果！

#### Multiple stats and selective faceting  多个状态和可选刻面

```ruby
search = Post.search do
  stats :average_rating do
    facet :featured
  end
  stats :blog_id do
    facet :average_rating
  end
end
```


### Functions  函数

Functions in Solr make it possible to dynamically compute values for each document.
Solr 里的函数允许为每个文档动态计算值。
This gives you more flexability and you don't have to only deal with static values.
这带来更多弹性，不再需要只面对静态值了。
For more details, please read [Fuction Query documentation](http://wiki.apache.org/solr/FunctionQuery).
更多信息，参见 Solr 的wiki。

Sunspot supports functions in two ways:
Sunspot 通过两种方式支持函数：

1. You can use functions to dynamically count boosting for field:
   可以使用函数来动态计算字段的高权：

```ruby
#Posts with pizza, scored higer (square promotion field) if is_promoted
# 搜索含有`pizza`的`post`，如果存在`is_promoted`则获得高权（对字段进行平方提权）
Post.search do
  fulltext 'pizza' do
    boost(function {sqrt(:promotion)}) { with(:is_promoted, true) }
  end
end
```

2. You're able to use functions for ordering (see examples for [order_by_function](#ordering))
   为排序使用函数，参见上面“排序”一节的示例。


### More Like This  更多相似

Sunspot can extract related items using more_like_this.
Sunspot 可使用`more_like_this`来析出相关项目。
When searching for similar items, you can pass a block with the following options: 
搜索相似项目时，可传入代码块来使用下列选项：

* fields :field_1[, :field_2, ...]
* minimum_term_frequency ##
* minimum_document_frequency ##
* minimum_word_length ##
* maximum_word_length ##
* maximum_query_terms ##
* boost_by_relevance true/false

```ruby
class Post < ActiveRecord::Base
  searchable do
    # The :more_like_this option must be set to true
    # :more_like_this 选项必须设置为 true
    text :body, :more_like_this => true
  end
end

post = Post.first

results = Sunspot.more_like_this(post) do
  fields :body
  minimum_term_frequency 5
end
```

To use more_like_this you need to have the [MoreLikeThis handler enabled in solrcofig.xml](http://wiki.apache.org/solr/MoreLikeThisHandler).
使用`more_like_this`，需要配置文件开启 MoreLikeThisHandler，参见 solr 的 wiki。

Example handler will look like this:
下面是一个处理器的示例：

```
<requestHandler class="solr.MoreLikeThisHandler" name="/mlt">
  <lst name="defaults">
    <str name="mlt.mintf">1</str>
    <str name="mlt.mindf">2</str>
  </lst>
</requestHandler>
```

### Spellcheck  拼写检查

Solr supports spellchecking of search results against a dictionary.
Solr 根据字典支持搜索结果的拼写检查。
Sunspot supports turning on the spellchecker via the query DSL and parsing the response.
Sunspot 支持通过查询 DSL 和解析响应来开启拼写检查器。
Read the [solr docs](http://wiki.apache.org/solr/SpellCheckComponent) for more information on how this all works inside Solr.
更多信息参见 Solr 的 wiki。

Solr's default spellchecking engine expects to use a dictionary comprised of values from an indexed field.
Solr 的默认拼写检查引擎会使用一个字典，并与索引字段的值进行比较。
This tends to work better than a static dictionary file, since it includes proper nouns in your index.
这会比静态字典文件更有效，因为它包含了你的索引里适当的名称。
The default in sunspot's `solrconfig.xml` is `textSpell` (note that `buildOnCommit` isn't recommended in production):
Sunspot 的`solrconfig.xml`的默认值是`textSpell`（注意不推荐在生产环境中使用`buildOnCommit`）。 

    <lst name="spellchecker">
       <str name="name">default</str>
       <!-- change field to textSpell and use copyField in schema.xml
       to spellcheck multiple fields -->
       <str name="field">textSpell</str>
       <str name="buildOnCommit">true</str>
     </lst>

Define the `textSpell` field in your `schema.xml`.
在你的`schema.xml`中定义`textSpell`字段：

    <field name="textSpell" stored="false" type="textSpell" multiValued="true" indexed="true"/>

To get some data into your spellchecking field, you can use `copyField` in `schema.xml`:
要将数据放入拼写检查字段中，可以在`schema.xml`文件中使用`copyField`：

    <copyField source="*_text"  dest="textSpell" />
    <copyField source="*_s"  dest="textSpell" />

`copyField` works *before* any analyzers you have set up on the source fields.
`copyField` 会在任何设置在源字段上分析器之前运行起来。
You can add your own analyzer by customizing the `textSpell` field type in `schema.xml`:
可以添加自己的分析器，通过在`schema.xml`里自定义`textSpell`字段的类型：

    <fieldType name="textSpell" class="solr.TextField" positionIncrementGap="100" omitNorms="true">
      <analyzer>
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.StandardFilterFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
    </fieldType>

It's dangerous to add too much to this analyzer chain.
添加太多分析器链是很危险的。
It runs before words are inserted into the spellcheck dictionary, which means the suggestions that come back from solr are post-analyzer.
它会在单词插入拼写检查字典之前运行起来，这意味着从 solr 返回的建议是分析后的。
With the default above, that means all spelling suggestions will be lower-case.
按照上面的默认值，所有拼写建议都是小写的。

Once you have solr configured, you can turn it on for a given query using the query DSL (see spellcheck_spec.rb for more examples):
一旦配置 Solr，可以使用查询 DSL 为给定查询开启这个检查

    search = Sunspot.search(Post) do
      keywords 'Cofee'
      spellcheck :count => 3
    end

Access the suggestions via the `spellcheck_suggestions` or `spellcheck_suggestion_for` (for just the top one) methods:
可以通过`spellcheck_suggestions`或`spellcheck_suggestion_for`（只适用最高的一个）方法来访问建议

    search.spellcheck_suggestion_for('cofee') # => 'coffee'

    search.spellcheck_suggestions # => [{word: 'coffee', freq: 10}, {word: 'toffee', freq: 1}]

If you've turned on [collation](http://wiki.apache.org/solr/SpellCheckComponent#spellcheck.collate), you can also get that result:
如果开启的校正功能，也可得到那个结果：

    search = Sunspot.search(Post) do
      keywords 'Cofee market'
      spellcheck :count => 3
    end

    search.spellcheck_collation # => 'coffee market'


## Indexes In Depth  深度索引

TODO

### Index-Time Boosts  索引时高权

To specify that a field should be boosted in relation to other fields for all queries, you can specify the boost at index time:
要声明一个字段对于其他字段在所有查询中获得高权重，可以在索引时指定权重：

```ruby
class Post < ActiveRecord::Base
  searchable do
    text :title, :boost => 5.0
    text :body
  end
end
```

### Stored Fields 存储字段

Stored fields keep an original (untokenized/unanalyzed) version of their contents in Solr.
存储字段在 Solr 保持内容的原始版本。

Stored fields allow data to be retrieved without also hitting the underlying database (usually an SQL server).
存储字段允许数据无需打开下层的数据库（通常是SQL服务器）就可重获。
They are also required for highlighting and more like this queries.
这是高亮和相似查询所必须的功能。

Stored fields come at some performance cost in the Solr index, so use them wisely.
存储字段在 Solr 索引中执行，因此应用广泛。

```ruby
class Post < ActiveRecord::Base
  searchable do
    text :body, :stored => true
  end
end

# Retrieving stored contents without hitting the database
# 无需动用数据库可重获存储内容
Post.search.hits.each do |hit|
  puts hit.stored(:body)
end
```


## Hits vs. Results  动用和结果的对比

Sunspot simply stores the type and primary key of objects in Solr.
Sunspot 只会存储 Solr 里对象的类型和主键。
When results are retrieved, those primary keys are used to load the actual object (usually from an SQL database).
当结果重获，那些主键被用于导入实际对象（通常从 SQL 数据库中）。

```ruby
# Using #results pulls in the records from the object-relational
# mapper (e.g., ActiveRecord + a SQL server)
# 在记录上从对象相关的映射器里使用`results`方法来拉。
Post.search.results.each do |result|
  puts result.body
end
```

To access information about the results without querying the underlying database, use `hits`:
要访问关于无需查询下层数据库就可得到结果的信息，使用`hits`：

```ruby
# Using #hits gives back all information requested from Solr, but does
# not load the object from the object-relational mapper
# 使用`hits`方法给回从 Solr 请求的所有信息，但不会加载对象相关映射器里的对象
Post.search.hits.each do |hit|
  puts hit.stored(:body)
end
```

If you need both the result (ORM-loaded object) and `Hit` (e.g., for faceting, highlighting, etc...), you can use the convenience method `each_hit_with_result`:
如果你同时需要`结果`（对象关系映射加载的对象）和`动用`（比如，刻面、高亮等），可以使用方便的`each_hit_with_result`方法：

```ruby
Post.search.each_hit_with_result do |hit, result|
  # ...
end
```

## Reindexing Objects  重新索引对象

If you are using Rails, objects are automatically indexed to Solr as a part of the `save` callbacks.
如果你正在使用 Rails，对象会被 Solr 自动索引为`save`回调的一部分。

There are a number of ways to index manually within Ruby:
在 Ruby 里有一些方法来手动索引：

```ruby
# On a class itself
# 在类本身：
Person.reindex
Sunspot.commit # or commit(true) for a soft commit (Solr4)

# On mixed objects
# 在混入对象上：
Sunspot.index [post1, item2]
Sunspot.index person3
Sunspot.commit # or commit(true) for a soft commit (Solr4)

# With autocommit
# 自动提交：
Sunspot.index! [post1, item2, person3]
```

If you make a change to the object's "schema" (code in the `searchable` block), you must reindex all objects so the changes are reflected in Solr:
如果更改对象的`schema`(`searchable`块里的代码)，比必须重索引所有对象，以便让改变重新反射到 Solr：

```bash
bundle exec rake sunspot:reindex

# or, to be specific to a certain model with a certain batch size:
# 或者，用特定尺寸指定特定的模型。
bundle exec rake sunspot:reindex[500,Post] # some shells will require escaping [ with \[ and ] with \]

# to skip the prompt asking you if you want to proceed with the reindexing:
# 如果想直接处理重索引，可跳过提示。
bundle exec rake sunspot:reindex[,,true] # some shells will require escaping [ with \[ and ] with \]
                                         # 有些 shell 要求将[和]转义为\[和\]字符
```

## Use Without Rails  在 Rails 外面使用（缺文档）

TODO

## Threading  线程

The default Sunspot Session is not thread-safe.
默认的 Sunspot 会话不是线程安全的。
If used in a multi-threaded environment (such as sidekiq), you should configure Sunspot to use the [ThreadLocalSessionProxy](http://sunspot.github.io/sunspot/docs/Sunspot/SessionProxy/ThreadLocalSessionProxy.html):
如果用于多线程环境（例如 sidekiq），应该配置 Sunspot 来使用ThreadLocalSessionProxy，参见 Sunspot 的配置。


```ruby
Sunspot.session = Sunspot::SessionProxy::ThreadLocalSessionProxy.new
```

## Manually Adjusting Solr Parameters  手动调整 Solr 参数

To add or modify parameters sent to Solr, use `adjust_solr_params`:
要添加或修改发送到 Solr 的参数，使用`adjust_solr_params`：

```ruby
Post.search do
  adjust_solr_params do |params|
    params[:q] += " AND something_s:more"
  end
end
```

## Session Proxies  会话代理（缺文档）

TODO

## Type reference  类型参考（缺文档）

TODO

## Configuration  配置

Configure Sunspot by creating a *config/sunspot.yml* file or by setting a `SOLR_URL` or a `WEBSOLR_URL` environment variable.
通过创建`config/sunspot.yml`或设置一个`SOLR_URL`或`WEBSOLR_URL`环境变量，可以配置 Sunspot。
The defaults are as follows.
默认值如下：

```yaml
development:
  solr:
    hostname: localhost
    port: 8982
    log_level: INFO

test:
  solr:
    hostname: localhost
    port: 8981
    log_level: WARNING
```

You may want to use SSL for production environments with a username and password.
你可能想在生产环境中使用带有`username`和`password` SSL。
For example, set `SOLR_URL` to `https://username:password@production.solr.example.com/solr`.
例如，设置`SOLR_URL`到`https://username:password@production.solr.example.com/solr`
 
You can examine the value of `Sunspot::Rails.configuration` at runtime.
你可以在运行时检测`Sunspot::Rails.configuration`的值。

## Development  开发

### Running Tests 运行测试

#### sunspot

Install the required gem dependencies:
安装必须的软件包依赖：

```bash
cd /path/to/sunspot/sunspot
bundle install
```

Start a Solr instance on port 8983:
在8983端口开始一个 Solr 实例：

```bash
bundle exec sunspot-solr start -p 8983
# or `bundle exec sunspot-solr run -p 8983` to run in foreground
```

Run the tests:
运行测试：

```bash
bundle exec rake spec
```

If desired, stop the Solr instance:
如果需要可以停止`Solr`示例：

```bash
bundle exec sunspot-solr stop
```

#### sunspot\_rails

Install the gem dependencies for `sunspot`:
安装`sunspot`软件包依赖：

```bash
cd /path/to/sunspot/sunspot
bundle install
```

Start a Solr instance on port 8983:
在8983端口开始一个 Solr 实例：

```bash
bundle exec sunspot-solr start -p 8983
# or `bundle exec sunspot-solr run -p 8983` to run in foreground
```

Navigate to the `sunspot_rails` directory:
导航到`sunspot_rails`目录：

```bash
cd ../sunspot_rails
```

Run the tests:
运行测试：

```bash
rake spec # all Rails versions
rake spec RAILS=3.1.1 # specific Rails version only
```

If desired, stop the Solr instance:
如果需要可以停止`Solr`示例：

```bash
cd ../sunspot
bundle exec sunspot-solr stop
```

### Generating Documentation  生成文档

Install the `yard` and `redcarpet` gems:
安装`yard`和`redcarpet`软件包：

```bash
$ gem install yard redcarpet
```

Uninstall the `rdiscount` gem, if installed:
卸载`rdiscount`软件包

```bash
$ gem uninstall rdiscount
```

Generate the documentation from topmost directory:
从 topmost 目录生成文档：

```bash
$ yardoc -o docs */lib/**/*.rb - README.md
```


## Tutorials and Articles  指南和作品

* [Using Sunspot, Websolr, and Solr on Heroku](http://mrdanadams.com/2012/sunspot-websolr-solr-heroku/) (mrdanadams)
* [Full Text Searching with Solr and Sunspot](http://collectiveidea.com/blog/archives/2011/03/08/full-text-searching-with-solr-and-sunspot/) (Collective Idea)
* [Full-text search in Rails with Sunspot](http://tech.favoritemedium.com/2010/01/full-text-search-in-rails-with-sunspot.html) (Tropical Software Observations)
* [Sunspot Full-text Search for Rails/Ruby](http://therailworld.com/posts/23-Sunspot-Full-text-Search-for-Rails-Ruby) (The Rail World)
* [A Few Sunspot Tips](http://blog.trydionel.com/2009/11/19/a-few-sunspot-tips/) (spiral_code)
* [Sunspot: A Solr-Powered Search Engine for Ruby](http://www.linux-mag.com/id/7341) (Linux Magazine)
* [Sunspot Showed Me the Light](http://bennyfreshness.com/2010/05/sunspot-helped-me-see-the-light/) (ben koonse)
* [RubyGems.org — A case study in upgrading to full-text search](http://blog.websolr.com/post/3505903537/rubygems-search-upgrade-1) (Websolr)
* [How to Implement Spatial Search with Sunspot and Solr](http://web.archive.org/web/20120708071427/http://codequest.eu/articles/how-to-implement-spatial-search-with-sunspot-and-solr) (Code Quest)
* [Sunspot 1.2 with Spatial Solr Plugin 2.0](http://joelmats.wordpress.com/2011/02/23/getting-sunspot-1-2-with-spatial-solr-plugin-2-0-to-work/) (joelmats)
* [rails3 + heroku + sunspot : madness](http://web.archive.org/web/20100727041141/http://anhaminha.tumblr.com/post/632682537/rails3-heroku-sunspot-madness) (anhaminha)
* [heroku + websolr + sunspot](https://devcenter.heroku.com/articles/websolr) (Onemorecloud)
* [How to get full text search working with Sunspot](http://cookbook.hobocentral.net/recipes/57-how-to-get-full-text-search) (Hobo Cookbook)
* [Full text search with Sunspot in Rails](http://web.archive.org/web/20120311015358/http://hemju.com/2011/01/04/full-text-search-with-sunspot-in-rails/) (hemju)
* [Using Sunspot for Free-Text Search with Redis](http://masonoise.wordpress.com/2010/02/06/using-sunspot-for-free-text-search-with-redis/) (While I Pondered...)
* [Fuzzy searching in SOLR with Sunspot](http://www.pipetodevnull.com/past/2010/8/5/fuzzy_searching_in_solr_with_sunspot/) (pipe :to => /dev/null)
* [Default scope with Sunspot](http://www.cloudspace.com/blog/2010/01/15/default-scope-with-sunspot/) (Cloudspace)
* [Index External Models with Sunspot/Solr](http://www.medihack.org/2011/03/19/index-external-models-with-sunspotsolr/) (Medihack)
* [Testing with Sunspot and Cucumber](http://collectiveidea.com/blog/archives/2011/05/25/testing-with-sunspot-and-cucumber/) (Collective Idea)
* [Cucumber and Sunspot](http://opensoul.org/2010/4/7/cucumber-and-sunspot) (opensoul.org)
* [Testing Sunspot with Cucumber](http://blog.trydionel.com/2010/02/06/testing-sunspot-with-cucumber/) (spiral_code)
* [Running cucumber features with sunspot_rails](http://blog.kabisa.nl/2010/02/03/running-cucumber-features-with-sunspot_rails) (Kabisa Blog)
* [Testing Sunspot with Test::Unit](http://timcowlishaw.co.uk/post/3179661158/testing-sunspot-with-test-unit) (Type Slowly)
* [Sunspot Quickstart](http://wiki.websolr.com/guides/Sunspot-Quick-Start) (WebSolr)
* [Solr, and Sunspot](http://www.kuahyeow.com/2009/08/solr-and-sunspot.html) (YT!)
* [The Saga of the Switch](http://web.archive.org/web/20100427135335/http://mrb.github.com/2010/04/08/the-saga-of-the-switch.html) (mrb -- includes comparison of Sunspot and Ultrasphinx)
* [Conditional Indexing with Sunspot](http://mikepackdev.com/blog_posts/19-conditional-indexing-with-sunspot) (mikepack)
* [Introduction to Full Text Search for Rails Developers](http://valve.github.io/blog/2014/02/22/rails-developer-guide-to-full-text-search-with-solr/) (Valve's)

## License  许可证

Sunspot is distributed under the MIT License, copyright (c) 2008-2013 Mat Brown

# vim: set filetype=markdown : 
